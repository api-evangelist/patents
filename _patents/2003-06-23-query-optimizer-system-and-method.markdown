---
title: Query optimizer system and method
abstract: An optimizer/normalizer is used to generate optimized intermediate language representation of an input query, such as an XML input query. A method of optimization of an input query in intermediate language form includes receiving the input query, examining the nodes in a left-depth first manner to identify code patterns and node types which are subjects for optimization, tagging the identified code patterns until the intermediate language representation of the input query has been examined in its entirety, searching from the top of the intermediate language representation for tagged code patterns, and adjusting the tagged code patterns with improved code patterns to form an optimal representation for an input query. The input to the optimizer/normalizer is assumed to be an input query transformed into an intermediate language representation containing code patterns and nodes, each node having a respective node type.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07146352&OS=07146352&RS=07146352
owner: Microsoft Corporation
number: 07146352
owner_city: Redmond
owner_country: US
publication_date: 20030623
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Appendix I"],"p":["The invention relates generally to the field of optimization of software queries, and more particularly to optimizations for XML query languages and view definition languages.","Language optimization is a goal of every programmer. Efficient code runs quicker, consumes less computer resources and is more compact. These attributes are attractive to consumers of code that desire good performance of their computer hardware and software. The goal of code optimization is desirable of most applications, including query language applications where the code may be used to query over large databases such as relational databases. The problem becomes more acute when a system for query execution takes on the task of querying over multiple databases using multiple languages. In this scenario, efficient code generation benefits the query by returning query results both more quickly and more consistently than non-optimized code. One example of an optimization need is in a system where XML-related language queries, such as XSLT, XQuery and XPath or view definition languages, may be input into a system for the execution of queries over a SQL database. In such a system the role of an optimizer is to improve execution code efficiency.","XML queries pose at least four barriers to normalization and optimization; node identity, ordering, side-effects and construction. A common technique in database and functional programming optimization is to eliminate variables by performing substitution. However, great care must be exercised when performing a substitution as even a simple substitution may not work well.","One problem is that many XML query languages explicitly or implicitly depend on node identity. Consider, for example, the XQuery:\n\n","Another complication in normalization and optimization is that XML is ordered. It is desirable that this ordering be stable across document instances. Consider the following example of a code-motion technique. This example involves pushing expressions inside a loop or pulling them out of a loop when they are independent of the loop.","Given the query:",{"@attributes":{"id":"p-0007","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["for $i in $e1","where $condition1","return","for $j in $e2","where $condition2","return $k\n\nA typical rewrite may result in:\n","for $i in $e1","for $j in $e2","where $condition1","and $condition2","return $k\n\nThe effect of this rewrite is adverse upon the ordering and position of the results. Although this rewrite seems correct at first glance, the inner condition may refer to the position within that loop, which the rewrite has altered. Any optimization that would cause an expression to have a different order should only be applied when the position need not be preserved. Otherwise, erroneous rewrites occur.\n"]}}}},"A common technique in programming language optimization is to eliminate temporary expressions when their results are not needed. However, elimination of even temporary XML query language expressions may not be completely side-effect free. Some expressions may terminate evaluation with an error, such as XQuery's error( ) function. Others may send a message to output, such as XSLT's <xsl:message\/> operator. Some temporary expressions can be eliminated only if the query language semantics allow it. As two examples, consider the XQuery error( ) and false( ), and the XSLT path expression:\n\n","Another complication is that faulty construction of XML may have undesirable side-effects. XML construction normally implies copying its contents and this alteration to node identity should be preserved through rewrites and execution. Consider the XQuery:\n\n","Thus it would be advantageous for an XML optimizer to avoid false substitutions, to avoid rewrites that alter the order of rewritten expressions when order is important in an optimized XML expression, to avoid side-effects from temporary expression elimination and multiple language use and to avoid construction problems. The invention addresses the aforementioned needs and solves them with various systems, methods and techniques that also offer other advantages for optimizing queries.","The invention is directed to an optimizer\/normalizer, and related techniques, which generate optimized intermediate language representation of an input query, such as an XML input query. The invention may be utilized as either a stand alone optimizer or as part of a larger system involving an XML query runtime system, for example.","The invention includes a first exemplary method for constructing an optimal representation for an input query by receiving the input query, examining the nodes in a left-depth first manner to identify code patterns and node types which are subjects for optimization, tagging the identified code patterns until the intermediate language representation of the input query has been examined in its entirety, searching from the top of the intermediate language representation for tagged code patterns, and adjusting the tagged code patterns with improved code patterns to form an optimal representation for an input query. The input to the optimizer\/normalizer is assumed to be an input query transformed into an intermediate language representation containing code patterns and nodes, each node having a respective node type.","A second exemplary method for constructing an optimal representation for an input query includes receiving the input query, examining the nodes to inspect code patterns associated with respective node types, comparing the inspected code patterns using a pattern match algorithm to detect non-optimized code patterns, and adjusting one or more of the non-optimized code patterns and the inspected code patterns with improved code patterns to form an optimal representation for an input query. Once again, the input query is an intermediate language representation containing nodes, each node having a respective node type.","The invention may be embodied in an exemplary system which includes an XML-centric runtime query processing methodology. The methodology involves taking multiple XML queries and translating them into an intermediate language representation, performing optimization, and then compiling the queries back into a form compatible with the data source format.","Optimizer\/Normalizer Overview","An exemplary query optimizer\/normalizer improves query efficiency by eliminating redundant forms and improving query execution speed. An exemplary normalizer function eliminates redundant forms and therefore simplifies back-end compiler implementations by reducing the number of kinds of queries the back ends have to be prepared to process. Better system performance is thereby achieved. The optimizer\/normalizer may be designed to be used as a standalone component or as part of a larger system.","The problem of false substitution in optimization is avoided by not performing substitution or other rewrites that are incorrect in the face of node identity. This is performed by utilizing a node oriented intermediate language representation of a query as an input. Thus node characteristics may be analyzed as part of the optimization process. A rewrite of a portion of the intermediate language representation of an input query is preferably performed only when re-ordering will have no effect on any subexpressions in the intermediate representation. The order of an expression is desirably unaffected by clearly identifying order sensitive expressions via the use of an unambiguous intermediate language representation of an input query. Overall, optimization errors and related complications may be avoided through a combination of optimization barriers, explicit operators and careful attention to well-authored rewrite rules.","The invention may be implemented in one or more of a set of hardware elements and software elements in a computer system. As such, an exemplary computer system which may include the invention is described hereinbelow.","Exemplary Computing Device",{"@attributes":{"id":"p-0025","num":"0042"},"figref":"FIG. 1"},"Although not required, the invention can be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software that operates according to the invention. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, appliances, lights, environmental control elements, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network\/bus or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices, and client nodes may in turn behave as server nodes.",{"@attributes":{"id":"p-0027","num":"0044"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer system . Components of computer system  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer system  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, Random Access Memory (RAM), Read Only Memory (ROM), Electrically Erasable Programmable Read Only Memory (EEPROM), flash memory or other memory technology, Compact Disk Read Only Memory (CDROM), compact disc-rewritable (CDRW), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer system , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer system  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM, CDRW, DVD, or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer system . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer system  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory (not shown). In addition to monitor , computer systems may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer system  may operate in a networked or distributed environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer system , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer system  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer system  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer system , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web-enabled interface for applications and computing devices, making computing activities increasingly Web browser or network-oriented.","For example, MICROSOFT\u00ae's .NET\u2122 platform, available from Microsoft Corporation, One Microsoft Way, Redmond, Wash. 98052, includes servers, building-block services, such as Web-based data storage, and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device, one or more portions of the invention may also be implemented via an operating system, application programming interface (API) or a \u201cmiddle man\u201d object between any of a coprocessor, a display device and a requesting object, such that operation according to the invention may be performed by, supported in or accessed via all of .NET\u2122's languages and services, and in other distributed computing frameworks as well.","Optimization Discussion and Exemplary Embodiments of the Invention","Two main sources of inefficiency in XML queries are buffering and type conversions. Buffering occurs when an operator cannot be streamed, and instead some data much be cached in memory and then traversed one or more times in order to evaluate the operator. When this occurs, pipeline processing may halt and memory allocations and multiple passes may occur. Turning queries that operate over data twice into queries that operate over it only once is therefore a desired optimization.","Buffering is mostly an aspect of the physical query plan, tightly coupled to how the query is implemented. However, there are patterns in the logical query plan that can be detected and rewritten. For example, the query sum($x)div count($x) may be equivalent to avg($x). The former expression requires evaluating $x twice, while the latter can perform its computation in a single pass.","In XML, type conversions generally involve going from a string representation to a machine type (like integer) or vice-versa. Relational databases traditionally do not optimize such queries well, because they are relatively uncommon in the relational domain where data is already stored as machine types. In the implementation of XML queries, it may be considered desirable to remove as many type conversions and type tests as possible, especially over relational data, but even for ordinary XML data.","For example, the query Customer[@CustomerID=\u2018ALFKI\u2019] implicitly may demand converting the CustomerID node to string. If this node is already typed as xs:string, then no conversion is required, although the string value of the node may still be retrieved. If the node is mapped to a column that has a SQL type such as nvarchar, then no conversion from relational data to XML data is needed either. Eliminating these two type conversions causes the SQL query plan to go from an index scan to an index seek, assuming CustomerID is indexed. This plan may reach upwards to a 10\u00d7 performance improvement.","These optimizations are generally physical in nature. Although unnecessary SQL\/XML conversions may be eliminated, there are some optimizations that are already possible in the logical query plan. One approach may be to eliminate type conversions and type tests by refining types during the optimization process. The more precisely static type information is known and understood concerning a query, the more operators may be statically eliminated.","An embodiment of the invention utilizes an intermediate language representation having a graph structure composed of nodes identifying functional operations in a query. As such, it represents the semantic meaning of a query. This intermediate language is a query intermediate language and is termed QIL. An example query intermediate language definition is provided in a co-filed patent application entitled QUERY INTERMEDIATE LANGUAGE METHOD AND SYSTEM assigned to Microsoft Corporation of Redmond, WA (Ser. No. 10\/601,444, filed on Jun. 23, 2003). The contents of that co-filed application are considered to be incorporated in its entirety by reference into this application.","Pattern detection is used to identify candidates for normalization and optimization. The patterns developed by such an intermediate language are not of an arbitrary complexity. Generally, the patterns are mostly shallow patterns and are rooted at a particular node type and all back-edges are constrained to occur in known locations. Consequently, a pattern match algorithm can easily accommodate this representation.","The XML intermediate language termed QIL is a representation of an XML query or view. The query intermediate language is an explicit representation of the meaning of an XML query. The query intermediate language may be viewed as a semantic representation common across all XML query and view language compilers. QIL is similar to an ordinary abstract syntax tree (AST) but different in that QIL captures not the syntax of the language but the semantics, or meaning, of a query. Another difference is that QIL is a graph structure and not a tree structure like AST.","QIL enables the abstraction of multiple different XML query languages and view definition languages (such as XPath, XSLT, and XQuery) over a variety of different target data sources (such as relational and non-relational data). As such, QIL enables a common construction to support all of the compatible XML languages. Every operation is both explicit and unambiguous.","The patterns that are generated by QIL and detected by the optimizer are grouped by root node type and then used to generate a subclass for pattern identification and optimization implementation. These subclasses perform a left-depth first (i.e., bottom-up) pass over the QIL graph, attempting to match each pattern in turn for a given node type. If no pattern matches, it copies the node (and its entire subgraph, which has already been visited); otherwise, it performs the indicated optimization replacement. This approach has worst-case complexity O(gn) where g is the number of patterns in the grammar and n is the number of nodes in the graph. The optimizer views each node and all descendants to match each pattern, although in practice, patterns tend to be only a single level deep so its average time is more accurately approximated as O(gn).",{"@attributes":{"id":"p-0047","num":"0064"},"figref":["FIG. 2","FIG. 1"],"b":["200","210"]},"Returning to , the front-end compilers  may receive an XML query, XML view, or other related XML language inquiries via an input device (not shown in ) and produce a compiled XML intermediate language representation  of the meaning of the composite of the input queries. Typical language types for the front-end compilers  include the world wide web consortium (W3C\u00ae) published standards of XPath, XML Stylesheet Language (XSL), XSLT and XML Query Language (XQuery). An XML view compiler may also be present and include the W3C\u00ae XML standard view of XQuery, among others. The intermediate language abstraction between query and view languages and multiple target models allows real XML data, such as from the Microsoft\u00ae .NET\u2122 as well as virtual XML data, to be used as data sources.","The XML intermediate language representation  is input to a query optimizer\/normalizer . The function of the optimizer is to improve query performance and eliminate redundant forms within the input intermediate language representation. The optimizer serves to increase system performance by implementing numerous algorithms that reduce the size and decrease the complexity of the XML intermediate language representation prior to the delivery of the optimized XML query representation to the back-end target generators .","There may be a plurality of back-end target generators  to support a multiplicity of related target query language execution engines . Each of the back-end target generators  may be constructed so that they efficiently work on data sources comporting with the model of the data within each supported data source. For example, a target query language generator for a SQL database source may be optimized for efficiency in querying over a relational database with a SQL database management system. Thus, for example, target query language generator may also be paired with an execution engine to transform the intermediate language representation  into a target machine language compatible with a specific data source . Optionally, a target generator may also transform an XML intermediate language representation  into another intermediate language, such as for example Microsoft\u00ae intermediate language (MSIL), so that an execution engine may directly query one or more data sources .","Upon execution of the compiled query, the execution engine normally produces query results  available for further processing, storage, display to a user, or provision to a subsequent software application, for example. The target compilers  and corresponding execution engines  may include such query languages as XML and SQL, to name a few.","Another aspect of the architecture is the modularity of data availability. For example, at the point where the optimized XML query representation is generated (e.g., inputs to target generators ), an output may be generated so that the optimized XML query intermediate language representation itself is available for use in another system or available for delayed target compiling. Also, the optimized XML query representation itself may be directly executed without actually converting first to a specific, non-XML instruction query. Thus, the XML intermediate language may be used to query over one or more data sources without a compiler using an execution engine specifically adapted to execute the optimized XML query intermediate language representation. As another option in system output, the target compiler output(s) may be used as an output for execution in a separate system or by another non-system application.","It should be noted that the exemplary architecture of  inherently allows great flexibility in constructing queries. The query architecture allows multiple queries to be input so that an optimized XML intermediate language composite of the multiple queries may be generated. Additionally, multiple back-end target compilers and execution engines may be used appropriately to query over data sources of differing data models. The architecture  also allows a reduction in the number of permutations of front-ends and back ends.  depicts M front end compilers and N back end compilers, where M and N are integers. Normally, this combination would yield a total number of possible system paths of M times N. However, because of the common intermediate language utilization, the number of permutations is advantageously reduced to M plus N.",{"@attributes":{"id":"p-0054","num":"0071"},"figref":"FIG. 3","b":["300","310","300","320","330"]},"If the detected pattern of the node type may be optimized, the code pattern is optimized  by replacement. Alternately, if an unnecessary repetition is detected, a normalization may occur  which may result in the elimination of the repetition. As a result of the normalization or optimization, the portions of changed and unchanged code are collected  and aggregated.","If the detected pattern of the node type may not be optimized  because it does not match with a node type or code pattern, then the code that was examined may be passed on  so that the code can be collected .","Once the code is collected , the process  determines whether the intermediate language representation has been fully examined for normalization\/optimization purposes. If the code has not been fully examined, the next node is examined  and the process of examination and optimization is replicated. If the process  has completed examining the intermediate language representation nodes, then the aggregated code is passed on and an optimized query results .",{"@attributes":{"id":"p-0058","num":"0075"},"figref":["FIG. 4","FIG. 3"],"b":["400","405","400","410","420","400","430"]},"The process  then checks to see if the entire graph has been examined . If the process is not yet complete, then the process  moves upward in the graph  to test the next node and identify potential optimizations .","If the process of checking the entire graph of the intermediate representation has been completed , then the process  moves to the top of the graph and searches for attributes tagged to the nodes . Some of the tagged attributes may be those of normalization, such as repetitious nodes, or of optimizations, such as replacement code. The attributes may indicate the kind of action (i.e., redundancy deletion, optimization replacement, etc.) that is needed. The process  conducts the optimization \/ normalization at the tagged nodes  from the top down at the tagged node locations. At the end of execution of the implementation of the optimization, the entire query may be reconstructed from the node type expressions and the optimized query  results.","It is convenient to establish a notation to describe query rewrites in terms of the underlying intermediate language representation. Rewrites may depend on the node types involved, and occasionally additional conditions, such as conditions on types or values, may be desirable to be satisfied for a rewrite to occur. A syntax that is node-centric but allows for additional conditions to be specified is preferably used in the embodiments of the invention.","As one in the art would recognize, node names may be wrapped in parentheses, as are nodes in the LISP language. A node's children, if any, may follow its name. Thus, (X) describes a single node X while (X Y Z) describes a node X with two child nodes, Y and Z. The order of children is significant. An example of a tree expression, 1+1=2 may be written as:\n\n","In a rewrite, the replacement structure may be written after the match pattern, using the token=> to separate them. The entire rule is also preceded by a name in square brackets; this name may be descriptive. In one embodiment, such rules may be selectively enabled or disabled for flexibility in code optimization. An example rewrite rule may be:\n\n","A code pattern may also allow patterns to match any node kind. This is indicated using the wildcard match (*). Typically, any pattern may be labeled by preceding it with a variable ($variableName) and a colon (:). Then, the variable name may be used instead of a node elsewhere in the match pattern or in the replacement. Labels generally provide the only way to express a back-reference. An example of a graph with back-references and wildcards may be:\n\n","Additional conditions may be expressed with a specific notation. A node pattern may be followed with code enclosed in curly braces. The code may refer to any variables that are in scope. An example graph with code conditions may be:\n\n","An extended Backus-Naur form (EBNF) description of the pattern grammar appears below and presents a pattern grammar.\n\n",{"@attributes":{"id":"p-0067","num":"0103"},"figref":"FIG. 5","b":["510","18","520","515","510","520","525","520"]},"Typically, rewrites such as those in  are not performed all at once, but instead are divided into smaller rewrites each of which manipulates some part of the graph. As depicted in , these smaller rewrites preferably cascade to produce the desired overall effect.",{"@attributes":{"id":"p-0069","num":"0105"},"figref":"FIG. 6","b":["610","615","612"],"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":{"@attributes":{"id":"ul0018-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":["[EliminateParent]","(Parent (For (Content $x:*)))=>$x"]}}}},"A next section of the intermediate code representation  may then be rewritten as an optimization  using the transformation  via the elimination of a tuple depicted by the rule:\n\n","Further processing on the rewritten code  results in a rewrite  using a transformation  via a loop invariant code motion depicted by the rule:\n\n","The resultant rewrite may be inserted into the query code  and may be further rewritten  using the transformation  via a tuple rewrite depicted by the rule:",{"@attributes":{"id":"p-0073","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[EliminateNTimes]"]},{"entry":[{},"(DocOrderDistinct $t:(Tuple***))"]},{"entry":[{},"=> {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QilTuple last = $t.LastTuple;"]},{"entry":[{},"if (last.Return.Type == QilNodeType.NTimes) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QilBinary ntimes = (QilBinary)last.Return;"]},{"entry":[{},"QilList list = f.List( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"list.Type = f.TypeFactory.Sequence(QilCardinal-"]},{"entry":[{},"ity.Zero, ntimes.Type);"]},{"entry":[{},"last.Return = Replace($0.EliminateNTimes, ntimes,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f.Conditional(f.Gt(ntimes.Right, f.Int32(0)),"]},{"entry":[{},"ntimes.Left,list));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The constructs of the resultant code when inserted into the original intermediate representation  may be optimized  further by the transformation  via the logical rewrite depicted by the rule:\n\n",{"@attributes":{"id":"p-0075","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[FoldTupleConditional]"]},{"entry":[{},"(Tuple $i:* $w:* (Conditional $cond:* $return:* $list:(List)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{$list.QilType.IsEmpty }))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"=> (Tuple $i (And $w $cond) $retum)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"When the resultant  is inserted into the original intermediate language query  of , the resultant is the optimization as shown in the optimized intermediate code  of . Thus multiple rewrites may be used in the optimization process of the invention.","Optimization and Normalization Descriptions","Optimizations are typically classified as either local or global optimizations. Local optimizations, such as constant-folding, are performed by looking at a small connected region of the graph. Global optimizations, such as dead code elimination, are performed by looking at the entire graph. Exemplary optimizations performed in accordance with aspects of the invention are summarized below:\n\n","The local normalizations performed can be grouped into several different categories: constant-folding, commutations, path rewrites, common subexpression-elimination, function inlining, and miscellaneous normalizations. Exemplary samples of the optimization rules and techniques are provided in Appendix I attached hereto.","Constant-Folding Optimizations","Constant folding involves eliminating certain compile-time constants. These optimizations reduce the query size, reduce the size of the code that will be generated, and may significantly affect performance in loop situations. Constant-folding patterns constitute the bulk of the patterns performed by the optimizer.","Logical Rewrite Optimizations","Some rewrites are not exactly constant-folding, but reduce the logical complexity of an expression. Others turn irregular forms, such as comparing two Boolean expressions which cannot be transliterated directly into SQL, into regular forms. Such regular forms perform logical operations on Boolean expressions which can be transliterated directly into SQL.","Basic Path Rewrite (Child, Attribute) Optimization","Navigation optimizations may play a role in query performance because XQuery is compositional (i.e., supporting navigation into other XQuery expressions). Paths in an intermediate language such as QIL are not generally represented with a single operator. Consequently, path rewrites may be composed of many smaller rewrites such as constant-folding patterns, such as for example, EliminateNameOf. Additionally, some path rewrites involve folding navigation operators like Content and Attribute with construction operators like ElementCtor and AttributeCtor.","Loop-invariant Code Motion Optimization","Loop-invariant code motion is a common optimization technique in which computations made in a loop that do not change during the loop (i.e., loop-invariant) can be factored out (i.e., code motion). In this way, the computation is performed only once instead of the number of iterations of the loop.","Commutation Optimization","Commutations are a class of rewrites that involve unraveling iterations over collections or iterations over iterations. Such rewrites are generally commutations of the form A B => f(B) g(A); that is, A applied to B is rewritten into B applied to A or B applied to some function of A, or a list of A applied to each member of B in turn. Some commutation patterns may be too complex to express fully using a pattern language. Therefore, these patterns typically may have a match pattern followed by a code action that performs the replacement.","Tuple Rewrites","In QIL, the Tuple and Filter node types (and the legacy Tuple node type) occupy a special role, and so have special rewrites associated with them, that are not classified in any other category.","Position Rewrites","As mentioned hereinabove, preserving position may present a barrier to optimization. Therefore, eliminating the position operators is a very worthwhile optimization. Additionally, the position operator satisfies certain constraints. For example, it is always at least 1 and at most the length of the set. Additionally, certain complex patterns using position may still be rewritten in ways that preserve it.","Benchmarks","Benchmarks notoriously do not represent real-world conditions, although for an optimizer this doesn't matter much; they still represent optimization opportunities.","Sort Elimination\/Grouping","Sort patterns come in two main varieties. One type of sort pattern eliminates unnecessary sorting such as, for example, applying a document order to an expression that is already in document order. Another sort pattern may recognize a grouping pattern which may be implemented by a back-end compiler using multiple passes.","As mentioned above, while exemplary embodiments of the present invention have been described in connection with various computing devices and software architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to implement a code optimizer. Thus, the methods and systems of the present invention may be applied to a variety of applications and devices. While exemplary programming languages, names and examples are chosen herein as representative of various choices, these languages, names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same, similar or equivalent systems and methods achieved by the invention.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the signal processing services of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","The methods and apparatus of the present invention may also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as an EPROM, a gate array, a programmable logic device (PLD), a client computer, a video recorder or the like, or a receiving machine having the signal processing capabilities as described in exemplary embodiments above becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of the present invention. Additionally, any storage techniques used in connection with the present invention may invariably be a combination of hardware and software.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Therefore, the invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims.","The following appended material includes examples of optimizations that may be part of exemplary embodiments in accordance with the invention. The list is exemplary only as more examples are possible within the bounds and spirit of the invention.",{"@attributes":{"id":"p-0093","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Constant Folding Type Optimizations"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constant-folding patterns for Boolean operators:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateAnd]"]},{"entry":[{},"(And (True) $x:*) => $x"]},{"entry":["2.","[EliminateAnd]"]},{"entry":[{},"(And (False) *) => (False)"]},{"entry":["3.","[EliminateAnd]"]},{"entry":[{},"(And $x:* (True)) => $x"]},{"entry":["4.","[EliminateAnd]"]},{"entry":[{},"(And * (False)) => (False)"]},{"entry":["5.","[EliminateOr]"]},{"entry":[{},"(Or (True) *) => (True)"]},{"entry":["6.","[EliminateOr]"]},{"entry":[{},"(Or (False) $x:*) => $x"]},{"entry":["7.","[EliminateOr]"]},{"entry":[{},"(Or * (True)) => (True)"]},{"entry":["8.","[EliminateOr]"]},{"entry":[{},"(Or $x:* (False)) => $x"]},{"entry":["9.","[EliminateNot]"]},{"entry":[{},"(Not (True)) => (False)"]},{"entry":["10.","[EliminateNot]"]},{"entry":[{},"(Not (False)) => (True)"]},{"entry":["11.","[EliminateConditional]"]},{"entry":[{},"(Conditional (True) $x:* *) => $x"]},{"entry":["12.","[EliminateConditional]"]},{"entry":[{},"(Conditional (False) * $x:*) => $x"]},{"entry":["13.","[EliminateConditional]"]},{"entry":[{},"(Conditional $x:* (True) (False)) => $x"]},{"entry":["14.","[EliminateConditional]"]},{"entry":[{},"(Conditional $x:* (False) (True)) => (Not $x)"]},{"entry":["15.","[EliminateConditional]"]},{"entry":[{},"(Conditional * $x:(True) (True)) => $x"]},{"entry":["16.","[EliminateConditional]"]},{"entry":[{},"(Conditional * $x:(False) (False)) => $x"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constant-folding patterns for collection operators:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[FoldLengthList]"]},{"entry":[{},"(Length $x:*) { $x.IsEmpty } => (LiteralInt32 0)"]},{"entry":["2.","[FoldLengthList]"]},{"entry":[{},"(Length $x:*) { $x.IsSingleton } => (LiteralInt32 1)"]},{"entry":["3.","[FoldLengthList]"]},{"entry":[{},"(Length $x:(List)) { IsConstant($x) } => (LiteralInt32 { $x.Length })"]},{"entry":["4.","[FoldLengthRange]"]},{"entry":[{},"(Length (Range $min:* $max:*)) => (Convert (Add (LiteralInt64 1) (Abs (Subtract $max"]},{"entry":[{},"$min))) Int32)"]},{"entry":["5.","[FoldLengthNTimes]"]},{"entry":[{},"(Length (NTimes $x:* $n:*)) => (Multiply (Length $x) $n)"]},{"entry":["6.","[EliminateList]"]},{"entry":[{},"(List $x:*) { $x.Count =\u2009= 1} => { $x[0] }"]},{"entry":["7.","[EliminateRange]"]},{"entry":[{},"(Range (LiteralInt64 $x:*) (LiteralInt64 $y:*)) {$x =\u2009= $y} => $x"]},{"entry":["8.","[EliminateNTimes]"]},{"entry":[{},"(NTimes * (LiteralInt32 0)) => (List)"]},{"entry":["9.","[EliminateNTimes]"]},{"entry":[{},"(NTimes $x:* (LiteralInt32 1)) => $x"]},{"entry":["10.","[EliminateDistinct]"]},{"entry":[{},"(Distinct $x:(List)) => $x"]},{"entry":["11.","[EliminateDistinctByValue]"]},{"entry":[{},"(DistinctByValue (For $x:(List) { $x.QilType.IsEmpty }) *) => $x"]},{"entry":["12.","[EliminateIntersection]"]},{"entry":[{},"(Intersection $x:(List) { $x.QilType.IsEmpty } *) => $x"]},{"entry":["13.","[EliminateIntersection]"]},{"entry":[{},"(Intersection * $x:(List) { $x.QilType.IsEmpty }) => $x"]},{"entry":["14.","[EliminateDifference]"]},{"entry":[{},"(Difference $x:(List) { $x.QilType.IsEmpty } *) => $x"]},{"entry":["15.","[EliminateDifference]"]},{"entry":[{},"(Difference $x:* $y:(List) { $y.QilType.IsEmpty }) => $x"]},{"entry":["16.","[EliminateAverage]"]},{"entry":[{},"(Average $x:(List) { $x.QilType.IsEmpty } ) => { f.Double(Double.NaN) }"]},{"entry":["17.","[EliminateAverage]"]},{"entry":[{},"(Sum $x:(List) { $x.QilType.IsEmpty } ) => (LiteralDouble 0)"]},{"entry":["18.","[EliminateMinimum]"]},{"entry":[{},"(Minimum $x:(List) { $x.QilType.IsEmpty } ) => $x"]},{"entry":["19.","[EliminateMaximum]"]},{"entry":[{},"(Maximum $x:(List) { $x.QilType.IsEmpty } ) => $x"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constant-folding patterns for arithmetic operators:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateNegate]"]},{"entry":[{},"(Negate (LiteralDecimal $x:*)) => (LiteralDecimal { \u2212$x })"]},{"entry":["2.","[EliminateNegate]"]},{"entry":[{},"(Negate (LiteralDouble $x:*)) => (LiteralDouble { \u2212$x })"]},{"entry":["3.","[EliminateNegate]"]},{"entry":[{},"(Negate (LiteralFloat $x:*)) => (LiteralFloat { \u2212$x })"]},{"entry":["4.","[EliminateNegate]"]},{"entry":[{},"(Negate (LiteralInt32 $x:*)) => (LiteralInt32 { \u2212$x })"]},{"entry":["5.","[EliminateNegate]"]},{"entry":[{},"(Negate (LiteralInt64 $x:*)) => (LiteralInt64 { \u2212$x })"]},{"entry":["6.","[EliminateAdd]"]},{"entry":[{},"(Add (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> (LiteralDecimal { $x + $y })"]},{"entry":["7.","[EliminateAdd]"]},{"entry":[{},"(Add (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> (LiteralDouble { $x + $y })"]},{"entry":["8.","[EliminateAdd]"]},{"entry":[{},"(Add (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> (LiteralFloat { $x + $y })"]},{"entry":["9.","[EliminateAdd]"]},{"entry":[{},"(Add (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> (LiteralInt32 { $x + $y })"]},{"entry":["10.","[EliminateAdd]"]},{"entry":[{},"(Add (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> (LiteralInt64 { $x + $y })"]},{"entry":["11.","[EliminateSubtract]"]},{"entry":[{},"(Subtract (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> (LiteralDecimal { $x \u2212 $y })"]},{"entry":["12.","[EliminateSubtract]"]},{"entry":[{},"(Subtract (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> (LiteralDouble { $x \u2212 $y })"]},{"entry":["13.","[EliminateSubtract]"]},{"entry":[{},"(Subtract (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> (LiteralFloat { $x \u2212 $y })"]},{"entry":["14.","[EliminateSubtract]"]},{"entry":[{},"(Subtract (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> (LiteralInt32 { $x \u2212 $y })"]},{"entry":["15.","[EliminateSubtract]"]},{"entry":[{},"(Subtract (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> (LiteralInt64 { $x \u2212 $y })"]},{"entry":["16.","[EliminateMultiply]"]},{"entry":[{},"(Multiply (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> (LiteralDecimal { $x * $y })"]},{"entry":["17.","[EliminateMultiply]"]},{"entry":[{},"(Multiply (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> (LiteralDouble { $x * $y })"]},{"entry":["18.","[EliminateMultiply]"]},{"entry":[{},"(Multiply (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> (LiteralFloat { $x * $y })"]},{"entry":["19.","[EliminateMultiply]"]},{"entry":[{},"(Multiply (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> (LiteralInt32 { $x * $y })"]},{"entry":["20.","[EliminateMultiply]"]},{"entry":[{},"(Multiply (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> (LiteralInt64 { $x * $y })"]},{"entry":["21.","[EliminateDivide]"]},{"entry":[{},"(Divide (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> { Divide($x, $y) }"]},{"entry":["22.","[EliminateDivide]"]},{"entry":[{},"(Divide (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> { Divide($x, $y) }"]},{"entry":["23.","[EliminateDivide]"]},{"entry":[{},"(Divide (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> { Divide($x, $y) }"]},{"entry":["24.","[EliminateDivide]"]},{"entry":[{},"(Divide (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> { Divide($x, $y) }"]},{"entry":["25.","[EliminateDivide]"]},{"entry":[{},"(Divide (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> { Divide($x, $y) }"]},{"entry":["26.","[EliminateModulo]"]},{"entry":[{},"(Modulo (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> { Modulo($x, $y) }"]},{"entry":["27.","[EliminateModulo]"]},{"entry":[{},"(Modulo (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> { Modulo($x, $y) }"]},{"entry":["28.","[EliminateModulo]"]},{"entry":[{},"(Modulo (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> { Modulo($x, $y) }"]},{"entry":["29.","[EliminateModulo]"]},{"entry":[{},"(Modulo (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> { Modulo($x, $y) }"]},{"entry":["30.","[EliminateModulo]"]},{"entry":[{},"(Modulo (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> { Modulo($x, $y) }"]},{"entry":["31.","[EliminateIntegerDivide]"]},{"entry":[{},"(IntegerDivide (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> { IntegerDivide($x, $y) }"]},{"entry":["32.","[EliminateIntegerDivide]"]},{"entry":[{},"(IntegerDivide (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> { IntegerDivide($x, $y) }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constant-folding patterns for string operators:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateStrLength]"]},{"entry":[{},"(StrLength (LiteralString $x:*)) => (LiteralInt32 { $x.Length })"]},{"entry":["2.","[EliminateStrConcat]"]},{"entry":[{},"$x:(StrConcat * $z:*)"]},{"entry":[{},"{ $z.Count =\u2009= 1"]},{"entry":[{},"&& $x.Delimiter.Type =\u2009= QilNodeType.LiteralString"]},{"entry":[{},"&& ((QilLiteral)$x.Delimiter).ReadStringValue( ).Length =\u2009= 0"]},{"entry":[{},"&& ((QilNode)$z[0]).QilType.IsSingleton } => { (QilNode)$z[0] }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constant-folding patterns for value comparison operators:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateEq]"]},{"entry":[{},"(Eq $x:(LiteralQName * * *) $y:(LiteralQName * * *))"]},{"entry":[{},"=> (Boolean { $x.Equals($y) })"]},{"entry":["2.","[EliminateEq]"]},{"entry":[{},"(Eq $x:(LiteralString *) $y:(LiteralString *))"]},{"entry":[{},"=> (Boolean { $x.Equals($y) }}"]},{"entry":["3.","[EliminateEq]"]},{"entry":[{},"(Eq (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> (Boolean { $x =\u2009= $y })"]},{"entry":["4.","[EliminateEq]"]},{"entry":[{},"(Eq (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> (Boolean { $x =\u2009= $y })"]},{"entry":["5.","[EliminateEq]"]},{"entry":[{},"(Eq (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> (Boolean { $x =\u2009= $y })"]},{"entry":["6.","[EliminateEq]"]},{"entry":[{},"(Eq (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> (Boolean { $x =\u2009= $y })"]},{"entry":["7.","[EliminateEq]"]},{"entry":[{},"(Eq (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> (Boolean { $x =\u2009= $y })"]},{"entry":["8.","[EliminateNe]"]},{"entry":[{},"(Ne $x:(LiteralQName * * *) $y:(LiteralQName * * *))"]},{"entry":[{},"=> (Boolean { !$x.Equals($y)})"]},{"entry":["9.","[EliminateNe]"]},{"entry":[{},"(Ne $x:(LiteralString *) $y:(LiteralString *))"]},{"entry":[{},"=> (Boolean { !$x.Equals($y) } }"]},{"entry":["10.","[EliminateNe]"]},{"entry":[{},"(Ne (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> (Boolean { $x != $y })"]},{"entry":["11.","[EliminateNe]"]},{"entry":[{},"(Ne (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> (Boolean { $x != $y })"]},{"entry":["12.","[EliminateNe]"]},{"entry":[{},"(Ne (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> (Boolean { $x != $y })"]},{"entry":["13.","[EliminateNe]"]},{"entry":[{},"(Ne (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> (Boolean { $x != $y })"]},{"entry":["14.","[EliminateNe]"]},{"entry":[{},"(Ne (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> (Boolean { $x != $y })"]},{"entry":["15.","[EliminateGt]"]},{"entry":[{},"(Gt (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> (Boolean { $x > $y })"]},{"entry":["16.","[EliminateGt]"]},{"entry":[{},"(Gt (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> (Boolean { $x > $y })"]},{"entry":["17.","[EliminateGt]"]},{"entry":[{},"(Gt (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> (Boolean { $x > $y })"]},{"entry":["18.","[EliminateGt]"]},{"entry":[{},"(Gt (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> (Boolean { $x > $y })"]},{"entry":["19.","[EliminateGt]"]},{"entry":[{},"(Gt (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> (Boolean { $x > $y })"]},{"entry":["20.","[EliminateGe]"]},{"entry":[{},"(Ge (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> (Boolean { $x >= $y })"]},{"entry":["21.","[EliminateGe]"]},{"entry":[{},"(Ge (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> (Boolean { $x >= $y })"]},{"entry":["22.","[EliminateGe]"]},{"entry":[{},"(Ge (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> (Boolean { $x >= $y })"]},{"entry":["23.","[EliminateGe]"]},{"entry":[{},"(Ge (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> (Boolean { $x >= $y })"]},{"entry":["24.","[EliminateGe]"]},{"entry":[{},"(Ge (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> (Boolean { $x >= $y })"]},{"entry":["25.","[EliminateLt]"]},{"entry":[{},"(Lt (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> (Boolean { $x < $y })"]},{"entry":["26.","[EliminateLt]"]},{"entry":[{},"(Lt (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> (Boolean { $x < $y })"]},{"entry":["27.","[EliminateLt]"]},{"entry":[{},"(Lt (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> (Boolean { $x < $y })"]},{"entry":["28.","[EliminateLt]"]},{"entry":[{},"(Lt (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> (Boolean { $x < $y })"]},{"entry":["29.","[EliminateLt]"]},{"entry":[{},"(Lt (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> (Boolean { $x < $y })"]},{"entry":["30.","[EliminateLe]"]},{"entry":[{},"(Le (LiteralDecimal $x:*) (LiteralDecimal $y:*))"]},{"entry":[{},"=> (Boolean { $x <= $y })"]},{"entry":["31.","[EliminateLe]"]},{"entry":[{},"(Le (LiteralDouble $x:*) (LiteralDouble $y:*))"]},{"entry":[{},"=> (Boolean { $x <= $y })"]},{"entry":["32.","[EliminateLe]"]},{"entry":[{},"(Le (LiteralFloat $x:*) (LiteralFloat $y:*))"]},{"entry":[{},"=> (Boolean { $x <= $y })"]},{"entry":["33.","[EliminateLe]"]},{"entry":[{},"(Le (LiteralInt64 $x:*) (LiteralInt64 $y:*))"]},{"entry":[{},"=> (Boolean { $x <= $y })"]},{"entry":["34.","[EliminateLe]"]},{"entry":[{},"(Le (LiteralInt32 $x:*) (LiteralInt32 $y:*))"]},{"entry":[{},"=> (Boolean { $x <= $y })"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constant-folding patterns for XML node properties:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (ElementCtor $name:* *)) => $name"]},{"entry":["2.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (Let (ElementCtor $name:* *))) => $name"]},{"entry":["3.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (For (ElementCtor $name:* *))) => $name"]},{"entry":["4.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (AttributeCtor $name:* *)) => $name"]},{"entry":["5.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (Let (AttributeCtor $name:* *))) => $name"]},{"entry":["6.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (For (AttributeCtor $name:* *))) => $name"]},{"entry":["7.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (CommentCtor *)) =>"]},{"entry":["8.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (Let (CommentCtor *))) =>"]},{"entry":["9.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (For (CommentCtor *))) =>"]},{"entry":["10.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (PICtor * *)) =>"]},{"entry":["11.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (Let (PICtor * *))) =>"]},{"entry":["12.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (For (PICtor * *))) =>"]},{"entry":["13.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (TextCtor *)) =>"]},{"entry":["14.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (Let (TextCtor *))) =>"]},{"entry":["15.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (For (TextCtor *))) =>"]},{"entry":["16.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (DocumentCtor *)) =>"]},{"entry":["17.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (Let (DocumentCtor *))) =>"]},{"entry":["18.","[EliminateNameOf]"]},{"entry":[{},"(NameOf (For (DocumentCtor *))) =>"]},{"entry":["19.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (ElementCtor $name:* *))"]},{"entry":[{},"=> (LiteralString { $name.LocalName })"]},{"entry":["20.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (Let (ElementCtor $name:* *)))"]},{"entry":[{},"=> (LiteralString { $name.LocalName })"]},{"entry":["21.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (For (ElementCtor $name:* *)))"]},{"entry":[{},"=> (LiteralString { $name.LocalName })"]},{"entry":["22.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (AttributeCtor $name:* *))"]},{"entry":[{},"=> (LiteralString { $name.LocalName })"]},{"entry":["23.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (Let (AttributeCtor $name:* *)))"]},{"entry":[{},"=> (LiteralString { $name.LocalName })"]},{"entry":["24.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (For (AttributeCtor $name:* *)))"]},{"entry":[{},"=> (LiteralString { $name.LocalName })"]},{"entry":["25.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (CommentCtor *)) =>"]},{"entry":["26.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (Let (CommentCtor *))) =>"]},{"entry":["27.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (For (CommentCtor *))) =>"]},{"entry":["28.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (PICtor * *)) =>"]},{"entry":["29.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (Let (PICtor * *))) =>"]},{"entry":["30.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (For (PICtor * *))) =>"]},{"entry":["31.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (TextCtor *)) =>"]},{"entry":["32.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (Let (TextCtor *))) =>"]},{"entry":["33.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (For (TextCtor *))) =>"]},{"entry":["34.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (DocumentCtor *)) =>"]},{"entry":["35.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (Let (DocumentCtor *))) =>"]},{"entry":["36.","[EliminateLocalNameOf]"]},{"entry":[{},"(LocalNameOf (For (DocumentCtor *))) =>"]},{"entry":["37.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (ElementCtor $name:* *))"]},{"entry":[{},"=> (LiteralString { $name.NamespaceURI })"]},{"entry":["38.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (Let (ElementCtor $name:* *)))"]},{"entry":[{},"=> (LiteralString { $name.NamespaceURI })"]},{"entry":["39.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (For (ElementCtor $name:* *)))"]},{"entry":[{},"=> (LiteralString { $name.NamespaceURI })"]},{"entry":["40.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (AttributeCtor $name:* *))"]},{"entry":[{},"=> (LiteralString { $name.NamespaceURI })"]},{"entry":["41.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (Let (AttributeCtor $name:* *)))"]},{"entry":[{},"=> (LiteralString { $name.NamespaceURI })"]},{"entry":["42.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (For (AttributeCtor $name:* *)))"]},{"entry":[{},"=> (LiteralString { $name.NamespaceURI })"]},{"entry":["43.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (CommentCtor *)) =>"]},{"entry":["44.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (Let (CommentCtor *))) =>"]},{"entry":["45.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (For (CommentCtor *))) =>"]},{"entry":["46.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (PICtor * *)) =>"]},{"entry":["47.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (Let (PICtor * *))) =>"]},{"entry":["48.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (For (PICtor * *))) =>"]},{"entry":["49.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (TextCtor *)) =>"]},{"entry":["50.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (Let (TextCtor *))) =>"]},{"entry":["51.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (For (TextCtor *))) =>"]},{"entry":["52.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (DocumentCtor *)) =>"]},{"entry":["53.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (Let (DocumentCtor *))) =>"]},{"entry":["54.","[EliminateNamespaceUriOf]"]},{"entry":[{},"(NamespaceUriOf (For (DocumentCtor *))) =>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constant-folding patterns for type operators:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateIsEmpty]"]},{"entry":[{},"(IsEmpty $x:*) { $x.QilType.IsEmpty } => (True)"]},{"entry":["2.","[EliminateIsEmpty]"]},{"entry":[{},"(IsEmpty $x:*) { ($x.QilType.Cardinality & QilCardinality.Zero)=\u2009=0 }"]},{"entry":[{},"=> (False)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constant-folding patterns for XPath operators:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (AttributeCtor $name:* $content:*"]},{"entry":[{},"{ IsConvertibleToString($content) } )) => { ConvertToString($content) }"]},{"entry":["2.","[FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (For (AttributeCtor $name:* $content:*"]},{"entry":[{},"{ IsConvertibleToString($content) } ))) => { ConvertToString($content) }"]},{"entry":["3.","[FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (ElementCtor $name:* (TextCtor $content:*"]},{"entry":[{},"{ IsConvertibleToString($content) } ))) => { ConvertToString($content) }"]},{"entry":["4.","[FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (For (ElementCtor $name:* (TextCtor $content:*"]},{"entry":[{},"{ IsConvertibleToString($content) } )))) => { ConvertToString($content) }"]},{"entry":["5.","[FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (ElementCtor $name:* $content:*"]},{"entry":[{},"{ IsConvertibleToString($content) } )) => { ConvertToString($content) }"]},{"entry":["6.","[FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (For (ElementCtor $name:* $content:*"]},{"entry":[{},"{ IsConvertibleToString($content) } ))) => { ConvertToString($content) }"]},{"entry":["7","[FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (TextCtor $content:*"]},{"entry":[{},"{ IsConvertibleToString($content) } )) => { ConvertToString($content) }"]},{"entry":["8.","[FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (For (TextCtor $content:*"]},{"entry":[{},"{ IsConvertibleToString($content) } ))) => { ConvertToString($content) }"]},{"entry":["9.","[FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (NamespaceDecl * *)) => (LiteralString \u201c\u201d)"]},{"entry":["10.","FoldXPathNodeValueCtor]"]},{"entry":[{},"(XPathNodeValue (For (NamespaceDecl * *))) => (LiteralString \u201c\u201d)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Logical rewrite patterns:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[FoldNotNot]"]},{"entry":[{},"(Not (Not $x:*)) => $x"]},{"entry":["2.","[IntroduceNand]"]},{"entry":[{},"(Not (Or $x:* $y:*)) => (And (Not $x) (Not $y))"]},{"entry":["3.","[FoldNotEq]"]},{"entry":[{},"(Not (Eq $x:* $y:*)) => (Ne $x $y)"]},{"entry":["4.","[FoldNotNe]"]},{"entry":[{},"(Not (Ne $x:* $y:*)) => (Eq $x $y)"]},{"entry":["5.","[FoldNotLt]"]},{"entry":[{},"(Not (Lt $x:* $y:*)) => (Ge $x $y)"]},{"entry":["6.","[FoldNotLe]"]},{"entry":[{},"(Not (Le $x:* $y:*)) => (Gt $x $y)"]},{"entry":["7.","[FoldNotGt]"]},{"entry":[{},"(Not (Gt $x:* $y:*)) => (Le $x $y)"]},{"entry":["8.","[FoldNotGe]"]},{"entry":[{},"(Not (Ge $x:* $y:*)) => (Lt $x $y)"]},{"entry":["9.","[FoldNotIs]"]},{"entry":[{},"(Not (Is $x:* $y:*)) => (IsNot $x:* $y:*)"]},{"entry":["10.","[FoldNotIsNot]"]},{"entry":[{},"(Not (IsNot $x:* $y:*)) => (Is $x $y)"]},{"entry":["11.","[FoldConditionalNot]"]},{"entry":[{},"(Conditional (Not $x:*) $true:* $false:*) => (Conditional $x $false $true)"]},{"entry":["12.","[EliminateConditional]"]},{"entry":[{},"(Conditional (IsEmpty $x:*) $y:(List) { $y.QilType.IsEmpty }"]},{"entry":[{},"$z:* { $z =\u2009= $x }) => $x"]},{"entry":["13.","[FoldBooleanEquality]"]},{"entry":[{},"(Eq (True) $x:*) => $x"]},{"entry":["14.","[FoldBooleanEquality]"]},{"entry":[{},"(Eq (False) $x:*) => (Not $x)"]},{"entry":["15.","[FoldBooleanEquality]"]},{"entry":[{},"(Eq $x:* (True)) => $x"]},{"entry":["16.","[FoldBooleanEquality]"]},{"entry":[{},"(Eq $x:* (False)) => (Not $x)"]},{"entry":["17.","[FoldBooleanEquality]"]},{"entry":[{},"(Eq $x:* $y:*) { $x.QilType.IsBoolean && $y.QilType.IsBoolean }"]},{"entry":[{},"=> (Or (And $x $y) (And (Not $x) (Not $y)))"]},{"entry":["18.","[FoldBooleanInquality]"]},{"entry":[{},"(Ne (True) $x:*) => (Not $x)"]},{"entry":["19.","[FoldBooleanInquality]"]},{"entry":[{},"(Ne (False) $x:*) => $x"]},{"entry":["20.","[FoldBooleanInquality]"]},{"entry":[{},"(Ne $x:* (True)) => (Not $x)"]},{"entry":["21.","[FoldBooleanInquality]"]},{"entry":[{},"(Ne $x:* (False)) => $x"]},{"entry":["22.","[FoldBooleanInquality]"]},{"entry":[{},"(Ne $x:* $y:*) { $x.QilType.IsBoolean && $y.QilType.IsBoolean }"]},{"entry":[{},"=> (Or (And $x (Not $y)) (And (Not $x) $y))"]},{"entry":["23.","[IntroduceExists]"]},{"entry":[{},"(Gt (Length $x:*) (LiteralInt32 0)) => (Not (IsEmpty $x))"]},{"entry":["24.","[IntroduceExists]"]},{"entry":[{},"(Ne (Length $x:*) (LiteralInt32 0)) => (Not (IsEmpty $x))"]},{"entry":["25.","[IntroduceIsEmpty]"]},{"entry":[{},"(Eq (Length $x:*) (LiteralInt32 0)) => (IsEmpty $x)"]},{"entry":["26.","[IntroduceIsEmpty]"]},{"entry":[{},"(Le (Length $x:*) (LiteralInt32 0)) => (IsEmpty $x)"]},{"entry":["27.","[ConstrainLength] #Use the constraint that Length >= 0"]},{"entry":[{},"(Ge (Length $x:*) (LiteralInt32 0)) => (True)"]},{"entry":["28.","[ConstrainLength] #Use the constraint that Length >= 0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(Lt (Length $x:*) (LiteralInt32 0)) => (False)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Basic path rewrite patterns:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","# Should be (Content (DocumentCtor $content:*)) => $content"]},{"entry":[{},"[FoldContentDocumentCtor]"]},{"entry":[{},"$x:(Content (DocumentCtor $content:*))"]},{"entry":[{},"=> (FixupNavigation $x, $content)"]},{"entry":["2.","[FoldContentDocumentCtor]"]},{"entry":[{},"$x:(Content (For (DocumentCtor $content:*)))"]},{"entry":[{},"=> { FixupNavigation($x, $content) }"]},{"entry":["3.","# Should be (Content (ElementCtor $content:*)) => $content"]},{"entry":[{},"[FoldContentElementCtor]"]},{"entry":[{},"$x:(Content (ElementCtor * $content:*))"]},{"entry":[{},"=> { FixupNavigation($x, $content) }"]},{"entry":["4.","[FoldContentElementCtor]"]},{"entry":[{},"$x:(Content (For (ElementCtor * $content:*)))"]},{"entry":[{},"=> { FixupNavigation($x, $content) }"]},{"entry":["5.","[CommuteContentTuple]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(Content (Tuple $for:* $w:* $r:*)) => (Tuple $for $w (Content $r))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["6.","[FoldContentAttributeCtor]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(Content (AttributeCtor * *)) => (List)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["7.","[FoldContentAttributeCtor]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(Content (For (AttributeCtor * *)) => (List)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Other path rewrite patterns:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateParent]"]},{"entry":[{},"(Parent (For (Content $x:*))) => $x"]},{"entry":["2.","[EliminateSelf]"]},{"entry":[{},"(Self $x:*) => $x"]},{"entry":["3.","[EliminateDescendantOrSelf]"]},{"entry":[{},"(DescendantOrSelf (For$x:*) { IsConstructed2($x) }"]},{"entry":[{},"=> { EvaluateDescendantOrSelf($x) }"]},{"entry":["4.","[EliminateXPathDescendant]"]},{"entry":[{},"$d:(XPathDescendant (For $x:*)) { IsConstructed2($x) }"]},{"entry":[{},"=> {"]},{"entry":[{},"QilList list = f.List( );"]},{"entry":[{},"list.QilType = f.TypeFactory.Sequence($d.Type, QilCardinality.Zero);"]},{"entry":[{},"} { EvaluateDescendant($x, list }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Loop invariant rewrite patterns:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateTuple]"]},{"entry":[{},"(Tuple $i:(For $b:*) $w:* $r:*) { $r =\u2009= $i && !DependsOn($w, $i) }"]},{"entry":[{},"=> (Conditional $w $b (List))"]},{"entry":["2.","[EliminateTuple]"]},{"entry":[{},"(Tuple $i:(For $b:*) { $b.QilType.IsSingleton } $w:* $r:*) { !DependsOn($w, $i) &&"]},{"entry":[{},"!DependsOn($r, $i) }"]},{"entry":[{},"=> (Conditional $w $r (List))"]},{"entry":["3.","[EliminateTuple]"]},{"entry":[{},"(Tuple $i:(For $b:*) $w:* $r:*)"]},{"entry":[{},"{ !DependsOn($w, $i) && !DependsOn($r, $i) }"]},{"entry":[{},"=> (Conditional $w (NTimes $r (Length $b)) (List))"]},{"entry":["4.","[IntroduceNTimes]"]},{"entry":[{},"(Tuple $i:* $w:* $r:*) { !DependsOn($r, $i) }"]},{"entry":[{},"=> (NTimes $r (Length (Tuple $i $w $i)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Tuple rewrite patterns:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[FoldTupleTuple]"]},{"entry":[{},"(Tuple $f:(For *){$f.Binding.QilType.IsSingleton}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$x:* { !DependsOn($x, $f) }"]},{"entry":[{},"$t:(Tuple $g:(For *){ ((QilIterator)$g).Binding =\u2009= $f }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$w:*"]},{"entry":[{},"$r:*){ !DependsOn($w, $f) && !DependsOn($r, $f) })"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"=> {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$g.Binding = $f.Binding;"]},{"entry":[{},"((QilTuple)$t).Where = f.And($x, $w);"]},{"entry":[{},"}"]},{"entry":[{},"$t"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["2.","[MiscCollapseTuple]"]},{"entry":[{},"(Tuple $i:* $w:* (Tuple $j:(Let $binding:*) $x:* $k:*)"]},{"entry":[{},"{ $j =\u2009= $k }) => (Tuple $i (And $w $x) $binding)"]},{"entry":["3.","[FoldTupleConditional]"]},{"entry":[{},"(Tuple $i:* $w:* (Conditional $cond:* $return:* $list:(List)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ $list.QilType.IsEmpty }))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"=> (Tuple $i (And $w $cond) $return)"]},{"entry":["4.","[FoldTupleConditional]"]},{"entry":[{},"(Tuple $i:* $w:* (Conditional $cond:* $list:(List)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ $list.QilType.IsEmpty } $return:*))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"=> (Tuple $i (And $w (Not $cond)) $return)"]},{"entry":["5.","[EliminateReturn]"]},{"entry":[{},"$x:(IsEmpty $t:(Tuple * * *))"]},{"entry":[{},"=> {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QilTuple t = (QilTuple)$t;"]},{"entry":[{},"while (t.For.Type != QilNodeType.Let"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"&& t.Return.Type =\u2009= QilNodeType.Tuple)"]},{"entry":[{},"t = (QilTuple)t.Return;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (t.For.Type != QilNodeType.Let &&"]},{"entry":[{},"\u2002!(t.Return is QilIterator) && t.Return.QilType.IsSingleton) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.Return = t.For;"]},{"entry":[{},"return Replace($0.EliminateReturn, $x, f.IsEmpty($t), true);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2002}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":["6.","[IntroduceList]"]},{"entry":[{},"(Tuple * (False) *) => (List)"]},{"entry":["7.","[IntroduceList]"]},{"entry":[{},"(Tuple * * $list:(List) { $list.QilType.IsEmpty } )=> $list"]},{"entry":["8.","[IntroduceList]"]},{"entry":[{},"(Tuple (For $list:(List) { $list.QilType.IsEmpty } ) * *)=> $list"]},{"entry":["9.","[EliminateTuple]"]},{"entry":[{},"(Tuple $i:(For $x:*) (True) $j:*) { $i =\u2009= $j } => $x"]},{"entry":["10.","[EliminateTuple]"]},{"entry":[{},"(Tuple $i:(Let $x:*) (True) $j:*) { $i =\u2009= $j } => $x"]},{"entry":["11.","[EliminateNTimes]"]},{"entry":[{},"(DocOrderDistinct $t:(Tuple * * *))"]},{"entry":[{},"=> {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QilTuple last = $t.LastTuple;"]},{"entry":[{},"if (last.Return.Type =\u2009= QilNodeType.NTimes) {"]},{"entry":[{},"QilBinary ntimes = (QilBinary)last.Return;"]},{"entry":[{},"QilList list = f.List( );"]},{"entry":[{},"list.Type = f.TypeFactory.Sequence(QilCardinality.Zero, ntimes.Type);"]},{"entry":[{},"last.Return = Replace($0.EliminateNTimes, ntimes,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"f.Conditional(f.Gt(ntimes.Right, f.Int32(0)), ntimes.Left, list));"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Position rewrite Patterns:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminatePositionOf]"]},{"entry":[{},"(PositionOf (Let *)) => (LiteralInt32 1)"]},{"entry":["2.","[EliminatePositionOf]"]},{"entry":[{},"(PositionOf (For $x:*) { $x.QilType.IsSingleton } ) => (LiteralInt32 1)"]},{"entry":["3.","[ConstrainPositionOf]"]},{"entry":[{},"(Ge (PositionOf *) (LiteralInt32 1)) => (True)"]},{"entry":["4.","[ConstrainPositionOf]"]},{"entry":[{},"(Lt (PositionOf *) (LiteralInt32 1)) => (False)"]},{"entry":["5.","[ConstrainPositionOf]"]},{"entry":[{},"(Gt $p: (PositionOf *) $one:(LiteraInt32 1)) => (Ne $p $one)"]},{"entry":["6.","[ConstraintPositionOf]"]},{"entry":[{},"(Le $p:(PositionOf *) $one:(LiteralInt32 1)) => (Eq $p $one)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Commutation patterns"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[CommuteIsEmptyList]"]},{"entry":[{},"$x:(IsEmpty $list:(List *)) => {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QilNode result = f.True( );"]},{"entry":[{},"foreach (QilNode member in ((QilList)$list)) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (member.QilType.IsEmpty) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ contributes nothing"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else if ((member.QilType.Cardinality & QilCardinality.Zero) =\u2009= 0) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ whole List is non-empty"]},{"entry":[{},"return Replace($0.CommuteIsEmptyList, $x, f.False( ));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"result = f.And(result, f.IsEmpty(member));"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"return Replace($0.CommuteIsEmptyList, $x, result, true);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":["2.","[CommuteXPathNodeValueList]"]},{"entry":[{},"$x:(XPathNodeValue $members:(List *)) => {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"bool fSuccess = true;"]},{"entry":[{},"QilStrConcat result = f.StrConcat( );"]},{"entry":[{},"foreach (QilNode member in ((QilList)$members)) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (!IsConvertibleToString(member)) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"fSuccess = false;"]},{"entry":[{},"break;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"result. Add(ConvertToString(member));"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (fSuccess)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return Replace($0.CommuteXPathNodeValueList, $x, result, true);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":["3.","[CommuteIsEmptyTuple]"]},{"entry":[{},"(IsEmpty (Tuple * (False) *)) => (True)"]},{"entry":["4.","[CommuteSetIsEmptyTuple]"]},{"entry":[{},"(IsEmpty (Tuple $i:* $w:* $r:*))"]},{"entry":[{},"{ !DependsOn($w, $i) && !DependsOn($r, $i) }"]},{"entry":[{},"=> (Or (Not $w) (IsEmpty $r))"]},{"entry":["5.","[CommuteIsEmptyConditional]"]},{"entry":[{},"(IsEmpty (Conditional $cond:* $true:* $false:*))"]},{"entry":[{},"=> (Conditional $cond (IsEmpty $true) (IsEmpty $false))"]},{"entry":["6.","[CommuteTupleTuple]"]},{"entry":[{},"$outer:(Tuple"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$ai:(For $inner:(Tuple $bi:* $bw:* $br:*)) $aw:* $ar:*)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"=> {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ (Tuple $$bi $$bw (Tuple (For $$br) $$aw $$ar))"]},{"entry":[{},"\/\/ Avoid having to push substitutions:"]},{"entry":[{},"$ai.Binding = $br;"]},{"entry":[{},"((QilTuple)$inner).Return = f.Tuple($ai, $aw, $ar);"]},{"entry":[{},"return Replace($0.CommuteTupleTuple, $outer, $inner, true);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":["7.","[CommuteTupleList]"]},{"entry":[{},"$t:(Tuple $i:(For $list:(List *)) $w:* $r:*) => {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QilList result = f.List( );"]},{"entry":[{},"foreach (QilNode member in ((QilList)$list)) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QilIterator j = f.For(member);"]},{"entry":[{},"PushSubstitution($i, j);"]},{"entry":[{},"result.Add(f.Tuple(j, Clone($w), Clone($r)));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"return Replace($0.CommuteTupleList, $t, result, true);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":["8.","[CommuteTupleConditional]"]},{"entry":[{},"$t:(Tuple $i:(For (Conditional $cond:* $true:*"]},{"entry":[{},"list:(List) {$list.QilType.IsEmpty})) $w:* $r:*) => {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ (Tuple (For $$true) (And $$w $$cond) $$r)"]},{"entry":[{},"\/\/ avoid having to push substitutions"]},{"entry":[{},"$i.Binding = $true;"]},{"entry":[{},"return Replace($0.CommuteTupleConditional, $t,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"f.Tuple($i, f.And($w, $cond), $r), true);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":["9.","[CommuteTupleConditional]"]},{"entry":[{},"$t:(Tuple $i:(For (Conditional $cond:*"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$list:(List){$list.QilType.IsEmpty} $false:*)) $w:* $r:*)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"=> {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ (Tuple (For $$false) (And $$w (Not $$cond)) $$r)"]},{"entry":[{},"\/\/ avoid having to push substitutions"]},{"entry":[{},"$i.Binding = $false;"]},{"entry":[{},"return Replace($0.CommuteTupleConditional, $t,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"f.Tuple($i, f.And($w, f.Not($cond)), $r), true);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":["10.","[CommuteDocOrderDistinctConditional]"]},{"entry":[{},"(DocOrderDistinct (Conditional $cond:* $true:* $false:*))"]},{"entry":[{},"=> (Conditional $cond (DocOrderDistinct $true) (DocOrderDistinct $false))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Type folding patterns:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateIsType]"]},{"entry":[{},"(IsType $x:* $t:*) { TypesMatch($x.QilType, $t) } => (True)"]},{"entry":["2.","[EliminateIsType]"]},{"entry":[{},"(IsType $x:* $t:*) { TypesDontMatch($x.QilType, $t) } => (False)"]},{"entry":["3.","[EliminateConvert]"]},{"entry":[{},"(Convert $x:* $t:*) { $x.QilType =\u2009= $t } => $x"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Sort elimination\/grouping patterns:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","[EliminateDocOrderDistinct]"]},{"entry":[{},"(DocOrderDistinct $x:*) { IsConstructed($x) } => $x"]},{"entry":["2.","[EliminateDocOrderDistinct]"]},{"entry":[{},"(DocOrderDistinct $t:(OldTuple * * *))"]},{"entry":[{},"{ IsConstructed($t.LastTuple.Return) } => $t"]},{"entry":["3.","[EliminateDocOrderDistinct]"]},{"entry":[{},"(DocOrderDistinct $x:(List)) { $x.QilType.IsEmpty }) => $x"]},{"entry":["4.","[EliminateSort]"]},{"entry":[{},"(Sort (For $x:(List) { $x.QilType.IsEmpty }) *) => $x"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0016","num":"0033"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0034"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0035"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0036"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0037"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0038"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
