---
title: Media compression for tunneled real-time communications
abstract: A system performs compression of real-time communications (“RTC”). The system establishes a tunnel with a user equipment (“UE”) by a tunneling server, and communicates encapsulated media with the UE over the tunnel. Subsequently, the system receives a request from a tunneling client at the UE to enable compression for the encapsulated media, determines a codec for transcoding the encapsulated media at the tunneling client and at the tunneling server, and sends a response back to the UE to indicate that compression is enabled for the encapsulated media. The system then communicates compressed encapsulated media with the UE over the tunnel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09332049&OS=09332049&RS=09332049
owner: Oracle International Corporation
number: 09332049
owner_city: Redwood Shores
owner_country: US
publication_date: 20150428
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND INFORMATION","SUMMARY","DETAILED DESCRIPTION"],"p":["One embodiment is directed generally to a communications network, and in particular, to delivering real-time traffic over a communications network.","Many enterprise environments have replaced their Public Switched Telephone Network (\u201cPSTN\u201d) telephony services with telephony services that use the Internet Protocol (\u201cIP\u201d), commonly known as Voice over IP (\u201cVoIP\u201d) or IP Telephony. Since IP Telephony uses an IP network as its backbone, it can provide advanced features such as video conferencing, call recording, and call forwarding.","Recently, the growing base of mobile data subscribers, the wide availability of Internet access, and the high availability of bandwidth in both fixed and mobile networks has resulted in the popularity of advanced services accessed via the Internet (known as Over-the-Top (\u201cOTT\u201d) services). This has caused competitive service providers to offer OTT services and hence face corresponding challenges as they implement these new services.","Embodiments provide a system for performing compression of real-time communications (\u201cRTC\u201d). The system establishes a tunnel with a user equipment (\u201cUE\u201d) by a tunneling server, and communicates encapsulated media with the UE over the tunnel. Subsequently, the system receives a request from a tunneling client at the UE to enable compression for the encapsulated media, determines a codec for transcoding the encapsulated media at the tunneling client and at the tunneling server, and sends a response back to the UE to indicate that compression is enabled for the encapsulated media. The system then communicates compressed encapsulated media with the UE over the tunnel.","One embodiment provides media compression services for real-time communications (\u201cRTC\u201d) in a network environment. In one embodiment, a tunneling client inspects packet formats of encapsulated traffic within a tunnel to determine whether the encapsulated traffic includes data or real-time media. If real-time media traffic is detected in the encapsulated traffic, the tunneling client transcodes the packets such that the encapsulated media traffic occupies a smaller bandwidth. Accordingly, embodiments use the tunnel bandwidth more efficiently and thereby improve the tunnel throughput.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":["100","100","102","114","122","102"]},"In performing RTC, UE  communicates signaling and media traffic with respective servers  in service provider network . Signaling traffic may be communicated according to an application layer protocol such as the Session Initiation Protocol (\u201cSIP\u201d). SIP is configured to be independent of the underlying transport layer. Accordingly, SIP can run on different transport protocols, such as the Transmission Control Protocol (\u201cTCP\u201d as described in, for example, Internet Engineering Task Force (\u201cIETF\u201d) request for comments (\u201cRFC\u201d) 793 and RFC 675), the User Datagram Protocol (\u201cUDP\u201d as described in, for example, IETF RFC 768), etc.","Network  further includes a tunneling server  that, together with a tunneling client  within UE , provides functionality for establishing and managing tunnels for performing RTC according to the Tunneled Services Control Function (\u201cTSCF\u201d) standard as described in, for example, 3rd generation partnership program (\u201c3GPP\u201d) technical report (\u201cTR\u201d) 33.830 V0.5.0, the disclosure of which is hereby incorporated by reference in its entirety. In general, using a tunnel for communications refers to using a delivery protocol to encapsulate a different payload protocol.","The TSCF standard provides client side and server side network elements for establishing managed tunnels for performing RTC (e.g., tunneling client  and tunneling server  in ). It also provides two types of outer layer tunneling transports: a stream-based outer layer tunneling transport via TCP or Transport Layer Security (\u201cTLS\u201d), and a datagram-based outer layer tunneling transport via UDP or Datagram Transport Layer Security (\u201cDTLS\u201d).","TLS is a cryptographic protocol as provided in, for example, IETF RFC 2246, RFC 4346, RFC 5246, and\/or RFC 6176. DTLS is a protocol that provides communications privacy for datagram protocols. TCP and TLS provide reliable, ordered and error-checked delivery of the inner layer traffic, but introduce undesirable latency that is detrimental to RTC applications over a communications network that experiences impairments. On the other hand, UDP and DTLS do not guarantee reliable delivery, thus minimizing latency and being desirable for RTC.","In some embodiments, IP network  may include security devices (e.g., firewalls, proxies, etc.) that allow traffic of only a certain transport protocol (e.g., only TCP, only UDP, etc.). Accordingly, tunneling client  and tunneling server  may establish and manage a corresponding TSCF tunnel so that UE  may use the TSCF tunnel to traverse such security devices and connect to tunneling server  to reach servers  in service provider network .","The TSCF standard further provides control messages for exchanging configuration information between tunneling client  and tunneling server . According to the TSCF standard, control messages are of a \u201crequest\/response\u201d type, and a control message response for a request includes either a corresponding reply or an error code indicating why the request cannot be honored by the receiving end. TSCF control messages use a Type Length Value (\u201cTLV\u201d) encoding. TLV is a variable length concatenation of a unique type and a corresponding value. The unique type is represented by an integer while the value is the actual value identified by the type.","Each TSCF control message includes a control message header at the beginning, including a \u201cCM_Version\u201d field identifying the version of the header and indicating the outer transport protocol of a TSCF tunnel, a \u201cCM_Indication\u201d field identifying whether the message is a control message or not, a \u201cReserved\u201d field reserved for future use, a \u201cCM_Type\u201d field identifying the type of the control message (e.g., whether it is a request or a response, the corresponding functionality, etc.), a \u201cTLV Count\u201d field indicating the number of TLVs that follow or are appended to the header in the corresponding control message, a \u201cTunnel Session ID\u201d (\u201cTSID\u201d) field including a tunnel session identifier (\u201cID\u201d) assigned by tunneling server  to uniquely identify TSCF tunnel , and a \u201cSequence\u201d field that is incremented per message, as described in, for example, 3GPP TR 33.830 V0.5.0.","In one embodiment, in order to establish TSCF tunnel , tunneling client  sends a \u201cconfiguration request\u201d message to tunneling server  to obtain configuration information for TSCF tunnel . In a \u201cconfiguration request\u201d message, TSID header field bits are set to 1 (i.e., FFFF . . . ). In response, tunneling server  assigns a TSID to a TSCF tunnel and sends a \u201cconfiguration response\u201d message back to tunneling client . The \u201cconfiguration response\u201d message includes the TSID assigned by tunneling server  to TSCF tunnel . The subsequent messages between tunneling client  and tunneling server  include this assigned TSID in their headers.","In one embodiment, if a control message is communicated between tunneling client  and tunneling server  and does not include the expected TSID, the control message is dropped and the corresponding TSCF tunnel is terminated. Alternatively, in one embodiment, tunneling client  may send a \u201cconfiguration release request\u201d message to tunneling server  to terminate a TSCF tunnel. In response to such a \u201cconfiguration release request\u201d message, tunneling server  sends a \u201cconfiguration release response\u201d message to tunneling client . At this time, the TSCF tunnel is terminated.","In one embodiment, UE  executes an application  that may be a SIP based RTC application relying on a library such as the software development kit (\u201cSDK\u201d) provided by the tunneled session management solution from Oracle Corp.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 1","FIG. 1","FIG. 2"],"b":["10","10","10","10","116","10","24"]},"System  includes a bus  or other communication mechanism for communicating information, and a processor  coupled to bus  for processing information. Processor  may be any type of general or specific purpose processor. System  further includes a memory  for storing information and instructions to be executed by processor . Memory  can be comprised of any combination of random access memory (\u201cRAM\u201d), read only memory (\u201cROM\u201d), static storage such as a magnetic or optical disk, or any other type of computer readable medium. System  further includes a communication device , such as a network interface card, to provide access to a network. Therefore, a user may interface with system  directly, or remotely through a network, or any other method.","Computer readable medium may be any available media that can be accessed by processor  and includes both volatile and nonvolatile media, removable and non-removable media, and communication media. Communication media may include computer readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism, and includes any information delivery media.","Processor  may further be coupled via bus  to a display , such as a Liquid Crystal Display (\u201cLCD\u201d). A keyboard  and a cursor control device , such as a computer mouse, may further be coupled to bus  to enable a user to interface with system  on an as needed basis.","In one embodiment, memory  stores software modules that provide functionality when executed by processor . The modules include an operating system  that provides operating system functionality for system . The modules further include a tunneling module  for providing tunneling, and all other functionality disclosed herein. In one example embodiment, tunneling module  may implement tunneling server  of  in conjunction with one or more remaining elements of . System  can be part of a larger system, such as added functionality to the \u201cAcme Packet 4500\u201d session border controller from Oracle Corp. Therefore, system  can include one or more additional functional modules  to include the additional functionality. A database  is coupled to bus  to provide centralized storage for tunneling module  and additional functional modules .","In one embodiment, tunneling module  and\/or additional functional modules  may include an establishing module that establishes a tunnel with a UE by a tunneling server; a communicating module that communicates encapsulated media with the UE over the tunnel; a receiving module that receives a request from a tunneling client at the UE to enable compression for the encapsulated media; a determining module that determines a codec for transcoding the encapsulated media at the tunneling client and at the tunneling server; a sending module that sends a response back to the UE to indicate that compression is enabled for the encapsulated media; and a communicating module that communicates compressed encapsulated media with the UE over the tunnel, as will be described herein with reference to .","Referring again to , with known systems, tunneling client  and tunneling server  may establish a TSCF tunnel  that encapsulates different types of traffic ranging from pure data to real-time media. In general, data is sensitive to integrity while real-time media is sensitive to latency. In some known systems, encapsulated media is typically communicated according to the real-time transport protocol (\u201cRTP\u201d as provided, for example, in IETF RFC 3550).","In some known systems, encapsulated media that is packetized according to RTP includes a compressed payload encoded by a codec  within application . A codec performs compression and\/or decompression of a data stream or signal according to a bitrate (the number of bits conveyed or processed per unit of time).","In some known systems, the compressed payload of packetized encapsulated media may be encoded by a high bitrate codec such as G.711 as provided, for example, according to the International Telecommunication Union (\u201cITU\u201d) Telecommunication Standardization Sector (\u201cITU-T\u201d) standard.","One disadvantage with these known systems is that media streams that are compressed with a high bitrate codec occupy excessive bandwidth. For example, with the same bandwidth that is used to transmit a single media stream transcoded using a high bitrate codec such as G.711, it is possible to transmit between 8 and 12 streams of speech transcoded using a lower bitrate codec such as G.729 as provided, for example, according to the ITU-T standard. Transcoding is the direct analog-to-analog or digital-to-digital conversion of one encoding to another.","One known solution for more efficient bandwidth consumption is that before compressing speech (and media in general), the endpoints may negotiate codecs at the application layer via a signaling protocol. However, notwithstanding the aforementioned negotiation, high bitrate codecs are typically selected and used due to client and\/or network limitations. Further, the resulting high bitrate transcoded media is encapsulated within a tunnel such as TSCF tunnel , the tunneling architecture does not affect the flow of traffic and transmits it transparently at the same high bitrate, therefore resulting in an unnecessarily high bandwidth consumption.","In contrast to the known solutions, embodiments of the present invention provide an encapsulation configuration that automatically detects media traffic and transcodes it using a lower bitrate codec as it traverses TSCF tunnel . In some embodiments, the detection and compression\/transcoding of embedded media streams within TSCF tunnel  is performed independently of the application layer (i.e., independently of application ).","One embodiment provides media compression functionality by implementing a first transcoding module  at tunneling client  and a second transcoding module  at tunneling server . In one embodiment, first transcoding module  at tunneling client  inspects encapsulated traffic in TSCF tunnel  to differentiate between data and real-time media based on their different traffic patterns, and performs compression on demand to improve the throughput of TSCF tunnel . In one embodiment, first transcoding module  transparently initiates media compression whenever real-time media is detected in encapsulated traffic in TSCF tunnel .","In one embodiment, first transcoding module  notifies application  whenever real-time media is detected in encapsulated traffic in TSCF tunnel . In one embodiment, when first transcoding module  detects a transition from real-time media to data mode, or vice versa, it notifies application  by indicating the inner socket affected by such transition. A network socket is an endpoint of an inter-process communication flow across a computer network according to a communications protocol. A network socket may be a datagram socket (a connectionless network socket) or a stream socket (a connection-oriented and sequenced socket). In general, for regular communications, a user can create a datagram or stream socket that uses the network interface of the system in which the application runs. In a TSCF environment, however, sockets use a tunnel for transport instead of a network interface. To differentiate these sockets from regular sockets, they are referred to as \u201cinner sockets\u201d since they only exist inside a tunnel. That is, an inner socket only exists in association with a tunnel and socket traffic gets transported by the tunnel.","In one embodiment, first transcoding module  determine whether the traffic pattern in TSCF tunnel  is indicative of real-time media or not by performing inner datagram packet analysis. When first transcoding module  detects a transition to real-time media in TSCF tunnel , it tries to negotiate media compression with second transcoding module  at tunneling server . Upon a successful negotiation, media compression is enabled at first transcoding module  and second transcoding module . Thereafter, if first transcoding module  detects a transition to data mode in TSCF tunnel , it tears down (i.e., terminates) the media compression functionality that was negotiated with second transcoding module .","In one embodiment, when media compression is negotiated between first transcoding module  and second transcoding module , they both transcode high bitrate media into low bitrate media before encapsulation, and transcode low bitrate media into high bitrate media after de-encapsulation. In one embodiment, based on load requirements of tunneling server , compression functionality may be asymmetric, for example, affecting only the traffic from tunneling client  to tunneling server  and not the other way around.","For example, since transcoding introduces computational complexities that require specific signal processing resources, if those resources are limited at tunneling server , tunneling server  may be able to perform decoding but not encoding, hence not allowing the implementation of transcoding functionality that is symmetric across tunneling client  and tunneling server . The resources that are limited at tunneling server  include, for example, a specific number of concurrent channels required for performing encoding and a specific number of concurrent channels required for performing decoding. In one embodiment, performing decoding may require much lighter resources than performing encoding, therefore the limitation of resources at tunneling server  typically relates to performing encoding.","In one embodiment, for example, G.711 encoding and decoding to\/from raw speech is according to a non-linear conversion formula between 16-bit samples and 8-bit samples. However, G.729 encoding of raw speech is more complex and requires extensive signal processing resources, while G.729 decoding of compressed speech is simpler than its encoding and does not require as much resources. Accordingly, if tunneling client  converts traffic from G.711 to raw speech and from raw speech to G.729 before transmitting to tunneling server , tunneling server  may be serving multiple (e.g., thousands) of simultaneous clients and thus may not have enough resources to convert raw speech to G.729 before transmitting to tunneling client  in the opposite direction. Therefore, the transmissions between tunneling client  and tunneling server  may not be symmetrical and the only conversion to low bitrate may be performed for traffic sent from tunneling client  to tunneling server , resulting in asymmetric transcoding.","One embodiment provides TSCF SDKs that support application programming interface (\u201cAPI\u201d) notification that provides functionality for first transcoding module  to notify application  of the detection of a transition from real-time media to data mode, or vice versa, in TSCF tunnel .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3","b":["300","108","300","108","300","108"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 4","FIG. 3"],"b":["400","300","118","108","400"]},"In RTP header configuration , fields V, SSRC, and PT are fixed for every media stream, and field SN is a 32 bit number that increases with every packet being transmitted. Accordingly, in one embodiment, first transcoding module  may detect a media stream in TSCF tunnel  when a sequence of consecutive frames have headers with the same V, SSRC, and PT fields, and each header in the sequence has an SN field that is larger than the SN field of the previous header by one. In one embodiment, first transcoding module  may examine a certain number of consecutive frames (e.g., 5 frames) before indicating a media stream, or otherwise data, in TSCF tunnel . Similarly, when a sequence of consecutive frames have headers that do not match the format expected of consecutive RTP headers, first transcoding module  may detect pure data in TSCF tunnel .","In one embodiment, first transcoding module  detects a traffic pattern in TSCF tunnel  (e.g., a media stream or otherwise pure data) according to the following example functionality:","Initialization:\n\n","end","OnIncomingPacket(pkt):\n\n","end","In the above functionality, \u201cCOUNT_THRESHOLD\u201d is a pre-configured number (typically 5). Once first transcoding module  detects media or data in TSCF tunnel , it notifies both application  and second transcoding module  at tunneling server .",{"@attributes":{"id":"p-0052","num":"0080"},"figref":["FIG. 5","FIG. 5","FIG. 1"],"b":["500","106","116","106","116"]},"At  tunneling client  sends a configuration request message to tunneling server  to establish TSCF tunnel , and at  tunneling server  responds to the configuration request message of tunneling client  with a configuration response message. Configuration request and response messages allow for tunneling client  to obtain configuration information for TSCF tunnel  from tunneling server , as described in, for example, 3GPP TR 33.830 V0.5.0. Accordingly, TSCF tunnel  is compliant with TSCF tunnel management (e.g., tunnel initialization, maintenance, termination, etc., as defined by, e.g., 3GPP TR 33.830 V0.5.0), and TSCF tunnel transport protocols are supported for the negotiation of TSCF tunnel  between tunneling client  and tunneling server . In one embodiment, from the RTC application perspective, application  at UE  creates TSCF tunnel  by executing a \u201ctsc_ctrl_new_tunnel\u201d API, and the configuration request message is sent to tunneling server  in response to the execution of this API.","Upon completing the exchange of configuration request\/response messages, tunneling client  and tunneling server  may use TSCF tunnel  for performing RTC and communicating signaling traffic and media traffic. For example, tunneling client  and tunneling server  may use TSCF tunnel  to perform signaling negotiation at  and to communicate high bitrate media at . In one embodiment, when inner signaling and media sockets are needed to place a call (e.g., for communicating SIP call control traffic or RTP media traffic), application  creates these sockets on TSCF tunnel  by executing a \u201ctsc_socket\u201d API. A socket is created by determining a socket type (e.g., datagram vs. stream) and a tunnel on which the socket should be created. In one embodiment, when a socket is created, application  binds the socket by executing a \u201ctsc_bind\u201d API. The bind function assigns a specific transport port (e.g., TCP or UDP) to the socket. This port is later used as a source port of all traffic generated by the socket. In one embodiment, if an inner socket is created in TSCF tunnel , there is a binding at tunneling server  that links the internal IP address of TSCF tunnel  to that socket.","At  first transcoding module  at tunneling client  detects that high bitrate RTP media is flowing through TSCF tunnel , and subsequently at  first transcoding module  sends a TSCF service request message to tunneling server  to enable compression functionality.","At  second transcoding module  at tunneling server  receives this service request message and, if tunneling server  can comply with the compression request, answers back to first transcoding module  with a TSCF service response message to confirm that compression functionality is enabled. In one embodiment, tunneling server  may not be able to comply with the compression request if, for example, it does not have transcoding resources or if the requested codec is not supported\/implemented at tunneling server .","Upon enabling compression functionality, at  tunneling client  and tunneling server  start communicating low bitrate compressed media over RTP through TSCF tunnel . In one embodiment, since the input to a codec is raw speech (e.g., with 16 bits per sample at an 8 KHz sampling rate), when first transcoding module  receives high bitrate payload from application , it first converts it to raw speech and then compresses it into low bitrate payload to be transmitted as encapsulated media to second transcoding module . When second transcoding module  receives such low bitrate payload, it again converts it to raw speech and then compresses it into high bitrate payload to be transmitted to the untunneled side of the communication (e.g., servers  in service provider network ). Similarly, when second transcoding module  receives high bitrate payload from the untunneled side of the communication, it first converts it to raw speech and then compresses it into low bitrate payload to be transmitted as encapsulated media to first transcoding module . When first transcoding module  receives such low bitrate payload, it again converts it to raw speech and then compresses it into high bitrate payload to be provided to application .","At  first transcoding module  at tunneling client  detects either an end-of-stream (indicating media transmission has ended) or detects data in TSCF tunnel , and subsequently at  first transcoding module  issues a TSCF service request message to tunneling server  to disable compression functionality.","At  second transcoding module  at tunneling server  responds back to first transcoding module  with a corresponding TSCF service response message indicating that compression functionality has been disabled.","One embodiment provides compression functionality by implementing a TSCF client service request message of type \u201cService_Type\u201d with two TLV values indicating compression enablement and disablement, respectively. Further, a \u201cPayload_Type\u201d TLV is provided to indicate high bitrate and low bitrate codecs corresponding to the compression functionality, and a \u201cConnection_Info\u201d TLV is provided to indicate source and destination transport and network endpoints. Table 1 below provides example TSCF TLVs for providing compression services, according to some embodiments.",{"@attributes":{"id":"p-0061","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example TSCF TLVs for providing compression services"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"SHORT\/",{},{},{}]},{"entry":["TLV TYPE",{},"LONG","VALUE",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["NAME","VALUE","SEMANTICS","FORMAT","TYPE","LENGTH","NOTES"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":["Connection_Info_IPv4","24","Client","Short","Octet",{},{}]},{"entry":[{},{},"Connection",{},"string",{},{}]},{"entry":[{},{},"Info",{},{},{},{}]},{"entry":["Connection_Info_IPv6","25","Client","Short","Octet",{},{}]},{"entry":[{},{},"Connection",{},"string",{},{}]},{"entry":[{},{},"Info",{},{},{},{}]},{"entry":["Service_Type","27","Service Type ","Short","Unsigned","1 byte","Enable_Media_Compression = 11"]},{"entry":[{},{},{},{},"integer",{},"Disable_Media_Compression = 12"]},{"entry":["Payload_Type","35","Payload Type ","Short","Unsigned",{},"PCMU = 0"]},{"entry":[{},{},{},{},"integer","1 byte","PCMA = 8"]},{"entry":[{},{},{},{},{},{},"G723 = 4"]},{"entry":[{},{},{},{},{},{},"G729 = 18"]},{"entry":[{},{},{},{},{},{},"AMR-NB-rate-0 = 240"]},{"entry":[{},{},{},{},{},{},"AMR-NB-rate-1 = 241"]},{"entry":[{},{},{},{},{},{},"AMR-NB-rate-2 = 242"]},{"entry":[{},{},{},{},{},{},"AMR-NB-rate-3 = 243"]},{"entry":[{},{},{},{},{},{},"AMR-NB-rate-4 = 244"]},{"entry":[{},{},{},{},{},{},"AMR-NB-rate-5 = 245"]},{"entry":[{},{},{},{},{},{},"AMR-NB-rate-6 = 246"]},{"entry":[{},{},{},{},{},{},"AMR-NB-rate-7 = 247"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},"In Table 1, the \u201cPayload_Type\u201d TLV may indicate a high bitrate codec such as G.711 pulse code modulation (\u201cPCM\u201d) \u03bc-law (\u201cPCMU\u201d) and G.711 PCM A-law (\u201cPCMA\u201d), or a low bitrate codec such as G.723, G.729, and adaptive multi-rate (\u201cAMR\u201d) narrow band (\u201cAMR-NB\u201d). Typically, compression functionality involves transcoding a high bitrate codec (e.g., PCMU, PCMA, etc.) into a low bitrate codec (e.g., G.723, G.729, AMR-NB, etc.). However, in some embodiments, compression functionality may be provided to transcode between any two codecs that have the same or different bitrates.","In one embodiment, once compression functionality has been enabled for a given stream of media in TSCF tunnel , in order for tunneling client  or tunneling server  to process a given media packet, a respective one of first transcoding module  and second transcoding module  transcodes the frame from a high bitrate payload into a low bitrate payload, and changes the PT field in the RTP header of the frame to reflect the new codec corresponding to the low bitrate payload. In one embodiment, in order to provide compression functionality, first transcoding module  and second transcoding module  select a low bitrate codec based on codec availability at both tunneling client  and tunneling server .","One embodiment provides a configuration object \u201ctscf-interface\u201d that includes a parameter \u201cassigned-services\u201d with keywords \u201cmedia-detection\u201d and \u201cmedia compression\u201d that enable detection and compression of media, respectively. Table 2 below provides an example TSCF configuration object for providing compression services, according to one embodiment.",{"@attributes":{"id":"p-0065","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"An example TSCF configuration object for providing compression services"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Extensible","Data","Value","Required or"]},{"entry":[{},"markup ","Type","Ranges\/","Optional (for"]},{"entry":["Parameter","language","and","Possible","feature to "]},{"entry":["Name","(\u201cXML\u201d) tag","Default","Values","work)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["assigned-","assigned-","String:","\u201cmedia-detection\u201d","Optional"]},{"entry":["services","services","Blank","\u201cmedia-",{}]},{"entry":[{},{},{},"compression\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The following functionality provides an example \u201caddress-pool\u201d configuration for providing compression services, according to one embodiment:\n\n","The following is an example XML functionality for providing compression services, according to one embodiment:\n\n","Some embodiments do not require SDK API changes at application  since compression functionality is triggered dynamically by tunneling client  based on TSCF configuration parameters. Accordingly, compression functionality may be provided transparently to application . However, some embodiments support application notification whenever first transcoding module  detects a transition from real-time media to data mode, or vice versa, in TSCF tunnel .","The following is an example functionality for enabling notification and for providing a corresponding callback:",{"@attributes":{"id":"p-0070","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003tsc_notification_enable(handle, tsc_notification_media_detection,"},{"entry":"media_detection_notification, NULL);"},{"entry":"\u2003void media_detection_notification(tsc_notification_data *notification)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003tsc_notification_media_detection_info_data *media_detection_data ="},{"entry":"(tsc_notification_media_detection_ info_data *)notification->data;"},{"entry":"\u2003\u2003if (media_detection_data && media_detection_data->available == "},{"entry":"\u2003\u2003tsc_bool_true) {"},{"entry":"\u2003\u2003\u2003if (media_detection_data->enabled == tsc_bool_true) {"},{"entry":"\u2003\u2003\u2003\u2003printf(\u201cmedia detection notification enabled on socket %d\\n\u201d,"},{"entry":"media_detection_data->socket);"},{"entry":"\u2003\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003printf(\u201cmedia detection notification disabled on socket %d\\n\u201d,"},{"entry":"media_detection_data->socket);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003printf(\u201cmedia detection notification not allowed on socket %d\\n\u201d,"},{"entry":"media_detection_data->socket);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the above functionality, the fourth \u201cNULL\u201d parameter in \u201ctsc_notification_enable\u201d is an opaque\/private data pointer that can be recovered in the \u201ctsc_notification_data\u201d structure upon callback.",{"@attributes":{"id":"p-0072","num":"0126"},"figref":["FIG. 6","FIG. 2","FIG. 1","FIG. 6"],"b":["16","116"]},"At  tunneling client  and tunneling server  establish TSCF tunnel .","At  tunneling client  and tunneling server  communicate encapsulated media over TSCF tunnel ;","At  first transcoding module  at tunneling client  inspects the traffic pattern in TSCF tunnel  and determines that encapsulated media is being communicated over TSCF tunnel  and sends a TSCF service request to tunneling server  to enable compression for the encapsulated media in TSCF tunnel . In one embodiment, first transcoding module  determines that the traffic pattern of TSCF tunnel  corresponds to the encapsulated media by identifying a sequence of consecutive headers conforming to RTP. In one embodiment, upon determining that the traffic pattern of TSCF tunnel  corresponds to the encapsulated media, first transcoding module  provides a corresponding notification to application  at UE  indicating an inner socket of the encapsulated media.","At  first transcoding module  and second transcoding module  determine a codec for transcoding the encapsulated media into compressed encapsulated media at tunneling client  and at tunneling server . In one embodiment, first transcoding module  and second transcoding module  determine the codec based on available codecs at tunneling client  and at tunneling server .","At  second transcoding module  at tunneling server  sends a TSCF service response back to first transcoding module  to indicate that compression is enabled for the encapsulated media in TSCF tunnel.","At  first transcoding module  and second transcoding module  communicate compressed encapsulated media over TSCF tunnel . In one embodiment, the encapsulated media includes high bitrate media, and upon enabling compression, first transcoding module  and second transcoding module  transcode the high bitrate media into low bitrate media and communicate the low bitrate media through TSCF tunnel . In one embodiment, if first transcoding module  subsequently determines that the traffic pattern of TSCF tunnel  has changed to encapsulated data, it sends a TSCF service request message to second transcoding module  to disable compression, and second transcoding module  responds back by sending a TSCF service response message indicating that compression is disabled.","As disclosed, embodiments allow for a TSCF tunneling configuration that provides media detection and compression functionality. Embodiments allow a tunneling client to detect media in a TSCF tunnel and initiate compression of encapsulated traffic. In one embodiment, upon automatically detecting encapsulated media, the high bitrate media payload is transcoded into a more efficient low bitrate payload. Accordingly, embodiments give the end user the possibility of improving tunnel throughput via a more efficient use of bandwidth.","Several embodiments are specifically illustrated and\/or described herein. However, it will be appreciated that modifications and variations of the disclosed embodiments are covered by the above teachings and within the purview of the appended claims without departing from the spirit and intended scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 6","FIG. 2"]}]},"DETDESC":[{},{}]}
