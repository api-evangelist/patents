---
title: Datalog support in a modular test system
abstract: A method for communicating test information from a source to a destination is disclosed. The method includes providing a modular test system, where the modular test system comprises a system controller for controlling at least one site controller, the at least one site controller for controlling at least one test module. The method further includes providing a datalog framework for supporting extension of user-defined datalog formats, providing support classes for supporting user-initiated datalog events, receiving a datalog event requesting for communicating input test information from the source to the destination, configuring output test information based upon the destination, the datalog framework and the support classes, and transferring the output test information to the destination.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07430486&OS=07430486&RS=07430486
owner: Advantest America R&D Center, Inc.
number: 07430486
owner_city: Santa Clara
owner_country: US
publication_date: 20040813
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY","DESCRIPTION OF EMBODIMENTS"],"p":["This application claims the benefit of provisional application No. 60\/573,577, \u201cSoftware Development in an Open Architecture Test System,\u201d filed by Advantest Corporation on May 22, 2004, which is incorporated herein in its entirety by reference.","The present invention relates to the field of automated test equipment (ATE). In particular, the present invention relates to a method and system for supporting datalog in an open architecture test system.","The increasing complexity of System-on-a-Chip (SOC) devices and the simultaneous demand for a reduction in the cost of chip testing has forced both integrated circuit (IC) manufacturers and tester vendors to rethink how IC testing should be performed. According to industry studies, without re-engineering the projected cost of testers will continue to rise dramatically in the near future.","A major reason for the high cost of test equipment is the specialized nature of conventional tester architecture. Each tester manufacturer has a number of tester platforms that are not only incompatible across companies such as Advantest, Teradyne and Agilent, but also incompatible across platforms within a company, such as the T3300, T5500 and T6600 series testers manufactured by Advantest. Because of these incompatibilities, each tester requires its own specialized hardware and software components, and these specialized hardware and software components cannot be used on other testers. In addition, a significant effort is required to port a test program from one tester to another, and to develop third party solutions. Even when a third party solution is developed for a platform, it cannot be ported or reused on a different platform. The translation process from one platform to another is generally complex and error prone, resulting in additional effort, time and increased test cost.","Datalogging is used to provide status information to the user when running a test or a series of tests. The information reported in a datalog may include the pass\/fail status of the device under test (DUT), any relevant measured parameters, and the overall run status of the test itself. This information is typically used offline to assess the completion of a test run and the performance of the device being tested. The support of datalog capabilities allows users to output their test information from a designated source to a designated destination in a desired format.","One of the problems of the specialized tester architecture is that all hardware and software remain in a fixed configuration for a given tester. To test a hardware device or an IC, a dedicated test program is developed that uses some or all of the tester capabilities to define the test data, signals, waveforms, and current and voltage levels, as well as to collect the DUT response and to determine DUT pass\/fail.","Since a test system needs to exercise a wide range of functionalities and operations in order to test a wide variety of test modules and their corresponding DUTs, there is a need for an open architecture test system that can be configured to support the wide variety of test modules. Specifically, in order to support the wide variety of test modules, there is a need for a datalog framework within the open architecture test system that can be configured to work with the different formats of the different sources and destinations of the test system.","In one embodiment of the present invention, a method for communicating test information from a source to a destination includes providing a modular test system, where the modular test system comprises a system controller for controlling at least one site controller, the at least one site controller for controlling at least one test module. The method further includes providing a datalog framework for supporting extension of user-defined datalog formats, providing support classes for supporting user-initiated datalog events, receiving a datalog event requesting for communicating input test information from the source to the destination, configuring output test information based upon the destination, the datalog framework and the support classes, and transferring the output test information to the destination.","In another embodiment of the present invention, a modular test system includes a system controller, at least one site controller coupled to the system controller, at least one test module and its corresponding device under test (DUT), a datalog framework configured to support extension of user-defined datalog formats, and one or more support classes configured to support user-initiated datalog events. The modular test system further includes means for receiving a datalog event requesting for communicating input test information from the source to the destination, means for configuring output test information based upon the destination, the datalog framework and the support classes, and means for transferring the output test information to the destination.","Methods and systems are provided for datalog support in a modular test system. The following description is presented to enable any person skilled in the art to make and use the invention. Descriptions of specific techniques and applications are provided only as examples. Various modifications to the examples described herein will be readily apparent to those skilled in the art, and the general principles defined herein may be applied to other examples and applications without departing from the spirit and scope of the invention. Thus, the present invention is not intended to be limited to the examples described and shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["102","104","106","108","110","106","108","106","106","110","112","114"]},"The system controller  serves as the overall system manager. It coordinates the site controller activities, manages system-level parallel test strategies, and additionally provides for handler\/probe controls as well as system-level data-logging and error handling support. The system controller  is the primary point of interaction for a test engineer in verifying and debugging the test environment. It provides a gateway to the site controllers , and manages the synchronization of the site controller activities in a multi-DUT environment. It further runs user applications and tools, such as the Datalog graphical user interface (DatalogGUI). Depending on the operational setting, the system controller  can be deployed on a CPU that is separate from the operation of site controllers . Alternatively a common CPU may be shared by the system controller  and the site controllers . Similarly, each site controller  can be deployed on its own dedicated CPU (central processing unit), or as a separate process or thread within the same CPU.","The site controllers  are responsible for running a test plan to test the DUTs. The test plan creates specific tests by using the Framework Classes as well as standard or user supplied Test Classes that encapsulate the test methodology. In addition, the test plan configures the hardware using the Standard Interfaces, and defines the test flow.","The system architecture of the present invention may be conceptually envisioned as the distributed system shown in  with the understanding that the individual system components may also be regarded as logical components of an integrated, monolithic system, and not necessarily as physical components of a distributed system. The plug-and-play or replaceable modules are facilitated by use of standard interfaces at both hardware and software levels. A tester operating system (TOS) allows a user to write test plan programs using a test plan programming language, and to operate the test system in a way specific to a particular device under test (DUT). It also allows the user to package sequences of the test system operations commonly used in test plan programs as libraries. These libraries are sometimes referred to as test classes and test templates.","Datalog Framework","The datalog framework runs on individual Site Controllers, along with the test plan and the system framework classes. It provides a set of interfaces, classes and methods to support the development, deployment and management of the datalog system. The datalog framework\n\n",{"@attributes":{"id":"p-0029","num":"0034"},"figref":["FIG. 2","FIG. 2"],"b":["200","202","204","206","208","200","210","212","214","216","218","220"]},"The standard datalog interfaces to the tester operating system (TOS) are defined as pure abstract C++ classes. The datalog stream interface (IDatalogStream)  represents an output file or device. The datalog system sends formatted output to streams. The system provides two built-in streams, a FileStream for sending output to a local disk file, and a ConsoleStream for sending output to the System's Console application.","The datalog format interface (IDatalogFormat)  represents the necessary instructions required to format data associated with datalog events to an output. The specific nature of the formatting capability is hidden inside each implementation of the IDatalogFormat. For example, the built-in GeneralFormat allows a general format string to be used with a macro-like capability for extracting named values from the DatalogValues objects, and inserting them into a formatted string.","The datalog type interface (IDatalogType)  represents a class or a \u201ctype\u201d of datalog source, such as a particular type of a Test. The DatalogManager  maps events to formats and streams based in part on the type of the source of the event. As new types of sources are created, they register themselves with the DatalogManager  and receive an identifier (ID) value. Managing these types allows the DatalogManager  to enable\/disable whole classes of datalog sources as well as specific instances of datalog sources. The IDatalogType objects  may generate multiple classes of datalog events. For example, a user test that loops over a set of patterns until some condition occurs may generate TestStart, TestEnd, IterationStart, IterationEnd, and ConditionTest datalog events. Each of these classes of events may have different data fields associated with it (see DatalogValues class below).","The datalog source interface (IDatalogSource)  represents a source of datalog events. While the IDatalogType  characterizes an entire class of datalog source objects, the IDatalogSource  represents an individual source instance. This interface allows enabling\/disabling datalogging of individual sources.","Datalog Support Classes","A central object of the datalog framework  is the DatalogManager object . This object is responsible for maintaining all datalog output streams as well as formatting and forwarding datalog events and their associated data to the appropriate stream(s). The DatalogManager  resides in the test plan server (TPS) of the Site Controller. It is the datalog execution engine. Specifically, the main functions of the DatalogManager  include:\n\n","The datalog format map class  is a named <EventType, EventName, Format> combination. That is, it groups together an EventType (representing a specific IDatalogType object), an EventName (representing one of the datalog events generated by EventType objects) and a Format (representing an IDatalogFormat object).","The datalog format group class  is a collection of DatalogFormatMap objects. Users may bundle DatalogFormatMap objects into a single group and assign the group to a stream or several streams. This provides the user-level control over the ultimate formatting of datalog events and the routing of these formatted strings to the appropriate streams.","The datalog values class  contains header information, like datalog type identifier and event, and a list of datalog fields that are set by the event source. The DatalogValues object acts as a string-to-string map, from name to value, allowing format objects to extract the required values by name, and insert them into a formatted stream.","The general format class  is an implementation of IDatalogFormat. It allows a general format string to be used with a macro-like capability for extracting named values from the DatalogValues objects, and inserting them into a formatted string.","The user format class  is a placeholder for a user-defined format class. If the supplied GeneralFormat class does not meet a user's specific requirements, one may add a new format class to the system and make use of it.","Datalog Sources","In one embodiment, a Site Controller based object may act as a source of datalog events by implementing an IDatalogSource interface . For example, the Test Plan and Test objects are examples of sources of events. Each instance of such an object implements the IDatalogSource interface. In addition, each type of such an object, for example FunctionalTest, has an implementation of the IDatalogType interface  associated with it. This is accomplished with a class-wide static object for each type of datalog source.  illustrates an implementation of datalog sources according to an embodiment of the present invention. The datalog sources include a functional test ( ) class , a datalog type implementation ( ) class , the datalog type interface  and the datalog source interface .","As shown in , the FunctionalTest class  has a class-wide static member of type DatalogTypeImp1 . An instance of the FunctionalTest checks this member variable when it is created. If the variable has not been created and assigned, then the constructor creates an instance of DatalogTypeImp1, initializes it, assigns it to the static member variable, and registers it with the DatalogManager. A subsequent instance of the FunctionalTest class accesses the DatalogTypeImp1 data member, and adds itself (i.e., the instance of the FunctionalTest as an IDatalogSource) to DatalogTypeImp1's list of datalog source instances that the latter FunctionalTest instance is serving.","In another embodiment, a sub-class of the FunctionalTest class, for example ADifferentFunctionalTest, may attempt to establish a datalog type different from that of the FunctionalTest. An implementation of ADifferentFunctionalTest may accomplish this by not using the class-wide DatalogTypeImp1 associated with the FunctionalTest, but using its own class-wide instance of a DatalogTypeImp1. Note that each instance of FunctionalTest implements the IDatalogSource interface. DatalogTypeImp1 uses this interface to enable\/disable individual sources.","Source Type Registration","When a Test Plan is loaded, datalog event sources may register with the DatalogManager object. The return value from this registration is an identifier, which is then used to generate events.",{"@attributes":{"id":"p-0044","num":"0055"},"figref":"FIG. 4","b":["402","404","406","408"]},"Users may set datalog formats for different event types. This may be done during Test Plan initialization to provide default formats and\/or done interactively from remote applications. A similar procedure is followed to allow users to set the datalog streams. The DatalogManager maintains a mapping from a set of {datalog-type, datalog-event} to a corresponding set of {datalog-format, datalog-stream} that specifies the route an event of a particular type may take through the test system. For file-based streams, a Test class on the Site Controller may close the stream allowing the datalog file to be transferred to the System Controller. The stream may then be reopened or replaced with another stream.","Formatting and Streaming Data","During testing, an object may generate a datalog event that is logged to a data stream.  illustrates a method for formatting and streaming data according to an embodiment of the present invention. The group of collaborating objects and interfaces for performing this task include a Test Plan object , a DatalogValues object , a DatalogManager object , a datalog format interface (IDatalogFormat)  and a datalog stream interface (IDatalogStream) . The Test Plan  creates the DatalogValues object instance , sets the appropriate values by calling the setvalue( ) method, and passes this object to the doDatalog( ) method of the DatalogManager . The doDatalog( ) method then finds the appropriate datalog format object  for the type\/event combination, and calls the apply( ) method on this datalog format object  to obtain a string object in return. This string object is then passed to the associated datalog stream object  for output using the writeMessage( ) method.","Datalog Initialization","In a different embodiment, the datalog system is initialized using the following steps:\n\n","The datalog application programming interface (API) provides functions to perform the above tasks. In addition, the test system provides a Test class, DatalogSetupTest, which reads one or more configuration files and performs the above steps. The example below illustrates the use of the DatalogSetupTest configuration file to perform the initialization steps. The DLL parameter within the datalog stream, datalog format map and datalog format group specifies a library to use for implementing the IDatalogStream  or IDatalogFormat .",{"@attributes":{"id":"p-0049","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Version 0.1.0;"},{"entry":"# Enable the datalog system"},{"entry":"Enabled;"},{"entry":"# Step 1: Stream Creation"},{"entry":"# Creates a stream of type FileStream, which logs the message to"},{"entry":"# a file."},{"entry":"Stream FunctionalTestStream"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DLL \u201cFileStream\u201d;"]},{"entry":[{},"FileName \u201cFuncDatalogDut<DutID>.log\u201d;"]},{"entry":[{},"Overwrite \u201c1\u201d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"# Step 2: Format Creation"},{"entry":"# Adds a format with a line that looks like:"},{"entry":"# Signal Info: $SignalInfo"},{"entry":"# where $SignalInfo is replaced by the string provided in the datalog"},{"entry":"source."},{"entry":"Format SignalInfoFormat"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DLL \u201cGeneralFormat\u201d;"]},{"entry":[{},"Format \u201cSignal Info: $SignalInfo\u201d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} # Adds a format with a line that looks like:"},{"entry":"# Test Result: $Result"},{"entry":"# where $Result is replaced by the string provided in the datalog"},{"entry":"# source."},{"entry":"Format TestResultFormat"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DLL \u201cGeneralFormat\u201d;"]},{"entry":[{},"Format \u201cTest Result: $Result\u201d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"# Step 3: FormatMap Creation"},{"entry":"# Maps format SignalInfoFormat to event DumpSignal from sources"},{"entry":"# of type com.Advantest.oai.TestClasses.FunctionalTest."},{"entry":"FormatMap SignalFormatMap"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type com.advantest.oai.TestClasses.FunctionalTest;"]},{"entry":[{},"Event DumpSignal;"]},{"entry":[{},"Format SignalInfoFormat;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"# Maps format TestResultFormat to event TestResult from sources"},{"entry":"# of type com.Advantest.oai.TestClasses.FunctionalTest."},{"entry":"FormatMap ResultFormatMap"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type com.advantest.oai.TestClasses.FunctionalTest;"]},{"entry":[{},"Event TestResult;"]},{"entry":[{},"Format TestResultFormat;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"# Step 4: FormatGroup Creation"},{"entry":"# Creates a group which directs messages from format map"},{"entry":"# SignalFormatMap and ResultFormatMap to destination"},{"entry":"# FunctionalTestStream and ConsoleStream."},{"entry":"FormatGroup FunctionalTestGroup"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FormatMap SignalFormatMap;"]},{"entry":[{},"FormatMap ResultFormatMap;"]},{"entry":[{},"Stream FunctionalTestStream;"]},{"entry":[{},"Stream ConsoleStream;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In yet another embodiment, a datalog setup file includes four different types of blocks: datalog format blocks, datalog stream blocks, datalog format map blocks and datalog format group blocks. These blocks are used to define the datalog formats, datalog streams, datalog format maps and datalog format groups respectively. Any of these four blocks may be used multiple times in a same setup file, and the datalog system may also be set up with multiple separate datalog setup files. Thus, the datalog system setup is modular and flexible. For example, there may be a first datalog setup file for setting up Cal\/Diags datalogging, a second datalog setup file for setting up datalogging for functional tests, and a third datalog setup file for setting up datalogging for parametric tests.","Datalog Format Block","In one embodiment, a datalog format block is used to define a datalog format. The definitions of the format may include a format name, a format DLL name, a message format string and optional user-defined format parameters. If the format DLL name is GeneralFormat, the predefined GeneralFormat is used; otherwise, a user-defined datalog format is used. In the latter case, the user provides a datalog format DLL in the system test directories. The following Datalog API is called to define the datalog format block:","void DatalogManager::addFormat(const OFCString &formatName,\n\n","Format SignalInfoFormat","{\n\n","}","defines a format SignallnfoFormat, which makes use of the predefined GeneralFormat. Its format string is $Signallnfo, in which $Signallnfo is a token which may be replaced by the datalog variable Signallnfo in the passed-in datalog record (DatalogValues) during runtime. A datalog format block can be used to remove an existing datalog format from the datalog system. In this scenario, the following datalog API is called.\n\n","In another embodiment, a datalog stream block is used to define a datalog stream. The definition of the datalog stream includes a stream name, a stream DLL name and optional user-defined stream parameters. If the stream DLL name is FileStream or ConsoleStream, a built-in datalog stream FileStream or ConsoleStream is used; otherwise, a user-defined datalog stream is used. In the latter case, the user provides a datalog stream DLL in the system test directories. The following Datalog API is called to define the datalog stream block:",{"@attributes":{"id":"p-0058","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void DatalogManager::addStream(const OFCString &streamName,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"const OFCString &typeName,"]},{"entry":[{},"const DatalogProperties_t properties);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"and"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Stream FunctionalTestStream"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DLL \u201cFileStream\u201d;"]},{"entry":[{},"FileName \u201cdatalog<DutID>.log\u201d;"]},{"entry":[{},"Overwrite \u201c0\u201d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"sub":["\u2014","\u2014","\u2014","\u2014","\u2014"]},"A datalog stream block can be used to remove an existing datalog stream from the datalog system. In this case, the following datalog API is called:\n\n","In a different embodiment, a datalog type block is used to define user-specific properties for a datalog type. The following Datalog API is called to define the datalog type block:",{"@attributes":{"id":"p-0061","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IDatalogType *DatalogManager::getType(const OFCString"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"&typeName) const;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void IdatalogType::addProperty(const OFCString &propName,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"const OFCString &propValue);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"and"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type com.Advantest.oai.TestClasses.FunctionalTest"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Mode \u201cDetailed\u201d;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"In yet another embodiment, a datalog format map block is used to define a datalog format map. The definition of the Format Map includes a format map name, a datalog type name and its event name to be mapped, and a mapped format name. The following Datalog API is called to define the datalog format map block:",{"@attributes":{"id":"p-0063","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003void DatalogManager::createFormatMap(const OFCString &mapName,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"const OFCString &typeName,"]},{"entry":[{},"const OFCString &eventName,"]},{"entry":[{},"const OFCString &formatName);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"and"},{"entry":"\u2003FormatMap SignalFormatMap"},{"entry":"\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type com.Advantest.oai.TestClasses.FunctionalTest;"]},{"entry":[{},"Event DumpSignal;"]},{"entry":[{},"Format SignalInfoFormat;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"A datalog format map block may be used to remove an existing datalbg format map from the datalog system. In this case, the following datalog API\n\n","In one embodiment, a datalog format block is used to define a datalog format group. The definition of the Format Group includes a format group name, a list of names of format maps that the format group contains, and a list of names of streams to which messages generated from the format group are exported. The following Datalog APIs are called to define the datalog format group block:",{"@attributes":{"id":"p-0066","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"void DatalogManager::createFormatGroup(const OFCString &groupName,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"const OFCStringVec_t &mapNames);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"void DatalogManager::setStream(const OFCString &groupName,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"const OFCString &streamName);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0067","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FormatMap SignalFormatMap;"]},{"entry":[{},"FormatMap ResultFormatMap;"]},{"entry":[{},"Stream FunctionalTestStream;"]},{"entry":[{},"Stream ConsoleStream;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"A datalog format map block may be used to remove an existing datalog format group from the datalog system. In this case, the datalog API\n\n","In the following examples, proxy objects, such as DatalogManagerProxy, DatalogHandelerProxy, and DatalogFilterProxy, are used by applications running the system controller to remotely control the current state and operation of the datalog framework on one or more site controllers. These objects act as remote proxies for the real objects on the site controllers and provide a transparent communication channel to these objects that allows applications on the system controller to deal with local object rather than the complexities of communication protocols.",{"@attributes":{"id":"p-0070","num":"0096"},"figref":["FIG. 6","FIG. 6"],"b":["602","604","606","608"],"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":{"@attributes":{"id":"ul0019-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":["1. In step 1, the DatalogGUI  or other tester GUI (e.g., Test Control Panel) includes a button or menu item Enable Datalog. When a user clicks on the button or menu item, the DatalogGUI  searches the DataloggerProxy object  from a test plan server proxy (TPSProxy).","2. The DatalogGUI  invokes a setEnable( ) method on the returned DataloggerProxy , passing in parameter value \u2018true\u2019, which means enabling the datalog system.","3. With the proxy model, the setEnable( ) method of the DataloggerProxy  invokes the setEnableTest( ) method of the Datalogger  to enable the datalog system.","4. The test object  calls an enteringTest( ) method to send out a datalog event to the Datalogger .","5. The Datalogger  checks whether it is enabled by calling an is Enabled( ) method.","6. If the Datalogger  is enabled, it invokes a log( ) method to start datalogging."]}}}},{"@attributes":{"id":"p-0071","num":"0103"},"figref":["FIG. 7","FIG. 7"],"b":["702","704","704","708","708"],"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":{"@attributes":{"id":"ul0021-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":["1. In step 1, the DatalogGUI  or other tester GUI (e.g., Test Control Panel) includes a button or menu item Disable Datalog. When a user clicks on the button or menu item, DatalogGUI searches the singleton DataloggerProxy object  from a TPSProxy.","2. The DatalogGUI  invokes a setEnable( ) method on the returned DataloggerProxy , passing in parameter value \u2018false\u2019, which means disabling the datalog system.","3. With the proxy model, the setEnable( ) method of the DataloggerProxy  invokes the setEnableTest( ) method of the Datalogger  to disable the datalog system.","4. The test object  calls an enteringTest( ) method to send out a datalog event to the Datalogger .","5. The Datalogger checks whether it is enabled. Since it is disabled, no datalogging may occur."]}}}},{"@attributes":{"id":"p-0072","num":"0109"},"figref":["FIG. 8","FIG. 8"],"b":["802","804","806","808","806"],"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":{"@attributes":{"id":"ul0023-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":["1. In step 1, the DatalogGUI  displays a list of available datalog formatters associated with a selected datalog handler. A user may select any datalog formatter by opening a pull-down menu, and selects the menu item Edit. The implementation of DatalogGUI associates each datalog formatter item in the list with the corresponding datalog formatter proxy reference (by using user data parameter). Next, the DatalogFormatterProxy object  is obtained.","2. The DatalogGUI  invokes a getFormat( ) method using the DatalogFormatterProxy object  to get the format string and related arguments.","3. With the proxy model, the getFormat( ) method of the DatalogFormatterProxy  invokes the corresponding getFormat( ) method of the DatalogFormatter .","4. The DatalogGUI  displays the format and argument of the datalog event with the selected formatter. The user may change the format and argument according to a set of predetermined datalog format requirements.","5. When the user applies the modified formatter into the datalog system, the DatalogGUI  invokes a setFormat( ) method of the DatalogFormatterProxy  and passes in the modified format string and arguments.","6. With the proxy model, DatalogFormatterProxy.setFormat( ) method of the DatalogFormatterProxy  invokes the corresponding setFormat( ) method of the DatalogFormatter .","7. Next, when the DatalogHandler  invokes a getOuptut( ) method on the modified datalog formatter to get formatted message with the datalog event, the modified formatter is applied."]}}}},{"@attributes":{"id":"p-0073","num":"0117"},"figref":["FIG. 9","FIG. 9"],"b":["902","904","906","908","910"],"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":{"@attributes":{"id":"ul0025-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":["1. In step 1, when a user selects a datalog handler to edit its associated datalog output stream, the DatalogGUI  displays a panel, which comprises two lists: a first list displays datalog stream names in the datalog system, and a second list displays the datalog stream names associated with the datalog handler. In addition, the DatalogGUI also includes Add, Remove, Apply, OK and Cancel buttons.","2. The DatalogGUI  calls a getStreamNames( ) method of the DatalogManagerProxy .","3. With the proxy model, the getStreamNames( ) method of the DatalogManagerProxy  invokes the corresponding getStreamNames( ) method of the DatalogManager  to get all datalog stream names registered in the datalog system.","4. The DatalogGUI  displays the retrieved datalog stream names in the first list.","5. The DatalogGUI  then calls a getStreamNames( ) method of the IDatalogHandlerProxy .","6. With the proxy model, the corresponding getStreamNames( ) method of the IDatalogHandlerProxy  invokes the corresponding getStreamNames( ) method of the IDatalogHandler  to get all datalog stream names currently associated with the selected datalog handler.","7. The DatalogGUI  displays the retrieved datalog stream names associated with the selected datalog handler in the second list.","8. Then, the user edits the associated datalog stream list using the buttons Add and Remove. After the user finishes editing and clicks an Apply or Ok button to apply the modified stream to the datalog system, the DatalogGUI  invokes a setStreams( ) method on the IDatalogHandlerProxy  and passes to it the modified datalog stream names.","9. With the proxy model, the setStreams( ) method of the IDatalogHandlerProxy  invokes the corresponding setStreams( ) method of the IDatalogHandler .","10. Then, the DatalogHandler  gets the associated datalog stream object reference for each datalog stream name from the DatalogManager .","11. The IDatalogHandler  then adds the stream into the stream vector. Afterwards, the IDatalogHandler  sends out newly selected datalog streams in the stream vector for its datalog output."]}}}},{"@attributes":{"id":"p-0074","num":"0129"},"figref":["FIG. 10","FIG. 10"],"b":["1002","1004","1006","1008"],"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":{"@attributes":{"id":"ul0027-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0028","list-style":"none"},"li":["1. In step 1, the DatalogGUI  displays a list of available datalog streams. A user may select any datalog stream by opening a pull-down menu, and selects a menu item Disable. The implementation of the DatalogGUI  associates each datalog stream item in the list with the corresponding IDatalogStreamProxy reference  (by using user data parameter). Then, the IDatalogStreamProxy  is obtained.","2. The DatalogGUI  invokes a disables method on the IDatalogStreamProxy object  obtained.","3. The disable( ) method of the IDatalogStreamProxy  invokes the corresponding disable( ) method of the IDatalogStream  through the proxy model.","4. The IDatalogHandler  calls a write( ) method to write out a formatted message to the stream.","5. The IDatalogStream  checks whether it is enabled. If it is enabled, the output stream may be modified."]}}}},{"@attributes":{"id":"p-0075","num":"0135"},"figref":["FIG. 11","FIG. 11"],"b":["1102","1104","1106","1108","1110","1112","1114","1116","1118","1120","1118"],"ul":{"@attributes":{"id":"ul0029","list-style":"none"},"li":{"@attributes":{"id":"ul0029-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0030","list-style":"none"},"li":["1. In step , the DatalogGUI  finds the DatalogManagerProxy object , and calls its addHandler( ) method to register a new DatalogHandler instance for the new source. Note that in this approach, the DatalogHandler  associates an event with a different Datalog Formatter. With this model, a new DatalogHandler instance is created to work with the new source (test class). The newly created DatalogHandlerProxy instance is returned.","2. With the proxy model, the addHandler( ) method of the DatalogManagerProxy  invokes the corresponding addHandler( ) method of the DatalogManager .","3. Next, the addHandler( ) method of the DatalogManager  creates a new instance of DatalogHandler, then it registers the newly created DatalogHandler instance to the DatalogManager .","4. Then, the DatalogGUI  associates the datalog filter proxy with the newly created datalog handler through the DatalogHandlerProxy  returned in step 1.","5. With the proxy model, the getFilter( ) method of the DatalogHandlerProxy  invokes the corresponding getFilter( ) method of the DatalogHandler .","6. With the DatalogFilterProxy , the DatalogGUI  calls its enableTest( ) method.","7. With the proxy model, the enableTest( ) method of the DatalogFilterProxy  invokes the corresponding enableTest( ) method of the DatalogFilter . As a result, the newly created datalog handler instance handles a selected event of the new test source.","8. The DatalogGUI  sets the formats for each selected datalog event of the newly created datalog handler through its proxy. For this new test source, the format of a new argument may be specified as Test.FooArgument. In the new test source, an interface IProperty may be implemented, which is shown as follows:"]}}}},{"@attributes":{"id":"p-0076","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class IProperty"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OFCString &getProperty(const OFCString &name) const;"]},{"entry":[{},"void setProperty(const OFCString &name, const OFCString"]},{"entry":[{},"*value);"]},{"entry":[{},"OFCStringVec_t getPropertyNames( ) const;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"where FooArgument is one of the properties in the new test source."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"ul":{"@attributes":{"id":"ul0031","list-style":"none"},"li":{"@attributes":{"id":"ul0031-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":["9. The DatalogHandlerProxy  calls a setFormato method thought the corresponding DatalogHandler .","10. The DatalogHandler  creates a DatalogFormatter for the selected event and adds it into the event route map. Next, the newly created datalog handler processes the datalog event from the new source. Then, the test plan with the new source test may start.","11. Once the TPS reaches the end of execution of the new source test, it sends an exitingTest( ) datalog request to the datalog system.","12. The Datalogger  accepts the request, and transfers it to the datalog event to be logged.","13. The Datalogger  forwards the new datalog event to the DatalogManager  to dispatch.","14. The DatalogManager  publishes the event to the registered datalog handlers one by one. Once a datalog handler is able to process the event, the publishing process may be stopped.","15. When the event is published to each datalog handler, the handler checks whether the event is loggable. The event is loggable if the newly created DatalogHandler instance is able to service the new test source.","16. The DatalogHandler  finds the DatalogFormatter  associated with the current event, and calls its getOuptut( ) method to get the formatted message based on the defined format. The getOuptut( ) method fetches the new parameter Test.FooArgument value by calling\n        \n        "]}}}},"There are number of benefits achieved by the disclosed datalog framework. First, the datalog framework is independent of the sources, nature and contents of the datalog events. This allows new datalog sources and events to be added without modifying the datalog framework. In addition, the formatting of datalog output is independent of the datalog framework. While the GeneralFormat is provided with the system, it is specified as a dynamically linked library (DLL) parameter to the Format block, and it is not \u201chard-coded\u201d into the framework. Moreover, the formatting of datalog events is configurable by the end user. For example, events may be formatted into human readable text, comma-separated values for spreadsheets or databases, application-specific text or binary formats for further processing, or they may even be ignored entirely. The datalog framework is independent of the destination of datalog streams. Furthermore, formats and output streams are extendable. That is, users may add new IDatalogFormat and IDatalogStream implementations to the system without modifying the framework. Test classes (and other datalog sources) and their corresponding datalog events are also extendable so the framework does not need to know about specific source or event types. As users add new Test classes with new datalog event types, no modification of the datalog framework is required.","One skilled in the relevant art will recognize that many possible modifications of the disclosed embodiments may be used, while still employing the same basic underlying mechanisms and methodologies. The foregoing description, for purpose of explanation, has been written with references to specific embodiments. However, the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described to explain the principles of the invention and its practical applications, and to enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The aforementioned features and advantages of the invention as well as additional features and advantages thereof will be more clearly understood hereinafter as a result of a detailed description of embodiments of the invention when taken in conjunction with the following drawings.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
