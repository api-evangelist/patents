---
title: System and method for motion estimation and mode decision for low-complexity H.264 decoder
abstract: The present invention relates to systems and methods for motion estimation and mode decision for low-complexity H.264 standard decoders. The present invention includes a method for optimizing the selection of motion vectors and motion compensation block modules in a video encoder in order to decrease the complexity of the video upon decoding. The novel method of the present invention may include novel steps for selecting motion vectors, block modes, and for applying a complexity-control algorithm to encode the received input video data sequence in accordance with the identified target complexity level. The present invention may be implemented in accordance with current and future video decoding standards to optimize decoding by reducing decoding complexity and thereby reducing required resources and power consumption.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09060175&OS=09060175&RS=09060175
owner: The Trustees of Columbia University in the City of New York
number: 09060175
owner_city: New York
owner_country: US
publication_date: 20070828
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","REFERENCES"],"p":["This application is a continuation of PCT International Application No. PCT\/US06\/07862 filed Mar. 6 8, 2006 which is based on U.S. provisional patent application No. 60\/658,440, filed Mar. 4, 2005, both of which applications are incorporated by reference in their entireties herein, and from which priority is claimed.","1. Technical Field","The present invention relates to systems and methods for motion estimation and mode decision for low-complexity H.264 standard encoders\/decoders.","2. Background Art","Emerging video coding standards like H.264 achieve significant advances in improving video quality and reducing bandwidth, but generally at the cost of greatly increased computational complexity at both the encoder and the decoder. Playing encoded videos produced by such compression standards requires substantial computational resources and thus results in substantial power consumption. This may be a serious concern in power-sensitive applications, such as handheld devices and other devices used in mobile applications.","Many portable media application devices such as mobile handheld devices are becoming increasingly popular. The computational resources available on these handheld devices is becoming relatively scarce as applications of increasing complexity and number are operated by the devices. Accordingly, there is growing interest in complexity-aware\/power-aware video coding solutions.","Most of today's video coding systems encode video bit streams to achieve the best video quality (e.g., the minimal signal distortion) while satisfying certain bitrate constraints. Specifically the following optimization problem formulation is often adopted:",{"@attributes":{"id":"p-0009","num":"0008"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"munder":{"mi":["min","P"]},"mo":"\u2062","mrow":{"mrow":[{"mi":"D","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"P"}},{"mi":["s","t"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}},{"mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"P"}},"mo":"\u2264","msub":{"mi":["R","T"]}}],"mo":","}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}},"br":{},"sub":"T "},"Methods for reducing computational complexity in the prior art include ARMS and National Semiconductor develop a systematic approach called PowerWise technology, which can efficiently reduce the power consumption of mobile multimedia applications through adaptive voltage scaling (AVS). (See National's PowerWise\u2122 technology, described at http:\/\/www.national.com\/appinfo\/power\/powerwise.html, which is fully incorporated herein by reference). Zhou et al. implements an H.264 decoder based on Intel's single-instruction-multiple-data (SIMD) architecture that reduces the decoding complexity and improved the H.264 decoding speed by up to three times. (See X. Zhou, E. Li, and Y.-K. Chen, \u201cImplementation of H.264 Decoder on General-Purpose Processors with Media Instructions\u201d, in Proc. of SPIE Visual Communications and Image Processing, January 2003, which is fully incorporated herein by reference). Ray and Radha propose a method to reduce the decoding complexity by selectively replacing the I-B-P Group of Pictures (GOP) structure with one using I-P only. (See A. Ray and H. Radha, \u201cComplexity-Distortion Analysis of H.264\/JVT Decoder on Mobile Devices,\u201d Picture Coding Symposium (PCS), December 2004, which is fully incorporated herein by reference). Lengwehasatit and Ortega developed a method to reduce the decoding complexity by optimizing the Inverse DCT implementation. (See K. Lengwehasatit and A. Ortega, \u201cRate Complexity Distortion Optimization for Quadtree-Based DCT Coding\u201d, ICIP 2000, Vancouver, BC, Canada, September 2000, which is fully incorporated herein by reference). He et al. optimizes the power-rate-distortion performance by constraining the sum of absolute difference (SAD) operations during the motion estimation process at the encoder. (See Z. He, Y. Liang, L. Chen, I. Ahmad, and D. Wu, \u201cPower-Rate-Distortion Analysis for Wireless Video Communication under Energy Constraints,\u201d IEEE Transactions on Circuits and Systems for Video Technology, Special Issue on Integrated Multimedia Platforms, 2004, which is fully incorporated herein by reference). In addition, power-aware joint source channel coding is also an active topic for mobile wireless video communication. (See Y. Eisenberg, C. E. Luna, T. N. Pappas, R. Berry, A. K. Katsaggelos, Joint source coding and transmission power management for energy efficient wireless video communications, CirSysVideo(12), No. 6, June 2002, pp. 411-424; Q. Zhang, W. Zhu, Zu Ji, and Y. Zhang, \u201cA Power-Optimized Joint Source Channel Coding for Scalable Video Streaming over Wireless Channel\u201d, IEEE International Symposium on Circuits and Systems (ISCAS) 2001, May, 2001, Sydney, Australia; X. Lu, E. Erkip, Y. Wang and D. Goodman, \u201cPower efficient multimedia communication over wireless channels\u201d, IEEE Journal on Selected Areas on Communications, Special Issue on Recent Advances in Wireless Multimedia, Vol. 21, No. 10, pp. 1738-1751, December, 2003, all of which are fully incorporated herein by reference). Unlike the conventional paradigm using complex encoding and light decoding, Girod et al. propose a distributed video coding system which transfers the motion estimation process from the encoder to the decoder so that the encoding complexity can be greatly reduced. (See B. Girod, A. Aaron, S. Rane and D. Rebollo-Monedero, \u201cDistributed video coding,\u201d , Special Issue on Video Coding and Delivery, 2005, which is fully incorporated herein by reference).","Furthermore, the computational complexity of each component of a video decoding system varies. Some are relatively constant and independent of the encoded data while others heavily depend on the coding results. For example, the components of inverse quantization and inverse transform have nearly fixed computational cost per coding unit while the motion compensation component has variable complexity depending on the block mode and the type of motion vector. Furthermore, the decoder complexity is dominated by the interpolation filtering process used in motion compensation if the motion vectors are sub-pixel. Other parts of the decoding system, like entropy decoding and inverse transform, do not incur significant computational cost when compared to the interpolation process.","As noted, motion estimation is usually the most computationally complex process since it involves searching over a large range of possible reference locations, each of which may require interpolation filtering. Among the components in the decoding system, the interpolation procedure used in the motion compensation component consumes the most computational resources (about 50%) due to the use of sub-pixel motion vectors. Accordingly, one way to increase power consumption efficiency in video decoding would be to reduce the major computational cost of the motion compensation interpolation procedure.","Many fast motion estimation algorithms have been developed to reduce the motion estimation complexity during encoding. (See A. M. Tourapis. \u201cEnhanced Predictive Zonal Search for Single and Multiple Frame Motion Estimation,\u201d Proceedings of Visual Communications and Image Processing 2002 (VCIP-2002), San Jose, Calif., January 2002, pp. 1069-79; H.-Y. Cheong, A. M. Tourapis, \u201cFast Motion Estimation within the H.264 codec,\u201d in proceedings of ICME-2003, Baltimore, Md., Jul. 6-9, 2003, both of which are incorporated herein by reference). Other work proposes scalable methods for motion estimation to control the coding complexity. (See M. Schaar, H. Radha, Adaptive motion-compensation fine-granular-scalability (AMC-FGS) for wireless video, IEEE Trans. on CSVT, vol. 12, no. 6, 360-371, 2002, which is incorporated herein by reference). Nevertheless these methods all focus on the encoding complexity reduction instead of the decoding complexity.","Accordingly, there exists a need in the art for an improved system and method for video encoding\/decoding with improved motion estimation which reduces computational costs and power consumption in the decoder.","The objects of the present invention may be met with a novel system and method for optimizing the selection of the motion vectors and motion compensation block modes in video decoding to reduce the computational cost of decoding while maintaining the desired video quality.","The present invention meets needs in the prior art by providing a system and method for optimizing a video encoder, including the steps of receiving an input video data sequence which includes at least one macroblock, identifying a target complexity level for the video data sequence, determining a Lagrange multiplier for the video data sequence, for each macroblock, calculating at least one motion vector for each block mode based on the determined Lagrange multiplier, for each at least one macroblock, selecting one of the block modes based on the determined Lagrange multiplier, and applying a complexity-control algorithm to encode the received input video data sequence in accordance with the identified target complexity level while maintaining a consistent complexity throughout decoding of the input video data sequence.","In another exemplary embodiment, the present invention provides a system and method for optimizing a video encoder, including the steps of receiving an input video data sequence including one or more macroblocks, for each macroblock, enumerating at least one inter-predictive block mode whose one or more motion vectors are to be calculated based on motion estimation, for each block of each enumerated block mode, selecting the one or more motion vectors that yield minimum rate-distortion-complexity, and storing the selected one or more motion vectors for each block of each enumerated block mode.","In another exemplary embodiment, the present invention provides a system and method for optimizing a video encoder, including the steps of receiving an input video data sequence including one or more macroblocks, identifying one or more possible block modes for each macroblock, retrieving one or more selected motion vectors for each block mode, using the selected motion vectors, calculating the rate-distortion-complexity cost for each block mode, selecting, for each macroblock, a block mode that yields a minimum rate-distortion-complexity cost function, and storing at least one of the selected block modes for further processing.","The accompanying drawings, which are incorporated and constitute part of this disclosure, illustrate preferred embodiments of the invention and serve to explain the principles of the invention.","Throughout the Figures, the same reference numerals and characters, unless otherwise stated, are used to denote like features, elements, components or portions of the illustrated embodiments. Moreover, while the present invention will now be described in detail with reference to the Figures, it is done so in connection with the illustrative embodiments.","The present invention relates to an important aspect of the complexity minimization problem in video decoding\u2014i.e., developing an encoding algorithm that achieves both high video quality and low decoding complexity while satisfying the bit rate constraint. The object is to reduce the complexity requirement of emerging video codecs, such as H.264, particularly on resource-limited devices such as handheld devices. The present invention is different from the approaches described above in that the present invention modifies the video encoding algorithm to minimize the required complexity at the decoder, not the encoder. The approach does not require substantial modification to existing decoder implementations. The present invention may be implemented such that it modifies the non-normative parts of, e.g., the H.264 encoding algorithm, such that it is compatible with standards-compliant decoders. However, the present invention is not limited to H.264, but may be implemented in accordance with any video encoding\/decoding system, including systems operating in accordance with the MPEG-4 standard, the Motion Compensated Embedded Zero Block Coding (\u201cMC-EZBC\u201d) standard, and others.","Additionally, other techniques for the decoder power minimization, such as those discussed above, are complementary and can be used in conjunction with the present invention. Notably, the exemplary system as described herein below may be implemented in accordance with the H.264 protocol. However, the present invention is not limited to H.264, but may be implemented in accordance with any video encoding\/decoding system, including systems operating in accordance with the MPEG-4 standard and the Motion Compensated Embedded Zero Block Coding (\u201cMC-EZBC\u201d) standard.","By way of background, generally, when considering the decoder's complexity during video encoding, the optimization problem is formulated as follows.",{"@attributes":{"id":"p-0029","num":"0028"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"munder":{"mi":["min","P"]},"mo":"\u2062","mrow":{"mrow":[{"mi":"D","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"P"}},{"mi":["s","t"],"mo":[".","."]}],"mo":"\u2062"}},{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"P"}},{"msub":{"mi":["R","T"]},"mo":"\u2062","mrow":{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"P"}}}],"mo":["\u2264","\u2264"],"msub":{"mi":["C","T"]}}],"mo":","}},{"mrow":{"mo":["(",")"],"mn":"2"}}]}}}}},"where C is the computational complexity at the decoder. Compared with the problem defined in Equation (1), a constraint on computational complexity is explicitly added. The solution for Equation (2) generally determines the best control variables, P, for each coding unit. Similar to the case for Equation (1), the control variables include quantization parameter, block mode of the motion compensation process, and the associated motion vectors.","Among the control variables, the motion vectors have the largest impact on the decoding complexity. Motion vectors can be of integer or fractional values corresponding to a displacement distance of integral pixels or fractional pixels. When a motion vector is of a sub-pixel value, multi-tap filtering is required to compute interpolation to form a reference block that is needed in the motion compensation process in the decoder. Such interpolation filtering involves huge computational cost and typically significantly increases the overall decoding complexity (the interpolation component constitutes about 50% of the decoding complexity). Although for mobile multimedia applications there are other power consuming components like wireless communication, display, and memory access, the decoding process is typically a significant one. Therefore improving the cost associated with the interpolation process is important for implementing a low-power decoding system, either in hardware or software.","In accordance with an exemplary embodiment of the present invention, the conventional rate-distortion framework is extended based on the Lagrange optimization method to incorporate the computational complexity. To estimate the complexity associated with different types of motion vectors, models are used to approximate the implementation cost involved in the interpolation filtering process.","In addition, in accordance with an exemplary embodiment of the present invention, the rate control algorithm may be extended to handle the joint rate-complexity control issue so that both the targets of rate and complexity can be met. This optimization method intelligently selects the block mode and motion vector type of each coding unit to achieve the highest video quality.","Referring now to , an exemplary diagram for a typical hybrid motion compensation and block-transform video coding system is shown. The interior box components  include the decoding portion (which typically is also simulated in the encoder system for rate control purpose). Additional components of a companion encoder system are shown in exterior box components . The present invention focuses generally on improvements in the motion compensation functions  by way of the motion estimation and mode decision functions . A general discussion of video encoding\/decoding principles follows herein, followed by a discussion of these principles as modified in accordance with exemplary embodiments of the present invention.","Further referring to , the basic decoding unit in a video decoder is a macroblock (MB), which is an array of spatially-adjacent pixels in a video sequence. For exemplary purposes,  is a diagram showing sub-pixel locations within a macroblock.","For each MB, the encoded bit stream may first undergo entropy decoding to obtain the syntax bits (this step is not shown in the figure, but would be known to one of ordinary skill in the art), motion vector V, and quantized coefficients (t), where t is the time index of the image frame. Typical entropy codecs include variable length coding (VLC) and adaptive arithmetical coding (AAC). Inverse quantization is then employed to obtain the transform coefficient d(t), which is further fed to an inverse transform module to reconstruct the pixel value or prediction error d(t), depending on whether intro- or inter-coded mode is utilized during encoding. For inter-coding mode, motion compensation is applied to generate the reference image (t) using motion vector v and previously decoded and buffered reference image (t\u22121). Motion compensation refers to the process of compensating the image displacement due to motion across frames. When the motion vector is of a sub-pixel value, interpolation is needed to compute the reference image. Lastly, by combining the prediction error d(t) and the reference image (t) the decoded image of the current frame is output.","The basic concept of motion estimation is to search for an optimal block with similar values in previous coded frames as the reference signal for the block in current frame so that the encoding cost can be minimized. The optimal reference signal position is indicated by the displacement vector, called a motion vector. Motion estimation applies the basic idea of inter-frame predictive coding. Sometimes, multiple reference signals are used to form motion estimation, for example in bidirectional inter-frame prediction. Motion vectors are entropy encoded in a differential and predictive manner. (See T. Wiegand, G. J. Sullivan, G. Bjontegaard, A. Luthra, \u201cOverview of the H.264\/AVC Video Coding Standard,\u201d IEEE Trans. Circuits Syst. Video Technol., vol 13, pp. 560-576. July 2003, which is incorporated herein by reference).","Compared to motion estimation, motion compensation is the procedure by which the decoder extracts a reference signal from the location indicated by the motion vector. In reconstructing the reference signal, interpolation is a widely adopted technique used to improve the compensation precision when the motion vector has a sub-pixel value. The effectiveness of the sub-pixel motion compensation has been verified in H.263 and subsequent coding standards, at the cost of increasing complexity. Therefore reducing the motion compensation complexity is the most important target for improvement.","H.264 uses up to quarter pixel precision during interpolation. (See T. Wedi; H. G. Musmann, Motion- and aliasing-compensated prediction for hybrid video codingPage(s): IEEE Trans. Circuits Syst. Video Technol., vol 13, pp. 577-586. July 2003, which is incorporated herein by reference). All half-pixel locations undergo 6-tap FIR filtering horizontally and vertically, whenever any one applies. All quarter-pixel locations undergo 2-tap average filtering using integer and half pixels. For example, the following formulae are used to calculate sub pixel b and e:\n\n((520205)+16)\/32\n\n(1)\/2\n","The amount of filtering varies depending on the exact location of the pixel. Referring again to , Table 1 below lists the possible interpolation operations and their associated complexities:",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sub pixel locations and their interpolation complexities"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Sub Pixel Type","Points","Interpolation"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["(0, 0)","G","No"]},{"entry":["(0, \u00bd), (\u00bd, 0)","b, h","1 6-tap"]},{"entry":["(0, \u00bc), (\u00bc, 0), (0, \u00be), (\u00be, 0)","a, c, d, n","1 6-tap + 1 2-tap"]},{"entry":["(\u00bc, \u00bc), (\u00bc, \u00be), (\u00be, \u00bc), (\u00be, \u00be)","e, g, p, r","2 6-tap + 1 2-tap"]},{"entry":["(\u00bd), (\u00bd)","j","7 6-tap"]},{"entry":["(\u00bd, \u00bc), (\u00bc, \u00bd), (\u00be, \u00bd), (\u00bd, \u00be)","i, f, k, q","7 6-tap + 1"]},{"entry":[{},{},"Bilinear"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"It is clear that different interpolation methods have quite different computing complexities. Some up-to-date video codecs may even have more complex interpolation. For example, in recent 3D scalable video coding standards such as MC-EZBC, an 8-tap floating filtering process is used to achieve high interpolation accuracy.","Given the information about the interpolation cost associated with each type of motion vector, the basic premise behind reducing the decoder complexity is to select motion vectors that involve less interpolation complexity while maintaining high video quality. An empirical analysis of some H.264 statistical data shows that depending on the video content, 40% to 80% of motion vectors are located on sub pixels with different interpolation complexities. Therefore the principal approach to complexity reduction is to change motion vectors from high complexity sub pixel positions into low complexity, or even to integer-pixel positions.","In order to further reduce the temporal redundancy and improve the efficiency of motion estimation, H.264 defines a diverse set of block mode options. Besides the conventional modes (intra, forward, backward and bidirectional), two new important modes are introduced: variable block size and SKIP\/DIRECT.","First, unlike earlier coding standards which use a fixed block size (usually 16\u00d716 or 8\u00d78) during motion estimation, H.264 allows for partitioning of an MB into several blocks with variable block size, ranging from 16 pixels to 4 pixels in each dimension. An MB can comprise up to 16 blocks. Each block with reduced size can have individual motion vectors to estimate the local motion at a finer granularity. Though such finer block sizes incur overhead such as extra computation for searching and extra bits for coding the motion vectors, they allow more accurate prediction in the motion compensation process and consequently the residual errors can be considerably reduced (which is generally favorable for the final rate-distortion performance).","Secondly, the SKIP\/DIRECT mode is utilized for the P\/B frame in H.264 motion compensation to further increase the coding efficiency. The spatial\/temporal neighbor motion vectors are used to predict the motion vector of the current block, without sending extra bits to encode the current motion vector. Details regarding the SKIP\/DIRECT modes can be found in the Wiegand et al and Tourapis et al. references, cited and incorporated by reference hereinabove. In the mode decision algorithm used in accordance with the present invention, both the variable-size block mode and the SKIP\/DIRECT mode may be considered during the search process.","The selection of block mode has a direct and substantial impact on the decoder computational complexity, because it determines what kind of motion vectors are recorded in the bit stream. Optimal selection of the block mode and the associated motion vectors are important problems addressed by the present invention. These steps are discussed in greater detail hereinafter.","As discussed above, conventional video coding systems generally encode a video bit stream by solving the optimization problem defined in Equation (1). The main control variables P involved in this procedure include motion vector v, block mode M and quantization parameter QP. There is complex interaction between the choices of these variables and thus the optimal solution is difficult to achieve. In practice, compromise approaches are taken and approximate solutions are often developed. For example, typically QP is determined through some empirical models and updated throughout the video sequence by some rate control algorithms. Given QP, the other variables, motion vector and block mode, are decided by applying some rate-distortion optimization process. A survey of these prior art procedures is described in G. J. Sullivan and T. Wiegand, Rate-Distortion Optimization for Video Compression IEEE Signal Processing Magazine, Vol. 15, Num. 6, pp. 74-90, November 1998, which is incorporated herein by reference. A brief background summary follows.","Specifically, for each block B with a block mode M, the motion vector associated with the block is selected through a rate-distortion joint cost function:",{"@attributes":{"id":"p-0050","num":"0049"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"msup":{"mi":"V","mo":"*"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","M"],"mo":","}}},{"munder":{"mrow":[{"mi":["arg","min"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"V","mo":"\u2208","mrow":{"mi":"sup","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["{","}"],"mi":"V"}}}]},"mo":"\u2062","msubsup":{"mi":["J","MOTION"],"mrow":{"mi":["R","D"],"mo":","}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":["V","B"],"mo":"\u2758"},"mo":",","mi":"M"}},{"munder":{"mrow":[{"mi":["arg","min"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"V","mo":"\u2208","mrow":{"mi":"sup","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["{","}"],"mi":"V"}}}]},"mo":"\u2062","mrow":{"mo":"{","mrow":{"mrow":{"msub":{"mi":["D","DFD"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["V","B"],"mo":"\u2758"},"mo":",","mi":"M"}}},"mo":"+"}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mi":{},"mo":["\u2062","}"],"mrow":{"msub":{"mi":["\u03bb","MOTION"]},"mo":"\u2062","mrow":{"msub":{"mi":["R","MOTION"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["V","B"],"mo":"\u2758"},"mo":",","mi":"M"}}}}}}}]}},{"mrow":{"mo":["(",")"],"mn":"3"}}]}}}},"br":{},"sub":["MOTION ","DFD ","MOTION","MOTION ","DFD","MOTION "],"sup":"R,D"},"In a similar manner the block mode M for an MB is decided by the following.",{"@attributes":{"id":"p-0052","num":"0051"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"msup":{"mi":"M","mo":"*"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["MB","QP"],"mo":","}}},{"munder":{"mrow":[{"mi":["arg","min"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"M","mo":"\u2208","mrow":{"mi":"sup","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["{","}"],"mi":"M"}}}]},"mo":"\u2062","msubsup":{"mi":["J","MODE"],"mrow":{"mi":["R","D"],"mo":","}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":["M","MB"],"mo":"\u2758"},"mo":",","mi":"QP"}},{"munder":{"mrow":[{"mi":["arg","min"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"M","mo":"\u2208","mrow":{"mi":"sup","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["{","}"],"mi":"M"}}}]},"mo":"\u2062","mrow":{"mo":"{","mrow":{"mrow":[{"msub":{"mi":["D","REC"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["M","MB"],"mo":"\u2758"},"mo":",","mi":"QP"}}},{"msub":[{"mi":["\u03bb","MODE"]},{"mi":["R","REC"]}],"mo":"\u2062"}],"mo":"+"}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mi":{},"mo":["\u2062","}"],"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["M","MB"],"mo":"\u2758"},"mo":",","mi":"QP"}}}}}]}},{"mrow":{"mo":["(",")"],"mn":"4"}}]}}}},"br":{},"sub":["REC ","REC ","MODE","M ","M","MODE "],"sup":"R,D"},"The Lagrange multipliers used in the above two cost functions determine the relative weights between signal quality and bit rate. To simplify the search process, an empirically derived relationship as the following is typically used in practice in the prior art. The square root relationship is partly due to the fact that SAD is used in modeling Dwhile SSD is used for D.\n\n\u03bb=\u221a{square root over (\u03bb)}\u2003\u2003(5)\n","Rate control (RC) is the procedure of adjusting control variables so that the target rate requirement can be achieved while optimizing the overall video quality. Given a target bit rate, the average allocated bit rate may be computed for each basic coding unit. Then the Lagrange optimization method may be used to find the optimal set of control variables. However, searching over the entire variable space is very complex. In practice, most implementations use empirical models to restrict the search space. For example, a popular method, called rate-quantization modeling, maps the target bit rate to the quantization parameter, from which the Lagrange multipliers are decided. In addition, since coding of a data unit may not result in a bit rate that exactly matches the target, a separate process, called buffer management, may be used to monitor the available bit rate budget for the remaining data units and thus update the allocated recourse. A brief discussion of these processes is provided below.","A rate-Quantization (RQ) model describes the relationship between QP and the bit rate. A widely adopted quadratic RQ model, as described in T. Chiang and Y.-Q. Zhang, \u201cA New Rate Control Scheme Using Quadratic Rate Distortion Model,\u201d IEEE Trans. Circuits Syst. Video Technol., Vol. 7, pp. 246-250, February 1997, which is fully incorporated herein by reference, is:\n\n()\u2003\u2003(6)\n\nwhere D is the source complexity of the video signal, and usually measured using the motion estimation prediction errors (such as SAD), and {P, P} are model parameters. Some systems use P=0 for simplicity. A typical RQ modeling procedure involves two major steps: model estimation and QP prediction. First several basic coding units are coded using some preset QP values. The coding units may include a certain number of MBs or one whole frame. The resulting rate-quantization-distortion (R-Q-D) points are collected. The model in Equation (6) is then estimated based on the observations. The estimated model can then be used to determine the QP value for the next coding unit based on the target bit rate Rand source complexity Dfor the new unit. The former is determined by the buffer management process to be described below, and the latter is predicted using previous observations of the source complexity. Usually the source complexity is assumed to vary gradually and can be estimated using some simple relationship such as a linear model. Once coding of the new unit is completed, new observations of the R-Q-D points are collected and used to update the estimation of the RQ model in a sliding window manner. Namely, the oldest R-Q-D point is purged and the latest point is added to update the model.\n","The buffer management employs a virtual buffer to simulate the behavior of the data buffer on the decoder side. It is an important component in rate control in order to adjust the target bit rate for each coding unit and avoid the problem of buffer overflow or underflow. For example, given a target bit rate for the video sequence, the average bit rate allocation for each Group of Pictures (GOP) can be computed, and the allocated bit rate, R, for a new frame to be coded (such as P frame) can be determined by monitoring the actual number of bits spent on the previous frames.","In H.264, given the target rate and QP for the coding unit, the following empirical relationship is often used to determine the Lagrange multiplier needed in the rate-distortion tradeoff optimization.",{"@attributes":{"id":"p-0058","num":"0057"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":["\u03bb","MODE"]},"mo":"=","mrow":{"mn":"0.85","mo":"\u00d7","msup":{"mn":"2","mfrac":{"mrow":{"mi":"QP","mo":"-","mn":"12"},"mn":"3"}}}}},{"mrow":{"mo":["(",")"],"mn":"7"}}]}}}}},"Such an empirical model is useful to simplify the search process in the Lagrange optimization method, while practical implementations have often shown satisfactory performance. Other parameters such as \u03bbcan also be determined according to Equation (5).","The present invention is an improvement on the above procedures and provides a new system and method for complexity-adaptive motion estimation and mode decision (\u201cCAMED\u201d). In accordance with an exemplary embodiment of the present invention, given defined metrics for signal distortion and computational complexity, the tradeoff between video quality and resource consumption (both bit rate and computational complexity) may be considered to approximate the optimal motion vectors and block mode used in the motion compensation process in the decoder, thereby reducing decoding complexity and power consumption.","A system and method of the present invention may consist of several sub-components: a rate-distortion-complexity (\u201cR-D-C\u201d) joint optimization framework, a complexity cost function, and a complexity control algorithm. The R-D-C framework extends the previously discussed Lagrange optimization framework to incorporate the complexity term. The complexity cost function provides quantitative measurements of the required computation for each motion vector type. The complexity control algorithm is used to control the complexity over different coding units to meet the overall target complexity.","The present invention provides a solution to the problem defined in Equation (2), with an explicit Lagrange term to model the complexity cost. Therefore, in accordance with an exemplary embodiment of the present invention, the motion vectors may be selected through a rate-distortion-complexity joint cost function as follows:",{"@attributes":{"id":"p-0063","num":"0062"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"msubsup":{"mi":["V","C"],"mo":"*"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","M"],"mo":","}}},{"munder":{"mrow":[{"mi":["arg","min"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"V","mo":["\u2208","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"sup","mo":"\u2062","mrow":{"mo":["{","}"],"mi":"V"}}}]},"mo":"\u2062","msubsup":{"mi":["J","MOTION"],"mrow":{"mi":["R","D","C"],"mo":[",",","]}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":["V","B"],"mo":"|"},"mo":",","mi":"M"}},{"munder":{"mrow":[{"mi":["arg","min"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"V","mo":["\u2208","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"sup","mo":"\u2062","mrow":{"mo":["{","}"],"mi":"V"}}}]},"mo":"\u2062","mtable":{"mtr":[{"mtd":{"mrow":{"mo":"{","mrow":{"mrow":{"msubsup":{"mi":["J","MOTION"],"mrow":{"mi":["R","D"],"mo":","}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["V","B"],"mo":"|"},"mo":",","mi":"M"}}},"mo":"+"}}}},{"mtd":{"mrow":{"mrow":{"msub":{"mi":["\u03b3","MOTION"]},"mo":"\u2062","mrow":{"msub":{"mi":["C","MOTION"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["V","B"],"mo":"|"},"mo":",","mi":"M"}}}},"mo":"}"}}}]}}],"mo":["=","\u2062"],"mi":{}}}}]}},{"mrow":{"mo":["(",")"],"mn":"8"}}]}}}}},"where Cis the complexity cost function associated with the selected motion vector (V|B,M), \u03b3is the Lagrange multiplier for the complexity term, J(v) is the rate-distortion joint cost function defined in Equation (3), and J(v) is the rate-distortion-complexity joint cost function.","Similar to the earlier case described in Equation (4), the block mode search process of the present invention may be performed according to the following.",{"@attributes":{"id":"p-0066","num":"0065"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"msubsup":{"mi":["M","C"],"mo":"*"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["MB","QP"],"mo":","}}},{"munder":{"mrow":[{"mi":["arg","min"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"M","mo":["\u2208","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"sup","mo":"\u2062","mrow":{"mo":["{","}"],"mi":"M"}}}]},"mo":"\u2062","msubsup":{"mi":["J","MODE"],"mrow":{"mi":["R","D","C"],"mo":[",",","]}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":["M","MB"],"mo":"|"},"mo":",","mi":"QP"}},{"munder":{"mrow":[{"mi":["arg","min"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"M","mo":["\u2208","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"sup","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["{","}"],"mi":"M"}}}]},"mo":"\u2062","mtable":{"mtr":[{"mtd":{"mrow":{"mo":"{","mrow":{"mrow":{"msubsup":{"mi":["J","MOTION"],"mrow":{"mi":["R","D"],"mo":","}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["M","MB"],"mo":"|"},"mo":",","mi":"QP"}}},"mo":"+"}}}},{"mtd":{"mrow":{"mrow":{"msub":{"mi":["\u03b3","MODE"]},"mo":"\u2062","mrow":{"msub":{"mi":["C","MODE"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["M","MB"],"mo":"|"}}}},"mo":"}"}}}]}}],"mo":["=","\u2062"],"mi":{}}}}]}},{"mrow":{"mo":["(",")"],"mn":"9"}}]}}}},"br":{},"sub":["MODE ","MODE ","MODE","MODE"],"sup":["R,D","R,D,C"]},"The effect of \u03b3=0 is apparent in view of the above. When \u03b3=0, the solutions of Equations (8) and (9) are identical with the ones in Equations (3) and (4), namely no consideration is given to the complexity constraint and many motion vectors may be of sub-pixel values in order to minimize the distortion. When \u03b3=\u221e, all motion vectors are forced to integer pixel locations in order to minimize the complexity involved in interpolation for sub-pixel locations. Clearly there is a tradeoff between these two extremes to balance the performance in terms of quality and complexity.","For simplification, restrictions may be adopted, like those described in Equation (5), to limit the search space. For example, the following relationship may be used to link \u03b3and \u03b3:\n\n\u03b3=\u221a{square root over (\u03b3)}\u2003\u2003(10)\n","In the joint cost function described above, a quantitative model may be used to estimate the complexity associated with each candidate motion vector and block mode. As discussed above, the computational complexity is heavily influenced by the type of the motion vector (integer, half-pixel, or quarter-pixel) and the interpolation filters used in the motion compensation process. Focusing on the interpolation filtering cost, quantitative estimates of such complexities can be approximated by the number of filtering operations needed in interpolation, such as those listed in Table 1. For example, using the same 6-tap filter and 2-tap filter implementations, the complexity of each motion vector type is as follows.",{"@attributes":{"id":"p-0070","num":"0069"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["C","B"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"V"}},{"msub":{"mi":["N","B"]},"mo":"\u00b7","mrow":{"msub":{"mi":["c","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"V"}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"11"}}]},{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["c","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"V"}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mi":["V","is","integer","MV"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mo":"\u2062"}}}]},{"mtd":[{"msub":{"mi":"e","mn":"6"}},{"mrow":{"mrow":{"mi":["V","is","subpixel","b"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":",","mi":"h"}}]},{"mtd":[{"mrow":{"msub":[{"mi":"e","mn":"6"},{"mi":"e","mn":"2"}],"mo":"+"}},{"mrow":{"mrow":{"mi":["V","is","subpixel","a"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":[",",",",","],"mi":["c","d","n"]}}]},{"mtd":[{"mrow":{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":"e","mn":"6"}},"mo":"+","msub":{"mi":"e","mn":"2"}}},{"mrow":{"mrow":{"mi":["V","is","subpixel","e"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":[",",",",","],"mi":["g","p","r"]}}]},{"mtd":[{"mrow":{"mn":"7","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":"e","mn":"6"}}},{"mrow":{"mi":["V","is","subpixel","j"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]},{"mtd":[{"mrow":{"mrow":{"mn":"7","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":"e","mn":"6"}},"mo":"+","msub":{"mi":"e","mn":"2"}}},{"mrow":{"mrow":{"mi":["V","is","subpixel","i"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":[",",",",","],"mi":["f","k","q"]}}]}]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"12"}}]}]}}},"br":{},"sub":["B","P","B ","6","2","6 "]},{"@attributes":{"id":"p-0071","num":"0070"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["c","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"V"}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mi":["integer","MV"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}]},{"mtd":[{"mn":"1"},{"mrow":{"mrow":[{"mi":["subpixel","a"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mrow":{"mi":"h","mo":"&"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"n"}],"mo":[",",",",",",","],"mi":["b","c","d"]}}]},{"mtd":[{"mn":"2"},{"mrow":{"mrow":{"mi":["subpixel","e"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":[",",",",","],"mi":["g","p","r"]}}]},{"mtd":[{"mn":"7"},{"mrow":{"mrow":{"mi":["subpixel","i"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":[",",",",",",","],"mi":["j","f","k","q"]}}]}]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"13"}}]}}}}},"Equations (11) and (13) may be used to estimate the computational complexity based on the interpolation operation\u2014these models provide platform-independent modeling. Alternatively, the complexity cost may be derived from specific software or hardware implementations (platform-dependant modeling). The following are two examples of platform-dependent modeling in accordance with exemplary embodiments of the present invention.","The complexity cost functions defined in Equation (11) and (13) are also considered to be pixel-based in that the complexity is calculated for each pixel independently without considering the reusability of previous calculated pixel (or sub pixel) values. For block-based motion compensation as adopted in H.264, some interpolations can be saved by directly using previous computed results. Again according to the H.264 standard description, the following categories of sub pixels may be considered:\n\n","Therefore, block-based complexity may be modeled as (after value scaling):",{"@attributes":{"id":"p-0075","num":"0079"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"msub":{"mi":["C","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"V"}},"mo":"=","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mi":["V","is","integer","MV"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]},{"mtd":[{"mn":"4"},{"mrow":{"mrow":[{"mi":["V","is","subpixel","a"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mi":["h","and","n"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":[",",",",",",","],"mi":["b","c","d"]}}]},{"mtd":[{"mn":"8"},{"mrow":{"mrow":{"mi":["V","is","subpixel","e"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":[",",",",","],"mi":["g","p","r"]}}]},{"mtd":[{"mn":"13"},{"mrow":{"mrow":{"mi":["V","is","subpixel","i"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":[",",",",",",","],"mi":["j","f","k","q"]}}]}]}}},{"mrow":{"mo":["(",")"],"mn":"14"}}]}}}}},"The model in Equation (14) above can even be further fine tuned considering variable block size implementation during MC, in accordance with the lookup table below:",{"@attributes":{"id":"p-0077","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Lookup table for complexity cost using variable block size"},{"entry":"MC implementation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Mode","Integer","1 6-tap","2 6-tap","7 6-tap"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SKIP\/DIRECT","0","256","512","592"]},{"entry":["16 \u00d7 16","0","256","512","592"]},{"entry":["16 \u00d7 8\u2002","0","128","256","296"]},{"entry":["\u20028 \u00d7 16","0","128","256","296"]},{"entry":["8 \u00d7 8","0","64","128","168"]},{"entry":["8 \u00d7 4","0","32","64","84"]},{"entry":["4 \u00d7 8","0","32","64","84"]},{"entry":["4 \u00d7 4","0","16","32","52"]},{"entry":["Intra","0","0","0","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"In an exemplary hardware implementation of an embodiment of the present invention, each interpolation operation can be divided into a number of basic operators such as addition, shifts, and\/or multiplications. In this case, {e,e} can be modeled with more detail, such as:",{"@attributes":{"id":"p-0079","num":"0083"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["e","i"]},"mo":"=","mrow":{"munderover":{"mo":"\u2211","mi":"j","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"\u2062","mrow":{"mi":"\u03c1","mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":[{"mi":"N","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["o","j"]}}},{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["o","j"]}}}]}}},{"mi":"i","mo":"=","mn":"2"}],"mo":[",",","],"mn":"6"}},{"mrow":{"mo":["(",")"],"mn":"15"}}]}}}},"br":[{},{},{}],"sub":["j ","j","j ","j","j","6","add","shift","add","shift "],"in-line-formulae":[{},{}],"i":["e","=P","P","P"]},"Each block may be associated with multiple reference blocks, each of which needs a motion vector. For example, for bidirectional prediction, each block may need two motion vectors for forward and backward prediction respectively. Thus, the computational cost for a block B with the block mode M is calculated as:",{"@attributes":{"id":"p-0081","num":"0085"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["C","MOTION"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["V","B"],"mo":"|"},"mo":",","mi":"M"}}},{"munderover":{"mo":"\u2211","mi":"j","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["c","B"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"msub":{"mi":"V","mrow":{"mi":"j","mo":","}},"mo":"\u2062","mi":"M"},"mo":",","mi":"B"}}}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"17"}}]}}}},"br":{}},"Each MB may consist of several smaller blocks, depending on the block mode, M. The overall computational cost associated with a MB and a block mode can be calculated as:",{"@attributes":{"id":"p-0083","num":"0087"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["C","MODE"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["M","MB"],"mo":"|"}}},{"munderover":{"mo":"\u2211","mi":"i","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mi":"j","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["c","B"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["B","i"]},{"mi":["V","j"]}],"mo":[",",","],"mi":"MB"}}}}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"18"}}]}}}},"br":{}},"Equations (8) and (9) use the Lagrange multiplier to formulate R-D-C combined optimization problems. Assuming that the selection of motion vector and block mode for a certain MB is independent of behaviors in other MBs (which is a reasonable approximation of the real case), at the optimal solution each MB will have the same Lagrange multiplier (\u03b3, \u03b3). This is an important property of the Lagrange multiplier. In other words, given a specific {circumflex over (\u03b3)}and considering Equation (10), the bit stream with complexity C({circumflex over (\u03b3)}) can be derived. This {circumflex over (\u03b3)}is (approximately) the optimal solution for the following problem:",{"@attributes":{"id":"p-0085","num":"0089"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"munder":{"mi":"min","mrow":{"mo":["{","}"],"mrow":{"mover":[{"mi":["V","_"]},{"mi":["M","_"]}],"mo":","}}},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"mrow":[{"msup":{"mi":"J","mrow":{"mi":["R","D"],"mo":","}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["V","i"]},{"mi":["M","i"]}],"mo":","}}},{"mi":["s","t"],"mo":[".","."]}],"mo":"\u2062"}}},{"mrow":[{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["V","i"]},{"mi":["M","i"]}],"mo":","}}}},{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mover":{"mi":"\u03b3","mo":"^"},"mi":"MODE"}}}],"mo":"\u2264"}],"mo":","}},{"mrow":{"mo":["(",")"],"mn":"19"}}]}}}}},"where {right arrow over (V)}=(V, V. . . V) and {right arrow over (M)}=(M, M. . . M) are the motion vectors and block modes for all MBs respectively, Vand Mare the motion vector and block mode for iMB respectively, Jis the R-D cost function, and C(V, M) is the complexity cost function. Unfortunately, the complexity level C({circumflex over (\u03b3)}) associated with {circumflex over (\u03b3)}cannot be known in advance unless the bit stream has been encoded. Therefore, the Lagrange multiplier has to be adjusted in order to match certain target complexity level. This procedure implemented in the context of the present invention is referred to as \u201ccomplexity control.\u201d","Complexity control, analogous to the rate control process described above, is a process to allocate the complexity resource among the coding units and to determine parameters like Lagrange multiplier \u03b3to be used in the optimization procedure. In the exemplary embodiment of the present invention described above, the allocated bit rate is mapped to the quantization parameter, which in turn is used to find the Lagrange multiplier \u03bb. In the following exemplary embodiment of the present invention, two components of the complexity control algorithm are described\u2014complexity modeling and buffer management. The former is used to characterize the relationship between the target complexity and the Lagrange multiplier \u03b3. The latter is for monitoring the complexity usage and updating the available computational resource for each new data unit.","In complexity control a feasible modeling of complexity and control parameters (\u03b3in this case) is necessary. One of the objectives of this modeling is to identify the relationship between the target complexity and the optimization control parameter, \u03b3. Based on experimentation, there is an approximately linear relationship between the complexity value and log of the Lagrange multiplier, and the type of the frame (B or P) greatly influences this relationship.","A reasonable model based on these observations is as follows:\n\n(\u03b3)=(ln(\u03b3)+)\u2003\u2003(20)\n\nwhere C is the complexity, D is a factor measuring the video source complexity similar to that used in Equation (6) for rate control. K, Kare the model parameters obtained during the coding procedure. Due to different coding mechanism, P and B frames will have distinguished model parameters and may need to be handled separately.\n","The above model is driven by empirical simulation observations. The linear dependence of the computational complexity on the signal source complexity is also intuitive\u2014the more complex the signal source is, the higher the accuracy required to estimate the motion vector, and thus there is a larger gain in using sub-pixel motion vectors, resulting in an increased computational cost.","Using this model, the Lagrange multiplier \u03b3(t) for the current coding unit t can be determined by the following:",{"@attributes":{"id":"p-0092","num":"0096"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["\u03b3","MODE"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mi":"exp","mo":"\u2062","mrow":{"mo":["{","}"],"mfrac":{"mrow":[{"mrow":[{"mi":"C","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"msub":{"mi":"K","mn":"0"},"mo":"\u2062","mrow":{"mi":"D","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}],"mo":"-"},{"msub":{"mi":"K","mn":"1"},"mo":"\u2062","mrow":{"mi":"D","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}]}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"21"}}]}}}},"br":{},"sub":"MODE"},"Referring now to , a flow chart for a method for optimizing the selection of motion vectors and motion compensation block modules in a video decoder in accordance with the above-described present invention is shown. In step , an input video data sequence is received. Next, in step , a target complexity level for the video decoder is determined. Then, in step , a Lagrange multiplier is determined. Next, in step , for each macroblock, a motion vector is calculated for one or more of the H.264 block modes. This may preferably be performed for every block mode available in H.264 (or the applicable video standard). Next, in step , for each macroblock, a best block mode is selected, based on the Lagrange multiplier. Finally, in step , a complexity-control algorithm, as described in detail above, is applied to encode the received input video data sequence in accordance with the identified target complexity level, such that, upon decoding, a consistent complexity level is maintained throughout decoding.","Referring now to , a flow chart for another method in accordance with the above-described present invention for selecting motion vectors in an optimized video decoder is shown. In step , an input video data sequence comprising one or more macroblocks is received. In step , for each macroblock, at least one inter-predictive block mode is enumerated. In step , for each block of each enumerated block mode, one or more motion vectors that yields the minimum rate-distortion-complexity is selected. Finally, in step , the selected one or more motion vectors is stored.","Referring now to , a flow chart for another method in accordance with the above-described present invention for selecting a block mode in an optimized video decoder is shown. In step , an input video data sequence is received. Next, in step , one or more possible block modes for each macroblock is selected. In step , one or more motion vectors for each block mode is received. A rate-distortion-complexity cost for each block mode is then calculated in step . In step , for each macroblock, a block mode is selected that yields a minimum rate-distortion-complexity cost function. Finally, in step , the selected block mode is stored for further processing.","In accordance with an exemplary embodiment of the present invention, a complexity buffer may also be implemented. A complexity buffer is a virtual buffer used to simulate the complexity usage status on the decoder side. It is analogous to the rate buffer used in the rate control to update the estimation of available resources and avoid issues of buffer overflow or underflow. Denoting CGOP the remaining complexity budget in one GOP, N, Nthe remaining numbers of P, B frames respectively, and \u03b7 the complexity ratio between P and B, which is updated during video coding, the target complexity levels for P, B frame C, Cmay be calculated using the following equations:",{"@attributes":{"id":"p-0097","num":"0101"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mfrac":{"msub":[{"mi":["C","B"]},{"mi":["C","P"]}]},"mo":"=","mi":"\u03b7"}},{"mrow":{"mo":["(",")"],"mn":"22"}}]},{"mtd":[{"mrow":{"mrow":{"mrow":[{"msub":[{"mi":["N","P"]},{"mi":["C","P"]}],"mo":"\u2062"},{"msub":[{"mi":["N","B"]},{"mi":["C","B"]}],"mo":"\u2062"}],"mo":"+"},"mo":"=","msub":{"mi":["C","GOP"]}}},{"mrow":{"mo":["(",")"],"mn":"23"}}]}]}}}},"Once C, Care available, \u03b3(t) is determined using the models and techniques described above. The formulations in Equations (22) and (23) assume the basic coding unit as one frame. It can be easily extended to smaller units for a finer granularity.","Notably, experiments involving an exemplary implementation of the present invention using an H.264 codec over different video sequences, different bit rates, and different complexity levels demonstrated that up to 60% of the interpolation complexity can be saved at the decoder without incurring noticeable quality loss (within 0.2 dB). Even for challenging video clips, 33% of the complexity can be reduced with quality difference less than 0.3 dB. Accordingly, the present invention can improve video decoding systems to reliably meet target complexity requirements for a wide range of video content.","As noted previously, the exemplary system as described herein is not limited to H.264, but may be implemented in accordance with any video encoding\/decoding system, including systems operating in accordance with the MPEG-4 standard, the Motion Compensated Embedded Zero Block Coding (\u201cMC-EZBC\u201d) standard, and others. Additionally, the present invention may be implemented using software, hardware, or some combination thereof, as would be understood by one of ordinary skill in the art. The scope of the invention is not limited to any particular implementation of the inventive system and method described herein.","The foregoing merely illustrates the principles of the invention. Various modifications and alterations to the described embodiments will be apparent to those skilled in the art in view of the teachings herein. It will thus be appreciated that those skilled in the art will be able to devise numerous systems and methods which, although not explicitly shown or described herein, embody the principles of the invention and are thus within the spirit and scope of the invention.",{"@attributes":{"id":"p-0102","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["[1] T. Wiegand, G. J. Sullivan, G. Bjontegaard, A. Luthra, \u201cOverview of the H.264\/AVC Video Coding Standard,\u201d IEEE Trans. Circuits Syst. Video Technol., vol 13, pp. 560-576. July 2003.","[2] T. Wedi; H. G. Musmann, Motion- and aliasing-compensated prediction for hybrid video codingPage(s): IEEE Trans. Circuits Syst. Video Technol., vol 13, pp. 577-586. July 2003.","[3] V. Lappalainen, A. Hallapuro, and T. D. H\u00e4m\u00e4l\u00e4inen, \u201cComplexity of Optimized H.26L Video Decoder Implementation,\u201d IEEE Trans. Circuits Syst. Video Technol., vol 13, pp. 717-725. July 2003","[4] A. M. Tourapis, F. Wu, S. Li, \u201cDirect mode coding for bi-predictive pictures in the JVT standard\u201d, ISCAS2003, vol. 2, 700-703, Thailand, 2003.","[5] G. J. Sullivan and T. Wiegand, Rate-Distortion Optimization for Video Compression IEEE Signal Processing Magazine, Vol. 15, Num. 6, pp. 74-90, November 1998","[6] T. Chiang and Y.-Q. Zhang, \u201cA New Rate Control Scheme Using Quadratic Rate Distortion Model,\u201d IEEE Trans. Circuits Syst. Video Technol., Vol. 7, pp. 246-250, February 1997","[7] T.-C. Chen, Y.-C. Huang and L.-G. Chen, \u201cFull Utilized and Resuable Architecture for Fractional Motion Estimation of H.264\/AVC\u201d, ICASSP2004, Montreal, Canada, May 17-21, 2004","[8] X. Zhou, E. Li, and Y.-K. Chen, \u201cImplementation of H.264 Decoder on General-Purpose Processors with Media Instructions\u201d, in Proc. of SPIE Visual Communications and Image Processing, January 2003","[9] National's PowerWise\u2122 technology. http:\/www.national.com\/appinfo\/power\/powerwise.html","[10] Y. Eisenberg, C. E. Luna, T. N. Pappas, R. Berry, A. K. Katsaggelos, Joint source coding and transmission power management for energy efficient wireless video communications, CirSysVideo(12), No. 6, June 2002, pp. 411-424.","[11] Q. Zhang, W. Zhu, Zu Ji, and Y. Zhang, \u201cA Power-Optimized Joint Source Channel Coding for Scalable Video Streaming over Wireless Channel\u201d, IEEE International Symposium on Circuits and Systems (ISCAS) 2001, May, 2001, Sydney, Australia.","[12] X. Lu, E. Erkip, Y. Wang and D. Goodman, \u201cPower efficient multimedia communication over wireless channels\u201d, IEEE Journal on Selected Areas on Communications, Special Issue on Recent Advances in Wireless Multimedia, Vol. 21, No. 10, pp. 1738-1751, December, 2003","[13] H. Kim and Y. Altunbasak, \u201cLow-complexity macroblock mode selection for the H.264\/AVC encoders,\u201d IEEE Int. Conf. on Image Processing, Suntec City, Singapore, October 2004","[14] A. Ray and H. Radha, \u201cComplexity-Distortion Analysis of H.264\/JVT Decoder on Mobile Devices,\u201d Picture Coding Symposium (PCS), December 2004","[15] K. Lengwehasatit and A. Ortega, \u201cRate Complexity Distortion Optimization for Quadtree-Based DCT Coding\u201d, ICIP 2000, Vancouver, BC, Canada, September 2000.","[16] Z. He, Y. Liang, L. Chen, I. Ahmad, and D. Wu, \u201cPower-Rate-Distortion Analysis for Wireless Video Communication under Energy Constraints,\u201d IEEE Transactions on Circuits and Systems for Video Technology, Special Issue on Integrated Multimedia Platforms, 2004.","[17] B. Girod, A. Aaron, S. Rane and D. Rebollo-Monedero, \u201cDistributed video coding,\u201d , Special Issue on Video Coding and Delivery, 2005.","[18] A. M. Tourapis. \u201cEnhanced Predictive Zonal Search for Single and Multiple Frame Motion Estimation,\u201d Proceedings of Visual Communications and Image Processing 2002 (VCIP-2002), San Jose, Calif., January 2002, pp. 1069-79.","[19] H.-Y. Cheong, A. M. Tourapis, \u201cFast Motion Estimation within the H.264 codec,\u201d in proceedings of ICME-2003, Baltimore, Md., Jul. 6-9, 2003","[20] M. Schaar, H. Radha, Adaptive motion-compensation fine-granular-scalability (AMC-FGS) for wireless video, IEEE Trans. on CSVT, vol, 12, no. 6, 360-371, 2002."]}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
