---
title: Methods and apparatus for reducing the number of server interactions in network-based applications using a dual-MVC approach
abstract: In accordance with a dual-MVC (Model-View-Controller) approach of the invention, the client machine maintains part of the Model, eliminating many round-trips to the server. The invention provides an implementation approach for constructing the frame(s) contained in the client's browser software to allow it to be refreshed locally. The invention addresses development and maintenance by specifying a library of functions that a programmer can use to construct the View and Controller on the client machine. When part of the Model is maintained on the client, the client has the ability to respond to user interaction without paying the performance penalty of continually interacting with the server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07702719&OS=07702719&RS=07702719
owner: International Business Machines Corporation
number: 07702719
owner_city: Armonk
owner_country: US
publication_date: 20000208
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["The present invention is related to network-based client\/server applications and, more particularly, to methods and apparatus for reducing the number of server interactions in world wide web-based applications using a dual Model-View-Controller approach.","Typical world wide web (e.g., Internet\/Intranet) applications allow users to access and update data on remote servers. The remote server contains the master application data and the client displays views of this data. Examples of such applications include a help desk, life insurance underwriting, health insurance pre-certification for medical procedures, and automated teller machines.","Historically (circa 1970), applications executed on large mainframe systems (servers), to which clients connected via \u201cdumb terminals,\u201d e.g., Teletypes, DEC VT100, IBM 327x-series terminals, etc. In these architectures, very little processing was done on the client side. Subsequently (circa 1980), as hardware became cheaper, some of the processing was moved to the client-side hardware, in so-called \u201cfat-client\u201d architectures. A fat client maintains some of the application state, enabling some processing to occur locally thus eliminating round-trips to the server.","Fat-client applications can be described in terms of the MVC (Model-View-Controller) paradigm. The MVC paradigm is described, for example, in G. E. Krasner and S. T. Pope, \u201cA Cookbook for Using the Model-View-Controller User Interface Paradigm in SmallTalk-80,\u201d Journal of Object-Oriented Programming, 1(3):26-49, August\/September 1988, the disclosure of which is incorporated herein by reference. In this paradigm, the \u201cModel\u201d contains the data, rules, and algorithms affecting the data. The \u201cView\u201d is a screen or window representation of a subset of the model that the application chooses to display. The \u201cController\u201d is the logic that processes user requests, such as pressing a button. The Controller causes the Model to be changed and\/or the View to be refreshed.","Fat-client applications may maintain a Model and Controller on the server but never maintain a View or View Generation Logic (VGL) on the server. Instead, View and VGL are maintained solely by the fat client.","While fat-client applications provided improved response time, the distribution and maintenance of the client software and databases was problematic. Users tended to customize their client system, and this made it difficult to develop a client-side software base that would work properly on all systems. In addition, when the client software needed to be updated, a company had to figure out how to update all the client machines in the field.","Applets (see http:\/\/java.sun.com\/applets\/index.html) are one implementation of the fat-client architecture. When the user starts the application, or while running the application, the server downloads part of the application to the client's machine to execute locally. This improves performance because round-trips to the server are lessened. However, when the applet is first invoked, it must be downloaded to the client, which in practice can take a significant length of time. Also, in practice, web browsers often support different levels of Java Virtual Machines (JVMs). Because an applet is interpreted by the JVM, the difference in JVMs causes inconsistent operation of applets on different browsers or even different versions of the same browser.","More recently (circa 1994), the development and popularization of the world wide web has led towards a so-called \u201cthin-client\u201d application architecture. In this architecture, most of the application logic again executes on the server, with only the browser display logic, i.e., application-independent display logic, executing inside the client-side web browser software. Here the browser is the client, and displays a View. Each time the user interacts with the View, the remote server is notified to update the View and\/or Model.","Another implementation of client\/server interaction over the web uses Dynamic HyperText Markup Language (DHTML). DHTML is described, for example, in D. Goodman, \u201cDynamic HTML, The Definitive Reference,\u201d O'Reilly, 1998, the disclosure of which is incorporated herein by reference. DHTML is a superset of HTML (HyperText Markup Language) which includes JavaScript and Cascading Style Sheets (CSS). JavaScript can be used to implement much of the same functionality that applets provide, is in practice more portable between browsers, and is quicker to download.","Although fat-client architectures provide the most flexibility and performance, their maintenance and distribution problems, together with the popularity of the web, have led many application developers to adopt thin-client architectures for new applications. A problem with this architecture is that network communication delays during server interactions again lead to reduced performance.","Therefore, a need exists for a new Model-View-Controller architecture for Internet\/Intranet applications which does not require continual network communication between the client and server.","The invention relates to web applications and, more particularly, to an architecture and method of programming which improves performance and eases the development and maintenance effort. The invention addresses performance by employing a dual-MVC approach, in which a subset of the application's Model-View-Controller reside on the client, and the full Model-View-Controller and View-Generating-Logic reside on the server, thereby reducing the number of required server interactions. In contrast to the fat-client architecture, the invention does not require any application installation or persistence on the client.","More specifically, the classic fat-client implementation requires that the user (or administrator) physically install the client software on the client machine, and the application will require the long-term use of persistent storage (i.e., disk space) on the client machine. For example, consider the well-known tax preparation assistance software program known as \u201cTurboTax\u201d as a fat-client application. A CDROM is required to run the install process. After installation, the program uses a sizable amount of disk space, both for its own program\/data files and for the user's tax return. From time to time, e.g., during electronic filing of a tax return, \u201cTurboTax\u201d interacts with a remote server as a (fat) client.","The applet approach avoids some of the problems of fat clients, because the applet is downloaded automatically and does not make long-term use of disk space. However, the applet may take a long time to download, and it is difficult in practice to write an applet which will function correctly on every client.","The dual-MVC approach of the invention avoids the installation and disk-space problems because client-side code associated with the MVC of the application is preferably downloaded from the server on demand by the user of the client device, avoiding the install process, and is preferably not saved permanently to the disk of the client. The dual-MVC approach also avoids problems associated with applets because the MVC code downloaded according to the invention is physically smaller than an applet and thus results in a faster download. Also, the dual-MVC approach of the invention preferably uses HTML and JavaScript constructs which are, in practice, more portable between browsers than are applets.","Particularly, in accordance with the unique dual-MVC approach of the invention, the client machine maintains part of the Model, eliminating many round-trips to the server. The invention provides an implementation approach for constructing the frame(s) contained in the client's browser software to allow it to be refreshed locally. The invention addresses development and maintenance by specifying a library of functions that a programmer can use to construct the View and Controller on the client machine. When part of the Model is maintained on the client, the client has the ability to respond to user interaction without paying the performance penalty of continually interacting with the server.","It is to be appreciated that the term \u201cframe\u201d as used herein has a similar usage as in HTML. Web browsers typically display one or more windows on the client's screen. Each window may correspond to one HTML frame, or may instead correspond to one HTML \u201cframeset.\u201d A frameset comprises one or more frames, which are like sub-windows inside a frameset window.","The invention specifies a way to structure browser-based clients so that classic MVC interactions are possible. The client's browser screen may be divided into multiple frames. In the case of a web browser running at the client, the web browser includes an HTML frameset. There may be one or more visible frames that the user interacts with, and a number of \u201cinvisible\u201d frames where the logic resides. By \u201cinvisible\u201d frame, we mean that the frames height or width has been set to a very small value, so that they appear not to occupy any screen area. Visible frames obviously occupy some screen area. The invisible frames contain the application logic and the logic to rewrite the visible frames. It is to be appreciated that an application may create additional windows or framesets, and\/or have additional frames within a window, where the window corresponds to a frameset. Without this invention, a client-side application attempting to update its View will destroy itself by overwriting its own Controller logic and Model data.","It is to be appreciated that the term \u201clogic\u201d as used herein is intended to refer to program code, preferably in JavaScript at the client side, although it may also be in Java, VBScript, C++, C, or any other programming language which is supported by the browser.","The invention also specifies a way to program this kind of web application. Programmers using only the dual-MVC and multiple frames will need to generate HTML within their View-generating logic. This requires the programmer to think in two different domains simultaneously: JavaScript for the View-generating logic, Model, and Controller, and HTML for the View itself. This may be a complicated, tedious, and error-prone task depending on the application being designed. To substantially eliminate this situation, the present invention specifies a library of functions that are capable of writing the HTML with JavaScript. The programmer can implement the application using these functions rather than having to write the complicated HTML\/JavaScript. This is analogous to programmers writing user interfaces using the Java Swing library.","These and other objects, features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof, which is to be read in connection with the accompanying drawings.","The following description will illustrate the invention using an exemplary web-based client\/server system. It should be understood, however, that the invention is not limited to use with any particular client\/server system. The invention is instead more generally applicable to any network-based client\/server system in which it is desirable to substantially reduce server interactions on the part of the client when executing one or more applications associated with the server.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 1","FIG. 1"],"b":["1000","1000","3000","5000","3000"]},"It is to be appreciated that an example of such a client\/server system as illustrated in  may include an arrangement wherein a user at a personal computer or workstation (client) accesses a particular application (e.g., help desk, life insurance underwriting, health insurance pre-certification for medical procedures, and automated teller machines) associated with a particular server on the HTTP network in accordance with web browser software loaded and running on the client machine.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["1000","5000","5400","5600","5800","5000","1200"]},"In contrast, referring now to , a block diagram illustrating a dual-MVC architecture according to an embodiment of the present invention is shown. In this architecture, the web server  comprises Model-View-Controller components, including server-side View-generating logic , server-side Model data  and server-side Controller logic . The web browser (client)  comprises a user-interaction window , client-side View-generating logic , client-side Model data  and client-side Controller logic . These MVC components are preferably downloaded to the client from the server at the time that the client requests use of the application at the server. Given the fact that the client and server both contain MVC components, we term this approach dual-MVC.","A principal advantage of our invention is a dramatic improvement in application response time, since many interactions with the server are eliminated. To demonstrate the performance improvement which may be achieved, a help desk application will be described. In accordance with such a help desk application, a computer user (i.e., customer) may have problems with his\/her computer and call technical support. The person providing the help (i.e., consultant) has a web application to record information about the customer and his\/her problem. In other words, a help desk consultant sits in front of a web-based user interface and uses the interface to communicate with the help desk server in order to record and track a customer's problems which he\/she reports during a call to the consultant. In such an example, the computer system with the user interface that the help desk consultant is using is considered the client. Specifically, the consultant utilizes a web browser  () running on the client to access the help desk server. The help desk server is the server  ().  illustrates an example of the consultant's initial screen, corresponding to the user-interaction window  of . Depending on the operating system selected, a new table is added to the screen to collect operating specific information about the customer's computer. This second screen with the new table is shown in .","We first describe the application flow for an implementation using the conventional thin-client architecture as shown in .  shows a generic application flow for the conventional thin-client architecture. In step , the web browser  requests the initial page from the web server , using the network . In step , the web server replies with the initial page and, in step , the web browser displays the page in the user-interaction window . The user interacts with the displayed page, in step , by inputting data into the window, and the web browser transmits the data back to the web server in step . The server-side controller  updates the server-side model  in step , and the server-side view-generating logic  generates the new page in step . The web server then transmits the new page to the web browser in step , and the flow repeats from step .","Now, referring back to the help desk example illustrated in accordance with , and using the conventional thin-client architecture, the following steps would occur:\n\n","When a subset of the Model is stored on the client, as in accordance with the dual-MVC approach of the present invention, a number of interactions with the server can be eliminated, thus providing better performance. For example, if the name, ID, phone, operating system, operating system-specific information, and remarks are in the client's model, i.e., are stored at the client, then: (i) the screen can be refreshed with the addition of a blank row; and (ii) the screen can be refreshed by adding the proper operating system table without going to the server.",{"@attributes":{"id":"p-0042","num":"0051"},"figref":["FIG. 7","FIG. 3"],"b":["6000","1000","5000","3000","6010","6020","1200","6030","6040","1800","6050","6080","5800","5600","6090","5400","6100","6110","6020"]},"Alternatively, if the client-side logic decides that no server interaction is required, then the client-side model  is updated, in step , to reflect the user's input. Next, the client-side view-generating logic  is executed and generates the new page in step . Returning to step , the page is displayed in the user-interaction window . The application flow then repeats from step .","Assuming that the name, ID, phone, operating system, operating system-specific information, and remarks are contained in the client-side model, the display of  can advantageously be generated without an interaction with the server. Thus, entering n problem reports requires n+2 round-trip interactions between the web browser and the web server using the dual-MVC approach of the present invention. Alternatives for improving performance often involve trade-offs. For example, if performance is critical, and the amount of space on the client\u201d s machine is large enough, more data can be copied to the client. Also, if a list of the hostnames and their corresponding IP addresses is stored on the client, the trip to the server to obtain the IP address given the hostname could also be skipped. If this were done, the number of round-trip interactions would be reduced to two. If a list of customer IDs and their corresponding names and phone numbers is stored on the client, this would eliminate the need to invoke the server to get check the customer ID and return the name and phone. All processing, except for the final save (one interaction), could then be done on the client side.","Referring to , a client-side frameset architecture for a dual-MVC approach according to an embodiment of the present invention is shown. Specifically, we specify an illustrative format for the client's browser in order to implement the dual-MVC approach of the invention. The client's browser screen  is divided into multiple frames. There may be one or more visible frames comprising the user-interaction window , an invisible library frame , and an invisible application-specific frame  where the model and logic to write screens resides. The library frame and the application specific frame may also be implemented in multiple frames. In any case, the library frame  contains view-generating logic , client-side model  and controller logic , each of which is independent of the application. The application-specific frame  contains the view-generating logic , client-side model , and controller logic , each of which is specific to the application.","The invention provides a library which is stored in one of the invisible frames. The library allows the developer to program the client's model, view, and controller in a manner where functions are called which are responsible for writing the HTML. This is very complicated and tedious. With the library, the developer's effort is greatly simplified.","The application frame  provides a stable anchor-point for the client-side logic. Since the invention works by rewriting visible frame(s), the visible frames cannot themselves contain controller\/view logic and model data, because the logic and data will be destroyed during the rewrite process.","The library frame  provides an application-programming-interface (API) and implementation for generating the view in the visible frame. The API allows the programmer to specify the layout in terms of visible components, with each component having controller properties, e.g., text values, color. The implementation of the components in the library writes the appropriate information into the visible frame (e.g., HTML) to generate the described visual layout. The library frame also contains an application-independent client-side model function , e.g., caching and data-movement operations. Finally, the library frame contains application-independent controller logic , e.g., generic user-interface event handling.","In a preferred embodiment, the application programmer codes the application-specific frame model and controller-logic using JavaScript, and generates the view via calls to the library API. The properties of the view are set from the model and, when instructed to do so by the controller logic, the view renders itself into the visible frame.","Referring now to , code fragments are shown in order to illustrate a sample application using components in a library frame . The application defines a simple Model (a counter value), and a number of library-frame components: (i) an LFrame, a component representing a browser window; (ii) an LForm, a component representing a user-input form in a window; (iii) an LText, a component representing a text-input field in a form; (iv) an LButton, a component representing a pushbutton on which the user may click; and (v) an LStaticText, a component representing a text label on the screen. Each of these components is implemented by code in the library frame . The application-specific frame  makes calls to the library frame  to create components to make callbacks to the application-specific frame  when certain user-input events occur, such as changes to text fields and button presses. During processing of these events, the event handlers in the application-specific frame  may make calls to the components implemented by the library frame  to modify their properties as a result of the user interaction. Of course, it is to be appreciated that the code sample shown in  is illustrative in nature and, given the inventive teachings herein, one of ordinary skill in the art will realize various other ways to implement library frames.","Accordingly, as has been explained, the present invention provides for a dual-MVC arrangement (a client-side MVC and a server-side MVC), together with a way of implementing the two MVCs using a standard browser without applets. The invention makes the client-side MVC possible by separating the interaction window  into a separate frame from the application logic (, ) and model .","Further, the invention provides a client-side application-programming interface (API) for application developers to use when implementing dual-MVC applications. Using this API, which may be implemented in JavaScript, makes it easier to write applications.","Still further, the invention provides for packaging the application-independent code into a separate frame called the library frame . In a preferred embodiment, the library frame contains the application-independent view-generating logic and application-independent controller logic and may contain an application-independent model. For example, it contains the logic to generate a button on the screen, and to receive events caused by clicking the button with a mouse, but does not know where to place the button, what label to place on it, or what application-specific controller action to take when the button is clicked. This is specified by the application-specific components in the application-specific frame . The advantage of the library frame is that the library frame only needs to be downloaded once per browser session, because it changes only when software updates take place (e.g., over weeks or months). The browsers can thus cache the library frame for extended periods. In contrast, the interaction window  is discarded\/rewritten on virtually every user interaction, and the application-specific frame  is reloaded on every server interaction. If the code in the library frame were moved to application-specific frame , it would need to be reloaded on every server interaction, which would waste communication bandwidth and cause additional response-time delays.","Referring now to , a block diagram is shown illustrating a hardware implementation of a client computer system and\/or server computer system suitable for implementing the dual-MVC methodologies of the present invention. As shown, both the client system and server system may be implemented in accordance with a processor , a memory  and I\/O devices . It is to be appreciated that the term \u201cprocessor\u201d as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit) and\/or other processing circuitry. The term \u201cmemory\u201d as used herein is intended to include memory associated with a processor or CPU, such as, for example, RAM, ROM, a fixed memory device (e.g., hard drive), a removable memory device (e.g., diskette), flash memory, etc. In addition, the term \u201cinput\/output devices\u201d or \u201cI\/O devices\u201d as used herein is intended to include, for example, one or more input devices, e.g., keyboard, for entering data to the processing unit, and\/or one or more output devices, e.g., CRT display and\/or printer, for presenting results associated with the processing unit. It is also to be understood that the term \u201cprocessor\u201d may refer to more than one processing device and that various elements associated with a processing device may be shared by other processing devices. Accordingly, software components including instructions or code for performing the methodologies of the invention, as described herein, may be stored in one or more of the associated memory devices (e.g., ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (e.g., into RAM) and executed by a CPU. For example, the individual Model, View and Controller logic associated with the client and the server, as shown in , may be implemented in accordance with a hardware architecture as depicted in .","Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be affected therein by one skilled in the art without departing from the scope or spirit of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 9A through 9C"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
