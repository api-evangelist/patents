---
title: System and method for retrieval of objects from object to relational mappings
abstract: A retrieval system generates a retrieval query for batch reading of related objects when a source object is read from the database. The related objects include nested objects and/or many-to-many relationship objects. It generates a single retrieval query for each type in each level of nested objects using its parent query. Also it generates a retrieval query to retrieve a collection of target objects having many-to-many relationships with a collection of source objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07054858&OS=07054858&RS=07054858
owner: OIC Acquisition Corporation
number: 07054858
owner_city: Redwood Shores
owner_country: US
publication_date: 20010801
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This invention relates to a system and method for retrieval of objects from object to relational mappings, and more particularly, to a system and method for retrieval of objects having many-to-many relationships from a relational database.","Object model technology is becoming more popular for building enterprise applications. However, many organizations have already developed relational databases and have their corporate data stored in those databases. Accordingly, it is desirable to provide a mechanism to allow object applications to manipulate objects in relational databases, i.e., write, read, delete and update objects in or from the relational databases. Object-oriented applications are built using object models with inheritance and relationships, whereas relational databases consist of flat tables and foreign keys. It is desired to be able to represent the raw database data as application objects. Databases are queried through a database query language, such as Structured Query Language (SQL), however it is desirable to query objects at the object level and through traversing the object model.","In an object model for a many-to-many relationship, each source object contains a collection of target objects. The source object contains references to the target objects. In a relational database, a many-to-many relationship is defined through the use of an intermediate join table. When a collection of source objects is read from the database, each of the collection of target objects of the source objects needs to be populated. For a single source object, only a single query is required. When many sources objects are queried, one query is required for each source object. This includes navigation from other one-to-many or many-to-many relationships. In some known systems, reading the target objects requires a database query for each source object to obtain its target objects. This requires n queries to the database given n original source objects, which hinders application performance due to an overhead associated with each individual database query.","In addition, object models can consist of complex interconnected graphs of related objects. A set of source objects could have a relationship of one-to-one, one-to-many or many-to-many to a set of target objects, which in turn could have a relationship to a set of related objects, and so on. In existing systems, the number of database queries required to read in the entire graph of objects is relative to the number of objects and the depth of the relationships. For example, consider a 3 level depth of related objects, on a root level query from application for 100 source objects for the related objects, each with a collection of 10 related objects, each with a collection of 10 other related objects. This requires 1+100+1000 or 1,101 database queries, and would be a performance hindrance to the application.","To load target objects for single level one-to-one and one-to-many relationships, it is known to use an existing solution which reads all of the relevant target objects for all of the source objects in a single query that joins the target table to the original source table query. The source and target objects are then matched together in-memory based on their foreign key information.","This existing solution only supports one-to-one and one-to-many relationship and not many-to-many relationships. For one-to-one and one-to-many relationships, the objects read from the database contain foreign key information for their relationships that allows them to be matched together. However, there is no such information stored in the objects read from the database for many-to-many relationships, making the problem significantly more difficult.","Also, this existing solution only supports optimizing a single level of relationships and does not support nested optimization. This limits the scenarios that the optimization could be applied and limited the degree of the optimization.","It is therefore desirable to provide a system and method which allows retrieval of objects having nested relationships and many-to-many relationships from the database.","It is an object of the invention to provide a novel system and method for retrieving objects having nested relationships and\/or many-to-many relationships from a relational database that obviates or mitigates at least one of the disadvantages of existing systems.","The present invention generates a retrieval query for batch reading of related objects when a source object is read from the database. The related objects include nested objects and\/or many-to-many relationship objects. It generates a single retrieval query for each type of relationships at each level of nested objects using its parent query. Also it generates a retrieval query to retrieve a collection of target objects having many-to-many relationships with a collection of source objects.","In accordance with an aspect of the present invention, there is provided a method for retrieving target objects stored in a relational database to which an object model is mapped. The method comprises steps of generating a retrieval query to read target objects for a collection of source objects, the collection of source objects having many-to-many relationships with the target objects, the collection of source objects and target objects being respectively stored in one or more source tables and target tables in the database, and the many-to-many relationship being defined in the database by using an intermediate join table of the source tables and the target tables; selecting join table information from the many-to-many join table relating to the collection of source objects and the target objects to enable matching of the target objects and the source objects using the join table information; and retrieving the matched target objects by executing the retrieval query on the database.","In accordance with another aspect of the present invention, there is provided a method for retrieving objects stored in a relational database to which an object model is mapped. The method comprises steps of obtaining nested specification information representing joins relating to a source object and related objects which are joined with the source object with multi-level relationships; obtaining parent query information representing a parent query for reading one or more parent objects at a parent level; generating a nested query for querying objects of next lower level which is next lower than the parent level; appending to the nested query the parent query information and the joins using the nested specification information; and retrieving the objects of next lower level by executing the nested query on the database.","In accordance with another aspect of the present invention, there is provided a retrieval system for retrieving target objects stored in a relational database to which an object model is mapped. The retrieval system comprises a query generator for generating a retrieval query to read target objects for a collection of source objects, the collection of source objects having many-to-many relationships with the target objects, the collection of source objects and target objects being respectively stored in one or more source tables and target tables in the database, and the many-to-many relationship being defined in the database by using an intermediate join table of the source tables and the target tables; a join table information handler for selecting join table information from the many-to-many join table relating to the collection of source objects and the target objects to enable matching of the target objects and the source objects using the join table information; and a batch reading handler for retrieving the matched target objects by executing the retrieval query on the database.","In accordance with another aspect of the present invention, there is provided a retrieving system for retrieving objects stored in a relational database to which an object model is mapped. The retrieval system comprises an information receiver function for obtaining nested specification information representing joins relating to a source object and related objects which are joined with the source object with multi-level relationships; a query generator for generating a nested query for querying objects of next lower level to parent objects which are queried by a parent query; and a batch reading handler for appending to the nested query information of the parent query and the joins using the nested specification information, and retrieving the objects of next lower level by executing the nested query on the database.","Other aspects and features of the present invention will be readily apparent to those skilled in the art from a review of the following detailed description of preferred embodiments in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1A","b":["1","1","2","4","6","8","10","12","2","2","4","2","4","2","4","2","5"]},"Further, the customer objects in Customer  have related or nested objects, i.e., address objects in Address  and phone objects in Phone# . Customer  has an address attribute and a phone attribute. The value of the address attribute references to an address object in Address . Thus, Customer  and Address  have a one-to-one relationship . Phone#  contains phone numbers. A single customer in Customer  may have zero or more phone numbers, and a value of each phone attribute references to one or more phone objects in Phone# . Thus, Customer  and Phone#  have a one-to-many relationship . Thus, Order , Customer  and Address  or Phone#  have two level relationships.","Similarly, Order , Orderdetail  and Item  have two levels of one-to-many relationships  and .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2A","b":["20","1","20","22","24","26","28","30","32","22","24","28","22","24","26","28","25","27","29","30","32","22","30","32","31","33"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1B","b":["1","1","42","44","46","42","44","42","44","42","44","42","45","44","42"]},"Similarly, Project  has references to Location . Location  stores location details. One project may be carried out in multiple locations and one location may be used for multiple projects. Thus, Project  and Location  have a many-to-many relationship . Employee , Project  and Location  have two level many-to-many relationships, with Location  nested in Project .",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 2B","FIG. 1B","FIG. 1B"],"b":["20","20","62","64","66","42","44","46","42","44","46","20","70","62","64","74","64","66","62","70","71","70","62","70","64","70","72","70","64","70","62","64","70","64","66","74","75","76"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3A","b":["100","120"]},"The mapping system  contains a class mapping tool , a meta-data storage  and a runtime mapping library .","The class mapping tool  is a development-time tool that assists developers of the database schema in defining how an object model maps to a database. For example, using this tool , a developer maps the object classes, Employee , Project  and Location , of object model \u2032 shown in  to the tables, EMPLOYEE , PROJECT  and LOCATION , in database \u2032 as shown in , respectively. Also, the many-to-many relationships ,  are mapped to foreign keys , , ,  through the intermediate join tables PROJ_EMP  and PROJ_LOC , respectively. A graphical tool having a graphical user interface may be suitably used as the class mapping tool .","The meta-data storage  stores mapping meta-data defining the mapping data of how the object classes map to the tables, and how the relationships map to the foreign keys. The meta-data comprises descriptors and mappings. A descriptor is a set of properties and mappings that describes how an object data is represented in a relational database. The descriptor contains mappings from the class attributes to the table columns, as well as the transformation routines necessary for storing and retrieving attributes. The descriptor acts as the link between the object model and the database representation. A mapping accomplishes the storage and retrieval of an object's attributes in and from the database representation.","The mapping meta-data may be stored in extended Markup Language (XML) files. The XML files are read in at runtime by the retrieval system  as further described below. The mapping meta-data is generally generated by the mapping tool . However, it may be specified through manually editing the XML file, or through Application Programming Interface (API) code. The meta-data storage  is provided external to both the source object classes and target object classes. Thus, there is no need to store additional information in the object classes.","The runtime mapping library  is a library storing a set of pre-defined generic mapping methods. The methods are defined such that they are executable on the database in terms of the object model, rather than the relational model. The runtime mapping library  executes the mapping methods on the database using the mapping meta-data to store or retrieve objects in or from the database. This allows users to use the mapping system  without knowledge of database access API's or database querying languages, such as Structured Query Language (SQL).","When accessing a relational database using an object oriented language, such as the Java (TM) programming language, it is desirable to express queries in terms of objects, rather than using database query language, such as SQL. The mapping system  allows object applications to transparently store and retrieve objects using a relational database. Developers can build sophisticated queries at the object level, rather than using SQL or other database query languages. When objects are read in, not only are the instance variables filled in with data but references to other objects are automatically maintained by the mapping system . The referenced objects are traversed by navigating the object model using normal object application methods, such as Java methods, rather than making additional explicit database queries or managing foreign keys. The mapping system  supports a variety of complex object models and automatically maintains references between objects in the database. While the embodiment is described using mainly Java and SQL, the invention is not limited to those languages.","The object retrieval system  is a runtime component. When target objects have relationships with other related objects, i.e., nested objects, the retrieval system  retrieves those nested objects and the relationships, as well as the target objects, when the source objects are retrieved. When a collection of source objects having a many-to-many relationship with a collection of target objects is read from the database, the retrieval system  retrieves the collection of relevant target objects and the relationship.","The retrieval system  allows batch reading or optimized loading of relevant objects relating to the source objects, including the target objects and their nested objects, through reducing the number of required queries to one per type of relationship or one per level, as further described below. This reduces the number of database queries to a constant number.","For example, consider a three-level depth of related objects, on a root level query from the application for 100 source objects (e.g., in , 100 orders), each with a collection of 10 target objects (e.g., 10 order details), each with a collection of 10 related objects (e.g., 10 items). In order to retrieve the target objects and related objects (e.g., the order details and related items), the retrieval system  uses three database queries; one query for all of the source objects (e.g., orders), one query for all of the target objects (e.g., order details) for all of the source objects, and one query for all of the related objects (e.g., items) for all of the target objects for all of the source objects. As described above, existing systems use 1,101 database queries. Accordingly, the retrieval system  provides a significant performance gain to the application, compared to the existing systems. That is, the same amount of data is read in by the retrieval system  and the existing systems described above, however, the database traffic is significantly reduced according to the retrieval system . Also, there is an overhead, e.g., at the client, network, query and database, associated with each database interaction. This overhead is also reduced by using the reduced number of queries through the reduced database traffic.","The retrieval system  comprises a query generator , a join table information handler  and a batch reading handler . The query generator  dynamically generates retrieval queries to read relevant objects, including the target objects and their nested objects, for source objects. The batch reading handler  passes the query information regarding the upper level retrieval query used for reading objects at upper level to a nested query for reading objects at the next lower level, and appends the additional query information and joins relating to the source object to the nested query, as further described below.","Also, query generator  dynamically generates a retrieval query to read all of relevant many-to-many target objects for all of a collection of source objects. To read many-to-many target objects, the join table information handler  selects foreign key information from the many-to-many intermediate join table to enable matching of the target and source objects, as further described below.","The batch reading handler  executes the retrieval queries generated by query generator .","In , the retrieval system  is shown separately from the components of the mapping system . However, the components of the retrieval system  may be combined with or made as a part of a component of the mapping system . For example, the retrieval system  may be a part of the runtime mapping library  which also manages objects with other relationships, such as a single level one-to-one or one-to-many relationships.","As shown in , the query generator  may have information receiver , expression tree handler  and expression tree combiner . The information receiver  obtains information regarding objects and relationships, expression tree handler  handles expression trees for representing the relationships between objects, and the expression tree combiner  combines expression trees, as further described below.","The functions of the retrieval system  are further described in more detail below.","First, the retrieval of multi-level objects is described. To retrieve multi-level objects, the retrieval system  generates a single retrieval query for retrieving objects of the same type of relationship in the same level. For example, if objects in a specific level are all related to their parent objects with the same relationship, e.g., one-to-many, the retrieval system  generates a single query for the level. If some objects in a specific level relate to the parent objects with a certain relationship, e.g., one-to-one, and the rest of the objects in the same level relate to their parent objects with a different relationship, e.g., many-to-many, then the retrieval system  generates two queries for this level.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 4"},"A source object is read from the database using a source query at the root level from the application (). The retrieval system  obtains, from the mapping meta-data, nested specification information representing nested joins relating to the source object (). The nested specification information may be created by the developer of the mapping meta data when the object model classes and relationships are mapped to tables and foreign keys of the database. To create the nested specification information, the developer may use a checkbox in the user interface of the mapping tool  shown in . The mapping meta-data is typically retrieved from the meta-data storage  when the mapping system  is initialized.","The nested specification information may also be obtained using an Application Programming Interface (API) call in API code. For example, a declarative specification API may be added to individual queries. The declarative specification API allows for nested attributes names to be given using expressions. The API allows for an expression object to be passed as argument, the expression defines arbitrary levels of nested optimization or batch reading. This allows for optimization or batch reading to be specified for complex object graphs and nested level query operations.","Using the nested specification information, the retrieval system  specifies, on the source query at the root level from the application, the relationships that may be optimized or batch read to allow for nested specification, i.e., the relationships which allow for batch reading (). The batch readable relationships may be specified on the source query using attributes of the target objects and nested objects. For the example shown in , the nested attributes may be specified as follows:","batchRead(\u201cprojects.locations.address\u201d).","Alternatively, relationship mappings of the retrieval system  may be set to always use batch reading allowing complex multi-level batch reading.","When the batch reading is enabled, the retrieval system  generates a single nested query for retrieving objects at the next lower level (). This is done by passing the information regarding the parent retrieval query for retrieving the upper level objects to the nested query. The parent retrieval query is the source query for the target objects at the first level, and for other nested objects, it is a nested query for querying objects of one level higher than the other nested objects. The retrieval system  then appends to the nested query the information of the parent query and joins relating to the source object (). Each individual join is obtained from the nested specification obtained from the mapping meta-data. For example, for a parent query:\n\n","The retrieval system  executes the nested query and retrieves the related objects (). Based on the nested specification, the retrieval system  repeats steps \u2013 for the next lower level until the related objects of all levels are retrieved.","Thus, the parent query is passed to each relationship mapping or batch reading handler , and a single nested query is generated for retrieving nested objects of the next lower level when the retrieval system  is building the value into the source object.","The retrieval system  may not build the value of each related object right away, but place an \u201cindirection\u201d object placeholder in the attribute of the source object, and continue the nested query building process. An indirection object is a mechanism to limit the depth of levels to which relationships are followed when related objects are being read. Without such a mechanism, the retrieval system  reads an object, all of the related objects and all of their related objects and so on. If it reads arbitrarily complex relationships, this would have a drastic effect on read performance. Indirection objects delay reading of the related objects until they are used. Indirection objects use an object placeholder to hold queries until the relevant relationships are accessed. Thus, the execution of the nested queries may be deferred through indirection objects until any of the source objects relationship is accessed at the first time.","By specifying the batch readable relationships on the source query, each source query for each source objects for a many-to-many mapping checks all of the mappings relating to the source object to see if any of the relationships of the source objects should be batched. Thus, it ensures that nested queries against that related relationships are optimized or batch read.","Generation of the nested query at step  depends on the type of the relationship between the parent objects and the lower level objects. When the relationship is one-to-one or many-to-many, the retrieval system  may use a known method for generating a query for single level relationship objects. For example, as shown in , objects in Item  may be added with a one-to-one reference back to Orderdetail  as indicated with arrow . In that case, the retrieval system  may use the back reference  to generate the nested query for retrieving Item objects from ITEM  in the database . For a one-to-many relation, the retrieval system  may also use the mapping meta-data to generate the retrieval query as described in co-pending application Ser. No. 09\/920,789 entitled \u201cSystem and method for managing object to relational one-to-many mapping\u201d filed on Aug. 1, 2001 by Yaoping Wang and James Bryce Sutherland, which is incorporated herewith by reference.","When the relationship with nested objects is many-to-many, the retrieval system  generates the query as shown in .","When a collection of source objects is read from the database (), the retrieval system  generates a retrieval query to read all target objects for the source objects (). The retrieval system  executes the retrieval query on the database, and selects target object information and join table information from the many-to-many join table (). The join table information is used for matching the target objects and the source objects. The retrieval system  further executes the retrieval query to populate the relationship of the source objects with the target objects using the join table information ().",{"@attributes":{"id":"p-0066","num":"0070"},"figref":"FIG. 6","b":["140","142","120"]},"An expression is a querying mechanism that allows queries based on the object model in an object query language. It defines querying criteria. An expression query written using an expression may be translated into SQL. An SQL query has a \u201cselect\u201d clause and \u201cwhere\u201d clause. The select clause defines the tables from which the data is to be read. The where clause defines the conditions of the query. An expression allows one to define these \u201cwhere\u201d clauses in an object query language. Expressions may be combined together through AND and OR operations.","An expression tree is a tree representing querying criteria, e.g., the SQL where clause, for related objects. An expression tree representing many-to-many relationships between objects includes the many-to-many join between the target table and join table. For the example shown in , the expression tree may be expressed as follows:","(((proj_emp.projectid) (=) (proj.projectid)) (and) ((proj_emp.empid) (=) (emp.empid)))","This is called an \u201cexpression tree\u201d because it is viewed as a tree with each ( ) as a node.","An expression tree may be created from the mapping meta-data stored in the meta-data storage . The mapping meta-data includes a list of key\/value pairs, e.g.,","<key>proj_emp.projectid<\/key> <value>proj.projectid<\/value>","<key>proj_emp.empid<\/key> <value>emp.empid<\/value>","The mapping meta-data may also be specified through API code which gives more flexibility, e.g.,","expb.getField(\u201cprojectid\u201d).equal(joinTable.getField(\u201cprojectid\u201d).and(expb.getP arameter(\u201cempid\u201d).equal(joinTable.getField(empid\u201d))","Also, the expression tree may be created through XML or graphical mapping tool, e.g., mapping tool , by the user for their queries.","In order to read the collection of source objects (), a read request is typically defined by the user or the application. A read request may be defined by mapping system  or retrieval system  in case of traversed relationships. Based on the read request, a read query is specified through a query language at the object level. The query language may be the expressions, i.e., an expression tree, or something that can be converted to the expression tree (e.g., Enterprise Java Bean Query Language (EJBQL), mapping\/query meta-data) (). The expression tree for the source objects, i.e., source expression tree, is translated into the database's query language (). The translated database query is executed on the database through the database access system, resulting in obtaining the source rows. The source rows are then translated into the source objects ().","In order to generate a retrieval query for all of the relevant target objects for all of the source objects, the retrieval system  builds from the mapping meta-data a target expression tree defined by the many-to-many relationships (). The target expression tree includes the join between the target table and the join table.","The retrieval system  combines the source expression tree and the target expression tree (). The expression trees may be combined through an AND operation. For examples, consider a source expression tree such as:\n\n((salary(Employee)) (>) (100000))\n\nA target expression tree is:\n\n(((EMPLOYEE.EMPLOYEE_ID) (=) (PROJECT_EMPLOYEE.EMPLOYEE_ID)) (AND) ((PROJECT_EMPLOYEE.PROJECT_ID) (=) (PROJECT.PROJECT_ID)))\n\nThe combined expression tree is:\n\n(((salary (Employee)) (>) (100000)) (AND) (((EMPLOYEE.EMPLOYEE_ID) (=) (PROJECT_EMPLOYEE.EMPLOYEE_ID)) (AND) ((PROJECT_EMPLOYEE.PROJECT_ID) (=) (PROJECT.PROJECT_ID))))\n","The retrieval system  generates the retrieval query from the combined expression tree (). Thus, the retrieval query is the source query joined with a target query. For the above example, the generated query is:\n\nRead all Projects and PROJECT_EMPLOYEE data where (((salary (Employee)) (>) (100000)) (AND) (((EMPLOYEE.EMPLOYEE_ID) (=) (PROJECT_EMPLOYEE.EMPLOYEE ID)) (AND) ((PROJECT_EMPLOYEE.PROJECT_ID) (=) (PROJECT.PROJECT_ID))))\n",{"@attributes":{"id":"p-0080","num":"0084"},"figref":"FIG. 7","b":["144","146"]},"The retrieval system  executes the retrieval query on the database (). It obtains the target object information and the join table information from the many-to-many join table (). The join table information includes the foreign key values. The retrieval system  appends the target object information and the join table information to the retrieval query (). The information is appended to the \u201cselect\u201d clause of the SQL select statements. For example,\n\n","When the source objects are being built, or if indirection is used when any of the source objects relationship is accessed, the relationship of the source objects is populated with the target objects. During this population of the relationship, the retrieval system  matches the source objects and the target objects together in memory, using the join table foreign key values () and the source objects primary key values. Thus, the source objects are matched with their corresponding target objects.","If the many-to-many target objects have nested objects, as shown in , the generation of a nested query at step  to the retrieval of the related objects at step  passes the expression tree to nested levels. At each level, an expression tree is appended to the upper level expression tree, and then passed on to the next level.","The above embodiments are described using Java technology as an example of an object based technology and language. However, the applicability of the invention is not limited to Java or Java based technologies. The invention may be applied to other object-based languages and technologies, such as those developed by Microsoft Corporation or Hewlett Packard, with or without appropriate modification as necessary or desired, and such application is within the scope of the invention.","Similarly, while the above embodiments are described using SQL as an example of a query language, the invention is not limited to technologies based on or SQL or employing SQL. The invention may be applied incorporating other database query languages with or without appropriate modification as necessary or desired, and such application is still within the scope of the invention.","The retrieval system of the present invention may be implemented by any hardware or a combination of hardware and software having the above described functions. The hardware may be a general purpose computer or a part of a general purpose computer. The software code, either in its entirety or a part thereof, may be stored in a computer readable memory. Such a computer readable memory is also within the scope of the present invention.","While particular embodiments of the present invention have been shown and described, changes and modifications may be made to such embodiments without departing from the true scope of the invention."],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be further understood from the following description with reference to the drawings in which:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
