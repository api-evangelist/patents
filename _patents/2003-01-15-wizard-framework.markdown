---
title: Wizard framework
abstract: The information exchanging facility is used by one wizard page to request the information it needs although it need not know where the information may have come from. This allows wizard pages that have already been developed in one wizard to be reused and placed into new wizards. This information exchanging facility is part of an architectural software framework that aids in the design of an interactive help utility, such as a wizard, that guides a user through steps of a particular task.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07308678&OS=07308678&RS=07308678
owner: Microsoft Corporation
number: 07308678
owner_city: Redmond
owner_country: US
publication_date: 20030115
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention relates generally to an architectural software framework, and more particularly, to the design of an interactive help utility, such as a wizard, that guides a user through steps of a particular task.","A wizard consists of multiple wizard pages that a user progresses through by clicking on the Next or Back buttons. Each wizard page of the wizard provides some information to the user to guide him through a subset of tasks necessary to complete a larger task. Wizards are used very commonly within graphical user interface (hereinafter \u201cGUI\u201d) operating systems and by hundreds of applications that run in these operating systems.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1","b":["100","100","102","102","104","104","1100","100","106","108","110","106","110","112","114","100","115","100","100","116","100","100"]},"Traditionally, the process of creating a wizard can be laborious and somewhat tedious. Here are typical development steps: First, the developer creates a main user interface that will host all of the wizard pages of the wizard. Second, the developer creates a user interface for each page of the wizard as well as writes the code to handle each page. Third, the developer has to come up with a mechanism for placing each page onto the main user interface of the wizard. And the mechanism should be cognizant that the presentation of these pages has to be in the correct order. In complicated wizards, the order of the pages might change based upon a user's selections. Thus, the mechanism needs to be able to handle this ordering of the pages. An additional mechanism is created by the developer to allow various pages of the wizard to communicate with one another and pass data back and forth. Then, the developer creates another mechanism for launching and displaying the wizard. And finally, the developer designs a process that launches the wizard and another process to receive the results of users' input from all the wizard pages of the wizard.","This toilsome effort for creating a wizard is repeated anew with each new wizard. Given that many software products make extensive use of wizards, a significant and therefore costly amount of developing time and money is be spent by software manufacturers to develop wizards. One glaring problem is that the conventional approach to create wizards precludes easy reusability of existing components or elements of wizards.","To allow wizard pages of a wizard to communicate with one another and pass data back and forth, each wizard page of a wizard is tightly coupled to a database where data is shared. To use the database, each wizard page of the wizard must intimately know all the data that can be written to or read by the other wizard pages. Otherwise, one wizard page could mistakenly access and change data in the wrong place in the database resulting in the corruption to the rest of the wizard pages of the wizard and possibly detrimental repercussions to the wizard itself. Unfortunately, this requirement results in the data in a database being vulnerably exposed by necessity to all of the wizard pages of the wizard. Not only does this present a serious security problem but it also inhibits reusability. The reason for this is because a wizard designer would have to be intimately familiar with the relationship between data among wizard pages. This familiar intimacy is a time-consuming undertaking, and it may also hinder the efficiency of designing and improving wizards.","All wizard pages of a wizard and their corresponding pieces of code are designed specifically to run without regard to how the pages and corresponding pieces of code can be reused. Conventional wizards are specific to the software products for which they are designed. For example, different software teams within a software company would design different means for transferring data between pages of wizards. Moreover, wizards may look slightly different from one another lacking unity in presentation to consumers. For example, placement of user interface elements, such as title bars, pictures, and buttons, might be differently placed and functions of the user interface elements might diverge from one another.","Thus, there is a need for an architectural software framework for designing wizards that incorporates protocols and means for expansion and interfacing among pages of wizards, as well as a reusable basic programming structure that assists in building wizards, while reducing or avoiding the foregoing and other problems associated with existing wizards.","In accordance with this invention, a system, method, and computer-readable medium for facilitating the exchange of information among components of an interactive help utility is provided. The system form of the invention comprises a wizard for guiding a user through a task. The wizard includes a first wizard page previously presented to the user. The first wizard page includes a set of services for accessing stored information provided by the user. The wizard further includes a second wizard page to be presented to the user. The second wizard page queries the wizard to gain access to the set of services and in response the wizard queries the first wizard page. The first wizard page returns a reference to the set of services and allows the second wizard page to access the stored information for customizing the presentation of the second wizard page to the user.","In accordance with further aspects of this invention, another system form of the invention comprises an interactive help utility for guiding a user through a task. The interactive help utility includes a wizard base that includes a history of previously presented wizard pages. The wizard base further includes a query service for querying the previously presented wizard pages to obtain a desired interface to access stored information previously provided by the user. The interactive help utility further includes a wizard page to be presented to the user. The wizard page invokes the query service of the wizard base to gain a reference to the desired interface thereby allowing access to the stored information for customizing the wizard page prior to presentation to the user.","In accordance with further aspects of this invention, a further system form of the invention comprises a computer-implemented architectural software framework for facilitating the exchange of information among components of an interactive help utility. The architectural software framework includes a wizard class for defining the order in which to display wizard pages. The wizard class includes a query service for returning a set of services that the wizard class supports. The architectural software framework further includes a wizard page to be presented to the user. The wizard page desires execution of an access service of other wizard pages to obtain stored information to customize the wizard page. The architectural software framework as yet further includes a wizard base that includes a query service for querying presented wizard pages to obtain the access service. The query service of the wizard base is invokable by the wizard page to find the access service. The query service of the wizard base invokes the query service of the wizard class to find the access service if the access service cannot be found among the presented wizard pages.","In accordance with further aspects of this invention, the method form of the invention for facilitating the exchange of information among components of an interactive help utility to guide a user through a task is implementable in a computer system. The method comprises querying a wizard base by a wizard page for an access service to access stored information so as to customize options presented by the wizard page to the user. The method further comprises invoking the access service by the wizard page to access the stored information when a reference to the access service is found by the wizard base by querying previously presented wizard pages for the reference to the access service.","In accordance with further aspects of this invention, the method form of the invention for exchanging information in a wizard is implementable in a computer system. The method comprises storing in a history a first wizard page previously presented to a user. The first wizard page includes a set of services for accessing stored information provided by the user. The method further comprises querying the wizard by a second wizard page that is to be presented to the user. The second wizard page queries the wizard to gain access to the set of services and in response to the query of the second wizard page the wizard querying the first wizard page. The first wizard page returns a reference to the set of services allowing the second wizard page to access the stored information for customizing the presentation of the second wizard page to the user.","In accordance with further aspects of this invention, another method form of the invention for exchanging information in an interactive help utility is implementable in a computer system. The method comprises storing previously presented wizard pages in a history by a wizard base. The wizard base includes a query service for querying the previously presented wizard pages to obtain a desired interface to access stored information previously provided by the user. The wizard base queries the wizard base by a wizard page that is to be presented to a user. The wizard page invokes the query service of the wizard base to gain a reference to the desired interface thereby allowing access to the stored information for customizing the wizard page prior to presentation to the user.","In accordance with further aspects of this invention, a further method form of the invention for facilitating the exchange of information among components of an interactive help utility is implementable in a computer system. The method comprises loading a wizard class that defines the order in which to display wizard pages. The wizard class includes a query service for returning a set of services that the wizard class supports. The method further comprises loading a wizard page to be presented to the user. The wizard page desires the execution of an access service of other wizard pages to obtain stored information to customize the wizard page. The method yet further includes querying a wizard base by the wizard page. The wizard base includes a query service for querying presented wizard pages to obtain the access service. The query service of the wizard base is invokable by the wizard page to find the access service. The query service of the wizard base invokes the query service of the wizard class to find the access service if the access service cannot be found among the presented wizard pages.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["200","200","200"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well-known computing systems, environments and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention is described in the general context of computer-executable instructions, such as program modules being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types.","The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media, including memory storage devices.","The computing system environment illustrated in  includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such bus architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus, also known as Mezzanine bus.","Computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer-readable instructions, data structures, program modules, or other data. Computer storage media include, but are not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tapes, magnetic disk storage or other magnetic storage devices, or any other computer storage media. Communication media typically embody computer-readable instructions, data structures, program modules or other data in a modulated data signal, such as a carrier wave or other transport mechanism that includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired media, such as a wired network or direct-wired connection, and wireless media, such as acoustic, RF infrared, and other wireless media. A combination of any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory, such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates the hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, the magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD-ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital videotapes, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface, such as interface , and the magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer-readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices, such as a keyboard  and pointing device , the latter of which is commonly referred to as a mouse, trackball, or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port, or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices, such as speakers  and printer , which may be connected through an input\/output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device, or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such network environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the input\/output peripheral interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are for illustrative purposes only and other means of establishing a communication link between the computers may be used.","As an illustration for the desire to exchange information among components of the architectural software framework  (), consider a wizard in a word processor application that allows a user to generate a letter template which includes the date, addresses of the sender and receiver, greetings, and closing statements. Such a wizard may include multiple pages where each page would be designed to allow the user to set up a portion of the letter. For example, the first wizard page might let the user choose the format for the date. The second wizard page might allow the user to choose whether the letter is formal or informal in presentation. If the user specifies that the letter is to be formal, the next wizard page that appears should allow the user to enter the address of the person receiving the letter. Otherwise, if the letter is informal, this wizard page can be skipped. Because the wizard class determines which wizard page appears next, the wizard class can retrieve information from the appropriate wizard page, such as the second page, to determine whether the user wants a formal or informal letter. The final wizard page might allow the user to enter a closing statement of the letter. If the letter is formal, this final wizard page may suggest a formal closing statement. Otherwise, if the letter is informal, the final wizard page will suggest instead an informal closing statement. Thus, this final wizard page would also need to query an earlier page (in this case, the first wizard page) to determine whether or not the user desires a formal or informal letter.","Various embodiments of the present invention provide a facility for querying for information so as to exchange information among wizard pages. For example, consider that the first wizard page (the wizard page in which the user picks informal or formal letter style) implements an interface called ILetterType. This interface has two methods, setFormal() and getFormal(). The setFormal() method allows write access to stored information pertaining to informal or formal letter style. The getFormal() method allows read access to the same stored information. In order for the final wizard page (the wizard page in which the user picks a closing statement) to suggest an appropriate closing statement, the final wizard page needs to access the stored information that pertains to the informal or formal letter style. Because the stored information is encapsulated by the ILetterType interface, the final wizard page needs to have a reference (such as a pointer) to the ILetterType interface, and invoking the getFormal() method of the ILetterType interface to access the stored information pertaining to the informal or formal letter style.","The difficulty involves where the final wizard page is to obtain the ILetterType interface. It turns out (as discussed in detail below) the final wizard page cares not where the ILetterType interface comes from as long as the ILetterType interface is implemented and such an interface can be obtained via a facility for querying for information so, as to exchange information among wizard pages. This facility is discussed in greater detail below. Moreover, when the wizard has completed its task, an application can gather all of the information entered by the user on all of the wizard pages so that the application can further process the task in the manner specified and desired by the user.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3A","b":["300","300","300"]},"An application , which is a program designed to assist in the performance of a specific task, such as word processing, spreadsheet, or crafting visual diagrams, is not part of the architectural software framework . However, the application  is shown coupled to the architectural software framework  to signify that wizards can be invoked from within applications, such as the application . Components of the architectural software framework  are coupled together either by solid lines or dashed lines that terminate to a wedge-shaped piercing tip resembling an arrowhead. A solid line symbolizes an active invocation order from one component to another component. For example, the application  directly invokes a wizard base . A dashed line indicates that one component has a reference to another component. For example, the application  has a reference to a wizard class . The term \u201creference\u201d means the inclusion of a pointer, which is a variable that contains the memory location (address) of some data, or a reference, which is an alias for a variable that actually stores the address of the variable.","Solid lines and dashed lines begin from one component of the architectural software framework  and end at a projection of another component. These projections have a circular terminus to represent an interface of a component. For example, the wizard base  has the interface IWizardBase. Each interface can be considered as an application programming interface of a particular component of the architectural software framework . Each interface has one or more methods that can be invoked by another component to access the services offered by the invoked component. The application  is not a component of the architectural software framework , and therefore, it lacks the interface shown on other components of the architectural software framework .","Each interface in each component of the architectural software framework  includes an IUnknown interface. The IUnknown interface is shown separate from the other interface of a component via a second projection that ends with the circular terminus. The interface IUnknown need not be programmatically separated from the other interface of a component but is shown separately here for clarity purposes (as explained in detail below). The IUnknown interface of a called (or invoked) component includes a QueryInterface() method that returns back to a calling component not only an interface supported by the called component but potentially other interfaces of other components programmatically known to the called component (explained in greater detail below). Conventional QueryInterface() method returns only those interfaces directly supported by the called component. Any suitable technology or languages can be used to implement the IUnknown interface. One suitable technology includes Component Object Model (COM). But other suitable technology is also possible, such as the remoting facility of Microsoft's .NET\u2122 or Sun Microsystems' JavaBean\u2122.","The architectural software framework  includes the wizard base . The wizard base  manages the displaying of wizard pages of a wizard and the exchange of data among wizard pages and other components, among other things. The main interface of the wizard base  is the IWizardBase interface.","The wizard class  is another component of the architectural software framework  that programmatically defines one particular wizard. In essence, the wizard class  describes a collection of wizard pages of a wizard that are to be presented together in a consistent fashion to a user. The main task of the wizard class  is to ensure that pages of the wizard are presented in a proper order. The wizard class  has an IWizardClass interface.","A number of pages -, which include \u201cwizard page 1,\u201d \u201cwizard page 2,\u201d and \u201cwizard page 3,\u201d collectively represent the wizard pages to be presented to a user for guiding the user through steps of a particular task. While each set of methods of functions of the pages - contains similar methods declared by the IWizardPage interface, each page may implement its own interface for data storage such that set of methods of functions of one page is different than another page. This is because information collected or presented to a user on one page of a wizard is likely to be different from another page of the same wizard. As noted above, and as will be discussed fully below, each method QueryInterface() eases the exchange of information of the architectural software framework .","Each component shown in  is an abstract data structure, which is instantiated by a developer during the process of creating a wizard. Certain components of the architectural software framework , such as the wizard pages -, contain the broad structure and generic programming code that is intended to be filled out and specialized for a particular wizard built by a developer.","The wizard base  is shown in greater detail in . Two programmatic portions comprise the wizard base . A user interface portion B contains user interface elements that are likely to be present in most wizards. For example, the user interface portion B includes a title bar  which lies horizontally at the top of a window that contains the name of the wizard. Appearing as a square button in the right corner of the title bar  with an X mark on it is a Close button . Clicking on the Close button  cancels the wizard. Wizard pages, which present information and receive input (information) from a user during the performance of the tasks defined by the wizard, are placed in an area . These pages of the wizard may be navigated back and forth using a Back button  or Next button . After collecting sufficient information from a user, the wizard presents a Finish button (not shown). A user clicking the Finish button causes the wizard to proceed to perform the wizard's task. At any point, a user may exit from the wizard by clicking on a Cancel button . Clicking on the Cancel button  causes the wizard to quit and returns the user to the application  that originally invoked the wizard.","The other part of the wizard base  is a code portion A. The code portion A manages the displaying of various pages of a wizard and the exchange of data among these pages as well as other components of the architectural software framework . As pages are displayed in the area  of the user interface portion B, the wizard base  keeps a history of presented wizard pages in yet another part of the wizard base \u2014a history portion C. The history portion C comprises a list of previously displayed wizard pages, such as pages C-C. By using the history portion C, the wizard base  can access any wizard pages and the corresponding information entered by a user onto those pages.","Interface IWizardBase of the code portion A includes a method QueryInterface() as briefly discussed above. The function QueryInterface() can be invoked via the interface IWizardBase. Pointers to the interface IWizardBase as discussed above are given to the architectural software framework , such as the wizard class  and wizard pages -. Thus, any of these components can invoke the function QueryInterface() of the code portion A via the IWizardBase interface for exchanging information. For example, because the wizard base  keeps a history of previously displayed pages C-C, the function QueryInterface() of the code port to query previously displayed pages to access information stored by those wizard pages.","The wizard base  manages the presentation of pages of a wizard. To display a wizard using the architectural software framework , the application  typically knows and has the unique identification of a wizard bearing identification data differentiating the wizard from other wizards known to the application . In addition, the application can obtain a reference to the IWizardClass interface. Using the unique identification of the wizard, the signature and identification of the IWizardClass interface, the application can obtain the desired reference to the IWizardClass interface. The application  passes the reference to the IWizardClass interface to the wizard base . This reference along with a unique identification of the wizard indicates to the wizard base  precisely which wizard known to the application  is to be presented to a user.","The wizard class  is shown in greater detail in . A wizard is basically a collection of wizard pages that are shown to a user together in a consistent fashion to guide the user through each step of a particular task. This collection of wizard pages is managed by the wizard class . The wizard class  is instantiated by a developer in order to define one particular wizard containing a set of wizard pages, such as pages B-B. One of the duties of the wizard class  is to inform the wizard based  of the correct order in which to load a wizard page and to present it to a user.","To access the services of the wizard class , other components of the architectural software framework  invoke a method specified by the IWizardClass interface of the wizard class . Like other components of the architectural software framework , the wizard class  inherits the QueryInterface() method. Upon invocation, the QueryInterface() method returns services that the wizard class  supports. The QueryInterface() method of the wizard class  is a part of a facility that allows data or information to be exchanged among the components of the architectural software framework .","When the presentation of a wizard commences, the wizard base  asks the wizard class  to provide the interface of the first wizard page that is to be displayed to a user. From then on whenever the user clicks the Next button , the wizard base  asks the presently displayed page for the next page that should be displayed. If there are no additional wizard pages, the wizard base  then queries the wizard class  for the next page. When the user selects the Back button , the wizard base  will automatically display the previously presented page without having to ask the wizard class  for assistance. As noted above, the wizard class  may store information that can be accessed by components of the architectural software framework , such as wizard pages, or by the application  that launched the wizard described by the wizard class . These pieces of stored information are accessible by invoking the QueryInterface() of the wizard class .","A wizard comprises multiple wizard pages. An exemplary wizard page  is shown in . The wizard page  is created by a developer to display one page among multiple pages of a wizard. Each page has a code portion and a user interface portion. With regard to the wizard page , the code portion is referenced as A and the user interface portion is referenced as B. Various user interface elements can be presented in the user interface portion B. For example, a textual description \u201cselect network server:\u201d instructs the user to enter or to choose a certain piece of information desired by the wizard page . As another example, buttons, such as radio buttons, list choices (\u201cHanoi,\u201d \u201cHue,\u201d \u201cSaigon\u201d) for the user to select. Many other suitable user interface elements can be used to entice the user to provide sufficient information in order to accomplish the wizard's task.","The code portion A contains a number of services, which are accessible by invoking methods declared by the IWizardPage interface. Like other components of the architectural software framework , the wizard page  inherits the QueryInterface() method. The QueryInterface() method allows the wizard page  to respond to an external request for the services that the wizard page provides, such as information extracted from a user and stored by the wizard page .","One of the duties of the wizard page  is to maintain the user interface elements, such as buttons and controls, on the user interface portion B; to provide the initial state of the user interface portion B when it is first presented to a user; to record the state of the user interface B when it is closed (such as when the user has entered desired information or completed the selection of a choice); and to store information related to the contents of the user interface portion B. The information that is stored by the wizard page  can be subsequently accessed by any components of the architectural software framework , such as other wizard pages, the wizard class , or by the application . The QueryInterface() method facilitates the ability of the wizard page  to exchange information stored and desired by other components.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 3E","b":["301","324","328","301","324","324","324","326","326","301","328","328","324","324","324","328","324","328"]},"The code portion A includes a method SetResolution() that is invoked once the user has made a selection of the level of resolution for his display. Another method called GetResolution() can be invoked to obtain the resolution choice made by the user. As previously discussed, an interface (e.g., an interface called IScreenResolution) separate from the IWizardPage interface of the wizard page  can be used to access the methods SetResolution() and GetResolution(). A component that desires the data stored by the method SetResolution() would query for the IScreenResolution interface, and if found, the component would then use that interface to get the desired data by calling QetResolution(). Two functions are available via another interface (e.g., an interface called IMonitor) of the wizard page . A SetMonitor() method is invoked to save away the choice made by the user with respect to the monitor that he is using. The GetMonitor() method retrieves the choice made by the user when the interface portion B was presented to him. A component that desires the data stored by the method SetMonitor() would query for the IMonitor interface, and if found, the component would then use that interface to get the desired data by calling GetMonitor(). The wizard page  has a SetColor() method or function, which can be invoked, to store the selection of color bits by the user using the wizard . A GetColor() method of the wizard page  allows retrieval of the color bits selection made by the user. Again, these two methods can be accessed by another interface (e.g., an interface called IColor) implemented by the wizard page . A component that desires the data stored by the method SetColor() would query for the IColor interface, and if found, the component would then use that interface to get the desired data by calling GetColor().","Because wizard pages - have been instantiated from the wizard page components of the architectural software framework , each wizard page inherits the QueryInterface() method. As explained in detail below, using the QueryInterface() method, one wizard page can query another wizard page for information to enhance or to customize the options presented to a user so as to ease the use of the wizard . Upon invocation, the QueryInterface() method of the wizard page  returns identifiers for, the GetResolution() function and the SetResolution() function. The QueryInterface() of the wizard page  returns identifiers for the GetMonitor() function and SetMonitor() function when the QueryInterface() is invoked. Similarly, identifiers for GetColor() and SetColor() are returned when the QueryInterface() function of the wizard page  is invoked. By using one of these identifiers, a wizard page can gain access to the information being stored by a particular wizard page, thereby allowing information to be exchanged.","A visually dynamic presentation of the exchange of information of pages ,  of the wizard  is shown in . Also shown in  are code portions A, , A, and A of the wizard base , the wizard class , the wizard page , and the wizard page  so as to focus the discussion. As previously explained, the selection of color bits may be customized depending on the resolution previously selected by a user at the wizard page . Prior to presenting the user interface B of the wizard page , the code portion A of the wizard page  invokes the QueryInterface() function using the IWizardBase interface of the code portion A of the wizard base . The code portion A realizes that it needs to invoke the GetResolution() function in order to access stored information pertaining to the selected resolution by the user.","Because the wizard page  may not know which other wizard pages implement the GetResolution() function, in order to access the stored resolution information, the wizard page  invokes the QueryInterface() of the code portion A of the wizard base  via the IWizardBase interface. The wizard base  has knowledge of prior presented wizard pages. Using its history portion C and the logic of the QueryInterface() function of the code portion A, the wizard base  can step through previously presented wizard pages and invoke the QueryInterface() function of each of these pages. For example, the QueryInterface() function in the code portion A of the wizard base  accesses the IWizardPage interface of the wizard page  and invokes the QueryInterface() method of the code portion A. In response, the QueryInterface() method of the code portion A returns the IScreenResolution interface from which the unique identifiers or signatures of two methods GetResolution() method and SetResolution() method can be obtained. Using the unique identifiers or signatures, the code portion A of the wizard page  executes the GetResolution() method to access stored information relating to the resolution set previously by the user.","If none of the pages in the history portion C of the wizard base  implements services allowing the wizard page  to access resolution information, the logic of the QueryInterface() method in the code portion A of the wizard base  accesses the IWizardClass interface and invokes the QueryInterface() of the wizard class . If the wizard class  also does not implement the services required by the wizard page  to access resolution information, an error code is returned to the wizard page  signifying that an interface through which the resolution information may be accessed cannot be found.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIGS. 4A-4G","FIGS. 3A-3F"],"b":["400","301","324","328","301","400","301","300","400","402","402","301","301"]},"From terminal A (), the method  proceeds to block  where the application  loads the wizard base . The term \u201cload\u201d means that the application  searches a memory device, such as a hard disk drive, to find a file including a dynamic link library that contains a wizard component, such as the wizard base . The application  then pulls data structures out of the file and creates an instance of the wizard component, such as the wizard base . Next, the application  communicates with the loaded wizard base  to provide the unique identification of the wizard class  that programmatically describes the wizard . See block .","The wizard base  is a piece of code that runs the wizard . The wizard base  has a user interface B as well as a piece of code A that is a mechanism which reacts when a user actuates a particular button - in the wizard . The wizard base  is contained by the architectural software framework . It can be the only component in the architectural software framework  but generally other components - along with the wizard base  comprise the architectural software framework . The wizard base  need not be customized by a developer so that wizards created from the architectural software framework  have the same feel and presentation of the user interface B of the wizard base . Hence, the wizard base  is a generic component of the architectural software framework .","Returning to , the application  provides to the wizard base  the IWizardClass interface of the wizard class . See block . Each wizard class is developed for a specific wizard, such as the wizard , that the developer wants to be executed by a user to perform a specified task. The wizard class  knows specifically about pages that will be displayed to the user in order to obtain information in the performance of the specified task. When the wizard base  receives either the unique identification of the wizard class  or the IWizardClass interface of the wizard class , the wizard base  has sufficient information to know the precise wizard (in this case the wizard ) to execute.","The wizard base , having obtained from the application  the unique identification of the wizard class  as well as the IWizardClass interface, provides the IWizardBase interface of the wizard base  back to the application . See block . As will be explained in further detail below, the application  can use the IWizardBase interface to access information provided by the user in the course of executing the wizard . At block , the wizard base  loads the wizard class . After the wizard class  has been instantiated, the wizard base  provides the IWizardBase interface to the wizard class . See block . Next, the method  proceeds to another continuation terminal (\u201cterminal A\u201d).","From the terminal A (), the method  proceeds to block  where the wizard base  asks the wizard class  to provide a wizard page to be displayed. The wizard class  internally knows the order in which the wizard pages are to be displayed. Because the wizard base  has obtained the IWizardClass interface, the wizard base  can determine via invoking the services of the wizard class  to obtain the first wizard page to be displayed. The wizard base  obtains a pointer to a wizard page to be displayed.","The wizard class  passes to the wizard base  a unique identification of a wizard page, such as pages -, that programmatically describes a portion of the wizard . See block . It should be recalled that a wizard is a collection of wizard pages. The wizard class  passes to the wizard base  a pointer to the IWizardPage interface of one of the wizard pages, -. See block . Now that the wizard base  has a pointer to one of the wizard pages, the wizard base  loads the wizard page. See block . The wizard base  also provides to the wizard page a pointer to the IWizardBase interface of the wizard base . See block . The wizard base  now displays the wizard page to the user for interaction. Next, the method  proceeds to the exit terminal B.","From the exit terminal B (), the method  proceeds to a set of method steps , defined between a continuation terminal (\u201cterminal C\u201d) and an exit terminal (\u201cterminal D\u201d). The set of method steps  determine whether information is to be exchanged and exchanges information among pages or other components of the wizard .","From terminal C (), the method  proceeds to decision block  where the wizard page, such as the wizard page , determines whether it needs to query for information to display the user interface portion B to a user. If the answer is NO, the method  proceeds to another continuation terminal (\u201cterminal C\u201d). Otherwise, if the answer is YES to the test at decision block , the method  proceeds to block  where the wizard page  executes the QueryInterface() method described by the IWizardBase interface of the wizard base .","The architectural software framework  allows information to be passed from one wizard page to another. Information from all wizard pages can be passed back to the application  that launched the wizard . It is desirable that wizard pages be able to read information from other wizard pages so that a wizard page can set its initial settings based upon earlier settings that the user has already entered on previously displayed wizard pages. Similarly, it is also desirable that the application  that launches the wizard  be able to read portions or all of the information that the user has entered on the presented wizard pages. Using the information, the application  can then carry out the operations associated with the task requested by the user. In the architectural software framework , the wizard class  is able to read information from each of the wizard pages -. This allows the wizard class  to dynamically choose which wizard page is to be displayed when the user clicks the next button  based upon the settings entered by the user on the currently displayed wizard page.","As discussed above, the user interface portion B of the wizard page  may limit the options of color bits which the user can select based upon the resolution earlier chosen by the user on the wizard page . Returning to , to facilitate the sharing of information, the architectural software framework  makes use of the fact that the wizard base , the wizard class , and the wizard pages - are components of the architectural software framework . Each component inherits the QueryInterface() method. Each component implements the QueryInterface() method individually. The QueryInterface() method returns a pointer to an interface of a component of the architectural software framework . In this way, one component can request a pointer to an interface in another component. When the requesting component receives this interface, the requesting component can then use the interface to call the methods within the called component. This allows the called component to provide information or services to the calling or requesting component.","Because the wizard page  may not know which wizard page implements the desired interface from which the wizard page  may access resolution information, the wizard page  communicates with the wizard base . Because the wizard base  is responsible for presenting wizard pages to the user, the wizard base  has knowledge using its history component C to determine whether other wizard pages implemented the desired interface.","Returning to , the process  proceeds to another decision block  where the wizard base  determines whether it implements the interface desired by the wizard page . If the answer is YES to the test at decision block , the method  proceeds to another continuation terminal (\u201cterminal C\u201d). Otherwise, the answer is NO, and the method  proceeds to another decision block. See decision block .","At decision block  the wizard base  invokes the QueryInterface() method of one of the pages in the history portion C and determines whether there is a wizard page that implements the desired interface. If the answer is YES to the test at decision block , the method  proceeds to the terminal C. Otherwise, if the answer is NO, the method  proceeds to another continuation terminal (\u201cterminal C\u201d).","In order to facilitate the exchanging of information among wizard pages and other components of the architectural software framework , typically these components have access to the IWizardBase interface of the wizard base . The wizard base  provides a pointer to the IWizardBase interface to the wizard class , to each wizard page -, and also to the application  that launches the wizard . This ensures that every component and the application has access to the IWizardBase interface, hence the ability to call back into the wizard base  to access the information exchanging facility. The IWizardBase interface implements the QueryInterface() method just like other components of the architectural software framework . Thus, other components can call the QueryInterface() method using the IWizardBase interface to get any other interfaces implemented by components of the architectural software . One suitable implementation includes the use of component object model (COM), but other suitable technology and languages can be used. For example, any customizable, tag-based languages, such as extensible markup language (XML), can be used.","The QueryInterface() method that is implemented by a conventional COM object returns the interface from inside the called COM object. If the COM object implements the interface, the COM object returns a pointer to the calling COM object. If the called COM object does not implement the interface, the called COM object returns an error. In various embodiments of the present invention, the QueryInterface() methods of various components of the architectural software framework  riot only can look for interfaces within themselves but also in other components in the architectural software framework , such as wizard pages - and wizard class .","Each wizard page - implements an IWizardPage interface which includes functions for storing and retrieving information entered by the user. Because each wizard page - implements one or more interfaces containing its information, other components can query for these interfaces in order to access the stored information for processing purposes. To query for a particular interface, a wizard page need only call or invoke the QueryInterface() method of the IWizardBase interface of the wizard base . The wizard base  then queries each wizard page, such as in an order from the most recently displayed, until the wizard base  finds a wizard page that implements the desired interface.","Returning to , from terminal C (), the method  proceeds to another decision block  where the wizard base  determines whether there are additional wizard pages in its history portion C to query for the desired interface. If the answer is YES to the test at decision block , the method  loops back to decision block  where the wizard base  queries another wizard page for implementation of the desired interface. Otherwise, if the answer is NO, the method  proceeds to another decision block. See decision block .","Decision block  is reached by the method  if there are no further wizard pages that the wizard base  can query for the desired interface. In this case, the wizard base  determines whether the wizard class  implements the desired interface. See decision block . If the answer is YES to the test at decision block , the method  proceeds to terminal C. Otherwise, if the answer is NO, the method  proceeds to block  where the wizard base  returns an error to the wizard page , which is the calling wizard page. Next, the process  enters another continuation terminal (\u201cterminal C\u201d).","From terminal C (), the method  proceeds to block  where the wizard base  returns to the wizard page  (the calling wizard page) a pointer to the desired interface IWizardPage of the wizard page . The wizard page  then invokes the GetResolution() method via the IWizardPage interface of the wizard page  to obtain the stored resolution information previously provided by a user. See block . The wizard base  then presents the wizard page  to the user with options that depend on the stored resolution information provided by the user on the wizard page . See block  (block  is also the destination of the terminal C from which the method  also enters block ). Next, the method  proceeds to the exit terminal D.","The power of the information exchanging facility discussed above is that one wizard page can request the information it needs but it need not know where the information may have come from. This allows wizard pages that have already been developed in one wizard to be reused and placed into new wizards. For example, the wizard page  can be reused in another wizard that requests the user to select one of many color bit choices. Recall that the wizard page  needs information pertaining to resolution. It is possible that in a new wizard no wizard pages of the new wizard implements an interface allowing the wizard page  to access resolution information. In this case, the services of the wizard page , which include the GetResolution() method, can be placed with the wizard class  in the new wizard. When the wizard page  queries the wizard base  for the GetResolution() method, the wizard base  eventually queries the wizard class , which implements the GetResolution() method, and returns some sort of default resolution values back to the wizard page . This reusability allows wizard pages to be plugged into entirely new wizard configurations and it allows wizard pages and wizard classes to retrieve information from one another without even necessarily knowing from which component they are receiving the information. If the information exists somewhere that is accessible by a service of an interface, a component of the architectural software framework  can access the stored information.","Returning to , from exit terminal D, the method  proceeds to a set of method steps , defined between a continuation terminal (\u201cterminal E\u201d) and an exit terminal (\u201cterminal F\u201d). The set of method steps  processes actuation of navigation buttons - on the user interface portion B of the wizard base .","From terminal E (), the method  proceeds to block  where the wizard base  waits for the user to enter information or select options on the displayed wizard page. The user then actuates a navigation button - to proceed. See block . Next, the method  enters another decision block  where it is determined whether the actuated navigation button is a Cancel button . If the answer is YES to the test at decision block , the process  terminates, hence closing the wizard , and returns back to the application  that invoked the wizard . Otherwise, if the answer is NO, the process  proceeds to another decision block  where it is determined whether the actuated button is the Back button . If the answer is YES, the process  proceeds to another continuation terminal (\u201cterminal E\u201d). If the answer is NO, the process  proceeds to another decision block. See decision block .","At decision block , it is determined whether the actuated button is the Next button . If the answer to the test at decision block  is YES, the method  proceeds to another continuation terminal (\u201cterminal E\u201d). Otherwise, the answer is NO, and the method  loops back to decision block  to execute the tests at decision blocks - again.","From terminal E (), the method  proceeds to block  where the wizard base  displays the previous wizard page using its history portion C. From block , the process  proceeds to another continuation terminal (\u201cterminal E\u201d). From terminal E (), the process  loops back to block  enabling the user to enter new information or select a new option on the previously displayed wizard page.","From terminal E (), the method  proceeds to another decision block, which determines whether the presently displayed wizard page has a child wizard page to be displayed to the user. See decision block . If the answer to the test at decision block  is YES, the method  proceeds to another continuation terminal (\u201cterminal E\u201d). From terminal E (), the method  loops back to block  to allow presentation of the child wizard page. If the answer is NO to the test at decision block , another decision block is entered by the method . See decision block . At this decision block, it is determined whether the wizard class  has another wizard page to be displayed to the user. If the answer to the test at decision block  is YES, the method  proceeds to another continuation terminal (\u201cterminal E\u201d). From terminal E, the method  loops back to block  where the wizard base once again asks the wizard class  to provide another wizard page to be displayed to the user.","Returning to , if the answer to the test at decision block  is NO signifying that no more wizard pages need be shown to the user, the wizard  terminates, and the application  collects information from all presented wizard pages of the wizard  by invoking the QueryInterface() method of the wizard base  (via the IWizardBase interface). See block . From here, the process  enters the exit terminal F. From exit terminal F (), the method  terminates execution.","While the preferred embodiment of the invention has been illustrated and described, it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same become better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3D"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3E"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3F"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 4A-4G"}]},"DETDESC":[{},{}]}
