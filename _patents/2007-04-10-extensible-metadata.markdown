---
title: Extensible metadata
abstract: Systems and methods for extensible metadata are described. In one aspect, source code is compiled to generate an assembly. During assembly generating operations, metadata and extensible metadata is emitted into the assembly. The extensible metadata describes standard and non-standard metadata that presents an extension to the standard metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08104025&OS=08104025&RS=08104025
owner: Microsoft Corporation
number: 08104025
owner_city: Redmond
owner_country: US
publication_date: 20070410
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","MetaSchema","MetaStringHeap","MetaTables","MetaHeapDef","MetaColDef","MetaToks","MetaCodedToks","MetaCodedVals","MetaFeature","UsesFeature","CONCLUSION"],"p":["This patent application is a continuation of U.S. patent application Ser. No. 10\/608,986, filed on Jun. 26, 2003, titled \u201cExtensible Metadata\u201d, and hereby incorporated by reference.","Metadata is information describing a computer program that is stored either in a common language runtime portable executable (PE) or in memory. When program code, type information and data is compiled into a PE file (i.e., an assembly), metadata is inserted into one portion of the file, whilst code is converted into an intermediate language (IL) and inserted into another portion of the file. Every type, all type members\u2014fields, methods, properties and events, are defined and referenced in a module or assembly is described within metadata. For instance, assembly metadata includes information to describe assembly identity (name, version, culture, public key, etc.), types (name, visibility, base class), exported types, descriptive elements that modify types and members, referenced assemblies, security permissions needed to run, interfaces implemented, and so on.","A metadata consumer (e.g., a browser, linker, compiler, runtime, integrated development environment (IDE), etc.) performs its respective functions by loading metadata into memory to discover information about the consumer code's types, members, inheritance, etc. Different consumers may use different metadata or share the same metadata for various purposes. Anyone building such a consumer must read and incorporate details of metadata layout, the structure of which is fixed\/\u201chardwired\u201d and enforced with a standardized schema, and semantics or meaning of the metadata to use the metadata. For instance, versions 1 and 1.1 of the Common Language Runtime (CLR) hard-wire metadata content and structure stored in assemblies\u2014that's to say, each assembly uses the same schema as documented in the well known ECMA-335-II document. Anyone building software that attempts to understand an assembly has no choice but to read and digest the details of layout and meaning defined in that document. Put another way, the metadata is not self-describing.","Entities such as computer programmers, business development, and so on, often strive to create new useful products and to improve existing products, for instance, by adding features to computer languages, the CLR, and\/or other software tools, to add a new table to change capabilities of a metadata consumer, etc. Such product development\/enhancement typically requires changes, or extensions to the kinds of metadata that are stored in existing assemblies. (Use of \u201ccustom attributes\u201d and\/or \u201ccustom modifiers\u201d associated with already standardized data is not considered a metadata extension, but rather a \u201cdecoration\u201d of already standardized data). However, since the layout of consumer metadata is hardwired with a fixed representation, such extensions will be incompatible and almost guaranteed breaking to most existing metadata consumers (i.e., applications that attempt to import the extended metadata used to support the new feature(s)). Execution of an unmodified consumer of the metadata may result in undesirable consequences such as application and\/or system crashes or lock-ups, data corruption, etc. An unmodified consumer is a metadata \u201cimporter\u201d (e.g., a compiler\/tool\/common language interface (CLI), and\/or the like) that has not been rewritten and recompiled to account for the newly added metadata.","For example, in view of a metadata extension, an unmodified metadata consumer might react as follows:\n\n","To avoid undesirable runtime failures in view of newly added metadata extension(s), each and every importer of the extension typically needs to be rewritten and recompiled to successfully parse the extension. Requiring computer programmers to rewrite and recompile metadata consumer(s) can be substantially time consuming, error prone, and labor intensive. To make matters worse, incompatible metadata consumer-breaking behavior may occur with respect to every new feature added to metadata. This problem becomes even larger when the metadata extension is to be shared across multiple different types of metadata consumers.","Accordingly, conventional systems and techniques make it substantially difficult to extend metadata to support new metadata consumer functionality without engaging in potentially time consuming, labor intensive, error-prone, and costly efforts to rewrite and recompile each and every metadata consumer that may use the modified metadata.","Systems and methods for extensible metadata are described. In one aspect, source code is compiled to generate an assembly. Whilst converting a program written in an assembly-level or higher-level language, metadata and extensible metadata is emitted into the assembly. The extensible metadata describes standard, plus non-standard metadata that presents an extension to the standard metadata.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","Overview","Systems and methods for emitting and consuming extensible (i.e., non-standard) metadata from an assembly are described. Extensible metadata describes metadata features, constructs, and\/or extensions to one or more source languages that cannot be stored or handled by standard metadata. Additionally, extensible metadata is self-describing with respect to its layout\/representation, content, and applicability to a metadata consumer. This self-describing aspect of extensible metadata allows a metadata consumer (a metadata \u201cimporter\u201d) to discover the presence, properties, and representation of the extensible metadata, as well as a suggestion of whether the importer needs to understand and incorporate semantics of the extensible metadata for proper importer functionality.","In view of the above, when a metadata consumer encounters unanticipated metadata (i.e., a non-standard metadata), the consumer can selectively implement subjectively-correct behavior by utilizing the self-describing aspect of the extensible metadata to intelligently parse the extension's layout, class information, and so on. If the extension is not understood, the consumer can selectively choose to display an error message, gracefully exit, and\/or perform some other operation\/response. This allows entities such as computer programmers to add a new feature to a metadata consumer (e.g., linkers, browsers, compilers, runtimes, interfaces, IDEs, etc.), wherein the new feature has a previously unanticipated layout or property, without breaking previously-shipped versions of the metadata consumer. Moreover, the new feature can be added independent of potentially labor-intensive, and costly rewriting\/re-compiling of the metadata consumer to parse a metadata extension associated with the new feature.","Exemplary Operating Environment","Turning to the drawings, wherein like reference numerals refer to like elements, the invention is illustrated as being implemented in a suitable computing environment. Although not required, the invention is described in the general context of computer-executable instructions, such as program modules, being executed by a personal computer. Program modules generally include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types.",{"@attributes":{"id":"p-0018","num":"0021"},"figref":"FIG. 1","b":["100","100","100","100"]},"The methods and systems described herein are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers, server computers, multiprocessor systems, microprocessor-based systems, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and so on. Compact or subset versions of the framework may also be implemented in clients of limited resources, such as handheld computers, internet-aware watches, embedded controllers in vehicles or manufacturing equipment, or other computing devices. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","As shown in , computing environment  includes a general-purpose computing device in the form of a computer . The components of computer  can include, by are not limited to, one or more processors or processing units , a system memory , and a bus  that couples various system components including system memory  to processor . The system bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnects (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer-readable media. Such media may be any available media that is accessible by computer , and it includes both volatile and non-volatile media, removable and non-removable media. In , system memory  includes computer-readable media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processor .","Computer  may further include other removable\/non-removable, volatile\/non-volatile computer storage media. For example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown and typically called a \u201chard drive\u201d), a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from or writing to a removable, non-volatile optical disk  such as a CD-ROM\/R\/RW, DVD-ROM\/R\/RW\/+R\/RAM or other optical media. Hard disk drive , magnetic disk drive  and optical disk drive  are each connected to bus  by one or more interfaces .","The drives and associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROM), and the like, may also be used in the exemplary operating environment.","A user may provide commands and information into computer  through input devices such as keyboard  and pointing device  (such as a \u201cmouse\u201d). Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, camera, etc. These and other input devices are connected to the processing unit  through a user input interface  that is coupled to bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device is also connected to bus  via an interface, such as a video adapter . In addition to monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers, which may be connected through output peripheral interface .","Computer  may operate in a networked environment using connections to one or more remote computers, such as a remote computer . Remote computer  may include many or all of the elements and features described herein relative to computer . Connections shown in  are a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, computer  is connected to LAN  via network interface or adapter . When used in a WAN networking environment, the computer typically includes a modem  or other means (e.g., wireless communications) for establishing communications over WAN . Modem , which may be internal or external, may be connected to system bus  via the user input interface  or other appropriate mechanism. Depicted in , is a specific implementation of a WAN via the Internet. Here, computer  employs modem  to establish communications with at least one remote computer  via the Internet .","In a networked environment, program modules depicted relative to computer , or portions thereof, may be stored in a remote memory storage device. Thus, e.g., as depicted in , remote application programs  may reside on a memory device of remote computer . It will be appreciated that the network connections shown and described are exemplary and other means of establishing a communications link between the computers may be used.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM , or RAM , including, e.g., an operating system (OS)  to provide a run-time environment, application programs  for EM, other program modules  (e.g., device drivers, etc.), and program data  such as source code, intermediate assemblies, and\/or the like.",{"@attributes":{"id":"p-0030","num":"0033"},"figref":["FIG. 2","FIG. 1"],"b":["106","130","134","130","202","204","202","204","202","204","202","206","232","208","206"]},"EM assembly  includes metadata  and platform\/processor-independent intermediate language (IL) instructions . As such, the EM assembly  represents an intermediate stage in the conversion of the source code into platform specific native code  for execution by a metadata consumer  (e.g., a browser, linker, compiler, and\/or other computer program that imports the metadata  portion of an EM assembly ; as well as execution of the native code by the processing unit(s)  of ). In contrast to conventional metadata, metadata  includes EM . EM  is self-describing in that it indicates its presence, properties, layout, content, and so on, to a interrogating metadata consumer . All EM  is substantially uniquely \u201ctagged\u201d, or differentiated from all \u201cnon-EM\u201d to allow a metadata importer (i.e., a consumer ) to discover the EM. Non-EM is standard metadata, which may also be represented in the metadata  portion of the EM assembly . Each EM  extension includes \u201csuggested action\u201d information. The suggested action information guides the metadata importer as to whether it must understand one or more features associated with the imported EM  to properly function. Or whether the importer may safely ignore the feature with assurance that nothing catastrophic\/undesirable will result during runtime operations if the feature is ignored. The guiding information is defined by the designer(s) of each \u201cEM emitter\u201d. An EM emitter is an entity that generates the EM .","In one implementation, the EM emitter is any computer-program application that has been designed to emit EM, such as a software tool that converts a Type Library, or XML type definition file, into a CLR assembly. In this implementation, the EM emitter is the primary compiler . During source code compiling operations, the primary compiler  emits EM  into the assembly  by interfacing with an EM emitting Application Programming Interface (API) . The API  is exposed by the runtime  as unmanaged code and does not run under the control of the runtime .","After assembly  has been generated by an EM emitter, the assembly  is available for loading and execution by one or more metadata consumers . Since a runtime  is being utilized in this implementation (the use of a runtime and all associated runtime interfaces is optional to generation and use of EM ), a metadata consumer utilizes a Just-In-Time (JIT) compiler component (not shown) of the runtime  to covert the loaded assembly into native code . During this process, the consumer  calls EM discovery API  to discover any EM  that may be associated with the loaded native code . Upon identifying EM , the consumer further interfaces with the API  to interrogate and subsequently evaluate properties and\/or suggested guideline use of the discovered EM .","For example, an importer  calls EnumTypeDefs (an API ) to retrieve details of all types defined in the current assembly . In contrast to existing techniques, the importer must check whether the information returned is tagged \u201cextension\u201d. If so, the importer must query for more information before proceeding\u2014for this, it will use the new method GetFeatureUsed of the API  to obtain a list of the features used by the assembly. (In this implementation, the API  is managed code that is exposed and runs under control of the runtime . In an alternative implementation, a method (e.g., EnumGenericTypeDefs) is used to retrieve only those type definitions that rely upon a particular feature, for example, the known \u201cGenerics\u201d feature. In this alternative implementation, multiple different species of EnumXXXTypeDefs are used by the importer to discover anything and\/or everything in the metadata .","Exemplary Extensible Metadata","We now describe exemplary aspects of the EM , which includes:\n\n","In this implementation, EM schema , or MetaSchema table is stored in a new metadata stream called #Schema that is different from other runtime streams (e.g., #Strings, #US, #Blob-\u201cBinary Large Object\u201d, #GUID, and #\u02dc). The MetaSchema table  has the following features.\n\n","EM  includes a new MetaStringHeap. It is modeled on the regular metadata String heap, storing identifier names as null-terminated UTF8 strings. It is stored in a new metadata stream called #MetaString. The MetaStringHeap is used to store meta-identifiers\u2014the name of a table (eg: \u201cNestedClassTable\u201d), of a heap (eg: \u201cUserStringHeap\u201d), the \u2018friendly\u2019 name of a feature (eg: \u201cGenerics\u201d) and so on. These are in contrast to the names stored in regular metadata heaps\u2014for example, the identifiers (names of classes, fields, methods, events, etc) for a user program.","It is suggested that the MetaStringHeap employ string interning, but this is not mandated. Any consumer  that builds dependencies upon whether a particular implementation of the MetaStringHeap interns strings is not portable.","Here is an example of the start of a MetaStringHeap. The first string is the null string \u201c \u201d at the byte offset 0x00, followed by \u201cTypeDef\u201d at byte offset 0x01, and so on. The terminating null is represented by the single \u201c\u22c4\u201d glyph.",{"@attributes":{"id":"p-0040","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Byte-Offset","UTF8 String"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0000","\u22c4"]},{"entry":["0001","TypeDef\u22c4"]},{"entry":["0009","Module\u22c4"]},{"entry":["0010","MemberRef\u22c4"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The new EM  EM MetaTables has the following column layout:\n\n",{"@attributes":{"id":"p-0042","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"8","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}},{"entry":[{},{},{},"Num",{},{},{},{}]},{"entry":["Num","Name","Flags","Cols","Pattern","Relates","SortCol","Feature"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0000","xxxx Mod","0000","0005","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0001","xxxx TypeRef","0000","0003","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0002","xxxx TypeDef","0000","0006","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0003","xxxx FieldPtr","0001","0001","0002 OneToOne","0003 Field","FFFF None","0001 Uncomp"]},{"entry":["0004","xxxx Field","0000","0003","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0005","xxxx MethPtr","0001","0001","0002 OneToOne","0006 Meth","FFFF None","0001 Uncomp"]},{"entry":["0006","xxxx Meth","0000","0006","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0007","xxxx ParamPtr","0001","0001","0002 OneToOne","0008 Param","FFFF None","0001 Uncomp"]},{"entry":["0008","xxxx Param","0000","0003","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0009","xxxx IFaceImpl","0000","0002","0001 Normal","FFFF None","0000 Class","FFFF None"]},{"entry":["000A","xxxx MembRef","0000","0003","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["000B","xxxx Const","0000","0003","0001 Normal","FFFF None","0001 Parent","FFFF None"]},{"entry":["000C","xxxx CustAttrib","0000","0003","0001 Normal","FFFF None","0000 Parent","FFFF None"]},{"entry":["000D","xxxx FieldMarshal","0000","0002","0001 Normal","FFFF None","0000 Parent","FFFF None"]},{"entry":["000E","xxxx DeclSec","0000","0003","0001 Normal","FFFF None","0001 Parent","FFFF None"]},{"entry":["000F","xxxx ClassLayout","0000","0003","0001 Normal","FFFF None","0002 Parent","FFFF None"]},{"entry":["0010","xxxx FieldLayout","0000","0002","0001 Normal","FFFF None","0001 Field","FFFF None"]},{"entry":["0011","xxxx StandAloneSig","0000","0001","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0012","xxxx EventMap","0000","0002","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0013","xxxx EventPtr","0001","0001","0002 OneToOne","0014 Event","FFFF None","0001 Uncomp"]},{"entry":["0014","xxxx Event","0000","0003","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0015","xxxx PropMap","0000","0002","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0016","xxxx PropPtr","0001","0001","0002 OneToOne","0017 Prop","FFFF None","0001 Uncomp"]},{"entry":["0017","xxxx Prop","0000","0003","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0018","xxxx MethSem","0000","0003","0001 Normal","FFFF None","0001 Meth","FFFF None"]},{"entry":["0019","xxxx MethImpl","0000","0003","0001 Normal","FFFF None","0000 Class","FFFF None"]},{"entry":["001A","xxxx ModRef","0000","0001","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["001B","xxxx TypeSpec","0000","0001","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["001C","xxxx ImplMap","0000","0004","0001 Normal","FFFF None","0001 Forw","FFFF None"]},{"entry":["001D","xxxx FieldRVA","0000","0002","0001 Normal","FFFF None","0001 Field","FFFF None"]},{"entry":["0020","xxxx Assem","0000","0006","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0021","xxxx AssemProc","0000","0001","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0022","xxxx AssemOS","0000","0003","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0023","xxxx AssemRef","0000","0009","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0024","xxxx AssemRefProc","0000","0002","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0025","xxxx AssemRefOS","0000","0004","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0026","Xxxx File","0000","0003","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0027","xxxx ExpType","0000","0005","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0028","xxxx ManRes","0000","0004","0001 Normal","FFFF None","FFFF None","FFFF None"]},{"entry":["0029","xxxx NestClass","0000","0002","0001 Normal","FFFF None","0000 Nested","FFFF None"]},{"entry":["0030","xxxx GenPar","0001","0006","0001 Normal","FFFF None","0001 Owner","0002 Generics"]},{"entry":["0031","xxxx MethSpec","0001","0002","0001 Normal","FFFF None","FFFF None","0002 Generics"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}}}}},"The new EM  EM MetaHeapDef table has the following column layout:\n\n","The following is an exemplary MetaHeapDef for metadata  heaps. (Items in italics are not stored as-is\u2014they are simply helpful annotations for the reader).",{"@attributes":{"id":"p-0045","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["Num","Name","Pattern","BaseSize","Feature","TotalSize"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0000","xxxx","0001","FFFF None","FFFF None","xxxx"]},{"entry":[{},"String","UTF8"]},{"entry":["0001","xxxx","0002","FFFF None","FFFF None","xxxx"]},{"entry":[{},"UserString","Unicode"]},{"entry":["0002","xxxx Blob","0003","FFFF None","FFFF None","xxxx"]},{"entry":[{},{},"Binary"]},{"entry":["0003","xxxx Guid","0004","0008","FFFF None","xxxx"]},{"entry":[{},{},"FixedElem"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}}},"EM  includes a new EM MetaColDef with the following layout, including layouts for \u201cextension\u201d features\u2014the FieldPtr table for uncompressed metadata. Note that assemblies  need only include details for those tables present\u2014there is no need to include the definition of all possible metadata  tables in all assemblies .",{"@attributes":{"id":"p-0047","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["TableNum","ColNum","Name","Width","Kind"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0000 Mod","0000","xxxx Gen","0002","FFFF None"]},{"entry":["0000 Mod","0001","xxxx Name","0004","0070 String"]},{"entry":["0000 Mod","0002","xxxx Guid","0002","0072 Guid"]},{"entry":["0000 Mod","0003","xxxx EncID","0002","0072 Guid"]},{"entry":["0000 Mod","0004","xxxx EndBaseId","0002","0072 Guid"]},{"entry":["0001 TypeRef","0000","xxxx ResScope","0002","0100 ResScope"]},{"entry":["0001 TypeRef","0001","xxxx Name","0004","0070 String"]},{"entry":["0001 TypeRef","0002","xxxx Namespace","0004","0070 String"]},{"entry":["0002 TypeDef","0000","xxxx Flags","0004","0101 TypeAttrib"]},{"entry":["0002 TypeDef","0001","xxxx Name","0004","0070 String"]},{"entry":["0002 TypeDef","0002","xxxx Namespace","0004","0070 String"]},{"entry":["0002 TypeDef","0003","xxxx Extends","0002","0102 TypeDefOrRef"]},{"entry":["0002 TypeDef","0004","xxxx FieldList","0002","0004 Field"]},{"entry":["0002 TypeDef","0005","xxxx MethList","0002","0006 Meth"]},{"entry":["0003 FieldPtr","0000","xxxx Field","0002","0004 Field"]},{"entry":["0004 Field","0000","xxxx Flags","0002","0103 FieldAttribs"]},{"entry":["0004 Field","0001","xxxx Name","0004","0070 String"]},{"entry":["0004 Field","0002","xxxx Sign","0002","0073 Blob"]},{"entry":["0006 Meth","0000","xxxx RVA","0004","FFFF None"]},{"entry":["0006 Meth","0001","xxxx ImplFlags","0002","0104 "]},{"entry":[{},{},{},{},"MethImplAttribs"]},{"entry":["0006 Meth","0002","xxxx Flags","0002","0105 MethAttribs"]},{"entry":["0006 Meth","0003","xxxx Name","0004","0070 String"]},{"entry":["0006 Meth","0004","xxxx Sig","0002","0073 Blob"]},{"entry":["0006 Meth","0005","xxxx ParList","0002","0008 Param"]},{"entry":["0020 Assem.","0000","xxxx HashAlgId","0004","FFFF None"]},{"entry":["0020 Assem.","0001","xxxx Ver","0008","FFFF None"]},{"entry":["0020 Assem.","0003","xxxx PubKey","0001","0073 Blob"]},{"entry":["0020 Assem.","0004","xxxx Name","0002","0070 String"]},{"entry":[". . .",". . .",". . .",". . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"An EM token is a 4-byte value. The top byte records its \u2018kind\u2019 (i.e., the table number it indexes into). The lower 3 bytes represent the row number (counted from 1) of that table. For example, the token 0x0200003C is an index into row 0x3C of the TypeDef table (whose table number is 0x02). In general, only those metadata structures indexed from the IL instruction stream are assigned a token. There is one kind of token, assigned a high byte of 0x70, that supplies a byte-offset (counted from zero) into the string heap.","The current set of tokens used is stored in the MetaToks table, thus:\n\n",{"@attributes":{"id":"p-0050","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Num","Flags","Indexes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["00","01","0000"]},{"entry":["01","01","0001"]},{"entry":["02","01","0002"]},{"entry":["04","01","0004"]},{"entry":["06","01","0006"]},{"entry":["08","01","0008"]},{"entry":["09","01","0009"]},{"entry":["0A","01","000A"]},{"entry":["0C","01","000C"]},{"entry":["0E","01","000E"]},{"entry":["11","01","0011"]},{"entry":["14","01","0014"]},{"entry":["17","01","0017"]},{"entry":["1A","01","001A"]},{"entry":["1B","01","001B"]},{"entry":["20","01","0020"]},{"entry":["23","01","0023"]},{"entry":["26","01","0026"]},{"entry":["27","01","0027"]},{"entry":["28","01","0028"]},{"entry":["2A","01","002A"]},{"entry":["2B","01","002B"]},{"entry":["70","02","0000"]},{"entry":["72","02","0002"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"EM  includes a new \u201cCodedTokens\u201d table. The CodedTokensble has the following exemplary layout:\n\n",{"@attributes":{"id":"p-0052","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Num","Name","SetSize"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0100","xxxx TypeDefOrRef","3"]},{"entry":["0101","xxxx HasConst","3"]},{"entry":["0102","xxxx HasCustAttrib","21"]},{"entry":["0103","xxxx HasFieldMarsh","2"]},{"entry":["0104","xxxx HasDeclSec","3"]},{"entry":["0105","xxxx MembRefParent","5"]},{"entry":["0106","xxxx HasSemantic","2"]},{"entry":["0107","xxxx MethDefOrRef","2"]},{"entry":["0108","xxxx MembForw","2"]},{"entry":["0109","xxxx Impl","3"]},{"entry":["010A","xxxx CustAttribType","5"]},{"entry":["010B","xxxx ResScope","4"]},{"entry":["010C","xxxx TypeMethOrDef","2"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Note that coded tokens are used in MetaColDef for the \u201ckind\u201d column. In this implementation, and for purposes of backward compatibility, values for the coded tokens are different from conventional token values, which are restricted to the values 0x00-0xFF. This is done by starting coded token values at 0x0100.","As well as recording that 0x0101 is the tokenized representation for the coded token known as \u201cHasConst\u201d, we record the set of tokens that it holds. And similarly for all other coded tokens. This is done in the MetaCodedVals table. Conceptually, the MetaCodedValues table is as follows:",{"@attributes":{"id":"p-0055","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0001 TypeRef"]},{"entry":[{},"0002 TypeDef"]},{"entry":[{},"001B TypeSpec"]},{"entry":[{},"0004 Field"]},{"entry":[{},"0008 Param"]},{"entry":[{},"0017 Prop"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The values in the MetaCodedValues table are a list of uint16s. The first entry in the MetaCodeToks table is \u201cTypeDefOrRef\u201d with a set size of 3\u2014so the first 3 uint16s in the MetaCodeVals \u201ctable\u201d\u2014{0x0001, 0x0002, 0x001B}={TypeRef, TypeDef, TypeSpec} are the members of the TypeDefOrRef coded token. And so on, for all the remaining coded tokens. Uint16s are used rather than uint8s, to accommodate the possibility in future that a coded token might have other coded tokens in its membership.","EM  includes a new \u201cFeatures\u201d table. It has the following exemplary layout:\n\n","Here is an example of a MetaFeature table in a specific assembly :",{"@attributes":{"id":"p-0059","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Num","ID","Name","Flags"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0001","0001","{6276708F-FF6E-4dfa-","xxxx Uncompressed","0000"]},{"entry":[{},{},"A2D7-D6D322C421C9}","Metadata",{}]},{"entry":["0002","0002","{4C4E403A-B278-4642-","xxxx Generics","0000"]},{"entry":[{},{},"BD07-8F9F7EB85B7B}",{},{}]},{"entry":["0007","0003","{3D71CF53-B22A-47aa-","xxxx ValueArrays","0000"]},{"entry":[{},{},"BDB1-383F0B658A92}",{},{}]},{"entry":["001F","0007","{707DB3D4-B829-404a-","xxxx Dynamic","0000"]},{"entry":[{},{},"B6BE-767F74E1D0E4}","Properties",{}]},{"entry":["0009","0009","{B28D6E81-FB85-4695-","xxxx Multiple","0000"]},{"entry":[{},{},"B918-2350762A31E4}","Inheritance",{}]},{"entry":["0035","000A","{68FD0A07-A6F8-4ae8-","xxxx Mixins","0000"]},{"entry":[{},{},"AA39-15D16AC603E6}",{},{}]},{"entry":["0027","0005","{2DC6C452-CD3A-4380-","xxxx Contracts","0000"]},{"entry":[{},{},"97C0-1D7A3B163252}",{},{}]},{"entry":["0013","0006","{90B70713-A9F1-492d-","xxxx Inner","0000"]},{"entry":[{},{},"97CF-A83AE249FB80}","Classes"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"This is a new metadata (not EM) table. It holds information about every row in every metadata table that is tagged as \u201cextended\u201d. Its layout is:\n\n","For example, a MustUnderstand mask of 0b0110 indicates that only CLR and Browsers can safely ignore the information in the table row defined by TableNum+RowNum; whilst Linkers and Compilers must understand the information to work correctly. A default MustUnderstand mask, for example, 0x0000, can be used to indicate all previous version features.","It's the UsesFeature table that a metadata importer queries when it reads an item of metadata marked with the \u201cextends\u201d bit. For performance reasons, the UsesFeature table is sorted by TableNum+RowNum columns (eg, for fast binary chop search).","Extensible Metadata Suggested Action\/Use Information","As noted above, each EM -provided extension further includes \u201csuggested action\u201d information. The suggested action information guides a metadata importer (consumer ) as to whether it must understand the feature associated with the imported EM  to properly function, or whether the importer may safely ignore the feature (i.e., with an implied assurance that nothing catastrophic\/undesirable will result during runtime operations if the importer ignores the feature). For purposes of discussion, software has to understand a feature if it needs to include code that explicitly checks for that feature's presence, and takes some action based on that feature. Defining such guiding information for each feature presented by new EM  implies careful thought by an EM emitter.","For example, in this implementation, when the EM  represents:\n\n","When it is substantially difficult to identify in advance how a particular type of consumer  (e.g., browser, compiler, runtime, linker, etc.) should respond to an EM -provided feature, the emitter marks the feature as \u201cmust understand\u201d for each type of importer.","An Exemplary Procedure",{"@attributes":{"id":"p-0066","num":"0131"},"figref":["FIG. 3","FIGS. 1 and 2","FIG. 2"],"b":["300","218","302","206","232","208","218","224","218"]},"As described above, the emitted EM  is self-describing to an EM consumer  (including the runtime ). The EM is tagged, or differentiated such that is can be differentiated by a metadata consumer from the standard metadata. During compilation operations, the primary compiler (the compiler that converts a source language into Intermediate Language (IL)) and generates a string heap (e.g., see \u201cother data\u201d ) to store character strings associated with the EM . The primary compiler emits compiled source code as metadata , which includes standard metadata and EM , into the assembly .","At block , a metadata consumer  (e.g., a browser, a linker, a compiler, and\/or a runtime) loads the assembly into memory. At block , the metadata consumer interrogates one or more portions of the assembly  to discover presence properties, and\/or representation of the EM . This operation is completely independent of whether or not the metadata consumer was designed to parse the layout, representation, semantics, and\/or use the one or more new features associated with the EM. In this implementation, the metadata consumer performs these discovery and interrogation operations by interfacing with API  exposed by the runtime . At block , the metadata consumer  uses information from the discovery and interrogation operations to determine whether it must understand the operations of the discovered EM to properly function, may safely ignore the discovered metadata, and\/or perform other implementation specific actions.","We now describe several exemplary applications of the procedure .","In one implementation, a metadata consumer  such as a browser uses information from assembly  discovery and interrogation operations to navigate the corresponding EM . Responsive thereto, the browser pretty-prints at least a subset of the content described by the EM . The at least a subset may include metadata corresponding to a particular method, new metadata feature, and\/or so on. Since the browser is designed to interface with the EM , the browser performs such navigating and pretty printing operations without being rewritten and recompiled (i.e., completely independent of whether the assembly  includes metadata extensions for features that, at the time of the browser's development, had not been defined).","In yet another example, a metadata consumer  is an assembly linker that uses information from assembly  discovery and interrogation operations to successfully link\/merge multiple different assemblies  together to generate a single output assembly. For purposes of discussion, such an output assembly or any other metadata consumer output is represented by respective portions of other data\u201d  of . At this point, any metadata consumer  (i.e., in addition to the assembly linker) can consume the output assembly without any need to rewrite and recompile the metadata consumer to resolve any conflicting use of metadata tables or heap use by respective ones of the merged assemblies. This is the case, even when the input assemblies embed a same numbering of one or more metadata tables and\/or heaps to describe totally different features or constructs, which may have been decided in isolation by their respective producers (i.e., via proprietary implementations). Even in view of such diverse assembly characteristics, a metadata consumer can parse the linked assembly (output assembly) to identify the meaning, representation, or interpretation of each such private metadata extension completely independent of whether the private metadata extension(s) had been defined at the time of the browser's development.","The described systems and methods provide for EM. Although the systems and methods have been described in language specific to structural features and methodological operations, the subject matter as defined in the appended claims is not necessarily limited to the specific features or operations described. Rather, the specific features and operations are disclosed as exemplary forms of implementing the claimed subject matter.","For example, although the EM emitter  of  is described as interfacing with APIs  to emit EM  into EM assembly , this description is only illustrative and other implementations could have been described. For instance, in a different implementation, the EM  does not utilize the exposed API  of the runtime  to emit EM  into the assembly , but rather utilizes a different API exposed by a different computer-program module, or alternatively, directly writes the EM  into the assembly, independent of any intermediate module and\/or API.","Additionally, although metadata consumer  of  is described as interfacing with APIs  to discover\/interrogate EM  portions of the EM assembly , this description is only illustrative and other implementations could have been described. For instance, in a different implementation, the EM  does not utilize the exposed API  of the runtime  to emit EM  into the assembly , but rather utilizes a different API exposed by a different computer-program module, or alternatively, directly writes and reads the EM  into\/from the assembly independent of any intermediate module and\/or API."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The following detailed description references the accompanying figures. In the figures, the left-most digit of a component reference number identifies the particular figure in which the component first appears.",{"@attributes":{"id":"p-0012","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0016"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0014","num":"0017"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
