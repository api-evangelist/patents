---
title: Apparatus and method for buffering data
abstract: A data buffering apparatus comprises a plurality of sessions and buffer logic. The plurality of session are respectively associated with session identifiers. Each of the sessions is configured to identify entries in a queue having the session's associated identifier and to pull, from the queue, the identified entries. Each of the sessions is further configured to retrieve data from the buffers pointed to by the identified entries that have the session's associated identifier. The buffer logic is configured to store a set of data to one of a plurality of buffers. The buffer logic is further configured to store, in the queue, for each expected retrieval of the set of data from the one buffer by the sessions, an entry that points to the one buffer and has a different session identifier associated with a different one of the sessions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06914607&OS=06914607&RS=06914607
owner: Hewlett-Packard Development Company, L.P.
number: 06914607
owner_city: Houston
owner_country: US
publication_date: 20030208
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["In some graphics systems, graphical data is communicated through a network, such as a local area network (LAN) or wide area network (WAN), to remote locations where the graphical data is rendered. Unfortunately, transmission of the graphical data through a network can introduce significant delays thereby degrading or limiting the performance of the graphics system. Indeed, remote rendering for some graphics applications that produce large amounts of graphical data is not always feasible.","Further, in some graphics systems, graphical data may be communicated from a transmitting unit through a network to a large number of remote receiving units, which render the graphical data via known techniques. Unfortunately, the delays introduced by the network can be particularly problematic for such communication. In this regard, the transmitting unit may be configured to transmit each graphics command multiple times through the network (e.g., once for each destination receiving unit that is to receive the command). The multiple transmissions of the graphics commands can significantly increase the amount of data that is to be buffered and communicated through the network.","Thus, better techniques for communicating and buffering data within a network communication system are generally desirable. Generally, embodiments of the present invention provides an apparatus and method for buffering data.","An exemplary data buffering apparatus in accordance with one embodiment of the present invention comprises a plurality of sessions and buffer logic. The plurality of session are respectively associated with session identifiers. Each of the sessions is configured to identify entries in a queue having the session's associated identifier and to pull, from the queue, the identified entries. Each of the sessions is further configured to retrieve data from the buffers pointed to by the identified entries that have the session's associated identifier. The buffer logic is configured to store a set of data to one of a plurality of buffers. The buffer logic is further configured to store, in the queue, for each expected retrieval of the set of data from the one buffer by the sessions, an entry that points to the one buffer and has a different session identifier associated with a different one of the sessions.","An exemplary data buffering method in accordance with one embodiment of the present invention comprises respectively associating a plurality of sessions with session identifiers, storing a set of data to one of a plurality of buffers, storing, in a queue, for each expected retrieval of the set of data from the one buffer by the sessions, an entry that points to the one buffer and has a different session identifier associated with a different one of the sessions, and retrieving, via different ones of the sessions, the set of data from the one buffer based on entries stored to the queue via the storing.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 1","FIG. 1"],"b":["20","21","21","22","24","21","24","21","21","24"]},"As shown by , the transmitting unit  preferably comprises at least one graphics application  that produces graphical data for transmission through the network . In the embodiment shown by , each graphics application  communicates with a corresponding set of buffer logic . When a graphics application  is invoked for communicating graphical data to at least one receiving unit , the graphics application  notifies its corresponding buffer logic , and this buffer logic  preferably submits a request, referred to hereafter as a \u201csession request,\u201d to a transport manager . In response, the transport manager , as will be described in more detail hereinafter, associates the graphics application  with at least one of a plurality processes , referred to herein as \u201ccommunication sessions.\u201d As will be described in more detail below, each session  is responsible for interfacing, with the network , graphical data produced by its associated graphics applications .","In this regard, each graphics application  produces graphical data via known or future-developed techniques, and its corresponding buffer logic  stores the graphical data within a shared resource  that is accessible by each buffer logic , as well as each communication session  shown in FIG. . Session logic  within each communication session  searches the shared resource  for data that its communication session  is responsible for interfacing with the network . When the session logic  within a particular communication session  finds, in the shared resource , graphical data from a graphics application  associated with the particular communication session , the session logic  retrieves such graphical data from the shared resource . The particular communication session  then interfaces the retrieved graphical data with the network  such that the data is communicated to the appropriate receiving units .","Since communication of the graphical data with the network  is handled by associated communication sessions , a graphics application  and\/or its corresponding set of buffer logic  may begin performing other tasks once the graphical data has been written to the shared resource . In this regard, it may be assumed, by the graphics application  and\/or its corresponding set of buffer logic , that the graphical data will be successfully transmitted to the appropriate receiving units  once the graphical data has been stored in the shared resource . Thus, after the graphical data has, in fact, been stored in the shared resource , the graphics application  may begin to immediately process the next set of graphical data. As a result, delays introduced by the communication of graphical data through the network  preferably do not significantly impact the performance of the graphics application .","Furthermore, each communication session  preferably runs on a separate thread of execution as compared to the graphics application  and the other communication sessions . As a result, the consumption of processing resources by each communication session  preferably does not significantly reduce the processing speed of the graphics application  and to the other communication sessions . However, it should be noted that, in other embodiments, it is possible for multiple ones of the communication sessions  to be implemented on the same thread of execution as another communication session  or as a graphics application .","It should be further noted that there are various techniques and protocols that may be employed to buffer data in the shared resource . Exemplary techniques for achieving this functionality will now be described in more detail below.","When a graphics application  is ready to initiate communication with at least one receiving unit , this graphics application , referred to hereafter as the \u201ctransmitting application ,\u201d notifies its corresponding set of buffer logic , referred to hereafter as the \u201ctransmitting buffer logic .\u201d In response to such notification, the transmitting buffer logic  is configured to submit a session request to the transport manager . This session request may identify (e.g., include the address of) each receiving unit  to which graphical data from the transmitting graphics application  is to be communicated, and the session request also may identify the type of transport protocol that is to be used to communicate such graphical data.","In a preferred embodiment, the network  is an internet protocol (IP) network, and the session request comprises the IP address of each receiving unit  that is to receive graphical data from the transmitting application . Further, the communication sessions  may be configured to enable various types of protocols for communication across the network . As an example, the communication sessions  may selectively enable communication via transmission control protocol (TCP), user datagram protocol (UDP), UDP-multicast (UDPM), and\/or any other type of known or future-developed protocol.","In response to the session request, the transport manager  selects a set of communication sessions  to service the transmitting graphics application  (i.e., to handle the communication of the transmitting graphics application's data with the network ). In this regard, the transport manager  preferably analyzes each active communication session  to determine whether any of the active sessions  are currently communicating data to the same set of receiving units  via the same protocol identified by the session request. Note that a communication session  is \u201cactive\u201d when it is currently handling the communication of at least one graphics application , and a communication session  is \u201cinactive\u201d when it is not presently handling the communication of any of the graphics applications . Further note that while in an inactive state, a communication session  is preferably not running (e.g., is asleep) and, therefore, does not significantly consume processing resources.","Moreover, if the transport manager  identifies any communication sessions  that are communicating to the same set of receiving units  via the same protocol identified by the session request, the transport manager  may be configured to select such identified communication sessions , if any, to service the transmitting graphics application . Note that such communication sessions  may exist when another graphics application  has previously initiated communication, via the same protocol requested via the session request, with the same set of receiving units  identified by the session request.","If none or an insufficient number of the active communication sessions  are presently communicating with the same set of receiving units  and with the same transport protocol, then the transport manager  preferably also selects at least one of the inactive communication sessions  to service the graphics application . For each selected inactive session , the transport manager  activates (e.g., awakens) the selected session  and configures the session  to communicate, via the transport protocol identified by the session request, with the set of receiving units  also identified by the session request.","In this regard, the transport manager  preferably stores or maintains sufficient information for enabling the manager  to find and initiate communication with each of the receiving units . Moreover, when the transport manager  receives a session request from the transmitting buffer logic , the manager  establishes a network socket (not specifically shown in ) configured to interface data with the network  via the transport protocol identified by the session request. Using this socket, the transport manager  establishes communication with each receiving unit identified by the session request. Once such communication is established, the transport manager  hands-off or, in other words, allocates the foregoing socket to at least one session  activated for servicing the requesting application . The activated session  may then utilize such socket for communicating with the identified receiving units  according to techniques that will be described in more detail hereinbelow.","Note that the number of sessions  selected to service a particular application  may vary depending on various factors and\/or the configuration of the system . For example, the graphics application  or the buffer logic  that initiated the session request may be configured to request that a particular number of sessions  be utilized for communicating the graphical data produced by the graphics application . The transport manager  may then be configured to select such a number of sessions  for servicing the graphics application  to the extent that such a number of sessions  is available.","In an alternative embodiment, the transport manager  may be configured to determine the number of communication sessions  to be used for servicing a particular application . For example, the transport manager  may be configured to allocate or select approximately the same number of sessions  for each application . In another embodiment, the transport manager  may prioritize the applications  according to any known or future-developed algorithm and then allocate a larger number of sessions  to service the applications  assigned higher priorities. Further, if a desired number of sessions  are not available for servicing a particular application , the transport manager  may be configured to reallocate at least one of the active sessions  such that the reallocated sessions  service (i.e., communicate the graphical data produced by) the particular application . Techniques for allocating and reallocating the sessions  will be described in more detail hereinbelow.","The transport manager  preferably assigns, to each set of communication sessions  configured to transmit to the same receiving units  via the same protocol, an identifier that uniquely identifies such sessions  from the other sessions  that also may retrieve data from the shared resource . The transport manager , after selecting a set of the communication sessions  for servicing the transmitting graphics application , as described above, provides the session identifier of the selected set to the transmitting buffer logic . As will be described in more detail hereinbelow, the transmitting buffer logic  then uses this session identifier when storing, to the shared resource , graphical data that is to be communicated to the receiving units .","As shown by , the shared resource  preferably comprises an entry queue  and shared memory  accessible by each of the sets of buffer logic  and the communication sessions . The shared memory  is preferably partitioned into multiple segments or blocks , referred to as \u201cbuffers.\u201d As shown by , each buffer  comprises a header , where various control information may be stored, and a data portion , where data (e.g., graphical data from one of the graphics applications ) to be communicated over the network  may be stored. Techniques for storing and retrieving data to and from the buffers  will be described in more detail hereinbelow.","The entry queue  of  preferably stores a plurality of queued entries , and each entry  has a session identifier (ID)  and a pointer , as shown by FIG. . Initially, the number of entries  corresponds to the number of buffers . More specifically, in the exemplary embodiment shown by , there is initially one entry  for each buffer . Further, each entry  preferably corresponds to a different buffer , and the pointer  of an entry  corresponding to a particular buffer  preferably points to (i.e., identifies) the particular buffer . Thus, initially, each entry  corresponds to and points to a different buffer .","Initially, the session identifier  of each entry  comprises a value, referred to hereafter as an \u201cempty buffer value,\u201d which indicates that the buffer  identified by the entry's pointer  is empty (i.e., may be written to without corrupting or losing data). Note that once operation of the system  is begun, new entries  having other values stored as the session identifier  are preferably pushed into the queue  as will be described in more detail hereafter. Thus, after operation of the system  is initiated, some of the entries  may have the empty buffer value stored as their session identifiers , and some of the entries  may other values stored as their session identifiers .","Moreover, when the transmitting application  is ready to transmit a set of graphical data to a set of receiving units , its corresponding set of buffer logic  (i.e., the transmitting buffer logic ) searches the queue  for an entry  having the empty buffer value stored as the entry's session identifier . Such an entry  is referred to herein as an \u201cempty buffer entry .\u201d When the transmitting buffer logic  locates such an empty buffer entry , it pulls the entry  from the queue  or, in other words, \u201cpops\u201d the entry  such that the entry  is no longer stored in the queue , thereby disabling other components of the transmitting unit  from accessing the popped entry . The transmitting buffer logic  then writes the aforementioned set of graphical data to the buffer  pointed to or, in other words, identified by the pointer  of the popped entry . For illustrative purposes, the foregoing buffer  will be referred to hereafter as the \u201cused buffer .\u201d","After popping, from the queue , an empty buffer entry  identifying the used buffer  and then writing to the used buffer , the transmitting buffer logic  pushes, into the queue , an entry  having the same pointer  as the popped entry  (i.e., having a pointer  identifying the used buffer ). However, the transmitting buffer logic  assigns the session identifier  of the pushed entry  the value of the session identifier previously provided to it by the transport manager . In other words, the session identifier  of the pushed entry  is associated with or identifies the set of communication sessions  that have been selected, by the transport manager , to service the transmitting application .","Note that, in one exemplary embodiment, each set of buffer logic  is configured to write data to a buffer  only when the set of buffer logic  is able to locate, in the queue , an empty buffer entry  that points to the particular buffer , as described above. Thus, by popping, from the queue , an empty buffer entry  identifying the used buffer , the transmitting buffer logic  temporarily prevents or disables other sets of buffer logic  from writing to the used buffer , thereby preventing corruption of the graphical data written to the used buffer  by the transmitting buffer logic .","When a set of buffer logic  pushes an entry  into the queue , the set of buffer logic  preferably increments a value, referred to herein as the \u201cconsumer count \u201d (FIG. ), in the header  of the buffer  identified by the pushed entry . Thus, in the example described above where the transmitting buffer logic  pushes, into the queue , an entry  pointing to the used buffer , the transmitting buffer logic  increments the consumer count  in the header  of the used buffer . Initially, the consumer count  in each of the headers  is set to a value of zero (0). Thus, if the transmitting buffer logic  is the first set of buffer logic  to write to the used buffer  after initialization, the transmitting buffer logic  increments the consumer count  in the header  of the used buffer  to a value of one (1). As will become apparent in the following description of the system , the consumer count  in the header  of a buffer  generally indicates the number of entries  (excluding empty buffer entries) in the queue  that point to the buffer .","In addition to incrementing the consumer count  of a buffer  after writing graphical data to the buffer , buffer logic  also stores, in the header , a value uniquely identifying the graphics application  that produced the data written to the buffer . This value will be referred to herein as the \u201capplication identifier .\u201d Thus, by analyzing the application identifier  in the header  of a buffer , it is possible to determine which application  produced the data that is stored in the data portion  of the buffer . Utilization of the application identifier  will be described in more detail hereafter. Note that the application identifier  of each application  may be predefined and provided by the graphics applications , or the transport manager  may be configured to assign a unique application identifier to each application  that initiates a session request transmitted to the transport manager .","The session logic  of each active communication session  preferably searches the queue  for any entries  that have session identifiers  identifying its communication session . When such an entry  is found, the session logic  pulls the entry  from the queue  or, in other words, \u201cpops\u201d the entry  such that the entry  is no longer stored in the queue  thereby disabling other components of the transmitting unit  from accessing the popped entry . The session logic  then retrieves the graphical data stored in the buffer  identified by the popped entry's pointer  () and provides the retrieved data to a network interface , which transmits the retrieved data to the network  (FIG. ). As described above, when a session  is activated, it is instructed by the transport manager  to communicate, via a certain protocol, over the network  to a set of identified receiving units . Moreover, when the session  pops an entry  from the queue  and retrieves the graphical data stored at the buffer  identified by the popped entry , the session  transmits, according to the certain protocol, the retrieved data over the network  to the identified receiving units .","As an example, assume that the aforementioned session request submitted by the transmitting buffer logic  to the transport manager  requested a set of sessions  that communicate via TCP to a particular set of receiving units . In such an example, the sessions  selected by the transport manager  to service the transmitting application  are configured to transmit any graphical data retrieved from the buffers  by such sessions  to the particular set of receiving units  according to TCP. Thus, when any of such sessions  pops an entry  pointing to the buffer  storing graphical data produced by the transmitting application , the session  retrieves and packetizes this graphical data. Then, using the addresses provided to the session  by the transport manager  (e.g., the addresses in the aforementioned session request), the session  transmits the packetized graphical data to each of the receiving units  within the particular set of receiving units . The session  preferably includes, in each packet, the application identifier  in the header  of the buffer  from which the graphical data is retrieved. Thus, for each packet of data transmitted through network , devices or systems at the receiving unit  may determine which application  produced the received data. Co-pending and commonly-assigned U.S. Patent Application entitled \u201cApparatus and Method for Communicating with a Network,\u201d and filed on Feb. 8, 2003, which is incorporated herein by reference, describes exemplary techniques for transmitting data from the transmitting unit  and receiving data at the receiving units .","It should be noted, that when the transport manager  selects more than one session  to service the transmitting graphics application , there are a plurality of sessions  searching the queue  for entries  that point to buffers  storing graphical data from the transmitting application . In particular, each of the sessions  selected, by the transport manager , to service the transmitting application  searches the queue  for entries  having the session identifier  associated with the selected set of sessions . However, since each session  pops an entry  from the queue  when it locates an entry  having the associated session identifier , the other selected sessions  that are searching for the same session identifier  are prevented or disabled from finding the popped entry . Thus, only the session  that pops the entry  from the queue  accesses and transmits, across the network , the data stored in the buffer  pointed to by the popped entry . Therefore, multiple transmissions of the same graphical data by multiple sessions  is prevented even though multiple sessions  may be allocated for servicing the same application  and, therefore, assigned the same session identifier. Such a feature helps to reduce needless additional transmissions of the same graphical data thereby helping to enhance the efficiency of the system .","It should be further noted that it may desirable for the graphical data produced by the transmitting application  to be displayed locally. Thus, as shown by , the system  comprises at least one rendering session  that is configured to locally render graphical data from the shared memory . In this regard, each rendering session , like the communication sessions , is preferably associated with a session identifier that identifies the rendering session . If the graphical data written to the used buffer  is to be rendered locally in addition to being transmitted over the network , the transmitting buffer logic  is configured to push, into the queue , an additional entry  for each rendering session  that is to separately retrieve and render the graphical data in the used buffer . Each such additional entry  preferably has a pointer  () identifying the used buffer  and has a session identifier  identifying the rendering session  that is to retrieve and render the graphical data in the used buffer . The transmitting buffer logic , upon pushing each such additional entry  into the queue , also increments the consumer count  in the header  of the used buffer . Thus, the queue  may simultaneously have multiple entries  with pointers  pointing to the used buffer .","Each rendering session , like the communication sessions , has session logic  that is configured to search the queue  for entries  having a session identifier  that identifies the logic's rendering session . When this session logic  locates such an entry , the session logic  pops the entry  from the queue  and retrieves the graphical data stored in the data portion  of the buffer  pointed to by the pointer  of the popped entry . The rendering session  then renders this retrieved data via a graphics accelerator  to a local display device  (FIG. ), which displays the rendered data.","As an example, assume that it is desirable for each of two rendering sessions  to separately render each set of graphical data produced from the transmitting application . When handling the session request initiated by the transmitting application , the transport manager  preferably assigns each of the two rendering sessions  different session identifiers . The transport manager  may then provide each of these session identifiers  to the transmitting buffer logic . In such an example, the transmitting buffer logic , in addition to pushing an entry  pointing to the used buffer  and identifying the selected communication sessions , also pushes two additional entries  to the queue . Each such additional entry  points to the used buffer  and has a session identifier  identifying a different one of the two rendering sessions . Thus, each rendering session , upon locating the additional entry  that identifies it, pops this additional entry  from the queue  and then reads the used buffer  that is pointed to by the additional entry . The rendering session  then renders this retrieved data. As a result, both rendering sessions  retrieve and render the graphical data stored in the used buffer .","In another example, it may be desirable for only one of the two rendering sessions  to render the graphical data stored in the used buffer . In such an example, the transport manager  may assign both rendering sessions  the same session identifier . In such an example, the one session identifier  is provided to the transmitting buffer logic , and the transmitting buffer logic  pushes only one additional entry  to the queue  in addition to the aforedescribed entry  that identifies the selected communication sessions . The additional entry  comprises the session identifier  provided by the transport manager , and the first of the two rendering sessions  to find the additional entry  pops the entry  from the queue  in response to a determination that the additional entry  identifies it. This rendering session  then retrieves and renders the graphical data stored in the used buffer .","By popping the additional entry , the foregoing rendering session  prevents or disables the other rendering session  from finding the additional entry , thereby preventing the other rendering session  from rendering the same graphical data. In such an example, each rendering session  renders a portion of the graphical data produced by the transmitting application . Rendering of graphical data by multiple rendering sessions  in this manner helps to decrease the amount of graphical data that each rendering session  would otherwise render if both rendering sessions  were not allocated to the same graphics application .","Note that a graphics application  or its corresponding set of buffer logic  may request the number of rendering sessions  that are allocated for locally rendering its graphical data. Provided that the requested number of rendering sessions  are available, the transport manager  may allocate the rendering sessions  as requested. However, the transport manager  may also be configured to dynamically allocate and reallocate the rendering sessions  based on run-time conditions, such as, for example, the number of applications  requesting local rendering, the amount of graphical data produced by such applications , etc. To reallocate a rendering session  to a different application , the transport manager  may simply assign the rendering session  a new session identifier  and then provide this new session identifier  to the different application . Upon being assigned a new session identifier , the rendering session  stops searching for its previous session identifier  and begins searching the queue  for its new session identifier . Thus, the rendering session  stops rendering data from the application  previously serviced by it and begins rendering data from the different application .","After a session  or  retrieves graphical data from a buffer  as described above, the session  or  preferably decrements the consumer count  () stored in the buffer's header . If the consumer count  is decremented to zero by the session  or , then there are preferably no entries  in the queue  that identify the buffer . In this regard, all such entries  previously pushed to queue  have been popped from the queue  according to the techniques described above. Thus, the data portion  may be overwritten since each session  or  that is to process the graphical data stored in data portion  has already retrieved such data from the shared memory . Therefore, when a session  or  decrements the consumer count  to zero, the session  or  preferably pushes, into the queue , an empty buffer entry  having a pointer  that points to the foregoing buffer . Such an action has the effect of freeing the buffer  such that any of the sets of buffer logic  may write into the buffer  once such logic  has located and popped the foregoing empty buffer entry .","However, if the consumer count  in the header  is greater than zero after being decremented by a session  or , then there is at least one other entry  that points to the buffer  and identifies another session  or . Thus, there is another session  or  that is to use the graphical data in the data portion  of the buffer  once the other session  or  locates and pops the other entry . To prevent such data from being overwritten until the other session  or  is able to retrieve the data, the session  or  that decremented the consumer count  preferably skips the step of pushing, into the queue , an empty buffer entry  that points to the buffer  containing the decremented consumer count . As a result, until the other session  or  retrieves the graphical data stored in the buffer and then pushes such an empty buffer entry  into the queue , none of the sets of buffer logic  will write into the buffer .","It should be noted that, at each receiving unit , similar techniques for buffering the graphical data received from the network  may be employed. In this regard, as shown by , each receiving unit  preferably comprises at least one receiver , a transport manager , a shared resource , and at least one rendering session  similar in configuration and operation as the rendering sessions  of FIG. . The shared resource  is preferably accessible by each receiver  and each rendering session . Further, similar to the shared resource  described above, the shared resource  at the receiving unit  preferably comprises an entry queue  and shared memory , and the shared memory  is preferably partitioned into multiple buffers .","When contacted by the transport manager  () of the transmitting unit , the transport manager  of  is configured to establish a network socket (not specifically shown in ) for communicating with the network socket that is handed-off by the transport manager  to one of the communication sessions . Similarly, the transport manager  hands-off the established network socket to at least one of the receivers  to enable such receiver  to communicate with the foregoing communication session  via the sockets established by the transport managers  and . Techniques that may be employed by the transport managers  and  to establish network sockets will be described in more detail hereinbelow.","As shown by , the entry queue  preferably stores a plurality of queued entries , and each entry , as shown by , has a pointer  and an application identifier , which is received from the network . Like the pointers  of the queue entries  of  that identify buffers  () in shared memory , the pointers  of the queue entries  point to or, in other words, identify buffers  in the shared memory . Initially, the number of entries  corresponds to the number of buffers . More specifically, there is initially one entry  for each buffer . Further, each entry  preferably corresponds to a different buffer , and the pointer  of the entry  corresponding to a particular buffer  preferably points to (i.e., identifies) the particular buffer . Thus, initially, each entry  corresponds to and points to a different buffer .","Like the session identifiers  of the entries  in , the application identifier  of each entry  initially comprises an empty buffer value indicating that the buffer  identified by the entry's pointer  is empty (i.e., may be written to without corrupting or losing data). Note that once operation of the system  is begun, new entries  having other values stored as the application identifier  are preferably pushed into the queue , as will be described in more detail hereafter. Thus, after operation of the system  is initiated, some of the entries  may have the empty buffer value stored as their application identifiers , and some of the entries  may other values stored as their application identifiers .","Moreover, when a receiver  receives graphical data from the network , buffer logic  within the receiver  searches the queue  for an entry  having the empty buffer value stored as the entry's application identifier . Such an entry  is referred to as an \u201cempty buffer entry .\u201d When the foregoing logic , referred to hereafter as the \u201creceiving buffer logic ,\u201d locates such an empty buffer entry , the receiving buffer logic  pulls the empty buffer entry  from the queue  or, in other words, \u201cpops\u201d the entry  such that the empty buffer entry  is no longer stored in the queue . The receiving buffer logic , then writes the received graphical data to the buffer  pointed to or, in other words, identified by the pointer  of the popped entry . For illustrative purposes, the foregoing buffer  will be referred to hereafter as the \u201cused buffer .\u201d","As shown by , each buffer  comprises data portion  and a header . In general, graphical data is stored in the data portion , and various control information is stored in the header . As an example, the buffer logic  may write, into the header , the application identifier  identifying the application  that produced the data presently stored in the data portion . The header  also preferably comprises a consumer count  that generally indicates the number of rendering sessions  that are to read and utilize the data stored in the data portion . The consumer count  is preferably initialized to a value of zero (0) but may be incremented and decremented, as will be described in more detail below.","After popping, from the queue , the empty buffer entry  identifying the used buffer , the receiving buffer logic  pushes, into the queue , at least one entry  having the same pointer  as the popped entry  (i.e., having a pointer  identifying the used buffer ). However, the receiving receiver  assigns the application identifier  of the pushed entry  the value of the application identifier transmitted along with the graphical data over the network . Thus, the application identifier  of the pushed entry  identifies the graphics application  that originally produced the graphical data being stored in the used buffer  by the receiving buffer logic . Note that the buffer logic  also sets the consumer count  of the foregoing buffer  to a value when writing to the buffer , and the number of the aforementioned entries  pushed to the queue  by the logic  preferably corresponds to the consumer count value, as will be described in more detail hereinbelow.","Note that each receiver  is preferably configured to write data to a particular buffer  only when the receiver  is able to locate an empty buffer entry  in the queue  that points to the particular buffer . Thus, by popping, from the queue , an empty buffer entry  identifying a buffer , a receiver  temporarily prevents or disables other receivers  from writing to the buffer , thereby preventing corruption of the graphical data written to the buffer .","Like the transport manager  of , the transport manager  of the receiving unit  depicted by  preferably allocates at least one rendering session  for rendering the graphical data from a particular application . This may be achieved by providing the application's identifier  to each rendering session  that is to render the application's graphical data. Session logic  of each such rendering session  then searches the entry queue  for entries  having the application identifier  provided to the session  much in the same manner that each rendering session  of  searches the queue  for entries  having the session identifier  provided to the session  by the transport manager . When the session logic  finds such an entry , the session logic  pops the entry  from the queue  and retrieves the graphical data stored in the buffer  pointed to by the popped entry . The session logic  then renders the retrieved data to at least one display device  via a graphics accelerator . Note that the application identifier of each application , if not already known by the transport manager , may be transmitted to the transport manager  by the transport manager  of  or some other component of the transmitting unit .","Like the transport manager  of , the transport manager  may allocate and reallocate different rendering sessions  to different graphics applications . To allocate a rendering session  to a particular application , the transport manager  may transmit, to the session , a command referred to herein as an \u201callocation command\u201d that comprises the application identifier identifying the particular application . In response to such a command, the session logic  of the session  that receives the command may begin searching, in the queue , for the application identifier that is included in the command. To unallocate a session  from servicing a particular application , the transport manager  may transmit, to the session , a command referred to herein as an \u201cunallocate command\u201d that comprises the application identifier identifying the particular application . In response to such a command, the session logic  of the session  that receives the command may stop searching for the application identifier included in the command.","Furthermore, like the transport manager  of , the transport manager  of the receiving unit  depicted by  may control whether or not each set of graphical data produced by a particular graphics application  is rendered by each rendering session  allocated to the transmitting application . In this regard, the transport manager  preferably provides, to each receiver , the application identifier of each graphics application  that produces data received by the receiving unit . Along with this application identifier, the transport manager  also preferably provides a number, referred to hereafter as a \u201csession count.\u201d If each rendering session  allocated to the application  identified by the associated application identifier is to render each set of graphical data produced by such application , then the transport manager  transmits, as the session count, a value indicative of the total number of rendering sessions  allocated to the foregoing graphics application . However, if each set of graphical data produced by the foregoing application  is to be rendered by only one of the allocated rendering sessions , then the transport manager  sets the session count to a value of one (1). Utilization of the session count provided to a receiver  will be described in more detail hereinbelow.","Moreover, when a receiver  receives a set of graphical data and stores the graphical data into a buffer , as described above, the buffer logic  of this receiver  preferably sets the value of the buffer's consumer count . In this regard, the buffer logic  analyzes the associated session count that was previously provided by the transport manager  along with the application identifier identifying the application  that produced the graphical data. The buffer logic  then increments the consumer count  of the buffer  by the number indicated by the associated session count. As noted above, the buffer logic  also pushes, to the queue , the same number of entries  that point to the foregoing buffer . Thus, the consumer count  indicates the number of times that the rendering sessions  will read the buffer  in response to the foregoing entries .","Like the rendering sessions  of , the session logic  of each rendering session , after reading a buffer , is configured to decrement the consumer count  of the read buffer . If the consumer count  is decremented to zero by the session logic  of a rendering session , then the data portion  may be overwritten. In this regard, each entry  identifying the buffer  has been pulled from the queue , and there are, therefore, no more rendering sessions  that are to read and utilize the data stored in the data portion . Thus, the session logic  that decremented the consumer count  to zero (0) preferably pushes, into the queue , an empty buffer entry  having a pointer  that points to the foregoing buffer . Such an action has the effect of freeing the buffer  such that any of the receivers  may write into the buffer , according to the aforedescribed techniques, once such a receiver  has located and popped the foregoing entry . Note that techniques other than those described above may be employed to buffer data at the receiving units . For example, U.S. Patent Application entitled \u201cSystem and Method for Buffering Data Received from a Network,\u201d and filed on Feb. 8, 2003, which is incorporated herein by reference, describes additional techniques for buffering data at a receiving unit .","It should be noted that the graphics applications , the buffer logic , the transport manager , the communication sessions , the rendering sessions , the receivers , and the rendering sessions  may be implemented in hardware, software, or any combination thereof. In an exemplary embodiment, which will be described in more detail hereinbelow, the graphics applications , buffer logic , transport manager , the communication sessions , the rendering session , and the rendering sessions  are implemented in software, and the receivers  are implemented via a combination of the hardware and software.","When any portion of the aforementioned components is implemented in software, such portion can be stored and transported on any computer-readable medium for use by or in connection with an instruction execution system, apparatus, or device, such as a computer-based system, processor-containing system, or other system that can fetch and execute instructions. In the context of this document, a \u201ccomputer-readable medium\u201d can be any means that can contain, store, communicate, propagate, or transport a program for use by or in connection with the instruction execution system, apparatus, or device. The computer readable-medium can be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium. Note that the computer-readable medium could even be paper or another suitable medium upon which the program is printed, as the program can be electronically captured, via for instance optical scanning of the paper or other medium, then compiled, interpreted or otherwise processed in a suitable manner if necessary, and then stored in a computer memory.","Various types of network protocols may be employed to process and render the graphical data produced by the graphics applications . In the exemplary embodiment of the system  described herein, X Protocol is preferably utilized to render two-dimensional (2D) graphical data, and an extension of X Protocol, referred to as \u201cOpenGL (OGL) Protocol,\u201d is preferably utilized to render three-dimensional (3D) graphical data, although other types of known or future-developed protocols may be utilized in other embodiments.","By way of background, OGL Protocol is a standard application programming interface (API) to hardware that accelerates 3D graphics operations. Although OGL Protocol is designed to be window-system independent, it is often used with window systems, such as the X Window System, for example. In order that OGL Protocol may be used in an X Window System environment, an extension of the X Window System has been developed called \u201cGLX.\u201d For more complete information on the GLX extension to the X Window System and on how OGL Protocol can be integrated with the X Window System, see for example Mark J. Kilgard, OpenGL Programming for the X Window System (Addison-Wesley Developers Press 1996), which is incorporated herein by reference. Also see commonly-assigned U.S. Pat. No. 6,249,294, entitled \u201c3D Graphics in a Single Logical Screen Display Using Multiple Remote Computer Systems,\u201d which is incorporated herein by reference as well.","As shown by , each graphics application  preferably runs on an operating system (OS) thread  along with its corresponding buffer logic , which preferably comprises an OGL layer  and a GLX layer . The graphics application  may be any known or future-developed application for producing or generating graphical data. The OGL and GLX layers  and , via known or future-developed techniques, preferably convert the graphical data from the graphics application  into a form that is compatible with OGL standards. Further, the OGL layer  preferably serves as an interface between the graphics application  and the transport manager . In this regard, the OGL layer  is preferably aware of which receiving units  are to receive the graphical data produced by the graphics application , and the OGL layer  submits a session request to the transport manager  when the graphics application  is ready to begin producing graphical data for transmission to the receiving units .","When the graphics application  actually begins producing graphical data for transmission to the receiving units , the OGL and GLX layers  and  convert the graphical data into a form compatible with OGL standards and store the converted graphical data in the shared resource  according to the techniques previously described above. Once a set of graphical data is stored in the shared resource , a set of communication sessions  selected by the transport manager  is responsible for interfacing such data with the network , and the graphics application , which is preferably running on a separate thread of execution, may begin processing other sets of graphical data. Thus, the graphics application  is not burdened with the task of interfacing the graphical data with the network , thereby helping the graphics application  to produce graphical data quicker than otherwise would be possible if the graphics application  is burdened with such a task.","As shown by , each communication session  preferably comprises session logic  and a network protocol layer  running on an OS thread  that is separate from the OS thread  of FIG. . The session logic  is configured to retrieve graphical data from the shared resource  in accordance with the techniques described hereinabove. In this regard, the session logic  searches the queue  for an entry  having a session identifier  that identifies the session  and retrieves the graphical data stored at the buffer  pointed to by this entry . Once the graphical data is retrieved, the network protocol layer  converts the data into a form that is suitable for communication over network  according to the appropriate protocol.","For example, in an exemplary embodiment, the system  preferably enables graphical data from any of the graphics applications  to be selectively communicated over the network via either TCP or UDPM. If TCP is selected, the network protocol layer  packetizes the graphical data according to TCP standards, and the network socket  then provides the packetized data to a network interface  (FIG. ), which interfaces the packetized data with the network . The network  then transmits each packet to its appropriate receiving unit  using known or future-developed networking techniques. Note that, in such an example, the network protocol layer , in accordance with conventional TCP standards and techniques, preferably handles various handshaking and other tasks to ensure that each transmitted packet successfully arrives at its destination.","If UDPM protocol is selected instead, then the network protocol layer , in accordance with UDPM standards, packetizes the graphical data retrieved by the session logic . The network socket  then provides the packetized data to a network interface  (FIG. ), which interfaces the packetized data with the network , and the network  then transmits each packet to is appropriate receiving unit .","According to UDPM protocol, each packet is not guaranteed to successfully arrive at its destination. Thus, it may be desirable for the session logic  of the transmitting session  to perform various handshaking with each destination receiving unit  to verify whether the receiving unit  has successfully received the transmitted data. In such an embodiment, the session logic  may be configured to save a copy of each transmitted packet until the logic  verifies that the packet has been successfully received by each receiving unit  that is to receive the packet. If the session logic  discovers that a receiving unit  failed to receive a particular data packet, then the session logic  may initiate a transmission of a copy of the lost data packet. Note that various network protocols in addition to or in lieu of TCP and UDPM may be employed to communicate, over the network , the graphical data retrieved by the session logic .","As shown by , each rendering session  preferably comprises session logic  and an OGL daemon  running on an OS thread . The session logic  is configured to retrieve graphical data from the shared resource  in accordance with the techniques previously described hereinabove. In this regard, the session logic  searches the queue  for an entry  having a session identifier  that identifies the rendering session  and retrieves the graphical data stored at the buffer  pointed to by this entry . Once the graphical data is retrieved, the OGL daemon  is configured to accelerate or drive the graphical data through a graphics accelerator  (FIG. ), sometimes referred to as a \u201cgraphics adapter,\u201d such that the graphical data is rendered to the display device  (FIG. ).","The graphics applications , buffer logic , transport manager , shared resource , and sessions  and  are preferably implemented via a computer system  shown by FIG. . In addition to the foregoing components, the computer system  preferably comprises at least one conventional processing element , such as a digital signal processor (DSP) or a central processing unit (CPU), that communicates to and drives the other components of the system  via a local interface , which can include one or more buses. Furthermore, an input device , for example, a keyboard or a mouse, can be used to input data from a user of the system , and the display device , or some other output device, can be used to output data to the user. The general operation of the computer system  will be described in more detail hereinbelow. Note that the graphics applications , transport manager , and sessions  and  may be implemented in software and stored in memory , as depicted by FIG. .","As shown by , each receiver  () preferably comprises buffer logic  and a network protocol layer  running on an OS thread . Each receiver  also comprises a network interface  and a network socket . When a data packet from the network  is received by the network interface , the network socket  provides the data packet to the network protocol layer . The network protocol layer  then recovers the graphical data and application identifier of the data packet, and the buffer logic  stores the recovered data in the shared resource  (FIG. ), according to the techniques previously described hereinabove. Thus, the buffer logic  pops an empty buffer entry  from the queue  and stores the recovered graphical data in a buffer  identified by the pointer  () of the popped entry . The buffer logic  then pushes, into the queue , at least one entry  pointing to the foregoing buffer  and having an application identifier  that identifies the graphics application  () that originally produced the graphical data.","As shown by , each rendering session  () preferably comprises an OGL daemon  running on an OS thread  that is preferably separate from the OS thread  of FIG. . The session logic  of the rendering session  depicted by  preferably runs on the OS thread  and, according to the techniques described above, searches the queue  for entries  having a particular application identifier  (i.e., an application identifier identifying the graphics application  that produces graphical data to be rendered by the session ). When such an entry  is found, the session logic  pops the entry  from the queue  and then retrieves the graphical data stored in the buffer  pointed to by the popped entry . The OGL daemon , via known or future-developed techniques, then drives the retrieved data through a graphics accelerator  () thereby rendering the graphical data.","Note that when the foregoing graphical data has been retrieved by the session logic , the session logic  preferably decrements the consumer count  of the read buffer . If the session logic  decrements the consumer count  to zero, the logic  pushes, into the queue , an empty buffer entry  that points to the buffer  from where the graphical data was previously retrieved. Thus, this buffer  is effectively freed for use by any of the receivers  to write newly received graphical data.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":["FIG. 14","FIG. 14","FIG. 14"],"b":["400","24","5","400","111","12","123","13","111","123","404"]},"The computer system  of  preferably comprises at least one conventional processing element , such as a digital signal processor (DSP) or a central processing unit (CPU), that communicates to and drives the other components of the system  via a local interface , which can include one or more buses. Furthermore, an input device , for example, a keyboard or a mouse, can be used to input data from a user of the system , and the display device , or some other output device, can be used to output data to the user. The general operation of the computer system  will be described in more detail hereinbelow.","Note that when the transport manager  of , in response to a session request, as described above, initiates communication with the transport manager  of , the transport managers  and  establish a pair of control sockets  () and  () by which to communicate with each other. Based on information exchanged over these control sockets  and , the transport manager  may establish at least one socket , according to known or future-developed techniques, and then allocate this socket  to at least one of the communication sessions  (FIG. ). Further, based on the exchanged information, the transport manager  may, similarly, establish at least one socket , according to known or future-developed techniques, and then allocate this socket  to at least one of the receivers  (FIG. ).","In alternative embodiments, each graphics application  () and receiver  may be configured to establish the sockets  and , respectively. However, in such embodiments, each such graphics application  would establish and maintain a control socket, and each such receiver  would also establish and maintain a control socket as well. Thus, several control sockets may be established and maintained at each of the transmitting and receiving units  and . However, in the exemplary embodiment described above where the transport managers  and  establish sockets, it is possible for the transport manager  to establish a relatively large number of sockets  for a relatively large number of communication sessions  using a small number (e.g., one) control socket  (FIG. ). Further, in such exemplary embodiment, it is possible for the transport manager  to establish a relatively large number of sockets  for a relatively large number of receivers  using a small number (e.g., one) control socket . Thus, having the transport managers  and  establish and hand-off sockets  or  helps to reduce the number of sockets created and managed by the system .","In addition, according to the techniques described above, it is possible for the same communication session  to service multiple graphics applications . As a result, data produced by multiple graphics applications  can be communicated through the same socket  enabling the system  to employ a lower number of sockets  than would otherwise be possible if each graphics application  established and maintained a separate socket  for communicating its data to the network .","Furthermore, having the transport manager  establish and hand-off sockets  to communication sessions  helps to simplify the configuration of the graphics applications  since the graphics applications  do not need to include complex logic for establishing and managing such sockets . In addition, delegating the establishment and management of sockets  to the transport manager , as described above, reduces the processing burden put on the graphics applications  allowing these applications  to produce graphical data with fewer delays. Further, the configurations of the transport manager  and communication sessions  described above help make the transmitting unit  scalable for accommodating various numbers of graphics applications  and various types of communication environments.","A preferred use and operation of the communication system  and associated methodology are described hereafter.","For the purposes of illustration, assume that it is desirable for one of the graphics applications , when running on the computer system  of , to produce data that is to be rendered by rendering sessions  () at multiple receiving units  (FIG. ). The foregoing graphics application  will be referred to hereafter as the \u201ctransmitting application ,\u201d and the foregoing receiving units  will be referred to hereafter as the \u201cdestination receiving units .\u201d","When the transmitting application  is invoked, it submits a request for establishing a network connection or socket. The OGL layer  () is preferably aware of the destination receiving units  as well as which type of protocol is to be used to communicate the graphical data of the transmitting application  to the destination receiving units . For illustrative purposes, assume that UDPM is to be utilized to communicate such graphical data to the destination receiving units .","In response to the foregoing request, the OGL layer  associated with the transmitting application  submits a session request to the transport manager , as shown by block  of FIG. . This session request preferably comprises the IP address of each destination receiving unit  as well as data indicating that UDPM is to be employed to communicate with the receiving units . As shown by decision block  and block  of , the transport manager  selects a set of communication sessions  to service the transmitting application  (i.e., the application  that initiated the session request).","In this regard, as shown by decision block  of , the transport manager  determines whether there exists any active communication sessions  that are currently communicating with the same destination receiving units  via the same protocol (i.e., UDPM in the instant example) identified by the session request. If the transport manager  identifies such matching communication sessions , the transport manager  may select such identified sessions  for servicing the transmitting application , as shown by block . However, if there are an insufficient number of matching communication sessions  to adequately service the transmitting application , then the manager  preferably selects at least one inactive session  for servicing the transmitting application , as shown by decision block  and block , and the transport manager  then activates each selected inactive session . In activating such sessions , the manager  provides each such activated session  with the IP addresses of the destination receiving units  and assigns the activated session  the session identifier  of the communication sessions  selected in block .","If there are no active sessions  presently communicating with the same destination receiving units  via the same protocol identified by the session request, then the transport manager  selects and activates a suitable number of inactive communication sessions  for servicing the transmitting application , as shown by blocks  and . In activating such sessions , the manager  provides each such activated session  with the IP addresses of the destination receiving units  and assigns the activated session  a unique session identifier  that has not been assigned to the other active sessions , as shown by block .","If there were any sessions activated via either blocks  or , the transport manager  establishes communication with the transport managers  of the destination receiving units , as shown by decision block  and block  of FIG. . In particular, the transport manager  establishes at least one control socket  for communicating with such units . The transport manager  also establishes, for each of the sessions  activated in block  or , a socket  configured to communicate with each of the destination receiving units  via UDPM. Then, the transport manager  hands-off or, in other words, allocates each such socket  to one of the activated sessions , as shown by block .","As shown by block , after selecting a set of sessions  for servicing the transmitting application , the transport manager  provides the aforementioned OGL layer  with the session identifier that identifies the selected set of sessions , which will be referred to hereafter as the \u201cservicing sessions .\u201d Note that this session identifier is received by the OGL layer  in block  of FIG. . In decision block  of , the transport manager  determines whether it has received any unserviced termination notifications from any of the sets of buffer logic  of FIG. .","Such termination notifications indicate that one of the graphics applications  will no longer be producing graphical data for transmission over the network . Further, such a termination notification preferably comprises the session identifier  of the set of sessions  that is servicing the terminating graphics application . Thus, in response to a termination notification, the transport manager  preferably determines whether the communication sessions  identified by the session identifier of the notice are servicing another application . If not, the transport manager  may deactivate or reallocate to another graphics application , any of the identified sessions , as shown by block . However, if the identified sessions  are servicing another application , then the transport manager  preferably skips blocks .","Note that in block , the transport manager  may also determine whether a communication element, such as a graphics application  or receiving unit , has stopped running or communicating with a communication session  even though a termination notice is not received from the communication element. In this regard, in some circumstances usually due to an error or an unexpected event, a communication element, such as a graphics application  or a receiving unit , may cease operation and, therefore, cease communicating with a communication session  without having the opportunity to gracefully terminate its operation. Thus, the communication element may terminate before having a chance to submit a termination notification to the transport manager . The transport manager  may be configured to monitor the communication of the sessions  to determine when communication between a communication session  and a communication element, such as a graphics application  or a receiving unit , has ceased. In such a situation, it may be desirable to terminate or reallocate the communication session , if the communication session  is not presently communicating graphical data successfully from at least one graphics application  to at least one receiving unit .","For example, the transport manager  may monitor the graphics applications  and determine that one of the graphics applications  is no longer producing graphical data. If the communication session  servicing the foregoing graphics application  is not servicing another application , then the transport manager  may deactivate the communication session  in order to conserve the processing resources of the transmitting unit . Alternatively, the transport manager  may reallocate the communication session  such that the session  services another graphics application .","In another example, the transport manager  may determine that the data being transmitted by a communication session  is not being successfully received by any of the receiving units . Such a condition may arise due to a network error or due to one or more receiving units  ceasing communication with the session  without providing notice to the transmitting unit  and, more particularly, to the transport manager . In such an example, the transport manager  may deactivate or reallocate the communication session . The transport manager  may further notify the graphics application  being serviced by the foregoing session  such that the graphics application  may quit its operation or attempt to re-establish communication with the receiving units .","Various other techniques for managing the communication sessions  by monitoring communication between the communication sessions  and other components of the system  are possible in other embodiments. Indeed, co-pending and commonly-assigned U.S. Patent Application entitled \u201cApparatus and Method for communicating with a Network and for Monitoring Operational Performance of the Apparatus,\u201d and filed on Feb. 8, 2003, which is incorporated herein by reference describes various techniques for monitoring the operation of the system  and controlling the resources of the system  based on such monitoring.","Once the OGL layer  receives the aforementioned session identifier from the transport manager , graphical data produced by the transmitting application  may be stored in the shared resource . When the transmitting application  produces a set of graphical data (e.g., a graphics command), the OGL layer  and\/or GLX layer  convert the graphical data into a form consistent with OGL standards, and the GLX layer  then pops an empty buffer entry  from the queue , as shown by decision block  and block  of FIG. .","In this regard, the GLX layer  searches the queue  until it finds an entry  that has the empty buffer value stored as its session identifier  (FIG. ). When the GLX layer  finds such an entry , the GLX layer  pulls the entry  from the queue  and then stores the set of graphical data in the buffer  identified by the popped entry's pointer  (FIG. ), as shown by block  of FIG. . In writing the graphical data to the buffer , the GLX layer  stores, in the header  of the buffer , an application identifier  () identifying the application  that generated the data (i.e., the transmitting application ). Also, as shown by block , the GLX layer  increments the consumer count  of this header  for each session  and  that is to read such data. Thus, if the data is not to be rendered locally, then the GLX layer  increments the consumer count  to a value of one (1). However, if the data is to be rendered locally, then the GLX layer  further increments the consumer count  once for each rendering session  that is to read the data.","Note that at any given instant, no more than one empty buffer entry  points to the same buffer . Thus, by popping an empty buffer entry  in block , the GLX layer  effectively prevents or disables other components from writing to the buffer  identified by the popped entry . Therefore, the GLX layer  may write a set of graphical data into this buffer  in block  without risking corruption of the data by another set of buffer logic . In this regard, as described hereafter, another empty buffer entry  identifying the foregoing buffer  is not pushed into the queue  until at least the set of graphical data produced by the transmitting application  is read out of the foregoing buffer  for the purposes of transmitting the set of graphical data to the receiving units . Thus, until such an entry  is pushed into the queue , none of empty buffer entries  residing in the queue  identify the buffer  that is storing the set of graphical data. As a result, other components are effectively prevented from overwriting the set of graphical data until it has been retrieved from the buffer .","As shown by block  of , once the aforementioned set of graphical data is written to the identified buffer , the GLX layer  pushes, to the queue , an entry  having (1) a pointer  () that points to the foregoing buffer  and (2) a session identifier  that identifies the servicing sessions  (i.e., the set of sessions  previously selected by the transport manager  in block  of  to service the transmitting application ). Further, assume that, in the present example, the aforementioned set of graphical data produced by the transmitting application  is to be rendered locally via the computer system . In such an embodiment, the GLX layer  pushes, to the queue , an additional entry  for each rendering session  that is to read the foregoing buffer , as shown by decision block  and block  of FIG. . Each such additional entry  also has a pointer  pointing to the aforementioned buffer  where the set of graphical data is stored. The session identifier  () of each additional entry  preferably identifies a different rendering session  (FIG. ).","At this point, the transmitting application  and its corresponding buffer logic  have completed their processing of the set of graphical data and may initiate a new task (e.g., produce another set of graphical data). However, if the present operation of the transmitting application  is quit such that no new task is to be performed until the application  is later invoked again, the OGL layer  transmits a termination notification to the transport manager , as shown by decision block  and block . In response, the transport manager  determines whether the servicing sessions  are presently servicing another graphics application . If not, the transport manager  deactivates the servicing sessions  in response to the termination notice. As a result, the servicing sessions  do not further usurp significant processing resources of the computer system . However, if the servicing sessions  are presently servicing another graphics application , then the transport manager  enables the servicing sessions  to remain active.","Once activated by the transport manager , the session logic  of each servicing session  initializes a protocol and a set of destination addresses based on information provided by the transport manager , as shown by block  of FIG. . Continuing with the instant example, the session logic  is configured to communicate via UDPM to the destination receiving units  via a UDPM socket  established by the transport manager . As shown by blocks - of , the session logic  begins to search the queue  for entries  having a session identifier  identifying the servicing sessions . At some point, the session logic  analyzes the first entry  pushed to the queue  by the GLX layer  in block  of FIG. . Since this entry  has a session identifier that identifies the servicing sessions , the session logic  of one of the servicing sessions  pops this entry  from the queue  in block  of FIG. . The session logic  then retrieves the aforementioned set of graphical data from the buffer  identified by the popped entry , as shown by block  of FIG. .","The network layer  () then packetizes the retrieved data for transmission across the network  () according to UDPM standards. In particular, the network layer  packetizes the set of graphical data and writes, in block  of , the packetized data to the UDPM socket  provided by the transport manager  such that the set of graphical data is transmitted over the network  to each destination receiving unit . Note that the network layer  preferably inserts, in each packet, the application identifier  () stored in the header  of the buffer  in which the aforementioned set of graphical is stored. In other words, the network layer  inserts, in each packet, an application identifier  that identifies the transmitting application .","In addition, once the set of graphical data has been retrieved from the aforementioned buffer  in block , as described above, the session logic  decrements the consumer count  () stored in the header  of the buffer  from where the set of graphical data is retrieved, as shown by block  of FIG. . If the value of the consumer count  is zero after being decremented, then there are no more entries  in the queue  that identify the foregoing buffer , and the data stored in the buffer  may be overwritten.","In such an example, the session logic  frees the buffer  by pushing, into the queue , an empty buffer entry  that points to the foregoing buffer , as shown by decision block  and block . However, in the instant example, there is another entry  (i.e., an entry  pushed to the queue  via block  of ) in the queue  that identifies the buffer . Thus, assuming that this entry  has yet to be popped from the queue  by the rendering session  (FIG. ), as will be described in more detail hereinbelow, it is desirable to continue preventing any of the components of system  () from writing to the buffer . To achieve this effect, the session logic  skips block , in the present example, and proceeds to decision block  of FIG. . Moreover, after performing block  and, if appropriate, block , the session logic  repeats the process depicted by  unless the logic's session  is deactivated or reallocated by the transport manager via block  of FIG. . If reallocated, the session logic  re-initializes to a new protocol and\/or set of destination addresses, as shown by decision block  and block . Note that the transport manager  may provide a new socket  according to a different protocol (e.g., TCP) if the session  is reallocated to another graphics application .","In addition, the session logic  () of the rendering session  () performs a process similar to the one depicted by FIG. . In this regard, the session logic  of the rendering session  searches the queue  for entries  having session identifiers  that identify the rendering session . At some point, the session logic  finds an entry  pushed, via block  of , into the queue  by the GLX layer  associated with the transmitting application . When this occurs, the session logic  pops this entry  from the queue . The session logic  then reads the set of graphical data from the buffer  identified by this entry  or, in other words, the buffer  previously read by the session logic  of one of the servicing session  described above. The OGL daemon  () of the rendering session  drives this graphical data through a graphics accelerator  (FIG. ), thereby rendering the data to the display device .","After reading the set of graphical data from the buffer , the session logic  of the rendering session  decrements the consumer count  () stored in the header  of the buffer . Assuming that the session logic  of the servicing session  previously decremented the consumer count  via block  of  such that the consumer count  is now decremented to a value of zero (0), the session logic  preferably pushes, into the queue , an empty buffer entry  pointing to the buffer . As a result, the buffer  may be written to with data from any of the graphics applications .","At some point, the aforementioned set of graphical data transmitted by one of the servicing sessions  arrives at the network interface  () of a receiver  () in each of the destination receiving units . When the graphical data arrives at such a receiver , the buffer logic  () of the receiver  pops an empty buffer entry  from the queue , as shown by decision block  and block  of FIG. . The buffer logic  then writes the set of graphical data to the buffer  identified by the pointer  of the popped entry , as shown by block  of FIG. . As shown by block , the buffer logic  also increments the consumer count  of the foregoing buffer  once for each session  that is to consume the buffer's data. Note that in the embodiment described herein, the number of sessions  to consume the buffer's data is indicated by a session count provided by the transport manager . Also note that popping the empty buffer entry  from the queue  in block  effectively prevents this data from being overwritten until an empty buffer entry  identifying the foregoing buffer  is later pushed to the queue .","As shown by block  of , after writing the set of graphical data to the foregoing buffer , the buffer logic  pushes, into the queue , an entry  having (1) an application identifier  () that matches the application identifier received with the set of graphical data and (2) a pointer  that points to the foregoing buffer . In other words, the buffer logic  pushes, into the queue , an entry  having an application identifier  that identifies the transmitting application  and a pointer  that points to the buffer  where the set of graphical data produced by such application  is written. Note that the buffer logic  pushes such an entry  for each session  that is to consume the buffer's data. As set forth above, the number of sessions  to consume the buffer's data is indicated by the session count provided from the transport manager .","The session logic  () associated with at least one rendering session  in the same receiving unit  as the foregoing receiver  is preferably initialized to the application identifier of the transmitting application  via block  of FIG. . The session logic  of each such rendering session  searches the queue  for entries  having application identifiers  that identify the transmitting application , as shown by blocks - of FIG. .","At some point, the session logic  finds one of the aforementioned entries  pushed to the queue  in block  of FIG. . When this occurs, the session logic  pops this entry  from the queue  and reads the buffer  pointed to by this entry , as shown by blocks  and . In other words, the session logic  reads, from the shared memory , the set of graphical data transmitted from the transmitting application . The OGL daemon  () then drives the retrieved graphical data through a graphics adapter  (FIG. ), thereby rendering the graphical data, as shown by block . Note that such data may be rendered to the display device  of the computer system  depicted by FIG. .","After retrieving the set of graphical data, via block , from a buffer  of the shared memory , the session logic  preferably decrements the consumer count  of this buffer , as shown by block . If the consumer count  is decremented to zero (0) via implementation of block , the session logic  pushes, into the queue , an empty buffer entry  that points to the foregoing buffer , as shown by decision block  and block  of FIG. . Pushing such an entry  has the effect of freeing the buffer  or, in other words, allowing the receivers  to write to the buffer .","As shown by decision block , the process shown by  continues until the rendering session  is deactivated by the transport manager . If the transport manager  reallocates the rendering session  to servicing a new application , then the session logic  re-initializes its application identifier such that it searches for the application identifier of the new application  in the queue , as shown by decision block  and block . Note that it is possible for the session logic  to be simultaneously associated with a plurality of application identifiers such that logic  concurrently performs the process shown by  for multiple application identifiers.","Moreover, by performing the aforedescribed techniques, graphical data is efficiently and reliably transmitted from the transmitting application  to each of the receiving units . Further, even though the graphical data may be communicated to a relatively large number of receiving units , the transmitting application  is not significantly burdened with the task of interfacing the graphical data with the network ."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention can be better understood with reference to the following drawings. The elements of the drawings are not necessarily to scale relative to each other, emphasis instead being placed upon clearly illustrating the principles of the invention. Furthermore, like reference numerals designate corresponding parts throughout the several views.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2","b":"1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3","b":"2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4","b":"2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5","b":"1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6","b":"5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7","b":"5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8","b":"2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9","b":"2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10","b":"2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11","b":"2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12","b":"5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 13","b":"5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 14","b":"5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 15","b":"2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 16","b":"2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 17","FIG. 2"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 18","b":"2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 19","b":"5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 20","b":"5"}]},"DETDESC":[{},{}]}
