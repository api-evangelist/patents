---
title: Method and system for a system call profiler
abstract: A method of acquiring software profile information of a target software application includes Monitoring an application program for system calls, detecting a system call of interest to the user, acquiring stack information, and processing the call stack information to produce statistical information concerning function calls. The call stack information includes program counter and other information which is derived from the target application as well as operating system. The call stack information may be recorded. The statistical information includes statistics concerning the number of samples that any one function call is at a top of the call stack information, the number of samples that a series of functions calls are included in the call stack information, and the number of samples that a set of function calls are at the top of the call stack information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07716647&OS=07716647&RS=07716647
owner: Microsoft Corporation
number: 07716647
owner_city: Redmond
owner_country: US
publication_date: 20041001
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Overview","Exemplary Embodiments of the Invention"],"p":["This application is related to the following co-pending, commonly assigned, patent application:","U.S. patent application Ser. No. 10\/957,264, entitled \u201cMethod and System for a Call Stack Capture\u201d filed Oct. 4, 2004, which is incorporated herein by reference in its entirety.","This invention relates in general to the field of software development. More particularly, this invention relates to profiling software performance in an embedded system development environment.","In general, software profiling is a technique for measuring or estimating what parts of a complex hardware and software system are consuming the most computing resources. The most common profiling tools aim to determine which segments of code within an application or service are consuming the most processor time and to find performance \u201cbottlenecks\u201d where optimization can be most beneficial to the running time. Profiling can also be applied to the consumption of other resources, such as processor caches, operating system APIs, memory, and I\/O devices.","The two most common approaches used in processor-time profiling are sampling and \u201cper-occurrence\u201d measurement. Sampling involves choosing a subset of interesting events, determining the cause of those events, and reporting the frequency of those causes. For example processor-time sampling involves measuring, at regular time intervals, which code was running; such as noting, at regularly-spaced times, the value in the processor's instruction pointer register.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 1(","FIG. 1","FIG. 1("],"i":["a","a","a"]},"\u201cPer-occurrence\u201d measurement is done every time a particular event occurs. The main forms of this measurement are counting the number of times an event occurs, or querying the time at the beginning and end of a work interval and subtracting to find the amount of time taken to perform that work. The \u201cinstrumentation\u201d to count the event or to measure the interval may be added to the code manually, or may be built-in to the code by a compilation tool. ) is an example of \u201cper-occurrence\u201d measurement in a software time profile where instrumentation is used to determine system events. Each test point (TP) in ) represents the beginning or end of an event, such as the beginning or end of a function within the software run profile.","The two techniques of sampling and per-occurrence profiling both have advantages and disadvantages. The per-occurrence measurement cannot be performed for code which does not contain any instrumentation. Also, duration timing measures nearly-exact running time, but the measurement itself can skew results by affecting the duration. For example, the work required to read the time on entry and exit to a function is much larger in proportion to the run-time of small functions than it is in proportion to the run-time of large functions. Per-occurrence measurement can also produce a very large amount of data if the occurrences happen very often. For example, logging the entry and exit of every function in an application shown in ) will add up quickly.","On the other hand, sampling, as in ) typically produces much less data. Rather than capturing every moment in time, time-based sampling is scaled back to sample at a relatively low frequency. In fact, the sampling frequency can be adjusted to suit the situation; sampling too often produces too much data, while sampling too infrequently leads to inaccuracy of measurement. For example, an ill-spaced sampling interval as in ) would miss two of the three occurrences of function FB. That inaccuracy is the disadvantage of sampling; since samples only provide you with captures for a very small portion of the overall whole, the result is only an estimate rather than an exact measurement. Chance sampling within functions that occur very rarely can make those functions appear to take a higher proportion of time than they actually do appear. Sampling is also susceptible to errors related to events that occur at the sampling interval. For example, if a profiler is sampling the processor instruction pointer once every 100 milliseconds, and some other event is occurring once every 100 milliseconds, then the profiler could possibly miss every instance of that event, or it could possibly hit every instance of that event, making it appear as though the event-handling code was running 0% or 100% of the time, respectively, when in truth the event-handling code would be running at some intermediate level between the extremes.","An ideal system would gather all of the data available and then process the data without affecting the run of the application. However, data memory and processing time are normally limited; so a compromise between the amount of data gathered and the level of insight sought is sometimes made. One approach is to capture and process only the data of interest. However, an instrumented approach would affect runtime performance. Thus, there is a need for a technique which can perform per-occurrence type of data collection for profiling in a time efficient manner without greatly affecting the runtime performance of the system under test. The present invention addresses the aforementioned needs and solves them with additional advantages as expressed herein.","An embodiment of the invention includes a method for profiling the software function calls of a system under development. A development system can include target software that a developer desires to optimize. The subject invention allows a user to track transition function calls made by the target application to and from an operating system. A call stack is captured when a system call is specified and the call event occurs while an application under test is being executed. The data that is captured is logged and may be either the application function calls or the operating system function calls or both.","In one embodiment, a method of acquiring profile information includes executing an application wherein function calls from the application are received by a call router. The function calls are monitored for a selected transition between an application call and an operating system call. The user is able to select which transition system calls are to be captured. Once the system call event occurs, the call stack is acquired relating to the selected system call and the application which spawned it. The information may be stored and the user has the choice of storing the application call data, the system call data or both. The information is then processed to produce statistical data concerning the operation of the application with respect to captured information. The monitoring and call capture occur with out the need for re-compiling the user application to insert test points, and without the need to manually insert test points in the application.","In an embodiment of the invention, a profiler can collect instruction counter or program counter information from a call stack during a currently running software thread. The call stack data is collected when software module detects a transition to or from a specific system call or application call. The captured call stack includes program counter information for the running application as well as within the OS system processes. An embodiment of the invention allows data to be captured in multiple modes allowing the user to select the amount of data to be collected as well as the level of program counter detail relative to the application and system processes. Post processing of the collected call stack information yields useful results for the software development user.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 2"],"b":["200","205","200","200","205","210","205"]},"The device side control application  serves to receive communications from the user interface  and communicate with the profiler application programming interface (API) . The profiler API  is part of the operating system kernel  of the embedded development system and also functions to transfer information from the system call router . The user interface  may provide options for choosing call stack scope, so that development system users can make the tradeoff between level of detail and level of intrusion. The user interface  may also provide options to choose the profiling mode. The kernel profiler API  will also expose these options. In operation, the user interface  passes the user preferences to the device-side control application  which initiates the profiler API . When the profiler API  is turned on, it will pass the user's settings to the kernel's system call router . Thus, the level of activity in capturing call stack information is dependent upon the user settings. Also note that a re-compiling of the user application with test points is not required in the current invention as may be required with other prior art profilers.","When a user application running in the development environment calls a system API to perform some operating system function, the call appears to be routed directly to the system process which implements the API. This action is represented in  as a dashed line between the user application  and the system API . In some operating systems, such as the Windows\u00ae CE operating system available from Microsoft\u00ae, the system call generated by the user application is first routed to the operating system kernel where it is then passed to the system API of interest. This allows the kernel to perform operations such as re-mapping memory addresses and making security checks.","This functional routing from a user application to the operating system is used advantageously in the present invention. This routing also makes it possible for a software development profiler to record entry and exit events for system calls. The system call profiler of the current invention uses instrumentation that is built into the kernel code which handles system calls. When an application calls a system function, the application can invoke a special exception that is handled by the kernel. This exception is a normal part of the routing that Windows\u00ae CE operating system does to service system calls. According to an aspect of the invention, during the exception, if system call profiling is enabled, the system call router  will call the profiler API  which will capture a sample. Using this method the profiler captures a sample for every system call that is made.","As an aspect of the present invention, a user application  generates a system call, which is handled by a system call router . The system call router  determines if system call profiling is enabled. If so, the system call router calls the profile API . The profile API  determines if the system call made by the user application is one of interest according to the user settings. In this way the profile API  monitors the system calls made by the user application . If the user application system call is a call that the profiler is to monitor, then the call stack capture API  is requested to capture the call stack of the processor under test. The information of the call stack represents not only the user application call information, but also the system call information.","Once the call stack capture API  captures the stack information for both the application and system call program counters, the profile API  may log the information via the event logger . The logged information is stored into a buffer . The information logged includes call stack information for both entry and exit of the call of interest as well as such items as entry\/exit time for the call, an identifier for the running thread, a timestamp and other system statistics. The system call router  proceeds to call the specific system API  for the system process requested of the user application once the relevant event information is captured. If the user application  generated a system call that is not of interest according to the user preferences in the system call router , no call stack capture would be initiated and the system call router  would forward the system call to the system API  for the called system process.","In one embodiment, the event logger is a straightforward text file recording mechanism that saves the call stack information. In another embodiment, the event logger is an embedded system data logger used to record both call stack information as well as other data. The event logger uses passes any collected information to a buffer .","The device-side control application  is responsible for eventually removing the call stack data from the buffer  and either communicating it back to the user interface  on the desktop PC, saving it in a file, or performing some other operation on the data. Eventually, on prompt from the user, the device-side control application  will call the kernel profiler API  to stop profiling.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 3","FIG. 2"],"b":["300","300","1","325","1","310","305"]},"For example, a capture of the call stack at time point  yields a call stack that is indicative of the main application function  and application software functions F  and F . The call stack request also retrieves the instruction pointer for system call function API  . If system call function API   goes on to call another system function S  which is not a system API or is not specified as one of interest by the user, the entry and exit to that function will not result in acquisition or capture of any call stack information. However system functions can call into other system functions, so system call stack information can be recorded in a \u201cnested\u201d fashion. For example, an application function which calls system call function API   can result in capture of the call stack at time point . If system call function API   calls another system function S , which calls system call function API  , this can result in capture of the call stack at time point . A capture of the call stack at time point  yields a call stack that is indicative of the main application function  and application software functions F  and F , along with the system call function API  , system function S , and system call function API  . Thus, using the call stack acquisition aspect of the invention, both system calls  as well as application calls  can be collected during a sample of the user application software process  thread. This ability can provide a body of rich information content for the embedded system operation. Additional information may be recorded that provides more information about the call entry, such as the current time, or other system statistics such as, but not limited to, the current number of instructions executed, the number of cache misses, or the number of translation lookaside buffer (TLB) misses. As is well known in the art, a translation lookaside buffer is a buffer (or cache) in a CPU that contains parts of the page table which references between virtual and real addresses. This buffer has a certain number of entries and is used for speed improvement by using faster cache storage instead the other slower memory storage.","Similarly, at time point , the system call router detects that an exit from a system call API   is occurring. Since the call stack was already recorded on entry, the profiler API does not record it again at system call exit. Instead only a minimum amount of information, such as the address of the system call API   and the identifier of the running thread, are required in order to correlate the exit event with the previously logged entry data from time point . Additional information may be recorded that provides more information about the call exit, such as the current time, the elapsed call time, or other system statistics such as, but not limited to, the current or elapsed number of instructions executed, the number of cache misses or the number of translation lookaside buffer (TLB) misses. Similarly, at time points  and  the system call router detects exits from system calls API  and API , and invokes the profiler API to acquire and store pertinent information about the exit events. Having both entry and exit points allows a user to determine the exact duration of the system call and the functions being performed.","In the current invention, the call stack information concerning the thread that was running is gathered when the system call router detected that a specific system call is made. The system call router then calls the call stall capture API as previously discussed to collect the stack information.","In one embodiment of the current invention of the present application, multiple operating modes are offered. In a first mode, only the address of the API being called is captured at each point of interest. This mode records only a minimum amount of information which makes it possible to know how many times each system API is called, and how many CPU resources were consumed during the calls. In a second mode, the entire call stack is acquired for each stack captured at every point of interest. This mode makes it possible to see what code paths led to spending time inside API calls, including paths through system code. A third mode captures only the call stack up to the point where the thread leaves its source application. This mode makes it possible to see what application code paths led to spending time inside API calls, without including details about the system code paths that the application went through to make those calls. This mode of operation accesses and records only call stack information that resides below level  in  and has the advantage of reducing the amount of gathered data by a significant amount. This mode also reduces the amount of intrusiveness of the profiler itself as well as the amount of performance impact related to storage or transportation of the gathered data. As an example, suppose a user is interested in finding out why or how often, an application writes to the disk. The profiler API could record calls to all of the file system APIs which write to the disk. Suppose an application calls some system call API  that does not write to disk, and so is not being recorded by the profiler. But API  calls function API  which does write to the disk, so the profiler will record the call to API . Depending on what mode the user has selected, the user may record call stacks including only the application code and thus discern which application code leads to disk writes. Alternatively, the user may record call stacks including application and system code and thus discern the path through the system code that led to a disk write.","In one embodiment of the invention, the above mentioned mode options may be provided to the user giving her the ability to gather extra system information unavailable in prior art profiling equipment. Providing the user with the ability to trade off between information and performance impact and data storage will make the profiler more usable for embedded device development. In many instances embedded devices are far more constrained than desktop PCs in terms of processor power or storage capacity. The desktop-side user interface  of  will provide options for choosing the call stack scope, so that users can make the tradeoff between level of detail and level of intrusion. The kernel profiler API  will also expose these mode options. When the profiler is turned on, it will pass the user's settings on to the system call router  so that it can call the kernel call stack capture API  with the user's preferential mode and parameter settings.","In a first mode, the collected stack information is filtered to extract the top most address of the system call function that is being called during a series of call stacks collected over time. The captured data is a stream of program counters from all the collected data, where the program counter is the address of an instruction. Each program counter may also be accompanied by additional information such as an identifier for the current running thread, system statistics such as the current time, or an identifier signifying whether the event was a call entry or exit. The stream of data may appear as follows:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<addr1> <ID1> <time1> <entry>"]},{"entry":[{},"<addr2> <ID2> <time2> <exit>"]},{"entry":[{},"<addr3> <ID3> <time3> <entry>"]},{"entry":[{},"... etc."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"During post processing of this data, the program counter address data is matched to the function that the address corresponds to in the relevant software code. Then, the post processing counts up all the hits for all the functions. For example, if function Foo( ) is in memory between <addr4> and <addr5>, and the captured sample <addr1> is between <addr4> and <addr5>, then we know that the captured sample was inside function Foo( ). Function Foo( ) would be entered into data corresponding to the span of two addresses within the code. All of the captured samples are added up and the number of samples in each function is provided. At the end of this portion of post processing, the functions are sorted by the number of hits in each function, and a report is generated of the functions that had the most samples. Since all system calls of interest are recorded as they occur, the number of call entry events per function exactly corresponds to the number of times the functions of interest were called, and the differences in system statistics between the call entry and exit events can be used to total up the exact amount of time spent inside those functions. In one embodiment, the processed data is may presented as functions with percentages as shown in Table 1:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"System","No. of","Percentage","Total","Percentage"]},{"entry":[{},"Call","calls","of calls","Time","of time"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Foo( )","300 calls","58%","400 us","39%"]},{"entry":[{},"Bar( )","200 calls","39%","\u200220 us","1%"]},{"entry":[{},"Moo( )","\u200210 calls","1%","600 us","58%"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}]}}},"In another embodiment, the collected sampled data is added up according to all of the functions inside a software module, and the report includes the modules with the most hits. For example, if Foo( ) and Bar( ) are inside mycode.dll, then we will attribute all the hits from Foo( ) and Bar( ) to mycode.dll as shown in Table 2:",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},"Percentage","Total","Percentage"]},{"entry":["Module","Calls","of calls","time","of time"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["mycode.dll","500 calls","98%","420 us","41%"]},{"entry":["other.dll","\u200210 calls","1%","600 us","58%"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"When a user is investigating a performance problem, and knows she spends 58% of her time inside function Foo( ), she has two options to reduce that time. One option is to make Foo( ) run in less time by reducing the work it does or improving its algorithm, and the second option is to call Foo( ) fewer times. A profiler having aspects of the current invention can help users identify what system calls they can rewrite to run in less time or call less often. But the user may still not be able to determine where the calls to Foo( ) are originating. A deeper level of information may be necessary and this deeper level can be found in a mapping mode as described below.","In one embodiment, there is a post-processing method of mapping addresses to functions during post processing of the captured stack information. A log of which functions were running at the capture point times is also generated. As an example, suppose an application has function A( ) which calls functions A( ) and A( ). Function A( ) calls into system function S( ), which calls system function S( ). Function A( ) calls function A( ). To help illustrate, you might draw a call graph like that shown in . The data that the profiler captures while this program is running might look something like that shown in Table 3:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Thread","Time","Entry\/",{}]},{"entry":["Call Stack","ID","(us)","Exit","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1 to A2 to S1","T1","0001","Entry","Sampled on entry to S1"]},{"entry":["A1 to A2 to S1 to","T1","0005","Entry","Sampled on entry to S2"]},{"entry":"S2"},{"entry":["S2","T1","0007","Exit","Sampled on exit from S2"]},{"entry":["S1","T1","0009","Exit","Sampled on exit from S1"]},{"entry":["A1 to A3 to A2 to","T1","0011","Entry","Sampled on entry to S1,"]},{"entry":["S1",{},{},{},"when called from a"]},{"entry":[{},{},{},{},"different path through"]},{"entry":[{},{},{},{},"the same program."]},{"entry":["A1 to A3 to A2 to","T1","0015","Entry","Sampled on entry to S2"]},{"entry":"S1 to S2"},{"entry":["S2","T1","0017","Exit","Sampled on exit from S2"]},{"entry":["A1 to A3 to A2 to","T1","0021","Entry","Sampled on entry to S2"]},{"entry":["S1 to S2",{},{},{},"when it is called a"]},{"entry":[{},{},{},{},"second time by S1"]},{"entry":["S2","T1","0023","Exit","Sampled on second exit"]},{"entry":[{},{},{},{},"from S2"]},{"entry":["S1","T1","0028","Exit","Sampled on exit from S1"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Each capture is an entire call stack, plus additional data for correlating call entry and exit events, along with system statistics for determining changes during the calls. The stream of captured and collected data from a buffer  data is a set of call stacks, where each call stack may be repeated more than once. In one embodiment, a number of reports are presented concerning the collected data set. For example, it is possible to derive the rough percentage of time an application was in a system function. Table 4 shows how the mode  data from Table 3 can be processed to produce results similar to those in Table 1.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},{},{},"Percentage of"]},{"entry":[{},{},"Percentage of calls",{},"time (25 us"]},{"entry":[{},"No.","(5 total system","Total ","total time inside "]},{"entry":["System Call","of Calls","calls made)","Time","system calls)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["S1","2 calls","40%","25 us","100%"]},{"entry":["S2","3 calls","60%","\u20026 us","24%"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Similarly, one report can add up time inside the modules that S and S are inside. As part of another report, the data from Table 3 can be processed to accumulate inclusive and exclusive sample counts for each part of the call graph. Where \u201cinclusive\u201d counts are the number of profiler samples that included that part of the graph, and \u201cexclusive\u201d counts are the number of profiler samples that were that exact graph. For example, post-processing could accumulate inclusive counts for all possible call graphs from the samples listed above. The results may be presented in a format similar to Table 5.",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},{},{},"Inclusive"]},{"entry":[{},{},"Inclusive",{},"time % (of"]},{"entry":[{},{},"call % (of","Inclusive","25 us total"]},{"entry":[{},{},"5 system","time total","in system"]},{"entry":["Graph","Inclusive call count","calls)","(us)","calls)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1 to A2 to S1","2","40%","8 us","32%"]},{"entry":[{},"(this is at the base"]},{"entry":[{},"of 2 call entries"]},{"entry":[{},"from Table 3)"]},{"entry":["A1 to A2 to S1","1","20%","2 us","8%"]},{"entry":["to S2","(this is at the base"]},{"entry":[{},"of 1 call entry from"]},{"entry":[{},"Table 3)"]},{"entry":["A1 to A3 to A2","2","40%","17 us\u2002","68%"]},{"entry":"to S1"},{"entry":["A1 to A3 to A2","2","40%","4 us","16%"]},{"entry":"to S1 to S2"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Inclusive counts can provide an exact accounting of the amount of time that it took to call a function, from entry to exit. From the time A first called S until the time S first returned, 50% of the program run-time passed. Accumulated exclusive counts for all possible call graphs from the samples listed in Table 3 result in the data of Table 6.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},"Exclusive","Exclusive","Exclusive"]},{"entry":[{},"Exclusive","call %","time total","time %"]},{"entry":["Graph","call count","(of 5 calls)","(us)","(of 25 us)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1 to A2 to S1","1","20%","6 us","24%"]},{"entry":[{},"(this exact",{},"(8 us total"]},{"entry":[{},"callstack",{},"between"]},{"entry":[{},"occurs only",{},"entry\/exit,"]},{"entry":[{},"once in",{},"minus 2 us for"]},{"entry":[{},"Table 3)",{},"the call to S2"]},{"entry":["A1 to A2 to S1","1","20%","2 us","\u20028%"]},{"entry":"to S2"},{"entry":["A1 to A3 to A2","1","20%","13 us","52%"]},{"entry":["to S1",{},{},"(17 us"]},{"entry":[{},{},{},"minus 4 us)"]},{"entry":["A1 to A3 to A2","2","40%","\u20024 us","16%"]},{"entry":["to S1 to S2",{},{},"(2 us each"]},{"entry":[{},{},{},"for two calls)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Exclusive counts correspond to an in-depth version of the data. A user could interpret that there are 3 calls to S and that S was executing for 24% of the program time. A user can interpret that S had 1 occurrence where the call came from A to A to S, and 2 occurrences where the call came from A to A to A to S. The data indicates how time divides among the various functions that called S.","In one embodiment, the inclusive and exclusive counts can be presented together in a single graphic format such that a user could expand or collapse parts of the graph, to assist the discovery of subsets of data that are interesting to the user. For example, there are additional views that are possible with mapping mode post processing data. A user may desire to generate a view that adds up inclusive and exclusive counts for subsets of the data. For example, the subset of all calls made by A, regardless of what function called A can be presented as in Tables 7 and 8.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":[{},{},{},{},{},"Inclusive",{}]},{"entry":[{},{},{},{},{},"time %","Inclusive"]},{"entry":[{},{},"Inclusive","Inclusive",{},"(of 17 us","time % (of"]},{"entry":[{},{},"call % (of","call % (of",{},"spent in","25 us total"]},{"entry":[{},"Inclusive","the 3 call","the 5 total","Inclusive","calls that","spent in"]},{"entry":[{},"call","entries that","system","call time","include","system"]},{"entry":["Graph","count","include A3)","calls)","(us)","A3)","calls)"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A3 to A2 to S1","3","100%","60%","17 us","100%","68%"]},{"entry":["A3 to A2 to S1","2","66%","40%","\u20024 us","24%","16%"]},{"entry":"to S2"},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":[{},{},"Exclusive",{},{},{},{}]},{"entry":[{},{},"% (of the",{},{},"Exclusive","Exclusive"]},{"entry":[{},{},"3 call",{},{},"time % (of","time % (of"]},{"entry":[{},{},"entries","Exclusive",{},"the 17 us","25 us total"]},{"entry":[{},{},"that","% (of the 5","Exclusive","spent in","spent in"]},{"entry":[{},"Exclusive","include","total system","call time","calls that","system"]},{"entry":["Graph","call count","A3)","calls)","(us)","include A3)","calls)"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A3 to A2 to S1","1","33%","20%","13 us","76%","52%"]},{"entry":["A3 to A2 to S1","2","66%","40%","\u20024 us","24%","16%"]},{"entry":"to S2"},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}}}},"Using the data from Tables 7 and 8, a user can discern the exclusive and inclusive break-downs of what functions A called, regardless of what functions called A. Similarly, another view could add up the subset of all calls made to S, regardless of what functions S called afterwards as shown in Table 9.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":[{},{},"Inclusive",{},{},"Inclusive","Inclusive"]},{"entry":[{},{},"call %",{},{},"time %","time % (of"]},{"entry":[{},{},"(of the 3","Inclusive",{},"(of the 6 us","25 us total"]},{"entry":[{},{},"calls that","call % (of","Inclusive","spent in","spent in"]},{"entry":[{},"Inclusive","include","the 5 total","call time","calls that","system"]},{"entry":["Graph","call count","S2)","calls)","(us)","include S2)","calls)"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1 to A2 to S1","1","33%","20%","2 us","33%","\u20028%"]},{"entry":"to S2"},{"entry":["A1 to A3 to A2","2","66%","40%","4 us","66%","16%"]},{"entry":"to S1 to S2"},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In another profile collection technique, a data set representing only the application portion of a call stack is collected and recorded as a result of a stack capture. Here, the profiler records only the part of the call stack that is within the application software thread. Using the same example program data as in the Table 3, the application only data would appear as in Table 10.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Thread","Time","Entry\/",{}]},{"entry":["Call Stack","ID","(us)","Exit","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1 to A2","T1","0001","Entry","Sampled on entry to S1"]},{"entry":["A1 to A2","T1","0005","Entry","Sampled on entry to S2"]},{"entry":["S2","T1","0007","Exit","Sampled on exit from S2"]},{"entry":["S1","T1","0009","Exit","Sampled on exit from S1"]},{"entry":["A1 to A3 to A2","T1","0011","Entry","Sampled on entry to S1,"]},{"entry":[{},{},{},{},"when called from a"]},{"entry":[{},{},{},{},"different path through"]},{"entry":[{},{},{},{},"the same program."]},{"entry":["A1 to A3 to A2","T1","0015","Entry","Sampled on entry to S2"]},{"entry":["S2","T1","0017","Exit","Sampled on exit from S2"]},{"entry":["A1 to A3 to A2","T1","0021","Entry","Sampled on entry to S2"]},{"entry":[{},{},{},{},"when it is called a"]},{"entry":[{},{},{},{},"second time by S1"]},{"entry":["S2","T1","0023","Exit","Sampled on second exit from"]},{"entry":[{},{},{},{},"S2"]},{"entry":["S1","T1","0028","Exit","Sampled on exit from"]},{"entry":[{},{},{},{},"S1"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Post processing the exemplary data in Table 10 as before results in the inclusive data of Table 11.",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},"Inclusive","Inclusive","Inclusive time"]},{"entry":[{},"Inclusive","call % (of 5","time","% (of 25 us"]},{"entry":[{},"call","system calls","total","total in system"]},{"entry":["Graph","count","recorded)","(us)","calls)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1 to A2","2","40%","\u20028 us","32%"]},{"entry":["A1 to A3 to A2","3","60%","17 us","68%"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Similarly, the exclusive results for the data from Table 10 are provided as in Table 12.",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Exclusive","Exclusive call %","Exclusive","Exclusive"]},{"entry":[{},"call","(of 5 system calls","time total","time %"]},{"entry":["Graph","count","recorded)","(us)","(of 25 us)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1 to A2","2","40%","\u20028 us","32%"]},{"entry":["A1 to A3 to A2","3","60%","17 us","68%"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}],"b":["1","2","4"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 5","b":["500","505","510","515"]},"Once a call event of interest is detected (step ), call stack information is acquired. This call stack information can include both application and system level program counter and other ancillary information. Depending of the mode selected by the process , the process can record the call stack information (step ) in a variety of data levels. In a first mode, both target application and target operating system stack data is recorded. In another mode, only the target application program counter information is recorded. Many collection variants are possible as discussed above.","Once recorded, the process  awaits the receipt of another event defined by the user (step ). The event may occur as a result of an entry to or an exit from a defined system call. If another event does occur, then the process  detects the event (step ) and steps  and  are repeated.","If another event is not expected, if a timeout occurs, or if the user terminates the process, then post-processing begins (step ). Post-processing retrieves information concerning the call stack information for each event detected. The call stack information may be processed to develop statistics concerning the operation of the application or operating system at the time the events occurred. The post-processing may include generating statistics corresponding to the mode of operation of data collection. If application data only is collected, then only application data is processed into statistical information. But if both application and system data is selected via the user selected mode, then both may be processed. The processed data may include statistics concerning the percentage of time that a specific function was operating as a results of executing the target code. The function could include an application function or a system function as reflected by the user selected mode. The data can be a listing of the functions entered and exited or it may be an inclusive accounting of all functions entered. Another statistic can be the number of exclusive functions demonstrated by the target code.","Upon generation of statistics concerning the data collected in the user-selected mode (step ), the post processed data and statistics may be displayed to the user (step ). This display of results may be in the form of graphs or tables and format selection may be dependent on user preferences.","Exemplary Computing Device",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 6"},"Although not required, embodiments of the invention can also be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, appliances, lights, environmental control elements, minicomputers, mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network\/bus or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 6","b":["600","600","600","600"]},"With reference to , an exemplary system for implementing an embodiment of the invention includes a general purpose computing device in the form of a computer system . Components of computer system  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer system  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, Random Access Memory (RAM), Read Only Memory (ROM), Electrically Erasable Programmable Read Only Memory (EEPROM), flash memory or other memory technology, Compact Disk Read Only Memory (CDROM), compact disc-rewritable (CDRW), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer system , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer system  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM, CDRW, DVD, or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer system . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer system  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory (not shown). In addition to monitor , computer systems may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer system  may operate in a networked or distributed environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer system , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer system  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer system  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer system , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web-enabled interface for applications and computing devices, making computing activities increasingly Web browser or network-oriented.","For example, MICROSOFT\u00ae's .NET\u2122 platform, available from Microsoft Corporation, includes servers, building-block services, such as Web-based data storage, and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device, one or more portions of an embodiment of the invention may also be implemented via an operating system, application programming interface (API) or a \u201cmiddle man\u201d object between any of a coprocessor, a display device and a requesting object, such that operation may be performed by, supported in or accessed via all of .NET\u2122's languages and services, and in other distributed computing frameworks as well.","As mentioned above, while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to implement a software program profiler for an embedded system. Thus, the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages, names and examples are chosen herein as representative of various choices, these languages, names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same, similar or equivalent systems and methods achieved by embodiments of the invention.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the signal processing services of an embodiment of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While aspects of the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Therefore, the claimed invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of exemplary embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating embodiments of the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 1(","i":["a","b"],"b":"1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
