---
title: Binary cache file format for themeing the visual appearance of a computer system
abstract: A binary theme file format provides optimized access to retrieve graphical component theme property data. The binary format includes data structures storing a set of defined visual characteristics for graphical component classes, parts, and states. The data structure includes a hierarchy of theme data. A theme manager quickly retrieves theme property data by indexing into the binary file with a unique theme handle. The theme manager accesses state, part, class, and global property sections to retrieve theme data. Jump tables and jump-to-parent references allow for quickly traversing property data sections. Packed data sections have packed objects having the necessary property data for frequently used graphical components. A custom image region data section provides border data for nontransparent image borders. A sampled colors section facilitates rendering of images with solid sections. The binary file format can be constructed using a text theme file and is loaded into shared process memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07565611&OS=07565611&RS=07565611
owner: Microsoft Corporation
number: 07565611
owner_city: Redmond
owner_country: US
publication_date: 20040812
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a divisional of application Ser. No. 09\/827,993 now U.S. Pat. No. 7,137,066, filed Apr. 5, 2001, and is incorporated herein by reference, which claims the benefit of U.S. Provisional Application No. 60\/195,607, filed Apr. 6, 2000, and a continuation-in-part application of U.S. patent application No. 09\/670,791, filed Sep. 27, 2000 now U.S. Pat. No. 6,873,337, entitled Application Programming Interface For Changing The Visual Style, which claims the benefit of U.S. Provisional Application No. 60\/195,593, filed Apr. 6, 2000.","The present invention relates to a computer system and, in particular, to a binary file format that facilitates creating and changing the visual style of displayed graphical components, such as controls.","Computer users in both the business and home environment have become accustomed to using a computer with a graphical operating system. For example, many users operate computers having a Microsoft Corporation \u201cWINDOWS\u201d operating system thereon. Certain components of these graphical operating systems are known as \u201ccontrols.\u201d For example, a control may be an \u201cOK\u201d button, which is generally a rectangular button with \u201cOK\u201d written in it. By moving the cursor over the button and clicking on the mouse, a known operation will begin that is associated with the control. Many other controls exist, with examples including scroll bars, dialog boxes and sliders. Beyond controls, the graphical operating systems also draw, or render, other graphical components as needed on the display of the computer, such as the window frame, the minimize box and the close box.","There are two general kinds of controls in WINDOWS: standard and custom. Standard controls are provided by the operating system. The code to create, draw and operate standard controls is contained in the common control library (COMCTL32.dll), or in USER32.dll, both of which are standard libraries provided as a part of WINDOWS. Custom controls are all other controls. Custom controls may be created by the manufacturer of the operating system or by third parties. The code for custom controls is contained in a corresponding separate library (DLL) or within an application.","Currently, when a graphical user interface component, such as a control, is used by an application, the application requests that an instance of the component be created. Following this, the operating system transmits a generic message to the component, instructing the component to render itself. The application plays a role in routing the message from the main window to the targeted control, but the control code performs the drawing. The application uses application programming interfaces (API's) to create and interact with the control. An API serves as a software interface to be used by other programs, much as the keypad serves as an interface to a calculator. An API is a fundamental concept of high-level programming. In high-level programming, a program often does not execute tasks by itself. Instead, the program asks some other program to execute these tasks. For example, programs frequently delegate various tasks to the underlying operating system. Continuing with the above example, an application delegates the rendering of a control to the control's code.","In the prior art environment, when a generic rendering message is received by a control to draw itself, the control will draw itself using its own drawing software code. In this prior art environment, the control knows what it is supposed to look like, how it is supposed to behave, and can effectuate such a display on the user interface of the computer. Thus, the application may delegate all aspects of visual rendering to the controls, avoiding the need to contain software code to support the visual rendering of the control within the host application itself.","By utilizing the standard controls defined and rendered by the operating system, all controls will have the same appearance, regardless of the application. Users of graphical operating systems can change only a limited number ofcharacteristics of the controls. In the \u201cWINDOWS\u201d operating system, a user can change the color scheme used to display the various controls and components on the monitor. The user can also select one of a number of fonts to be used by the controls and components. The user can also specify a limited number of nonclient sizes that will control the sizing of the non-client areas. Thus, the colors, fonts and a limited set of sizes of the controls and components may be changed. However, the basic appearance of the controls and components is dictated by the rendering software code within the control library containing the particular graphical component or control. In the prior art environment, to change the appearance of the controls or graphical components, the rendering software code must be altered. For example, if it is desired to change the appearance of the \u201cOK\u201d button, the rendering software code within the operating system DLL file containing the button control must be altered and the DLL file reconstructed at the binary level. If it were desired to render the button as an oval, the software code would have to be changed accordingly. Such an approach makes it difficult, if not impossible, for a computer user and for software manufacturers, to easily alter the appearance of the controls and graphical components.","In order to enhance the user experience of the computer, it would be desirable for the user to have the ability to change the overall \u201clook and feel\u201d of the graphical display by changing the overall visual appearance or \u201ctheme\u201d of the various graphical components. In other words, it would be desirable if the user could change not only the color and font of the graphical components appearing on the monitor, but to change the appearance of those graphical components as well. For example, it would be desirable to be able to alter and direct the layout of the parts of a control, and to define the shape of a control or its parts. It would also be desirable to control all aspects of how a control or its parts are drawn. Because the controls and graphical components existing within the DLL file in the prior art environment are \u201chard coded\u201d with their own rendering software code, it is difficult and cumbersome to change the appearance of all of the controls and components. To do so would require recoding each of the controls to achieve the desired appearance. If multiple visual styles were required, they would each have to be predefined and each \u201chard coded\u201d into every control.","Using the current approach, if a user interface designer desires to have a new \u201clook\u201d for a set of graphical components, the designer typically communicates this desire to a programmer. The programmer will then attempt to appropriately code the components to achieve the look desired by the designer. The designer will then review the look and communicate any needed changes to the programmer. This process continues, often with multiple iterations, until the designer is satisfied with the look achieved. It can be seen that the above process is time consuming and is limited by the communication between the designer and the programmer. It would be desirable to allow the designer to be able to perform the tasks necessary to achieve a specific look and to be able to revise the look achieved until the designer is satisfied. This would eliminate the revision time between the designer and the programmer and would give the designer more flexibility in the look achieved.","Certain prior art approaches exist that attempt to address the above situation. However, these solutions do not allow all of the controls and graphical components of the entire system to be changed. Instead, the prior art approaches address only limited portions of the set of displayed components. This allows the appearance of some controls and graphical components to be altered, leaving the remainder unaltered. Such an approach leaves an appearance that is not as coordinated as may be desired.","The prior art approaches are further limited by the techniques they employ to implement control of the appearance characteristics of visual elements of the graphical user interface. Prior art appearance modifiers operate by intercepting the generic rendering signals transmitted to the control, and, using low-level operating system graphical APIs, substitute their own rendering code for that of the control. However, only a portion of the visual elements in the graphical user interface is interceptible. Because the prior art approaches depend exclusively on the interception of operating system signals, not only are they themselves incapable of controlling the appearance of visual elements that do not function according to this protocol, they are incapable of providing a standard means for the author of the visual element to modify the rendering code to accommodate external control.","Further, it is not possible to intercept all relevant signals transmitted by the operating system to a control in the course of rendering. Still further, it is not always possible to reproduce complex visual behavior implemented by a control, such as animated sequences. Thus, the prior art approaches are prone to functional incompatibilities, visual flaws, and performance problems.","Further, prior art approaches do not allow the file that describes how to modify the appearance of the graphical components to be extensible. In other words, only certain components can be changed and this limited set of components cannot be expanded by the designer. Such an approach leaves an appearance that is not as coordinated as may be desired, and does not offer the needed flexibility to the designer. Still further, prior art approaches do not offer the user multiple choices within a selected visual appearance or theme.","Furthermore, the speed of property retrieval in prior art approaches is suboptimal. Prior art approaches store properties in text files that require the time-consuming process of parsing during run time to retrieve the property data. Prior art approaches do not provide direct access to properties with fixed structures for standard controls that are frequently accessed. An additional problem with existing systems is they do not provide a method for rapidly indexing to the desired property data using binary operations. Still further, prior art approaches have no special optimization for images that contain solid colors as one or more of the 9-grids of the image or multiple solid color lines as borders. Typically, solid colors can be drawn much faster than bitmap images.","In accordance with the present invention, the above and other problems are solved by creating a theme file in a binary format for fast and efficient access to retrieve graphical component theme property data. The binary format includes a control name table object representative of the controls names within the schema file and providing a link to each control's property data. The property data for a control include a hierarchal property list which contains part and state jump tables and a property value data structure for each property defined in the authored classdata (text) file. Together, these property value data structures define the visual characteristics for all parts of the control (including every state of each part).","In accordance with other aspects of the present invention, included is a system that converts a non-binary format theme file into a binary format theme file and loads the binary format file into shared memory when the user selects a new theme. The newly loaded theme is available to processes for later rendering of graphical components.","In accordance with other aspects, the present invention relates to a method of retrieving theme property data from the binary format file when requested by a graphical component. The method includes searching a state properties table and retrieving any property data that is found there. A subsequent jump to the part property table enables the retrieving of any property data that is found there. After another jump to a more generic class property table, property data stored there is retrieved. This is followed by a final jump to the global property section and retrieving the most generic property data.","The invention also includes packed drawing objects that are the minimum set of property structures needed to represent each class, part, and state in the theme file. Also included is a custom region data section having points with horizontal and vertical offset values that define the borders of nontransparent regions of an image. Also included is a sampled colors section having samples of colors to facilitate resizing images with solid borders and interior regions. The invention also includes a text objects section having the minimum set of properties needed to represent each graphical text component.","The invention may be implemented as a computer process, a computing system or as an article of manufacture such as a computer program product or computer readable media. The computer program product may be a computer storage media readable by a computer system and encoding a computer program of instructions for executing a computer process. The computer program product may also be a propagated signal on a carrier readable by a computing system and encoding a computer program of instructions for executing a computer process.","The great utility of the invention is that theme properties are quickly and efficiently retrieved. Also, changes to themes do not necessitate changes to component rendering code, so that many themes can be developed and easily implemented.","These and various other features as well as advantages, which characterize the present invention, will be apparent from a reading of the following detailed description and a review of the associated drawings.","The present invention provides a system, method and file format that facilitates creating and changing the visual style of displayed graphical components, such as controls, within a graphical operating environment. In one embodiment of the present invention illustrated in , operating system  is a graphical operating system having graphically displayed controls and components associated therewith. Controls include, but are not limited to, such things as scroll bars, push buttons and sliders. Other controls are within the scope of this invention, and are known to those of skill in the arL Other graphically displayed components are also within the scope of this invention. These components include, but are in no way limited to, non-client sections of the windows in the display, such as the frame surrounding an application display on the user interface, the minimize box, and the close box.","In , the basic architecture used in this embodiment of the present invention is illustrated. If the reader is already familiar with the operations of the theming system due to familiarity with the related patent application identified above, then it is suggested that the reader proceed to the description of )-(), , and  to understand embodiments of the present invention related to a binary file format for theming system components. The architecture is illustrated with example applications  that are open and running on the computer . As an application  is running it often requires a control or graphical component to be rendered, or displayed, on the monitor  of the computer .","In , libraries ,  and  are linked to the applications  through a fusion module . Fusion module  enables the theming of controls in applications without needing to change the applications themselves to request the themeable version of the controls. Fusion module  enables each application  to load the specific version of the DLL ,  or  at run time through the use of a manifest. The fusion manifest specifies the environment in which an application will run, which allows multiples versions of a DLL to exist on one machine. Thus, fusion module  will map the request for a component so that it is rendered as a themeable element in DLL  instead of a non-themeable element from DLL  or . This allows an existing application to be themed without changing code of the application. Fusion module  also allows the new themeable controls to be placed in a different DLL from the existing DLL, which simplifies implementation and minimizes compatibility risks.","Shared theme data  is a binary theme file containing all graphical component theme property data. Shared theme data  is created from several text files. The information from the text files is serialized into a binary theme file to allow for rapid run-time retrieval of property data. When an application  is started and dynamic link libraries are linked into its memory map, shared theme data is linked into the memory map. Theme manager  indexes shared theme data  using a handle from application APP  and component information. Shared theme data  is built with hierarchical levels of component data. The format of shared theme data  will be discussed in more detail with reference to )-().","Application  is notified by theme manager  when new binary theme file is loaded into shared theme data . A new binary theme file is loaded into shared theme data  when the computer user selects a new theme, such as \u201cBusiness.msstyles\u201d . In response to notification of a new theme, each control in an application such as APP , makes a request for a new theme handle, which is a theme handle used for later access into shared thane data . Theme manager  will return a handle to the requesting control if matching theme data is found for the application and control in the shared theme data . If theme data specific to the requesting application and its control is not found, a match for the control itself will be searched for. If successful, a theme handle for will be returned in response to the request. For subsequent component rendering, the theme handle is passed to the theme manager as a parameter, allowing the theme manager  to rapidly locate theme property data in shared theme data . The process of shared theme data update will be discussed in more detail in reference to .","An example display of graphical components having a variety of appearances is seen in . As shown in , the controls may take the form of an OK button , a Cancel button  and an Apply button . The present invention allows the appearance of the controls and other components to be visually changed to better suit the desire of the computer user. The invention allows the appearance of the controls to be altered beyond color and font selection. For example, the layout of the parts of a control can be defined as desired. For example, a scroll bar could be rendered with the up and down arrow buttons adjacent to each other at the bottom of the scroll bar, instead of the up arrow and the top and the down arrow at the bottom. Further, the shape of the control and its parts may be defined. As shown in , four different overall appearances are shown for each of the buttons ,  and . Each different appearance setting is coordinated and is called a \u201ctheme.\u201d Each theme is represented by one of the rows of buttons in . While only four themes are shown in , an unlimited variety of themes may be created for selection by the computer user. The theme is a collection or set of appearance characteristics relating to a particular subject or desired visual environment. As described below, the present invention allows the user of the computer to specify which of a number of predefined themes is to be applied to the controls and other components of the visual display. Moreover, the present invention allows new visual themes to be added to the system without the need of changing the software code of the controls and other graphical components. Still further, the present invention allows addition of new rendering technologies or modification of existing rendering technologies without changing the software code of the controls and other graphical components.","As an application  is running it often requires a control or graphical component to be rendered, or displayed, on the monitor  of the computer . For example, with reference to , the display of an OK button  may be needed by the application on the monitor. Application  requests that an instance of button  be created. Following this, the operating system transmits a generic message to the control instructing it to draw itself. This request would be routed to the dynamic link library (DLL) that contained the particular control. As an example, the DLL in the WINDOWS operating environment would be called User32.dll or ComCtl32.dll(V5), shown as  and , respectively, in . Libraries  and  exist within graphical operating system . Libraries  and  are linked through fusion module  with applications . The defined control within libraries  and  contains the drawing code needed to render the control on the monitor. Therefore, to change the appearance of controls in libraries , and , the software drawing code must be changed for each control within libraries  and .","An additional library DLL, shown as  in  similar to library , in that it contains a number of predefined controls and graphical components that may be used by application . Broadly, DLL  contains a number of components that are to be graphically displayed. In library , however, the controls are defined differently, making them \u201ctheme aware.\u201d Rather than containing all of the software code needed to render the control, the controls are defined with certain basic information or values about the control, for example, the location, parts and states of the controls.","The location is the position on the user interface where the control is desired. Parts are the different items that make up the control. For example, a scrollbar control has an elongated rectangular shaft part, a smaller thumb part that slides within the shaft part, and an arrow part at each end of the shaft part. The state of a control describes the current appearance and functional state. For example, a button can be active, pressed, hot (when the mouse is over the control), disabled or inactive.","The controls within DLL  also contain the drawing code needed to render the controls if no themes are selected, as well as the theme-aware paths through the code. DLL  requests rendering or drawing services from a theme manager DLL . Theme manager  provides the requested rendering services and draws the control on the display at the indicated location, with the indicated parts in the indicated states.","Theme manager  contains a series of APIs that allow library  to interact and communicate with the theme manager. The APIs allow a control author to define a control within DLL  as a series of parts and states without the need for software rendering code.","These APIs are generally divided into three types: drawing APIs , information APIs  and utility APIs . Drawing APIs  are generally used to render and assist in the layout of the needed control parts and other components. Information APIs  are generally used to obtain information about the current defined appearance of the controls to allow controls to be individually customized. Utility APIs  are those APIs used by parts of the operating system other than the controls, to control theme selection. Utility APIs  include functions that can be used to enumerate available themes and load one of them.","Drawing APIs  are a collection of theme-aware drawing services. Each individual API within the set of drawing APIs  is used to perform a different drawing service. Generally, each API requires a specified part and state of the graphical component at hand. An API called \u201cDrawThemeBackground\u201d is provided that draws the theme-specified border and fill for the specified part and state at the desired location. Similarly, an API called \u201cDrawThemeText\u201d is provided that draws the specified text using the themo-specified color and font for the specified part and state.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 2","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through an non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Although many other internal components of the computer  are not shown, those of ordinary skill in the art will appreciate that such components and the interconnection are well known. Accordingly, additional details concerning the internal construction of the computer  need not be disclosed in connection with the present invention.","Those skilled in the art will understand that program modules such as the operating system , application programs  and data  are provided to the computer  via one of its memory storage devices, which may include ROM , RAM , hard disk drive , magnetic disk drive  or optical disk drive . Preferably, the hard disk drive  is used to store data  and programs, including the operating system  and application programs .","When the computer  is turned on or reset, the BIOS , which is stored in the ROM  instructs the processing unit  to load the operating system from the hard disk drive  into the RAM . Once the operating system  is loaded in RAM , the processing unit  executes the operating system code and causes the visual elements associated with the user interface of the operating system  to be displayed on the monitor . When a user opens an application program , the program code and relevant data are read from the hard disk drive  and stored in RAM .","In operation, as is best seen in , an application  or  will request a graphic, such as a control, to be rendered on the user interface, as represented at . This graphical request is routed through fusion . As represented by , the fusion process will determine if the requested control is a theme-aware control. If the control requested is not theme-aware, the old code is used and the control will draw itself using a control from DLL  or , as represented by  in . If the control is theme aware, the graphical request is processed in DLL , as is represented by . The controls within DLL  will pass basic information for the graphical request, such as the part, state and location for the requested control to the theme manager  in a request for rendering services, using APIs ,  and . Thus, the graphical request is processed in DLL  without application of the appearance characteristics that are found by theme manager . Theme manager  will then determine or apply the theme-specific appearance characteristics for the given control part and state, as shown by . This appearance data is retrieved from the shared memory map data file . Using the retrieved appearance data, for the requested control part and state, along with the location, the theme manager will render the control on the display of the computer, as represented by .","Each theme  and  has similar architecture. As seen in , a theme directory  is included with business theme . Directory  includes a series of image files . Image files  are the image files that will be used by the particular theme. In this case, image files  are the image files that will be used by business theme . Business theme  also includes a themes.ini file . File  is a text file and can be created in ether ANSI or UNICODE character sets. File  specifies the available color schemes and sizes available for the theme. In the case of theme , file  specifies the available color schemes and sizes available for business theme . File  therefore represents all of the variations of the theme to which it applies, as is more fully described below.","File  is a directory of available class data files . In other words, the class data files  are packaged into file , as is described below. Class data files  are also .ini files as shown by the label \u201cDefault.ini.\u201d Class data files are used to list the theme data for a specific size and color. Each class data file is created by the theme author or designer from a schema file , labeled TMSchema.h in . Schema file  defines the controls, parts, states and available properties. Schema file  defines the properties that are recognized by the theme manager and gives them a unique identifier so they can be shared between the theme manager  and the control code at runtime. Schema file  is thus the defining vocabulary of available options that may be placed in a class data file . However, file  is extensible, as represented by the added material  in . Therefore, if a theme author creates a custom control with custom properties that are not within file , the theme author may create a mini-schema file , and register it, which may then be used to create a class data file . Schema file  typically resides within theme manager .","As an example of the type of information within schema file , information about the button control may be present. For example, the following may be contained within the schema file :\n\n","This information informs the theme author of the available controls and the defined parts and states for those controls. This information, along with available properties for the controls, parts and states, informs the theme author as to what is available for composing class data file . If a custom control is created, it may be placed in the mini-schema file . The flexibility provided by the mini-schema file allows a designer or theme author to add to schema file  and the created class data files . Thus, schema file  and any mini-schema files  are basically master definition files that allow the theme author to create a defined theme appearance.","As best seen in  each class data file  has a specific file format that allows each class data file  to be easily and uniformly created. File  may contain defining sections , which may be either predefined sections  or created sections . Typical predefined sections  include a globals section  that is a list of property name settings that are inherited by each parent class section. If used, the globals section  must be the first section. The globals values will be overridden by more specific, created properties if they are present, as is more fully described below.","Another predefined section that may be specified is called \u201cSysmetrics,\u201d and is labeled  in . Sysmetrics section  allows the theme author to set the system metrics when the theme is loaded so that the look of non-themed applications can be made to more closely match the look of the theme. The Sysmetrics section  is therefore available to legacy applications that are not \u201ctheme aware.\u201d When a theme is created, the theme author can set system metrics values to appear as close to the theme as possible. System metrics such as the colors for controls and non-client components, fonts, sizes, booleans and strings can be set using the Sysmetrics sections .","Created sections  are also referred to as class sections. Each class section can have an optional group name , a control name , an optional part name  and an optional state name . The group name  is the base name of an application, such as \u201cMICROSOFT MONEY.\u201d If the group name is specified, then the properties specified will be applied only to that application. The control name  is simply the class name as defined by the control author. For example, the control name might be \u201cbutton.\u201d The part name  is the child part name. For example, a part name for a button might be \u201cpushbutton.\u201d The child part name  must be defined as a part name for the control name  in the TMSchema.h file . Finally, the state name  is the state that the part might be in. For example, a state name  for the pushbutton part might be \u201cup.\u201d The state name  must be defined as a state name for its part  in the TMSchema.h file . In order to logically separate each of the above, the group name  is followed by ::, a period is placed between the control name  and the part name  and the state is placed in parentheses. As an example, a theme author may specify [MICROSOFT MONEY::button.pushbutton(up)]. The properties defined using this specification would apply only to the up state of the pushbutton part of the button in MICROSOFT MONEY applications. For both the predefined sections  and the created sections  properties are specified along with a corresponding value, as indicated at  in . The following table represents the basic property types and the corresponding value formats:",{"@attributes":{"id":"p-0071","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["PROPERTY",{}]},{"entry":["TYPE","VALUE FORMAT"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["String","Any text to the right of the \u201c=\u201d with no quotes."]},{"entry":["Int","A signed integer or hex number"]},{"entry":["Bool","On of the values: \u201ctrue\u201d or \u201cfalse.\u201d"]},{"entry":["Color","A comma separated list of three numbers, corresponding to"]},{"entry":[{},"red, green and blue."]},{"entry":["Enum","A string value that gets matched to a declared enum."]},{"entry":["Margins","A comma separated list of four integers, with partnames"]},{"entry":[{},"\u201clw\u201d, \u201crw\u201d, \u201cth\u201d and \u201cbh\u201d."]},{"entry":["Filename","A relative path that gets fully qualified."]},{"entry":["Size","An integer followed by optional \u201ctwips,\u201d \u201cpixels,\u201d"]},{"entry":[{},"or \u201cpoints.\u201d"]},{"entry":["Position","A comma separated list of two integers with partnames"]},{"entry":[{},"\u201cx\u201d and \u201cy.\u201d"]},{"entry":["Rect","A comma separated list of four integers with partnames"]},{"entry":[{},"\u201cl\u201d, \u201ct\u201d, \u201cr\u201d, and \u201cb\u201d."]},{"entry":["Font","Family name, size and font flags."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Each of the group name, control name, part name and state name behave in a hierarchical fashion. State names  inherit from their part name  or control name  and part names  inherit from their control names . The group name , control name , part name  and state name  contain, together with the inherited globals section , all of the property values needed to render the specified class of control. This hierarchy can best be seen in . As indicated at , it is first determined if properties are defined for the control, part and state. If so, they will be used. Similarly, it is next determined if properties are defined for the control and part, as indicated at . If so, the defined properties will be used. If not, it is then determined whether properties are defined for the control, as shown at . If so, the defined properties will be used. If not, the properties defined in the globals section  will be used, as indicated at .","The above file format for the class data files , along with the available vocabulary as defined in the schema file  can be used by the theme author to create a variety of class data files  without the need to go through a series of iterations with a programmer. As an example, a theme author may draft the following:\n\n","In this example, the properties defined for all buttons are \u201cfont\u201d and \u201cImageFile\u201d. The pushbutton part of the button overrides the \u201cfont\u201d property with its own value, adds a new \u201cTextColor\u201d property, and inherits the \u201cImageFile\u201d property from button. The defined properties for the button class will be applied to all buttons, but the specified properties for the pushbutton part will prevail over the specified properties for the button class.","Theme file , the \u201cpackage\u201d file, also consists of one or more sections. The sections within theme file  include a documentation section , a size section , a color scheme section  and a file section . Documentation section  is optional and may contain any property name. For example, documentation section may specify a name for the theme to be displayed on the user interface, such as \u201cbusiness theme.\u201d Size section  specifies the size names available, such as \u201cdefault size,\u201d \u201cvery small\u201d or \u201cvery large.\u201d","Color scheme section  is used to specify a simple color scheme name and an optional color scheme transformation associated with the color scheme name. For example, if only one color scheme is available, the color scheme name would likely be \u201cdefault color.\u201d Other color scheme names could be made available, as described below, and would be named as well. For example, a blue color scheme and a red color scheme could be listed in color scheme section. If a particular desired color scheme has not been created as a class data file, as more fully described below, the theme author can perform a color scheme transformation on an existing theme file. In the color scheme section, the theme author can transform an existing color scheme through use of \u201cFrom Color=\u201d and \u201cTo Color=\u201d commands along with available \u201cFrom Hue=\u201d and \u201cTo Hue=\u201d commands. The values specified after the \u201c=\u201d sign are values for red, green and blue, respectively. For example, if the theme author desired to change any color that is red to green and to change the hue of the color scheme, the theme author may specify in the color scheme section :\n\n","The size section  can operate similarly to color scheme section  as described above. As such, a size name can be associated with a specific class data file. Additionally, size transformations can be performed on a specified class data file in a manner like that described above for the color transformations.","File section  is used to specify a unique name for each of the class data files . Each class data file listed in the file section  will include the file name, a color scheme (from color scheme section , including transformations) for that file name, and the sizes (from the size section ) that the file will support. File section  is therefore a list of all possible colors and sizes available, including color transformations. The file section  is named \u201cfile.xxx\u201d where \u201cxxx\u201d is replaced with a unique name for the class data file. The file section  recognizes properties for a filename, color schemes and sizes. An example file section for the class data file named \u201cOne\u201d would be:\n\n","In this example, file section  corresponds to the Large class data file and supports the color schemes default, blue and red. The only size that the file supports is \u201cLarge.\u201d","Image files  and theme file  (including packaged class data files ) are broadly grouped together to make up theme directory . Theme directory  and the schema file , along with any mini-schemas , are used to build the business theme file . Theme directory  thus contains a theme.ini file , one or more class data files  and all of the image files  used by the theme. The contents of theme directory  can be packaged into a DLL file by packthem tool . Packthem tool  processes the Themes.ini file  by parsing it against the schema file  for syntax errors and adding the .ini file to the package being built. Recognized properties from documentation section  are written to a package string table. Color scheme information from color scheme section  and size information from size section  is also written to a package string table. Each class data file  is also processed. As the class data file is processed, the file is parsed against the schema file  for syntax errors. Each class data file is also added to the package being built.","The DLL file produced by packthem tool  is business theme file . File  contains the theme data and this theme data is isolated from control library . This allows different themes to be created and selected without changing the controls defined within library . Thus, control authors can create and define controls independently of the appearance or theme data. File  is in binary format and is passed into a shared theme data file  when business theme  is selected by the computer user, as best seen in . File  is a shared memory map file that can be accessed by all processes. Thus, when a theme is selected by the computer user, theme manager  will read the information for a defined theme file, such as file , and will place that information in a binary format in file  where all running processes have access to the binary information.","As best seen in , a theme-switching control panel  is provided that is in communication with theme manager . Panel  cooperates with a user interface that displays the available themes from which the user can select. As shown in , control panel  would allow a user to select business theme  or consumer theme . The user would also be presented with available options created by the theme author within each of the class data files. For example, as is best seen in , the user interface may present a series of drop down menus corresponding to the visual style , the available color scheme  for that visual style and the available sizes  for that visual style. In the example seen in , the user can see that the business theme  is selected, but that consumer style  is available. For the selected business theme , the user can see that the theme author has created two color schemes, displayed as \u201cBLUE\u201d and \u201cRED.\u201d Finally, the user can see that the only size the theme author has made available is the default size.","If as has been discussed above, business theme  is selected and the user of the computer switches to select consumer theme , theme  will be loaded into shared memory map file  as binary data. Theme manager  also sends a message to each themeaware control within DLL file  that the theme has changed. Each themoaware control knows how to respond to this message.",{"@attributes":{"id":"p-0084","num":"0103"},"figref":["FIG. 9(","FIG. 9(","FIG. 9(","FIG. 9("],"i":["a","a","a","a"],"b":"238"},"In ) a binary file format  is shown having a header section , class index section , global class section , system metrics class section , and other class sections . A class section is shown as having a hierarchical theme data section  and a packed objects section . The hierarchical theme data section  is shown having a part jump table , a class property data section , a part property data section , state jump tables , a state property data section , and a jump-to-parent data section . Furthermore, as will be discussed below, the hierarchically arranged sections allow for rapid indexing and retrieval of theme property data.","In the embodiment of ), the header section  typically contains general data describing the theme version number, checksum, total file length, and offsets to the various sections of the file. Class index section  contains a list of the applications and classes(i.e., graphical component) and an offset to their associated class sections. The class index  contains entries for each class defined in the class data file . Each of these entries contains a single class name. Some entries are specific to an application. Any entry that is specific to an application contains an application name as well as a class name. Two special class sections are the global section  and the system metrics section . The global section  contains global property data for components, generically. As will be discussed, global properties are retrieved if there are no specific properties found in another section of the theme data section . System Metrics section  contains a single property value data structure consisting of a fixed size embedded data structure containing all of the system metric values. The system metrics section will be discussed in more detail later in the discussion of . The other class section  contains theme property data for control classes applicable to all applications as well as some application-specific control class sections. The class data section  is describes the composition of each class section. The packed object section  contains commonly accessed property data grouped together for each control\/part\/state where they are defined, and will be discussed in more detail with reference to ).","The hierarchical theme data section  contains control properties in a set of data sections arranged in a hierarchy. Part jump table  contains an offset to the part property data section  or an offset into state jump table . A special entry in the part jump table  contains an offset to the packed objects  (for all parts and states of the class), which will be discussed in reference to ). State jump table  contains an offset to each state's property data section  wherein property data for the part and state are stored. Class property data  contains theme property data items for properties defined at the class level. Class property data , part property data , and state property data  contain items that are instances of a property data item , shown in ). The lowest level in the hierarchy is the state property data section . The next highest level is the part property section . The class property section  is one level higher than the part property section . The global section  is the highest level in the hierarchy. A jump-to-parent data section  provide an offset into a higher level, or parent, property section. For example, at the end of the state property section , the jump-to-parent data section  can provide an offset into the part property data .","A jump-to-parent data section  can be placed at the end of the state property data section , part property data section , and class property data section . For example, after the last property data item  in the part property data  there can be a jump-to-parent reference  that refers to an offset to an entry in the class property data section . The class level properties describe the component more generically. Similarly, at the end of a list of class property data items  in the class property data section  there can be a jump-to-parent reference  that refers to an associated entry in the global class section . Jump-to-parent references  are used to traverse the hierarchy of property sections to gather common property data to build packed objects, such as packed drawing objects  ()), and to retrieve custom properties in response to requests by controls.","In the embodiment, a property search begins in the state property section . After the state property section  is searched, a jump may be made to a higher level property section (e.g, the part property section , class property section , or global property section ) for further searching. The jump does not need to be to the next highest level in the hierarchy. For example, the jump could be made from the state property section  to the class property section , skipping the part property section .","If the property sought for a control is not found in a lower level property section, such as the state property section , a jump-to-parent reference  at the end of the lower level property section may direct the theme manager  to continue the search in a higher level section, such as the class property section . In the example, the class property section  is considered the parent section of the state property section  for the control. When the theme manager  searches for a particular property in a property data section, the theme manager  steps through and reads each property data item , determining whether the property data item  matches the desired property. If none of the property data items  match the desired property in the current property data section, the theme manager  will use the jump-to-parent section  to jump to the next defined parent property data section. The theme manager  will continue searching for the desired property in the associated parent section. The jump-to-parent section  is in the form of a property data item , which will be discussed next.","Turning to ), there is shown an example of a property data item . Property data item  consists of derived property ID , primitive property ID , property data length , property data . Derived property ID  contains a numeric identifier for the particular part of the component to be rendered. For example, derived property ID  might be , which could indicate that the value that follows is the color to be used when rendering text in the component to be rendered. Primitive property ID  contains a numeric identifier for the type of the derived property . For example, if the derived property ID  indicates Text Color, primitive property ID  would be the identifier for color. Thus, property data  would be data for the color of the text. Property data length  is the length in bytes of the property data that follows. This is useful in jumping quickly past unneeded properties. For example, if a \u201ccolor text\u201d property with ID \u201c45\u201d where being searched for in the hierarchy, the search could look at the property ID  of the data item and, if it didn't equal \u201c45\u201d, add the data length  to a current data pointer to index directly to the next data property. When the property data item  is a jump-to-parent reference , the property data  is an offset to the associated parent section.","Referring again to ), there is shown a packed objects section . The packed objects section  is in binary format and is preferably located after the hierarchical data section  as shown in ). In one embodiment, the packed objects section  contains a drawing objects section , a custom region data section , a sampled colors section , and a text objects section . As will be shown in more detail, each of the sections , , , and  are fixed structures of property data created from the hierarchical class sections of binary file format . As will be shown, the format of the fixed structures in the packed objects section  optimizes the speed of property retrieval.","An exemplary embodiment of the drawing objects section  is shown in more detail beside the packed objects section . In this embodiment, each unit of drawing object data consists of a drawing object  and an associated drawing object header . A drawing object  is a fixed structure created from the data in the hierarchical binary file format . In this embodiment, a packed drawing object is created for classes, parts, and states that specify one or more image file or BorderFill property. The theme manager  searches the binary file format  using the jump-to-parent references  as discussed earlier, and creates a drawing object  and drawing header  for every unique part and state number combination that have at least one instance of an Imagefile property and Borderfill property. Each state property, part property, class property, and global property, as appropriate, is gathered from the hierarchy and put into a drawing object . In the example embodiment shown in ), two types of structures exist, an Imagefile structure and a Borderfill structure. For every part or state for which a packed data object is created, an offset value is put into the beginning of the part jump table , indicating where the first packed object for the class is located in the shared data .","Although the packed drawing objects are preferably stored sequentially following the hierarchal property data section for a class, at runtime the theme manager  creates another set of data structures to optimize access to the packed objects using a separate set of part\/state jump tables to obtain a direct pointer to the correct drawing object. Exemplary embodiments of these data structures are shown in ).","Referring to ) there is illustrated an exemplary embodiment of a class object data structure  that facilitates access to packed drawing objects in the packed object section . The class object data structure  includes a part count  and a part information array . The part information array  is an array of part information structures , which contain offset information associated with a class. The part count  is the number of part information structures  in the part information array . The part count  can be viewed as the number of parts associated with the control for which packed drawing objects have been created.","The part information structure  includes a state count , a part drawing object pointer , a part text object pointer , a state drawing object pointer array, and a state text object pointer array . The state count  is the number of states associated with a part. The state count  gives the length of the state drawing object pointer array  and the state text object pointer array . The part drawing object pointer  is a reference, or offset, to an associated part drawing object in the drawing objects section . The part text object pointer is an offset to an associated text object in the text objects section . The state drawing object pointer array  is an array of offsets to a set of associated state drawing objects in the drawing objects section . The state text object pointer array  is an array of offsets to a set of associated state text object in the text objects section .","After the structures shown in ) have been created, whenever the properties are requested for a part and state associated with a drawing object , the requesting control passes in a part ID and state ID. The part information array , in the class object data structure , is indexed with the Part ID to obtain an associated part information structure . It is determined whether a valid state drawing object pointer  exists in the part information structure . If the state drawing object pointer array is not valid (e.g., a pointer not allocated), the part drawing object pointer  is used to obtain the associated part-level drawing object. Note that class level properties are treated internally as \u201cpart 0\u201d objects (since real part numbers are allocated starting at \u201c1\u201d). If the array of state drawing objects is valid, the state drawing object pointer array  is indexed with the state ID and a direct pointer to a drawing object  is obtained.","The drawing object  is accessed and provides all the necessary property data, eliminating the steps of scanning the hierarchy of the binary file format . Importantly, a drawing object  for the Imagefile property structure typically provides offsets into the custom region data section  and the sampled colors section . Exemplary property data associated with the drawing object  is shown in ).","Shown in ) is an embodiment of a drawing object  having an Imagefile structure. The Imagefile structure is used for parts and states that have one or more images as a property. A single image data section  can provide data including, but not limited to, device independent bitmap(DIB) data offset, image count, image layout, image height, and image width. A region list offset  is an offset into the custom region data section , and will be discussed in more detail. A multiple image data section  can provide data including, but not limited to, multiple image offsets and file sizes. A sizing type indicator  indicates the type of sizing. Sizing types include, but are not limited to, stretching, tiling, and true size. A border only indicator  indicates that only the border grids of the image should be rendered.","A transparency indicator  is provided to indicate whether there are transparent parts in an image. An alpha channel indicator  indicates whether alpha channel processing should be applied to the image. Alpha channel is eight bits in a 32-bit graphics pixel that is used as a separate layer for representing levels of transparency in an object. As will be discussed in more detail, the transparency indicator  and alpha channel indicator  are preferably used to determine whether the region list offset  is used. A mirror image indicator  indicates whether the image should be mirrored (flipped horizontally) when rendered in a mirrored device context. A true size image data section  provides property data for true size images and is used if the sizing type  is true size. Sizing margins  and content margins  provide property data for the margins that define the grids and the position of an image. Grids will be discussed in more detail with reference to .","A solid border indicator  and a solid content indicator  each indicate whether an image has solid colors associated with it, and is used to determine whether the sampled colors section  may be used to render the image. If the solid border indicator  or solid content indicator  are true, then sampled colors offset  is used to index the sampled color data from the associated section of the sampled colors section , from which, the image can be rendered more quickly. A text property data section  provides text property data including, but not limited to, font, color, and size. An image data reference  provides a reference to image data when a component does not have an associated theme file. A part and state identifier  is provided to associate the draw object  with a part and state.","Turning now to the custom region data section  shown in ), there is shown one possible embodiment of the custom region data section . In this embodiment there is custom region data for multiple states. Thus, a section, such as max states , provides the number of states for which there is custom region data. The region list offset  of the drawing object  refers to the max states section . One or more region data offsets  provide the offsets for each element of custom region data. As shown in ), a region data offset , refers to a custom region data header . Region data header  includes a part number and state number associated with the drawing object . A custom region data section  contains data defining the borders of nontransparent (clickable) regions of an image. Custom region data  is preferably in the form of coordinate points, and will be discussed in more detail in reference to . A region grid data section  is a list of reference grids related to the points in the custom region data , and will be discussed in more detail in reference to .",{"@attributes":{"id":"p-0103","num":"0122"},"figref":["FIG. 9(","FIG. 9("],"i":["c","c"],"b":["938","957","941","938","970","967","967","968","969","969"]},"The sample color data section  is typically a structure containing a plurality of arrays having color data. A COLORREF is a typically a \u201cDWORD\u201d, meaning 4 bytes. The bytes represent the value for Red, Green, Blue, and Alpha. For example, red=0 means there is no red in the color and red=255 means the color contains the maximum amount of red. Also, alpha=0 means the color is completely transparent\/invisible. alpha=255 means the color is opaque and has no transparency. Shown in Table 1 below is an exemplary layout for the sampled colors data section :",{"@attributes":{"id":"p-0105","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["struct SAMPLEDCOLORS",{}]},{"entry":"{"},{"entry":"\u2003COLORREF crContent;"},{"entry":["\u2003COLORREF crLeftBorderColors[ ];","\/\/ array of colors"]},{"entry":[{},"(length=SizingMargins.left)"]},{"entry":["\u2003COLORREF crRightBorderColors[ ];","\/\/ array of colors"]},{"entry":[{},"(length=SizingMargins.right)"]},{"entry":["\u2003COLORREF crTopBorderColors[ ];","\/\/ array of colors"]},{"entry":[{},"(length=SizingMargins.top)"]},{"entry":["\u2003COLORREF crBottomBorderColors[ ];","\/\/ array of colors"]},{"entry":[{},"(length="]},{"entry":[{},"SizingMargins.bottom)"]},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Referring to , shown therein is a logical representation of an image  in an embodiment of the present invention. An image is comprised of a plurality of pixels. In the example of , the image  is 18 pixels wide and 20 pixels tall. Each pixel has an associated color value. Image  can be viewed as a rectangular image with grids - (). Also shown in  is a regional mapping overlay  that will be discussed later.","Each grid  is defined by a set of sizing margins. Exemplary sizing margins in  are right sizing margin , left sizing margin , bottom sizing margin , and top sizing margin . Thus, for example, grid  () has a top boundary of top sizing margin , a bottom boundary of bottom sizing margin , a left boundary of left sizing margin , and a right boundary of right sizing margin . The boundaries of the image are easily determined from the sizing margins. For example, in , top sizing margin  has a value of five because it is five pixels vertically below the top boundary of the image . Similarly, bottom sizing margin  has a value of five because it is five pixels vertically above the bottom boundary of the image . Similarly, left sizing margin  has a value of three and right sizing margin  has a value of three. The sizing margin values used for the example of  are examples used for illustration purposes only and can be any values such that they define grids  of an image .","Also shown in the exemplary image of  are four transparent parts  of the image. Transparent parts are parts of the image through which whatever is behind them is visible to the computer user. Also, transparent parts are parts of the image that the user is not able to \u201cclick\u201d on with the mouse pointer. Nontransparent parts of an image are clickable and transparent parts are non-clickable. If a computer user positions the mouse pointer over an image and clicks, it must be determined whether the user has clicked on a transparent part or a non-transparent part. Clicking on a transparent part will generally result in no computer processing action, whereas clicking on a nontransparent part will generally result in computer processing action. Thus, it is necessary to logically represent and distinguish between the positions and sizes of nontransparent parts and those of transparent parts. The logical representation of  illustrates how one embodiment of the present invention logically represents clickable image parts and non-clickable image parts in memory.","In the example image of , each transparent part  is one pixel in size in a corner of the image; however, each transparent part  can be located anywhere in the image and be of any size or shape. The present embodiment defines borders of image regions, such as rectangle  (), rectangle  (), and rectangle  (). The border definitions, combined with the grid boundaries , are sufficient data to define the positions and sizes of transparent parts . For example, rectangle  () is bounded on the left by a transparent part  and on the right by transparent part . Rectangle  () is bounded on the top left by transparent part , on the top right by transparent part , on the bottom left by transparent part , and on the bottom right by transparent part . Rectangle  () is bounded on the left by transparent part  and on the right by transparent part .","As will be shown, six points, each having two values, and six grid numbers are preferably stored to define the borders of transparent parts  of the exemplary image  of . The positions of nontransparent regions, rectangle  (), rectangle  (), and rectangle  () are each defined by two points. Point 1032 and point 1034 define the boundaries of rectangle  (). Point 1036 and point 1038 define the boundaries of rectangle (). Point 1040 and point 1042 define the boundaries of rectangle  (). Each of the points 1032, 1034, 1036, 1038, 1040, and 1042 has a pair of values, the first value (an \u201cx\u201d value) defining a horizontal offset from a vertical reference line, the second value (a \u201cy\u201d value) defining a vertical offset from a horizontal reference line. Grid  (), grid  (), grid  (), and grid  () are superimposed on regional mapping overlay  to illustrate how vertical reference lines and horizontal reference lines are determined.","In the example of , the point  has an x, or horizontal offset value, of one. Point 1032 has a \u2018y\u2019, or vertical offset value, of zero. As mentioned earlier an associated grid number is stored for each point. In the case of the example point 1032, the grid number stored is grid  (). In this representation, the \u2018x\u2019 value of point 1032 is relative to the left vertical boundary of grid  (), and the \u2018y\u2019 value of point 1032 is relative to the top horizontal boundary of grid  (). Continuing with the example, the point 1034 has an \u2018x\u2019 value of two and a \u2018y\u2019 value of one, with the associated grid, grid  (). Thus, the horizontal and vertical offsets of point 1034 are measured from the left boundary of the grid  () and the top boundary of grid  (), respectively. The logical representation using the points 1032 and 1034 thus sufficiently define the boundaries of the rectangle  ().","The boundaries of the exemplary regions, rectangle  () and rectangle  (), are represented in a similar fashion. Thus, the point 1036 has an \u2018x\u2019 value equal to zero and a \u2018y\u2019 value equal to one. The associated reference grid number is zero for point 1036 because the point 1036 is located relative to grid  (). The point 1038 has an \u2018x\u2019 value equal to three and a \u2018y\u2019 value equal to four, and the associated reference grid  (). With the point  and the point 1038, the boundaries of the rectangle () are defined. Likewise, the point 1040, with \u2018x\u2019 value of one and \u2018y\u2019 value of four, and the associated reference grid  (), describe the left and top boundaries of the rectangle  (). The point 1042, having \u2018x\u2019 value of two and \u2018y\u2019 value of five, and the associated reference grid  (), define the right boundary and bottom boundary of rectangle  ().","The values described in  are stored in a data structure described in . Referring now to , shown therein is a custom region data structure  having point data and reference grid data. Continuing with the example image of , a point is stored, such as point 0 (1032), that gives a horizontal offset from the top border of a reference grid and a vertical offset from the left border of a reference grid. A reference grid is stored so that the absolute location of the border of a nontransparent part can be calculated. In the case of point 0 (1032), the associated relative grid is stored in section relative grid (point 0) (1100). The horizontal offset value associated with point 0 (1032) is stored in section x (point 0) 1102 and the vertical offset value associated with point 0 (1032) is stored in section y (point 0) 1104. Similarly, point 1 (1034) has an associated reference grid, relative grid(point 1) (1106), associated horizontal offset value x(point 1) 1108, and associated vertical value y(point 1) 1110. To illustrate further, point 2 has an associated reference grid, such as relative grid(point 2) 1112, associated horizontal offset value x(point 2) 1114, and associated vertical offset value y(point 2) 1116. Any number of points, associated grids, associated horizontal offsets, and associated vertical offsets can be stored for any number of transparent regions.","During run time, drawing object images often need to be resized to draw image parts into sizes and locations specified by the control. Likewise, the transparent regions of the resized image part need to be determined. The prior art approach is to size the image and then convert the newly sized image into a transparency region. This process is very expensive because it involves \u201cwalking the pixels\u201d in the image to determine which are transparent. The custom region data  allows the image parts to be quickly resized using the 9-grid parameters of the associated image.","After data structures such as those shown in  are constructed, an image can be resized and displayed quickly and efficiently by determining transparent regions prior to resizing the image. A point, such as point 0 (1032), is transformed into a transformed point identifying vertical and horizontal boundary lines of a transparent region. Transforming a point includes adding an x value, such as x (point0) 1102, to a location of a vertical grid boundary, such as the left boundary of relative grid (point 0) 1100, to obtain a vertical boundary line for a transparent region, such as the transparent region  of . Transforming a point also includes adding a y value, such as y (point0) 1104, to a location of a horizontal grid boundary, such as the top boundary of relative grid (point0) 1100, to obtain a horizontal boundary line for a transparent region, such as transparent region . Transforming a point can also include scaling a point.","One possible implementation of a method of transforming the points of  to yield boundaries of transparent regions is shown in Table 2.",{"@attributes":{"id":"p-0117","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"for (int i=0; i < cPoints; i++, pt++, pByte++, ptNew++)"},{"entry":"\/\/ transform each \u201cpoint\u201d"},{"entry":"\u2003{"},{"entry":"\u2003\u2003switch (*pByte)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003case GN_LEFTTOP: \u2003\u2003\/\/ left top : grid 0"},{"entry":"\u2003\u2003\u2003\u2003ptNew->x = pt->x + iLeftXOffset;"},{"entry":"\u2003\u2003\u2003\u2003ptNew->y = pt->y + iTopYOffset;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case GN_MIDDLETOP: \u2003\u2003\/\/ middle top : grid 1"},{"entry":"\u2003\u2003\u2003\u2003ptNew->x = (pt->x*iXMult)\/iXDiv + iMiddleXOffset;"},{"entry":"\u2003\u2003\u2003\u2003ptNew->y = pt->y + iTopYOffset;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case GN_RIGHTTOP: \u2003\u2003\/\/ right top : grid 2"},{"entry":"\u2003\u2003\u2003\u2003ptNew->x = pt->x + iRightXOffset;"},{"entry":"\u2003\u2003\u2003\u2003ptNew->y = pt->y + iTopYOffset;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case GN_LEFTMIDDLE: \u2003\u2003\/\/ left middle : grid 3"},{"entry":"\u2003\u2003\u2003\u2003ptNew->x = pt->x + iLeftXOffset;"},{"entry":"\u2003\u2003\u2003\u2003ptNew->y = (pt->y*iYMult)\/iYDiv + iMiddleYOffset;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case GN_MIDDLEMIDDLE: \u2003\u2003\/\/ middle middle : grid 4"},{"entry":"\u2003\u2003\u2003\u2003ptNew->x = (pt->x*iXMult)\/iXDiv + iMiddleXOffset;"},{"entry":"\u2003\u2003\u2003\u2003ptNew->y = (pt->y*iYMult)\/iYDiv + iMiddleYOffset;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case GN_RIGHTMIDDLE: \u2003\u2003\/\/ right middle : grid 5"},{"entry":"\u2003\u2003\u2003\u2003ptNew->x = pt->x + iRightXOffset;"},{"entry":"\u2003\u2003\u2003\u2003ptNew->y = (pt->y*iYMult)\/iYDiv + iMiddleYOffset;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case GN_LEFTBOTTOM: \u2003\u2003\/\/ left bottom : grid 6"},{"entry":"\u2003\u2003\u2003\u2003ptNew->x = pt->x + iLeftXOffset;"},{"entry":"\u2003\u2003\u2003\u2003ptNew->y = pt->y + iBottomYOffset;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case GN_MIDDLEBOTTOM: \u2003\u2003\/\/ middle bottom : grid 7"},{"entry":"\u2003\u2003\u2003\u2003ptNew->x = (pt->x*iXMult)\/iXDiv + iMiddleXOffset;"},{"entry":"\u2003\u2003\u2003\u2003ptNew->y = pt->y + iBottomYOffset;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case GN_RIGHTBOTTOM: \u2003\u2003\/\/ right bottom : grid 8"},{"entry":"\u2003\u2003\u2003\u2003ptNew->x = pt->x + iRightXOffset;"},{"entry":"\u2003\u2003\u2003\u2003ptNew->y = pt->y + iBottomYOffset;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Turning now to , shown therein are exemplary embodiments of the binary format of the text objects section  and the system metrics section . Like the other packed objects sections discussed previously, the text objects section  is a binary structure having all the necessary theme property data for a particular type of graphical component. The text objects section  has theme property data for graphical text components that is obtained from the class, part, and state property data sections (, , and ) of the binary file format .","The theme manager  searches the classes' hierarchal property section in the binary file format  and creates a text object and drawing header  for every unique part and state number combination that have at least one instance of a TextDraw property. For every unique combination of state and part having a TextDraw property, every state property, part property, class property, and global property associated with the combination is gathered from the hierarchy and put into a text object. When text of a control is to be rendered or measured, the control calls one of the text theme API's, passing a plurality of parameters, including, but not limited to, an associated theme handle (which is an indirect pointer to the control's associated class object in the class object data structure ), and part and state IDs. The associated text object is retrieved using the class object and part and state IDs, in a similar manner to how drawing objects are retrieved (as described above, using )).","The text objects section  contains a text color data section  having the color of the text. A shadow properties section  can provide any shadow property data, including but not limited to, a shadow position, a shadow color, a shadow type, and a shadow indicator, indicating whether a shadow should be applied. A border properties section  preferably provides text border property data such as border size and border color. A font properties section  preferably provides a font type and a font indicator, indicating whether a font should be applied. A graphical component identifier, such as ID , stores the associated graphical component part identifier and state identifier.","Turning now to the exemplary system metrics data section , of , shown therein are a fonts section , a colors section , a sizes section , a Booleans section , and a string section . As mentioned earlier, these sections can be used to store property data for applications that are not theme aware, so that the application appears as close to the theme as possible.","Referring to , shown therein is an embodiment of a method of building a custom region. Control begins at start operation  wherein startup initialization is performed. Control then transfers to the get next property operation  wherein the next property in the hierarchical structure of the binary file format  is selected. Control then transfers to the determining operation  wherein it is determined whether the selected property is an image file property. If it is not an image file property, control transfers back to the get next property operation .","If, on the other hand, the selected property is an image file property, control transfers to the determining operation  wherein it is determined whether the transparent indicator is set to true for the class, part, or state associated with the selected property. If the transparent indicator is not set to true, control transfers to determining operation  wherein is determined whether the alpha channel indicator is set to true for the class, part, or state associated with the selected property. If the alpha channel indicator is not set to true, control transfers to storing operation  wherein the image is stored without custom region information, because the image has no transparent or alpha channel parts.","If, on the other hand, either the transparent indicator is true in the determining operation , or the alpha channel indicator is true in determining operation , control transfers to locating operation . In the locating operation , the borders of the transparent regions of the image are located. After the transparent regions are located, control transfers to creating operation , wherein the points and grids discussed with reference to  are created using border locations found in operation . Control then transfers to the streaming operation  wherein the point data and grid reference data are stored in binary format in the custom region data section  as shown in . After the custom region data is stored, control transfers to determining operation  wherein it is determined whether all the properties have been processed. If not, control transfers back to the get next property operation  to begin processing the next theme property of the binary file format . If all of the properties have been processed, control transfers to return operation  wherein control is transferred back to the calling function.","Referring now to , there is shown a flow control diagram illustrating one embodiment of a method of loading a newly selected theme in the system. Control begins with a receiving operation . When the user selects a new theme(e.g., Business theme), the theme manager  uses a utility API  to load the theme(e.g., Business.msstyles ) into shared theme data . Control then transfers to a parsing operation , wherein the utility API  parses text data in Business.msstyles and creates a binary version of the component and theme property data contained therein. Creation of a binary file format  involves parsing the themes.ini  text file and the class data text file  and then building the header , class index table , and class sections , , and  for each class in the class data file .","Control then transfers to a notifying operation  wherein the theme manager  sends a message to all running applications  that a new theme has been loaded into the shared theme data . In response to the notification message, themeable applications  will request a new theme handle used by the theme manager  to index into shared theme data . Subsequently, control transfers to a receiving operation  wherein the theme manager  receives a request to update the theme handle for a control. The request typically includes one or more control class names. The request may also include an application name if the requesting control has application-specific theme properties. In response to the request, control transfers to a determining operation  wherein the theme manager  performs a string comparison between the requesting class (and optional application) name and the class name strings of class index .","As was discussed previously, the class index  contains entries for each class defined in the class data file . Each of these entries contains a single class name; some of them also contain an optional application name. After the receiving operation , control transfers to the determining operation  wherein, if the requesting control has passed in a non-NULL application name, the entries of class index  having an application name matching the passed in application name are searched first. If the class name of one of application-specific entries matches one of the class names passed in by the control (in the list of class names), a match is found and control transfers to a returning operation .","If, in the determining operation , no match is found by searching the matching application name entries, or if the calling control passed a NULL application name, then control transfers to a determining operation  wherein the entries of the class index  with a NULL application name are searched. If the class name of one of these entries matches one of the class names passed in by the control (in the list of class names), a match is found and control transfers to the returning operation . In the returning operation , a non-null theme handle associated with the class entry is returned to the requesting control.","If, in the determining operation , no control class name is found for the requested control, operation transfers to a returning operation  wherein theme manager  returns a null to the requesting control. A null indicates that no theme information was found for the specified application and list of class control names in the shared theme data .","After a theme handle is obtained, components are rendered by calling the drawing APIs  of theme manager  as discussed earlier. A component that requires rendering passes its handle, part, and state to the theme manager . The theme manager  uses the theme handle to get the associated class object which locates the correct drawing object or text object, as previously described.","For individual property retrieval API requests from the control, the theme manager  translates the theme handle into a class object. From the class object, a pointer to the associated class section in the binary theme data is obtained. Then, the hierarchal property section is searched for the property as follows: The theme manager searches the state property section  and returns property data defined for the component, part, and state if it is found. If state properties are not found, part property data  is searched for property data defined for the component and part. If part property data is defined it is returned. If part property data is not defined, there is a jump to class data section . Theme manager  searches class data section for theme property data specific to the requesting component for the application. If the desired data is found it is returned. If not theme manager jumps to the global section  where globally generic property data is identified and returned.","While the invention has been particularly shown and described with reference to preferred embodiments thereof, it will be understood by those skilled in the art that various other changes in the form and details may be made therein without departing form the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9(","i":["a","d"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
