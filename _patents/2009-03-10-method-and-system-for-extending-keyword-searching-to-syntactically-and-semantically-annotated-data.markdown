---
title: Method and system for extending keyword searching to syntactically and semantically annotated data
abstract: Methods and systems for extending keyword searching techniques to syntactically and semantically annotated data are provided. Example embodiments provide a Syntactic Query Engine (“SQE”) that parses, indexes, and stores a data set as an enhanced document index with document terms as well as information pertaining to the grammatical roles of the terms and ontological and other semantic information. In one embodiment, the enhanced document index is a form of term-clause index, that indexes terms and syntactic and semantic annotations at the clause level. The enhanced document index permits the use of a traditional keyword search engine to process relationship queries as well as to process standard document level keyword searches. In one embodiment, the SQE comprises a Query Processor, a Data Set Preprocessor, a Keyword Search Engine, a Data Set Indexer, an Enhanced Natural Language Parser (“ENLP”), a data set repository, and, in some embodiments, a user interface or an application programming interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08131540&OS=08131540&RS=08131540
owner: Evri, Inc.
number: 08131540
owner_city: Seattle
owner_country: US
publication_date: 20090310
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention was made with government support under Contract No. DAAH01-00-C-R168, awarded by Defense Advanced Research Project Agency and Contract No. W74Z8H-04-P-0104, awarded by the Office of the Secretary of Defense, U.S. Army. The government has or may have certain rights in this invention.","1. Field of the Invention","The present invention relates to a method and system for searching for information in a data set, and, in particular, to enhanced methods and systems for syntactically indexing and performing syntactic searching of data sets using relationship queries to achieve greater search result accuracy.","2. Background","Often times it is desirable to search large sets of data, such as collections of millions of documents, only some of which may pertain to the information being sought. In such instances it is difficult to either identify a subset of data to search or to search all data yet return only meaningful results. The techniques that have been traditionally applied to support searching large sets of data have fallen short of expectations, because they have not been able to achieve a high degree of accuracy of search results due to inherent limitations.","One common technique, implemented by traditional keyword search engines, matches words expected to found in a set of documents through pattern matching techniques. Thus, the more that is known in advance about the documents including their content, format, layout, etc., the better the search terms that can be provided to elicit a more accurate result. Data is searched and results are generated based on matching one or more words or terms that are designated as a query. Results such as documents are returned when they contain a word or term that matches all or a portion of one or more keywords that were submitted to the search engine as the query. Some keyword search engines additionally support the use of modifiers, operators, or a control language that specifies how the keywords should be combined when performing a search. For example, a query might specify a date filter to be used to filter the returned results. In many traditional keyword search engines, the results are returned ordered, based on the number of matches found within the data. For example, a keyword search against Internet websites typically returns a list of sites that contain one or more of the submitted keywords, with the sites with the most matches appearing at the top of the list. Accuracy of search results in these systems is thus presumed to be associated with frequency of occurrence.","One drawback to traditional keyword search engines is that they do not return data that fails to match the submitted keywords, even though the data may be relevant. For example, if a user is searching for information on what products a particular country imports, data that refers to the country as a \u201ccustomer\u201d instead of using the term \u201cimport\u201d would be missed if the submitted query specifies \u201cimport\u201d as one of the keywords, but doesn't specify the term \u201ccustomer.\u201d For example, a sentence such as \u201cArgentina has been the main customer for Bolivia's natural gas\u201d would be missed, because no forms of the word \u201cimport\u201d are present in the sentence. Ideally, a user would be able to submit a query and receive back a set of results that were accurate based on the meaning of the query\u2014not just on the specific keywords used in submitting in the query.","Natural language parsing provides technology that attempts to understand and identify the syntactical structure of a language. Natural language parsers (\u201cNLPs\u201d) have been used to identify the parts of speech of each term in a submitted sentence to support the use of sentences as natural language queries against data. However, systems that have used NLPs to parse and process queries against data, even when the data is highly structured, suffer from severe performance problems and extensive storage requirements.","Natural language parsing techniques have also been applied to extracting and indexing information from large corpora of documents. By their nature, such systems are incredibly inefficient in that they require excessive storage and intensive computer processing power. The ultimate challenge with such systems has been to find solutions to reduce these inefficiencies in order to create viable consumer products. Several systems have taken an approach to reducing inefficiencies by subsetting the amount of information that is extracted and subsequently retained as structured data (that is only extracting a portion of the available information). For example, NLPs have been used with Information Extraction engines that extract particular information from documents that follow predetermined grammar rules or when a predefined term or rule is recognized, hoping to capture and provide a structured view of potentially relevant information for the kind of searches that are expected on that particular corpus. Such systems typically identify text sentences in a document that follow a particular part-of-speech pattern or other patterns inherent in the document domain, such as \u201ctrigger\u201d terms that are expected to appear when particular types of events are present. The trigger terms serve as \u201ctriggers\u201d for detecting such events. Other systems may use other formulations for specified patterns to be recognized in the data set, such as predefined sets of events or other types of descriptions of events or relationships based upon predefined rules, templates, etc. that identify the information to be extracted. However, these techniques may fall short of being able to produce meaningful results when the documents do not follow the specified patterns or when the rules or templates are difficult to generate. The probability of a sentence falling into a class of predefined sentence templates or the probability of a phrase occurring literally is sometimes too low to produce the desired level of recall. Failure to account for semantic and syntactic variations across a data set, especially heterogeneous data sets, has led to inconsistent results in some situations.","Embodiments of the present invention provide enhanced methods and systems for syntactically indexing and searching data sets to achieve more accurate search results with greater flexibility and efficiency than previously available. Techniques of the present invention provide enhanced indexing techniques that extend the use of traditional keyword searching techniques to relationship and event searching of data sets. In summary, the syntactic and\/or semantic information that is gleaned from an enhanced natural language parsing process is stored in an enhanced document index, for example, a term-clause matrix, that is amenable to processing by the pattern (string) matching capabilities of keyword search engines. Traditional keyword search engines, including existing or even off-the-shelf search engines, can be utilized to discover information by pattern (or string) matching the terms of a relationship query, which are associated with syntactic and semantic information, against the syntactically and\/or semantically annotated terms of sentence clauses (of documents) that are stored in the enhanced document index. In this manner, the relationship information of an entire corpus can be searched using a keyword search engine without needing to limit a priori the types or number of relationships that are stored.","Example embodiments of the present invention provide an enhanced Syntactic Query Engine (\u201cSQE\u201d) that parses, indexes, and stores a data set, as well as performs syntactic searching in response to queries subsequently submitted against the data set. In one embodiment, the SQE includes, among other components, a data set repository and an Enhanced Natural Language Parser (\u201cENLP\u201d). The ENLP parses each object in the data set and transforms it into a canonical form that can be searched efficiently using techniques of the present invention. To perform this transformation, the ENLP determines the syntactic structure of the data by parsing (or decomposing) each data object into syntactic units, determines the grammatical roles and relationships of the syntactic units, associates recognized entity types and\/or ontology paths if configured to do so, and represents these relationships in a normalized form. The normalized data are then stored and\/or indexed as appropriate in an enhanced document index.","In one aspect, a corpus of documents is prepared for electronic searching by parsing each sentence into syntactic elements, normalizing the parsed structure to a plurality of tagged terms, each of which indicate an association between the term and a type of tag, and then transforming each sentence into a data structure that treats the tagged terms as additional terms of the sentence to be searched by a keyword search engine. In some embodiments, the tags include a grammatical role tag, a part-of-speech tag, an entity tag, an ontology path specification, or an action attribute. Other tags that indicate syntactic and semantic annotations are also supported. In some embodiments, linguistic normalization is performed to transform the sentence.","In another aspect, the SQE supports a syntax and a grammar for specifying relationship searches that can be carried out using keyword search engines. In one embodiment, the syntax supports a base component that specifies a syntactic search, a prepositional constraint component, a keyword (e.g., a document level keyword) constraint component, and a meta-data constraint component. One or more of the components may be optional. In another embodiment, the components are combined using directional operators that identify which query term has a desired grammatical role.","In yet another aspect, the SQE receives a query that specifies a relationship query using a term, tag type, or tag value. The SQE transforms the query into a set of Boolean expressions that are executed by a keyword search engine against the data structure that has been enhanced to include syntactic and\/or semantic annotations. Indicators to matching objects, such as clause, sentences, or documents are returned. In one embodiment, the data structure comprises a term-clause index, a sentence index, and a document index.","In another aspect, the SQE performs corpus ingestion and executes queries using parallel processing. According to one embodiment, each query is performed in parallel on a plurality of partition indexes, which each include one or more portions of the entire enhanced document index.","It is often desirable to search large sets of unstructured data, such as collections of millions of documents, only some of which may pertain to the information being sought. Traditional search engines approach such data mining typically by offering interactive searches that match the data to one or more keywords (terms) using classical pattern matching or string matching techniques. At the other extreme, information extraction engines typically approach the unstructured data mining problem by extracting subsets of the data, based upon formulations of predefined rules, and then converting the extracted data into structured data that can be more easily searched. Typically, the extracted structured data is stored in a relational database management system and accessed by database languages and tools. Other techniques, such as those offered by Insightful Corporation's InFact\u00ae products, offer greater accuracy and truer information discovery tools, because they employ generalized syntactic indexing with the ability to interactively search for relationships and events in the data, including latent relationships, across the entire data set and not just upon predetermined extracted data that follows particular syntactic patterns. InFact\u00ae's syntactic indexing and relationship searching uses natural language parsing techniques to grammatically analyze sentences to attempt to understand the meaning of sentences and then applies queries in a manner that takes into account the grammatical information to locate relationships in the data that correspond to the query. Some of these embodiments support a natural language query interface, which parses natural language queries in much the same manner as the underlying data, in addition to a streamlined relationship and event searching interface that focuses on retrieving information associated with particular grammatical roles. Other interfaces for relationship and event searching can be generated using an application programming interface (\u201cAPI\u201d). Insightful's syntactic searching techniques are described in detail in U.S. Provisional Application Nos. 60\/312,385 and 60\/620,550, and U.S. application Ser. Nos. 10\/007,299, and 10\/371,399. The techniques described in these patent applications have typically employed the use of complex data bases with a proprietary search technology for performing relationship and event searching.","Embodiments of the present invention provide enhanced methods and systems for syntactically indexing and searching data sets to achieve more accurate search results with greater flexibility and efficiency than previously available. Techniques of the present invention provide enhanced indexing techniques that extend the use of traditional keyword search engines to relationship and event searching of data sets. In summary, the syntactic and semantic information that is gleaned from an enhanced natural language parsing process is stored in an enhanced document index, for example, a form of a term-clause matrix, that is amenable to processing by the more efficient pattern (string) matching capabilities of keyword search engines. Thus, traditional keyword search engines, including existing or even off-the-shelf search engines, can be utilized to discover information by pattern (or string) matching the terms of a relationship query, which are inherently associated with syntactic and semantic information, against the syntactically and semantically annotated terms of sentence clauses (of documents) stored in the enhanced document index. As another benefit, the additional capabilities of such search engines, such as the availability of Boolean operations, and other filtering tools, are automatically extended to relationship and event searching.","Relationship and event searching, also described as \u201csyntactic searching\u201d in U.S. Application Nos. 60\/312,385, 10\/007,299, 10\/371,399, and 60\/620,550, supports the ability to search a corpus of documents (or other objects) for places, people, or things as they relate to other places, people, or things, for example, through actions or events. Such relationships can be inferred or derived from the corpus based upon one or more \u201croles\u201d that each term occupies in a clause, sentence, paragraph, document, or corpus. These roles may comprise grammatical roles, such as \u201csubject,\u201d \u201cobject,\u201d \u201cmodifier,\u201d or \u201cverb;\u201d or, these roles may comprise other types of syntactic or semantic information such as an entity type of \u201clocation,\u201d \u201cdate,\u201d \u201corganization,\u201d or \u201cperson,\u201d etc. The role of a specified term or phrase (e.g., subject, object, verb, place, person, thing, action, or event, etc.) is used as an approximation of the meaning and significance of that term in the context of the sentence (or clause). In this way, a relationship or syntactic search engine attempts to \u201cunderstand\u201d the sentence when a query is applied to the corpus by determining whether the terms in sentences of the corpus are associated with the roles specified in the corresponding query. For example, if a user of the search engine desires to determine all events in which \u201cHillary Clinton\u201d participated in as a speaker, then the user might specify a relationship query that instructs a search engine to locate all sentences\/documents in which \u201cHillary Clinton\u201d is a source entity and \u201cspeak\u201d is an action. In response, the syntactic search engine will determine and return indicators to all sentences\/clauses in which \u201cHillary Clinton\u201d has the role of a subject and with some form of the word \u201cspeak\u201d (e.g., speaking, spoke) or a similar word in the role of a verb.","For example,  shows a relationship query and the results returned by an example embodiment of the InFact\u00ae 2.5 search engine. In the InFact\u00ae 2.5 product, a user of the search engine can specify a search for a known \u201csource\u201d or \u201ctarget\u201d entity (or both) looking for actions or events that involve that entity. The user can also specify a second entity and look for actions or events that involve both the first and second entity. The user can specify a particular action or may specify a type of action or any action. An entity specified as a source entity typically refers to the corresponding term's role as a subject (or subject-related modifier) of a clause or sentence, whereas an entity specified as a target typically refers to the corresponding term's role as an object (or object-related modifier) of a clause or sentence. An action or event typically refers to a term's role as a verb, related verb, or verb-related modifier. Moreover, instead of a specific entity, the user can specify an entity type, which refers to a tag such as an item in a classification scheme such as a taxonomy. A user can also specify a known action or action type and look for one or more entities, or entity types that are related through the specified action or action type. Many other types and combinations of relationship searches are possible and supported as described in the above-mentioned co-pending patent applications.","In the example user interface shown in , a value for the first known entity is specified in entity field , a value for a known action is specified in action field , and a value for the type of the second entity is specified in entity type field . The source field  and target field  indicate whether the first known entity is to be a source of the action or a recipient (target) of the action. The particular query displayed instructs the search engine to look for sentence clauses that describe any person that drives a jeep when the Find Relationships button  is pressed. The results are returned in result field , which is shown sorted by similarity to the query.","Example embodiments of the present invention provide an enhanced Syntactic Query Engine (\u201cSQE\u201d) that parses, indexes, and stores a data set, as well as performs syntactic searching in response to queries subsequently submitted against the data set. In one embodiment, the SQE includes, among other components, a data set repository and an Enhanced Natural Language Parser (\u201cENLP\u201d). The ENLP parses each object in the data set (typically a document) and transforms it into a canonical form that can be searched efficiently using techniques of the present invention. To perform this transformation, the ENLP determines the syntactic structure of the data by parsing (or decomposing) each data object into syntactic units, determines the grammatical roles and relationships of the syntactic units, associates recognized entity types if configured to do so, and represents these relationships in a normalized form. The normalized data are then stored and\/or indexed as appropriate.","In one set of example embodiments, which were described in U.S. Application Nos. 60\/312,385, 60\/620,550 10\/007,299, and 10\/371,399, normalized data structures are generated by an enhanced natural language parser and are indexed and stored as relational data base tables. The SQE stores the grammatical relationships that exist between the syntactic units and uses a set of heuristics to determine which additional relationships to encode in the normalized data structure in order to yield greater accuracy in results subsequently returned in response to queries. For example, the SQE may generate relationship representations in the normalized data structure that correspond to more \u201cstandard\u201d ways to relate terms, such as the relationship represented by the tuple (subject, verb, object), but may also generate relationships that treat terms with corresponding certain grammatical roles in a non-standard fashion, such as generating a relationship representation that treats a term that is a modifier of the subject as the subject of the sentence itself. This allows the SQE to search for a user specified entity (as a subject) even in sentences that contain the specified entity as a modifier instead of as the subject of the sentence. For example, the clause:\n\n","In the example embodiments of the SQE that are described herein, the normalized data, including the grammatical role and other tag information that can be used to discover relationships, are integrated into enhanced versions of document indexes that are typically used by traditional keyword search engines to index the terms of each document in a corpus. A traditional keyword search engine can then search the enhanced indexing information that is stored in these document indexes for matching relationships in the same way the search engine searches for keywords. That is, the search engine looks for pattern\/string matches to terms associated with the desired tag information as specified (explicitly or implicitly) in a query. In one such example system, the SQE stores the relationship information that is extracted during the parsing and data object transformation process (the normalized data) in an annotated \u201cterm-clause matrix,\u201d which stores the terms of each clause along with \u201ctagged terms,\u201d which include the syntactic and semantic information that embodies relationship information. Other example embodiments may provide different levels of organizing the enhanced indexing information, such as an annotated \u201cterm-sentence matrix\u201d or an annotated \u201cterm-document matrix.\u201d One skilled in the art will recognize that other variations of storage organization are possible, including that each matrix may be comprised of a plurality of other data structures or matrices.",{"@attributes":{"id":"p-0056","num":"0060"},"figref":["FIG. 2","FIG. 2"],"b":["201","202","206","203","204","205"]},"For illustrative purposes,  shows a partial term-clause index that corresponds to the text of a given Document D that includes:\n\n",{"@attributes":{"id":"p-0058","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201c(ontology root node)\/ENTITY\/LOCATION\/COUNTRY\/Soviet"]},{"entry":[{},"Union_obj\u201d 207 and"]},{"entry":[{},"\u201c(ontology root node)\/ENTITY\/LOCATION\/COUNTRY\/Soviet"]},{"entry":[{},"Union_prep\u201d 208"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Several additional aspects are also notable with respect to the conceptual term-clause index illustrated in . The index illustrates the use of custom specified portions of an ontology. In this case, in order to add verb sense information for a set of verbs (i.e., group a set of verbs together), a \u201cVERB\u201d node that indicates different types of verb sense information has been added to the ontology. Additional ontology information could be configured by a system administrator, or, alternatively, a user interface for dynamically modifying the ontology could be provided. In the particular portion of the ontology shown, two verb senses \u201cVERB_CHANGE\u201d and \u201cVERB_STATIVE\u201d are present. When the SQE ingests a verb that has not been categorized by the ontology, the verb is simply added to the index without a semantic annotation, such as the verb \u201cally,\u201d which has been indexed as \u201cally_verb. The same is true for other terms that correspond to other parts of speech that have not been classified (yet) by the ontology. For example, the nouns \u201crelationship,\u201d \u201cstrain\u201d and \u201cexpansionism\u201d have been indexed with syntactic annotations for their respective grammatical roles, but do not have any associated semantic (ontology path) annotations. One skilled in the art will recognize that a variety of combinations could be represented in the term-clause index. Also note that the concepts of wildcard interpretation can be implemented a variety of ways, including explicitly putting \u201cgeneric\u201d nodes that correspond to particular types of wildcards (e.g., entity wildcards, physical_object wildcards, verb wildcards, etc.) depending upon the nodes in the ontology.","The integration of the enhanced indexing information into traditional search engine type document indexes (for example, an inverted index) is what supports the use a standard keyword search techniques to find a new type of document information\u2014that is, relationship information\u2014easily and quickly. An end user, such as a researcher, can pose simple Boolean style queries to the SQE yielding results that are based upon an approximation of the meaning of the indexed data objects. Because traditional search engines do not pay attention to the actual contents of the indexed information (they just perform string matching or pattern matching operations without regard to the meaning of the content), the SQE can store all kinds of relationship information in the indexed information and use a keyword search engine to quickly retrieve it.","The SQE processes each query by translating or transforming the query into component keyword searches that can be performed against the indexed data set using, for example, an \u201coff-the-shelf\u201d or existing keyword search engine. These searches are referred to herein for ease of description as keyword searches, keyword-style searches, or pattern matching or string matching searches, to emphasize their ability to match relationship information the same way search terms can be string- or pattern-matched against a data set using a keyword search engine. The SQE then combines the results from each keyword-style search into a cohesive whole that is presented to the user.","For example, suppose a researcher is attempting to discover something about China's relationships. In particular, suppose that the researcher would like to know China's attitude toward other countries. The researcher accordingly enters a relationship query to the SQE, for example,\n\n","In contrast to the term-clause index, the document index of a traditional keyword search engine system simply stores each term that is present in the document, along with an indication of the number of times the term appears in each document.  is an example block diagram that conceptually represents a traditional term-document index. The term document index  includes rows indexed by the terms  of the document. Each column, for example columns -, indicates the number of times the indexed term (in each row) appears in the document. In order to pose a query to find out the same information against this document index, the researcher needs to be much smarter about the content of the documents being searched, or, alternatively, willing to end up with a lot of potentially random information to search through. For example, the researcher could search for documents that contain \u201cChina\u201d or documents that contain \u201cChina\u201d and a list of alternative countries to look for. In any case, because much of the information concerning China's role in each document is lost when stored in this type of traditional document index, the results provided would tend to be less informative.",{"@attributes":{"id":"p-0064","num":"0072"},"figref":["FIG. 4","FIG. 4"],"b":["402","404","401","404","403","401","401","404","403","401"]},{"@attributes":{"id":"p-0065","num":"0073"},"figref":"FIG. 5","b":["501","505","506","509"]},"Specifically, in step , the SQE receives a data set, for example, a set of documents. The documents may be received electronically, scanned in, or communicated by any reasonable means. In step , the SQE preprocesses the data set to ensure a consistent data format. In step , the SQE parses the data set, identifying entity type tags and the syntax and grammatical roles of terms within the data set as appropriate to the configured parsing level. For the purpose of extending keyword searching to syntactically and semantically annotated data, parsing sufficient to determine at least the subject, object, and verb of each clause is desirable to perform syntactic searches in relationship queries. However, one skilled in the art will recognize that subsets of the capabilities of the SQE could be provided in trade for shorter corpus ingestion times if full syntactic searching is not desired. For example, as described in U.S. Patent Publication No. 2003\/0233224 (U.S. patent application Ser. No. 10\/371,399), the parsing level may be configured using a range of parsing levels, from \u201cdeep\u201d parsing to \u201cshallow\u201d parsing. Deep parsing decomposes a data object into syntactic and grammatical units using sophisticated syntactic and grammatical roles and heuristics. Shallow parsing decomposes a data object to recognize \u201cattributes\u201d of a portion or all of a data object (e.g., a sentence, clause, etc), such as entity types specified by a default or custom ontology associated with the corpus or the SQE. In step , the SQE transforms the each parsed clause (or sentence) into normalized data by applying various linguistic normalizations and transformations to map complex linguistic constructs into equivalent structures. Linguistic normalizations include lexical normalizations (e.g., synonyms), syntactic normalizations (e.g., verbalization), and semantic normalizations (e.g., reducing different sentence styles to a standard form). These heuristics and rules are applied when ingesting documents and are important to determining how well the stored sentences eventually will be \u201cunderstood\u201d by the system.","For example, the SQE may apply one or more of transformational grammar rules, lexical normalizations (e.g., normalizing synonyms, acronyms, hypernyms, and hyponyms to canonical or standard terms), semantic modeling of actions (e.g., verb similarity), anaphora resolution (e.g., noun and pronoun coreferencing resolution) and multivariate statistical modeling of semantic attributes. Multivariate statistical modeling of semantic attributes refers to applying the techniques used to determine similar verbs to other parts of speech, such as nouns and adjectives. These techniques as applied to verbs include such determinations as the frequency weight of the primary sense of the verb; the set of troponyms associated to this verb sense (other ways to perform this verb, e.g., \u201csweep,\u201d \u201ccarry,\u201d and \u201cprevail\u201d are all troponyms of the verb \u201cwin\u201d because they express ways to win); the set of hypernyms associated to this verb sense (more generic classes of which this verb is a part, e.g., \u201cwin\u201d is one way to \u201cgain,\u201d \u201cget,\u201d or \u201cacquire\u201d); and the set of entailments associated with this verb sense (other verbs that must be done before this verb sense can be done, e.g., \u201cwinning\u201d entails \u201ccompeting,\u201d \u201ctrying,\u201d \u201cattempting,\u201d \u201ccontending,\u201d etc.). The ability to transform a term to alternatives so that similar actions and entities will also be searched for provides one important way to increase the ability of the SQE to \u201cunderstand\u201d a search query and retrieve more relevant results. Many transformational grammar rules also can be incorporated into the SQE. The transformational grammar rules may take many forms, including, for example, noun, pronoun, adjective, and adverb verbalization transformations. Verbalization rules convert the designated part of speech to a verb. For example, the clause \u201cX is a producer of Tungsten\u201d can be simplified to the clause \u201cX produces Tungsten.\u201d Another example transformation rule is to simplify a clause by changing it from passive to active voice. For example, the clause \u201cthe chart was created by Y\u201d can be transformed to the clause \u201cY created the chart.\u201d","In step , the SQE stores the parsed and transformed sentences in a data set repository. As described above, when the SQE is used with a keyword search engine, the normalized data is stored in (used to populate) an enhanced document index such as the term-clause matrix shown in . After storing the data set, the SQE can process relationship queries against the data set. In step , the SQE receives a relationship query, for example, through a user interface such as that shown in  below. Alternatively, one skilled in the art will recognize that the query may be transmitted through a function call, batch process, or translated from some other type of interface. In step , if necessary (depending upon the interface) the SQE preprocesses the received relation query and transforms it into the relationship query language understood by the system. For example, if natural language queries are supported, then the natural language query is parsed into syntactic units with grammatical roles, and the relevant entity and action terms are transformed into the query language formulations understood by the SQE. In step , the SQE executes the received query against the data set stored in the data set repository. The SQE transforms the query internally into sub-queries as appropriate to the organization of the data in the indexes and executes a traditional keyword search engine (or its own version of keyword style searching) to process the query. In step , the SQE returns the results of the relationship query, for example, by displaying them through a user interface such as the summary information shown in .","One skilled in the art will recognize that, although the techniques are described primarily with reference to text-based languages and collections of documents, similar techniques may be applied to any collection of terms, phrases, units, images, or other objects that can be represented in syntactical units and that follow a grammar that defines and assigns roles to the syntactical units, even if the data object may not traditionally be thought of in that fashion. Examples include written or spoken languages, for example, English or French, computer programming languages, graphical images, bitmaps, music, video data, and audio data. Sentences that comprise multiple words are only one example of a phrase or collection of terms that can be analyzed, indexed, and searched using the techniques described herein. One skilled in the art will recognize how to modify the structures and program flow exemplified herein to account for differences in types of data being indexed and retrieved. Essentially, the concepts and techniques described are applicable to any environment where the keyword style searching is contemplated.","Also, although certain terms are used primarily herein, one skilled in the art will recognize that other terms could be used interchangeably to yield equivalent embodiments and examples. In addition, terms may have alternate spellings which may or may not be explicitly mentioned, and one skilled in the art will recognize that all such variations of terms are intended to be included. Also, when referring to various data, aspects, or elements in the alternative, the term \u201cor\u201d is used in its plain English sense, unless otherwise specified, to mean one or more of the listed alternatives. For example, the terms \u201cmatrix\u201d and \u201cindex\u201d are used interchangeably and are not meant to imply a particular storage implementation. Also, a document may be a single term, clause, sentence, or paragraph or a collection of one or more such objects.","For example, the term \u201cquery\u201d is used herein to include any form of specifying a desired relationship query, including a specialized syntax for entering query information, a menu driven interface, a graphical interface, a natural language query, batch query processing, or any other input (including API function calls) that can be transformed into a Boolean expression of terms and annotated terms. Annotated terms are terms associated with syntactic or semantic tag information, and are equivalently referred to as \u201ctagged terms.\u201d Semantic tags include, for example, indicators to a particular node or path in an ontology or other classification hierarchy. \u201cEntity tags\u201d are examples of one type of semantic tag that points, for example, to a type of ENTITY node in an ontology. In addition, although the description is oriented towards parsing and maintaining information at the clause level, it is to be understood that the SQE is able to parse and maintain information in larger units, such as sentences, paragraphs, sections, chapters, documents, etc., and the routines and data structures are modified accordingly. Thus, for ease of description, the techniques are described as they are applied to a term-clause matrix. One skilled in the art will recognize that these techniques can be equivalently applied to a term-sentence matrix and a term-document matrix.","In the following description, numerous specific details are set forth, such as data formats and code sequences, etc., in order to provide a thorough understanding of the techniques of the methods and systems of the present invention. One skilled in the art will recognize, however, that the present invention also can be practiced without some of the specific details described herein, or with other specific details, such as changes with respect to the ordering of the code flow.","The Syntactic Query Engine is useful in a multitude of scenarios that require indexing, storage, and\/or searching of, especially large, data sets, because it yields results to queries that are more contextually accurate than other search engines. An extensive relationship query language (\u201cRQL\u201d) is supported by the SQE. The query language is designed to be used with any SQE implementation that is capable of retrieving relationship information from an indexed data set, regardless of whether the SQE uses a relational database implementation with a proprietary search engine or an enhanced document index that supports a keyword search engine. However, some of the operators may be more easily implemented in one environment versus the other, or may not be available in certain situations. One skilled in the art will recognize that variants of the query language are easily incorporated and that other symbols can be equivalently substituted for operators.","In general, the syntax for a relationship query specifies \u201centities\u201d and \u201cactions\u201d that are linked via a series of \u201coperators\u201d with one or more constraints such as document level filters.\n\n","The general format for a relationship query comprises four components:\n\n","In addition to the basic syntactic search component of the query, there are three optional components that can be added to filter results (constrain the search):\n\n","Note that there are two expressions designated in the document filter above: \u201cforeign service\u201d and \u201cdiplomat.\u201d When a document contains a keyword in adjective form, e.g., \u201cdiplomatic,\u201d the document is included in the search results responsive to a query that designated the noun form. The SQE may be configured to automatically extract the stem of the word and search for other forms. Document level queries are also allowed by specifying a keyword or phrase (even without a syntactic search component). For example:\n\n","Filter clauses (i.e., constraint components) can also be entered in a more abbreviated form, in which the terms \u201cPREP CONTAINS\u201d, \u201cDOCUMENT CONTAINS\u201d, and \u201cMETADATA CONTAINS\u201d are replaced by a \u2018^\u2019, \u2018;\u2019 and a \u2018#\u2019 character respectively, as in:\n\n","RQL formulated queries can also be embedded within a scripting language to provide an ability to execute batch relationship queries, functions having multiple queries, and control flow statements. For example, it may be desirable to encode a query to be executed at certain times each day against a data set that is continually updated and incrementally ingested. One skilled in the art will recognize that many scripting languages could be defined to achieve control flow of multiple relationship queries, and that the scripting language could include conditional statements. Relationship queries formulated using RQL are submitted to the SQE for execution from a variety of interfaces. For example, a web-based interface, similar to that provided by default with the InFact\u00ae products, can be used to submit relationship queries. In addition, relationship queries can be submitted using a natural language interface to the SQE, which parses the natural language query into syntactic units that can be translated into an RQL formulated query and then executed. Alternatively, the SQE supports an API that allows the development of other code, such as other user interfaces, that can execute relationship queries by submitting RQL formulated query strings to the SQE.  described below exemplify one such interface that provides a more graphical use of relationship queries.",{"@attributes":{"id":"p-0080","num":"0127"},"figref":"FIGS. 6A-6G","b":["7","7","8","8"]},{"@attributes":{"id":"p-0081","num":"0128"},"figref":["FIGS. 6A-6G","FIG. 6A","FIGS. 8A-8F","FIG. 9","FIG. 10"],"b":["6","03","6","01","6","02","6","08","604","6","05","6","06"]},{"@attributes":{"id":"p-0082","num":"0129"},"figref":"FIG. 6B","b":["6","01","6","00","6","02","6","02"]},{"@attributes":{"id":"p-0083","num":"0130"},"figref":"FIG. 6C","b":["6","01","6","00","6","02"]},{"@attributes":{"id":"p-0084","num":"0131"},"figref":"FIG. 6D","b":["6","01","6","00","6","02"],"sup":["rd ","rd "]},{"@attributes":{"id":"p-0085","num":"0132"},"figref":"FIG. 6E","b":["6","01","6","00","6","02","6","03"]},{"@attributes":{"id":"p-0086","num":"0133"},"figref":"FIG. 6F","b":["6","01","6","00","6","02","6","03"]},"The ontology path specified in the query, \u201c[organization\/name]\u201d is defined by an ontology associated with the system. Ontologies are typically associated with a corpus at system configuration time, although one skilled in the art will recognize that they can be dynamically changed and the portions of the corpus that are affected by the change, re-ingested. An ontology can be a default ontology associated with the SQE or a custom ontology generated for a specific corpus. Ontology paths are enclosed in brackets, as in [person] or [country]. If a bracketed term is found in a relationship query, the SQE searches the ontology[ies] for all paths matching the term. If there are multiple matches, all matches are included in the search and results are combined. For example, in a search query containing the type [person], the SQE will substitute with [IF\/Entity\/Person] to indicate use of the default ontology provided with the system. If another path exists in a custom ontology such as \u201cMyOntology\/People\/Person,\u201d this path is also included in the query and the results are combined. Ontology paths can be browsed through an interface provided under the \u201cCorpus\u201d tab, as described further below with respect to .",{"@attributes":{"id":"p-0088","num":"0135"},"figref":"FIG. 6G","b":["6","00"]},{"@attributes":{"id":"p-0089","num":"0136"},"figref":["FIGS. 7A-7F","FIG. 7A","FIG. 7B","FIG. 7B","FIG. 7C","FIG. 7D","FIG. 7C","FIG. 7E","FIG. 7F"],"b":["7","01","7","02","7","03","7","04","7","01","7","01"]},{"@attributes":{"id":"p-0090","num":"0137"},"figref":["FIGS. 8A-8F","FIG. 8A"],"b":["8","01","8","02","8","03","8","04"]},{"@attributes":{"id":"p-0091","num":"0138"},"figref":["FIGS. 8B-8F","FIG. 8B","FIG. 8C","FIG. 8D","FIGS. 8E and 8F"],"b":["8","02","8","01","8","03","8","04","8","01","8","02","8","01","8","02"]},{"@attributes":{"id":"p-0092","num":"0139"},"figref":"FIG. 9","ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":{"@attributes":{"id":"ul0022-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":["Include negated actions: When this option is enabled, relationships matching both the positive and negative sense of a verb are displayed. If a user performed a search such as \u201cClinton>visit>Russia\u201d, the sentence \u201cDue to heath reasons Clinton did not visit Russia.\u201d would only be returned if this setting was set to true. By default Show Negated Actions is disabled, and only positive actions are displayed.","Search modifiers along with entities: This option specifies whether modifiers should be searched along with sources and\/or targets (as subjects and\/or objects). In the above example sentence \u201cBill visits beautiful, green pastures outside Seattle,\u201d if this property is set to true, then a search such as \u201cBill>visit>Seattle\u201d will return the above relationship. If this property is false, then it will not, and only the query \u201cBill>visit>pasture\u201d would still yield this result.","Display modifiers: In the sentence \u201cBill visits beautiful, green pastures outside Seattle,\u201d \u201cbeautiful, green\u201d is the prefix modifier for pastures, and \u201coutside Seattle\u201d is the postfix modifier. In a search like \u201cBill>visit>*, with this property set to true the SQE will display modifiers along with pastures in the target entity summary. If this property is set to false, only the word \u2018pastures\u2019 will be displayed as the target in the tabular display.","Enforce strict bi-directionality: When doing searches with bi-directional arrows, such as \u201c< >\u201d, the search can be interpreted in two different ways. For example, with the search query \u201cClinton< >*< >Bush\u201d, one might wish only to view results in which Bush did something to Clinton XOR Clinton did something to Bush. (XOR indicates an exclusive Boolean OR operation.) Enforcing strict bi-directionality provides this result. However, one might also wish to see instances in which Bush and Clinton both did something to some other target together. These additional results are displayed if strict bi-directionality is not enforced.","Search ontology path name as term: If a user includes an ontology path like \u201c[city]\u201d in a search query, then results with cities are returned. However, the word \u201ccity\u201d is not an instance of an item in the ontology itself, and is not associated with the ontology path. Therefore, without setting this preference, one would not see results that contain the word \u201ccity.\u201d This preference is set to true to include results with the term \u201ccity\u201d in them as well as any terms defined by the ontology path \u201ccity.\u201d","Number of relationships per page: The user can set the number of relationships to display on a single page of relationship results. The smaller this value, the faster results will be returned.","Number of documents per page: The user can set the number of documents to display on a single page of document results. The smaller this value, the faster results will be returned.","Sort scheme: This setting allows users to sort results in a given chunk or batch of results according to one of several sorting schemes, and to set the default sort scheme for all future searches. Note that an individual result set can also be sorted in the result display. If results are sorted using the drop-down selection box on the results page, the setting does not persist for subsequent searches.","Surrounding sentences to export: This option allows the user to vary how much contextual information from the document is included along with the sentences returned when the user exports a result set to HTML."]}}}},{"@attributes":{"id":"p-0093","num":"0149"},"figref":"FIG. 10","b":["1000","1010","1000","1001","1002","1003","1004","1005"]},{"@attributes":{"id":"p-0094","num":"0150"},"figref":["FIGS. 11A-11F","FIG. 11A","FIG. 11B","FIG. 11C","FIG. 11D","FIGS. 11E and 11F","FIG. 11E","FIG. 11F"],"b":["11","02","11","03","11","01","11","02","11","03","11","01"]},"An SQE as described may perform multiple functions (e.g., data set parsing, data set storage, query transformation and processing, and displaying results) and typically comprises a plurality of components.  is a conceptual block diagram of the components of an example embodiment of a Syntactic Query Engine. A Syntactic Query Engine  comprises a Relationship Query Processor , a Data Set Preprocessor , a Data Set Indexer , an Enhanced Natural Language Parser (\u201cENLP\u201d) , a data set repository , and, in some embodiments, a user interface (or an Applications Programming Interface \u201cAPI\u201d) . The Data Set Preprocessor  converts received data sets  to a format that the Enhanced Natural Language Parser  recognizes. The Enhanced Natural Language Parser (\u201cENLP\u201d) , parses the preprocessed sentences, identifying the syntax and grammatical role of each meaningful term in the sentence and the ways in which the terms are related to one another and\/or identifies designated entity and other ontology tag types and their associated values, and transforms the sentences into a canonical form\u2014a normalized data representation. The Data Set Indexer  indexes the normalized data into the enhanced document indexes and stores them in the data set repository . The Relationship Query Processor  receives relationship queries and transforms them into a format that the Keyword Search Engine  recognizes and can execute. (Recall that the Keyword Search Engine  may be an external or 3party keyword search engine that the SQE calls to execute queries.) The Keyword Search Engine  generates and executes keyword searches (as Boolean expressions of keywords) against the data set that is indexed and stored in the data set repository . The Keyword Search Engine  returns the search results through the user interface\/API  to the requester as Query Results .","In operation, the SQE  receives as input a data set  to be indexed and stored. The Data Set Preprocessor  prepares the data set for parsing by assigning a Document ID to each document that is part of the received data set (and sentence and clause IDs as appropriate), performing OCR processing on any non-textual entities that are part of the received data set, and formatting each sentence according to the ENLP format requirements. The Enhanced Natural Language Parser (\u201cENLP\u201d)  parses the data set, identifying for each sentence, a set of terms, each term's tags, including potentially part of speech and associated grammatical role tags and any associated entity tags or ontology path information, and transforms this data into normalized data. The Data Set Indexer  indexes and stores the normalized data output from the ENLP in the data set repository . The data set repository  represents whatever type of storage along with the techniques used to store the enhanced document indexes. For example, the indexes may be stored as sparse matrix data structures, flat files, etc. and reflect whatever format corresponds to the input format expected by the keyword search engine. After a data set is indexed, a Relationship Query  may be submitted to the SQE  for processing. The Relationship Query Processor  prepares the query for parsing, for example by splitting the Relationship Query  into sub-queries that are executable directly by the Keyword Search Engine . As explained above, a Relationship Query  is typically comprised of a syntactic search along with optional constraint expressions. Also, different system configuration parameters can be defined that influence and instruct the SQE to search using particular rules, for example, to include synonyms, related verbs, etc. Thus, the Relationship Query Processor  is responsible for augmenting the specified Relationship Query  in accordance with the current SQE configured parameters. To do so, the Relationship Query Processor  may access the ontology information which may be stored in Data Set Repository  or some other data repository. The Relationship Query Processor  splits up the query into a set of Boolean expression searches that are executed by the Keyword Search engine  and causes the searches to be executed. The Relationship Query Processor  then receives the result of each search from the Keyword Search Engine  and combines them as indicated in the original Relationship Query  (for example, using Boolean operators). One skilled in the art will recognize that the Relationship Query Processor  may be comprised of multiple subcomponents that each execute a portion of the work required to preprocess and execute a relationship query and combine the results for presentation. The results (in portions or as required) are sent to the User Interface\/API component  to produce the overall Query Result . The User Interface Component  may interface to a user in a manner similar to that shown in the display screens of  and A-F.",{"@attributes":{"id":"p-0097","num":"0153"},"figref":"FIG. 13","b":["1301","1302","1303","1302","1303","1302","1303","1302","1303"]},{"@attributes":{"id":"p-0098","num":"0154"},"figref":"FIG. 14","b":["1401","1403","1404","1404","1401","1402","1402","1404","1405"]},{"@attributes":{"id":"p-0099","num":"0155"},"figref":["FIG. 15","FIG. 13","FIG. 15"],"b":["1303","1501","1502","1503","1504","1508","1509","1505","1512","1513","1509","1506","1507","1503","1510","1511","1507","1514","1515","1518","1519","1520","1521"]},{"@attributes":{"id":"p-0100","num":"0156"},"figref":["FIG. 16","FIG. 15"],"b":["1601","1602","1603","1604","1605","1606"]},"Note that the normalized data shown in  supports many different types of relationship queries. For example, all of the following relationship queries will cause the SQE to return an indicator to the sentence that has been normalized to the data of  (assuming modifiers are searched):",{"@attributes":{"id":"p-0102","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"* > visits > [country] \u2003(Query for information on all visits of all"},{"entry":"countries.)"},{"entry":"president <> * \u2003\u2003\u2003(Query for anything a president does.)"},{"entry":"* > * > China \u2002\u2003\u2003\u2003(Query for any relationship with China.)"},{"entry":"(Note that the SQE returns the sentence because it searches for"},{"entry":"\u201cChina\u201d as a modifier instead of just as an object of the sentence.)"},{"entry":"* > * > [country] \u2003\u2003\u2002\u2009(Query for any relationship with any country.)"},{"entry":"France <> * <> China \u2003(Query for any relationship b\/n France & China.)"},{"entry":"(Note that the SQE returns the sentence because it searches for"},{"entry":"\u201cFrance\u201d and \u201cChina\u201d as modifiers instead of just as subjects and\/or"},{"entry":"objects of the sentence.)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"figref":"FIG. 16"},"The Syntactic Query Engine performs two functions to accomplish effective relationship query processing with syntactic searching capabilities. The first is the parsing, indexing, and storage of a data set (sometimes termed corpus ingestion). The second is the query processing, which according to the example embodiment described herein, results in the execution of keyword searches. These two functions are outlined with reference to .",{"@attributes":{"id":"p-0104","num":"0160"},"figref":["FIG. 17","FIG. 12","FIG. 17","FIG. 12","FIG. 16","FIG. 12"],"b":["1701","1702","1203","1702","1702","1704","1204","1704","1705","1207","1705"]},"In addition to indexing and storing a data set prior initially, in some embodiments, the SQE can incrementally index and store new documents, updating the relevant enhanced document indexes as necessary. In addition, in embodiments that support dynamic changes to an existing ontology, the SQE can determine a set of affected documents and \u201cre-ingest\u201d a portion of the corpus as needed. Other variations can be similarly accommodated.","After indexing and storing a data set, the SQE may perform its second function, processing relationship queries against the stored data set.  is a block diagram of query processing performed by an Syntactic Query Engine. A user  (or program through an API) submits a relationship query  to the SQE. The Query Processor  component of the SQE transforms the query into one or more keyword searches  with appropriate syntactic and semantic annotation information included and executes the keyword searches  by invoking one or more keyword search engine processes, for example, keyword search engines -. The results of each keyword search  are subsequently returned back to the invoking Query Processor , which then combines the results  as specified in the relationship query  and returns them to the user\/program.",{"@attributes":{"id":"p-0107","num":"0163"},"figref":"FIG. 19","b":["1901","1907","1901","1902","1907"]},"In step , the query is transformed to handle synonyms of any specified subjects and\/or objects. In one embodiment, synonyms are handled by searching the ontology structure for synonyms of a specified term, and, if they are present, adding keyword searches for each synonym found. In an alternative embodiment, terms having synonyms are mapped (e.g., at SQE configuration time) to a common indicator, such as a \u201cconcept identifier\u201d (concept ID). During ingestion, terms are looked up in the map to determine whether they have corresponding synonyms (hence concept IDs), and, if so, the concept IDs are stored as part of the indexing information. Upon receiving a query, a look up is performed to find a corresponding concept ID (if one exists) to a received term. The query is then transformed so that the resultant keyword searches contain the corresponding concept ID as appropriate. One skilled in the art will recognize that, using either mechanism (or any other implementation), the formatting of the invoked keyword searches needs to correspond to the way the data has been indexed.","In step , the query processor transforms the query to handle ontology path specifications or \u201ctypes\u201d if provided in the received query string. For example, a relationship query may provide a subject and\/or object list as [entity] or [person] or [location\/country], etc., which is interpreted as a type of node in an ontology hierarchy. The amount of the pathname that is specified is matched to the ontology. Thus, the entity specification \u201c[location\/country]\u201d is matched to any ontology path containing that sub-path. Keyword searches are thus specified for each of the matching ontology paths. Similarly, heuristics may be applied that include as additional keyword searches also searches for related terms, such as hypernyms and hyponyms (more generic and more specific classification terms, respectively), if not already accounted for using available synonym logic.","In step , the query processor transforms the query to handle action types (types of verbs) if specified in the relationship query. For example, a query that specifies \u201cpresident < >[communication]\u201d instructs the SQE to find all relationships that involve a president doing something by any verb that is considered to be a communication verb. Like the implementations for synonyms described above, the query processor can handle this by including additional keyword searches for each verb of that action type, or can use some kind of verb concept identifier. Again, the query processor needs to match whatever form the indexed data is stored.","In step , based upon the additional transformations from steps -, the query processor reformulates the relationship query into one or more keyword searches that can be executed by a keyword search engine. In step , the one or more keyword searches are accordingly invoked and executed. If the enhanced document index is stored as one data structure, then it is possible to execute one keyword search. Alternatively, if the indexed data is actually split between several matrices, then a keyword search is executed on each index as appropriate. For example, searches for matching \u201ckeywords\u201d as subjects (or modifiers of subjects) are executed on the subject term-clause index. In step , the results of the keyword searches are combined as expressed in the flow of control logic parsed from the relationship query, and then forwarded to an interface for presentation to the user or program that invoked the relationship query. The query processor then returns to the beginning of the loop in step .","The functions of data set processing (data object ingestion) and relationship query processing can be practiced in any number of centralized and\/or distributed configurations of client\u2014server systems. Parallel processing techniques can be applied in performing indexing and query processing to substantial increase throughput and responsiveness. Representative configurations and architectures are described below with respect to ; however, one skilled in the art will recognize that a variety of other configurations could equivalently perform the functions and capabilities identified herein.",{"@attributes":{"id":"p-0113","num":"0169"},"figref":"FIG. 20","b":["2001","2002","2003","2004","2005","2020","2006","2007","2008","2011","2012","2015","2005","2009","2010","2002"]},{"@attributes":{"id":"p-0114","num":"0170"},"figref":"FIG. 21"},"The unit of organization used to support indexing and searching is termed a \u201cpartition.\u201d Thus, an enhanced document index (labeled here as a \u201ckeyword index\u201d) comprises typically a plurality of \u201cpartition indexes,\u201d each of which stores some portion of the total keyword index. To perform a search on the entire corpus, then, it is necessary to search each of the partition indexes (with the same keyword search string) and thereafter to combine the results as if the search were performed on a single index. Note that the keyword index may be partitioned according to a variety of schemes, including, for example, a percentage of the index based upon the size of the documents indexed, documents that somehow related together by concept or other classification, schemes based upon storing portions of the index based upon a type supported by the ontology, etc. Any such scheme may be implemented by the servers and may be optimized for the application for which the SQE is being deployed.","A variety of servers and services are employed to process the ingestion and searching on the backend so as to present a unified view of the term-clause, sentence, and document indexes.  presents one such embodiment, although one skilled in the art will recognize that a variety of other organizations and components can equivalently support and provide the functions and techniques of the SQE. In , an index manager  schedules document ingestion for a collection of document  between a plurality of workers -, each responsible for indexing a portion of the corpus. The work could be divided at a variety of levels including by document, by sentence, etc., and allows the ingestion workload to be processed in parallel, thus decreasing the amount of time required to ingest a corpus. Each worker -contains an instance of the SQE data set processing components (and others if necessary), including the preprocessor and an instance of the ENLP. Upon parsing a sentence and annotating it with syntactic and semantic tags, the worker -creates a corresponding temporary keyword index -, which represents the portion of the corpus that it has processed until stored in the partition indexes -. The index manager  is responsible for distributing the temporary keyword indexes -to the partition indexes  and  to be merged into their respective keyword indexes  and . Note that the index manager  and the workers -may in some embodiments utilize an additional data base management system  to store recovery information, such as copies of documents, document metadata, sentences, parse trees and a copy of the clause tables,  although this is a convenience and not necessitated by the functions of the SQE.",{"@attributes":{"id":"p-0117","num":"0173"},"figref":["FIG. 22","FIG. 21"],"b":["2201","2202","2203","2204","2204","2202","2205","2202","2206"]},{"@attributes":{"id":"p-0118","num":"0174"},"figref":["FIG. 23","FIG. 21","FIG. 23","FIG. 12"],"b":["2104","2105","2301","2302","2311","2304","2303","2304","2303","2304","2305","2305","2308","2305","2307","2307","2309","2310","2305","2306"]},{"@attributes":{"id":"p-0119","num":"0175"},"figref":["FIG. 24","FIG. 24"],"b":["2401","2402","2402","2403","2405","2403","2410","2404","2422","2423","2405","2424","2402","2406","2407","2408","2409"]},"As mentioned, it is sometimes desirable to support the indexing of additional corpus information even when the corpus is being searched. This provides the ability to support incremental indexing of data. It is also sometimes desirable to provide fault tolerance, especially in mission critical applications.  is an example block diagram of an architecture of the partition indexes that supports incremental updates and data redundancy. The underlying organization involves maintaining several data instances of the partition index, only one of which is \u201cactive\u201d for searching at any one time and maintaining a redundant copy of the data instances that comprise the partition index. The \u201cactive\u201d partition index data instance provides the view of the data that the initiator of a query believes is current. To update a partition index, the searcher redirects the indicator of the active partition index data instance to a different data instance. In , the searcher  maintains a master partition index  and a clone partition index , which is a replica of the master partition index. Each of the partition indexes  and  in turn maintain a plurality of data instances, for example data instances - and -. In the diagram, partition index data instance  is indicated as the \u201cactive\u201d partition index data instance. While instance  is active, the searcher  can update other data instances  and  thus providing another type of parallelism. Since clone partition index  is a replica of the master partition index , the data instances - are replicas of the information and state of data instance -. One skilled in the art will recognize that there are other ways to provide incremental updating and that  illustrates one of them.","The architectures described (and others) can be used to support the indexing and searching functions of an example SQE.  is an example conceptual diagram of the transformation of a relationship search into component portions that are executed using a parallel architecture. In the example illustrated, the relationship query  is a link search, however one skilled in the art will recognize that the technique described can be applied and extended to a variety of searches including a plurality of relationship searches that are combined by a scripting language or other means of controlling flow. The query being processed:\n\n","The architectures illustrated (and others) can also support the preprocessing and data storage functions of an example SQE. As described with reference to , the Data Set Preprocessor  performs two overall functions\u2014building one or more tagged files from the received data set files and dissecting the data set into individual objects, for example, sentences. These functions are described in detail below with respect to . Although  present a particular ordering of steps and are oriented to a data set of objects comprising documents, one skilled in the art will recognize that these flow diagrams, as well as all others described herein, are examples of one embodiment. Other sequences, orderings and groupings of steps, and other steps that achieve similar functions, are equivalent to and contemplated by the methods and systems of the present invention. These include steps and ordering modifications oriented toward non-textual objects in a data set, such as audio or video objects.",{"@attributes":{"id":"p-0123","num":"0182"},"figref":"FIG. 27","b":["2701","2702","2703","2704","2705"],"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":{"@attributes":{"id":"ul0026-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":"This is a map of China.\n\nIn step , the build_file routine generates an object identifier (e.g., (a Document ID) and inserts a tag with the generated identifier. In step , the build_file routine writes the processed document to the created text file. Steps  through  are repeated for each file that is submitted as part of the data set. When there are no more files to process, the build_file routine returns.\n"}}}},{"@attributes":{"id":"p-0124","num":"0184"},"figref":"FIG. 28","b":["2801","2802","2803","2804","2805","2805"],"ul":{"@attributes":{"id":"ul0028","list-style":"none"},"li":{"@attributes":{"id":"ul0028-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0029","list-style":"none"},"li":"This table shows the Defense forces, 1996,\n\nis generated from the title of the actual table in the document. The remaining sentences shown in Table , are generated from the rows in the actual table in the document. One skilled in the art will recognize that various processes and techniques may be used to identify documents within the data set and to identify entities (e.g., tables) within each document. The use of equivalent and\/or alternative processes and markup techniques and formats, including HTML, XML, and SGML and non-tagged techniques are contemplated and may be incorporated in methods and systems of the present invention.\n"}}}},"The second function performed by the Data Set Preprocessor component of the SQE is dissecting the data set into individual objects (e.g., sentences) to be processed.  is an example flow diagram of the steps performed by the dissect_file routine of the Data Set Preprocessor component of a Syntactic Query Engine. In step , the routine extracts a sentence from the tagged text file containing the data set. In step , the dissect_file routine preprocesses the extracted sentence, preparing the sentence for parsing. The preprocessing step may comprise any functions necessary to prepare a sentence according to the requirements of the natural language parser component of the ENLP. These functions may include, for example, spell checking, removing excessive white space, removing extraneous punctuation, and\/or converting terms to lowercase, uppercase, or proper case. One skilled in the art will recognize that any preprocessing performed to put a sentence into a form that is acceptable to the natural language parser can be used with techniques of the present invention. In step , the routine sends the preprocessed sentence to the ENLP. In step , the routine receives as output from the ENLP a normalized data representation of the sentence. In step , the dissect_file routine forwards the original sentence and the normalized data representation to the Data Set Indexer for further processing. Steps - are repeated for each sentence in the file. When no more sentences remain, the dissect_file routine returns.","The Data Set Indexer (e.g., component  in ) prepares the normalized data generated from the data set (e.g., as illustrated in ) to be indexed and stored in the data set repository. One skilled in the art will recognize that the normalized data can be stored in a variety of ways and data structures, yet still achieve the abstraction of maintaining a term-clause matrix, a term-sentence matrix or a term-document matrix. Any data structure that can be understood by the target keyword search engine being used is operable with the techniques of the present invention. In one embodiment, separate indexes exist for each enhanced document (term-clause, term-sentence, and term-document) matrix. In addition, in some embodiments the term-clause index is further divided into a separate index for each grammatical role, so as to allow more efficient keyword searches. The indexes are cross referenced by an internal identifier, which can be used to decipher a document id, sentence id, or a clause id. The tuple (document id, sentence id, clause id) that uniquely identifies each clause in the document corpus. Other divisions and distributions of the data can be accommodated. Table 1 below conceptually illustrates the information that is maintained in an example term-clause index of the present invention.",{"@attributes":{"id":"p-0127","num":"0188"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Id (internal)","Indexed,","document id, sentence id, clause id"]},{"entry":[{},"stored","concatenated separated by \u2018_\u2019"]},{"entry":["subject","tokenized,","contains subjects(s), subject modifiers and"]},{"entry":[{},"indexed","entity type(s) for subjects and modifiers."]},{"entry":[{},{},"The modifiers are preferably separated"]},{"entry":[{},{},"into prefix and suffix. If subject has entity"]},{"entry":[{},{},"type, the data indexer also stores t_entity"]},{"entry":[{},{},"(just once). If any modifier has entity type,"]},{"entry":[{},{},"the data indexer also stores tm_entity (just"]},{"entry":[{},{},"once). Noun phrases that were recognized"]},{"entry":[{},{},"by NL parser are also stored with spaces"]},{"entry":[{},{},"replaced by \u2018\\.\u2019 The subject field order is:"]},{"entry":[{},{},"prefix_subject_mod subject"]},{"entry":[{},{},"suffix_subject_mod"]},{"entry":[{},{},"Entity_types"]},{"entry":[{},{},"NLP_noun_phrases."]},{"entry":["object","tokenized,","contains objects(s), object modifiers and"]},{"entry":[{},"indexed","entity type(s) for objects and modifiers"]},{"entry":[{},{},"The modifiers are preferably separated"]},{"entry":[{},{},"into prefix and suffix. If object has entity"]},{"entry":[{},{},"type, the data indexer stores t_entity (just"]},{"entry":[{},{},"once). If any modifier has entity type, the"]},{"entry":[{},{},"data indexer also stores tm_entity (just"]},{"entry":[{},{},"once). Noun phrases that were"]},{"entry":[{},{},"recognized by NL parser are also stored"]},{"entry":[{},{},"with spaces replaced by \u2018\\.\u2019 The object"]},{"entry":[{},{},"field order is:"]},{"entry":[{},{},"prefix_object_mod object"]},{"entry":[{},{},"suffix_object_mod"]},{"entry":[{},{},"Entity_types"]},{"entry":[{},{},"NLP_noun_phrases."]},{"entry":["pcomp","tokenized,","contains pcomp(s), preposition(s), pcomp"]},{"entry":[{},"indexed","modifiers and entity type(s) for pcomp,"]},{"entry":[{},{},"modifiers. The modifiers are preferably"]},{"entry":[{},{},"separated into prefix and suffix. If pcomp"]},{"entry":[{},{},"has entity type, the data indexer also store"]},{"entry":[{},{},"t_entity (just once). If any modifier has"]},{"entry":[{},{},"entity type, the data indexer also stores"]},{"entry":[{},{},"tm_entity (just once). Noun phrases that"]},{"entry":[{},{},"were recognized by NL parser are also"]},{"entry":[{},{},"stored with spaces replaced by \u2018\\.\u2019 The"]},{"entry":[{},{},"pcomp field order is:"]},{"entry":[{},{},"preposition pcomp modifiers,"]},{"entry":[{},{},"pcomp Entity_types"]},{"entry":[{},{},"NLP_noun_phrases"]},{"entry":["verb","tokenized,","contains verbs(s), verb modifiers and"]},{"entry":[{},"indexed","entity type(s) for verbs and modifiers."]},{"entry":[{},{},"Noun phrases that were recognized by NL"]},{"entry":[{},{},"parser are also stored with spaces"]},{"entry":[{},{},"replaced by \u2018\\.\u2019 The verb field order is:"]},{"entry":[{},{},"prefix_verb_mod verb suffix"]},{"entry":[{},{},"verb _mod Entity_types"]},{"entry":[{},{},"NLP_noun_phrases."]},{"entry":["parent_id","indexed,","clause id(10)"]},{"entry":[{},"stored"]},{"entry":["clause_rel_sent_class","tokenized,","Contains inter-clause relationships such"]},{"entry":[{},"indexed","as:"]},{"entry":[{},{},"conditional_c"]},{"entry":[{},{},"causal_c"]},{"entry":[{},{},"prepositional_c"]},{"entry":[{},{},"temporal_c"]},{"entry":[{},{},"and Sentence Attributes such as:"]},{"entry":[{},{},"question_s"]},{"entry":[{},{},"definition_s"]},{"entry":[{},{},"temporal_s"]},{"entry":[{},{},"numerical_s."]},{"entry":["relationship","stored","(Encoded clause for display)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0128","num":"0189"},"figref":"FIG. 30","b":["3001","3002","3003","3005","3004","3005","3006","3007","3008"],"sub":["\u2014","\u2014"]},"Table 2 below conceptually illustrates the information that is maintained in an example sentence index of the present invention. Since the terms with syntactic and semantic annotations are stored in the term-clause index, the enhanced indexing information can be identified by the sentence index, but is not typically stored as part of it.",{"@attributes":{"id":"p-0130","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["sentid","indexed","Document id sentence id separated by \u2018_\u2019"]},{"entry":["sent_text","Stored","String content of the sentence"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Table 3 below conceptually illustrates the information that is maintained in an example document index of the present invention. Since the terms with syntactic and semantic annotations are stored in the term-clause index, the enhanced indexing information can be identified by the document index, but is not typically stored as part of it.",{"@attributes":{"id":"p-0132","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["doc_id","Indexed, stored","Document id"]},{"entry":["dhs_doc_id","stored","DHS_doc_id (URL in one"]},{"entry":[{},{},"embodiment)"]},{"entry":["title","Tokenized,","Document title"]},{"entry":[{},"Indexed, stored"]},{"entry":["creationDate","Indexed, stored","Document creation date;"]},{"entry":[{},{},"format: yyyy.MM.dd-HH:mm:ss"]},{"entry":["metatag","Tokenized,","MetatagName#MetatagValue"]},{"entry":[{},"Indexed, stored"]},{"entry":["content","Tokenized,","String content of the document"]},{"entry":[{},"Indexed, Not"]},{"entry":[{},"Stored"]},{"entry":["document_type","stored","Document type (HTML, MSWORD)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0133","num":"0194"},"figref":"FIG. 31","b":["3101","3102","3103","3104","3105","3106"]},"Although specific embodiments of, and examples for, methods and systems of the present invention are described herein for illustrative purposes, it is not intended that the invention be limited to these embodiments. Equivalent methods, structures, processes, steps, and other modifications within the spirit of the invention fall within the scope of the invention. The various embodiments described above can be combined to provide further embodiments. Also, all of the above U.S. patents and patent publications referred to in this specification, including U.S. patent application Ser. No. 10\/007,299, filed on Nov. 8, 2001, entitled \u201cMethod and System for Enhanced Data Searching,\u201d and issued as U.S. Pat. No. 7,283,951 on Oct. 16, 2007; U.S. patent application Ser. No. 10\/371,399, filed on Nov. 8, 2001, entitled \u201cMethod and System for Enhanced Data Searching\u201d, and issued as U.S. Pat. No. 7,398,201 on Jul. 8, 2008; and U.S. patent application Ser. No. 11\/012,089, filed on Dec. 13, 2004, entitled \u201cMethod and System for Extending Keyword Searching to Syntactically and Semantically Annotated Data,\u201d and published as U.S. Patent Application No. 2005\/0267871; are incorporated herein by reference, in their entirety.","Aspects of the invention can be modified, if necessary, to employ methods, systems and concepts of these various patents, applications and publications to provide yet further embodiments of the invention. In addition, those skilled in the art will understand how to make changes and modifications to the methods and systems described to meet their specific requirements or conditions. For example, the methods and systems described herein can be applied to any type of search tool or indexing of a data set, and not just the SQE described. In addition, the techniques described may be applied to other types of methods and systems where large data sets must be efficiently reviewed. For example, these techniques may be applied to Internet search tools implemented on a PDA, web-enabled cellular phones, or embedded in other devices. Furthermore, the data sets may comprise data in any language or in any combination of languages. In addition, the user interface and API components described may be implemented to effectively support wireless and handheld devices, for example, PDAs, and other similar devices, with limited screen real estate. These and other changes may be made to the invention in light of the above-detailed description. Accordingly, the invention is not limited by the disclosure."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 6A-6G"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 7A-7F"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 8A-8F"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 11A-11F"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 31"}]},"DETDESC":[{},{}]}
