---
title: Static code analysis
abstract: Techniques for static code analysis are provided. The techniques include routing a code analysis request to a set of one or more static code analysis tools based on a context of the request, merging one or more tool-specific outputs of the code analysis, wherein merging the one or more tool-specific outputs comprises using one or more tool-specific mappings to one or more static code analysis abstractions and one or more source linkages of one or more static code analysis defects, performing a deep analysis on a set of one or more defect categories, and combining results of the merging with the deep analysis to filter out one or more false-positives and to add one or more new true positives to create an optimal set of defects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08806441&OS=08806441&RS=08806441
owner: International Business Machines Corporation
number: 08806441
owner_city: Armonk
owner_country: US
publication_date: 20090629
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["Embodiments of the invention generally relate to information technology, and, more particularly, to static code analysis.","Challenges exist in contemporary static code analysis approaches. For example, existing static code analysis tools report a large percentage of false positives that adversely impact the role of static code analysis in software quality. Also, existing static code analysis tools require end-users to be aware of a tool's internals (that is, setup process, configurations, and its terminology), adversely impacting consumability.","Additionally, existing static code analysis tools do not offer visualizations of the actual code-patterns that have led the tool to report a defect to the user. This, consequently, leaves a gap in empowering a user to take an intelligent judgment on whether a reported bug presents a scenario that can cause a severe impact on code quality. Further, existing static code analysis tools do not offer supporting user feedback and learning from user actions and feedback so as to be more adaptive to user needs.","Principles and embodiments of the invention provide techniques for static code analysis. An exemplary method (which may be computer-implemented) for static code analysis, according to one aspect of the invention, can include steps of routing a code analysis request to a set of one or more static code analysis tools based on a context of the request, merging one or more tool-specific outputs of the code analysis, wherein merging the one or more tool-specific outputs comprises using one or more tool-specific mappings to one or more static code analysis abstractions and one or more source linkages of one or more static code analysis defects, performing a deep analysis on a set of one or more defect categories, and combining results of the merging with the deep analysis to filter out one or more false-positives and to add one or more new true positives to create an optimal set of defects.","One or more embodiments of the invention or elements thereof can be implemented in the form of a computer product including a tangible computer readable storage medium with computer usable program code for performing the method steps indicated. Furthermore, one or more embodiments of the invention or elements thereof can be implemented in the form of an apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps. Yet further, in another aspect, one or more embodiments of the invention or elements thereof can be implemented in the form of means for carrying out one or more of the method steps described herein; the means can include (i) hardware module(s), (ii) software module(s), or (iii) a combination of hardware and software modules; any of (i)-(iii) implement the specific techniques set forth herein, and the software modules are stored in a tangible computer-readable storage medium (or multiple such media).","These and other objects, features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof, which is to be read in connection with the accompanying drawings.","Principles of the invention include a novel combination of shallow and deep static code analysis in a tool-transparent, feedback-driven, and adaptive static code analysis service. One or more embodiments of the invention include a static code analysis apparatus that offers static analysis as a service, wherein the apparatus can be primed with static code analysis abstraction vocabulary, empirical prioritization of the relevant items of the vocabulary, static analysis tools, tool-specific vocabularies to static code analysis abstraction mappings and user directories.","One or more embodiments of the invention provide a novel combination of shallow and deep static code analysis and package it as a service. The techniques can include, for example, routing a code analysis request to a set of static code analysis tools based on a context of the request, and merging tool-specific outputs of the code analysis, wherein merging the tool-specific outputs includes using tool-specific mappings to static code analysis abstractions and source linkages of static code analysis defects.","Also, the techniques detailed herein include performing a deep analysis on a select set of defect categories wherein the chosen categories are critical from the perspective of fixing the defects. Shallow static code analysis on these categories leads to a high-volume of false positives, and shallow static code analysis is likely to miss out of difficult to find true positives. One can combine the results of the merging with the deep analysis to filter a high percentage of false-positives and add new true positives to present an optimal set of defects to the user.","The techniques detailed herein include facilitating creation of projects, creation of builds for projects, as well as upload or association of source and\/or binary packages for builds. One or more embodiments of the invention also facilitate creation of named analysis configurations from static code analysis abstractions, and their scoped association to projects or across projects. Further, one or more embodiments of the invention can facilitate launching static code analysis requests for a chosen set of builds using a corresponding chosen set of named-analysis-configurations.","Static code analysis requests can be routed to a configured set of shallow static-analysis tools based on the context of the request. On successful completion of analysis by the tools, one or more embodiments of the invention can merge the tool-specific output using tool-specific mappings to static code analysis abstractions and the source linkages of the static code analysis defects. The techniques described herein can additionally filter reported merged defects based on the empirical prioritization with which the apparatus has been primed, the user-feedback on the reported defects in previous analysis-runs, and defect relevance trend-analysis based on user-feedback and configurations across users and projects.","Also, one or more embodiments of the invention can carry-out a deep pass code-analysis analysis corresponding to a set of select categories. Categories for deep analysis are chosen such that they are critical from the perspective of fixing the defects. Shallow code analysis on these categories leads to a high-volume of false positives, and shallow code analysis is likely to miss out of difficult to find true positives. Deep code analysis results are used to filter out false-positives and merge new true-positives from\/into the previous shallow code analysis results.","One or more embodiments of the invention additionally facilitate users (for example, authenticated users) to provide feedback on the reported defects as well as code-navigation-based visualization of the code-patterns leading to the defects. This feedback can be used, for example, to provide a more relevant user-adapted prioritization and filtering of defects in subsequent analysis-runs.","One or more embodiments of the invention can include a web-based portal front, a representation state transfer (REST) based Service API, and its implementation. The techniques detailed herein also include a tool-agnostic static code analysis vocabulary that is an end-user-driven abstraction of code-analysis terms and concepts, masking the end-user from numerous variations of tool-specific terms and concepts. Additionally, the techniques described herein can accommodate various static-analysis-tools configurationally by providing a mapping of their vocabularies to the tool-agnostic static code analysis vocabulary. Also, multiple mapped static analysis tools can be run towards a static-analysis request, and then one can aggregate, map and merge tool-specific analysis-reports to the tool-agnostic static code analysis vocabulary.","One or more embodiments of the invention also include a generalized code-navigation scheme based on named-marker sets that describe a path of navigation thru the code in a generalized manner, as well as using the generalized code-navigation scheme and code-patterns to provide an end-user with a visualization of code-slices and their navigational paths that led to a static code analysis defect being reported.","One or more embodiments of the invention include capturing user-feedback on entities such as, for example, reported static code analysis defects and role and\/or relevance of code-patterns leading to such defects. Direct and derived user-feedback (for example, selection of analysis-configurations (with which the users are running static code analysis or storing as named analysis-configurations for later use) can be used to adapt to a user's needs in filtering and\/or prioritizing reported defects. Further, one or more embodiments of the invention include capturing tool-specific feedback that can be used by any of the underlying tools to improve the analysis results.","The techniques detailed herein include reducing false positives in static code analysis via a deep code analysis for a select set of categories and using a learning and adaptive scheme based on direct and\/or derived user feedback for defect-prioritization and filtering. As described herein, one or more embodiments of the invention identify control-flow-based patterns, prioritize defects within a category, and, based on user feedback, use multiple features of defects (for example, defect patterns) and build classifiers for reprioritization defects. Additionally, given, for example, the defect reports for two versions of a program, the techniques described herein can compute deleted defects, new defects, and common defects by performing control-flow-based differencing of the two program versions.","One or more embodiments of the invention can include, by way of example only and not limitation, the following steps. For instance, an end-user can log-in to the system and see a list of linked projects as well as personal named-analysis-configurations. Named-analysis-configurations are a set of analysis types that the end-user has grouped together on some logical basis and wishes to re-use across builds within the same project or across projects. Also, the end-user can create either of the above mentioned entities (that is, a project or a named-analysis-configuration), and the named-analysis-configurations can be created across projects or within the scope of a project. Once the end-user creates a project, new builds can be created in the scope of that project. A build is a set of source and\/or binary packages that are directly uploaded or derived from configurations describing the uniquely identifying details of a source control repository and build-scripts.","Once a build is created and source and\/or binary packages are associated to that build, an end-user can run an analysis on the build. For example, in one or more embodiments of the invention, the end-user can choose more that one build and more than one analysis configurations to run on those builds. Upon the end-user's running the analysis with a set of chosen builds from a project and a corresponding set of analysis-configurations, a request processor receives the analysis requests and looks at the configurations to select the right set of static code analysis tools and runs them.","Once the static code analysis tools have all reported their completion, an aggregation and merge engine selects static code analysis abstractions to specific tool mappings and applies them to convert tool specific static code analysis defect reports to a common base (based on the aforementioned abstractions). The engine can then merge the abstractions while at the same time knocking off duplicates based on the defect-type and source-linkage combination.","One or more embodiments of the invention can apply a deep code-analysis corresponding to a set of select categories. Categories for deep analysis are chosen such that they are critical from the perspective of fixing the defects. Shallow code analysis on these categories leads to a high-volume of false positives, and shallow code analysis is likely to miss out of difficult to find true positives. Deep code analysis results are used to filter out false-positives and merge new true-positives from\/into the previous shallow code analysis results. Additionally, one or more embodiments of the invention can apply a filter based on user-feedback and learning based on trend-analysis to filter-out false-positives, as well as apply prioritization based on empirical defect-analysis knowledge.","The techniques detailed herein further include reporting static code analysis defects as a report to the end-user. Depending on the combination (of builds and analysis-configurations) on which the end-user fired the analysis, there can be more than one reports listed for the end-user. The end-user can choose to view the details of a specific report, wherein the user can be presented with the filtered and prioritized report of defects. Using marker sets associated with the reported defects, a user may also view a visualization of the code leading to the defect.","As the end-user selects a defect (which may include, for example, simply hovering over the defect), a choice of feedbacks and\/or the associated and\/or identified code-patterns (if any) can also be presented to the user. Further, based on the end-user actions, feedback on the defect or on the code-patterns can be accepted to reflect immediate changes in the current report and for later use in the subsequent analysis.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["102","104","106","108","110","112","114","116","118","120","122","124"]},"The configurator component  provides the ability to accommodate various existing static-analysis-tools configurationally by providing a mapping of their vocabularies to a tool-agnostic static-code-analysis vocabulary. The tool-agnostic static-code-analysis vocabulary is an end-user driven abstraction of code-analysis terms and concepts, masking the end-user from numerous variations of tool-specific terms and concepts. The configurator  also allows registering the capability and confidence associated to a particular analysis tool towards its support for a particular category in the code analysis vocabulary. An end-user of the static analysis service does not have to usually be aware of the configurator.","The analysis driver component  chooses the correct set of underlying static analysis tools applicable for the requested static analysis, federates the static-analysis job to these underlying static analysis tools, and assembles the response. It can make the choice of the underlying static analysis tools based on, for example, the initially registered capability for the tool towards the categories of analysis, the observed trends in terms of the false-positives detection, and the user-feedback in terms of acceptance or rejection of the identified bugs.","The aggregation and merge engine  unifies the assembled responses received for the federated static analysis performed by the underlying tools. It uses the mappings between the underlying tools' vocabularies and the common static analysis abstraction to do so. The aggregation and merge engine also filters out duplicates based on the defect-type and source-linkage combination.","The deep analyzer component  performs a deep static analysis for a select set of defect-categories. Primarily, these categories are important from the perspective of fixing defects, and have a lot of false positives from shallow static analysis performed by the underlying tools.","The prioritize and filter engine  performs a number of tasks. For example, it uses the deep analysis output to both filter out a lot of false positives post the aggregation and merge, as well as add new defects that may have been discovered new in the deep-analysis. Also, the prioritize and filter engine  applies a filter based on user-feedback and learning based on trend-analysis to knock-off further false-positives. Additionally, the prioritize and filter engine  applies prioritization based on empirical defect-analysis knowledge as well as observed personal trends in terms of defects and categories actually chosen for fixing.","The feedback engine  allows capturing user-feedback on entities such as, for example, reported static code analysis defects. The users can state things such as whether they will fix or ignore the defects, any remarks and\/or directions for the fixers in relation to the defect, whether a particular category of defects should be prioritized low\/high\/ignored all together, etc. Analysis tools (for example, components ,  and ) can include, for example, typical code analysis tools that are common in the field.","The data store component  persists the information relevant from the perspective of the techniques detailed herein. It uses the disclosed schema as a data-model guidance in persistence. The static analysis portal front  is a web-based portal through which one or more embodiments of the invention are offered to end-users. Further, the static code analysis service API  is the programmable API that may be used in programmatic integrations with one or more embodiments of the invention.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["202","204","206","208","210","212","214","216","218","220","222","224","226","228","230"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 3","FIG. 4","FIG. 4"],"b":["302","402"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 5","FIG. 6","FIG. 7"],"b":["502","602","702"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 8","FIG. 8"],"b":["802","804","806","808"]},"Step  includes creating an analysis project. Once the system is configured, the first task from a user perspective is to create a project where builds can be uploaded for analysis (see, for example, ). This step has three sub-components. Specifically, step  includes analysis configuration, wherein project configurations can be set up that specify the defects and the defect priorities (see, for example, ). Also, step  includes running configuration, wherein one can set up run-time schedules, according to which the system will extract the code specified in the source configuration and automatically generate reports. Additionally, step  includes source configuration, which indicates whether the source is to be uploaded manually, via downloaded scripts (such as ant, java, php, etc. scripts) or whether the source is to be collected from a source control system (such as svn, cvs, etc.).","Step  includes uploading a project build. Depending on the configured run and source configurations, this step can be accomplished manually via the portal, or semi-automatically via the upload scripts or completely automatically from a configured source control system (see, for example, ). Step  includes analyzing, wherein one can run appropriate analysis tools based on the configured analysis configuration. Step  includes computing the \u201cdiff\u201d between the current build and every previous build (see, for example, ).","Step  includes reporting, wherein the analysis results can be displayed and\/or e-mailed to the appropriate project member(s) (see, for example, ,  and ). Step  includes aggregating and merging, wherein the results from the various tools are aggregated and merged. Hence, the user need not look at multiple reports for the same defect (see, for example, ). Step  includes filtering false positive, wherein deep analysis tool results can be used to invalidate some results from shallow analysis tools and mark them as false positives (see, for example, ). Also, step  includes diff and statistics, wherein on request, diffs may be displayed (see, for example ). Similarly, statistics may be computed and displayed (see, for example, ).","Step  includes classifying and prioritizing, wherein all defects are classified and prioritized based on rules in the analysis configuration (see, for example, ). Additionally, one or more embodiments of the invention include code navigation paths, which include the path along which a bug occurred can be displayed (see, for example, ).","Step  includes providing and\/or receiving feedback, wherein a user can give feedback on the value of each defect. Feedback can include, for example, must-fix, wont fix, invalid , which can be derived from defect reporting repositories (such as bugzilla, CMVC, etc.). Must-fix is a high priority bug that must be fixed as soon as possible. Wont-fix is recognized as a bug but the developer uses his discretion to ignore it. Invalid indicates a false positive as noted by human intelligence (see, for example, ). Feedback can also include general comments , which can include free text comments that can be added to each defect reported.","Additionally, as depicted by , step  includes recalculating prioritization. Based on feedback, the defect prioritization can be recalculated and the analysis configuration can be updated accordingly.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIGS. 9 through 18","FIG. 8","FIG. 9","FIG. 10","FIG. 11"],"b":["902","1002","1102"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 12","FIG. 13","FIG. 13","FIG. 13"],"b":["1202","1302"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 14","FIG. 14"],"b":"1402"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 15","FIG. 15","FIG. 16","FIG. 16"],"b":["1502","1602"]},"Also,  is a diagram illustrating an example embodiment  of \u201cCode navigation paths,\u201d according to an embodiment of the invention.  depicts an example of a defect path highlighted in the code (shaded).  is a diagram illustrating an example embodiment  of \u201cMust-fix, wont fix, invalid\u201d feedback, according to an embodiment of the invention.  depicts radio buttons to accept such feedback.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 19","b":"1902"},"Step  includes merging one or more tool-specific outputs of the code analysis, wherein merging the one or more tool-specific outputs comprises using one or more tool-specific mappings to one or more static code analysis abstractions and one or more source linkages of one or more static code analysis defects. Merging tool-specific outputs of the code analysis can additionally include producing a unified analysis report.","Step  includes performing a deep analysis on a set of one or more defect categories (wherein the defect categories are critical from a perspective of fixing the defects). Step  includes combining results of the merging with the deep analysis to filter out one or more false-positives and to add one or more new true positives to create an optimal set of defects. Additionally, one or more embodiments of the invention include presenting the optimal set of defects to a user.","The techniques depicted in  also include filtering one or more merged defects based on, for example, an empirical prioritization, user-feedback (for example, on the reported defects in previous analysis-runs), and\/or defect relevance trend-analysis based on user-feedback and configurations (for example, across users and projects). One or more embodiments of the invention can also include performing one or more additional pass code-analyses to search for code-patterns that led to a set of previously-filtered defects.","Additionally, the techniques depicted in  can include enabling a user (for example, via a service portal) to specify configuration, interact, see results, and\/or provide feedback for static-analysis of code (for example, in a tool-agnostic manner). One or more embodiments of the invention can additionally include identifying elemental code patterns leading to refined defect categories (thereby achieving substantial reduction in false positives), as well as implementing a generalized code navigation scheme based on named-marker-sets.","The techniques depicted in  can also include, as described herein, providing a system, wherein the system includes distinct software modules, each of the distinct software modules being embodied on a tangible computer-readable recordable storage medium. The distinct software modules can include, for example, a static analysis portal module, a static code analysis service application programming interface module, a configurator module, an analysis driver module, an aggregation and merge engine module, a prioritize and filter engine module, a deep analyzer module, a categorizer module, a feedback engine module, an analysis tool module and a data store module executing on a hardware processor.","In one or more embodiments of the invention, configuring analysis tools can be performed by a configurator module, create an analysis project and uploading a project build can be performed by a static analysis portal front module, a static code analysis service API module, and the schema. Also, analyzing can be performed by an analysis driver module, aggregating and merging can be performed by an aggregation merge engine module, and filtering false positives can be performed by a deep analyzer module. Additionally, classifying and prioritizing can be performed by a prioritize and filter engine module, providing and receiving feedback can be performed by a feedback engine module, and recalculating prioritization can be performed by a prioritize and filter engine module.","Additionally, the techniques depicted in  can be implemented via a computer program product that can include computer useable program code that is stored in a computer readable storage medium in a data processing system, and wherein the computer useable program code was downloaded over a network from a remote data processing system. Also, in one or more embodiments of the invention, the computer program product can include computer useable program code that is stored in a computer readable storage medium in a server data processing system, and wherein the computer useable program code are downloaded over a network to a remote data processing system for use in a computer readable storage medium with the remote system.","A variety of techniques, utilizing dedicated hardware, general purpose processors, firmware, software, or a combination of the foregoing may be employed to implement the present invention or components thereof. One or more embodiments of the invention, or elements thereof, can be implemented in the form of a computer product including a computer usable medium with computer usable program code for performing the method steps indicated. Furthermore, one or more embodiments of the invention, or elements thereof, can be implemented in the form of an apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps.","One or more embodiments can make use of software running on a general purpose computer or workstation. With reference to , such an implementation might employ, for example, a processor , a memory , and an input\/output interface formed, for example, by a display  and a keyboard . The term \u201cprocessor\u201d as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit) and\/or other forms of processing circuitry. Further, the term \u201cprocessor\u201d may refer to more than one individual processor. The term \u201cmemory\u201d is intended to include memory associated with a processor or CPU, such as, for example, RAM (random access memory), ROM (read only memory), a fixed memory device (for example, hard drive), a removable memory device (for example, diskette), a flash memory and the like.","In addition, the phrase \u201cinput\/output interface\u201d as used herein, is intended to include, for example, one or more mechanisms for inputting data to the processing unit (for example, mouse), and one or more mechanisms for providing results associated with the processing unit (for example, printer). The processor , memory , and input\/output interface such as display  and keyboard  can be interconnected, for example, via bus  as part of a data processing unit . Suitable interconnections, for example via bus , can also be provided to a network interface , such as a network card, which can be provided to interface with a computer network, and to a media interface , such as a diskette or CD-ROM drive, which can be provided to interface with media .","Accordingly, computer software including instructions or code for performing the methodologies of the invention, as described herein, may be stored in one or more of the associated memory devices (for example, ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (for example, into RAM) and implemented by a CPU. Such software could include, but is not limited to, firmware, resident software, microcode, and the like.","Furthermore, the invention can take the form of a computer program product accessible from a computer-usable or computer-readable medium (for example, media ) providing program code for use by or in connection with a computer or any instruction implementation system. For the purposes of this description, a computer usable or computer readable medium can be any apparatus for use by or in connection with the instruction implementation system, apparatus, or device. The medium can store program code to implement one or more method steps set forth herein.","The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a tangible computer-readable storage medium include a semiconductor or solid-state memory (for example memory ), magnetic tape, a removable computer diskette (for example media ), a random access memory (RAM), a read-only memory (ROM), a rigid magnetic disk and an optical disk (but exclude a propagation medium). Current examples of optical disks include compact disk-read only memory (CD-ROM), compact disk-read\/write (CD-R\/W) and DVD.","A data processing system suitable for storing and\/or executing program code will include at least one processor  coupled directly or indirectly to memory elements  through a system bus . The memory elements can include local memory employed during actual implementation of the program code, bulk storage, and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during implementation.","Input\/output or I\/O devices (including but not limited to keyboards , displays , pointing devices, and the like) can be coupled to the system either directly (such as via bus ) or through intervening I\/O controllers (omitted for clarity).","Network adapters such as network interface  may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modem and Ethernet cards are just a few of the currently available types of network adapters.","As used herein, including the claims, a \u201cserver\u201d includes a physical data processing system (for example, system  as shown in ) running a server program. It will be understood that such a physical server may or may not include a display and keyboard.","Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Embodiments of the invention have been described herein with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a tangible computer-readable storage medium that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable medium produce an article of manufacture including instruction means which implement the function\/act specified in the flowchart and\/or block diagram block or blocks. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks. The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s).","It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be implemented substantially concurrently, or the blocks may sometimes be implemented in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.","Furthermore, it should be noted that any of the methods described herein can include an additional step of providing a system comprising distinct software modules embodied on a tangible computer readable storage medium; the modules can include any or all of the components shown in . The method steps can then be carried out using the distinct software modules and\/or sub-modules of the system, as described above, executing on a hardware processor. Further, a computer program product can include a tangible computer-readable storage medium with code adapted to be implemented to carry out one or more method steps described herein, including the provision of the system with the distinct software modules.","In any case, it should be understood that the components illustrated herein may be implemented in various forms of hardware, software, or combinations thereof; for example, application specific integrated circuit(s) (ASICS), functional circuitry, one or more appropriately programmed general purpose digital computers with associated memory, and the like. Given the teachings of the invention provided herein, one of ordinary skill in the related art will be able to contemplate other implementations of the components of the invention.","At least one embodiment of the invention provides one or more beneficial effects, such as, for example, filtering and prioritizing reported defects based on user feedback","It will be appreciated and should be understood that the exemplary embodiments of the invention described above can be implemented in a number of different fashions. Given the teachings of the invention provided herein, one of ordinary skill in the related art will be able to contemplate other implementations of the invention. Indeed, although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 17","b":"1702"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
