---
title: Methods and apparatuses for selective code coverage
abstract: Methods and apparatuses that collect code coverage information for selected code locations when executing executable code are described. Source code in one or more files may be annotated at the selected code locations. The executable code may be compiled from the annotated source code using standard compilers. The code coverage information may be collected into a run time data store accessible by other applications. In response to receiving a code coverage request, the code coverage information can be retrieved from the data store to compare with annotations identified from the source code. A code coverage report can be generated to indicate whether one or more of the selected code locations are not covered when executing the executable code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08381194&OS=08381194&RS=08381194
owner: Apple Inc.
number: 08381194
owner_city: Cupertino
owner_country: US
publication_date: 20090828
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCES TO RELATED APPLICATIONS","FIELD OF INVENTION","BACKGROUND","SUMMARY OF THE DESCRIPTION","DETAILED DESCRIPTION"],"p":["The present invention is a continuation-in-part of U.S. patent application Ser. No. 12\/544,191, filed Aug. 19, 2009, now pending, and the disclosures of which are considered part of and are incorporated by reference in the disclosure of this application.","The present invention relates generally to code development tools. More particularly, this invention relates to selective code coverage tools.","With the increasing size of software code, correctness verification is often conducted incrementally focusing on a few critical parts of the code in each test run. For example, modern kernel code for a computing device usually includes a large portion of code handling a variety of code branches. Usually, a kernel test may target one or two code branches without regard to other parts of the system that are of no interest in the current testing, or those handling rarely occurred boundary conditions, such as when a hard drive returns a wrong bit, when a network is broken, or other unusual error conditions. However, most existing code coverage tools attempt to cover every portion of target software, for example, to report a percentage of overall code covered in the testing. Therefore, comprehensive software test using such tools could waste disproportionate system and engineering resources on uninterested or uncritical software code.","Furthermore, to monitor each instruction execution on target software, existing code coverage tools usually require more functionalities than what standard compilers would offer. Such requirement, however, adds more complexity to software development environment. In addition, an executable built for existing code coverage tools tends to include significant amount of overhead code, resulting in a code size much larger than a corresponding executable built for release using standard compilers. Moreover, even if an existing code coverage tool, which is designed to cover the entire body of software to be tested, allows manual removal of selected portions of software code from coverage analysis, it can be cumbersome, laborious, or practically impossible to turn off coverage analysis of a large portion of source code when, for example, the source code files includes millions of code lines.","Therefore, traditional code coverage tools do not provide a simple and efficient mechanism for selective code coverage analysis.","An embodiment of the present invention can include methods and apparatuses that collect code coverage information for selected code locations when executing executable code. Source code in one or more files may be annotated at the selected code locations. These selected code locations can be a very limited number of code portions which are \u201chand picked\u201d in order to limit the scope of code coverage detection. In one embodiment, if a portion of code is not annotated, then no code coverage analysis will be preformed or recorded for that partition; in other words, the system is configured so that the default is no code coverage analysis for the entire code and code coverage analysis of any portion requires that this portion be annotated to cause code coverage analysis. The executable code may be compiled from the annotated source code using standard compilers. The code coverage information may be collected into a run time data store accessible by other applications. In response to receiving a code coverage request, the code coverage information can be retrieved from the data store to compare with annotations identified from the source code. A code coverage report can be generated to indicate whether one or more of the selected code locations are not covered (e.g. no tested or not executed) when executing the executable code.","An embodiment of the invention can be used for software which does not normally complete execution, such as an operating system's (OS) kernel. Hence, code coverage analysis can be performed on selected portions of an operating system's kernel even as it continues to run after data for a code coverage report has been obtained and after the report has been created. This can allow for interactive testing to generate multiple reports showing code coverage (e.g. whether selected annotated code portions were executed) of the OS's kernel. Further, this embodiment of code coverage analysis can allow for the generation of a code coverage report at any point in time of execution of the compiled code which includes the annotations. In an implementation of this embodiment, the inserted coverage code can include a programming interface or command to allow the creation of and access to a data store which is used to store collected code coverage information as described herein.","In an alternative embodiment, an executable code can be compiled from annotated source code inserted with one or more copies of coverage code at selected code locations. The executable code can include indicators corresponding to the selected code locations of the source code. A run time data store can be updated by accessing the indicators when executing the executable code. Code coverage information for the selected code locations annotated in the source code can be retrieved from the data store. A code coverage report can be generated to indicate the number of actual executions on a selected code location based on the retrieved code coverage information.","Other features of the present invention will be apparent from the accompanying drawings and from the detailed description that follows.","Methods and apparatuses for selective code coverage are described herein. In the following description, numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent, however, to one skilled in the art, that embodiments of the present invention may be practiced without these specific details. In other instances, well-known components, structures, and techniques have not been shown in detail in order not to obscure the understanding of this description.","Reference in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification do not necessarily all refer to the same embodiment.","The processes depicted in the figures that follow, are performed by processing logic that comprises hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general-purpose computer system or a dedicated machine), or a combination of both. Although the processes are described below in terms of some sequential operations, it should be appreciated that some of the operations described may be performed in different order. Moreover, some operations may be performed in parallel rather than sequentially.","In one embodiment, selective code coverage can allow a programmer to annotate specific blocks of code. A compiler may detect annotated blocks and modify the code so that when executed, the code can output to a buffer in memory the file and line number for each line of code in the scope of the annotation that has actually executed during a given test run. A selective code coverage tool can selectively turn coverage monitoring for targeted code on and off via source code annotation.","In one embodiment, selective code coverage may enable code coverage test with minimal overhead and\/or impact on actual performance of target software. A programmer could insert a few lines of annotations in key branches (e.g. using flags) for selecting code to be covered in a test run. Selective code coverage may not need additional tool\/compiler\/debugger support other than standard compilers (e.g. C language compiler). Thus, selective code coverage can be conducted in a manner independent of tools\/compilers\/debuggers. An executable can be built for final release based on the same annotated source code for selective code coverage using simple flag switches in compiler settings.","In some embodiments, annotations in selective code coverage can be based on macro mechanism for inserting coverage code with low execution overhead to check code coverage. The coverage code can remember execution traces, e.g. based on line numbers and file names, into a small data structure. A report generator can scan the annotations from source files to compare with the execution traces stored in the data structure and generate a report indicating which annotated code have not executed. In one embodiment, a report generator can periodically generate reports for selective code coverage while a target executable code (e.g. a kernel) is running.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["100","101","107","109","105","105","101","107","105","103","105"]},"In one embodiment, target execution system  may execute executable code  to collect code coverage information for selected locations as annotated in annotated source code , according to, for example, instructions compiled from coverage codes inserted at the selected code locations. Tool system  can retrieve the code coverage information from target execution system , e.g. during run time while executing executable code . In one embodiment, tool system  may generate a code coverage report  by comparing annotated source code  with the code coverage information retrieved from target execution system . Code coverage report  can indicate whether a selected code location in the original source code is covered or not when target execution system  executing executable code .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 1"],"b":["200","201","101","107","227","223","201","219","105","227","221","215","219","227","105","221","227"]},"In one embodiment, compiler  may compile annotated source code  to generate executable code including data processing module  and code coverage module . Data processing module  may include instructions compiled from source code . In one embodiment, compiler  may insert coverage code  into each annotated code location in annotated source code  to generate executable code. Code coverage module  may include instructions compiled from coverage code  via compiler . In one embodiment, data processing module  may include indicators corresponding to code locations  as annotated in annotated source code . Each indicator may be an index allocated in memory when the executable code compiled from annotated source code  is loaded in the memory for execution. Executing instructions compiled from the code at a code location corresponding to an indicator may cause the indicator to be accessed for code coverage module  to collect code coverage information into coverage information store  for the code location.","In one embodiment, coverage information store  may include code coverage information associated with a file name and a line number for a corresponding code location. Code coverage information can include a count indicating number of times the code at a code location has been executed. In one embodiment, coverage information access module  may retrieve code coverage information for code locations  from code coverage information store . An interface (e.g. an Application Programming Interface or a system command) to coverage information access module  may be registered in a kernel interface module  for an application, such as report generator module , to access code coverage information stored in coverage information store . Coverage code  may include registration codes for registering the interface, e.g. in system . In one embodiment, coverage information access module  may include instructions compiled from coverage code .","Report generator module  may compare annotated source code  and code coverage information received from coverage information store  to generate a report indicating whether source code  annotated at code locations  have been executed (or covered). In one embodiment, report generator module  may determine code locations  from annotated source code  via source code scanner module  to report if a code location annotated in annotated source code  is covered. In some embodiments, report generator module  can generate a report indicating which annotated code locations are not covered in response to a user request from user interface module .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 3","FIG. 2","FIG. 2","FIG. 2","FIG. 1"],"b":["300","300","200","301","300","227","221","105"]},"At block , the processing logic of process  may compile annotated source code, for example, based on compiler  of . The processing logic of process  may use one or more compiler settings (e.g. compilation flags, parameters values etc.) to compile the annotated source code. In one embodiment, executable code for selective code coverage can be built using similar compiler settings for building executable code for release. For example, a common compiler, such as compiler  of , can build the executable code for code coverage and the executable code for release based on whether a flag is on or off in the compiler settings.","In one embodiment, the processing logic of process  may execute executable code compiled from an annotated source code to store once a code location (or insertion location) associated with an annotation in the annotated source code. A code location may include a file name and a line number. The processing logic of process  may allocate a run time data store (e.g. a data structure), such as coverage information store  of , for storing code locations. In one embodiment, the processing logic of process  may create a location indicator for an annotation to index the data storage for storing a corresponding code location (e.g. file name and\/or line number). For example, the processing logic of process  can store a line number and\/or a pointer to a file name as indexed to the corresponding code location. Thus, the actual file name for a file can be stored only once when multiple code locations are annotated inside the file. The processing logic of process  may store code locations for one or more annotations included in the annotated source code. In one embodiment, each code location stored in the data store may indicate coverage of the code at the code location.","At block , according to one embodiment, the processing logic of process  may collect code coverage information for an insertion location (or code location) into a data store when executing instructions compiled for the corresponding code at the code location of the source code. In one embodiment, code coverage information may include a number of times instructions for a certain code location have been executed. In another embodiment, code coverage information may indicate whether instructions for a certain code location have been executed. The processing logic of process  may update the data store indexed by a location indicator corresponding to an annotation in the source code to collect code coverage information.","In one embodiment, at block , the processing logic of process  may determine which code locations annotated in source code have not been executed (or covered) by comparing annotated source code and coverage information collected in a run time data store. The processing logic of process  may scan the annotated source code, e.g. annotated source code , to identify which code locations have been annotated. In one embodiment, the processing logic of process  may retrieve code coverage information collected in the data store via an API interface registered to a kernel system. The code coverage information may include one or more code locations which have been covered. In one embodiment, the processing logic of process  may determine a code location identified from the annotated source code is not covered if the code coverage information does not include the code location.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 4","FIG. 2"],"b":["400","400","200","401","400"]},"At block , the processing logic of process  can collect code coverage information in a data store (or data structure) via indicators. The processing logic for process  may allocate the data store dynamically while executing instructions compiled from annotated. In one embodiment, an indicator may be associated with a unique value to index the collected code coverage information in the data store. Code coverage information may include code location (e.g. a file name or a pointer to the file name, and\/or a line number) for the corresponding code covered. In one embodiment, the processing logic of process  may determine if a corresponding entry for an indicator exists in the data store when the indicator is accessed. The processing logic of process  may store the code location (e.g. a file name or a pointer to the file name and\/or the line number) corresponding to the indicator in the data store once, e.g. the first time an entry is created in the data store, for the indicator. In some embodiments, the processing logic of process  may update (e.g. increment) a counter associated with an indicator in the data store when the indicator is accessed (or the code is covered).","At block , the processing logic of process  may retrieve code coverage information from a data store in response to a request received (e.g. a user request). The processing logic of process  may receive the request via an interface registered (e.g. in a system kernel) according to instructions compiled from annotated code. The code coverage information retrieved may indicate, up to the time of retrieval, which selected code locations in a source code as annotated have been covered. At block , the processing logic of process  can generate a code coverage report from the code coverage information retrieved. For example, the processing logic of process  can compare selected code locations annotated in a source code with the code location retrieved (e.g. based on file name and\/or line number) to determine if a selected code location is not covered.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 5","FIG. 2"],"b":["500","500","200","501","500","500","500","500","500"]},"At block , the processing logic of process  can execute the executable for collecting code coverage information on the selected code locations of the source code. For example, a code location may represent one of a number of branches for a conditional statement of a source code. The code coverage information may indicate whether or how many times the corresponding of branch has been executed. In one embodiment, at block , the processing logic of process  may register an interface (e.g. a programming interface or a command) to access a data store which stores collected code coverage information. The processing logic of process  may allocate the data store (e.g. a data structure) based on instructions compiled from an initializing code inserted into the source code. The processing logic of process  may register the interface to access the data store based on instructions compiled from the initializing code.","In one embodiment, at block , the processing logic of process  can update a counter in a data store to indicate coverage of the source code at the selected location. A counter may include a binary value to indicate whether a corresponding code location has been covered during a test run. In some embodiments, a counter may include an integer value indicating the number of times the corresponding code location has been covered. The processing logic of process  may associate code coverage information collected in the data store with the corresponding code location. For example, an entry for the code location in the data store may store code coverage information including a counter, a file name and a line number for the code location. In one embodiment, the processing logic of process  may allocate a location indicator which can be accessed when instructions compiled from the code at the corresponding code location are executed. The processing logic of process  can identify a file name and a line number for the location indicator to represent the corresponding code location in the data store.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 6","FIG. 1"],"b":["600","105","605","603","607","603","607","605","603","607","601","601","603","607"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 7","FIG. 2"],"b":["700","213","700","701","703","701","709","707","705","709","701","700","700"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 8","FIG. 1","FIG. 8"],"b":"800"},"As shown in , the computer system , which is a form of a data processing system, includes a bus  which is coupled to a microprocessor(s)  and a ROM (Read Only Memory)  and volatile RAM  and a non-volatile memory . The microprocessor  may retrieve the instructions from the memories , ,  and execute the instructions to perform operations described above. The bus  interconnects these various components together and also interconnects these components , , , and  to a display controller and display device  and to peripheral devices such as input\/output (I\/O) devices which may be mice, keyboards, modems, network interfaces, printers and other devices which are well known in the art. Typically, the input\/output devices  are coupled to the system through input\/output controllers . The volatile RAM (Random Access Memory)  is typically implemented as dynamic RAM (DRAM) which requires power continually in order to refresh or maintain the data in the memory.","The mass storage  is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD RAM or a flash memory or other types of memory systems which maintain data (e.g. large amounts of data) even after power is removed from the system. Typically, the mass storage  will also be a random access memory although this is not required. While  shows that the mass storage  is a local device coupled directly to the rest of the components in the data processing system, it will be appreciated that the present invention may utilize a non-volatile memory which is remote from the system, such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface or wireless networking interface. The bus  may include one or more buses connected to each other through various bridges, controllers and\/or adapters as is well known in the art.","Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine-executable instructions that cause a machine that executes these instructions to perform certain functions. In this context, a \u201cmachine\u201d may be a machine that converts intermediate form (or \u201cabstract\u201d) instructions into processor specific instructions (e.g., an abstract execution environment such as a \u201cvirtual machine\u201d (e.g., a Java Virtual Machine), an interpreter, a Common Language Runtime, a high-level language virtual machine, etc.), and\/or, electronic circuitry disposed on a semiconductor chip (e.g., \u201clogic circuitry\u201d implemented with transistors) designed to execute instructions such as a general-purpose processor and\/or a special-purpose processor. Processes taught by the discussion above may also be performed by (in the alternative to a machine or in combination with a machine) electronic circuitry designed to perform the processes (or a portion thereof) without the execution of program code.","An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as, but is not limited to, one or more memories (e.g., one or more flash memories, random access memories (static, dynamic or other)), optical disks, CD-ROMs, DVD ROMs, EPROMs, EEPROMs, magnetic or optical cards or other type of machine-readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a propagation medium (e.g., via a communication link (e.g., a network connection)).","The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be kept in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or \u201cdisplaying\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), RAMs, EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus.","The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general-purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion, the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
