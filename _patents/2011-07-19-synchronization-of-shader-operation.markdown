---
title: Synchronization of shader operation
abstract: The example techniques described in this disclosure may be directed to synchronization between producer shaders and consumer shaders. For example, a graphics processing unit (GPU) may execute a producer shader to produce graphics data. After the completion of the production of graphics data, the producer shader may store a value indicative of the amount of produced graphics data. The GPU may execute one or more consumer shaders, after the storage of the value indicative of the amount of produced graphics data, to consume the produced graphics data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09442780&OS=09442780&RS=09442780
owner: QUALCOMM Incorporated
number: 09442780
owner_city: San Diego
owner_country: US
publication_date: 20110719
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates to graphics shaders, and more particularly, to execution of one or more graphics shaders on a graphics processing unit (GPU).","A device that generates viewable content generally includes a graphics processing unit (GPU). The GPU may process graphics data to generate pixel values for the pixels on a display. To process the graphics data, the GPU may execute one or more shader programs, often referred to as shaders. A shader program may be a software program that causes the GPU to perform functions defined by the shader program when the GPU executes the shader program. For instance, the shader program may define the manner in which the GPU should process graphics data to generate pixel values for the pixels on the display.","In general, this disclosure describes techniques for synchronizing the execution of one or more shader programs on a graphics processing unit (GPU). In some examples, one shader program may generate graphics data that is consumed or utilized by another shader program. The shader program that generates the graphics data may be referred to as a producer shader, and the shader program that consumes the generated graphics data may be referred to as a consumer shader. Some of the example techniques described in this disclosure may cause a GPU to synchronize the execution of the producer and consumer shaders such that the GPU does not execute the consumer shader until the producer shader has generated the graphics data that is to be consumed by the consumer shader.","In one example, this disclosure describes a method that includes executing, with a graphics processing unit (GPU), a producer shader that produces graphics data, and storing, with the GPU, the graphics data produced by the producer shader in a storage location of a first buffer. The method further includes upon completion of the production of the graphics data, storing, with the producer shader executing on the GPU, a value indicative of an amount of the graphics data produced by the producer shader in a storage location of a second buffer.","In another example, this disclosure describes an apparatus that includes a first buffer, a second buffer, and a graphics processing unit (GPU). The GPU is operable to execute a producer shader that produces graphics data, and store the graphics data produced by the producer shader in a storage location of the first buffer. The GPU is also operable to, upon completion of the production of the graphics data, store, with the producer shader executing on the GPU, a value indicative of an amount of the graphics data produced by the producer shader in a storage location of the second buffer.","In another example, this disclosure describes an apparatus that includes a first buffer, a second buffer, and a graphics processing unit (GPU). The GPU includes means for executing a producer shader that produces graphics data, and means for storing the graphics data produced by the producer shader in a storage location of the first buffer. The GPU also includes, upon completion of the production of the graphics data, means for storing, with the producer shader executing on the GPU, a value indicative of an amount of the graphics data produced by the producer shader in a storage location of the second buffer.","In another example, this disclosure describes a non-transitory computer-readable storage medium. The non-transitory computer-readable storage medium includes instructions that cause one or more processors to execute, with a graphics processing unit (GPU), a producer shader that produces graphics data, and store, with the GPU, the graphics data produced by the producer shader in a storage location of a first buffer. The instructions also include instructions to, upon completion of the production of the graphics data, store, with the producer shader executing on the GPU, a value indicative of an amount of the graphics data produced by the producer shader in a storage location of a second buffer.","The details of one or more examples are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description and drawings, and from the claims.","In general, this disclosure relates to synchronization of various processes of a graphics processing unit (GPU). The techniques of this disclosure are generally applicable to video devices such as media players, set-top boxes, wireless handsets such as mobile telephones, personal digital assistants (PDAs), desktop computers, laptop computers, gaming consoles, display devices, televisions, and the like.","To process graphics data, a GPU initiates, e.g., executes, different shader programs. In some instances, graphics data produced by one shader program is consumed by another shader program. For example, a geometry shader may receive graphics data and produce graphics data for a plurality of primitives such as coordinates of vertices of the primitives and color values and other attributes for the vertices of the primitives. A pixel shader may receive the graphics data for the plurality of primitives and perform graphics processing on the plurality of primitives such as shading, illuminating, and blending to render pixels for presentation on a display.","In the previous example, the geometry shader may be considered as an example of a \u201cproducer\u201d shader, and the pixel shader may be considered as an example of a \u201cconsumer\u201d shader. In some examples, the GPU may need to synchronize the producer shader and the consumer shader such that the consumer shader does not attempt to consume graphics data before the producer shader has produced the graphics data. For example, in some instances, the GPU may know ahead of time when to execute a producer shader, but may not know ahead of time how much graphics data the producer shader will produce. Because the amount of graphics data the produce shader will produce is variable, the GPU may not know ahead of time when the producer shader will complete producing the graphics data.","Moreover, in some examples, there may be multiple producer shaders and multiple consumer shaders. In some of these examples, based on the graphics data, a consumer shader may not be able to consume graphics data from one of the producer shaders until another producer shader completes producing graphics data. For example, assume that the GPU executes a first producer shader, and at a time thereafter executes a second producer shader. Due to the variability in the amount of data each producer shader produces, it may be possible for the second producer shader to complete producing graphics data before the first producer shader completes producing graphics data. However, based on the graphics data produced by each of the producer shaders, a first consumer shader may need to consume the graphics data from the first producer shader before a second consumer shader consumes the graphics data from the second producer shader.","In some examples, the device that includes the GPU may also include a producer shader storage buffer and a producer shader count buffer. The producer shader storage buffer and the producer shader count buffer may be formed within the same memory device or different memory devices.","In some examples, the producer shader storage buffer may include a plurality of storage locations. The GPU may assign each storage location to one producer shader. Each producer shader may store its produced graphics data into its assigned storage location within the producer shader storage buffer. For example, graphics data produced by a first producer shader may be stored in the first storage location, and graphics data produced by the second producer shader may be stored in the second storage location, and so forth. In this example, the GPU may have assigned the first storage location to the first producer shader, the second storage location to the second producer shader, and so forth (for additional producer shaders).","The size of each of the storage locations, e.g., the amount of graphics data each storage location can store, may be based on the maximum amount of graphics data the producer shaders can produce. For example, the GPU may not know ahead of time how much graphics data a producer shader will produce; however, the GPU may know ahead of time the maximum amount of graphics data the producer shaders will produce. As one example, the maximum amount of graphics data that any producer shader may produce is 4 kilo-bytes (KB). Accordingly, in this example, for every producer shader that the GPU executes, the GPU may assign that producer shader a 4 KB storage location within the producer shader storage buffer to store the graphics data produced by that producer shader.","The producer shader count buffer may also include a plurality of storage locations. The GPU may assign each storage location within the producer shader count buffer to each producer shader. Because the GPU assigns a storage location within the producer shader count buffer and a storage location within the producer shader storage buffer to a producer shader, each storage location within the producer shader count buffer and each storage location within the producer shader storage buffer assigned to the same producer may be considered as corresponding to one another.","Each of the storage locations within the producer shader count buffer may store a value indicative of the amount of graphics data stored in its corresponding storage location within the producer shader storage buffer. In other words, a storage location within the producer shader count buffer may store a value indicative of the amount of graphics data produced by the producer shader assigned to that storage location within the producer shader count buffer.","As one example, a storage location within the producer shader count buffer may store a value that indicates the number of primitives produced by a producer shader. For instance, as described above, a geometry shader may produce graphics data for a plurality of primitives. In this example, the storage location within the producer shader count buffer assigned to the geometry shader may store a value indicative of the number of primitives produced by the geometry shader. Accordingly, the storage of a value indicative of the number of primitives produced by the geometry shader in the assigned storage location within the producer shader count buffer may indicate that the geometry shader has completed the production of graphics data.","In some examples, the number of bytes of graphics data produced by the geometry shader for each primitive may be constant; however, the number of primitives produced by the geometry shader may be variable. For instance, each primitive produced by a geometry shader may be defined by 100 bytes; however, the number of primitives produced by the geometry shader may be variable.","For purposes of illustration, as an example, assume that a first producer shader, e.g., a first geometry shader, produces data for five primitives, and a second producer shader produces data for ten primitives. Also, assume that each primitive is defined by 100 bytes. In this example, the storage location within the producer shader count buffer that is assigned to the first producer shader may store the value of five, and the storage location within the producer shader count buffer that is assigned to the second producer shader may store the value of ten. Also, in this example, the storage location within the producer shader storage buffer that is assigned to the first producer shader may store 500 bytes of graphics data, e.g., 5 primitives*100 bytes per primitive, and the storage location within the producer shader storage buffer that is assigned to the second producer may store 1 kilo-byte of graphics data, e.g., 10 primitives*100 bytes per primitive.","In some of the example implementations, the producer shader may output the value indicative of the amount of graphics data stored in its assigned storage location within the producer shader storage buffer after each producer shader completes producing the graphics data. For example, as the producer shader is producing graphics data, the GPU may output the produced graphics data, for storage, to the storage location within the producer shader storage buffer that is assigned to that producer shader. After the producer shader completes producing the graphics data, the producer shader may then store the value indicative of the amount of graphics data produced by that producer shader within the storage location of the producer shader count buffer assigned to that producer shader.","There may be at least two different techniques to cause the producer shader to output the value indicative of the amount of graphics data produced by the producer shader until after the producer shader completes producing the graphics data. As one example, the producer shader may be designed to maintain a counter value that indicates the amount of primitives that the producer shader produced. For instance, a programmer of the producer shader may write source code for the producer shader, and part of the source code may be instructions to cause the producer shader to maintain the counter value that indicates the amount of primitives that the producer shader produced.","A compiler may compile the source code that includes the instructions for the counter value to generate object code. The instructions of the source code, applied as compiled object code, may cause the producer shader, when executed, to increment its counter value after every primitive it produces. After the producer shader completes producing the graphics data, the producer shader may output the counter value to the storage location within the count buffer assigned to that producer shader. For example, the source code may include instructions that cause the producer shader, when executed by the GPU, to output the counter value to the storage location within the count buffer assigned to that producer shader after the producer shader completes producing the graphics data.","As another example, it may be possible for producer shader programs to not include instructions for the counter in the source code. For example, the source code for some legacy producer shader programs may not include instructions for the counter value, or instructions to output the counter value after completion of the production of the graphics data. In such examples, the compiler may be developed such that it is capable of inserting object code instructions, during the compiling, that cause the producer shader to maintain the counter value, and output the counter value indicative of the amount of produced graphics data after the producer shader completes the production of the graphics data.","For instance, a compiler, executing on a processor other than the GPU, may be configured to compile the source code of each producer shader, and may be configured to generate instructions, e.g., the object code of the producer shader, that are executable by the GPU, and cause the GPU to perform functions of the producer shader. In generating the instructions of the producer shader, e.g., the object code of the producer shader, the compiler may include instructions that cause the producer shader, when executed, to maintain a counter value that indicates the amount of primitives that the producer shader produced, in addition to the instructions that cause the producer shader, when executed, to perform functions of the producer shader. The compiler may also include instructions in the object code of the producer shader that causes the producer shader to output the counter value, included in the producer shader, to the storage location within the count buffer assigned to that producer shader after the producer shader completes producing the graphics data","In this manner, even in examples where the source code of the producer shader does not include the counter value (e.g., instructions for the counter value), aspects of this disclosure may allow for a compiler to include instructions for generation of the counter value into the object code of the producer shader. For instance, the compiler may compile the source code of the producer shader to generate the object code. In the process of generating the object code, the compiler may include the instructions for the counter value into the object code. As indicated above, the counter value may count the amount of graphics data produced by the producer shader while the producer shader is producing the graphics data.","The GPU may execute consumer shaders based on the count value stored in each of the storage locations of the producer shader count buffer. In some examples, the GPU may execute one consumer shader for each count value. For example, if a storage location in the producer shader count buffer stored the count value of five, the GPU may execute five consumer shaders to process the graphics data stored in a corresponding storage location within the producer shader storage buffer.","In some examples, the producer shader count buffer may be considered as an ordered producer shader count buffer. For example, the GPU may assign a first storage location within the producer shader count buffer to a first producer shader whose graphics data should be consumed before graphics data from any other producer shader is consumed. The GPU may assign a second storage location within the producer shader count buffer to a second producer shader whose graphics data should be consumed after the first producer shader and before the graphics data from other producer shaders is consumed, and so forth.","In this manner, the GPU may be able to execute consumer shaders when the graphics data is ready to be consumed, rather than executing consumer shaders before the graphics data is ready to be consumed. As one example, for illustration purposes, assume that the GPU executes a first producer shader, and a time thereafter executes a second producer shader. In this example, the first producer shader is assigned to a first storage location within the count buffer, and the second producer shader is assigned to a second storage location within the count buffer. Further assume that the graphics data from the first producer shader should be consumed before the graphics data from the second producer shader.","In this example, the second producer shader completed producing graphics data before the first producer shader. Accordingly, the second storage location within the producer shader count buffer stored a value before the first storage location within the producer shader count buffer. Because the GPU may know, e.g., based on the order in which it executed the first and second producer shaders, that graphics data produced by the first producer shader should be consumed before the graphics data produced by the second producer shader, in this example, the GPU may withhold from executing consumer shaders until the first storage location within the producer shader count buffer stores a value. As described above, storage of a count value, e.g., the value indicative of the amount of produced graphics data, within a storage location of the producer shader count buffer indicates that the producer shader assigned to that storage location completed producing graphics data.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1","b":["10","10","10","10","10","10","10"]},"Examples of GPU  include, but are not limited to, a digital signal processor (DSP), a general purpose microprocessor, an application specific integrated circuit (ASIC), a field programmable logic array (FPGA), or other equivalent integrated or discrete logic circuitry. As illustrated in , GPU  may include controller , geometry shader count buffer , geometry shader buffer , and consumption count buffer . Also, as illustrated in , GPU  may execute one or more instances of vertex shaders , geometry shaders , and pixel shaders .","GPU  may include additional units or modules that form the graphics pipeline. However, such additional units or modules are not illustrated in  for purposes of clarity. Moreover, although geometry shader count buffer , geometry shader buffer , and consumption count buffer  are illustrated as being internal to GPU , aspects of this disclosure are not so limited. In alternate examples, one or more of geometry shader count buffer , geometry shader buffer , and consumption count buffer  may be external GPU . For example, it may possible that the amount of graphics data that is to be stored in geometry shader buffer  is greater than the amount of storage space available on GPU . In these examples, geometry shader buffer  may be external to GPU . As an alternate, in some examples, it may be possible that geometry shader count buffer  and geometry shader buffer  are part of a common buffer, e.g., one buffer includes both geometry shader count buffer  and geometry shader buffer . Furthermore, consumption counter buffer  may potentially provide additional synchronization assistance to controller , as described below, but may not be necessary in every example of GPU .","Controller , of GPU , may be a hardware unit or a software unit executing on GPU . For purposes of illustration, controller  is described in the context of being a hardware unit. Controller  may determine when GPU  should execute one or more vertex shaders , geometry shaders , and pixel shaders . Controller  may also determine how many instantiations of vertex shaders , geometry shaders , and pixel shaders  GPU  should execute.","Vertex shaders , geometry shaders , and pixel shaders  may be software units executing on GPU . For purposes of illustration, vertex shaders , geometry shaders , and pixel shaders  are illustrated as residing within GPU . However, this is to illustrate that vertex shaders , geometry shaders , and pixel shaders  are executed by GPU . The instructions for vertex shaders , geometry shaders , and pixel shaders  may be stored in a storage device that is external to GPU . For example, the compiled object code or source code for vertex shaders , geometry shaders , and pixel shaders  may be stored in a storage device that is external to GPU .","It should be understood that vertex shaders , geometry shaders , and pixel shaders , as described in this disclosure, may generally take the form of functional units executed by GPU . Such functional units are described separately to highlight particular functional aspects of the shaders, and do not necessarily imply that such aspects must be structured, arranged or coded separately. Accordingly, such functional aspects may be formed integrally or separately, executed on one GPU or multiple GPUs, or multiple GPU cores, and the description should not be considered limiting as to the implementation of such functional aspects.","In some examples, controller  may receive attributes of an image that is to be displayed on a display. For example, a processor (not shown) external to GPU  may generate an image to be displayed on the display. The processor may divide the image into one or more primitives which may be polygons such as triangles, as one example. The processor may determine vertex attributes of each of the vertices of the polygons. For example, the processor may determine vertex coordinates and color values, e.g., red-green-blue (RGB) color values or luma and chroma values, of each of the vertices. The processor may transmit the vertex attributes of each of the vertices to controller  of GPU .","Controller  may determine how many instantiations of vertex shaders  should be executed by GPU  based on the, for example, the attributes received from the processor. For example, as illustrated in , GPU  may execute vertex shaders A-N. Each one of these vertex shaders A-N may perform similar functions, but on different sets of graphics data. For example, a storage device external to GPU  may store instructions for a vertex shader. GPU  may execute multiple instances of the instructions of the vertex shader, as determined by controller , which are represented as vertex shaders A-N.","In some examples, controller  may cause GPU  to execute one of vertex shaders  for each primitive. For example, controller  may cause GPU  to execute vertex shader A to process the first primitive, cause GPU  to execute vertex shader B to process the second primitive, and so forth. In this manner, GPU  may be able to execute multiple instances of vertex shaders  in parallel. However, aspects of this disclosure are not so limited. Controller  may not necessarily cause GPU  to execute one of vertex shaders  for each primitive.","Vertex shaders , when executed, may convert the received coordinates of the vertices of the polygons into coordinates of the display, and may determine light values for the vertices. For example, vertex shaders  may rotate and scale the received polygons to generate primitives. The output of vertex shaders  may be attributes of vertices of the primitives. Vertex shaders  may transmit the attributes of the vertices, as determined by vertex shaders , to geometry shaders .","Similar to vertex shaders , a storage device external to GPU  may store the instructions for a geometry shader. Controller  may determine how many instantiations of geometry shaders  GPU  should execute, which are represented as geometry shaders A-M, based on, for example, the number of primitives generated by vertex shaders . In some examples, the number of geometry shaders  that GPU  should execute may be the same as the number of vertex shaders  GPU  executed. However, aspects of this disclosure are not so limited. Geometry shaders A-M may perform similar functions, but on different data.","Each one of geometry shaders  may receive vertex attributes of vertices for a single primitive from one of vertex shaders . In some examples, geometry shaders  may further divide the single primitive into one or more primitives. For instance, geometry shader A may receive vertices of single triangle, and may divide the single triangle to produce five triangles. Geometry shaders  may also determine the attributes, e.g., color and coordinates, for each of the vertices of the primitives produced by geometry shaders . The primitives produced by geometry shaders , including the vertices and their corresponding attributes, may be referred to as the graphics data produced by geometry shaders .","In some examples, the number of primitives that each one of geometry shaders  may produce may be unknown. Also, it may be unknown when each one of geometry shaders  will finish producing the primitives. For example, controller  may determine that GPU  should execute two geometry shaders , e.g., geometry shader A and geometry shader B, and may cause GPU  to execute geometry shader A and geometry shader B. In this example, controller  may not know how many primitives geometry shader A will produce and how many primitives geometry shader B will produce.","Controller  may know how many bytes are used to represent a primitive based on the programming of geometry shaders . For example, each of the primitives generated by geometry shaders  may be represented by 100 bytes, e.g., the 100 bytes represent the vertices and the attributes of a primitive generated by one of geometry shaders . However, because controller  may not know how many primitives geometry shaders  may produce, controller  may not know how many total bytes geometry shaders  may produce.","Also, controller  may not know when each of geometry shaders  will complete producing the primitives. For example, controller  may cause GPU  to first execute geometry shader A and then execute geometry shader B. In this example, it may be possible that geometry shader B completes producing its primitives before geometry shader A completes producing its primitives.","These uncertainties, e.g., the amount of graphics data geometry shaders  will produce and when geometry shaders  will complete producing the graphics data, may make it difficult for controller  to determine when to execute one or more pixel shaders . Pixel shaders  may consume the graphics data, e.g., primitives and corresponding attributes, produced by geometry shaders . Accordingly, one or more of geometry shaders  may be examples of \u201cproducer\u201d shaders, and one or more pixel shaders  may be examples of \u201cconsumer\u201d shaders.","In other words, one or more producer shaders may produce graphics data that is consumed by one or more consumer shaders. One non-limiting example of the producer shaders is geometry shaders , and one non-limiting example of the consumer shaders is pixel shaders . Although examples described in this disclosure describe geometry shaders  as being producer shaders and pixel shaders  as being consumer shaders, aspects of this disclosure are not so limited. In general, the example techniques described in this disclosure may be extendable to any shader that produces a variable amount of graphics data, and to any shader that should consume the produced variable amount of graphics data. The example techniques described in this disclosure may be extendable to any graphics system where synchronization of execution of producer and consumer shaders may be desirable.","It may be advantageous for GPU  to execute one or more pixel shaders  after the data that is to be consumed by each one of the one or more pixel shaders  is available. For example, if controller  caused GPU  to execute one or more pixel shaders  before graphics data that is to be consumed by the executed pixel shaders  is available, then these executed pixel shaders  may remain idle, e.g., in a \u201cbusy wait\u201d state, until the graphics data that is to be consumed is available. In the \u201cbusy wait\u201d state, the executed pixel shaders  remain in a loop waiting for the graphics data that is to be consumed, exit the \u201cbusy wait\u201d state when graphics data becomes available, and then consume the graphics data. The \u201cbusy wait\u201d state may be undesirable because hardware units of GPU , such as registers or allocated memory, which are to be used by the executed pixel shaders  when consuming the graphics data, are unavailable for other tasks while the executed pixel shaders  are waiting for graphics data to consume.","Some of the example techniques described in this disclosure may allow controller  to synchronize execution of one or more pixel shaders  such that GPU  executes one or more pixel shaders  after the graphics data that is to be consumed by the one or more pixel shaders  is available. As illustrated in , GPU  may include geometry shader count buffer . Geometry shader count buffer  may include a plurality of storage locations. For example, geometry shader count buffer  may be registers or part of the local memory, e.g., an internal cache, of GPU . In some examples, controller  and GPU  may be able to access the contents of geometry shader count buffer  relatively quickly without requiring access through an external system bus. As described above, in some examples, geometry shaders  may be examples of producer shaders. Accordingly, geometry shader count buffer  may be referred to as a producer shader count buffer.","Controller  may assign each of the plurality of storage locations of geometry shader count buffer  to each of the executed geometry shaders . For example, controller  may assign the first storage location of geometry shader count buffer  to one of the executed geometry shaders , assign the second storage location of geometry shader count buffer  to another one of the executed geometry shaders , and so forth. Each one of the executed geometry shaders  may store a value indicative of the amount of graphics data it produced into its assigned storage location of geometry shader count buffer . As one example, the value indicative of the amount of graphics data produced by one of the executed geometry shaders  may be a value of the amount of primitives produced by that one of geometry shaders .","In some examples, each one of the executed geometry shaders  may store the value indicative of the amount of graphics data produced by that one of geometry shaders  after it completes the production of the graphics data. For example, as illustrated in , geometry shaders  may output their produced graphics data to geometry shader buffer  as it is being produced. For example, geometry shader A may produce three primitives, and may output the graphics data of each primitive to geometry shader buffer  after it completes the production of graphics data for each primitive. Geometry shader A may then store the value of three (designating three primitives as output data) in the storage location of geometry shader count buffer  assigned to geometry shader A after geometry shader A completes the production of graphics data for the third primitive.","In some examples, geometry shaders  may be tasked with storing the value indicative of the amount of produced graphics data because geometry shaders  may be operable to count the amount of produced graphics data, e.g., count the number of produced primitives. Otherwise, another unit, such as controller  may be required to track the amount of primitives produced by geometry shaders  which may be inefficient and may unnecessarily consume processing power.","Also, as indicated above controller  may not know how many primitives geometry shaders  may produce. Accordingly, in some examples, geometry shaders  may be well suited to store the value indicative of the amount of produced graphics data because geometry shaders  will know when they have completed the production of graphics data.","For instance, in this example, after geometry shader A completes production of the graphics data of the first primitive or the second primitive, geometry shader  may not yet store a value indicative of the amount of graphics data produced by geometry shader . Rather, geometry shader A may wait until it has completed the production of the graphics data for all three primitives before storing a value indicative of the amount of graphics data produced by geometry shader A. Accordingly, the storage of a value indicative of the amount of produced graphics data in a storage location of geometry shader count buffer  may indicate that the geometry shader of geometry shaders  assigned to that storage location of geometry shader count buffer  has completed the production of its graphics data.","There may be at least two techniques to ensure that the executed geometry shaders  do not store a value indicative of the amount of produced graphics data until the completion of the production of the graphics data. As one example technique, geometry shaders  may be designed with a counter. For example, a programmer writing the source code for geometry shaders  may include instructions within the source code for geometry shaders  to maintain a counter.","A compiled version of the source code may cause geometry shaders  to increment their counter values after production of each primitive to indicate the amount of graphics data produced by geometry shaders , e.g., the number of produced primitives. The source code may also include instructions that cause geometry shaders  to output the counter value to their assigned storage locations within geometry shader count buffer  after geometry shaders  complete production of the graphics data.","However, in some examples, it may be possible that geometry shaders  were not designed with a counter, e.g., the counter is not part of the source code of geometry shaders . For example, source code for legacy geometry shaders  may not have been designed with the counter. In these instances, a compiler may be designed to include the counter within geometry shaders . For example, a processor (not shown) may be executing a compiler that compiles the source code for a geometry shader to generate object code that is executable by GPU . Instantiations of the compiled geometry shader may be geometry shaders . During the compilation, the compiler may include instructions into the object code of the geometry shader to maintain a counter that increments after the executed geometry shaders  produce a primitive. The compiler may also include instructions in the object code of the geometry shader to store the counter value in the assigned storage location within geometry shader count buffer  after completion of the production of the graphics data. In this manner, the executed geometry shaders  may be able to store a value indicative of the amount of produced graphics data even when geometry shaders  were not designed with a counter, e.g., even where the counter value is not part of the source code for geometry shaders .","In either of the above example techniques, the compiler may compile the source code to generate object code for geometry shaders  that is executable by GPU . In the first example technique, the source code for geometry shaders  may already include instructions to maintain a counter, and may also include instructions to cause geometry shaders  to output the counter value at the completion of the production of the graphics data. The compiler may compile the source code instructions for the counter, and the instructions that cause geometry shaders  to output the counter value at the completion of the production of the graphics data to generate the executable object code.","In the second example technique, the source code for geometry shaders  may not include instructions to maintain a counter, and may not include instructions to cause geometry shaders  to output the counter value at the completion of the production of the graphics data. In this example, the compiler may be designed to proactively include object code instructions, as an add-in to the object code, for the counter and object code instructions that cause geometry shaders  to output the counter value at the completion of the production of the graphics data. In this manner, even for legacy geometry shaders , the compiler may be able to generate object code, executable by GPU , that causes geometry shaders  to maintain the counter and output the counter value at the completion of the production of the graphics data.","Controller  may determine how many pixel shaders  to execute based on the values stored in geometry shader count buffer . For example, similar to vertex shaders  and geometry shaders , a storage device external to GPU  may store instructions for a pixel shader, e.g., object or source code for the pixel shader. Controller  may execute one or more instances of pixel shaders , represented as pixel shaders A-X. Pixel shaders  may perform similar functions, but on different graphics data. Pixel shaders  may receive the primitives produced by geometry shaders  and perform one or more functions such as rasterizing, shading, blending, illuminating, and other graphics related functions on the received primitives. The output of pixel shaders  may be the pixel values for the pixels that are to be displayed on the display.","Controller  may determine how many instances of pixel shaders  to execute based on the values stored in geometry shader count buffer . As one example, controller  may execute one of pixel shaders  for each primitive generated by each of geometry shaders . For instance, assume that the first storage location of geometry shader count buffer  stored the value of five, the second storage location of geometry shader count buffer  stored the value of six, the third storage location of geometry shader count buffer  stored the value of ten, and the fourth storage location of geometry shader count buffer  stored the value of one. Also, assume that the first through the fourth storage locations of geometry shader count buffer  are assigned to geometry shaders A-D, respectively.","In this example, controller  may execute five instances of pixel shaders  that each consume the graphics data of one of the five primitives produced by geometry shader A. Controller  may then execute six instances of pixel shaders  that each consume the graphics data of one of the six primitives produced by geometry shader B, then execute ten instances of pixel shaders  that each consume the graphics data of one of the ten primitives produced by geometry shader C, followed by execution of one instance of pixel shaders  that consumes the graphics data of the one primitive produced by geometry shader D.","Controller  need not necessarily wait until the completion of the execution of the first instances of pixel shaders  before beginning the execution of the next instances of pixel shaders . For example, controller  may not wait until the completion of the execution of the first five instances of pixel shaders  before beginning the execution of the next six instances of pixel shaders  in the previous example. Controller  may execute the first instances of pixel shaders , and, in some examples, while the first instances of pixel shaders  are executing, may begin the execution of the next instances of pixel shaders . In other words, GPU  may execute multiple instances of pixel shaders  in parallel, in some examples.","In some examples, graphics data generated by one of geometry shaders  may need to be consumed before graphics data from another one of geometry shaders . For example, two geometry shaders of geometry shaders  may produce graphics data for overlapping primitives. In this example, the graphics data for the overlapped primitive may need to be consumed before the graphics data for the overlapping primitive so that pixel shaders  can properly blend the colors of the overlapping and overlapped primitives. However, it may be possible that the geometry shader of geometry shaders  that produced the overlapping primitive completed production of its primitives before the geometry shader of geometry shaders  that produced the overlapped primitive completed production of its primitives.","To ensure that graphics data produced by geometry shaders  is consumed in proper order, geometry shader count buffer  may function as an ordered count buffer. For instance, controller  may assign a storage location, e.g., the first storage location, within geometry shader count buffer  to a first one of geometry shaders  whose graphics data should be consumed before graphics data from any other geometry shaders  is consumed. Controller  may assign another storage location, e.g., the second storage location, within geometry shader count buffer  to a second one of geometry shaders  whose graphics data should be consumed after the first one of geometry shaders  and before the graphics data from any other geometry shaders  is consumed, and so forth.","With an ordered count buffer, controller  may ensure that it executes pixel shaders  to consume the graphics data in the order in which it should be consumed. For example, controller  may monitor the values stored in the storage locations within geometry shader count buffer . Controller  may wait to execute one or more pixel shaders  until the storage location within geometry shader count buffer , which is assigned to the geometry shader of geometry shaders  whose graphics data should be consumed first, stores a value indicative of the produced graphics data.","In some instances, it may be possible that a storage location within geometry shader count buffer  stores a value indicative of the amount of produced graphics data before a storage location within geometry shader count buffer , which is assigned to the geometry shader of geometry shaders  whose graphics data should be consumed first, stores a value indicative of the amount of produced graphics data. In these instances, controller  may not execute one or more pixel shaders  until after the storage location within geometry shader count buffer  that is assigned to the geometry shader of geometry shaders  whose graphics data should be consumed first stores a value indicative of the amount of produced graphics data.","As an illustrative example, assume that GPU  executes geometry shaders A and B. Also, assume that the graphics data produced by geometry shader A should be consumed before the graphics data produced by geometry shader B. Controller  may assign the first storage location within geometry shader count buffer  to geometry shader A, and assign the second storage location within geometry shader count buffer  to geometry shader B.","In this illustrative example, geometry shader B completed producing graphics data before geometry shader A. Accordingly, the second storage location within geometry shader count buffer  may store a value indicative of the amount of graphics data produced by geometry shader B before the first storage location within geometry shader count buffer  stores a value indicative of the amount of graphics data produced by geometry shader A. Although the second storage location of geometry shader count buffer  may store a value, controller  may not yet execute one or more pixel shaders  because the graphics data produced by geometry shader A should be consumed first, and geometry shader A has not yet completed the production of graphics data. Controller  may know that geometry shader A has not yet completed the production of graphics data because the first storage location within geometry shader count buffer  has yet to store a value indicative of the amount of graphics data produced by geometry shader A. As described above, the storage locations within geometry shader count buffer  store values after their assigned geometry shaders  complete production of graphics data.","In this manner, controller  may synchronize the execution of one or more pixel shaders  and geometry shaders . For example, utilizing some of the example techniques described in this disclosure, controller  may ensure that GPU  executes one or more pixel shaders  when the graphics data is available for consumption. Also, utilizing some of the example techniques described in this disclosure, controller  may ensure that pixel shaders  do not only consume the graphics data when available, but also consume the graphics data in the order in which the graphics data should be consumed.","Consumption count buffer  may further assist controller  in synchronizing the execution of one or more pixel shaders . Similar to geometry shader count buffer , consumption count buffer  may be registers or part of the local memory, e.g., an internal cache, of GPU . Consumption count buffer  may not be necessary in every example of GPU .","Consumption count buffer  may function as a counter-of-counters. For example, consumption count buffer  may store a value that, in some instances, indicates how many geometry shaders  have produced graphics data that is yet to be consumed. The value of consumption count buffer  may initially be zero. Controller  may increment the value of consumption count buffer  when a geometry shader of geometry shaders  stores a value indicative of the amount of produced graphics data in its assigned storage location within geometry shader count buffer . Controller  may decrement the value of consumption count buffer  after the graphics data produced by a geometry shader of geometry shaders  is consumed.","In some examples, controller  may increment the value of consumption count buffer  after the geometry shader of geometry shader  whose graphics data should be consumed first stores a value indicative of the amount of produced graphics data in its assigned storage location within geometry shader count buffer . For instance, keeping with the illustrative example above, if geometry shader B stores a value in geometry shader count buffer  before geometry shader A, then controller  may not yet increment the value of consumption count buffer . Then, when geometry shader A stores a value in geometry shader count buffer , controller  may increment the value of consumption count buffer  from zero to two.","Controller  may monitor the value stored in consumption count buffer  to determine which storage locations of the ordered geometry shader count buffer  store values indicative of produced graphics data. For example, if consumption count buffer  stored the value of six, then controller  may know that the first six storage locations of geometry shader count buffer  store values. Controller  may then know that controller  should now begin the execution of sufficient pixel shaders  to consume the graphics data produced by six geometry shaders .","As illustrated in , geometry shaders  may output their produced graphics data to geometry shader buffer . Geometry shader buffer  may be referred to as a producer shader buffer because geometry shader  may be examples of producer shaders. Although  illustrates geometry shader buffer  as being a part of GPU , aspects of this disclosure are not so limited. In some examples, the amount of graphics data that geometry shader buffer  should store may be greater than the amount of storage space available on GPU . In these examples, geometry shader buffer  may be external to GPU , and may reside in a storage device that GPU  can access with a system bus.","Geometry shader buffer  may include a plurality of storage locations. Each of the storage locations may store graphics data produced by each of the executed geometry shaders . For example, controller  may assign the first storage location of geometry shader buffer  to geometry shader A, the second storage location of geometry shader buffer  to geometry shader B, and so forth. Each one of geometry shaders  may output their produced graphics data to their assigned storage location within geometry shader buffer  as they are producing the graphics data.","For example, if geometry shader A produces five primitives, then geometry shader A may output the graphics data for the first primitive to the first storage location of geometry shader buffer  after geometry shader A produces the graphics data for the first primitive, followed by storing the graphics data for the second primitive in the first storage location of geometry shader buffer , and so forth. As described above, while geometry shader A may output its produced graphics data to the first storage location of geometry shader buffer  as it is producing the graphics data, geometry shader A may not output the value indicative of the amount of produced data to its assigned storage location in geometry shader count buffer  until after geometry shader A completes the production of the graphics data for all five primitives.","In some examples, although controller  may not know how much graphics data each of the geometry shaders  may produce, controller  may know ahead of time the maximum amount of graphics data each geometry shaders  may produce. For example, each one of geometry shaders  may be designed such that they are limited in the total amount of graphics data they can produce. The size of the storage locations of geometry shader buffer , e.g., the amount of graphics data that each storage location of geometry shader buffer  can store, may be equal to the maximum amount of graphics data that each one of geometry shaders  can produce.","As one example, the maximum amount of graphics data that each one of geometry shaders  can produce may be 4 kilo-bytes (KB), although aspects of this disclosure are not so limited. In this example, the size of the storage locations of geometry shader buffer  may be 4 KB.","In some examples, the graphics data stored in the storage locations of geometry buffer  may be \u201csparsely populated.\u201d For instance, in some examples, each primitive generated by each of geometry shaders may be represented by 100 bytes. If one of geometry shaders  produces five primitives, then the storage location of geometry buffer  assigned to that one of geometry shaders  may store 500 bytes, e.g., 5 primitives*100 bytes per primitive. Therefore, in this example, one of geometry shaders  stored 500 bytes in a storage location of geometry shader buffer  that can store up to 4 KB. Because the storage location of geometry buffer  stores one-eighth of the total amount of data that it can store, e.g., 500 bytes divided 4 KB, the data within the storage location of geometry buffer  may be considered as being sparely populated, in this example.","Each one of pixel shaders  may consume the graphics data stored in storage locations of geometry shader buffer . For instance, assume that the graphics data produced by geometry shader A should be consumed before the graphics data from any other one of geometry shaders . Also, assume that controller  assigned the first storage location of geometry shader count buffer  to store the value indicative of the amount of graphics data produced by geometry shader A. In this example, after geometry shader A stores the value indicative of the amount of produced graphics data in the first storage location of geometry shader count buffer , controller  may cause GPU  to execute one or more pixel shaders  that consume the graphics data from the storage location of geometry shader buffer  assigned to geometry shader A.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 2","FIG. 2","FIG. 1","FIG. 2"],"b":["26","26","26","28","10","32","24","36","38","40","10","26","10","10"]},"Although processor  and GPU  are illustrated as separate units, aspects of this disclosure are not so limited. In some examples, processor  and GPU  may be formed in a common integrated circuit (IC). Processor  and GPU  may each include a single processor core or multiple processor cores.","Device  may include additional modules or units not shown in  for purposes of clarity. For example, device  may include a speaker and a microphone, neither of which are shown in , to effectuate telephonic communications in examples where device  is a mobile wireless telephone, or a speaker where device  is a media player. Furthermore, the various modules and units shown in device  may not be necessary in every example of device . For example, user interface  and display  may be external to device  in examples where device  is a desktop computer or other device that is equipped to interface with an external user interface or display.","Examples of processor  include, but are not limited to, a DSP, a general purpose microprocessor, an ASIC, a FPGA, or other equivalent integrated or discrete logic circuitry. Storage device  may comprise one or more computer-readable storage media. Examples of storage device  include, but are not limited to, a random access memory (RAM), a read only memory (ROM), an electrically erasable programmable read-only memory (EEPROM), CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer, a processor, or a GPU. In some example implementations, storage device  may include instructions that cause processor  and\/or GPU  to perform the functions ascribed to processor  and GPU  in this disclosure.","Storage device  may, in some examples, be considered as a non-transitory storage medium. The term \u201cnon-transitory\u201d may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However, the term \u201cnon-transitory\u201d should not be interpreted to mean that storage device  is non-movable. As one example, storage device  may be removed from device , and moved to another device. As another example, a storage device, substantially similar to storage device , may be inserted into device . In certain examples, a non-transitory storage medium may store data that can, over time, change (e.g., in RAM).","Examples of user interface  include, but are not limited to, a trackball, a mouse, a keyboard, and other types of input devices. User interface  may also be a touch screen and may be incorporated as a part of display . Transceiver module  may include circuitry to allow wireless or wired communication between device  and another device or a network. Transceiver module  may include modulators, demodulators, amplifiers and other such circuitry for wired or wireless communication.","As illustrated in , storage device  may store instructions for vertex shader , geometry shader , and pixel shader , e.g., source code and\/or object code. GPU  may execute multiple instances of the instructions of vertex shader , geometry shader , and pixel shader  for the instantiations of vertex shaders A-N, geometry shaders A-M, and pixel shaders A-\u00d7, as illustrated in .","Also, in some examples, storage device  may include geometry shader buffer . As described above, geometry shader buffer  may store the graphics data produced by one or more of geometry shaders A-M. Storage device  may include geometry shader buffer  because, in some examples, it may be possible that the amount of graphics data that is to be stored in geometry shader buffer  is greater than the amount of storage space available on GPU .","Storage device  may, in some examples, store instructions for compiler . However, storage of instructions for compiler  may not be necessary in every example of device . Compiler  may, in some example implementations, include instructions that when executed cause processor  to include a counter within the instructions of geometry shader . For example, processor  may execute the instructions of compiler , as illustrated in , to compile geometry shader , e.g., receive source code for geometry shader  and generate object code for geometry shader . Processor  may then store the compiled geometry shader  in storage device . When GPU  executes one or more instances of geometry shader , e.g., geometry shaders A-M, each one of geometry shaders A-M may increment their respective counters that indicate an amount of graphics data produced by each one of geometry shaders A-M.","GPU , via one or more pixel shaders , may output the pixel values for an image that is to be displayed on display . In some examples, GPU  may output the pixel values directly to display . In some alternate examples, GPU  may output the pixel values of the image to display buffer . Display buffer  may temporarily store the pixel values of image until the entire image is rendered. Display buffer  may be considered as an image frame buffer. Display buffer  may then transmit the rendered image to be displayed on display . Display  may comprise a liquid crystal display (LCD), an organic light emitting diode display (OLED), a cathode ray tube (CRT) display, a plasma display, or another type of display device.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 3","FIGS. 1 and 2"],"b":"10"},"GPU  may execute a producer shader that produces graphics data (). Examples of the producer shader include one or more geometry shaders . As described above, the one or more geometry shaders may each receive one primitive from one or more vertex shaders  and divide the one primitive into one or more primitives. The graphics data produced by the producer shader may be attributes of the vertices of the produced one or more primitives, e.g., color and coordinate values for the vertices of the produced one or more primitives.","GPU  may store the produced graphics data in a storage location of a first buffer (). One example of the storage location of the first buffer may be a storage location within a producer shader buffer. An example of the producer shader buffer may be geometry shader buffer . In the example where geometry shader buffer  is part of storage device , GPU  may access geometry shader buffer  via a system bus.","Upon completion of the production of graphics data, the producer shader may store a value indicative of the amount of graphics data produced by the producer shader in a storage location of a second buffer (). An example of the storage location within the second buffer may be a storage location within a producer shader count buffer. One example of the producer shader count buffer may be geometry shader count buffer . One example of the value indicative of the amount of graphics data produced by the producer shader may be an amount of primitives produced by the producer shader. In some examples, the producer shader may be suitable for storing the number of produced primitives because the producer shader may know when it has completed the production of the graphics data. However, other units, such as controller  may not know when the producer shader will complete the production of graphics data.","After storage of the value indicative of the amount of graphics data produced by the producer shader, GPU  may execute one or more consumer shaders (). By executing the one or more consumer shaders after storage of the value indicative of the amount of graphics data produce by the producer shader, controller  may ensure that the one or more consumer shaders are not executed before graphics data to be consumed by the one or more consumer shaders is available. Examples of the consumer shaders include the one or more pixel shaders .","In one or more examples, the functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored as one or more instructions or code on a computer-readable medium. Computer-readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and\/or data structures for implementation of the techniques described in this disclosure. By way of example, and not limitation, such computer-readable media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage or other magnetic storage devices, or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and Blu-ray disc where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.","The code may be executed by one or more processors, such as one or more digital signal processors (DSPs), general purpose microprocessors, application specific integrated circuits (ASICs), field programmable logic arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. Accordingly, the term \u201cprocessor,\u201d as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. Also, the techniques could be fully implemented in one or more circuits or logic elements.","The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (i.e., a chip set). Various components, modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined in a hardware unit or provided by a collection of interoperative hardware units, including one or more processors as described above, in conjunction with suitable software and\/or firmware.","Various examples have been described. These and other examples are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 3","FIG. 1"]}]},"DETDESC":[{},{}]}
