---
title: Service level executable environment for integrated PSTN and IP networks and call processing language therefor
abstract: A service level executable environment (SLEE) in a telecommunications network linking a PSTN and a packet (e.g., IP) network is provided. The SLEE includes a scripting language, a compiler adapted to compile scripts written with said scripting language into executables, and a plurality of dynamically loaded shared libraries, wherein the dynamically loaded shared libraries are distributed over the IP network and executables can utilize dynamically loaded shared libraries from different locations in the IP network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07934206&OS=07934206&RS=07934206
owner: Convergent Networks, Inc.
number: 07934206
owner_city: Lowell
owner_country: US
publication_date: 20010209
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of provisional applications U.S. Ser. No. 60\/182,111 filed Feb. 11, 2000.","1. Field of the Invention","This invention relates broadly to telecommunications. More particularly, this invention relates to a switching infrastructure and developer environment for telecommunication applications.","2. State of the Art","For much of the history of the telecommunications industry, telephone calls have been connected primarily via the public switch telephone network (PSTN), a point-to-point telecommunications network. The PSTN includes end office (EO) and access tandem (AT) switches. The EO switches connect a local carrier to a subscriber (a party capable of malting or receiving a call), and the AT switches connect local carriers and other intermediary AT switches together. In the PSTN, a path (circuit) is defined between the calling party and the called party through the EO and AT switches, and the call is connected over this path. For a long time, signaling associated with the call (e.g., information about the route through various switches to the called party) and the call content (e.g., analog voice signals) were sent over the same path in the network.","The PSTN was designed to handle voice calls having an average duration of five minutes. Due to a change in calling patterns, in which the average call has become longer, the PSTN network has become quite congested. The reason for the change in calling patterns is, at least in part, a result of the popularity of the Internet and an associated increased data traffic from modem use. Modem calls are typically relatively longer than voice calls, averaging thirty minutes in duration.","As a partial solution to the congestion, the SS7 (signaling system 7) system was deployed. In SS7, the signaling for setting up a path for the call is sent \u201cout-of-band\u201d (over a discrete network), and the call is then connected via a path through the legacy PSTN. While this removes the signaling traffic from the PSTN network switches, even this system does not satisfactorily relieve the PSTN network congestion.","In the 1980's, long distance telecommunication was deregulated. New long distance companies, such as MCI and Sprint, among others, were granted equal access to end-office (EO) switches at the local exchange carrier central office in order to compete directly with AT&T by installing their own access tandem (AT) switches and their own long distance network.","With the Telecommunications Act of 1996, competition was opened for local telephone service, giving rise to competitive local exchange carriers (CLECs). CLECs were permitted equal access to the AT switches of the long distance companies, and local exchanges needed to make space available in their central offices for a competitor's EO switch. As such, the regulatory guidelines that governed the separation of functionalities which previously existed between an AT exchange (switch) and an equal access EO exchange have for the most part diminished. Therefore, switching systems residing in the local exchange today typically have both end-office and access tandem functionality; hence, the term EO\/AT.","Given the increase in competition created by deregulation, the cost to the consumer to make a voice call, both local and long distance, has decreased. Consequently, the per call profit to the call provider has also decreased. As such, call providers have been eager to offer profit-making value-added enhanced services above and beyond Class 5 services such as caller-ID, three-way calling, call waiting, etc. Originally, these services were implemented on the EO switches; a typical implementation occurred on the EO switch of the called party. The implementation was \u201chard coded\u201d into the switch, and a call provider was tied to the EO-switch vendor for services.","It was therefore desired to implement enhanced services in a manner which was both effective and did not rely on the switch vendor for services. To meet this need, the Advanced Intelligent Network (AIN) has been implemented in some areas. The AIN comprises service control points in the SS7 network and operates to move call services away from the traffic switches to de-couple service logic from the switching function and provide an enhanced system of service distribution and third party service suppliers. However, the AIN system has been hindered by SS7 interoperability issues with respect to different Tier 1 International Carriers and also due to vendor-specific implementations. That is, an implementation of the AIN system is confined to a particular geographic area and\/or vendor. For example, in Europe there are multiple carriers, each using a different and incompatible AIN protocol.","During the 1990's, the Internet grew at a tremendous rate. Traffic over the Internet is transferred in a uniform manner using Internet Protocol (IP). The IP network therefore has an architecture adapted to provide communication and services over a single and uniformly compatible system worldwide. As such, the IP (or other packet) network has been recognized as a possible substitute for the PSTN.","However, moving from the PSTN system to an IP (or other type of packet) network would require the challenging integration of the IP network with the legacy PSTN system. This is because any change from the PSTN system would necessarily be deployed over time. In addition, the IP network is a packet-based network. This is suitable for viewing web pages on the world-wide web where timing is not critical. It would be ideal to move enhanced call services away from the EO\/AT switches and make available and distribute call services in a non-localized manner, similar to the manner in which web pages are made available. Yet, for some call services latency is critical.","Services are distinguished by class, with Class 5 service functions (e.g., three-way calling) requiring practically immediate implementation upon request and therefore residing onboard the stored program control switch (SPCS) in the PSTN. Over the years these embedded service functions have been highly optimized. In fact, it takes only 50-120 milliseconds for an SPCS to route a call to its destination from the time a user goes off-hook and dials the number, inclusive of cycling through a Class 5 feature interaction. This time measurement is referred to as the Class 5 delay budget, and is relatively immovable, as callers expect immediate response for such services. This benchmark poses significant challenges to next-generation telecommunication architecture utilizing an IP network.","When referring to \u201cnext-generation\u201d architecture, it is presumed that the application server (AS) which handles the enhanced services will reside separately from the basic call processes (BCP), or call control elements, in the network. Where the AS has been decoupled from a switch, interworking between the decoupled AS and the switch is often implemented using the H.323 Initiation Protocol (SIP). However, there is no evidence that a decoupled AS can be used in a loosely decoupled fashion to implement a Class 5 service in a production network. The Class 5 delay budget imposes an insurmountable barrier to Class 5 service distribution. As such, there is a significant difference between emulation of a Class 5 service in an offline laboratory, and actually replacing a Class 5 end-office switch delivering primary line telephone service to thousands of subscriber lines.","Moreover, once the challenge of integrating the IP and PSTN networks is accepted, it would be further beneficial to have a programming environment which is adapted to facilitate creation, deployment and distribution of enhanced services over the integrated network. Service distribution operates to relieve network congestion. Moreover, service distribution over an IP network reduces the relative high costs associated with using the PSTN for the implementation of such services.","For purposes of this disclosure, the telecommunications network(s) is often referred to using the following suggestive abstract terms: the media transport plane, the signalling and control plane, the application services plane, and the management plane. The media transport plane defines the portion of the network devoted to delivering content from one point (or multipoints) to another point (or multipoints) in the network. The signalling and control plane is primarily used to set up and tear down connections. The application services plane is the portion of the network used to deliver enhanced services. The management plane is used for billing, record keeping, provisioning, etc.","Over the last several years, the efforts of the telecommunications industry to integrate the PSTN with an IP network have been spent largely in proving out the new voice over packet switching technologies which primarily address the media transport plane. To a lesser extent, softswitches, which address the signaling and control plane in the new generation network have just come onto the horizon. This adoption cycle, albeit necessary, has continued at the expense of not realizing any significant advancements in telecommunications service delivery on a large scale during the same time period.","It is therefore an object of the invention to provide a network architecture that can be deployed in stages.","It is another object of the invention to provide a next generation network architecture that is suitable for both the PSTN and IP networks.","It is a further object of the invention to provide an integrated network that can deploy multiple types and classes of services.","It is an additional object of the invention to provide an integrated network that can implement Class 5 services and meet the Class 5 delay budget, i.e. a method for implementing service execution functional entities in a tightly-coupled fashion in relation to a softswitch, such that the service execution functional entities operate in a similar fashion to that of an SPCS.","It is also an object of the invention to provide a Class 5 end-office switching in a next generation IP network, i.e. a method for implementing service execution functional entities in a loosely-coupled fashion in relation to a softswitch, such that the service execution functional entities operate in a similar fashion to fully detached Application Servers on an IP network (such as the Internet).","It is still another object of the invention to provide an integrated system capable of distributing enhanced services over the network.","It is still a further object of the invention to provide an integrated network in which services are distributed in a manner which permits service latency requirements to be met, i.e. a method for providing location transparency or abstraction of the distribution of the service execution functional entities from its users.","It is yet another object of the invention to provide a developer environment for creating, deploying, and distributing services across a next generation IP network.","It is another object of the invention to provide a method for intercommunication between service execution functional entities and a softswitch.","It is also an object of the invention to provide a method for intercommunication between individual service execution functional entities.","It is still another object of the invention to provide a method for dynamically duplicating or \u2018cloning\u2019 individual service execution functional entities such that the availability of a particular application or application feature may increase proportionally with demand.","It is yet another object of the invention to provide a client system for creating, naming, cataloguing, reusing, combining and re-combining service execution functional entities.","It is another object of the invention to provide a server system for storing service execution functional entities and for distributing executable service applications.","It is still another object of the invention to provide a client system for managing the server systems.","It is yet another object of the invention to provide client and server systems for run-time management of individual service execution functional entities.","It is another object of the invention to provide client and server systems for creating, naming, cataloging and distributing state transition tables.","In accord with these objects, which will be discussed in detail below, a next generation telecommunications network architecture according to the invention efficiently integrates and offers services in both the PSTN and an IP network. The enveloping architecture generally includes signaling gateways (SG) connected directly to the SS7 network for PSTN signaling support, one or more service creation switches (SX) coupled to each SG, and a plurality of media gateways (MG) (or broadband switches) coupled to each SX. Each MG includes hardware responsible for switching and interworking (converting signals) between the IP and PSTN networks.","The SX is preferably implemented in software and includes a media gateway controller (MGC) and a calling agent (CA). The MGC is responsible for controlling a set of endpoints across a given set of MGs, the set of endpoints comprising a domain. The CA contains the intelligence and policies used by the MGC to make routing decisions, as well as provides service interworking functionality; i.e., the CA works in conjunction with an application providing a service on a user's line. According to the invention, the SX supports both tightly coupled and loosely distributed application server (AS) functions, with the tightly coupled AS functions (such as Class 5 services) residing in the SX, and the loosely coupled AS functions (e.g., voice mail) carried out in a service level executable environment (SLEE), described below. From a network perspective, the SX provides the basic connection control function over a domain of endpoints which may be media channels in a media gateway, subscriber line terminations in a residential gateway, or digital circuits in a trunking gateway. The capability of the SX to support both tightly and loosely coupled AS functions is a critical advantage over other proposed next-generation solutions. According to the presently preferred embodiment, the SLEE carries out both loosely coupled and tightly coupled services, with a portion of the SLEE embodied in the SX.","More particularly, the SLEE includes an application creation and management environment which utilizes dynamically loaded shared libraries (DLLs) to facilitate the deployment and distribution of enhanced services over the integrated network. The SLEE has an application layer, a Soft switch interworking layer, and a Media server interworking layer, and also includes run time commands suitable for debugging application files. The SLEE receives service request messages from an SX or user agent through an API, the SLEE Library, and is responsible for communicating with the Soft switch interworking layer and the Media server interworking layer. In the interworking layers (the capability layer), the SLEE loads specific application triggering mechanisms which include a project state machine. The project state machine is a shared library loaded by the SLEE. Each project also has a different state machine that governs events at a finer level. The logic that handles each event is written in a scripting language and then compiled into the DLLs.","The SLEE can operate in a Loosely Coupled Mode, Mode 1, or a Tightly Coupled Mode, Mode 2. From the perspective of a single softswitch, it is possible to implement one SLEE operating in Mode 2 and one or more SLEEs operating in Mode 1. Furthermore, from a network perspective it is possible to implement a plurality of SLEE in either mode of operation.","When describing applications for the Decoupled Telecommunications System, there are two broad classifications, Network Applications and User Applications.","An example of a Network application is broadband access. Broadband access is a superset of functionalities that embody all of the essential capabilities of a Class 5 SPCS (EO\/AT) in the PSTN such that the User cannot distinguish between their Class 5 service delivered through a Decoupled Telecommunications System versus a Class 5 SPCS in the PSTN.","To achieve functional equivalence to the Class 5 SPCS in a Decoupled Telecommunications System, an equivalent state machine is created through the SLEE CPL and then mobilized into the softswitch. This state machine combines the Originating and Terminating basic call state machines specified by the ITU for Capability Set 2. The SLEE function which implements this composite state machine is the Basic Call Process (BCP). The BCP is a specialized implementation of the Application Services Interworking Layer. The BCP is a byproduct of the SLEE operating in mode 2. The BCP function facilitates tightly coupled interaction between the SLEE and the softswitch. The BCP is the \u2018gearbox\u2019, subject to the previous analogy. SLEE mode 2 is the appropriate operational mode for the broadband access network application because it incorporates user services which are subject to the \u2018delay budget\u2019.","An example of a User application is Unified Messaging (UM). Although UM is a relatively complex application, it mainly involves repeated request\/response pairs of user interactions where moderate delays are acceptable. SLEE mode 1 is the appropriate operational mode for the UM application because the delay budget is not an issue and the application generally involves lengthy interactive sessions between the SLEE and other distributed Application Server elements including media servers, messaging servers and web servers using protocols that are not typically supported in a softswitch.","Additional objects and advantages of the invention will become apparent to those skilled in the art upon reference to the detailed description taken in conjunction with the provided figures.","In order to facilitate understanding of the detailed description, Table 1 is provided. Table 1 defines the acronyms used in the Specification and Drawings.",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Acronym Definitions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AAL-2","ATM Adaption Layer 2"]},{"entry":[{},"AIN","Advanced Intelligent Network"]},{"entry":[{},"AP","Application"]},{"entry":[{},"API","Application Programming Interface"]},{"entry":[{},"AS","Application Server"]},{"entry":[{},"AS1, AS2","Application Service Interfaces"]},{"entry":[{},"ASI","Application Services Interworking"]},{"entry":[{},"AT","Access Tandem"]},{"entry":[{},"ATM","Asynchronous Transfer Mode"]},{"entry":[{},"BCP","Basic Call Processing"]},{"entry":[{},"BMS","Billing Management Platform"]},{"entry":[{},"CA","Call Agent"]},{"entry":[{},"CAS","Channel Associated Signaling"]},{"entry":[{},"CDR","Call Detail Record"]},{"entry":[{},"CID","Call Instance Data"]},{"entry":[{},"CLI","Command Line Interface"]},{"entry":[{},"CPL","Call Processing Language"]},{"entry":[{},"DLL","Dynamically Loaded Shared Libraries"]},{"entry":[{},"DNS","Dynamic Naming Services or Domain"]},{"entry":[{},{},"Name Server"]},{"entry":[{},"DSLAM","Digital Subscriber Line Access"]},{"entry":[{},{},"Multiplexer"]},{"entry":[{},"EMS","Element Management System"]},{"entry":[{},"EO","End Office"]},{"entry":[{},"EO\/AT","End Office\/Access Tandem"]},{"entry":[{},"GSI","Generic Signaling Interface"]},{"entry":[{},"GW1","Gateway Interface"]},{"entry":[{},"HA","High Availability"]},{"entry":[{},"HA1","High Availability Interface"]},{"entry":[{},"HTTP","Hypertext Transfer Protocol"]},{"entry":[{},"IAD","Integrated Access Device"]},{"entry":[{},"IETF","Internet Engineering Task Force"]},{"entry":[{},"IN","Intelligent Network"]},{"entry":[{},"IP","Internet Protocol"]},{"entry":[{},"IPL","Initial Program Load"]},{"entry":[{},"ISDN","Integrated Services Digital Network"]},{"entry":[{},"ISUP","ISDN User Part"]},{"entry":[{},"ITU","International Telecommunications"]},{"entry":[{},{},"Union"]},{"entry":[{},"LAN","Local Area Network"]},{"entry":[{},"M1, M2, M3, M4","Management Interfaces"]},{"entry":[{},"MG","Media Gateway (Broadband Switch)"]},{"entry":[{},"MGC","Media Gateway Control"]},{"entry":[{},"MGCP","Media Gateway Control Protocol"]},{"entry":[{},"MIB","Management Information Base"]},{"entry":[{},"MS","Media server"]},{"entry":[{},"NCAS","Non-Channel Associated Signaling"]},{"entry":[{},"NM","Network Management"]},{"entry":[{},"O-BCSM","Originating Basic Call State Model"]},{"entry":[{},"OSI","Open Systems Interconnection"]},{"entry":[{},"OSS","Operations Support System"]},{"entry":[{},"PIM","Protocol Independent Management"]},{"entry":[{},"PRI","Primary Rate Interface"]},{"entry":[{},"PSTN","Public Switched Telephone Network"]},{"entry":[{},"S1, S2","Signaling Interfaces"]},{"entry":[{},"SCP","Service Control Point"]},{"entry":[{},"SDP","Session Description Protocol"]},{"entry":[{},"SG","Signaling Gateway"]},{"entry":[{},"SIB","Service Independent Building Block"]},{"entry":[{},"SIP","Simple Internet Protocol"]},{"entry":[{},"SLEE","Service Level Executable Environment"]},{"entry":[{},"SNMP","Simple Network Management Protocol"]},{"entry":[{},"SPCS","Stored Program Control Switch"]},{"entry":[{},"SPM","Signaling Protocol Multiplexing"]},{"entry":[{},"SS","Soft Switch"]},{"entry":[{},"SS7","Signaling System 7"]},{"entry":[{},"SX","Service Creation Switch"]},{"entry":[{},"TALI","Royalty Free Signaling Protocol"]},{"entry":[{},{},"Source Code from Tekelec"]},{"entry":[{},"T-BCSM","Terminating Basic Call State Model"]},{"entry":[{},"TCAP","Transaction Capabilities Application"]},{"entry":[{},{},"Part"]},{"entry":[{},"TCP","Terminal Control Program"]},{"entry":[{},"TDM","Time Division Multiplexing"]},{"entry":[{},"UDP","User Datagram Protocol"]},{"entry":[{},"UNI","User Network Interface"]},{"entry":[{},"VC","Virtual Channel"]},{"entry":[{},"WAN","Wide Area Network"]},{"entry":[{},"XML","Extensible Markup Language"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Turning now to , a next generation telecommunications network architecture according to the invention integrates PSTN and IP networks. The architecture generally includes signaling gateways (SG)  connected directly to the SS7 network  for PSTN signaling support, one or more service creation switches (SX)  coupled to each SG , and a plurality of media gateways (MG)  coupled to each SX .","The MG  is a broadband switch designed to support switching and interworking between traditional circuit switched network (PSTN) and broadband or \u201cpacket-based\u201d networks such as an IP network  and an ATM network  (). Generally speaking, the media gateway function is to terminate multiple physical or logical \u2018bearer\u2019 channels (typically associated with User connections), and perform inter-working between two or more transport mediums (e.g. TDM, ATM, IP). The media gateway function exists in the media transport plane. As such, the MG  includes ports (or endpoints) that when connected create a connection. Each MG has means responsible for switching and interworking (converting signals) between the IP and PSTN networks, and consequently has interfaces for both IP (packet-based) and PSTN (TDM-based) networks.","Referring to , the SX  is generally an integrated services creation softswitch platform which includes connection control, management capability, and the ability to host the basic call process of the SLEE. In this mode, it supports several high-level control domain internal functions: basic call processing (BCP) , application services interworking (ASI) , call agent (CA) , generic signaling interface (GSI) , media gateway control (MGC) , and network management (NM) .","According to the invention, the SX  also includes carrier-ready modules including Class 5 services, and is an open service creation environment  (service level executable environment or SLEE) that enables the rapid delivery of new carrier-class services and enhanced applications. Briefly, the SLEE  includes an application programming interface (API) called the SLEE Library which utilizes dynamically loaded shared libraries (DLLs) to facilitate the deployment and distribution of enhanced services which are not subject to the Class 5 delay budget over the integrated network. The basic call processing (BCP) 20 is a specialized ASI function that creates the coupling between the SX  and the SLEE . The BCP  and SLEE  intercommunicate using a special command set referred to as the SLEE library, which is described in detail below. The BCP  is modeled conceptually on the ITU Advanced Intelligent Network (AIN 0.2) basic call process functions. That is, the BCP  uses separate originating and terminating views to express a connection between half-calls. In the BCP , a two-party call is viewed as two separate half-calls each with their own connection related data (context) and status (state). The BCP  controls all calls in the SX  which originate or terminate on a subscriber line. In addition, the BCP  also controls all tandem trunk to trunk (AT to AT) calls, which do not require any feature interaction with SLEE . In summary, the BCP  emulates within the SX  all basic call control functions of EO\/AT switches currently deployed in the PSTN.","The application services interworking (ASI) function  manages the interaction between SX  and the application service (AS) functions residing in the service control domain for any non-SLEE AS functions supported by the SX . When the SLEE AS functions are implemented, the BCP  replaces the thin ASI function .","The call agent (CA)  is described by its subfunctions, which include: call admission control, call routing, call detail record (CDR) management, and database management. The call admission control determines which application service function (AS) is responsible for controlling an inbound call and selects the appropriate ASI to interface with a particular AS. Each AS must register with an SX  prior to receiving work. Call routing uses call related information to perform route table searches and returns one or multiple trunking facilities which may be used for termination. Call routing is described in more detail below. CDR management maintains the integrity of all CDR records in database , makes CDR information accessible to other functions in the SX  and periodically writes CDR data to disk. Database management maintains the integrity of all local SX database tables, and performs route table synchronization between active and standby SX systems as dynamic updates are submitted through management interfaces. Generally speaking the call agent (CA) function is to coordinate calls and caller related activities and resources. Furthermore, a call agent views a call as a transaction which can include one or many participants. A call agent provides basic call related services to one or many call parties based on their individual service policies. The call agent control function exists in the signaling and control plane.","The generic signaling interface (GSI) function  performs common channel control signal interworking between the SX and the network, specifically SS7 and ISDN PRI. The GSI  translates raw ISUP, TCAP, AIN, IN and ISDN message structures into generic primitives understood by the SX . A generic address structure is used to carry call addressing information between the SX and the SG, e.g. calling party number\/sub-address, called party number\/sub-address and destination prefix. A generic circuit information structure is used to communicate circuit connection related information between an SX  and SG , e.g. endpoint type (ISUP trunk group or ISDN access port) and circuit\/channel information.","The media gateway controller (MGC)  performs interworking between an SX  and one or more MGs , and provides termination to a collection of endpoints in one or more domains. The MGC  translates the connection status (state) and call transaction specific connection information (context), received through an MGC protocol (MGCP), into a generic set of primitives understood by other SX internal functions that may be required to facilitate the call transaction. The MGC  is also responsible for managing connections between the SX  and MGs , including such activities as endpoint audit and fail-over. Generally speaking, the media gateway controller function is to orchestrate and manipulate the connections between two or more physical or logical \u2018bearer\u2019 channels terminating on a single media gateway or terminating between two or more media gateway elements. Furthermore, a media gateway controller may also orchestrate and manipulate the connections between two or more physical or logical \u2018bearer\u2019 channels between a media gateway and a media server(s). The media gateway control function exists in the signaling and control plane.","Network management (NM)  includes a number of subfunctions related to network management access control to the SX . The subfunctions include configuration session management, alarm interface, database interface, CDR interface, and high availability (HA). The configuration session management controls one or more sessions where a network administrator or a script emulating multiple configuration instructions is submitting configuration updates to the SX  using a command line interface (CLI). The SX is preferably run on a Sun Solaris 2.8 platform. The Solstice Enterprise Agents (SEA) from Sun Microsystems provides a software development kit that enables the building of subagents to manage different subsystems, components and applications within a system in Sun Solaris environment. The alarm interface handles alarms as SNMP traps in the SX system. Traps are predefined within each component and, when the trap conditions are met, components call alarm functions within a support manager library to send out SNMP traps. The database interface is synchronized with a subscriber management portal centralized database, e.g., an ORACLE database. The CDR interface maintains all relevant switch and billing information. All records are stored in database . The SX MGC\/CA host generates raw (unformatted) CDR records for each call from its internal database. CDR data is synchronized between both an active SX system  and a standby SX system . As such, should the active SX system  become unavailable, the standby SX system is able to take over all existing operations without loss of data. The high availability (HA) function  supports redundancy in the event of a failure. As such, the HA function coordinates all internal HA related processes, monitors IP traffic and heartbeat messages over a serial link and two Ethernet interfaces, and determines when to perform failover and recovery functions. When a fail-over needs to occur (due to SX  failure), the HA operates to mediate and coordinate fail-over processes between the active SX  and standby SX systems. The HA also manages all of the data replication required to maintain all stable calls in the system. The data elements which require replication include CDR records, subscriber profile data, BCP call state information, MIB data (routing tables, IP addresses, etc.), and signaling interface call transaction related data objects in MGC and GSI. At specified intervals, a Billing and Recordkeeping Server (BRS)  polls the SX  for any new CDR records.","In view of the above described internal functions, a typical call flow through the SX  is now described. A notify message  from an MG  to the MGC  in the SX  signals a user off-hook event with the user ID (endpoint) and dialed digits attached. The MGC  makes the association between the user endpoint ID and a virtual channel (VC) address used internally in SX . The MGC  then signals the CA  on the new call at  and the CA creates a call context and a call detail record (CDR) and appends these two objects to the calling VC object. The call context contains all information about the call during its active life and is made accessible to all internal functions of the SX . The CA  coordinates with the HA function  at  to provide the status of the calling VC with the appended call context and CDR information to the standby SX at . The CA  signals the BCP  on the new call at , providing the BCP with a pointer to the calling VC object and passes control of further call processing of the line to the BCP. The BCP  notes the status of the line and checks to see if any service function is required at this stage.","Assuming the SLEE  needs to analyze the dialed destination, the BCP  uses the current status of the line at  to determine which, if any, service function (a service independent building block or SIB as defined by the ITU)  in the SLEE needs to be called. If the BCP  determines that an SIB needs to be called, the SIB is called and performed on the dialed destination based on the calling party's feature profile. The SIB returns a response to the BCP  which then updates the status of the line at . The SLEE  updates the subscriber profile data putting the dialed destination in the last number dialed field.","Based on the new line status, the BCP  signals the CA  at  to route the call to its destination. The CA  performs a route lookup and determines a preferred PSTN trunk group (e.g., ISUP or TCAP) for the call and whether idle capacity is available. The CA  coordinates with the HA function  to provide the updated status of the calling VC with the appended call context and CDR info to the standby SX at .","The CA  signals the GSI  at  to initiate a call to the user dialed destination on the preferred trunk group. Once an idle circuit in the trunk group is selected, its port id is passed back to the CA at . The CA then creates a context and CDR for the terminating connection (called VC) and appends these two objects to the called VC object.","During the destination call setup, the GSI  and MGC  exchange signals at  that coordinate the connection activity on the selected trunk group bearer channel with the MG .","Once the called party answers, the GSI  signals the CA  at . Now the calling VC and the called VC are connected and the CA  updates the BCP  at . The CA coordinates at  with the HA function  to provide the updated status of the calling VC\/called VC with the appended call context and CDR info to the standby SX . The stable call is maintained on an SX fail-over.","The CA  signals the BCP  at  with respect to the connected call, providing the BCP with a pointer to the calling\/called VC objects. The BCP  notes the status of the line and checks to see if any service function is required at this stage. In this example, it is assumed that the SLEE  is not required. The call remains connected until either party hangs up.","Assuming the called party hangs up, the GSI  signals the CA  at  of the release from the network side, which the CA acknowledges, and the CA subsequently notifies the BCP at . The CA starts a process every few seconds which writes the CDR data into the database . The CA coordinates with the HA function  at , to provide the updated status of the calling VC\/called VC with the appended call context and CDR info to the standby SX . This releases the connection resources and generates a CDR in the standby SX . On a configurable time interval, the Billing and Recordkeeping Server (BRS)  acquires any new CDR records (marked \u2018unread\u2019) from the local database  of the SX  at  ().","Referring to , the SX functions map, through interfaces, to other objects, applications, and management terminals in an IP network. The SX interfaces are grouped into the following categories: signaling interfaces S1 and S2, gateway interface GW1, application service interfaces AS1 and AS2, management interfaces M1, M2, M3, M4, and high availability interface HA1.","According to the relationship between non-channel associated signaling (NCAS) data and bearer channels, SX NCAS signaling functions can be divided into two classes: embedded and non-embedded. The embedded signaling function classification means that the signaling channel and the associated bearer channels terminate on the same piece of hardware. For example, in traditional telecommunication equipment, an ISDN D-channel is the 24th channel in a T1 (or the 30th channel in an E1) interface and all the other 23 (or 29) channels are for bearer purpose. Conversely, the non-embedded signaling classification means that the signaling channel and the bearer channels terminate on different hardware equipment, e.g. in the case of SS7 A-links which terminate on dedicated equipment such as a signaling gateway, while the mapped bearer channels terminate on a trunking gateway. Channel associated signaling (CAS) in the SX  is a subfunction of the MGC .","Signaling interface S1 represents a logical connection between the SS7 non-embedded signaling function  of the GSI  of the SX  and the signaling gateway (SG)  used to deliver ISUP, TCAP, IN and AIN protocol-related information. The TCAP\/AIN\/IN information relates to toll-free number, local number portability, and calling party name database queries.","The S1 physical interface is Ethernet over which the multilayered SX to SG protocol shown in  is implemented. In this protocol, the call signaling messages received on the signaling link from a PSTN signaling end point  are processed by the Q.931\/ISUP stack in the SG  and converted into GSI primitives (e.g. connection indication, etc.). The GSI primitives are then sent from the SG  to the SX  through the Ethernet S1. Several protocol layers are implemented between the SX  and the SG  to provide reliable and efficient transportation of the GSI primitives. First, a modified version of TALI is used as the transportation layer of the protocol between SX and SG implemented. TALI preferably runs on top of TCP\/UDP and IP. TALI is a protocol originally submitted by Tekelec to the IETF to be reviewed for adoption as a standard, but rejected as a standard. A redundancy manager layer runs over TALI, and serves to maintain two mutual-backup connections between the SX  and the SG . A signaling protocol multiplexing (SPM) layer which multiplexes and demultiplexes native signaling protocols, such as ISDN, ISUP, ATM UNI, etc. runs over the redundancy manager layer. Preferably a backup mechanism is provided in which each SX  is coupled via S1 interfaces to a pair of SGs . Generally speaking, the signaling gateway (SG) function is to perform inter-working between two or more signaling mediums (e.g. SS7, TCP\/IP, etc.). The call agent control function exists in the signaling and control plane. The signaling gateway control function exists in the signaling and control plane.","The S2 physical interface represent a logical connection between the ISDN non-embedded signaling function  of the GSI  and an ISDN endpoint  on the MG . The S2 physical interface is Ethernet over which the multilayered protocol shown in  is implemented.","With respect to provisioning the signaling information of S1 and S2, a centralized element management station (EMS)  of the Billing and Recordkeeping Server (BRS)  coordinates the provisioning of the SG , SX  and MG . After EMS provisioning is complete, the SG, SX, and MG coordinate their configurations such that during operation they can correctly map the logical resources in common between them.","The gateway interface (GW1) manages the interconnection of the SX  to an MG , preferably using the MGCP Version 1.0 protocol. The MGC  of the SX  implements specific media gateway control protocol (MGCP) packages  for line, trunk and channel-associated signaling (CAS) with the MG . For CAS, the signals are carried on the same facility as the voice path. Since the MG  does not support direct termination of analog interfaces , the CAS control to the analog interface  is delivered through digital supervision signaling (ABCD bits) over a DSLAM (DSL access multiplexer)  to an integrated access device (LAD)  using an ATM AAL-2 loop emulation protocol at . The LAD  is a customer located access device that can handle both voice and data services on the same access line and is connected to a telephone  at the customer premises.","The GW1 physical interface is Ethernet over which the IP, user datagram protocol (UDP), and MGCP protocol layers are implemented. In order to facilitate the implementation of redundant MGCs, MGCP uses domain names, rather than IP addresses to identify the MGC and the MG. Several IP addresses can be associated with a domain name. MGCP is a transaction-based protocol, which allows a new MGC function to take over control at any given point of time. When the gateway detects a new MGC source in a new MGCP request, the gateway then sends the associated responses to the new MGC, while responses to previous commands are still transmitted to the original source MGC.","The high availability interfaces (HA1) manage the redundancy between the active and standby SX systems , . The physical interfaces utilized by the HA1 include four Ethernet connections and one serial connection.","Management interfaces M1 and M2 are for CLI provisioning and element management (EMS), respectively. Both M1 and M2 interfaces are SNMP over UDP. Management interface M3 is used to synchronize subscriber data between the subscriber management portal (SMP)  of the Billing and Recordkeeping Server (BRS)  and one or more SX systems  in the network. Management interface M4 is used to pull CDR records from SX systems  to the billing mediation platform (BMS)  of the Billing and Recordkeeping Server . Both interfaces M3 and M4 are TCP\/IP.","The AS1 interface manages the interconnection of the ASI function  of the SX  to application service functions (AS) . The application server (AS) function is to coordinate calls and caller related activities and resources for specialized purposes beyond the basic call process and typically associated with enhanced service arrangements. Furthermore, an application server may provide feature interaction management between application program functions. The application server function exists in the application services plane.","The SX is adapted to support two types of AS interfaces. The first interface type, designated AS1, defines the logical and physical interface between the SX BCP  and the SLEE . The second interface type, designated AS2, defines the logical and physical interface between the SX ASI  and an external AS  residing in the IP network. The physical characteristics of the AS1 interface may be implemented two ways, depending on whether or not the SLEE resides on the same server as the SX. When the SLEE  and SX  reside on separate servers, the AS1 physical interface is Ethernet over which the transport protocol used is UDP over IP. This option requires the network to support IP4 multicasting between nodes, and is implemented by enabling IP multicast routing and IP PIM on all client-server interfaces. The BCP  and SLEE  communicate through a request\/response API referred to as the SLEE Library. When the SLEE and SX reside on the same server, the ASI physical interface is UDP.","Within the SX, connection control primarily involves the signaling and gateway interface functions being coordinated by the call agent function (CA) , with call control residing in the basic call process function (BCP) . An overview of SX connection control with respect to each interface type is provided in Table 2.",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SX Internal Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Int. Id","Logical Interface","Physical Interface(s)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Signaling Interfaces (S-Type)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["S1","SX GSI SS7 to SG","Ethernet"]},{"entry":["S2","SX GSI ISDN to MG","Ethernet"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Gateway Interfaces (GW-Type)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["GW1","SX MGC\/CAS to MG","Ethernet; MGCP\/UDP\/IP"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"High Availability Interfaces"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["HA1","SX Active HA to SX Standby HA","Ethernet, Serial"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Management Interfaces (M-Type)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["M1","SX NM to Management Terminal","Ethernet, Serial RS-232"]},{"entry":["M2","SX NM to Billing and Recordkeeping Server EMS","Ethernet"]},{"entry":["M3","SX NM to Billing and Recordkeeping Server SMP","Ethernet"]},{"entry":["M4","SX NM to Billing and Recordkeeping Server BMS","Ethernet"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Application Server Interfaces (AS-Type)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["AS1","SX BCP to SLEE (on same server)",{}]},{"entry":[{},"SX BCP to SLEE (on separate servers)","Ethernet; UDP\/IP; IP4 Multicast"]},{"entry":[{},{},"pim dense"]},{"entry":["AS2","SX ASI to Generic Application Server (AS)","Ethernet; TCP\/IP"]},{"entry":["AS3","SX SMDI to External Voice Mail System","Serial RS-232"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0089","num":"0088"},"figref":["FIG. 6","FIG. 4"],"b":["10","14","16","34","124","124","124","124","80"],"i":["a","b","c","d "]},"Referring more particularly to the SLEE , the SLEE allows for the implementation of many reusable basic application service functions (modules), referred to as service independent building blocks (SIBs) . These SIBs may be representative of individual call states, specialized service functions, or the set of atomic functions specified by the ITU for AIN 0.2. Using a call processing language (CPL), discussed below, new SIBs can be scripted which are then combined and compiled into application scripts which execute in the SLEE. Because SIBs contain relatively few lines of programming code they can be easily and quickly tested. SIBs can be reused and combined with newly coded SIBs to create future service applications.","According to one embodiment, the SLEE implementation makes each SIB into a separate process, with user datagram protocol (UDP) as the preferred method of inter-process communication. This makes the implementation completely distributable, driven entirely by the time-to-live attribute of the UDP message, which determines the scope of distribution (e.g., LAN segment, WAN, or world-wide network). As such, new features can be built and tested, and then sent to a customer system by reference in the SLEE Dynamic Naming Services (DNS) server which, as discussed below, permits the distribution of functional elements over the network. Within the SLEE, multiple copies of any SIB can be run as the call load directed to a particular service function or feature peaks. Conversely, distribution of services can also be implemented by having a single SLEE connect to multiple SXs across the IP network. Rather than forcing applications or the SX to learn the details of using the SLEE DNS server, the SLEE Library, referenced above and described in detail below, is provided to make the interface clean and easy.","According to the presently preferred embodiment, the SLEE is instantiated by a C-language program module named slee. The slee executable is a generic implementation of very basic SLEE functions. Consequently, it can run in a variety of environments, wherever service level execution is desired: at the application level, as part of the service creation switch (SX), or embedded within a Media Server (MS) or a similar device. A Media Server generally provides interworking between the SLEE and a media server which preferably supports HTTP. A media server functions to terminate one or many physical or logical \u2018bearer\u2019 channels (typically associated with User connections) into an ephemeral resource (dynamically loaded digital signal processor-attached resource). Furthermore, a media server may mix one or many physical or logical \u2018bearer\u2019 channels into a multi-party conference. A media server is differentiated from a media gateway through its ability to provide enhanced services to a bearer channel (e.g. speech recognition, interactive voice response scripts, text-to-speech, etc.). The media server function exists in the media transport plane. In effect, the media server is the capability layer of the SLEE. The combination of the slee and the libraries, threads, and projects loaded by it make up the actual application. A call flow is implemented within a project.","Referring to , the SLEE  is shown with a number of projects  loaded in the lower right hand corner, a pool of threads  in the lower left hand corner, and three fixed threads , ,  along the left side. Fixed thread  provides for communication between the SLEE and another node on the network. Fixed thread  provides for operator commands to control and monitor the SLEE while it is running. Fixed thread  provides for communication with the SX. For each project  that the SLEE  runs, a thread is retrieved from the thread pool , and the thread then runs the project-specific code. The SLEE module provides for balance between the threads that instantiate the projects.","The fixed threads govern a variety of interfaces, one interface per thread and one thread per interface. The fixed threads are written as C-language source modules and linked into the slee at compile time. A configuration file slee.cfg governs which threads are loaded, and the order in which they are loaded. Fixed threads include the following:","opcmds Thread (sleecmd.c)","This thread is the command thread, and provides a keyboard interface to the SLEE to allow reconfiguration, shutdown, and similar commands.","sleenode Thread (sleenode.c)","This thread allows communication between the SLEE in a subject node and the SLEE in other nodes. This thread also accepts requests from other non-SLEE services to the SLEE (e.g., a request from the notification process that the SLEE make calls to pager bureaus, and to send CDR's for notification events handled by the notification process).","Database Interface Thread (sleedam.c)","This thread waits for database events to occur and forwards these events through the main SLEE thread to the appropriate call flow.","Timer Thread (sleepuls.c)","This thread tracks the time remaining for an array of script-managed functions. When each timer reaches zero, the call context in informed, and any wait condition pausing the script is interrupted.","Media Server Thread (sleemm.c)","This thread waits for events from the Media server. When a new event arrives, it is part of SLEE's queue. The SLEE's main thread forwards the event to the appropriate call flow in order that the script handles the information returned by the Media server.","Soft Switch API Thread (sleerm.c)","This thread manages the API with the Soft switch. When a new event arrives, it is placed on the queue for the slee main thread, which forwards the event to the appropriate call flow.","The various SLEE fixed threads have input and output mechanisms that differ based on the purpose of the thread.","SLEE Main Thread (slee.c)","This thread services a linked list of queue of events. All the other threads add events to this queue through a function within the main slee thread called slee_addEvent. This thread removes events from its queue and adds them to the linked list queue for the appropriate call flow.","sleecmd Thread","This queue removes its input from a UNIX message queue. Its output is typically to a file called \/usr2\/USM2\/LOGS\/slee.out.","sleedam Thread","This thread gets all new input from the database interface (DBIF) through a call to the function Get_Database_Response. The output is to the slee event queue.","sleepuls Thread","This thread has no input. Rather, scripts can initialize one of five function timers through a statement with the syntax:\n\n","sleemm Thread","The input for this thread is through the function call in mmlib.c named mm_EventGet( ). The mmlib code manages TCP\/IP socket connections to the various Media server servers. Output is to the slee main event queue.","sleerm Thread","Input to this thread is through the TCP\/IP socket connection that underlies the open API. Output is to the slee main event queue.","Referring to , the project state machine contains the logic that implements a project . Each project  can have a different state machine that governs the meaning of events at a finer level than the call states. Each project state machine  is a shared library loaded by the slee module, and pulls messages off of a linked list created by the slee module and processes each as a separate event. The state machine tracks the context of each event and the result of each event handler (script).","The logic that handles each event is written in scripts in a call processing language (CPL), and then compiled into dynamically loaded shared libraries (DLLs). Each state machine  governs a pool  of threads that handle active calls. The threads make calls to the shared libraries, to the state machine, and to the slee module.","The slee module is invoked as a separate process at the application layer with a parameter that indicates the level at which it implements the SLEE, as follows:\n\n","The slee is run within its own thread in the Soft switch (if it runs there) and in the Media server. The entry point is a routine named slee( ), which takes two parameters: the level at which it is running, and the path to the configuration information:\n\n","Also in the SLEE directories are the dynamically loaded shared libraries (DLLs) that provide the API between the layers. In the case of the AP directory, there is a DLL that provides inter-node communication services; e.g., Access Node to Service Node, Guaranteed Delivery, etc. The shared libraries also provide basic services such as trace file logging, alarm and trap notifications, etc. The shared libraries are preferably compiled for the specific operating system in which they run.","The slee module loads the unique processing logic (project state machines) for the various projects, and receives the run-time commands discussed below.","The application layer slee has several functions. First, the application layer slee module receives all messages from the SS through the selected API, e.g., an interface such as PARLAY\u2122 (from the Parlay Group) and S-100. The received message is then added to the appropriate linked list for the project that the message pertains to, and the project is notified to handle the message. Second, the application layer slee module is also responsible for communicating with other layers. Third, the application layer slee module controls connections to other nodes like Access Node to Service Node, the Guaranteed Message Delivery system, and the database. Fourth, the application layer slee module loads the node configuration details and makes them available to the various project state machines.","According to the preferred embodiment, the slee module is preferably not loaded in the Soft switch (SS) layer. However, given an appropriate function, the slee module may be loaded in the SS layer.","In the Media server, the slee is responsible for loading specific project logic where necessary.","By way of example, the following high level pseudo-code for implementation of the slee module is provided:\n\n","Each slee module has a control thread that reads a message queue for run time commands that can be entered at a keyboard. A separate module named tellslee knows how to communicate with the command thread through the message queue, and an operator can send messages directly to the slee module to affect how it runs. Commands all have a prefix that can be tested (e.g., \u201c!!\u201d) and then one of a series of standard commands:\n\n","As discussed above, the slee module launches the project state machine appropriate to the state machine's level of execution, AP (Application), SS (Soft switch), or MS (Media server). The files that control the project state machines and the compiled scripts are contained in directories designated for the level of execution:\n\n","Each of the Active and Inactive directories contain a file named inventory that names all of the scripts that should be loaded by the project state machine.","A separate thread handles each event for a call. The threads make calls to the shared libraries, to the state machine, and to the slee module. When the thread completes its handling of the event (that is, when the script is completed), the thread is returned to the thread pool.","The transitions in the call states are the responsibility of the project state machine in the application layer and its interface to persistent call objects. Therefore, SLEE elements in the Soft switch and the Media server must trigger events in the application layer to effect the changes in the call's call state.","An unexpected release of the call by the caller will generate an event that will cause the Soft switch to broadcast an asynchronous release event to the application and the Media server.","By way of example, the following high level pseudo-code for implementation of the project state machine is provided:\n\n","Each project state machine also has a control thread that reads a message queue for run time commands that can be entered at a keyboard. A separate module named tellproj knows how to communicate the command thread through the message queue, and an operator can send the messages or commands described above (SHUTDOWN, KILL #, TRACELVL, etc.) directly to the slee module to affect how it runs.","The inner workings of the SLEE can be monitored real time with the following command: display.sh. The results are written to slee.out.","The command to show the names of scripts as they execute is:\n\n","The command to display the names of prompts as they play is:\n\n","The command to be able to see each Soft switch event as it arrives is:\n\n","The command to view the results of Media server functions as they are reported to the SLEE is:\n\n","The command to see whether the SLEE is receiving calls is:\n\n","The command to change the ISP service addresses while the SLEE is running is:\n\n","The current settings of an ISP modem can be viewed by either:\n\n","As mentioned, the call processing language (CPL) is used to create scripts for the SLEE. A script, as briefly described above, is an event handler or a system independent building block (SIB), either high-level or low-level. Since events of telephony significance can take place on all layers of the OSI stack, the CPL does not limit itself to the Application Layer. Instead, CPL scripts can be executed in a variety of environments. The first layering scheme separates the functionality of the application logic from the Soft switch and the Media server.","Each call is represented in the application layer by a persistent call object \u201cowned\u201d by the application layer that maintains a number of items relevant to a call. \u201cOwnership\u201d means responsibility to maintain the \u201ccall state\u201d. Since the application layer \u201cowns\u201d the call object, changes to the call object are made only through the application layer scripts. Scripts at other layers have to generate (\u201ctrigger\u201d) application events to change information in the call object. The call object contains the subscriber profile data, the cumulating CDR data, and the application state of the call besides the call state. The application state is a variable that tracks the most recently handled event and the event next expected.","\u201cCall state\u201d means the state of the call in the sense described in the documentation for PARLAY\u2122 or some similar standard application server. Whenever an event in any layer would change the call state, an application layer event must be triggered so that the application layer will change the call state within the persistent call object.","As a call progresses, parts of the persistent call object are sent between the application layer and the layers lower in the OSI stack, and possibly back up to the application layer. The result is that each call is controlled by the application layer.","According to a preferred embodiment, scripts written in CPL are compiled into C-language statements, which are then compiled into shared libraries by a standard C compiler for the target computer. The compiler is made up of a specification preferably developed with the C code yacc command, a parser preferably developed with the C code lex command, and preferably a number of C code and header files. Once a script is written, the command to generate C code from the script is cpl SCRIPTNAME.cp. The output is a file named SCRIPTNAME.c. The C code is then compiled into a shared library according to the specifications of the target platform. The importance of implementing the scripts as shared libraries is that scripts can be dynamically loaded; even at run time, a command can be issued to load a new copy of a script. Any new calls made will use the newly loaded version. The command interface for loading the new version of a script as a dynamically linked library is described above. On the Linux operating system, it may be necessary to link the scripts together into a single large linked library that represents a whole call flow. The call flow can be changed during run time as described above, but it is not possible to change individual scripts at run time.","The scripts for the CPL are written as plain ASCII files with new-line delimiters. Scripts are composed of sections. Some sections are required, and other sections are optional and appear only when required by the script.","Scripts can request the execution of other scripts, either at the same layer of execution, or at other layers. \u201cRun\u201d or \u201cjump\u201d are the two possible commands when a script executes another script within the same layer, that is, if an application script runs an application script). The command \u201crun\u201d is used if the original script expects to continue running after the other script has begun executing (synchronously, like a subroutine call). The syntax is run SCRIPT(parameters); for example,\n\n","A script can run another script in the background. The second script runs (in part) in parallel with the first script. The second script is called the \u201cchild\u201d script, and the original script is called the \u201cparent\u201d script. The child script inherits certain features from the parent, including the call reference number that will tie CDR's produced by the child with the CDR's created by the parent. The syntax is: bgrun SCRIPT (parameters); for example,\n\n","If a script running in one layer wants another layer to execute a script, it will \u201ctrigger\u201d the running of the script with the command <LAYER>_trigger, where <LAYER> will be:\n\n","A script itself is delimited by the \u201cstart script\u201d and \u201cend script\u201d key words. As such, the first non-comment or blank line must contain only the key words \u201cstart script\u201d and a new line character. The last non-blank and non-comment line must contain only the key words \u201cend script\u201d and a new line character. Incorrectly formatted key words are ignored. Hence, required key words incorrectly formatted will be flagged as absent, and the script will not compile.","Scripts return a value of \u201cSUCCESS\u201d or \u201cFAILURE.\u201d The return value signals to the requesting layer whether the values in the interface buffers are of any value. A return of FAILURE would indicate that the contents of the interface buffers are undefined. A return of OK would indicate that the contents are set as expected. Returns are coded within the then or else section with the keyword RETURN plus SUCCESS or FAILURE. Actually, the \u201cSUCCESS\u201d keyword is translated into (void *) thisCall, where \u201cthisCall\u201d is the address of the call object, and the \u201cFAILURE\u201d keyword is translated to (void *)NULL.","Comment lines begin with a hash (\u2018#\u2019) in the first position. Comments are allowed anywhere within a script, including before the \u201cstart script\u201d and after the \u201cend script\u201d keywords. Blank lines; that is, lines consisting only of white space and a new line, are allowed at any point.","The header and code sections, described individually hereafter, are required to be in all scripts. The ibuffer (input buffers), obuffer (output buffers), prompts, and counters sections, also described hereafter, are optional, and their absence is not considered to be an error unless reference is made to them.","The header section begins with a line consisting of only the keywords \u201cstart header\u201d and a new line and ends with a line consisting of only the keywords \u201cend header\u201d and a new line. Each field within the header consists of a keyword plus white space (any number of tabs or spaces) plus a value. The header must include required fields, and may include optional fields.","The following fields must appear in the header, and in the following sequence. ScriptName VALUE VALUE must start with:\n\n","ExecutedBy VALUE VALUE shows which layer executes the script Valid choices are:\n\n","The following fields are optional and only appear if necessary:\n\n","An \u201cinput buffer\u201d (ibuffer) is a buffer with data (input parameters) that is provided by the level that calls the script. An ibuffer, when present, begins with a line that has the words \u201cstart ibuffer\u201d and a new line, and ends with a line that has the words \u201cend ibuffer\u201d and a new line. The ibuffer section can contain up to five buffers. Each ibuffer description consists of the name of the buffer and the size of the buffer in bytes.","When the ibuffer section compiles, the name of each buffer becomes:\n\n","An obuffer section declares the buffers necessary during the execution of the script The compiler executes a malloc( ) call for each obuffer, using the size of the buffer as a parameter. Buffer names have script scope. An obuffer section, if present, begins with a line that has the words \u201cstart obuffer\u201d and a new line, and ends with a line that has the words \u201cend obuffer\u201d and a new line. The obuffer section can contain any number of buffers. The script refers to the buffers by name. Each obuffer description consists of the following and the size of the buffer to reserve. An example of an obuffer is:\n\n","The optional counters section is a list of script counters that can govern script flow. The section begins with a line that has the keywords \u201cstart counters\u201d and a new line, and it ends with a line that has the keywords \u201cend counters\u201d and a new line. The counters themselves are declared a name; for example, \u201cretries.\u201d Within the script code, the counters are referred to by their names. For example, given the declaration \u201cretries\u201d, to increment the counter \u201cretries\u201d the script code would be \u201cretries +1.\u201d Counter names have script scope.","The code section is required and contains what the script actually does. The code section begins with a line with the key words \u201cstart code\u201d and a new line, and ends with a line that contains the key words \u201cend code\u201d and a new line. Each line of code can have the following elements, and only in the order specified.","The code section can have an optional code label field. The labels can be numbers or names. Name labels begin at the first position on the line with a colon, followed by label's name, as in :CLI_Blacklisted.","The code section can also have a keyword language. If a prompt is to be played, the keyword language followed by a valid choice sets the language in which prompts (VOX files) are to be played. The valid choices for the language keyword are the \u201cnative\u201d and \u201csubscriber\u201d. The keyword \u201cnative\u201d identifies the native language of the node or DNS on which the script is running. The keyword \u201csubscriber\u201d identifies the language selected by the subscriber in which to hear prompts.","If a prompt is to be played, the keyword prompt is followed by the name of the prompt selected from the list of prompts in the prompts section of the script:\n\n",{"@attributes":{"id":"p-0171","num":"0266"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MAXWAITTIME","Maximum initial silence"]},{"entry":[{},"IDDTIME","Inter digit silence timer"]},{"entry":[{},"STAR","The star key (*) was pressed"]},{"entry":[{},"POUND","The pound key (#) was pressed"]},{"entry":[{},"MAXSIL","Maximum silence was detected"]},{"entry":[{},"MAXTIME","Maximum functional time"]},{"entry":[{},"TONE","An expected tone was detected"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0172","num":"0267"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["promptName1:","Name of a prompt"]},{"entry":["promptName2:","A script can store a prompt name in an obuffer variable"]},{"entry":[{},"and request playing the prompt"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0056","list-style":"none"},"li":{"@attributes":{"id":"ul0056-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0057","list-style":"none"},"li":"variableName, smartMode:\n        \n        "}}}},"If a built-in routine is to be called, the keyword execute appears followed by the name of a built-in routine to execute and its parameters. The parameters to the routines follow the name of the routine in parentheses; for example, \u201cDTMF (parm1, parm2, . . . , parmN, trapMask)\u201d.","The trapMask field is a bit-map of events or \u201ctraps\u201d known to the subroutine. Each trap is a termination condition. If the routine understands eight traps, the trapMask can be thought of as an 8-toggle switch. If all 8 bits are off, the toggle looks like this: 00000000. If the script wants to know that the second trap happens (or \u201cfires\u201d), the trapMask would look like this: 01000000. In other words, the bits are numbered from the left, beginning with 1. To instruct the script to behave a certain way if the trap fires, the script author writes a sequence line with the notation:\n\n","An operation consists of a counter, an arithmetic operator (e.g., plus or minus) and an optional operand. A counter can be referred to by its name in the counter section in the script header. Counters are initialized to zero by default. The valid operations on a counter are shown below. Note that there is a space between the counter and the operator, and no space between the operator and the operand.\n\n","The if keyword followed by a condition in parentheses is optional. For example:\n\n","The valid operators are:\n\n","In order to facilitate understanding of the CPL, the following sample script is provided:",{"@attributes":{"id":"p-0179","num":"0304"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"# This script is a subroutine that plays the owner's Status Messages"},{"entry":"#"},{"entry":"# Reference: ABCSample Service Logic"},{"entry":"# Unified Messaging High Level Voice Menu Structure"},{"entry":"#-----------------------------------------------------"},{"entry":"start script"},{"entry":"start header"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ScriptName:","AP_MailboxLimit"]},{"entry":["ProjectNo:","2001"]},{"entry":["ProjectName:","XYZProject"]},{"entry":["CreationDate:","2001-02-09"]},{"entry":["ExecutedBy:","AP"]},{"entry":["Release:","A"]},{"entry":["Customer:","ABC"]},{"entry":["Application:","Sample"]},{"entry":["UpdatedBy:","John Q. Smith"]},{"entry":["UpdatedOn:","2000-03-02 12:00"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"end header"},{"entry":"# no ibuffers"},{"entry":"#start obuffer"},{"entry":"#end obuffer"},{"entry":"#start counters"},{"entry":"#end counters"},{"entry":"start prompts"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"V903511 Warning, your mailbox is full."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"end prompts"},{"entry":"start code"},{"entry":"#-----------------------------------------------------"},{"entry":"# Mailbox usage >= 100%. This message is NOT interruptible."},{"entry":"#-----------------------------------------------------"},{"entry":"# Warning, your mailbox is full."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"cpl({V903511},0,0,\u201c \u201d)"]},{"entry":[{},"waitfor PROMPT_COMPLETE"]},{"entry":[{},"return SUCCESS"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"end code"},{"entry":"end script"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In accord with a preferred aspect of the invention, a Dynamic Naming Service (DNS) for the SLEE is provided. The sleedns permits service to be distributed over multiple segments in a network.","The sleedns module starts early in the IPL sequence of an application service. It accepts requests over UDP on a defined port. When applications or application elements open their own ports for listening, the library function that performs the socket and bind commands sends a UDP registration request to the local sleedns process. The message contains the name of the element, the hostname of its host, the IP address of the host, and the port that the element listens on. Application elements that want to send to another application element issue commands in the format:\n\n","If a processing element is over-burdened, it preferably deregisters with its local sleedns, and the local copy bears the responsibility to update all the network copies. Thus, the application element is no longer in sight. It is the responsibility of the local copy of sleedns to remain synchronized with the other network copies. This can be accomplished by sending multicast messages to all listeners in the network on the sleedns port.","A number of predefined messages are known to the server. All messages to and from the sleedns are preferably in Session Description Protocol (SDP) or XML format, and some (indicated below) have responses associated with them. If a response is not received before the expiration of the timer (configured in a configuration file), the request is repeated.","An application element registers that is ready to receive messages. The registration is done at initialization. The local sleedns is responsible to multicast the new location to all the other sleedns servers in the network. Each registration is stored with the time of its receipt. If the application element is already registered, the entry in the DNS is updated with the new time, and success is returned.","The Session Description Protocol (SDP) request to register an application element consists of the fields shown in Table 3. A semicolon separates fields from each other, and the order of the fields is not important. An example registration request would look like:\n\n",{"@attributes":{"id":"p-0186","num":"0313"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SDP Registration Request Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["r = ElementName","Required","ElementName can be a","\u201cST4\u201d is short for"]},{"entry":[{},{},"maximum of 31 bytes.","\u201cState4.\u201d There is enough"]},{"entry":[{},{},{},"room to be clear about the"]},{"entry":[{},{},{},"name, as in"]},{"entry":[{},{},{},"\u201cST_Alerting.\u201d"]},{"entry":["p = port","Required","In network byte order","\u201c20806\u201d is how the"]},{"entry":[{},{},{},"network byte order for"]},{"entry":[{},{},{},"18001 is reported by"]},{"entry":[{},{},{},"Linux on Intel x86's."]},{"entry":["h = Hostname","Optional","Maximum size of"]},{"entry":[{},{},"NI_MAXHOST-1 (1023)."]},{"entry":["i = HostTCPaddress","Optional","In IPv4 dot notation."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The reply is the request, with a new result field, and the optional Hostname and HostTCPaddress fields supplied. The reply to the example request is in the following format:\n\n",{"@attributes":{"id":"p-0188","num":"0317"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SDP Registration Replies Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["k = ACK",{},{},{}]},{"entry":["k = NAK|reason","ACK or NAK is required,","Supplied by the DNS","Note that if a NAK has a"]},{"entry":[{},"the reason is optional","server.","reason, there is a vertical"]},{"entry":[{},{},{},"bar between the word"]},{"entry":[{},{},{},"\u201cNAK\u201d and the reason,"]},{"entry":[{},{},{},"which could be several"]},{"entry":[{},{},{},"words, such as \u201cno room"]},{"entry":[{},{},{},"in table.\u201d"]},{"entry":["r = ElementName",{},"From the request."]},{"entry":"s = r"},{"entry":["p = port",{},"From the request."]},{"entry":["h = Hostname",{},"From the request, or"]},{"entry":[{},{},"supplied by the DNS"]},{"entry":[{},{},"server."]},{"entry":["i = HostTCPaddress",{},"From the request, or"]},{"entry":[{},{},"supplied by the DNS"]},{"entry":[{},{},"server."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Application elements can query the sleedns for the address of another element. This is done by the library routine sendTo without the knowledge of the application. The SDP version of the query request looks like:\n\n",{"@attributes":{"id":"p-0190","num":"0320"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SDP Query Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["q = ElementName","Required","ElementName can be a",{}]},{"entry":[{},{},"maximum of 31 bytes."]},{"entry":[{},{},"This is what to look for."]},{"entry":["p = port","Required","In network byte order","\u201c20806\u201d is how"]},{"entry":[{},{},{},"the network byte order for"]},{"entry":[{},{},{},"18001 is reported by"]},{"entry":[{},{},{},"Linux on Intel x86's."]},{"entry":["h = Hostname","Optional","Maximum size of"]},{"entry":[{},{},"NI_MAXHOST-1 (1023)."]},{"entry":["i = HostTCPaddress","Optional","In IPv4 dot notation."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The reply to a query preferably has as many of the fields supplied as possible; for example,\n\n",{"@attributes":{"id":"p-0192","num":"0324"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SDP Reply Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["k = ACK",{},{},{}]},{"entry":["k = NAK|reason","ACK or NAK is required,","Supplied by the DNS","Note that if a NAK has a"]},{"entry":[{},"the reason is optional","server.","reason, there is a vertical"]},{"entry":[{},{},{},"bar between the word"]},{"entry":[{},{},{},"\u201cNAK\u201d and the reason,"]},{"entry":[{},{},{},"which could be several"]},{"entry":[{},{},{},"words, such as \u201cno room"]},{"entry":[{},{},{},"in table.\u201d"]},{"entry":["q = ElementName",{},"From the request."]},{"entry":["s = r",{},"Status of the","On a NAK, the status will"]},{"entry":[{},{},"ElementName. Can be","be \u2018q\u2019."]},{"entry":[{},{},"\u2018r,\u2019 \u2018R,\u2019 (for \u201cregistered\u201d)."]},{"entry":["p = port",{},"From the request."]},{"entry":["h = Hostname",{},"From the request, or"]},{"entry":[{},{},"supplied by the DNS"]},{"entry":[{},{},"server."]},{"entry":["i = HostTCPaddress",{},"From the request, or"]},{"entry":[{},{},"supplied by the DNS"]},{"entry":[{},{},"server."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"An application element can hide itself from other elements by deregistering with the local sleedns. The local server is responsible to deregister the element by multicasting to all the other servers on the network. Each deregistration is stored with the time of its receipt. If an attempt is made to deregister an element that is already deregistered, the DNS entry is updated, and the return will indicate success. Deregistering a non-existent element is also treated as a success.","The request to deregister an element is provided in the following format:\n\n",{"@attributes":{"id":"p-0195","num":"0328"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SDP Deregistration Requests Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["d = ElementName","Required","ElementName can be a maximum of",{}]},{"entry":[{},{},"31 bytes."]},{"entry":["p = port","Required","In network byte order"]},{"entry":["h = Hostname","Optional","Maximum size of"]},{"entry":[{},{},"NI_MAXHOST-1 (1023)."]},{"entry":["i = HostTCPaddress","Optional","In IPv4 dot notation."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The SDP version of the reply to a deregistration request is in the following format:\n\n",{"@attributes":{"id":"p-0197","num":"0331"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SDP Deregistration Request Reply Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["k = ACK or",{},{},{}]},{"entry":["k = NAK|reason","ACK or NAK is required,"]},{"entry":[{},"the reason is optional"]},{"entry":["r = ElementName",{},"From the request."]},{"entry":["s = d",{},"Supplied by the DNS"]},{"entry":[{},{},"server."]},{"entry":["p = port",{},"From the request."]},{"entry":["h = Hostname",{},"From the request, or"]},{"entry":[{},{},"supplied by the DNS"]},{"entry":[{},{},"server."]},{"entry":["i = HostTCPaddress",{},"From the request, or"]},{"entry":[{},{},"supplied by the DNS"]},{"entry":[{},{},"server."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Each sleedns server communicates with all the others on the network. The synchronization messages are multicast to the sleedns port on all hosts. The synchronization messages look like the original requests, with all of the optional fields filled out by the sending server. The status field is changed to upper case so that registrations are forwarded with status set to \u2018R\u2019 and deregistration messages have a status of \u2018D.\u2019","Each host periodically multicasts a heartbeat message to the other hosts. The time between heartbeats is set in the configuration file. The heartbeat message contains a count of registered elements and the time of the last update. An example of a heartbeat message is the following:\n\n",{"@attributes":{"id":"p-0200","num":"0335"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Heartbeat Message Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["b = UpdateTime","Required","UpdateTime is a string version of the","967230863 = Fri Aug 25"]},{"entry":[{},{},"time_t of the last time that a change","15:14:26 2000"]},{"entry":[{},{},"was made in the shared memory table",{}]},{"entry":[{},{},"of registered elements.",{}]},{"entry":["e = NumberOfEntries","Required","The number of registered elements in","\u201c14\u201d is the number of"]},{"entry":[{},{},"the table, not the total number of","registered elements."]},{"entry":[{},{},"entries in the table.",{}]},{"entry":["i = HostIpAddr","Required","The address of the host where the",{}]},{"entry":[{},{},"server is located",{}]},{"entry":["p = Port","Optional (can","In network byte order, the port of","\u201c20550\u201d normalized is"]},{"entry":[{},"be Required)","the sending DNS server.","18000."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"If the server receiving the heartbeat message has the same number of entries, the time from the update field and the network address of the sending server are recorded in a table. There is no acknowledgement or response to the heartbeat.","If a server receives a message with a different number of current registrations, the host with the less recent (older) update time sends a session request message with its count to the host with the more recent update time. Only one update session is allowed at a time. Once the host with the smaller number receives a session header message from a host, any other session header message is rejected. An example of a session request message is the following:\n\n",{"@attributes":{"id":"p-0203","num":"0339"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Session Header Message Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["o = SessionId","Required","SessionId is a string","967230863 = Fri Aug 25"]},{"entry":[{},{},"version of the time_t of","15:14:26 2000"]},{"entry":[{},{},"the time that the session",{}]},{"entry":[{},{},"request was sent.",{}]},{"entry":["i = HostIpAddr","Required","In IPv4 dot notation.",{}]},{"entry":["e = NumberOfEntries","Required","The number of registered","\u201c12\u201d is the number of"]},{"entry":[{},{},"elements in the table, not","registered elements. Note"]},{"entry":[{},{},"the total number of entries","that in the example"]},{"entry":[{},{},"in the table.","heartbeat above there were"]},{"entry":[{},{},{},"14 entries."]},{"entry":["p = Port","Optional (can","In network byte order, the","\u201c20550\u201d normalized is"]},{"entry":[{},"be Required)","port of the sending DNS","18000."]},{"entry":[{},{},"server."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"If the server that receives the session message is able to start an update session, an acceptance message is returned that echoes back the session open request and reports that the server is ready to begin the session. The message looks like this:\n\n",{"@attributes":{"id":"p-0205","num":"0343"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Session Reject Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["k = ACK",{},{},{}]},{"entry":["or",{},{},{}]},{"entry":["k = NAK|reason","ACK or NAK is required,",{},{}]},{"entry":[{},"the reason is optional",{},{}]},{"entry":["o = SessionId",{},"From the request",{}]},{"entry":["i = HostIpAddr",{},"From the request",{}]},{"entry":["e = NumberOfEntries",{},"From the request",{}]},{"entry":["p = Port",{},"From the request"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"An acceptance (k=ACK) message is followed immediately by the start of transmission header message. The message is in the following format:\n\n",{"@attributes":{"id":"p-0207","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"center"}},"thead":{"row":{"entry":"TABLE 12"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Acceptance Message Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["x = STX","Required",{},{}]},{"entry":["o = SessionId",{},"From the request",{}]},{"entry":["i = HostIpAddr","Required","The address of the sending",{}]},{"entry":[{},{},"server, in IPv4 dot",{}]},{"entry":[{},{},"notation.",{}]},{"entry":["e = NumberOfEntries","Required","The number of registered",{}]},{"entry":[{},{},"elements in the table on",{}]},{"entry":[{},{},"the sending server, not the",{}]},{"entry":[{},{},"number of entries in the",{}]},{"entry":[{},{},"session request.",{}]},{"entry":["p = Port","Optional (can be Required)","In network byte order, the","\u201c20550\u201d normalized is"]},{"entry":[{},{},"port of the sending DNS","18000."]},{"entry":[{},{},"server."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Then the sending server sends a copy of each registration to the receiving host:\n\n",{"@attributes":{"id":"p-0209","num":"0349"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":{"entry":"TABLE 13"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Registration Message Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Required","Comments","From the Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["r = ElementName","Required","ElementName can be a","\u201cST4\u201d is short for"]},{"entry":[{},{},"maximum of 31 bytes.","\u201cState4.\u201d There is enough"]},{"entry":[{},{},{},"room to be clear about the"]},{"entry":[{},{},{},"name, as in"]},{"entry":[{},{},{},"\u201cST_Alerting.\u201d"]},{"entry":["e = NumberOfEntries","Required","The number of entries on",{}]},{"entry":[{},{},"the sender at the time this",{}]},{"entry":[{},{},"message was sent (up to",{}]},{"entry":[{},{},"date in real time).",{}]},{"entry":["h = Hostname","Optional","Maximum size of",{}]},{"entry":[{},{},"NI_MAXHOST-1 (1023).",{}]},{"entry":["i = HostTCPaddress","Required","In IPv4 dot notation.",{}]},{"entry":["p = port","Required","In network byte order","\u201c20806\u201d is how the"]},{"entry":[{},{},{},"network byte order for"]},{"entry":[{},{},{},"18001 is reported by"]},{"entry":[{},{},{},"Linux on Intel x86's."]},{"entry":["o = sessionId","Required","From the original session",{}]},{"entry":[{},{},"request"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The receiving server can interrupt the flow when the counts are equal, as follows:\n\n",{"@attributes":{"id":"p-0211","num":"0352"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 14"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Interrupt Message Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"From the"]},{"entry":["Field","Required","Comments","Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["k = CAN","Required",{},{}]},{"entry":["o = SessionID","Required","From the request",{}]},{"entry":["i = HostIpAddr","Optional","The address of the",{}]},{"entry":[{},{},"sending server, in",{}]},{"entry":[{},{},"IPv4 dot notation.",{}]},{"entry":["e = NumberOfEntries","Required","The number of entries",{}]},{"entry":[{},{},"on the sender at the",{}]},{"entry":[{},{},"time this message was",{}]},{"entry":[{},{},"sent (up to date in",{}]},{"entry":[{},{},"real time).",{}]},{"entry":["p = Port","Required","In network byte order,",{}]},{"entry":[{},{},"the port of the sending",{}]},{"entry":[{},{},"DNS server."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The data stored by the sleedns server is preferably kept in shared memory so that it can survive the collapse and restart of the server process.","The SLEE DNS Server makes two clones of itself at initialization time by calling the UNIX system function fork. The original executable and each of the forked processes is referred to as a thread. The main thread is the original executable that is launched by the operating system and is responsible for (1) initializing what has to be present in all threads, (2) forking the two child tasks, (3) receiving all messages over the UDP socket, (4) processing registrations, deregistration requests, and queries, (5) multicasting the synchronization messages to other servers, and (6) setting the cancellation flag to end a session for the download session thread.","The heartbeat thread is in a constant loop that waits for the amount of time in the configuration file, and then multicasts the heartbeat message.","The count rectification session thread sends a copy of each registration entry to the server that requested to see all the registrations. Its loop is controlled by the cancellation flag that may be set by the main thread.","The state machine that governs the receiving end of the count rectification is shown in Table 15.",{"@attributes":{"id":"p-0217","num":"0358"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 15"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Receiving State Machine"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"State","Event","Next State"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Idle","Socket initialization succeeds","Invite"]},{"entry":[{},{},"Socket initialization fails","Idle"]},{"entry":[{},"Invite","Failure to send (3 times)","Invite"]},{"entry":[{},{},"Failure to send #4","Clean"]},{"entry":[{},"Wait ACK","Receive ACK from sender","Wait STX"]},{"entry":[{},{},"NAK from sender","Clean"]},{"entry":[{},{},"Timeout (3 times)","Wait ACK"]},{"entry":[{},{},"Timeout #4","Clean"]},{"entry":[{},"Wait STX","STX from sender","Recv"]},{"entry":[{},{},"Timeout (3 times)","Invite"]},{"entry":[{},{},"Timeout #4","Clean"]},{"entry":[{},"Recv","Next registration","Evaluate"]},{"entry":[{},{},"Evaluation OK","Recv"]},{"entry":[{},{},"NAK to correction","Clean"]},{"entry":[{},{},"ACK to correction","Recv"]},{"entry":[{},{},"ETX from sender","Clean"]},{"entry":[{},"Evaluate","Record matched","Recv"]},{"entry":[{},{},"Record not matched and added","Cancel"]},{"entry":[{},{},"makes counts equal",{}]},{"entry":[{},{},"Record shows more recent state here","Correct"]},{"entry":[{},"Cancel","Send OK","Clean"]},{"entry":[{},{},"Failure to send (3 times)","Cancel"]},{"entry":[{},{},"Failure #4","Clean"]},{"entry":[{},"Correct","Sent NAK to sender","Recv"]},{"entry":[{},{},"Failure to send (3 times)","Correct"]},{"entry":[{},{},"Failure to send #4","Clean"]},{"entry":[{},"Clean","Clean complete","Idle"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0218","num":"0359"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 16"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sending State Machine"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"State","Event","New State"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Idle","Invitation from receiver","Send ACK"]},{"entry":[{},"Send ACK","Failure to send (3 times)","Send ACK"]},{"entry":[{},{},"Invitation from receiver","Reject"]},{"entry":[{},{},"Failure #4","Clean"]},{"entry":[{},{},"Send OK","Send STX"]},{"entry":[{},"Send STX","Send failure (3 times)","Send STX"]},{"entry":[{},{},"Invitation from receiver","Reject"]},{"entry":[{},{},"Failure #4","Clean"]},{"entry":[{},{},"Send OK","Send Regs"]},{"entry":[{},"Send Regs","Send failure (3 times)","Send Regs"]},{"entry":[{},{},"Invitation from receiver","Reject"]},{"entry":[{},{},"Failure #4","Clean"]},{"entry":[{},{},"NAK from receiver","Evaluate"]},{"entry":[{},{},"Send OK","Next Record"]},{"entry":[{},"Evaluate","Accept change; send ACK","Send Regs"]},{"entry":[{},{},"Invitation from receiver","Reject"]},{"entry":[{},{},"Reject change; send NAK","Send Regs"]},{"entry":[{},{},"Send failure (3 times)","Evaluate"]},{"entry":[{},{},"Failure #4","Clean"]},{"entry":[{},"Next Record","Exists","Send Regs"]},{"entry":[{},{},"Invitation from receiver","Reject"]},{"entry":[{},{},"No record","Send ETX"]},{"entry":[{},"Send ETX","Send failure (3 times)","Send ETX"]},{"entry":[{},{},"Invitation from receiver","Reject"]},{"entry":[{},{},"Send failure #4","Clean"]},{"entry":[{},{},"Send OK","Clean"]},{"entry":[{},"Reject","Send NAK to receiver","Clean"]},{"entry":[{},{},"Invitation from receiver","Reject"]},{"entry":[{},"Clean","Clean up complete","Idle"]},{"entry":[{},{},"Invitation from receiver","Reject"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The SLEE DNS servers provide the advantage of allowing for a software architecture that is infinitely scalable and fully distributed. Referring to , Node A includes call control and device control , and a finite state machine  that controls the application. Above the finite state machine are the DNS libraries  that allow access to the States , , and SIBs , , that are distributed across the network. The DNS servers (on Node A ), (on Node B ), (on Node C ) keep each other synchronized so that the server on Node A is aware of the existence of the States , and SIBs , on the other nodes. The messaging libraries allow the application on Node A to execute States and SIBs on the other nodes, e.g., Nodes B and C. The other nodes can be within the same network segment, on different network segments, or even on different continents.","SLEE Library","Rather than forcing the application to learn the details of using the SLEE DNS server, the sleelib, a group of library functions, is provided to make the interface relatively clean and easy. The library is preferably written in C. Applications and application elements that use the library include specific headers files and link sleelib.o into their programs.","The library assumes the use of IP4 multicasting between network nodes so that new nodes can come on the network without being specifically known to the UNIX network configuration files. Preferably, the sleedns and sleeport modules are running on the local computer in order to permit the library to function properly.","Referring now to , the three basic application elements that the library accommodates are shown: a finite state machine (FSM) , a state process , and a SIB . The finite state machine  is on the left with sleelib  linked in. The notation \u201cFSMz\u201d means \u201csome (z) finite state machine\u201d. The state process  is in the middle with sleelib  linked in. The notation \u201cStateN\u201d means \u201csome (N) state\u201d. The SIB is on the right with sleelib  linked in. The notation \u201cSIBx\u201d means \u201csome (x) SIB\u201d. It is noted that the finite state machine , the state process , and the SIB  are each independent processes rather than threads.","The FSM  calls sleeInit during its initialization phase. After that, the FSM  performs whatever processing is required. When a transition occurs from one state to another, the FSM  sends a message to the state  that should do the processing by calling sleeSend. The FSM is free to continue processing while waiting for a response, or it can immediately call sleeRecv to block for a response. A loop is provided in the FSM that will lead from the bottom to the top. It is, of course, not necessary for the application on the left to be a finite state machine.","The state  calls sleeInit during its initialization phase. Although it is typical for the state to do little processing before waiting for input from the FSM (or some other application), it is available for processing. Eventually, the state waits for input from some other source by calling sleeRecv. When the input arrives, the state  processes the input as required. Eventually, the state calls sleeReply to send synchronizing information back to the FSM that sent the input. In the example shown in the , the state makes a call to SIB for some processing. The sending of the data is accomplished by calling sleeSubmit, and the response is read by calling sleeRead. It is not necessary for every state to call another application element (SIB).  merely illustrates that there is a secondary method to send data to another entity and a mechanism to receive an expected reply that will not be interleaved with other forms of input.","The SIB  process is substantially a replica of the state process , except it is simplified. The SIB calls sleeInit during its initialization phase. After that, the SIB receives input by calling sleeRecv, and it sends responses back to the sender by calling sleeReply.","For the FSM , the standard flow is sleeInit, sleeSend, sleeRecv. For the state , the standard flow is sleeInit, sleeRecv, optional calls to sleeSubmit and sleeRead, and then sleeReply. The state may then send to another state or to another SIB for additional processing. For the SIB , the standard flow is sleeInit, sleeRecv, sleeReply. The SIB may use sleeSubmit and sleeRead to send data to another state or another SIB for processing. Neither the state nor the SIB must reply. Of course, if the sender of the input is blocked on a reply, the state or the SIB could leave a process blocked on a sleeRecv or sleeRead forever. The effects on the robustness of the system are easy to predict. If the FSM has all of its states contained within itself, there is no need to call sleeInit, sleeSend, or sleeRecv. A similar statement hold true for the state and the SIB. Note that the FSM, the state, and the SIB are not \u201caware\u201d that there is UDP messaging that leaves the elements loosely coupled. The FSM, the state, and the SIB could each be located on a different computer, and there are no geographical boundaries on the data. It is not necessary for what is shown as a finite state machine to be a finite state machine. Any type of application will do. It is not necessary for the state process to implement a \u201cstate\u201d for a finite state machine. It is not necessary for the SIB to be in the picture. The illustration means to show a typical usage.","The sleeInit function initializes the SLEE DNS environment on behalf of an application. The function binds two UDP sockets for listening, and creates a UDP socket for communicating with the SLEE DNS server.","The sleeSend function sends the contents of sendbuf to the process registered as the \u201cdestination\u201d. The sleeSend function keeps a table of recently used addresses so that it is not necessary to do a SLEE DNS look up for each message. The sleeSend function sends sendlen bytes of data. The function will time out in some combination of seconds seconds and usec microseconds. If both seconds and usecs are zero, there will be no time out, and the function will block until the send will succeed or fail at the kernel level.","The sleeReply function provides a way for an application element to return data and\/or control to the application element that sent the sleeReply function data for processing. A response can be received without interfering with the main sleeRecv\/sleeReply loop.","Application elements that want to send to another application element (like a subroutine) call sleeSubmit and then receive a response by calling sleeRead. The sleeSubmit function has the responsibility to query the SLEE DNS to look up the host, IP address, and port for the named element, and to send the UDP message to that port on that host. The sleeSubmit function keeps a table of recently used addresses so that it is not necessary to do a SLEE DNS look up for each message. The sleeRead function reads for an incoming reply to a message previously sent by calling sleeSubmit.","The call processing language (CPL) of the SLEE implements EO\/AT Class 5 services on the SX. Each conventional Class 5 feature is dissected into a sequence of atomic functions. Analysis of Class 5 services is used to create a transition table which maps each transition in a call sequence to a basic (or atomic) function (SIB) that performs a specific feature interaction. The call processing language (CPL) then generates a call state transition table, which is implemented in the SX BCP function. Upon initialization, the BCP loads the call state transition table into memory and uses it to determine which, if any, SIB gets called during call processing when a call transitions into a new state (e.g., idle\/null to off-hook).","The overall control of the execution of the SIBs resides within clearly defined finite state machines (FSMs) which, similar to the call state transition tables, are generated by the CPL and loaded into the SX BCP. The FSMs for the originating and terminating sides of a call are defined by the ITU, as follows.","When the calling party initiates a call, the SX BCP, which emulates an EO\/AT switching exchange, starts the originating basic call state model (O-BCSM) process. The O-BCSM models the caller lifting the receiver, dialing a number, and making a call. The O-BCSM states are enumerated as follows:\n\n","The terminating basic call state model (T-BCSM) models the called party receiving a call. The T-BCSM states are enumerated as follows:\n\n","Referring to , in order to emulate EO\/AT stored program switching functions and process a high volume of calls within tight delay constraints, the call states and the events that cause transitions between them need to be made available to the SLEE . In addition, the call finite state machines are located close to the persistent call data, which resides within the domain of the SX . A tight coupling between the SLEE  and the SX connection control domain is made in the basic call process function (BCP) . The BCP  loads the call finite state machines (O-BCSM  and T-BCSM ) and respective transition tables ,  into memory and uses them to perform call control and determine which SIB , , , . . . , , , , . . . , if any, gets called when a call transitions into a new state. Each state has at least two outcomes, success and failure. The outcome triggers the process to the next state.","The protocol for data interaction between the SLEE state module and the finite state machines is as follows:",{"@attributes":{"id":"p-0237","num":"0403"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Total Number of Records Within Packet"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Data ID","Length of Data Field","Data Field Description","Payload"]},{"entry":[".",".",".","."]},{"entry":[".",".",".","."]},{"entry":[".",".",".","."]},{"entry":["Data ID","Length of Data Field","Data Field Description","Payload"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0105","list-style":"none"},"li":{"@attributes":{"id":"ul0105-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0106","list-style":"none"},"li":["Data ID char","Length of Data Field char","Data Field Descriptionchar","Payload as described in Tables 17 and 18."]}}}},{"@attributes":{"id":"p-0238","num":"0408"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 17"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Input Data Field Definitions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Data Description",{}]},{"entry":["Data ID","Data Length","(enums)","Payload"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["1 (int)","sizeof(int)","what int is it?","value of int"]},{"entry":["2 (bool)","sizeof(int)","what bool is it?","1 or 0"]},{"entry":["3 (char)","sizeof(char)","what char?","Value"]},{"entry":["4 (string)","strlen( ) + 1","what string?","Value + NULL"]},{"entry":["5 (bit field)","64 bits","which (subscriber\/","Binary"]},{"entry":[{},{},"channel)",{}]},{"entry":["6 (prev or","sizeof(int)","NULL","Value"]},{"entry":["current state)",{},{},{}]},{"entry":["7 (event that","sizeof(int)","NULL","Value"]},{"entry":"happened)"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0239","num":"0409"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 18"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Output Data Field Definitions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Data Description",{}]},{"entry":["Data ID","Data Length","(enums)","Payload"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["\u20021 (int)","sizeof(int)","what int is it?","value of int"]},{"entry":["\u20022 (bool)","sizeof(int)","what bool is it?","1 or 0"]},{"entry":["\u20023 (char)","sizeof(char)","what char?","Value"]},{"entry":["\u20024 (string)","strlen( ) + 1","what string?","Value +"]},{"entry":[{},{},{},"NULL"]},{"entry":["\u20025 (bit field)","64 bits","which (subscriber\/","Binary"]},{"entry":[{},{},"channel)",{}]},{"entry":["11 (set subscriber int)","sizeof(int)","which field","Value of int"]},{"entry":["12 (set subscriber bool)","sizeof(bool)","which field","1 or 0"]},{"entry":["13 (set subscriber char)","sizeof(char)","which field","Value"]},{"entry":["21 (set channel int)","sizeof(value)","which field","Value"]},{"entry":["22 (set channel bool)","sizeof(int)","which field","1 or 0"]},{"entry":["23 (set channel char)","sizeof(char)","which field","Value"]},{"entry":["3x","sizzeof(int)","Tone ID from","value"]},{"entry":[{},{},"enum",{}]},{"entry":["4x","sizeof(int)","Timer","Useconds"]},{"entry":["50 (set subscriber bit)","1","which bit field","1 or 0"]},{"entry":["51 (set channel bit)","1","which bit field","1 or 0"]},{"entry":["5x (etc.)",{},{},{}]},{"entry":["60 (set next state)","sizeof(int)","NULL","Value"]},{"entry":["70 (generate indication)","sizeof(int)","indicate transition","value"]},{"entry":[{},{},"to\/from",{}]},{"entry":[{},{},"originating,",{}]},{"entry":[{},{},"terminating",{}]},{"entry":["80 (active\/passive call leg)","sizeof(char)","which call leg are","Value (0\/1)"]},{"entry":[{},{},"we on?"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"An initialization function, sleeParmsInitO, allows the initialization of the buffer that will be used to send the packet data. The functions that are used to assemble and disassemble the UDP packets are sleeParmsAddO and sleeParmsGetO, respectively. In order to release any buffers that may be dynamically allocated within the course of usage of the above routines, a clean up routine has also been implemented called sleeParmCleanO. These functions do not send or receive any data, but rather are data placeholders permitting other routines ready access to the packet information. The functions are made available to both the finite state machine (FSM) as well as directly within the SLEE and are designed to be re-entrant capable.","SleeParmsInitO","The buffer that will be used to hold the packet being built will be initialized in this routine. The entire buffer will be initialized to null characters for the sake of simplicity. The record counter that is kept to track the number of records being added to the buffer is also initialized as well as all pointers that are being used within the SLEE Parameter functions.","SleeParmsAddO","This function is used to assemble information that needs to be communicated to other processes. This assembly is callable multiple times so that multiple records can be added to a send buffer used to hold all of the packet data. The number of records added to the packet are kept track of so that the number may be added to the top of the send buffer. The function also contains standard error checking to validate information coming into the function and to send back the appropriate return values for the calling routine to evaluate.","SleeParmsGetO","This function is used to dissect all of the information within the UDP packet that has already been received and returns the information to the calling routine one record at a time. Each subsequent call to the function returns the next record available within the packet. This is done through the parameter list of the function. The function also contains standard error checking to validate the integrity of the packet being dissected and to send back the appropriate return values for the calling routine to evaluate.","SleeParmsCleanO","This function cleans up all the sleeParm functions described above. The function is placed in the function sleeCleanO (SLEE Library) and is responsible for the freeing of allocated memory and all other general clean-up that may be needed.","From the foregoing, it will be appreciated that the SLEE can operate in two modes: Mode 1, Loosely Coupled SLEE, or Mode 2, Tightly Coupled SLEE. From the perspective of a single softswitch, it is possible to implement one SLEE operating in Mode 2 and one or more SLEEs operating in Mode 1. Furthermore, from a network perspective it is possible to implement a plurality of SLEE in either mode of operation.","When describing applications for the Decoupled Telecommunications System, there are two broad classifications, Network Applications and User Applications. An example of a Network application is broadband access. Broadband access is a superset of functionalities that embody all of the essential capabilities of a Class 5 SPCS (EO\/AT) in the PSTN such that the User cannot distinguish between their Class 5 service delivered through a Decoupled Telecommunications System versus a Class 5 SPCS in the PSTN.","To achieve functional equivalence to the Class 5 SPCS in a Decoupled Telecommunications System, an equivalent state machine is created through the SLEE CPL and then mobilized into the softswitch. This state machine combines the Originating and Terminating basic call state machines specified by the ITU for Capability Set 2. The SLEE function which implements this composite state machine is the Basic Call Process (BCP). The BCP is a specialized implementation of the Application Services Interworking Layer. The BCP is a byproduct of the SLEE operating in mode 2. The BCP function facilitates tightly coupled interaction between the SLEE and the softswitch. The BCP is the \u2018gearbox\u2019, subject to the previous analogy. SLEE mode 2 is the appropriate operational mode for the broadband access network application because it incorporates user services which are subject to the \u2018delay budget\u2019.","An example of a User application is Unified Messaging (UM). Although UM is a relatively complex application, it mainly involves repeated request\/response pairs of user interactions where moderate delays are acceptable. SLEE mode 1 is the appropriate operational mode for the UM application because the delay budget is not an issue and the application generally involves lengthy interactive sessions between the SLEE and other distributed Application Server elements including media servers, messaging servers and web servers using protocols that are not typically supported in a softswitch.","There have been described and illustrated herein an embodiments of methods and systems for providing integration","between PSTN and IP networks. While particular embodiments of the invention have been described, it is not intended that the invention be limited thereto, as it is intended that the invention be as broad in scope as the art will allow and that the specification be read likewise. Thus, while particular files, modules, threads, parameters, etc. have been disclosed by name and with a particular implementation, it will be appreciated that other files, modules, threads, parameters, etc., with different names and implemented in different manner, yet provide the same functionality, may be used as well. In addition, while particular elements have been described as preferably being implemented in hardware and other in software, it will be appreciated that hardware elements may be implemented in software and software elements may be implemented in hardware. Most significantly, while the invention has been described with respect to an IP network, it will be appreciated that virtually any packet network may be used in lieu of an IP network. It will therefore be appreciated by those skilled in the art that yet other modifications could be made to the provided invention without deviating from its spirit and scope as claimed."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
