---
title: Aggregate computer system via coupling of computing machines
abstract: Described is an aggregate computer system that operates by sharing devices of networked computing machines. A consumer machine uses a real device of a producer machine as a virtual device, by coupling the real driver of the real device over the network to a virtual driver of the consumer machine. Each machine may include an aggregate device manager that manages the virtual devices, and/or an aggregate connection manager that processes communications received over at least two different types of networks. Each machine may include a virtual bus and virtual bus driver that simulates a physical connection of a remote device to that machine via a bus. Upon receiving a request to plug-in a virtual device, the consumer machines queries for information of the device, and loads a virtual driver based on the device information when received. The consumer machine may query by sending plug-and-play events to the virtual bus.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08001553&OS=08001553&RS=08001553
owner: Microsoft Corporation
number: 08001553
owner_city: Redmond
owner_country: US
publication_date: 20070625
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Contemporary operating systems are primarily designed for personal computer use, which tends to create complexity when attempting to couple additional computing machines to the personal computer. For example, for many computer users it is a difficult task to establish a connection between the user's personal computer such as a laptop and the user's Smartphone (herein considered a computing machine with mobile telephone capability), even when the two computing machines both run operating systems from the same operating system vendor.","Further, consider a user working with locally networked computers. Even thought the computers are networked, they are disaggregated with respect to resource sharing. For example, each computer system has its own mouse and keyboard, and in general the user cannot seamlessly use the mouse and keyboard of one computer with another computer, (e.g., without manually changing the wired or wireless connections).","This Summary is provided to introduce a selection of representative concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used in any way that would limit the scope of the claimed subject matter.","Briefly, various aspects of the subject matter described herein are directed towards a technology by which an aggregate computer system is provided by sharing the devices of a plurality of computing machines that are coupled to one another by a network. For example, each computing machine of the aggregate computer system may have at least one device that can be used by each other computing machine as a virtual device. This is facilitated by coupling a real driver of a real device of one computing machine over the network to a virtual driver corresponding to that real device of another computing machine.","In one implementation, a first machine may act as a device producer by coupling a real driver of the device to the communications means. A second machine consumes the device of the first machine for use as a device of the second machine by coupling a virtual driver for the device to the communications means. The first and second machines may be both device consumers and device producers.","Each machine may include an aggregate device manager that manages the device, and\/or an aggregate connection manager that processes communications received over at least two different types of networks corresponding to the communications means. The aggregate connection manager includes connection APIs for accessing channel management functionality, including for managing a virtual named channel, managing a relationship between virtual named channel instances and underlying sockets, transferring data and handling exceptions. The aggregate connection manager also may include connection APIs for accessing host management functionality, including discovering available hosts and resolving a network address of a host.","Each machine may include a virtual bus and a virtual bus driver that simulates a physical connection of a remote device to that machine via a bus. For example, the virtual bus may simulate one or more of a PCI bus, an AGP bus, and\/or a USB bus, including at the same time. Example devices for which virtual drivers facilitate virtual device usage include a sound card device, a network card device, a graphics card device, a keyboard device, a pointing device and\/or a camera device. Via controller means, an application program or the like can use real devices of a computing machine along with one or more virtual devices as if each device was physically part of that computing machine.","In one aspect, a request may be made to couple a consumer computing machine to a virtual device. Upon receiving a request to plug-in a virtual device that is a real device of a producer computing machine, the consumer machines queries for information of the device. Upon receiving the device information, the consumer computing machine loads a virtual driver based on the device information. The consumer computing machine may query for the information of the device and for other information such as an updated device list by sending plug-and-play events, e.g., to the virtual bus.","Other advantages may become apparent from the following detailed description when taken in conjunction with the drawings.","Various aspects of the technology described herein are generally directed towards an aggregate (e.g., personal) computing system, in which various computing machines are aggregated into what is generally a unified entity, instead of operating as separate parts. For example, a user can couple two or more computing machines into an aggregated computer system, and thereafter control each machine's connected hardware devices (via wired and\/or wireless connections) from a uniform user interface, such as to perform pointing device (e.g., mouse) switching, keyboard switching, use a SmartPhone as a media center user interface, use a SmartPhone camera as a local computer camera, provide a multiple-display system, and access a vast amount of storage space. To this end, a framework\/mechanism is provided that uniformly controls the aggregate personal computer, comprised of multiple computing machines and their hardware devices, as a unified entity. From the user's perspective, the control and device usage is a seamless and relatively easy computing experience.","While the technology is described with various examples and architectures that provide flexible computing environments that are also stable and reliable, adaptable, intelligent, secure, extendable and updatable, it is understood that the architectures and components thereof are only examples of possible implementations. For example, some of the described separate components may be combined into a lesser number of components, while other components may be further separated into a greater number of components. In addition, much of the communication between devices describes an example network and example functions, structures and communication protocols, however it is understood that any suitable way of coupling devices for communication may be used.","As such, the present invention is not limited to any particular embodiments, aspects, concepts, structures, functionalities or examples described herein. Rather, any of the embodiments, aspects, concepts, structures, functionalities or examples described herein are non-limiting, and the present invention may be used various ways that provide benefits and advantages in computing in general.","Turning to , there is shown a general block diagram in which an example aggregate computer system  is comprised of a local computing machine  coupled via a network  to remote computing machines M-Mn. While one local computing machine  and six such remote computing machines M-Mn are exemplified in , it is understood that as few as one such remote computing machine up to any practical number may be present in a given environment. Moreover, although one machine is described as being \u201clocal\u201d with respect to other remote machines, in general, any machine can act as the local machine, and thus \u201clocal\u201d generally represents the one machine with which the user is (or the user believes to be) physically interacting at a given moment.","The network  may be any suitable wired or wireless network, or a combination of wired and wireless communication means, such as Ethernet and\/or WiFi, and so forth. Remote computing machines and\/or their hardware devices also may be coupled by other means, such as USB (Universal Serial Bus), serial, parallel, infrared, FireWire, Bluetooth\u00ae and the like; note that while some of these may not necessarily be considered \u201cnetwork\u201d connections in a conventional sense, for purposes of simplicity in this description, any such connections can be considered as networked via the network .","As described in more detail below, the local computing machine  includes an operating system framework , its local device hardware , and an aggregation mechanism\/framework  coupled to the network through networking components . In general, each of the remote devices M-Mn includes similar components, at least to the extent that each participates as part of the aggregate computer system . For example, a mobile telephone may not have sufficient resources to provide the same functionality as a personal computer, but still may make some or all of its software programs and\/or hardware available to the aggregate computer system  to an extent.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2A","FIG. 2A","FIG. 2A"],"b":["102","1","104","106","220","222","110","224","226","228","230","226","232","234","228","236","238","110"]},"Another set of components comprise kernel mode components, and in the example operating system framework  include system services  and device drivers  for the machine hardware . As described below, for the aggregation mechanism framework  there are virtual drivers , filter drivers , and one or more virtual bus drivers . In this example, a network connection API set  is provided for communicating with the remote devices (e.g., M-Mn).",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2B","FIG. 2A"],"b":"210"},"In , a configuration manager  is provided as a user mode component, as is an aggregate device manager  and aggregate connection manager . Much of the structure and functionality of these components are the same as example counterpart components of , however note that the aggregate connection manager  generally couples to the remote machines and their hardware devices in the example of .","For purposes of brevity, the following description is primarily with reference to , with the aggregate device manager  of  generally similar to the virtual device manager  of , and the aggregate connection manager  of  generally similar to the P2P scheduler  of .","In general, regardless of the example architecture, to provide for seamless sharing of devices, the current software (e.g., application) programs need not be changed in order to use the shared resources. To this end, device virtualization is provided as a model for device sharing. In one implementation, a hardware device of a shared remote computing machine (e.g., M) is mapped to a local device if an application wants to use that device, with the mapped device referred to as a virtualized device that acts as a proxy between the application program and the (remotely-located) real physical device. Applications and other programs use the remote device by interacting with the virtualized device.","The control center user interface  allows a user to change settings and to control the aggregate computer system . For example, via the user interface , the user can plug and unplug remote devices, lock and unlock local devices, and so forth. In one implementation, the user interface  provides a representation of the organization of the aggregate computer system  and the status of each machine and\/or device.","In general, the user interface  allows the user to change settings and take actions such as plug in or plug out remote devices. In one example implementation, the program's main message loop is also in the user interface , e.g., the function CreateTrayWindow( ). The user interface may be in any form, such as a popup menu on tray icon, or a full program window. When the aggregate device manager  first starts, it calls each component's initialization function to initialize, and then calls a function (e.g., CreateTrayWindow( )) to create the tray icon or other window and start the message loop. In order to link a menu item to a specified action, such as to plug in a remote device, a structure may be defined as follows:",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct tagMENU_PLUG"]},{"entry":[{},"{"]},{"entry":[{},"\u2003list_head list;"]},{"entry":[{},"\u2003LPTSTR lpDevice;"]},{"entry":[{},"\u2003DWORD deviceType;"]},{"entry":[{},"\u2003LPTSTR lpRemoteProvideri"]},{"entry":[{},"\u2003BOOL bLocalDevice;"]},{"entry":[{},"} MENU_PLUG, *PMENU_PLUG;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The configuration manager  saves and loads settings and configuration data related to the aggregate computer system . When the aggregate computer system  is started, the aggregate device manager  configures the aggregate computer system  according to any previous settings and configuration data, (at least to the extent that the configuration remains the same). When a setting is changed, the configuration manager  records that setting for the next incarnation, including after the aggregate computer system  is closed. Examples of information managed and saved for the aggregate computer system by the configuration manager  include a host name and a group name, the main channel's information, and remote provider's information. For example, the settings may be saved in a program directory (e.g., a config.ini) file, and when the system  starts, the configuration manager  loads the settings and each remote provider's address from that file. An example of such a file is set forth below:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Channel Information]"]},{"entry":[{},"APCName=APC1"]},{"entry":[{},"[Options]"]},{"entry":[{},"IsCloneScreen=0"]},{"entry":[{},"IsDisplayFullScreen=1"]},{"entry":[{},"[RemoteProviderAddress]"]},{"entry":[{},"Enum=SCUT-500234764D, Media Center,"]},{"entry":[{},"SCUT-500234764D#Interface=ViaIP"]},{"entry":[{},"SCUT-500234764D#Type=1"]},{"entry":[{},"SCUT-500234764D#Addr=02004B597F000001"]},{"entry":[{},"Media Center#Interface=ViaIP"]},{"entry":[{},"Media Center#Type=1"]},{"entry":[{},"Media Center#Addr=02004B59AC174146"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the [Channel Information] section in the above example, the APCName is the name of aggregate computer system , and is also the group name. The settings are in the [Options] section. In the section [RemoteProviderAddress], the Enum field enumerates the remote device providers' name. The connection interface which the device provider is on, the machine type of the device provider, and its address on that connection interface are recorded in MachineName#Interface, MachineName#Type, MachineName#Addr fields, respectively.","In this example, a function LoadOptions( ) loads the options from the profile, and the function CfgSwitchXxx( ) switches the corresponding setting and writes the setting to the profile. The function CfgIsXxx( ) can be used to query the settings. A function LoadRemoteProvider( ) loads the remote device providers' information from the profile and a function SaveRemoteProvider( ) saves the remote device providers' information in the profile and the function. Whenever the settings are changed, the save function of the configuration manager  is called and the settings are saved in the configuration file. When the aggregate device manager  is shut down, the remote device providers' information is updated and saved in the profile. In general, the remote device provider's information is saved and loaded when the aggregate computer system  starts because this makes discovering other remote machines much faster than broadcasting messages on the network. This also makes it possible for two aggregate system machines to communicate with each other even they are not on the local area network, (whereby broadcasting messages to each other may fail). Note however that in such a situation, the remote provider's address needs to be added in the profile manually or via another user interface.","In this example, the Configuration Manager starts in CfgStartHost( ) and closes in CfgCloseHost( ). The local devices are added to the local device provider list in the function CfgStartHost( ). A first broadcast message is also sent in this function.","The aggregate device manager  records an identifier for each member (e.g., its address) of the aggregate computer system . When the aggregate computer system  is restarted, those members are remembered even if not discovered.","In general, the aggregate device manager  provides management for devices in the aggregate computer system ; (additional details about one example aggregate device manager  are set forth below). The various computing machines that compose the aggregate computer system  cooperate by providing access to their hardware devices. In general, each hardware device connected to a machine of the aggregate personal computer  physically is regarded as a device of the whole aggregate personal computer system  (although it is feasible to limit access to any device). Any device may be utilized by any aggregate personal computing machine in this system  through the network connection. For example, the mouse of the local computing machine  can be used as a mouse of the remote computing machine D, and vice-versa; the keyboard of D can be used as a keyboard of the device D and vice-versa, and so forth.","The aggregate device manager  thus controls the devices in each computing machine of the aggregate computer system . In one example architecture, the aggregate device manager  runs in the user mode of the operating system platform and communicates with the virtual bus driver  running in kernel mode. Management includes discovering and registering of physical devices, local and remote device management, device Plug-and-Play management, device connection and data transfer between aggregate computing machines. Management also includes local device broadcasting, connection maintenance between aggregate computing machines, and management of filter driver controllers and virtual driver controllers.","Connectivity to each other aggregate computing machine in the aggregate computer system  is provided by the aggregate connection manager ; (additional details about one example aggregate connection manager  are set forth below). The aggregate connection manager  allows various connections (e.g., via connection modules) between the aggregate computing machines  and M-Mn, to generally provide the same communication experience to other components, and in particular to the aggregate device manager , regardless of the actual connection type, e.g., via Ethernet, USB, Bluetooth, Wi-Fi, IrDA or any other connection mechanism.","In one example, the aggregate connection manager  provides various functionalities for the aggregate device manager . Such functionalities include registering and management of connection modules, establishing and terminating of communication channels, broadcasting information for the local computing machine, discovering communication channels of the other remote aggregate computing machines, and connection and data transfer between communication channels.","Turning to the aspects of remote device connection, as generally represented in , when a remote device connection between two computing machines is established, the machine that has the real physical device connected provides its device to the other machine, and is referred to as a device provider; the other machine that uses the virtual device is called the device consumer. A computing machine may be a device consumer and a device provider at the same time. Note that in , the \u201cL\u201d in each component label represents the local component, and the \u201cR\u201d in each component label represents the remote counterpart component corresponding to that local component, but the \u201cL\u201d and \u201cR\u201d labels are omitted in the following description except where otherwise noted.","For each computing machine such as the local computer , the controllers  for virtual drivers run in user mode (in this example), and register virtual device drivers  to the aggregate device manager . In one aspect, the controllers  provide communication between the user mode aggregate device manager  and the kernel mode virtual device drivers . The virtual device drivers  run in kernel mode and report to the operating system as devices connected to the computing machine. As a result, consumer applications  running in the same (local) computing machine may operate the (remote) virtual hardware devices through the operating system APIs  and consider those virtual devices as if they were local physical devices. Operations between the applications  and the virtual devices are reported to the aggregate device manager  by the controllers  of virtual drivers , and those operations are transferred to the remote physical devices through the aggregate connection manager . Note that a virtual driver may be installed and run in the device consumer computer only after a remote device connection between two computing machines is established.","The consumer's virtual drivers  are implemented for each virtual driver component and run in kernel mode. They are developed for virtual devices and report to the operating system framework  (e.g., to system services ) as real physical device drivers. In one example, the virtual drivers  are installed in a device consumer only once remote device connections between the consumer and one or more other aggregate computing machines are established.","After the virtual device drivers  are installed, applications  running in the operating system framework  may consider those virtual devices on the device consumers as physical devices and operate them through the operating system APIs . In turn, the APIs  call system services  which then call the virtual device drivers  to complete operations on the virtual devices. In general, the virtual device drivers  send commands and data to the real physical device in the other end of aggregate computer system , i.e., the device provider such as the machine M in , and then respond or return data from the provider. In general, the virtual device drivers  act like agents of the remote devices in other computing machines, and guarantee the data and command connection between the device consumers and the device providers.","The controllers  for filter drivers are implemented for each filter driver component, and run in user mode. The controllers  register filter device drivers with the aggregate device manager  and provide a communication path between the aggregate device manager  and their respective filter device driver (of the set of drivers ) that run in kernel mode. The filter drivers directly control the physical devices in kernel mode.","When a remote device connection between two aggregate computing machines is established, each filter driver of the physical device transfers data between the device and the filter driver controller , and the filter driver controller  communicates with the aggregate device manager . In turn, the aggregate device manager  transfers device data to the other computing machine's (the consumer's) virtual driver.","The filter drivers  for the device providers are installed in device providers, run in kernel mode and are those developed for real physical devices and filter packets of real physical devices. When device providers provide physical devices to other computing machines, the filter drivers capture the data from physical devices and send them to the device consumer. As the filter drivers filter the packets, that machine's operating system no longer receives data packets from physical devices, whereby the physical devices appear to the device providers to have been disconnected (\u201cplugged out\u201d). Commands and output data packets from device consumers are sent to the physical device through the filter drivers. An advantage of using filter drivers rather than using application filtering is that the filter drivers run lower in kernel mode and it is safer because few applications can access their data.","In this example, virtual devices are used to control local hardwires, however classic buses require hardware support, and the connected devices should also have hardware. In order to be connected to the bus, the device's hardware should be designed according to the bus requirements. These concepts prevent such \u201cvirtual devices\u201d (those without local hardware) from being connected and managed by these buses. To solve this problem, in one aspect a virtual bus that does not control any hardware is implemented so as to enable Plug and Play of virtual devices. Note that the virtual bus is a hypothetical bus that does not control any hardware; the devices connected to it also have no local hardware support.","A virtual bus driver  is provided for the virtual bus on which the virtual device drivers are installed. The aggregate device manager  communicates with virtual devices through the virtual bus driver . The virtual bus driver  controls data transfer between virtual devices and the aggregate device manager , controls the installation of virtual device drivers, controls virtual device registration to the operating system, and controls un-installation of the virtual devices from the operating system. The virtual bus driver  provides virtual device management and Plug-and-Play features of the aggregate computer system .","Various features of the virtual bus include that it controls no bus hardware, yet can attach virtual devices that do not have local hardware. The virtual bus can attach any kind of virtual device, and the connected device is regarded as a real device by the operating system.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 4","b":["444","444","440","442","444"]},"As represented in , the computer system includes real and virtual devices, with real devices exemplified by a sound card  and a network card  operating via the PCI Bus , a graphics card  operating via the AGP bus , and a camera  operating via the USB (external) bus . The virtual devices  operate via the virtual bus , and are exemplified by a virtual sound card , a virtual network card , a virtual graphics card  and a virtual camera .","The applications (two are shown labeled  and ) of a device consumer are the applications which operate on devices. As is understood, the applications do not know whether the devices they are using are local devices or virtual devices.","Also represented in  is a device manager , which is a kernel component of the operating system that tracks loaded drivers and their interfaces. For example, the device manager  can notify the user when device interfaces become available and unavailable. The power manager  is also a kernel component of Windows\u00ae operating system responsible for managing power usage for the system. The power manager  administers the system-wide power policy and tracks the path of the power I\/O request packets (IRPs) through the system. The PnP manager  includes a kernel-mode PnP manager and a user-mode PnP manager. The kernel-mode PnP manager interacts with operating system components and drivers to configure, manage, and maintain devices. The user-mode PnP manager interacts with user-mode setup components, such as Class Installers, to configure and install devices. The user-mode PnP manager also interacts with applications, for example to register an application for notification of device changes and notify the application when a device event occurs.","As also represented in , the I\/O manager  is a core component of the operating system I\/O subsystem. The I\/O manager  exports I\/O system services, which user-mode protected subsystems may call to carry out I\/O operations on behalf of their applications and\/or end users. In general, the I\/O manager  intercepts these calls, sets up one or more IRPs, and routes them through possibly layered drivers to physical devices.","The operating system interacts with buses exclusively by the bus drivers, wherein a bus driver services a bus controller, adapter, or bridge. There is one bus driver for each type of bus in a machine; in general each bus driver enumerates the devices on its bus, responds to Plug and Play IRPs and power management IRPs, provides multiplex access to the bus, and generically administers the devices on its bus. A bus driver acts as the function driver for its controller, adapter, or bridge, and therefore manages device power policy for these components.","As represented in , there is provided a virtual bus driver  to control the virtual bus  (). In general, the virtual bus  and virtual bus driver  fulfill the requirements of the operating system and manages connected virtual devices.  represents a typical driver stack when virtual devices are connected to the virtual bus  via their virtual device drivers  and . When the device manager  queries for a child device list of the virtual bus , two devices are reported. After loading the  and  for these child devices, the operating system is able to use these devices like other local devices. Because the virtual devices do not control hardware, the data processing is redirected to other places, rather than locally. For example, in , the virtual devices get or receive data through a network, with the data processing performed by the remote devices  and , respectively.","To summarize, the virtual bus driver  controls the virtual bus , communicates with the operating system and manages virtual devices. The virtual device driver  or  controls its virtual device and presents the virtual devices to the operating system as real devices, where, as set forth above, real devices  and  are physical devices connected to other computers or mobile devices among the network, and consumed by the virtual devices.","Because a virtual bus  does not control hardware, plug and play is simulated to make the virtual devices usable. To this end, a series of steps are performed to prepare a virtual device for use. As represented in , example steps for plugging a new device into the virtual bus  include notifying the bus driver  to plug in a new device, e.g., via a user's request through an application (step ).","In response, the virtual bus driver  creates a child PDO (Physical Device Object) for the virtual device, and keeps it in an internal list of children (child list), and reports a device relation change to the operating system.","At step , the PnP manager  sends a PnP event IRP to the virtual bus  to query the updated device list. The virtual bus driver  responds with an array of the currently attached child devices, as represented by step . By comparing (step ) the device list with a previous one, the operating system recognizes that a new device has been connected, whereby at step  the PnP manager  sends a series of PnP events to the virtual bus  to query for detailed device information of the newly added device. The virtual bus driver  responds with the device information, as represented by step . According to the device information, at step  the operating system loads the appropriate driver (e.g., ) for the newly added device.","At this time, the new device is ready for use, whereby the operating system is able to send data to or receive data from the virtual device like other local devices. Note again that because the virtual device does not have any hardware, the data processing should be done by other ways, such as by remote processing.","When a virtual device is removed, the PnP manager  sends a series of PnP events to the virtual bus driver  and the device driver (e.g., ). The virtual bus driver  responds by removing the PDO of the corresponding child device from the internal child list, and destroys the PDO.","As can be seen, sending PnP events is one primary way for an operating system to communicate with the virtual bus driver  and query information about enumerated devices. The bus driver  is required to process some of these events, and respond with requested data.","Two types of PnP events include PnP events for the bus driver , and PnP events for the child PDO; the bus driver  needs to handle these types. Set forth below is one example as to how the virtual bus driver  handles these PnP events:",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PnP events for bus driver:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Process"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["IRP_MN_QUERY_DEVICE_RELATIONS","Virtual bus driver"]},{"entry":[{},"handles BusRelations"]},{"entry":[{},"request for its FDO. The"]},{"entry":[{},"PnP manager sends"]},{"entry":[{},"this request to query the"]},{"entry":[{},"child devices when the"]},{"entry":[{},"device is enumerated"]},{"entry":[{},"and at other times"]},{"entry":[{},"while the device is"]},{"entry":[{},"active. The virtual bus"]},{"entry":[{},"driver handles it by"]},{"entry":[{},"returning a list of"]},{"entry":[{},"pointers to the PDOs"]},{"entry":[{},"of the connected"]},{"entry":[{},"child devices."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PnP events for child PDO"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IRP_MN_QUERY_CAPABILITIES","When a device is enumerated,"]},{"entry":[{},"but before the function and"]},{"entry":[{},"filter drivers are loaded"]},{"entry":[{},"for the device, the PnP"]},{"entry":[{},"Manager sends this request"]},{"entry":[{},"to the parent bus driver for"]},{"entry":[{},"the device. The virtual bus"]},{"entry":[{},"driver handles it by setting"]},{"entry":[{},"the DEVICE_CAPABILITIES"]},{"entry":[{},"structure to specify the"]},{"entry":[{},"capabilities of the child"]},{"entry":[{},"device."]},{"entry":["IRP_MN_QUERY_ID","There are four types of IDs"]},{"entry":[{},"the virtual bus driver"]},{"entry":[{},"handles:"]},{"entry":[{},"BusQueryDeviceID,"]},{"entry":[{},"BusQueryInstanceID,"]},{"entry":[{},"These two IDs are used to"]},{"entry":[{},"differentiate a device from"]},{"entry":[{},"other devices on the same"]},{"entry":[{},"machine."]},{"entry":[{},"BusQueryHardwareIDs,"]},{"entry":[{},"BusQuerycampatibleIDs."]},{"entry":[{},"These two IDs allow Setup to"]},{"entry":[{},"locate the appropriate"]},{"entry":[{},"drivers for the bus's child"]},{"entry":[{},"device."]},{"entry":[{},"Virtual bus driver returns"]},{"entry":[{},"the IDs according to the"]},{"entry":[{},"child device type."]},{"entry":["IRP_MN_QUERY_DEVICE_RELATIONS","The PnP manager sends this"]},{"entry":[{},"IRP to gather information"]},{"entry":[{},"about devices with a"]},{"entry":[{},"relationship to the"]},{"entry":[{},"specified device. Virtual"]},{"entry":[{},"bus driver handles this"]},{"entry":[{},"request for"]},{"entry":[{},"TargetDeviceRelation for its"]},{"entry":[{},"child devices. It returns"]},{"entry":[{},"the pointer to PDO for the"]},{"entry":[{},"specified child device."]},{"entry":["IRP_MN_QUERY_DEVICE_TEXT","The PnP manager uses this"]},{"entry":[{},"IRP to get a device's"]},{"entry":[{},"description or location"]},{"entry":[{},"information. This string is"]},{"entry":[{},"displayed in the \u201cFound New"]},{"entry":[{},"Hardware\u201d pop-up window if"]},{"entry":[{},"no INF match is found for"]},{"entry":[{},"the device. Virtual bus"]},{"entry":[{},"driver returns a string"]},{"entry":[{},"description of the child"]},{"entry":[{},"device."]},{"entry":["IRP_MN_QUERY_RESOURCES","The PnP manager uses this"]},{"entry":[{},"IRP to get a device's boot"]},{"entry":[{},"configuration resources. The"]},{"entry":[{},"virtual bus driver does"]},{"entry":[{},"nothing when processing this"]},{"entry":[{},"request because none of its"]},{"entry":[{},"child devices consume local"]},{"entry":[{},"resources."]},{"entry":["IRP_MN_QUERY_RESOURCE_REQUIREMENTS","The PnP manager uses this"]},{"entry":[{},"IRP to get a device's"]},{"entry":[{},"alternate resource"]},{"entry":[{},"requirements list. The"]},{"entry":[{},"virtual bus driver does"]},{"entry":[{},"nothing when processing this"]},{"entry":[{},"request."]},{"entry":["IRP_MN_QUERY_BUS_INFORMATION","The PnP manager uses this"]},{"entry":[{},"IRP to request the type and"]},{"entry":[{},"instance number of a"]},{"entry":[{},"device's parent bus. Virtual"]},{"entry":[{},"bus driver returns the"]},{"entry":[{},"request information."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Turning to aspects related to networking, the network aggregate connection manager  for the aggregated computer system  provides a mechanism for applications on different machines that are connected by diverse networks to communicate with each other with unified experience. This includes connecting various kinds of computing machines, such as Desktop PCs, Laptops, Pocket PCs and\/or Mobile phones, and seamlessly sharing I\/O devices such as a mouse, keyboard, display and camera between these computers. However, because of the different features of these computers, network connection between them can be distinct, such as over Ethernet, WI-FI, Bluetooth or USB.","In general, the aggregate connection manager  hides the details of the underlying network physical mediums and topology structures, and provides a unified APIs for applications to communicate with each other transparently and efficiently.","In one example implementation, the aggregate connection manager  provides APIs for applications to communicate over a virtual named channel based on a client\/server mode. Similar to named pipes, a virtual named channel is a named, duplex channel for communication between a channel server and one or more channel clients. The instances of a virtual named channel share the same pipe name, but each instance has its own buffers and handles, and provides a separate conduit for client-server communication. In general, the aggregate connection manager  hides the details of the underlying network including network type and network address, and provides a simple unified APIs for applications to communicate with each other, in an efficient way with respect to establishing a data connection, transferring data and checking network exceptions.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["254","770","772","774","776","778","780","254"]},"The connection APIs  comprise a set of functions which can be called by applications; these functions may be linked into a single DLL with an additional exported library. The channel management module  contains sub-components - that provide the underlying implementation of the exported APIs.","Each virtual named channel can be viewed as a server which can be connected by one or more clients. These servers are managed by a virtual named channel service component . Channel instance management  manages the mapping relationship between created virtual named channel instances and the underlying sockets. Data transferring  controls how data is receive or sent over the virtual named channel. Exceptions and errors on virtual named channels are handled by an exception handling component .","The host management module hides the details of discovering available hosts in the network environment which is accomplished by host discovery component , and resolving network address of a host by host address resolving component .","Each virtual named channel has a unique name, e.g., with format as \u201c\/\/Servername\/channel\/channelname\u201d where Servername is either the name of a remote computer or a period (or the like) that specifies the local computer. For example, when the channel server creates a virtual named channel, the ServerName is a period, e.g., \/\/.\/channel\/channelname.","When a client connects to a virtual named channel server, the name of the virtual channel is specified, where ServerName is the name of the remote computer. Available virtual named channels and their associated names can be enumerated by the connection APIs.","With respect to host discovery and virtual named channel enumeration, an application utilizing the connection APIs to communicate only needs to know the name of the virtual named channel with which to connect, and then connects with the channel, rather than resolving the virtual named channel to a connectable endpoint containing IP address and port number. To this end, such details are implemented in the aggregate connection manager , which is transparent to the upper levels.","The aggregate connection manager  implements a mechanism to get the dynamic view of the hosts joined to the aggregated computer system and their network addresses. If the underlying network is LAN or WLAN, IP multicast is utilized to discover hosts, while direct searching is performed if the underlying network is an Ad-hoc Bluetooth network. When the aggregate connection manager  is initialized on a host in LAN or WLAN, the host joins a special multicast group, an IP multicast packet containing the host's network address is sent by the host management module to this special multicast group to indicate that this host is joining the aggregated computer system. Other hosts which have already joined the special multicast group and the aggregated computer system receive the multicast packet and reply directly to the original host with UDP packets to indicate their existence. After this process, the newly joined host and existing host discover each other.","The host management module  on each joined host sends a keep-alive multicast packet to the special multicast group (e.g., every few minutes) to indicate its existence. If a host is going to leave the aggregated computer system , the host management module  on that host sends a multicast packet to notify others of its leaving. However, IP multicast is not supported in Ad-hoc Bluetooth network, whereby available hosts and their network addresses need to be searched and discovered directly by the host management module . The discovery process may be repeated (e.g., every few minutes) to discover newly joined hosts and remove hosts that have left.","To let applications know which virtual named channels have been created in the aggregated computer system environment before connecting with one channel, a function is provided by the connection APIs  to enumerate the available virtual named channels. In one example implementation, the channel management module  sends a request to each available host for requiring information about the created virtual named channels on this host, such as channel name, channel properties, and channel endpoint address (IP and port). The information is saved in a local cache and returned to the user. For better performance, the content of the cache may be directly returned (without doing actually querying) when the application enumerates available virtual named channels.","A virtual named channel as a server is associated with an actual server socket and listens on that server socket before any client can connect with the channel. In one implementation, a TCP server socket bound on a distinct port is created for each virtual named channel, as managed by the virtual named channel service component.","Communication between the channel server and a client is based on a virtual named channel instance, which is implemented as a wrapper of a low-level TCP socket object managed by the operating system. When a client is connecting to a server channel, an underlying TCP socket is created and connects with the TCP server socket of the server channel. Then, the underlying TCP socket is wrapped by a virtual named channel instance which is used by the client to communicate with the server.","At the server side, a TCP socket is created each time a client connects; the created TCP socket is then wrapped by a virtual named channel instance which is used by the server application to communicate with the client. However, the underlying sockets on both sides are responsible for actually transferring the data through this channel. The relationship between the virtual named channel instance and the underlying socket is managed by the channel instance management component. Exceptions and errors occurring on the underlying socket are reflected on the corresponding virtual channel instance, and applications are notified about such exceptional events.","A virtual named channel instance can be operated in blocking mode or non-blocking mode. In blocking mode, reading and sending operations are blocked until there is data to be read from the channel or the data sent to the channel has been sent out. While in non-blocking mode, reading and sending operations return immediately and the actual operations on the instance are finished in an asynchronous way.","A virtual named channel instance can be message based or byte-stream based. When the channel instance is message based, a basic unit of data operated on this channel instance is a well-defined message. For example, a reading operation is blocked until the whole message including message header and data content has reached on the channel instance; also a sending operation is blocked until all parts of the message has been sent out through the channel instance. Message-based channel instance is operated in blocking mode.","When the channel instance is byte-stream based, a basic unit of data operated on the channel instance is a byte. A byte-stream based channel instance can be operated in blocking mode or non-blocking mode.","The connection APIs comprise a set of functions used for communicate between applications. The following functions are supported in one example, (where the term \u201cServer\u201d refers to the application that creates a channel server and is listening for clients, and the term \u201cClient\u201d refers to the application that connects to a channel server).","CmInit( );",{"@attributes":{"id":"p-0093","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["Initialize Network Connection Manager. Server or Client.\n\nCmRelease( );\n","Release the associated resources with Network Connection Manager. Server or Client.\n\nCmCreateChannel( );\n","Create a virtual named channel. Server only.\n\nCmDestroyChannel( );\n","Destroy a virtual named channel. Server only.\n\nCmOpenChannel( );\n","Wait for incoming connection to the virtual named channel and open a channel instance on the virtual named channel to connect with the client. Server only.\n\nCmCloseChannel( );\n","Close a channel instance and close the connection with the client. Server only.\n\nCmConnectChannel( );\n","Connect to a virtual named channel. Client only.\n\nCmDisconnectChannel( );\n","Disconnect to a virtual named channel. Client only.\n\nCmReadChannel( );\n","Read data from a virtual named channel instance. Server or Client.\n\nCmwritechannel( );\n","Write data to a virtual named channel instance. Server or Client.\n\nCmEnumChannels( );\n","Enumerate all the available virtual named channels and return their names. Client only.\n\nCmGetChannelInfoByName( );\n","Retrieve information about a virtual named channel by its name. Server or Client.\n\nCmGetChannelInfoByHandle( );\n","Retrieve information about a virtual named channel by its handle. Server only."]}}}},"By way of example using code samples a server typically operates as follows when using the APIs:",{"@attributes":{"id":"p-0095","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CmInit( );"]},{"entry":[{},"CmCreateChannel( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CmOpenChannel( );","\/\/ block until a client connects with"]},{"entry":[{},{},"\/\/ channel;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"\u2003\/\/ call CmReadChannel( )\/CmWriteChannel to communicate"]},{"entry":[{},"\u2003\/\/ \u2002with the client;"]},{"entry":[{},"..."]},{"entry":[{},"CmCloseChannel( );"]},{"entry":[{},"CmDestroyChannel( );"]},{"entry":[{},"CmRelease( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A client typically operates as follows when using the APIs:",{"@attributes":{"id":"p-0097","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CmInit( );"]},{"entry":[{},"CmConnectChannel( ); \/\/ block until connection is finished;"]},{"entry":[{},"..."]},{"entry":[{},"\/\/ call CmReadChannel( )\/CmWriteChannel to communicate with"]},{"entry":[{},"\/\/ the server;"]},{"entry":[{},"..."]},{"entry":[{},"CmDisconnectChannel( );"]},{"entry":[{},"CmRelease( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A client also may call CmEnumChannels( ) to get the available virtual named channels and then call CmConnectChannel( ) to connect with one of them.","Turning to various aspects of communication, the aggregate computer system  is not a fixed computer system, but rather is adaptable to changes of the number of computing machines as well as to changes of computer members' network addresses. The computing machines in the system discover each other by broadcasting or multicasting on the network. To this end, when a computing machine is started, the device broadcasts its network address and its brief information to the other computing machines on the network. When one device receives the broadcast message from another device, the receiving device thus knows the sending device's network address and can connect to the sender device to retrieve further information and establish a connection. In this way, every computing machine member in the aggregate computer system  can discover each other by broadcasting and receiving the broadcast message from each other.","The adaptation to device changes is like the Plug-and-Play in a single computer. Whenever a device is plugged in or plugged out, locked or unlocked by the device provider, the aggregate computing machine involved broadcasts a message to notify others to update its device list.","The devices in each computing machines can be switched and connected to others through network communication. As the devices in the system communicate with the system by digital data, the aggregate computer system  connects devices on different computers by digital data transfer between them. The device provider uses filter drivers to capture device data and send them to a remote device consumer through network. Via virtual device drivers, the device data from the device provider are sent to the operating system on the device consumer. Then the system provides the device to the applications running in the system.","The aggregate device manager  provides management for devices in the aggregate computer system. Different machines that compose the aggregate computer system need to cooperate with their devices. In general, each device physically connected to an aggregate computer system  is regarded as being a device of the whole aggregate computer system , which can be utilized by any aggregate computing machine in the system through a network connection. The aggregate device manager  controls the devices in each aggregate computer system  by providing management related to physical device discovering and registering, local and remote device management, device Plug-and-Play management, device connection and data transfer between computing machines, remote device discovering, local device broadcasting, connection maintenance between computing machines, management of filter driver controllers, and management of virtual driver controllers.","With respect to physical devices discovering and registering, the discovering process is completed by calling VmUpdateLocalDeviceList( ) in each filter driver controller. Whenever the controller of the filter driver find a new physical device newly connected to the system, the controller calls VmUpdateLocalDeviceList( ) to let the aggregate device manager  update the local device list. This function calls each filter driver controller's query device list function to query the current device list and add each local device to the local device list. After getting the local device lists from each filter driver controller, the aggregate device manager  calls BroadcastLocalDeviceListUpdated( ) to broadcast a message indicating that this aggregate machine's device list has been updated.","When an aggregate computing machine starts, it calls each filter driver controller's query device list function to query the device list and add each local device to the local device list. Note that the display's filter driver controller will only report a fixed display device named \u201cPrimary Monitor.\u201d Other devices' filter driver controllers will report devices found in the system, and their name in the operating system, respectively.","After the aggregate device manager  gets the local device lists from each filter driver controller, the aggregate device manager  calls VmAddLocalDeviceProvider( ) to add devices in the local device list. Two lists, g_listLocalDevices and g_listRemoteProviders, hold the local and remote device lists in the aggregate device manager . The list member of g_listLocalDevices is the type of PLOCAL_DEVICE_LIST_ENTRY. It is a pointer to LOCAL_DEVICE_LIST_ENTRY structure that records the local device's type, name, handle, status, consumer's name, provider channel and communication channels linked to it, and is defined as follows:",{"@attributes":{"id":"p-0106","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct tag_LOCAL_DEVICE_LIST_ENTRY"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003struct list_head","list;",{}]},{"entry":["\u2003HANDLE","hChannel;","\/\/ provide on which channel"]},{"entry":["\u2003DWORD","deviceType;","\/\/ type of device, starting from 1"]},{"entry":["\u2003HANDLE","hAppHandle;","\/\/ device handle for device"]},{"entry":[{},{},"\/\/ related application"]},{"entry":["\u2003LPTSTR","lpDeviceName;","\/\/ device name, can't be NULL"]},{"entry":["\u2003DWORD","dwStatus;","\/\/ status: DEVICE_LOCKED,"]},{"entry":[{},{},"\/\/ DEVICE_PLUGGED_OUT"]},{"entry":["\u2003LPTSTR","lpConsumer;","\/\/ consumer's name, can't be NULL,"]},{"entry":[{},{},"\/\/ \u201c\u201d at least,"]},{"entry":[{},{},"\/\/ may be deleted if share mode"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003struct list_head","listChannelInstance;","\/\/ channel instances"]},{"entry":[{},{},"\/\/ linked, more than one"]},{"entry":[{},{},"\/\/ if in share mode"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\/\/DWORD","dwAccess;","\/\/ read\/write\/password"]},{"entry":[{},{},"\/\/ protected, etc."]},{"entry":["\u2003\/\/LPTSTR","lpPassword;","\/\/ password to use this device"]},{"entry":["\u2002BOOL","bPresent;","\/\/ Mark whether the device is still"]},{"entry":[{},{},"\/\/ present"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} LOCAL_DEVICE_LIST_ENTRY,"},{"entry":"*PLOCAL_DEVICE_LIST_ENTRY;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The list member of g_listRemoteProviders is the type of PREMOTE_PROVIDER_ENTRY. It is a pointer to REMOTE_PROVIDER ENTRY structure which records remote provider's handle, name, machine type, device list, and is defined as follows:",{"@attributes":{"id":"p-0108","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct tag_REMOTE_PROVIDER_ENTRY"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003struct list_head","list;",{}]},{"entry":["\u2003HANDLE","hProvider;","\u2003\/\/ handle of provider"]},{"entry":["\u2003LPTSTR","lpProviderName;","\u2003\/\/ name of provider"]},{"entry":["\u2003DWORD","dwMachineType;","\u2003\/\/ type of provider's machine"]},{"entry":["\u2003int","nDevices;","\u2003\/\/ number of devices"]},{"entry":["\u2003PDEVICE_INFO","devices;","\u2003\/\/ array of devices"]},{"entry":["\u2003BOOL","bPresent;","\u2003\/\/ mark whether the provider"]},{"entry":[{},{},"\u2003\/\/ is still present"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} REMOTE_PROVIDER_ENTRY,"},{"entry":"*PREMOTE_PROVIDER_ENTRY;"},{"entry":"typedef struct tag_DEVICE_INFO"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003LPTSTR","lpDeviceName;",{}]},{"entry":["\u2003DWORD","dwDeviceType;"]},{"entry":["\u2003DWORD","dwStatus;","\/\/ status: DEVICE_LOCKED,"]},{"entry":[{},{},"\/\/ DEVICE_PLUGGED_OUT"]},{"entry":["\u2003LPTSTR","lpConsumer;"]},{"entry":["\u2003\/\/struct list_head","listConsumers;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} DEVICE_INFO, *PDEVICE_INFO;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"There are two pairs of functions which can add or delete the list members of g_listLocalDevices and g_listRemoteProviders:",{"@attributes":{"id":"p-0110","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"VmAddLocalDeviceProvider( ) \u2002and \u2002VmDeleteLocalDeviceProvider( );"},{"entry":"AddRemoteProviderEntry( ) \u2002and \u2002RemoveRemoteProviderEntry( )."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"These functions add or delete the list members of g_listLocalDevices and g_listRemoteProviders. Example places where they are called are set forth below:",{"@attributes":{"id":"p-0112","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"VmAddLocalDeviceProvider( ):"},{"entry":"\u2003CfgStartHost( ) \u2002when host is started"},{"entry":"\u2003VmUpdateLocalDeviceList( ) \u2003when local device list is updated."},{"entry":"VmDeleteLocalDeviceprovider( ):"},{"entry":"\u2003EndUpdateLocalDeviceList( ) \u2002when local device is disappeared."},{"entry":"AddRemoteProviderEntry( ):"},{"entry":"\u2003VmFoundNewProvider( ) \u2002when a new device provider is found."},{"entry":"RemoveRemoteProviderEntry( ):"},{"entry":"\u2003UIChangeGroup( ) \u2003which needs to clear all providers after"},{"entry":"\u2003group is changed."},{"entry":"\u2003ConnectionMaintainThread( ) \u2002when the provider disappeared."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"VmDeleteLocalDeviceProvider( ) and RemoveRemoteProviderEntry( ) are also called in MainRouting( ) to release memory when the aggregate device manager  is going to be shut down.","Device Plug-and-Play features are based on the operating system and the controllers of the filter drivers for physical devices. When a Plug-and-Play device is connected to the aggregate computer system , the controller of the filter driver for that particular kind of device receives a notification from the operating system and calls VmUpdateLocalDeviceList( ) to notify the aggregate device manager that the local device list should be updated. The aggregate device manager registers this newly added device to the local device list and broadcasts a message that the local device list in the aggregate computer system  has been updated, in order to let other computing machines of the aggregate computer system  retrieve the updated device list.","The broadcast is completed by calling a function, e.g., CmQueryChannels( ), which is also the function that broadcast the network address to other computing machines. In one example implementation, the broadcast message comprises a UDP packet in \u201cViaIP\u201d connection module, and is exemplified as follows:",{"@attributes":{"id":"p-0116","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct tag_PROVIDER_INFO_UDP_PACKET"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003DWORD","dwFlag; \u2003\u2003\/\/ PROVIDER_INFO_FLAG or"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003QUERY_PROVIDER_INFO_FLAG"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003DWORD","dwStatus;","\/\/ status of the provider"]},{"entry":["\u2003DWORD","dwPort;","\/\/ port number"]},{"entry":["\u2003DWORD","dwMachineType;","\/\/ machine type"]},{"entry":["\u2003DWORD","cbNachineName;","\/\/ size of characters in machine name"]},{"entry":["\u2003TCHAR","szMachineName[1];","\/\/ characters of machine name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} PROVIDER_INFO_UDP_PACKET,"},{"entry":"*PPROVIDER_INFO_UDP_PACKET;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"After other computing machines receive the broadcast message, they attempt to retrieve the device list from the computer that sent the message. Because the broadcast message is sent after the device list has been updated, the other computing machines will get the updated device list. In this manner, the device list in the various computing machines of the aggregate computer system  is refreshed, whereby and the plugged-in Plug-and-Play device can be provided to any remote aggregate computing machine.","Local devices are published to other remote computing machines by broadcasting. In order to save network load, each computing machine in the aggregate computer system  broadcasts its device provider information in a UDP packet rather than broadcasting the entire device list. Because only brief provider information is provided in the broadcast message, the receiver of the message needs to connect to the device provider to retrieve the provider's device list.","After receiving the broadcast message from other computing machines, the aggregate device manager  tries to retrieve the device list information from the device providers. The aggregate connection manager  first receives the broadcast message and then calls a function, e.g., VmFoundNewProvider( ), which has been registered by the aggregate device manager  as a callback function. In VmFoundNewProvider( ), the aggregate connection manager  connects to the device provider and sends a control code (e.g., VM_CTL_QUERY_DEVICE_INFO) to query the device list information. In one example, the data returned from the device provider is as follows:",{"@attributes":{"id":"p-0120","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\/\/ data sent by device provider"},{"entry":"DWORD \u2003\u2003\u2003dwDeviceNum; \u2003\u2003\/\/ number of devices"},{"entry":"DEVICE_INFO_LIST"},{"entry":"\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003LONG","cbDeviceName;","\/\/ size of the first device"]},{"entry":[{},{},"\/\/ name string"]},{"entry":["\u2003\u2003\u2003TCHAR","szDeviceName[ ];","\/\/ the first device name"]},{"entry":["\u2003\u2003\u2003DWORD","dwDeviceType;","\/\/ device type"]},{"entry":["\u2003\u2003\u2003DWORD","dwStatus;","\/\/ status: DEVICE_LOCKED 0x1,"]},{"entry":[{},{},"\/\/ DEVICE_PLUGGED_OUT 0x2"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003LONG","cbConsumerName;","\/\/ size of consumer name"]},{"entry":["\u2003\u2003\u2003TCHAR","szConsumerName[ ];","\/\/ if no consumer, it's \u201c\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003LONG","cbDeviceName;","\/\/ size of the second device"]},{"entry":[{},{},"\/\/ name string"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003TCHAR","szDeviceName[ ];","\/\/ the second device name"]},{"entry":["\u2003\u2003\u2003DWORD","dwDeviceType;","\/\/ device type"]},{"entry":["\u2003\u2003\u2003DWORD","dwStatus;","\/\/ status: DEVICE_LOCKED 0x1,"]},{"entry":[{},{},"\/\/ DEVICE_PLUGGED_OUT 0x2"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003LONG","\u2002cbConsumerName;","\/\/ size of consumer name"]},{"entry":["\u2003\u2003\u2003\u2003TCHAR","szConsumerName[ ];","\/\/ if no consumer, it's \u201c\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003\u2003\u2003...",{},"\/\/ other devices' information"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"After receiving the device list from the device provider, the aggregate device manager  calls a function, e.g., AddRemoteProviderEntry( ), to add the remote provider entry to the remote provider list, and then sends a disconnect control code to the provider to disconnect.","When the device consumer is going to plug in a remote device, the device consumer calls a function, e.g., VmCreateLink( ), to create a link between the remote device and the aggregate device manager  of the device consumer. In this function, the device consumer first sends a control code (e.g., VM_CTL_ADD_LINK) and then sends the data, which is one example implementation is as follows:",{"@attributes":{"id":"p-0123","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{}]},{"entry":["\u2003DWORD","dwDeviceType;","\/\/ device type"]},{"entry":["\u2003\u2002LONG","cbDeviceName;","\u2002\/\/ size of device name string"]},{"entry":["\u2003TCHAR","szDeviceName[ ];","\/\/ device name"]},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The device provider receives the request in a function, e.g., VmAcceptThread( ), and processes this request in another function, e.g., VmAddLink( ). In the VmAddLink( ) function, the device provider checks whether the requested device is available to provide to the device consumer. If the check passes, the device provider returns an \u201caccept\u201d answer code (e.g., 0) to accept the request. After the consumer receives the accept code, the consumer allocates a list entry, e.g., of the type DEVICE_LINK_ENTRY, and adds the entry to the device link list, e.g., g_listDeviceLinks. In one example implementation, DEVICE_LINK_ENTRY is defined as follows:",{"@attributes":{"id":"p-0125","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct tag_DEVICE_LINK_ENTRY"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002struct list_head","list;","\/\/ list entry head"]},{"entry":["\u2003\u2002HANDLE","hChannelInstance;","\/\/ communication channel"]},{"entry":[{},{},"\/\/ handle"]},{"entry":["\u2003\u2002LPTSTR","lpProvider;","\/\/ device provider name"]},{"entry":["\u2003LPTSTR","\u2002lpDevice;","\u2002\/\/ device name"]},{"entry":["\u2003DWORD","\u2002deviceType;","\u2002\/\/ device type"]},{"entry":["\u2003\u2002HANDLE","\u2003hThread;","\/\/ handle of thread for"]},{"entry":[{},{},"\/\/ linkage"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} DEVICE_LINK_ENTRY, *PDEVICE_LINK_ENTRY;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Once the device connection information is recorded in the device link list (e.g., g_listDeviceLinks), the device consumer creates a thread, e.g., by calling a VmLinkRemoteDeviceThread( ) function. The device consumer first tries to install the virtual driver by calling a function (e.g., PluginDevice( )) provided by the virtual bus.","Because each virtual device is assigned a serial number before calling the PluginDevce( ) virtual bus function, the aggregate device manager  maintains a serial number pool for virtual devices. In one example implementation, the serial number pool comprises an array as set forth below:",{"@attributes":{"id":"p-0128","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"BYTE g_fbDeviceSN[ DEVICE_TYPE_SUPPORTED+1 ][ 32 ];"},{"entry":"\/\/ support 256 devices for each type;"},{"entry":"\/\/ serial number 0 for each type is reserved"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Example functions for allocating and releasing serial numbers from the serial number pool are set forth below:",{"@attributes":{"id":"p-0130","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/*\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ \u2003Description:"]},{"entry":[{},"\/\/ \u2003\u2003Allocate a new serial number from flagbits;"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ \u2003Arguments:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ \u2003\u2003flagbits","\u2003\u2003-","pointer to bits stored allocated serial"]},{"entry":[{},"number"]},{"entry":[{},"\/\/ \u2003\u2003size","\u2003\u2003-","the size of flagbits, in bytes"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ \u2003Return Value:"]},{"entry":[{},"\/\/ \u2003\u2003Serial number;"]},{"entry":[{},"\/\/"]},{"entry":[{},"*\/"]},{"entry":[{},"int AllocSN( BYTE* flagbits, int size );"]},{"entry":[{},"\/*\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ \u2003Description:"]},{"entry":[{},"\/\/ \u2003\u2003Free serial number from flagbits;"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ \u2003Arguments:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ flagbits","\u2003-","pointer to bits stored allocated"]},{"entry":[{},"\/\/ serial number"]},{"entry":[{},"\/\/ \u2003\u2003sn","\u2003\u2003-","serial number"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ \u2003Return Value:"]},{"entry":[{},"\/\/ \u2003\u2003None;"]},{"entry":[{},"\/\/"]},{"entry":[{},"*\/"]},{"entry":[{},"void FreeSN( BYTE* flagbits, int sn );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As described above, after the virtual device is plugged in by PluginDevice( ), the virtual bus  notifies the operating system that a device is plugged in, whereby the operating system attempts to install the virtual driver of this device. When the virtual driver is installed, the aggregate device manager  of the device consumer communicates with the device provider and transfers data from the device consumer to the virtual driver.","When the device provider returns an accept answer code (e.g., 0) to accept the request in the appropriate function, e.g., VmAddLink( ), the device provider sets the local device's status to \u201cbeing used\u201d status, e.g., DEVICE_PLUGGED_OUT, and broadcasts a message to tell other computing machines that the device list has been updated. The device provider opens the local device by calling an open device function provided by controller of device filter driver and starts to transfer data between the controller of this device filter driver and the device consumer's aggregate device manager . Example control codes are listed below:",{"@attributes":{"id":"p-0133","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define VM_CTL_QUERY_MACHINE_INFO","0x00000010",{}]},{"entry":["#define VM_CTL_QUERY_DEVICES","0x00000011","\/\/ query info"]},{"entry":[{},{},"\/\/ value"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ should be < 0x100"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["#define VM_CTL_ADD_LINK","0x00000101","\/\/ action value"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ should be > 0x100"]},{"entry":["#define VM_CTL_DELETE_LINK","0x00000102"]},{"entry":["#define VM_CTL_SWITCH_DESKTOP","0x00000103"]},{"entry":["#define VM_CTL_SWITCH_BACK","0x00000104"]},{"entry":["#define VM_CTL_PLUG_IN_DEVICE","0x00000105"]},{"entry":["#define VM_CTL_PLUG_OUT_DEVICE","0x00000106"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In one example implementation, the device types are defined as follows:",{"@attributes":{"id":"p-0135","num":"0146"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ Device type constants, type 0 is reserved"},{"entry":"\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define DEVICE_TYPE_SUPPORTED","\u2003\u20034","\/\/ number of"]},{"entry":[{},{},"device types"]},{"entry":[{},{},"\/\/ supported"]},{"entry":["#define VM_DEVICETYPE_DISPLAY",{},"0x00000001"]},{"entry":["#define VM_DEVICETYPE_KEYBOARD",{},"0x00000002"]},{"entry":["#define VM_DEVICETYPE_MOUSE",{},"0x00000003"]},{"entry":["#define VM_DEVICETYPE_CAMERA",{},"0x00000004"]},{"entry":["#define VM_DEVICETYPE_SPEAKER",{},"0x00000005"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In one example implementation, the machine types are defined as follows:",{"@attributes":{"id":"p-0137","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define VM_MACHINETYPE_PC","0x00000001"]},{"entry":[{},"#define VM_MACHINETYPE_PDA","0x00000002"]},{"entry":[{},"#define VM_MACHINETYPE_PHONE","0x00000003"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Note that when the machine type is VM_MACHINETYPE_PDA, the VmAddLink( ) calls VmProcessDevicesForMobile( ) to process the data connection between the computer and a personal digital assistant (PDA) because it is different to connect devices from computer to PDA.","In one example implementation, the device messages are defined as follows, where the message codes are used in data transfer for device connection:",{"@attributes":{"id":"p-0140","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/",{}]},{"entry":[{},"\/\/ Device message definition"]},{"entry":[{},"\/\/"]},{"entry":[{},"#define DEVICE_MOUSE_DATA_MSG","0x00000003"]},{"entry":[{},"#define DEVICE_KEYBOARD_DATA_MSG","0x00000004"]},{"entry":[{},"#define DEVICE_SCREEN_DATA_MSG","0x00000005"]},{"entry":[{},"#define DEVICE_PRINT_SCREEN_MSG","0x00000006"]},{"entry":[{},"#define DEVICE_CAMERA_DATA_MSG","0x00000007"]},{"entry":[{},"#define DEVICE_CAMERA_PC_DATA_MSG","0x00000008"]},{"entry":[{},"#define DEVICE_DISPLAY_DATA_MSG","0x00000009"]},{"entry":[{},"#define DEVICE_DISPLAY_NOT_EXIST_MSG","0x0000000A"]},{"entry":[{},"#define DEVICE_DISPLAY_FULL_SCREEN","0x0000000B"]},{"entry":[{},"#define DEVICE_DISPLAY_WINDOWED","0x0000000C"]},{"entry":[{},"#define DEVICE_DISPLAY_NULL","0x0000000D"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In order to dynamically update the aggregate computer system  list in the control center user interface, there is a thread (e.g., ConnectionMaintainThread( )) created for connection maintenance between computing machines. This thread tries to connect each computing machine in the device provider list to see whether the device provider is still connectable. If the connection attempt fails, that is, the device provider has disappeared in the network, the device provider is removed from the device provider list. In one example, the thread waits for fifteen seconds after every provider in the list is checked.","The aggregate device manager  maintains a list of filter driver controllers' interface, which in one example is defined as follows:",{"@attributes":{"id":"p-0143","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VM_APP_INTERFACE"]},{"entry":[{},"g_AppInterface[ DEVICE_TYPE_SUPPORTED+1 ];"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ device_type 0 reserved"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one example, a function, e.g., VmAppRegister( ), is used for filter driver controllers to register their interface:","int VmAppRegister(PVM_APP_INTERFACE vmAppInterface, DWORD deviceType);","In one example, related structures for device types are defined as follows:",{"@attributes":{"id":"p-0146","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct tag_VM_APP_INTERFACE"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003PVM_APP_OPEN","appOpen;"]},{"entry":[{},"\u2003\u2003PVM_APP_CLOSE","appClose;"]},{"entry":[{},"\u2003\u2003PVM_APP_READ","appRead;"]},{"entry":[{},"\u2003\u2003PVM_APP_WRITE","appWrite;"]},{"entry":[{},"\u2003\u2003PVM_APP_QUERY_LIST","appQueryList;"]},{"entry":[{},"\u2003\u2003PVM_APP_QUERY_NAME","appQueryName;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VM_APP_INTERFACE, *PVM_APP_INTERFACE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In one example, the related types are defined as:",{"@attributes":{"id":"p-0148","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ Open device by handle"},{"entry":"\/\/ \u2003handle - the handle to the device"},{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Zero - successful"},{"entry":"\/\/ \u2003Nonzero - failure"},{"entry":"\/\/"},{"entry":"typedef int (*PVM_APP_OPEN) ( HANDLE handle );"},{"entry":"\/\/"},{"entry":"\/\/ Close device by handle"},{"entry":"\/\/ \u2003handle - the handle to the device"},{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Zero - successful"},{"entry":"\/\/ \u2003Nonzero - failure"},{"entry":"\/\/"},{"entry":"typedef int (*PVM_APP_CLOSE) ( HANDLE handle );"},{"entry":"\/\/"},{"entry":"\/\/ Read data from device"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ \u2003handle","- the handle to the device"]},{"entry":["\/\/ \u2003buf","- data buffer"]},{"entry":["\/\/ \u2003size","- size of buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Positive - number of bytes read from the device"},{"entry":"\/\/ \u2003Zero or negative - failure"},{"entry":"\/\/"},{"entry":"typedef int (*PVM_APP_READ) ( HANDLE handle, BYTE* buf,"},{"entry":"DWORD size );"},{"entry":"\/\/"},{"entry":"\/\/ Write data to device"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ \u2003handle","- the handle to the device"]},{"entry":["\/\/ \u2003buf","- data buffer"]},{"entry":["\/\/ \u2003size","- size of data in buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Positive - number of bytes written to the device"},{"entry":"\/\/ \u2003Zero or negative - failure"},{"entry":"\/\/"},{"entry":"typedef int (*PVM_APP_WRITE) ( HANDLE handle, BYTE* buf,"},{"entry":"DWORD size );"},{"entry":"\/\/"},{"entry":"\/\/ Query device list"},{"entry":"\/\/ \u2003handle - pointer to a handle array which receives the handle"},{"entry":"\/\/ list,"},{"entry":"\/\/ \u2003\u2003\u2003the number of handles should be less than 128"},{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Positive - number of handles in the list"},{"entry":"\/\/"},{"entry":"typedef int (*PVM_APP_QUERY_LIST) ( HANDLE* handle );"},{"entry":"\/\/"},{"entry":"\/\/ Query device name"},{"entry":"\/\/ \u2003handle - the handle to the device"},{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Nonzero - a pointer to device name, it won't be released"},{"entry":"\/\/ \u2003outside"},{"entry":"\/\/"},{"entry":"typedef LPCTSTR (*PVM_APP_QUERY_NAME) ( HANDLE"},{"entry":"handle );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Each filter driver controller calls a function, e.g., VmAppRegister( ), to register its interface as part of its initialization function. Note that the aggregate device manager  calls each filter driver controller's initialization function, e.g., in VmServerInit( ).","The aggregate device manager  maintains a list of virtual driver controllers' interfaces, which in one example is defined as follows:",{"@attributes":{"id":"p-0151","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VM_DRV_INTERFACE"]},{"entry":[{},"g_DrvInterface[ DEVICE_TYPE_SUPPORTED+1 ];"]},{"entry":[{},"\/\/ device_type 0 reserved"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The VmDrvRegister( ) function is used for virtual driver controllers to register their interfaces. In one example, it is defined as:",{"@attributes":{"id":"p-0153","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int VmDrvRegister( PVM_DRV_INTERFACE vmDrvInterface,"]},{"entry":[{},"DWORD deviceType );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0154","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct tag_VM_DRV_INTERFACE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003PVM_DRV_CREATE","drvCreate;"]},{"entry":[{},"\u2003PVM_DRV_CLOSE","drvClose;"]},{"entry":[{},"\u2003PVM_DRV_READ","drvRead;"]},{"entry":[{},"\u2003PVM_DRV_WRITE","drvWrite;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} VM_DRV_INTERFACE, *PVM_DRV_INTERFACE;"},{"entry":"and related types defined as follows:"},{"entry":"\/\/"},{"entry":"\/\/ Create a virtual device"},{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Positive - the handle to the device created"},{"entry":"\/\/"},{"entry":"typedef HANDLE (*PVM_DRV_CREATE) ( );"},{"entry":"\/\/"},{"entry":"\/\/ Close a virtual device"},{"entry":"\/\/ \u2003handle - the device handle"},{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Zero - successful"},{"entry":"\/\/ \u2003Nonzero - failure"},{"entry":"\/\/"},{"entry":"typedef int (*PVM_DRV_CLOSE) ( HANDLE handle );"},{"entry":"\/\/"},{"entry":"\/\/ Read data from the virtual device"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ \u2003handle","- the device handle"]},{"entry":["\/\/ \u2003buf","- the data buffer"]},{"entry":["\/\/ \u2003size","- size of the data buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Positive - number of bytes read from the device"},{"entry":"\/\/ \u2003Zero or negative - failure"},{"entry":"\/\/"},{"entry":"typedef int (*PVM_DRV_READ) ( HANDLE handle, BYTE* buf,"},{"entry":"DWORD size );"},{"entry":"\/\/"},{"entry":"\/\/ Write data to the virtual device"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ \u2003handle","- the device handle"]},{"entry":["\/\/ \u2003buf","- the data buffer"]},{"entry":["\/\/ \u2003size","- size of the data buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ Returns:"},{"entry":"\/\/ \u2003Positive - number of bytes written to the device"},{"entry":"\/\/ \u2003Zero or negative - failure"},{"entry":"\/\/"},{"entry":"typedef int (*PVM_DRV_WRITE) ( HANDLE handle, BYTE* buf,"},{"entry":"DWORD size );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Each filter driver controller calls VmDrvRegister( ) to register its interface in the initialization function. Note that the aggregate device manager  calls each filter driver controller's initialization function, e.g. in VmServerInit( ).","The aggregate connection manager  provides connectivity between each computing machine of the aggregate computer system . The aggregate connection manager  provides for various kinds of connections between computing machines, whereby the aggregate device manager  may communicate in the same way whether a device is connected via Ethernet, USB, Bluetooth, Wi-Fi, IrDA or another connection. To this end, the aggregate connection manager  as different connection modules and provides connection module registering and management. The aggregate connection manager  such as connection modules registering and management, communication channel establishing and terminating, broadcasting of local aggregate computer system , discovering communication channels of other computing machines and connection and data transfer between communication channels.","When the aggregate connection manager  starts, a function (e.g., CmInitialize( )) is called to initialize each connection interface. In initialization function of each connection interface module, the RegisterCmInterface( ) should be called to register the connection interface. It is defined by:",{"@attributes":{"id":"p-0158","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HANDLE RegisterCmInterface( LPCTSTR lpInterfaceName,"]},{"entry":[{},"PCM_INTERFACE cmInterface );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one example, related structures and types are defined by:",{"@attributes":{"id":"p-0160","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct tag_CM_INTERFACE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003PCM_QUERY_CHANNEL","cmQueryChannels;"]},{"entry":["\u2003\u2003PCM_CREATE_CHANNEL","cmCreateChannel;"]},{"entry":["\u2003\u2003PCM_DESTROY_CHANNEL","cmDestroyChannel;"]},{"entry":["\u2003\u2003PCM_OPEN_CHANNEL","cmOpenChannel;"]},{"entry":["\u2003\u2003PCM_CLOSE_CHANNEL","cmCloseChannel;"]},{"entry":["\u2003\u2003PCM_CONNECT_CHANNEL","cmConnectChannel;"]},{"entry":["\u2003\u2003PCM_DISCONNECT_CHANNEL","cmDisconnectChannel;"]},{"entry":["\u2003\u2003PCM_DISABLE_CHANNEL","cmDisableChannel;"]},{"entry":["\u2003\u2003PCM_READ_CHANNEL","cmReadChannel;"]},{"entry":["\u2003\u2003PCM_WRITE_CHANNEL","cmWriteChannel;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CM_INTERFACE, *PCM_INTERFACE;"},{"entry":"\/\/"},{"entry":"\/\/ Query channels"},{"entry":"\/\/ \u2003Query what channels are opened by others"},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"void"},{"entry":"(*PCM_QUERY_CHANNEL) ( );"},{"entry":"\/\/"},{"entry":"\/\/ Create a channel"},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"int"},{"entry":"(*PCM_CREATE_CHANNEL) ("},{"entry":"\u2003PCM_CHANNEL_ENTRY pChannelEntry"},{"entry":"\u2003);"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["typedef struct tag_CM_CHANNEL_ENTRY {","\/\/ entry of channel list"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003struct list_head","list;","\u2002\/\/ list head entry"]},{"entry":["\u2003LPTSTR","lpChannelName;","\u2003\/\/ name of channel"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003PCM_CALLBACK_ACCEPT cmCallbackAccept;","\/\/ pointer to"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ callback function of accept"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003CM_CHANNEL_INFO","channelInfo;","\/\/ channel's information"]},{"entry":["\u2003struct list_head","listSubChannel;","\u2003\/\/ future use"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CM_CHANNEL_ENTRY, *PCM_CHANNEL_ENTRY;"},{"entry":"typedef void (CALLBACK *PCM_CALLBACK_ACCEPT) ( HANDLE"},{"entry":"hChannelInstanceHandle );"},{"entry":"typedef struct tag_CM_CHANNEL_INFO"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TCHAR","szGroupName[256];"]},{"entry":[{},"TCHAR","szDescription[1024];"]},{"entry":[{},"DWORD","dwProperty;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CM_CHANNEL_INFO, *PCM_CHANNEL_INFO;"},{"entry":"\/\/"},{"entry":"\/\/ Destroy a channel"},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"int"},{"entry":"(*PCM_DESTROY_CHANNEL) ("},{"entry":"\u2003HANDLE hChannelHandle"},{"entry":"\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Open a channel"},{"entry":"\/\/ \u2003hChannelHandle - channel's handle"},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"HANDLE"},{"entry":"(*PCM_OPEN_CHANNEL) ("},{"entry":"\u2003HANDLE hChannelHandle"},{"entry":"\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Close a channel"},{"entry":"\/\/ \u2003hChannelInstanceHandle - channel instance's handle"},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"int"},{"entry":"(*PCM_CLOSE_CHANNEL) ("},{"entry":"\u2003HANDLE hChannelInstanceHandle"},{"entry":"\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Connect to a channel"},{"entry":"\/\/ \u2003addr - the address of the channel"},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"HANDLE"},{"entry":"(*PCM_CONNECT_CHANNEL) ("},{"entry":"\u2003BYTE* addr"},{"entry":"\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Disconnect a channel"},{"entry":"\/\/ \u2003hChannelInstanceHandle - channel instance's handle"},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"int"},{"entry":"(*PCM_DISCONNECT_CHANNEL) ("},{"entry":"\u2003HANDLE hChannelInstanceHandle"},{"entry":"\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Read data from a channel"},{"entry":"\/\/ \u2003hChannelInstanceHandle - channel instance's handle"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ \u2003lpBuffer","- data buffer that receives the data"]},{"entry":["\/\/ \u2003bufSize","- size of buffer"]},{"entry":["\/\/ \u2003flags","- the flags:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ \u2003\u2003\u2003\u2003CM_READ_FLAG_READ_FULL_SIZE","\/\/ read full"]},{"entry":[{},"\/\/ size buffer"]},{"entry":["\/\/ \u2003\u2003\u2003\u2003CM_READ_FLAG_PEEK","\/\/ MSG_PEEK"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"typedef"},{"entry":"int"},{"entry":"(*PCM_READ_CHANNEL) ("},{"entry":"\u2003HANDLE hChannelInstanceHandle,"},{"entry":"\u2003LPVOID lpBuffer,"},{"entry":"\u2003int bufSize,"},{"entry":"\u2003\u2002int flags"},{"entry":");"},{"entry":"\/\/"},{"entry":"\/\/ Write data to a channel"},{"entry":"\/\/ \u2003hChannelInstanceHandle - channel instance's handle"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ \u2003lpBuffer","- data buffer that is going to sent"]},{"entry":["\/\/ \u2003bufSize","- size of buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"typedef"},{"entry":"int"},{"entry":"(*PCM_WRITE_CHANNEL) ("},{"entry":"\u2003HANDLE hChannelInstanceHandle,"},{"entry":"\u2003LPVOID lpBuffer,"},{"entry":"\u2003int bufSize"},{"entry":");"},{"entry":"\/\/"},{"entry":"\/\/ Disable a channel"},{"entry":"\/\/ \u2003hChannelInstanceHandle - channel instance's handle"},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"int"},{"entry":"(*PCM_DISABLE_CHANNEL) ("},{"entry":"\u2003HANDLE hChannelInstanceHandle"},{"entry":");"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"After each connection module is registered, the aggregate connection manager  has access to the functions needed in every module. It maintains a list which contains the interfaces' information. The list is g_listInterfaces, and the list member is of the type PCM_INTERFACE_ENTRY which is defined as follows:",{"@attributes":{"id":"p-0162","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct tag_CM_INTERFACE_ENTRY \/\/ entry of interface list"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct list_head","list;"]},{"entry":[{},"LPTSTR","lpInterfaceName;"]},{"entry":[{},"CM_INTERFACE","cmInterface;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CM_INTERFACE_ENTRY, *PCM_INTERFACE_ENTRY;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As a member of the aggregate computer system , an aggregate computing machine connects to other computing machines through a network or other kind of connection. Before coupling to other machines, a machine establishes a communication channel on the network. The aggregate connection manager  creates a communication channel by calling the function CmCreateChannel( ) when it starts. This function creates communication channels on each communication interface, whereby one channel can communicate with others on every connection interface. The aggregate connection manager  may optimally choose the best connection interface when there are more than one connection interface available between two computers.","The aggregate connection manager  is designed to be able to create more than one channel. There is a list called g_listChannels which records the channels created. The member of the list is of the type PCM_CHANNEL_ENTRY which is defined as follows:",{"@attributes":{"id":"p-0165","num":"0176"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct tag_CM_CHANNEL_ENTRY { \u2003\/\/ entry of channel list"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2009struct list_head","list; \u2003\u2003\u2003\u2003\u2003\u2003\/\/ list head entry"]},{"entry":["\u2003\u2009LPTSTR","lpChannelName; \/\/ name of channel"]},{"entry":["\u2003\u2009PCM_CALLBACK_ACCEPT","cmCallbackAccept;"]},{"entry":"\u2003\u2009\/\/ pointer to callback"},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ function of accept"]},{"entry":["\u2003\u2009CM_CHANNEL_INFO","channelInfo; \/\/ channel's information"]},{"entry":["\u2003\u2009struct list_head","listSubChannel; \u2003\/\/ future use"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CM_CHANNEL_ENTRY, *PCM_CHANNEL_ENTRY;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In one example, the type and structure are defined by:",{"@attributes":{"id":"p-0167","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef void (CALLBACK *PCM_CALLBACK_ACCEPT) ( HANDLE"},{"entry":"hChannelInstanceHandle );"},{"entry":"typedef struct tag_CM_CHANNEL_INFO"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003TCHAR","szGroupName[256];"]},{"entry":["\u2003\u2003TCHAR","szDescription[1024];"]},{"entry":["\u2003\u2003DWORD","dwProperty;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CM_CHANNEL_INFO, *PCM_CHANNEL_INFO;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"However, only one channel is needed and implemented. When the aggregate connection manager  starts, it first calls CmInitialize( ) to initialize each connection interface. Then the function CmCreateChannel( ) is called by the configuration manager to create a communication channel named with the machine name. This function calls each interface's create channel function to create channels. When a communication channel is created, the computer acts like a server listening at the channel and accept a connection when another machine connects to it. The channel can be destroyed by calling CmDestroyChannel( ). Once all channels are destroyed for an aggregate computing device, communication with others is ended.","When an aggregate computing machine starts, it broadcasts its information to other computing machines so that the other computing machines know about the starting machine and can communicate with it by the information provided. The broadcast message for ViaIP module is a UDP packet, which in one example is structured as follows:",{"@attributes":{"id":"p-0170","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct tag_PROVIDER_INFO_UDP_PACKET"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002DWORD dwFlag;","\/\/ PROVIDER_INFO_FLAG or"]},{"entry":[{},"\/\/ QUERY_PROVIDER_INFO_FLAG"]},{"entry":["\u2002DWORD dwStatus;","\/\/ 1 - start, 2 - running, 3 - close"]},{"entry":["\u2002DWORD dwPort;","\/\/ port number"]},{"entry":["\u2002DWORD dwMachineType;","\/\/ machine type"]},{"entry":["\u2002DWORD cbMachineName;","\/\/ size of the machine name"]},{"entry":["\u2002TCHAR szMachineName[1];","\u2003\/\/ machine name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} PROVIDER_INFO_UDP_PACKET,"},{"entry":"*PPROVIDER_INFO_UDP_PACKET;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The dwFlag of the UDP packet indicates whether this is a passive broadcast message or not. Because sometimes the broadcast message may be lost, when a machine receives the broadcast message with the QUERY_PROVIDER INFO FLAG from the other one, it broadcasts a passive broadcast message with PROVIDER_INFO_FLAG. Via the different flags, the two machines will not infinitely broadcast the messages.","The dwStatus of the UDP packet indicates whether this UDP packet is sent at a starting time, running time or ending time.","To discover the communication channels of other computing machines, there is a query channel function implemented by each connection module. By calling CmQueryChannels( ), in which the connection interfaces' query functions are called, a query channel message is broadcast to others. The message may be the same as the broadcast message described above. Whenever an aggregate computing machine receives the broadcast message, the machine knows which other machine sent the message according to the information provided in the message, and can connect to that machine to identify and retrieve the information needed, such as device list.","Each connection module opens a thread listening to the broadcast message. When the aggregate connection manager  receives the broadcast message sent by an aggregate machine, the connection manager  discovers the computer's channel and then connects to it to retrieve the device provider information. In each connection module, when the broadcast message is received, it calls CmAddProviderAddr( ) to tell the aggregate connection manager  to add the newly discovered provider's address to the provider list g_listRemoteChannels. The member of the list is of the type PROVIDER_ENTRY which in one example is defined as follows:",{"@attributes":{"id":"p-0175","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["typedef struct tag_PROVIDER_ENTRY","\/\/ entry of provider list"]},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003struct","list_head list;","\/\/ list head entry"]},{"entry":["\u2003HANDLE","hInterface;","\/\/ connection interface"]},{"entry":["\u2003BYTE","addr[64];","\/\/ address defined by interface"]},{"entry":["\u2003LPTSTR","lpProviderName;","\/\/ provider channel name"]},{"entry":["\u2003DWORD","dwProviderType;","\/\/ machine type"]},{"entry":["\u2003LPTSTR","lpDescription;","\/\/ provider channel description"]},{"entry":["\u2003DWORD","dwProperty;","\/\/ property of provider channel"]},{"entry":["\u2003\/\/struct list_head","\u2003listSubChannel;","\u2003\/\/ provider channel's"]},{"entry":[{},{},"\u2003\/\/ sub-channel list"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} PROVIDER_ENTRY, *PPROVIDER_ENTRY;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"After the provider entry is added to the list, it calls g_cmCallbackQuery( ) which is the callback function registered in CmQueryChannels( ). The provider is added by the aggregate device manager  via a VmFoundNewProvider( ) function.","The connection between two computing machines may be established by calling CmConnectChannel( ), which is defined as:","HANDLE CmConnectChannel (HANDLE hprovider);","The parameter is the handle to the device provider, which can be obtained in the member of the list g_listRemoteProviders. It is the hprovider of REMOTE_PROVIDER_ENTRY. As it may be blocked when connecting, a thread calling CmConnectWatchThread( ) is created before connecting to display a message, e.g., to tell users \u201cConnecting . . . Please wait . . . \u201d or the like.","After the connection is established, a handle instance of this connection is allocated as a structure CM_HANDLE_INSTANCE which is defined as follows:",{"@attributes":{"id":"p-0180","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct tag_CM_HANDLE_INSTANCE"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003HANDLE \u2003\u2003hInterface;"]},{"entry":[{},"\u2003\u2003HANDLE \u2003\u2003handle;"]},{"entry":[{},"\u2003\u2003HANDLE \u2003\u2003hProvider;"]},{"entry":[{},"} CM_HANDLE_INSTANCE, *PCM_HANDLE_INSTANCE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The above structure records the connection interface handle hInterface, the handle of this connection for the interface handle, and also the handle to the device provider hprovider. The handle instance structure is needed when using other connection functions such as CmReadChannel( ) and CmWriteChannel( ), which are connection interface related. Via the interface handle and the handle of the connection for this interface, a function such as CmReadChannel( ) can call the specified interface's read function to read data from the channel.","In order to make the computing machines in different aggregate computer systems connect to each other to get the device list information, a group name is used in the channel. The group name is also the name of the whole aggregate computer system , and is in the channelInfo member of CM_CHANNEL_ENTRY and is assigned when the communication channel is created. After a connection is established by a certain interface, the aggregate connection manager  sends the following data:",{"@attributes":{"id":"p-0183","num":"0194"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD","cbLength;"]},{"entry":[{},"TCHAR","szGroupName[ ];"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The machine that accepted the connection receives the data and identifies whether they are in the same group, and returns a DWORD accept (code ) if yes, or refuse (code ) if not.","After the group name identification passes, the connection between the aggregate connection managers (e.g., L and R) of the two computing machines is established. They call CmReadChannel( ) or CmWriteChannel( ) to receive or send data, respectively. When the data transfer is completed and connection is no longer needed, the function CmDisconnectChannel( ) is called to disconnect and the channel instance which is allocated when the connection established will be released.","Turning to aspects related to virtual displays, in general, to draw to a screen requires a display driver (e.g., a .dll file whose primary responsibility is rendering), a video miniport driver  (; e.g., a .sys file whose responsibilities include resource management, such as hardware configuration, and physical device memory mapping specific to the video hardware) and a display adapter. Display adapters usually have frame buffers that can be mapped linearly into CPU address space; a frame buffer is a dedicated memory on a video adapter that can hold the contents of a single screen image.",{"@attributes":{"id":"p-0187","num":"0198"},"figref":"FIG. 8","b":["802","804","806","808","804","810","812","814"]},"By way of example of a miniport driver , consider a mirror driver, which is a display driver for a virtual device that mirrors the drawing operations of one or more additional physical display devices. A mirror driver is implemented and behaves much like any other display driver, however, its paired video miniport driver is minimal in comparison to a typical miniport driver.","A virtual miniport driver  relies on a port driver  and handles device-specific operations for the port driver . For example, a video miniport driver replies on a video port driver (videoprt.sys) which exports functions such as VideoPortXxx. A video miniport driver calls these functions to handle device-specific operations. For most types of devices, the port driver  is supplied with the operating system, and the miniport driver is supplied by a device vendor. The following system-defined functions are implemented in the virtual video miniport driver :",{"@attributes":{"id":"p-0190","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Required Function Name","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DriverEntry","Initializes video miniport"]},{"entry":[{},{},"driver."]},{"entry":[{},"HwVidFindAdapter","Gets access ranges for devices"]},{"entry":[{},{},"on an enumerable bus; if"]},{"entry":[{},{},"necessary, determines the"]},{"entry":[{},{},"device type."]},{"entry":[{},"HwVidGetPowerState","Queries whether a device can"]},{"entry":[{},{},"support the requested power"]},{"entry":[{},{},"state."]},{"entry":[{},"HwVidGetVideoChildDescriptor","Enumerates the child devices"]},{"entry":[{},{},"attached to the specified"]},{"entry":[{},{},"device."]},{"entry":[{},"HwVidInitialize","Performs one-time"]},{"entry":[{},{},"initialization of the adapter"]},{"entry":[{},{},"for the corresponding display"]},{"entry":[{},{},"driver. Called in response to"]},{"entry":[{},{},"a request to open the adapter."]},{"entry":[{},"HwVidSetPowerState","Sets the power state of the"]},{"entry":[{},{},"specified device."]},{"entry":[{},"HwVidStartIO","Begins processing of the"]},{"entry":[{},{},"incoming VRP."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In DriverEntry, VideoPortInitialize is called exported by video port driver with a data structure VIDEO_HW_INITIALIZATION_DATA filled with entry points of HwVidXxx functions implemented by the virtual driver to complete the initialization of the virtual miniport driver.","Because the virtual video miniport driver  is implemented without hardware operation, the routines are completed by returning a default successful or no error code, and build the driver. The following comprises a list of return value of each function:",{"@attributes":{"id":"p-0193","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Required Function Name","Return Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DriverEntry","Return Value of"]},{"entry":[{},{},"VideoPortInitialize"]},{"entry":[{},"HwVidFindAdapter","NO ERROR"]},{"entry":[{},"HwVidGetPowerState","NO ERROR"]},{"entry":[{},"HwVidGetVideoChildDescriptor","ERROR NO MORE DEVICES"]},{"entry":[{},"HwVidInitialize","TRUE"]},{"entry":[{},"HwVidSetPowerState","NO ERROR"]},{"entry":[{},"HwVidStartIO","TRUE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"To implement a virtual display driver , the driver needs to enable and disable the graphics hardware, supply GDI with information about hardware capabilities, and enable the drawing surface. The following table lists functions that the virtual display driver  implements. Following DrvEnableDriver, the remaining functions are listed alphabetically; note that except for DrvEnableDriver, which GDI calls by name, the other display driver functions do not have fixed names, and are listed with pseudonyms:",{"@attributes":{"id":"p-0195","num":"0206"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Function","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DrvEnableDriver","As the initial driver entry"]},{"entry":[{},{},"point, provides GDI with the"]},{"entry":[{},{},"driver version number and"]},{"entry":[{},{},"entry points of optional"]},{"entry":[{},{},"functions supported."]},{"entry":[{},"DrvAssertMode","Resets the video mode for a"]},{"entry":[{},{},"specified video hardware"]},{"entry":[{},{},"device."]},{"entry":[{},"DrvCompletePDEV","Informs the driver about the"]},{"entry":[{},{},"completion of device"]},{"entry":[{},{},"installation."]},{"entry":[{},"DrvDisableDriver","Frees all allocated resources"]},{"entry":[{},{},"for the driver and returns"]},{"entry":[{},{},"the device to its initially"]},{"entry":[{},{},"loaded state."]},{"entry":[{},"DrvDisablePDEV","When the hardware is no"]},{"entry":[{},{},"longer needed, frees memory"]},{"entry":[{},{},"and resources used by the"]},{"entry":[{},{},"device and any surface"]},{"entry":[{},{},"created, but not yet deleted."]},{"entry":[{},"DrvDisableSurface","Informs the driver that the"]},{"entry":[{},{},"surface created for the"]},{"entry":[{},{},"current device is no longer"]},{"entry":[{},{},"needed."]},{"entry":[{},"DrvEnablePDEV","Enables a PDEV."]},{"entry":[{},"DrvEnableSurface","Creates a surface for a"]},{"entry":[{},{},"specified hardware device."]},{"entry":[{},"DrvGetModes","Lists the modes supported by"]},{"entry":[{},{},"a specified video hardware"]},{"entry":[{},{},"device."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"When a Microsoft\u00ae NT-based operating system enables a display driver, it first calls the driver's DrvEnableDriver function. As other functions in the driver do not have fixed names, the driver has to send GDI a pointer to a function list. According to this list, the GDI calls other required functions of the driver to complete the initialization.","After DrvEnableDriver is called, GDI calls DrvEnablePDEV in succession to get a description of the physical device's characteristics. A primary responsibility of the driver's DrvEnablePDEV function is to fill in two system-defined structures, GDIINFO and DEVINFO, create and fill in a driver-defined structure PDEV that identifies the enabled device and return a handle to it. These operations are based on the received DEVMODE structure and device name.","PDEV is a driver-defined structure which describes private device instance information. It is maintained by driver itself. The driver can store information they need such as handles and screen's properties in it. Any global variables should be stored in this device specific structure, and the pointer to this data structure will be passed in when most driver functions are called.","The GDIINFO structure describes the graphics capabilities of a given device. The DEVINFO structure provides information about the driver and its private PDEV to the graphics engine. Both of them can be filled according to samples in DDK.","The operations in DrvEnablePDEV are structure filling processes except palette handle filling requires calling of EngCreatePalette, which is important to 8 bpp and 16 bpp display mode. Because in 8 bpp and 16 bpp display mode, RGB colors are indexed or compressed, as there is not enough space to store 3-bytes RGB information. If the display mode is 8 bpp, the EngCreatePalette function is called to create an indexed palette. For 16 bpp, the function is called to indicate which bits in the 16 bits represent red, green, or blue values.","When DrvEnablePDEV is finished, GDI completes the installation of the physical device and then calls DrvCompletePDEV. This provides the virtual driver  with a handle to the PDEV to be used when requesting GDI services for the device, and also provides a handle to the physical device that has been installed. This is the GDI handle for the physical device being created. The virtual driver  uses this handle when calling GDI functions, and thus the virtual driver store the GDI handle in its PDEV structure.","With reference to the DrvEnableSurface function, after DrvCompletePDEV is called, GDI calls DrvEnableSurface to let the virtual driver  set up a surface to be drawn on and associates it with a given PDEV. Usually, a display driver first calls a miniport driver to map the frame buffer on adapter to a linear memory address, creates a surface and modifies its first scan line's address to the frame buffer's linear memory address, and then associates it with the GDI handle. For a virtual display driver , the address is modified to a frame buffer allocated by the virtual display driver , not a physical frame buffer's memory address. After this, GDI performs drawing operations on the virtual driver-managed frame buffer.","In order to make memory allocation simpler, EngCreateBitmap may be used instead of EngCreateDeviceSurface to create the surface. This allows GDI to allocate memory for the bitmap and without needing virtual driver management. To get the screen's content of the virtual display driver, a DrvEscape routine may be implemented and registered with GDI; when a user mode application  calls the GDI function EscapeExt, GDI interprets the request and calls DrvEscape, whereby the virtual driver  can copy the frame buffer's content to the user mode application's memory by parameters.","In an alternative way, the user mode application  does not have to be concerned about the virtual display driver, and instead gets the screen content by a GDI function, e.g., by capturing an image. This method is easier to implement as the user application  does not have to deal with the raw pixel data according to different color modes, however this may be less efficient. Resources may be released as with conventional video drivers.","To simulate querying the display mode supported by hardware, a constant array of VIDEO_MODE_INFORMATION structures may be defined and initialized with video mode information supported by the virtual driver . In the DrvEnablePDEV routine, a query is used to determine whether the video mode is supported, and responded to by filling in the data structures based on the VIDEO_MODE_INFORMATION array.","DrvGetModes is used by GDI to query the list of video modes supported by a specified video hardware device. By calling DrvGetModes to obtain the video mode list, the operating system can let users adjust resolution and color format, e.g., in a display property dialog or the like.","The controller for virtual display driver is developed for the aggregate device manager . When it is initialized in the function VDisplayInitialize( ), it registers its interface to the aggregate device manager . Both filter driver controller and virtual driver controller are registered in this function and implemented in VDisp.cpp.","The filter driver controller for the virtual display driver  is an application running in user mode that displays the virtual display's output image. As with other kinds of filter drivers, it possesses the physical display device and outputs data to the device. In order to make it faster to refresh frames and consume lower CPU time, it uses DirectDraw to display the image.","When the filter driver controller is opened by the aggregate device manager , it creates a thread CreateDisplayWindow( ) to display the output of the remote virtual display driver. In this thread, a window is created and the message processing function of this window is VDisplayWndProc( ). More particularly, in one example implementation, it first creates a 640\u00d7480 16 bpp DirectDraw window, a global screen hdc and a timer of 30 Hz. Whenever receives a timer message, it calls DrawFrame( ) to draw the global screen hdc. In the function VDisplayWrite( ), the global screen hdc is updated. Some control messages are defined as follows:",{"@attributes":{"id":"p-0210","num":"0221"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define DEVICE_DISPLAY_DATA_MSG","0x00000009"]},{"entry":[{},"#define DEVICE_DISPLAY_NOT_EXIST_MSG","0x0000000A"]},{"entry":[{},"#define DEVICE_DISPLAY_FULL_SCREEN","0x0000000B"]},{"entry":[{},"#define DEVICE_DISPLAY_WINDOWED","0x0000000C"]},{"entry":[{},"#define DEVICE_DISPLAY_NULL","0x0000000D"]},{"entry":[{},"#define VDISP_CTL_SET_RESOLUTION","0xA0000000"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"When the first DWORD value of the data input to VDisplayWrite( ) is one of the above message codes, it means, respectively, that the following data is pure display data; the virtual display driver is not yet installed; show in full screen; show in window mode; and empty display message. For set resolution, the data following the message is formed as follows:",{"@attributes":{"id":"p-0212","num":"0223"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct tagSCREEN_RESOLUCTION_INFO"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","width;"]},{"entry":[{},"int","height;"]},{"entry":[{},"int","bpp;"]},{"entry":[{},"BOOL","bFullScreen;"]},{"entry":[{},"RECT","rcVirtualDesktop;"]},{"entry":[{},"RECT","rcScreen;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} SCREEN_RESOLUCTION_INFO;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"After processing the display data, the VDisplayWrite( ) sends back the current mouse cursor data to simulate a remote mouse when the mouse is moving or clicking in the display window.","The aggregate computer system  is designed to be able to plug in more than one remote display. To this end, the controller of the virtual display driver has a list g_listVDispDrv to record each different virtual display's information. The member of the list is of the type PVDISP_DRV_ENTRY which is defined as:",{"@attributes":{"id":"p-0215","num":"0226"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct tag_VDISP_DRV_ENTRY"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct","list_head list;","\/\/ list head entry"]},{"entry":[{},"LPTSTR","szDeviceName;","\/\/ device name"]},{"entry":[{},"BOOL","bIsMirror;","\/\/ is a mirror driver?"]},{"entry":[{},"union"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003HDC","hDC;","\/\/ hdc of the device"]},{"entry":[{},"\u2003CMirror*","pMirror;","\/\/ pointer to CMirror object"]},{"entry":[{},"};"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BYTE*","frameBuffer;","\/\/ pointer to frame buffer"]},{"entry":[{},"BYTE*","backBuffer;","\/\/ pointer to back buffer"]},{"entry":[{},"int","currentIndex;","\/\/ current cursor index"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD","tickCount;","\/\/ tick count"]},{"entry":[{},"DWORD","lastSyncTickCount;","\/\/ tick count of last time sync"]},{"entry":[{},"int","width;","\/\/ screen width"]},{"entry":[{},"int","height;","\/\/ screen height"]},{"entry":[{},"int","bpp;","\/\/ bits per pixel"]},{"entry":[{},"int","x;","\/\/ left-top x position"]},{"entry":[{},"int","y;","\/\/ left-top y position"]},{"entry":[{},"BOOL","bFullScreen;","\/\/ is in full-screen mode"]},{"entry":[{},"LPTSTR","lpProvider;","\/\/ name of device provider"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} VDISP_DRV_ENTRY, *PVDISP_DRV_ENTRY;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"When a new virtual display is plugged in, the aggregate device manager first plugs in a virtual mouse to make the remote computer able to control the virtual desktop by this virtual mouse. Then the aggregate device manager sends a DEVICE_DISPLAY_NOT_EXIST_MSG message to the remote computer and receives the resolution information for the remote computer. In this way, the virtual display's resolution can be initialized to the resolution of the remote computer's desktop. The resolution of the remote computer's desktop is thus not changed at the very beginning. If the virtual display driver is successfully installed, the calling of the create function of the virtual display driver's controller in succession will be successfully returned. Otherwise, it will continually send the DEVICE_DISPLAY_NOT_EXIST_MSG message to the remote computer and on the remote computer, and the display window will display a message such as \u201cThe device is not ready; the virtual display may be not enabled or installed.\u201d","After the virtual display driver  is created and installed, the aggregate device manager  calls its read function to read data from the controller and transfer the data to the remote computer. It also reads virtual mouse messages from the remote computer and sends them to the virtual bus .","The display data transferred between the local virtual display driver controller and the remote filter display driver controller may be compressed by a simplified differential run length encoding algorithm, e.g., the function EncodePxl( ).","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example and not limited in the accompanying figures in which like reference numerals indicate similar elements and in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
