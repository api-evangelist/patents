---
title: Join tuple assembly by partial specializations
abstract: Various embodiments of systems and methods for join tuple assembly by partial specializations are described herein. The join tuple assembly by partial specializations is a phase of the method for join query evaluation by semi-join reduction. By using partial specializations of the non-join part of the WHERE clause of a join query and matching sets, the join tuple assembly is organized in a manner that all computations are necessary, none are repeated, and failure to complete a partial join tuple to a full tuple is detected as early as possible. The method can be applied to inner and outer joins, and to arbitrary join graphs and non-join conditions in the WHERE clause. It can also be used outside the context of semi-join reductions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08788482&OS=08788482&RS=08788482
owner: SAP AG
number: 08788482
owner_city: Walldorf
owner_country: DE
publication_date: 20120914
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation application of U.S. patent application Ser. No. 12\/781,855, filed May 18, 2010, now U.S. Pat. No. 8,296,289 which is incorporated herein by reference.","Embodiments of the invention generally relate to the software arts, and, more specifically, to methods and systems for join query evaluation by semi-join reduction.","In the world of commercial computation, a major part of all computation is devoted to join evaluation. The cost in evaluating joins is high as well with respect to memory consumption as to processing time. A common technique for reducing the amount of data is the use of semi-joins. A join (e.g., an SQL join) combines two or more tables in a database, producing a new one that can be saved as a table or used as an intermediate result of more complex computations. The join combines the fields from the two tables by using values that are common to each of them. A semi-join is a binary operator on two relations. If these relations are R and S, the result of the semi-join of R with S is the set of all rows in R for which there is a row in S that is equal on their common attribute value. A relation is a data structure that consists of a heading (an unordered set of attributes as columns in a table) and a body (an unordered set of rows that share the same type). In computer science, a row represents an ordered list of attribute values. An n-tuple is a sequence (or an ordered list) of \u201cn\u201d elements, where \u201cn\u201d is a positive integer.","A semi-join between two tables consists of rows from the first table where one or more matches are found in the second table. If there are two relations R and S, the difference between the semi-join of R with S and the join between R and S is: the semi-join is a subset of if alone, whereas the join is a subset of the product R\u00d7S. As a subset, the semi-join contains every row of R at most once. Even if S contains two matches for a row in R, only one copy of the row in R is retained. Conceptually, if J is the join between R and S, the semi-join is the projection of J to R.","A join query is typically processed in the following way: first, semi-join reductions of the sizes of the joining relations are performed; then, the reduced relations are assembled to compute the join, and finally from every tuple in the join the attributes referenced in the expressions in the SELECT clause are projected, the expressions are evaluated and the results are returned to the user.","Various embodiments of systems and methods for join tuple assembly by partial specializations are described herein. In an embodiment, the method includes receiving a join query, a materialization graph representing a join part of the join query, and a plurality of matching sets. The method further includes configuring a tuple construction counter, which value indicates progression in an overall length of constructing a join tuple and an iterator that traverses through elements in a matching set from the plurality of matching sets. While the tuple construction counter value is a positive integer, a partial specialization of an operator tree is computed, wherein the operator tree represents a non-join part of the join query. If the computed partial specialization satisfies the non-join part of the join query and the tuple construction counter value is less than the overall length of the join tuple, a subset of the plurality of matching sets are recomputed. Further, if no empty matching set is encountered during recomputation, the tuple construction counter value is increased.","In an embodiment, the system includes a database storage unit for storing one or more of a plurality of matching sets derived from semi-join reduction of a plurality of relations, a join query, and a materialization graph representing a join part of the join query. Further, the system includes a processor in communication with the database storage unit that executes instructions including: configuring a tuple construction counter, which value indicates progression in an overall length of constructing a join tuple and an iterator that traverses through elements in a matching set from the plurality of matching sets. While the tuple construction counter value is a positive integer, a partial specialization of an operator tree is computed, wherein the operator tree represents a non-join part of the join query. If the computed partial specialization satisfies the non-join part of the join query and the tuple construction counter value is less than the overall length of the join tuple, a subset of the plurality of matching sets are recomputed. Further, if no empty matching set is encountered during recomputation, the tuple construction counter value is increased.","These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof, presented in connection with the following drawings.","Embodiments of techniques for join tuple assembly by partial specializations are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 1","FIGS. 1-5","FIG. 1"],"sub":["1 ","2 ","3 ","4 ","5 ","6 ","7 ","n ","1 ","2 ","3 ","4 ","5 ","6 ","7 "],"b":["105","110","115","120","125","130","135","105","110","115","120","125","130","135"]},"A method of query evaluation by semi-join reduction is applied to the following query using the relations R, R, R, R, R, R, and R:",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Join query (140)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SELECT",{},"R.z + R.z + R.z + R.z + R.z + R.z + R.z"]},{"entry":["FROM",{},"R, R, R, R, R, R, R"]},{"entry":["WHERE",{},"R.a = R.a AND"]},{"entry":[{},{},"R.b = R.b AND"]},{"entry":[{},{},"R.c = R.c AND"]},{"entry":[{},{},"R.d = R.d AND"]},{"entry":[{},{},"R.e = R.e AND"]},{"entry":[{},{},"R.f = R.f AND"]},{"entry":[{},{},"R.g = R.g AND"]},{"entry":[{},{},"R.h = R.h AND"]},{"entry":[{},{},"R.i = R.i AND"]},{"entry":[{},{},"R.j = R.j AND"]},{"entry":[{},{},"R.k = R.k AND"]},{"entry":[{},{},"R.l = R.l AND"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(R.z)+ (R.z)+ (R.z)+ (R.z)+ (R.z)+ (R.z)+ "]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(R.z)<= 1000 AND"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"((R.z * R.z * R.z * R.z >= 1000) OR (R.z * R.z * R.z *"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"R.z = 0))"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Table 1 shows an example of a join query  based on the relations R, R, R, R, R, R, and R. The SELECT statement defines what data to be retrieved. In the example, there is only one expression, but this expression references attributes from all seven tables. For simplicity, all these attributes are named as \u201cz\u201d. The FROM clause defines which relations are necessary to evaluate the join query . The WHERE clause includes one or more conditions that have to be fulfilled. Some of these conditions (in the example, all conditions except the last one) are join conditions, making the query a join query. Join query  will join relations R, R, R, R, R, R, and R using the corresponding columns specified in the WHERE clause. For example, the first condition of the WHERE clause is R\u00b7a=R\u00b7a, which means that columns with attribute \u201ca\u201d from relations R and R will be joined. This means that in every 7-tuple (r, r, r, r, r, r, r)\u2208R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7Rsatisfying the complete WHERE clause, the values in the \u201ca\u201d columns of Rand Rmust be equal. Analogously, this is valid for the remaining join conditions of the WHERE clause.","All joins in join query  are inner joins. An inner join is a common join operation used in applications and represents the default join type. The inner join creates a new result table by combining column values of two tables (A and B) based upon a join predicate. However, the method can also be applied to left outer joins, right outer joins, and full outer joins. An outer join does not require each record in the two joined tables to have a matching record. The joined table retains each record, even if no other matching record exists. The result of a left outer join (or simply \u201cleft join\u201d) of table A with table B always contains all records of the \u201cleft\u201d table (A), even if the join condition does not find any matching record in the \u201cright\u201d table (B). A right outer join (or \u201cright join\u201d) closely resembles a left outer join, except with the treatment of the tables reversed. A full outer join combines the results of both left and right outer joins.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["140","210","140","210","105","110","115","120","125","130","135","210","140","105","110"],"sub":["1 ","2 ","3 ","4 ","5 ","6 ","7 ","1 ","2 ","1","2","1 ","2 "]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3","b":["140","140","310"],"br":[{},{},{},{}],"in-line-formulae":[{},{},{},{},{},{}],"i":["R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z*R","\u00b7z*R","\u00b7z*R","\u00b7z>=","R","\u00b7z*R","\u00b7z*R","\u00b7z*R","\u00b7z="],"sub":["1","2","3","4","5","6","7","1","2","3","4","1","2","3","4"],"sup":["2","2","2","2","2","2","2"]},"The method of query evaluation by semi-join reduction applied to the join query  should result in a set of join tuples. Every join tuple is a 7-tuple (r, r, r, r, r, r, r) where ris a join tuple R, rin R, rin R, rin R, rin R, rin R, and rin R. Every such 7-tuple has to satisfy both the join conditions, assembled in the join graph , and the non-join conditions, assembled in the operator tree .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4","sub":["1","2","3","4","5","6","7 ","1 ","2 ","3 ","4 ","5 ","6 ","7 ","1 ","2 ","3 ","4 ","5 ","6 ","7 "],"b":["140","105","110","115","120","125","130","135","405","410","415","420","425","430","435"]},"The second step of the method of query evaluation by semi-join reduction is join tuple assembly. Its purpose is to construct all 7-tuples (r, r, r, r, r, r, r)\u2208R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7Rsatisfying the complete WHERE clause of the SELECT statement, or at least the needed number of 7-tuples, if the query was a first-k query. A first k-query is a query, where the size of the result is limited by the user, for example, the user may specify: \u201creturn only the first 20 rows of the result\u201d. For the join tuple assembly phase, a materialization graph (MG) is constructed. The MG will be used to construct the join tuples satisfying the complete WHERE clause.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5","b":["510","510","210","210","510"],"sub":["3 ","3","3","6 ","6 ","3 ","6","3","3","6","7 ","7 ","3 ","7","3","7","3","6","7","4","4","2","2","7","7","4","7","2","7"]},"In general, the choice of a good materialization sequence is an optimization issue. For simplicity reasons, the natural order R, R, R, R, R, R, Ris used in the example. The sequence chosen is represented in the materialization graph  by relabeling its vertices by their position in this sequence. For example, Ris relabeled as 1, Rrelabeled as 2, and so on. If the materialization sequence was chosen to be R, R, R, R, R, R, R, then the vertices would be relabeled in the following way: Ras 5, Ras 2, Ras 7 and so on. Additionally, the edges in MG  are given a direction. The edges are made arrows, pointing from lower numbered tail to higher numbered head. For example, arrow \u201ca\u201d points from 1 to 2, where 1 is the tail of the arrow and 2 is the head of the arrow.","The query evaluation by semi-join reduction is complete when all join tuples are assembled, meaning that all 7-tuples (r, r, r, r, r, r, r)\u2208R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7Rsatisfying the complete WHERE clause of the SELECT statement are known. For example, the 7-tuple (r=3, r=5, r=2, r=4, r=3, r=1, r=1), or just (3, 5, 2, 4, 3, 1, 1), satisfies the WHERE clause of join query . This can be verified in the following way: first, the join condition r\u00b7a=r\u00b7a is checked for the rows r=3 and r=5. Looking into the reduced relations R and R, since r=3, the row identifier for R is \u201c3\u201d, which corresponds to the second row in table . Looking at the second row of table  and at the \u201ca\u201d attribute, it shows that r\u00b7a=3. Again, looking at the reduced relations R and R, since r=5, the row identifier for R is \u201c5\u201d, which corresponds to the second row in table . Looking at the second row of table  and at the \u201ca\u201d attribute, it shows that r\u00b7a=3. Therefore, r\u00b7a=3=r\u00b7a. The following list shows the verification of all join conditions of the WHERE clause on the 7-tuple given above.",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"r.a = 3 = r.a,"},{"entry":"r.b = 6 = r.b,"},{"entry":"r.c = 9 = r.c,"},{"entry":"r.d = 12 = r.d,"},{"entry":"r.e = 15 = r.e,"},{"entry":"r.f = 14 = r.f,"},{"entry":"r.g = 9 = r.g,"},{"entry":"r.h = 10 = r.h,"},{"entry":"r.i = 16 = r.i,"},{"entry":"r.j = 15 = r.j,"},{"entry":"r.k = 1 = r.k,"},{"entry":"r.l = 20 = r.l"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":[{},{},{},{},{},{},{},{},{},{}],"in-line-formulae":[{},{},{},{},{},{},{},{},{},{},{},{}],"i":["R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z","R","\u00b7z*R","\u00b7z*R","\u00b7z*R","\u00b7z>=","R","\u00b7z*R","\u00b7z*R","\u00b7z*R","\u00b7z="],"sub":["1","2","3","4","5","6","7","1","2","3","4","1","2","3","4","1","2","3","4","5","6","7"],"sup":["2","2","2","2","2","2","2","2","2","2","2","2","2","2"],"figref":["FIG. 1","FIG. 4"]},"When all join tuples are constructed, their attributes referenced in the SELECT clause are fetched and the final answer is computed. For example, corresponding to the 7-tuple (3, 5, 2, 4, 3, 1, 1), these are just the z-values from which their sum is computed: 10+0+12+12+4+20+14=72. \u201c72\u201d is therefore one element of the result returned by the query.","As mentioned above,  present an example of the method for query evaluation by semi-join reduction. The query evaluation method includes several steps, among which is the join tuple assembly. The standard techniques first construct all tuples satisfying the join part of the WHERE clause, then select from these tuples those that additionally satisfy the non-join conditions. This construction is expensive with respect to time and memory consumption. Depending on the data and the topology of the join graph (e.g., cyclic joins), certain obstacles can occur such as: 1) perfect reduction of tables to the projections of the join, by semi-joins alone, is challenged; and 2) to flatten the join graph in the reduction phase into a tree by duplicating vertices leads to practical inefficiencies when afterwards, in the assembly phase, one has to secure the identity of the join tuple entries at the positions of the duplicated nodes. In these cases, and also in the presence of non-join conditions that can only be evaluated on the already evaluated join, it is common in practice that the phase of join tuple assembly is the one consuming most of the computation time and\/or the phase with the highest memory consumption.","Embodiments of techniques for a join tuple assembly algorithm by partial specializations are described herein. For simplicity reasons, the algorithm for a join tuple assembly is described using parts of the example introduced with . In an embodiment, the algorithm is applied on a join query (e.g., join query ). The WHERE clause is divided into a join part and a non-join part. The join part can be visualized as a join graph (e.g., JG ) and the non-join part can be visualized as an operator tree (e.g., operator tree ). The join tuples to be constructed should also satisfy the condition represented by the operator tree (i.e., \u0393). In the operator tree, the inner nodes are Boolean operators and the leaves are certain terms. Every term references some subset of the base relations R, R, . . . , Rof the join.","A materialization graph G=(V, A), where \u201cV\u201d is a set of vertices and \u201cA\u201d is a set of arrows, has been built that in general corresponds to a subgraph of the join graph. In the example, MG  corresponds to the full join graph. In general, the materialization graph G is a directed graph on the vertex set V={1, 2, 3 . . . N}, where N\u2208N. In general, every vertex n represents one base relation Rof the join graph (e.g., JG ). In the materialization graph G, the relations are renamed as in MG . In the current example, Ris 1, Ris 2, and so on. Here, every arrow a\u2208A,",{"@attributes":{"id":"p-0040","num":"0039"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":["m","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}}}},"br":{},"sub":["m ","n"]},{"@attributes":{"id":"p-0041","num":"0040"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":["\u201c","\u201d"],"mrow":{"mi":["m","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}}}}},"br":{},"sub":["m ","n"]},{"@attributes":{"id":"p-0042","num":"0041"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":["m","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}}}},"br":{}},"In an embodiment, the underlying join graph part (including a set of vertices V and a set of edges E, where the set of edges E is obtained from a set of arrows A but without a direction) may contain undirected cycles, but not loops (cycles of length 1). Also, every full subgraph G\u2032=G\u2229{1, 2, . . . , n}, 1<=n<=N of G has the same properties as G. A subgraph G\u2032 of a graph G is called full, if all edges in G connecting vertices in G\u2032 are also edges in G\u2032. Similarly to G, G\u2032 is a directed acyclic graph with ascending arrows, it has exactly one source, and for all vertices v\u2208G\u2032, that is, for 1<=v<=n, there is at least one directed path in G\u2032 from 1 to v.","In an embodiment, for every arrow a\u2208A, a head h and a tail t are defined. If an arrow a is",{"@attributes":{"id":"p-0045","num":"0044"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["m","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}},"mo":","}}},"br":{},"sup":"\u22121"},{"@attributes":{"id":"p-0046","num":"0045"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["m","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0047","num":"0046"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["m","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2190","msup":{"mi":"a","mrow":{"mo":"-","mn":"1"}}}},"mo":","}}},"br":{},"sup":["\u22121","\u22121","\u22121 "],"sub":["1 ","2 ","r","i","i","1+1","r","1"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 6","FIG. 6"],"b":["610","620","630","640","620","630","640","620","630","640","620","630","630","640","640","620","630"]},"In an embodiment, an arrow has at most one predecessor. A predecessor of an arrow is another arrow that has the same head as the first arrow, but the next lower tail. In the same example, c  has a predecessor, namely b , and b  also has a predecessor, namely a , whereas a  has no predecessor. a  is not the predecessor of c  since b  is between them. This can be written as P(c)={b}, P(b)={a} and P(a)=\u03c6.","In an embodiment, matching sets from the reduction of the full relations R, R, R, R, R, R, and R are defined as part of the algorithm for join tuple assembly by partial specializations. For every vertex n\u2208V, the matching set MRis the reduction result of the full table R. Additionally, for every arrow a\u2208A,",{"@attributes":{"id":"p-0051","num":"0050"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["m","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}},"mo":","}}},"br":{},"sub":["a","n"],"u":"\u2282"},{"@attributes":{"id":"p-0052","num":"0051"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["m","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0053","num":"0052"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["k","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"b"}},"mo":","}}},"br":{},"sub":["ab","k","n,0","a","ab"],"sup":["\u22121","\u22121"],"u":"\u2282"},"In an embodiment, the collection of all matching sets is defined as M. M contains exactly |V| sets of the form M, exactly |A| sets of the form M, and at most |A| sets of the form M. Further, M contains at least one set of the form Mexactly when the materialization graph G contains unoriented cycles.","The definition of the matching sets also includes defining the head and tail functions on M (as so far, these are defined only for paths in G). In an embodiment, M\u2208M is a matching set of the form M, M, or M. If M=Mfor some vertex n\u2208V, then h(M)=n and t(M)=0. If M=Mfor some path c=a (or c=ab) in G, then h(M)=h(c) and t(M)=t(c). These definitions lead to the following two consequences: 1) for every matching set M there is MR, where n=h(M); and 2) for any n\u2208V there are matching sets (M\u2208M) with t(M)=n exactly when n is not a sink (a vertex of a directed graph with no outgoing arrows) in G.","In an embodiment, the above described head and tail functions on M are used to define an ordering on M. First, the tail function is applied: for all M, M\u2032\u2208M:t(M)<t(M\u2032)M before M\u2032. This means that if the tail of matching set M is lower than the tail of matching set M\u2032, then M is ordered before M\u2032. Having ordered the matching sets with unequal tails, the matching sets of equal tail remain to be ordered. This is first done for the case of two matching sets that both have tail \u201c0\u201d: For all 1<=m<n<=N, Mis ordered before M.","Then, two matching sets having a common tail t are ordered, where 1<=t<=N. For this purpose, let",{"@attributes":{"id":"p-0058","num":"0057"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"t","mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","msub":{"mi":"a","mn":"1"}},"msub":{"mi":"n","mn":"1"}},{"mi":"t","mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","msub":{"mi":"a","mn":"2"}},"msub":{"mi":"n","mn":"2"}},{"mi":"t","mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","msub":{"mi":["a","S"]}},"msub":{"mi":["n","s"]}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},"br":{},"sub":["1","2","5","1","2","5","a1","as ","a1 ","a2 ","a3 ","as","ab","ab","a"],"sup":["\u22121 ","\u22121 "]},"In another embodiment, the set M of all matching sets is subdivided using the head function for every vertex n\u2208V, let M={M\u2208M:h(M)=n}M. Then, M=M\u222aM\u222a . . . \u222aM. This means that Mis a subset of matching sets from the collection M that have the same head and M is their disjoint union. Since M is already ordered, every subset Mof M is also ordered. Thus, it remains to make this ordering of Mexplicit: for all M, M\u2032\u2208M:t(M)<t(M\u2032)M is place before M\u2032. Since the head of the matching sets M and M\u2032 is the same (i.e., n), then the tails of the matching sets are compared. If they are different, the matching set with the lower tail is placed first (in this case, matching set M) in the ordering. Malways contains the matching set M(where h (M)=n and t(M)=0), which is placed first in M.","The ordering of Mis to be made explicit for matching sets of equal tails. This is done for all matching sets M\u2208Mhaving t(M)=t, where t is a fixed value with 1<=t<N. These matching sets can be obtained as follows: there is an arrow a\u2208A,",{"@attributes":{"id":"p-0061","num":"0060"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":["t","k"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}}}},"br":{},"sub":"a"},{"@attributes":{"id":"p-0062","num":"0061"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":["n","k"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"b"}}}},"br":{},"sub":"ab","sup":"\u22121"},{"@attributes":{"id":"p-0063","num":"0062"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":["t","k"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}}}},"br":{},"sub":["a ","ab"],"sup":"\u22121"},{"@attributes":{"id":"p-0064","num":"0063"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"t","mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","msup":{"mi":["a","\u2032"]}},"msup":{"mi":["k","\u2032"]}}}},"br":{}},{"@attributes":{"id":"p-0065","num":"0064"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["t","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}},"mo":","}}},"br":{},"sub":["a","n ","n "]},"The ordering in Mcan be written as: M={M, M, M, . . . , M}, r\u2208N, where Mis placed before M, which is placed before Mand so on till M. This expression provides the matching sets M, which have the form M=Mfor some path c=a (or c=ab), with an additional name M=M, where i>0 represents their position in the ordered collection M. These matching sets can be referred as \u201chigher matching sets\u201d. The first matching set, M, is the matching set already defined above as reduction result of relation R. Mis always placed first in M. The ordered collection Mhas some properties including: 1) M\u2208Mfor all n\u2208V; and 2) |M|>1 for all n>1.","In an embodiment, the matching sets Mform a descending chain (for any fixed n\u2208V) of the type: RMMM . . . M, where r\u2208N. The descending order of this chain comes from the fact that their members satisfy successively more conditions that are necessary to qualify as the next element in a join tuple construction process. Elements for the construction process will only be taken from the last smallest set M, but the intermediate chain members Malso represent valuable information. This information can be reused without being recomputed and accelerates the entire tuple construction process.","In an embodiment, every matching set defined as part of the algorithm for join tuple assembly by partial specializations depends on some t-tuple (r, r, . . . , r)\u2208R\u00d7R\u00d7 . . . \u00d7R, for 0<=t<N. This means that the tuple (r, r, . . . , r) is needed for M to be defined. The dependency of the matching sets on tuples can be described abstractly in the following way: when M depends on (r, r, . . . , r), this could be any tuple in R\u00d7R\u00d7 . . . \u00d7R. When executing the join tuple algorithm, the tuples (r, r, . . . , r) that occur in this context will be no longer arbitrary\u2014they occur during the algorithm as valid join tuples for some subgraph of G that are in the process to be completed to a full N-tuple (r, r, . . . , r)\u2208R\u00d7R\u00d7 . . . \u00d7R, satisfying the complete WHERE clause.","The matching sets are defined recursively in the order of M. The induction basis is formed by the reduction results M, . . . , M, which are already defined and ordered first in M. In the ordering of M, let M be the first matching set that is yet undefined. In an embodiment, the first case is considered that M=Mfor some arrow",{"@attributes":{"id":"p-0070","num":"0069"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["t","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mrow":{"mstyle":[{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}}],"mo":["\u2062","\u2062"],"mi":"a"}}},{"mi":"a","mo":"\u2208","mrow":{"mi":"A","mo":"."}}],"mo":","}}},"br":{},"sub":["n,i ","n,i","n","n,i\u22121","n,i\u22121","n","n,i","a","n,i","n,i\u22121","t","t","n ","t ","1","2","N\u22121","1","2","N\u22121","t","n","1","n","a","n,i","n,i\u22121","1","n,i\u22121","n","n,i\u22121 ","t "],"u":["\u2282","\u2282","\u2282","\u2282","\u2282"]},"In another embodiment, the first yet undefined matching set M has the form: M=Mfor some arrow",{"@attributes":{"id":"p-0072","num":"0071"},"maths":{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["t","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0073","num":"0072"},"maths":{"@attributes":{"id":"MATH-US-00018","num":"00018"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["k","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"b"}},"mo":","}}},"br":{},"sub":["k,i ","k,i","k","a ","ab","a ","k,i\u22121 ","a","ab","k,i","k,i\u22121","a","a","k ","a ","a","k","a ","k","k,i\u22121 "],"u":["\u2282","\u2282"],"sup":["\u22121","\u22121","\u22121","\u22121","\u22121"]},"In an embodiment, let \u0393 be an operator tree, such as operator tree  and 1<=n<=N, and r\u2208Rare given. \u0393(r), the specialization of\u0393 by r, is an operator tree obtained from \u0393 as follows: into any term in \u0393 (all terms are at the leaf positions of the tree) that references the relation R, the value ris substituted for the variable R. Thus, all terms are specialized, resulting in new terms not referencing R. Some of the new terms may even become constant, this is, identical to True of False. Further, the specialization includes obtaining all constant terms from the operator tree that are not in a root position. Then, the Boolean values of the constant terms are propagated upwards through the nodes of the operator tree \u0393. This leads to further operator tree nodes becoming constant. \u0393(r) is the result of this specialization process of \u0393.","In an embodiment, \u0393 is the operator tree (e.g., operator tree ) representing those conditions of a join query that are not join conditions (and cannot be evaluated before the join has been evaluated). For any N-tuple (r, r, . . . , r)\u2208R\u00d7R\u00d7 . . . \u00d7R, a sequence of successive partial specializations of \u0393 may be defined as follows: let \u0393=\u0393, \u0393=\u0393(r), \u0393=\u0393(r), . . . , \u0393=\u0393(r). In this case, \u0393, the full specialization of \u0393, is either True or False, at the latest. In an embodiment, if some previous specialization \u0393has already been constant, then all specializations that follow \u0393are identical to it and are constant.","The above definitions present matching sets of the form Monly in the case where there are two arrows a, b\u2208A and the successor of arrow a is arrow b: S(a)={b}. If arrow a has a tail m and a head n,",{"@attributes":{"id":"p-0077","num":"0076"},"maths":{"@attributes":{"id":"MATH-US-00019","num":"00019"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["m","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0078","num":"0077"},"maths":{"@attributes":{"id":"MATH-US-00020","num":"00020"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["k","n"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"b"}},"mo":","}}},"br":{},"sup":["\u22121","\u22121","\u22121 ","\u22121","\u22121","\u22121 "],"sub":["ab","ab"]},"If an (N\u22121)-tuple (r, r, . . . , r)\u2208R\u00d7R\u00d7 . . . \u00d7Ris provided and a matching set M\u2208M with 0<=t=t(M)<N has been defined as above, then: 1) M does not depend on r, . . . , r; and 2) if t>0, then M depends on r.","In an embodiment, memory consumption can be greatly reduced by not explicitly storing all matching sets Mof the following descending chain: RMMM . . . M, where r\u2208N, pertaining to some fixed vertex n\u2208V. It is enough to store Mand together with every element x (x\u2208M), an integer i (0<=i<=r), which interpretation is: 1) x\u2208M, x\u2209M, if 0<=i<r, and 2) x\u2208M, if i=r.","Additionally, the computation of matching sets can be further decreased. Let M\u2208M be a matching set and t=t(M), where M depends at most on r, r, . . . , r. If M has been first computed for some t-tuple (r, r, . . . , r) and is later needed for a different t-tuple (r\u2032, r\u2032, . . . , r\u2032), then the attribute values of the rows of the relations that entered the computation from both t-tuples are compared and it is checked if these attribute values are the same on (r\u2032, r\u2032, . . . , r\u2032) as they were on (r, r, . . . , r). If they agree, M does not need to be recomputed, although (r, r, . . . , r) changed. This leads to one more decrease in recomputation since repeated attribute values are quite common in practice.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 7","b":["700","140","310","510","210","705","705","710","705","715"],"sub":["1,0","N,0 ","n,0 "]},"At block , a defined number of initializations are performed. In an embodiment, the initializations include the following elements: 1) a tuple construction counter t; 2) an iterator it; and 3) a trivial partial specialization \u0393of the operator tree \u0393. The tuple construction counter t indicates how far the algorithm  has proceeded in building one more join tuple. For example, if the relations are seven in number, then 7-tuples (r, r, . . . , r) are to be generated and the counter t indicates how far the construction of the current tuple has gone. For example, if t=3, this means that a 2-tuple (r, r) has been identified and constructed that can be completed to a 7-tuple (r, r, . . . , r) and all conditions on rand rhave been checked, and currently the algorithm will search for a suitable r. Initially t is 1 (t=1). The iterator is an object that allows the algorithm  to traverse through all elements of a matching set such as iterator itand M. More iterators are used later in the algorithm, such as: ittraverses M, ittraverses M, ittraverses M, ittraverses M, ittraverses Mand ittraverses M. In general, every iterator ittraverses the matching set ordered last in M.","At block , the algorithm  checks if the value of the counter t is a positive integer, i.e., t>0. If the result from decision block  is \u201cNO\u201d, i.e., t=0, then the algorithm  stops at block  meaning that all tuples satisfying the complete WHERE clause of the join query have been identified as produced. If the result from decision block  is \u201cYES\u201d, then the algorithm continues at block . At block , the iterator itis accessed. This iterator has been initialized either in block  or in an earlier traversal of block . The row ris the row that itcurrently points to; afterwards, itis made to point to the next row in the matching set ittraverses, if there is one: r=*it; it++. When the value of the iterator increases, the algorithm moves to the next row of the matching set. For example, t=1, then itfirst points to 2, since here M={2,3}. At block , the partial specialization \u0393=\u0393(r) is computed from \u0393. This means that the algorithm is at a specific row (r) of the table and there are some attribute values in this row, which are taken to compute the partial specialization \u0393(since attribute values the reduction results are given as input for the algorithm). The computation of \u0393(r) is performed by taking the attribute values from the specified row rand substituting these values into \u0393.","At decision block , the algorithm  checks if the computed partial specialization \u0393is False, this is, whether the operator tree \u0393has degenerated into the simple constant expression False. If the result from decision block  is \u201cYES\u201d, then the algorithm continues at block . At block , while the counter t is a positive integer (t>0) and the current iterator (it) points to the end of the matching set it traverses, hence no row, the value of the counter t is decreased by one or more count value. In an embodiment if, for the original value of t, itpoints to some row of its matching set, then t remains unchanged. In another embodiment, t can be decreased by more than 1. For example, if t decreased from 5 to 3, this means that in the process of constructing the next join tuple, there is a 4-tuple (r, r, r, r) constructed, which so far satisfies all necessary conditions and a suitable rhas to be found. However, this may fail. Thus, a better rhas to be found. But this may also fail, so a better rwill be needed in that case. Therefore, the algorithm resumes work on the current 2-tuple (r, r), searching for a suitable ras part of a 3-tuple (r, r, r) that can be completed to a full N-tuple (r, r, r, . . . r) satisfying the WHERE clause. The algorithm  is returned to decision block . If the result from decision block  is \u201cNO\u201d, then the algorithm continues at block . At decision block , the algorithm  checks whether the value of the tuple construction counter t is equal to N, the needed length for a tuple to be completed, which also equals the number of vertices in tire materialization graph. For example, N=7 is the number of relations from which a row is materialized and thus, the length of every valid tuple is 7.","If the result from decision block  is \u201cYES\u201d, then the algorithm continues at block . At block , the tuple construction counter t is equal to the needed length (t==N), i.e., another N-tuple (r, r, . . . , r) is obtained satisfying the complete WHERE clause. In an embodiment, when a valid N-tuple (r, r, . . . , r) is found, it can be used immediately during the algorithm. This could be the choice if, for example, the join result is used as input by another operation on a second computer. For example, sending the join tuple to the second computer, letting it begin its work immediately instead of waiting for the first computer to complete. In an alternative embodiment, all found N-tuples (r, r, . . . , r) can be first collected and stored in a storage unit for later use.","If the result from decision block  is \u201cNO\u201d, then the algorithm continues at block . At this point, the tuple constructed so far is shorter than a full TV-tuple and the algorithm  prepares for finding the rows that are still needed to complete the full tuple. At block , all matching sets that depend on rare recomputed. These matching sets are identified by the condition that their tail equals t. At decision block , the algorithm checks whether any one of the just recomputed matching sets turned empty. If the result from decision block  is \u201cYES\u201d, then the algorithm continues at block . This means that if there is an empty matching set, then no full join tuple can be constructed from the current shorter tuple. At block , while counter t is a positive integer (t>0) and tire current iterator (it) points to the end of the matching set it traverses, hence to no row, the value of the tuple construction counter t is decreased. The algorithm returns to block  and tries to find a new row rwith the decreased value of t.","If the result from decision block  is \u201cNO\u201d, then the algorithm continues at block . This means that there are no empty matching sets. At block , the value of the counter t is increased by \u201c1\u201d (as part of the loop), indicating that the current tuple, which is to be prolonged to a full N-tuple, has successfully been prolonged by 1. The algorithm is returned to block  where the algorithm searches for a row r, with the increased value of t. The algorithm  terminates when t=0, indicating that all join tuples have been produced.","Algorithm  can be presented with the following code as well:",{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Join Tuple Assembly Algorithm by Partial Specializations (700)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if \u0393 == False or M== \u2205 for any 1 <= n <= N : Stop, the join is empty."},{"entry":"t = 1 ; it= M, begin() ; \u0393= \u0393 ;"},{"entry":"while (t > 0) {\/\/ loop invariants: 1) (r, r, . . . , r) is a join tuple for G \u2229 {1, 2, . . . , t \u2212 1},"},{"entry":"\u2003\u2003\u2003\/\/\u2003\u20032) all M\u2208M with t(M) < t are known and not empty,"},{"entry":"\u2003\u2003\u2003\/\/\u2003\u20033) it, points to some row in the matching set it enumerates, and"},{"entry":"\u2003\u2003\u2003\/\/\u2003\u20034) \u0393!= False."},{"entry":"\u2003r= * it; it++ ; \/\/ (r, r, . . . , r) is a valid join tuple for G \u2229 {1, 2, . . . , t}"},{"entry":"\u2003use rto compute the next partial specialization: \u0393= \u0393(r);"},{"entry":"\u2003incr = (\u0393, != False) ; \/\/ t is incremented\u2009 \u2009rprolongs (r, r, . . . , r)"},{"entry":"\u2003if (incr and t < N) {\/\/ recompute all M\u2208M with t(M) = t"},{"entry":{}},{"entry":"\u2003\u2003\n\n"},{"entry":{}},{"entry":"\u2003\u2003{\/\/ in the order of M : by n increasing!"},{"entry":"\u2003\u2003\u2003compute M= M= M\u2229 a (r);"},{"entry":"\u2003\u2003\u2003incr = (M!= \u2205) ;"},{"entry":{}},{"entry":"\u2003\u2003\u2003\n\n"},{"entry":{}},{"entry":"\u2003\u2003\u2003\u2003compute M= M= M\u2229 b(M);"},{"entry":"\u2003\u2003\u2003\u2003incr = (M!= \u2205);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003if(incr) {"},{"entry":"\u2003\u2003t ++ ; \/\/ for the new t, let Mbe the matching set ordered last in M"},{"entry":"\u2003\u2003it= M. begin() ; \/\/ since M\u2260 \u2205, itpoints to some row"},{"entry":"\u2003}"},{"entry":"\u2003else {"},{"entry":"\u2003\u2003if (t == N and \u0393== True): (r, r, . . . , r), the next join tuple, has been produced"},{"entry":"\u2003\u2003\/\/ try next r, at the same t if possible, otherwise decrease t:"},{"entry":"\u2003\u2003while (t > 0) and itdoes not point to any row: t \u2212\u2212 ;"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The algorithm  accelerates the process of join tuple assembly in the method of semi-join reduction such that the method itself becomes faster and, when compared to other implementations, also decreases memory consumption. The join tuple assembly process is accelerated by algorithm  by using decision steps at several places (e.g., blocks  and ) checking as early as possible whether to stop the computation, if it is clear that the current tuple cannot be completed. For example, at decision block , if the operator tree \u0393, depending on (r, r, . . . , r), is identical to False, then there is no chance that the last operator tree \u0393could ever become True. Instead, the algorithm is returned to block  to find another rthat does not make the operator tree \u0393identical to False. Similarly, at block  if during recomputation of a subset of the matching sets, an empty matching set is encountered, then the algorithm is returned again to block , because the algorithm is aware that at this place for some positions of the join tuple to be filled later, there will be no eligible candidates. These are the earliest possible detections of future failures, using only computations that may not be avoided, hence causing no extra cost. In this way, algorithm  avoids redundant iterations in the loop and performing the same computation twice, which reflects on the join tuple assembly acceleration.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIGS. 8A and 8B","FIGS. 1-5","FIG. 8A"],"b":["700","801","802","830","801","510","801","510","805","810","510"]},{"@attributes":{"id":"p-0093","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Matching Sets with Their Head and Tail Values"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["h(M) = 1, t(M) = 0","h(M) = 3, t(M) = 1","h(M) = 3, t(M) = 2"]},{"entry":["h(M) = 2, t(M) = 0","h(M) = 4, t(M) = 1","h(M) = 5, t(M) = 2"]},{"entry":["h(M) = 3, t(M) = 0","h(M) = 2, t(M) = 1","h(M) = 7, t(M) = 2"]},{"entry":["h(M) = 4, t(M) = 0","h(M) = 5, t(M) = 1","h(M) = 3, t(M) = 2"]},{"entry":["h(M) = 5, t(M) = 0","h(M) = 2, t(M) = 1","h(M) = 4, t(M) = 3"]},{"entry":["h(M) = 6, t(M) = 0","h(M) = 6, t(M) = 1","h(M) = 6, t(M) = 3"]},{"entry":["h(M) = 7, t(M) = 0","h(M) = 3, t(M) = 1","h(M) = 7, t(M) = 3"]},{"entry":["h(M) = 2, t(M) = 1","h(M) = 4, t(M) = 2","h(M) = 4, t(M) = 3"]},{"entry":[{},{},"h(M) = 7, t(M) = 4"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Then, the collection of all matching sets M is ordered using the computed head and tail functions, at block . The ordering of the matching sets follows the definitions given above. First, the matching sets that are not of the type Mare ordered, these are the reduction results Mand the sets of type M. For these matching sets, the order is: first by ascending tail function; and then, for equal values of the tail function, by ascending head function. These indications are sufficient since for these types of sets no two different sets have the same head and tail. Then, every matching set Mis placed immediately after its corresponding set M. According to the example, the resulting ordering is:",{"@attributes":{"id":"p-0095","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Ordered Collection of all Matching Sets"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M = {M, M, M, M, M, M, M, M, M, M, M, M,"},{"entry":"M, M, M, M, M, M, M, M, M, M, M, M, M}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"At block , the collection of all matching sets M is divided into a number of sub-collections containing matching sets with equal head function:",{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sub-Collections of all Matching Sets by Equal Head"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= {M}"},{"entry":"M= {M, M, M, M}"},{"entry":"M= {M, M, M, M, M}"},{"entry":"M= {M, M, M, M, M}"},{"entry":"M= {M, M, M}"},{"entry":"M= {M, M, M}"},{"entry":"M= {M, M, M, M}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"These sub-collections can be renumbered to represent the order of a given matching set in a given sub-collection. This is:",{"@attributes":{"id":"p-0099","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Renumbered Matching Sets"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= {M}"},{"entry":"M= {M, M, M, M}"},{"entry":"M= {M, M, M, M, M}"},{"entry":"M= {M, M, M, M, M}"},{"entry":"M= {M, M, M}"},{"entry":"M= {M, M, M}"},{"entry":"M= {M, M, M, M}"},{"entry":"where: M= M, M= M, M= M"},{"entry":"M= M, M= M, M= M, M= M"},{"entry":"M= M, M= M, M= M, M= M"},{"entry":"M= M, M= M, M= M, M= M"},{"entry":"M= M, M= M, M= M"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"At block , the matching sets Mwith i>0 are recursively defined using the reduction results Mas the induction basis. As set in the example of , it is assumed that a 6-tuple (r, r, r, r, r, r)\u2208R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7Ris given. The example of  includes a 7-tuple (r, r, r, r, r, r, r)\u2208R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7r\u00d7R, but since the last vertex is a sink in the materialization graph , reflecting a general property of all materialization graphs, the last tuple (i.e., r) will never be used. The defined matching sets depend on appropriate parts of this 6-tuple. Simultaneously, it is verified that the extent of dependency of the matching sets on the 6-tuple (r, r, r, r, r, r) is correctly reproduced by the tail function, as described above.","The definition of the higher matching sets begins by setting: M=M=M\u2229a(r). The predicate a is a(x, y)=(x\u00b7a=y\u00b7a) for x\u2208R, y\u2208R, where the set a(r), depending on the first element rof the 6-tuple, is a(r)={x\u2208R:x\u00b7a=r\u00b7a} so that matching set Mhas been defined: M=M={x\u2208M:s\u00b7a=r\u00b7a}. Hence, M=Mdepends on r, but not on r, r, r, r, r. Since t(M)=1, this agrees with the following general observation: if M\u2208M is a matching set with 0<=t=t(M)<N, then: 1) M does not depend on r, . . . . , r; and 2) if t>0, then M depends on r. Analogously, matching sets Mand Mcan be defined: M=M=M\u2229b(r) and M=M=M\u2229c(r).","The next matching set in the ordering of M is M=M. The definition of Muses the previously defined M=Mand M=M:M=MM\u2229f(M). The predicate fin f this example is f(x,y)=(x,f=y,f) for x\u2208R, y\u2208R. An explicit description of the set f(M)={x\u2208R:x\u00b7f=y\u00b7f for some y \u2208M}. Therefore, the matching set Mcan be defined explicitly as: M=M={x\u2208M:x\u00b7f=y\u00b7f for some y\u2208M}. Since M=Mand M=Mboth depend on r, but not on r, r, r, r, r; the same is valid for M=M, in accordance with t(M)=1.","Analogously, the following matching sets can be defined, as all of them have a tail equal to 1 and depend on r, but not on r, r, r, r, r.",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Matching Sets M with tail t(M) = 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= M= M\u2229 d(r)"},{"entry":"M = M= M\u2229 g(M)"},{"entry":"M= M= M\u2229 e(r)"},{"entry":"M = M= M\u2229 j(M)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Further, in the ordering of M the matching sets with tail t(M)=2 are defined. These matching sets depend on r, r, but not on r, r, r, r:",{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Matching Sets M with tail t(M) = 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= M= M\u2229 f(r)"},{"entry":"M = M= M\u2229 i(M)"},{"entry":"M= M= M\u2229 g(r)"},{"entry":"M= M= M\u2229 h(r)"},{"entry":"M = M= M\u2229 k(M)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Further, in the ordering of M the matching sets with tail t(M)=3 are defined. These matching sets depend on r, r, r, but not on r, r, r:",{"@attributes":{"id":"p-0108","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Matching sets M with tail t(M) = 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= M= M\u2229 i(r)"},{"entry":"M= M= M\u2229 j(r)"},{"entry":"M= M= M\u2229 k(r)"},{"entry":"M = M= M\u2229 l(M)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Finally, in the ordering of M the matching set with tail t(M)=4 is defined, as in this example there is only one such matching set: M=M=M\u2229l(r). Similarly, the matching set Mdepends on r, r, r, r, but not on r, r. In this example of the method for join query evaluation, there are no matching sets with tail t(M)=5, 6, 7, since these vertices are sinks in the materialization graph . That is why no matching set depends on ror r. However, it should be noted that for other materialization graphs on 7 vertices matching sets with tail t(M)=5, 6 may exist.","At block , the join tuple assembly algorithm is initiated to construct all join tuples satisfying the complete WHERE clause; each of them is a 7-tuple (r, r, r, r, r, r, r)\u2208R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7R. At the outset, their number is unknown; both options are possible: there might be no join tuples at all or there might be up to |R|*|R|*|R|*|R|*|R|*|R|*|R| join tuples. Their number also has to be determined by the algorithm.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":["FIG. 8B","FIGS. 1-5"],"b":["802","801","700","405","410","415","420","425","430","435","700"],"sub":["1 ","2 ","3 ","4 ","5 ","6 ","7 ","1,0","2,0","3,0","4,0","5,0","6,0","7,0"]},"At block , the non-join conditions of the WHERE clause are checked. Since M={2,3}\u2260\u03c6, . . . , M={1,2}\u2260\u03c6 and\n\n\u0393=()+()+()+()+()+()+()<=1000\n\nAND\n\n((1000) OR (0))\n\nis not identical to the constant expression False, the algorithm is initialized by setting the counter t=1, the iterator itpoints to 2\u2208M={2,3} and \u0393=\u0393 is set up as the first member of the sequence of successive partial specializations to come. At this point of the algorithm, a 0-tuple is constructed. The algorithm  has to select a suitable r\u2208M, of which it might be possible to complete it to a full 7-tuple (r, r, r, r, r, r, r)\u2208R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7Rsatisfying the complete WHERE clause.\n","At block , the algorithm  checks if the tuple construction counter is a positive integer. Since in the current example, the tuple counter is a positive integer, the loop of algorithm  is entered. Executing r=*it; it++ from block  of algorithm  leads to r=2 and itpointing to 3\u2208M={2,3}. At block , the first partial specialization is computed. Using the attribute value r\u00b7z=9, the partial specialization \u0393=\u0393(r) of \u0393can be computed by substituting the attribute value into \u0393:\n\n\u0393=9+()+()+()+()+()+()<=1000\n\nAND\n\n((91000) OR (90))\n\nThis expression can be simplified to:\n\n\u0393=()+()+()+()+()+()<=919\n\nAND\n\n((111.111) OR (0))\n\nAt block , the computed partial specialization is checked whether it is identical to the constant expression False. In the current example, this is not the case: since \u0393still contains variables, e.g. R\u00b7z, it is not constant, so it is neither False nor True. If the computed partial specialization was False, then the algorithm will continue at block . At block , the tuple construction counter t may remain unchanged if itstill points to some row, i.e., to \u2208Mor the tuple counter may be decreased by one or more counts if the iterator itpoints to no row. The algorithm then continues at block  where the same procedure has to be performed for the value r=3 that was just performed for the value r=2.\n","At block , the tuple construction counter is checked if its value is equal to the needed length of any join tuple. Since currently t=1 and the needed length is 7, a full 7-tuple is not constructed and the method continues at block . Otherwise the method continues at block  where the constructed full tuple is stored or used directly in some functionality. At block , all matching sets with t(M)=1 are computed for the first time (and recomputed on each next execution of the loop of algorithm ), this is, those matching sets that depend on ronly. According to MG , all arrows with tail( )=1, ordered by head( ) ascending, are:",{"@attributes":{"id":"p-0115","num":"0114"},"maths":{"@attributes":{"id":"MATH-US-00023","num":"00023"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mn":["1","2"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"a"}},{"mn":["1","3"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"b"}},{"mn":["1","4"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"c"}},{"mn":["1","5"],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"d"}},{"mn":["1","6."],"mo":["\u2062","\u2062"],"mover":{"mo":"\u2192","mi":"e"}}],"mo":[",",",",",",","]}}},"br":{},"sub":["a","2,1 ","a","2,1","2,0","1","1","a","2,1","2,0","2,0","2 ","2 ","a","2,1","a ","2,0 ","1","1","1","2","3","4","5","6","7","1","2","3","4","5","6","7 "]},"Analogously, the matching sets Mand Mare computed. Since M=M={x\u2208M:x\u00b7b=r\u00b7b} and M=M={x\u2208M:x\u00b7c=r\u00b7c} and r\u00b7b=4 and r\u00b7c=6, then M=M={x\u2208M:x\u00b7b=4}={3} and M\u2192M={x\u2208M:x\u00b7c=6}={3}.","Further, the matching set M=Mis computed. As defined above, M=M={x\u2208M:x\u00b7f=y\u00b7f for some y\u2208M}. Since M={3} in this case is a singleton (a set with exactly one element), the set {y\u00b7f:y\u2208M}={12} is also a singleton. Therefore, M=M={x\u2208M:x\u00b7f=12} has to be evaluated. Since only row ID=4 in reduction table R satisfies this condition, then M=M={4}.","Analogously, the matching sets M, M, M, and Mare computed: M=M={x\u2208M:x\u00b7d=r\u00b7d}={x\u2208M:x\u00b7d=8}={2}; M=M={x\u2208M:x\u00b7g=y\u00b7g for some y\u2208M}={x\u2208M:x\u00b7g=9}={4}; M=M={x\u2208M:x\u00b7e=r\u00b7e}={x\u2208M:x\u00b7e=10}={2,4}; and M=M,={x\u2208M:x\u00b7j=y\u00b7j for some y\u2208M}. Although M={2,4} is a 2-element set, these two rows happen to have identical j attributes and thus {y\u00b7j:y\u2208M}={12} and M=M={x\u2208M:x\u00b7j=12}={3}. The last computed matching set Mcan be interpreted as follows: for r=2, only the subset: {3}=M=MM={2,3}, matches runder the join condition b\u2208MG (since MM=M) and matches, under join condition j\u2208MG, some row in M, which under join condition e\u2208MG, matches r. Thus, only the elements of M=Msatisfy the stated necessary conditions for rto become completed to a full 7-tuple (r, r, r, r, r, r, r)\u2208R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7Rsatisfying the complete WHERE clause.","At this point of the computation, it is possible that the 1-tuple (r=2) can be completed to a full 7-tuple (r, r, r, r, r, r, r), because: 1) the first partial specialization \u0393is not False, thus the complete specialization \u0393could become True; and 2) all matching sets depending exactly on r, these are M, M, M, M, M, M, M, and M, were computed and proven to be non-empty sets, thus rhas a consistent choice of join partners in all joins it participates in.","At block , the tuple construction counter t is increased by \u201c1\u201d. This leads to t=2, which means that a 2-tuple (r, r) is going to be constructed from the 1-tuple (r=2). Considering the following descending chain of matching sets: RMMMM, the iterator itpoints to row ID=4\u2208M={4}. Method  is returned to block , where algorithm  is returned to the initial step of the loop as r=4 and itpoints to the end of M. Using the attribute value r\u00b7z=5 (the only attribute of Rreferenced in \u0393), the next partial specialization \u0393=\u0393(r) is computed, as in block . Substituting the attribute value r\u00b7z=5 into \u0393leads to:\n\n\u0393=5+()+()+()+()+()<=919\n\nAND\n\n((5111.111) OR (50))\n\nThis expression can be simplified to:\n\n\u0393=()+()+()+()+()<=894\n\nAND\n\n((22.222) OR (0))\n","As \u0393is not False, all matching sets with tail t(M)=2 (those matching sets that depend exactly on r) are computed:",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Computed Matching Sets Depending on (r= 2, r= 4)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= M= {x \u03b5 M:x.f = r.f} = {x \u03b5 M:x.f = 12} = {3}"},{"entry":"M = M= {x \u03b5 M:x.i = y.i for some y \u03b5 M} = {x \u03b5 M:x.i = 14} = {3}"},{"entry":"M= M= {x \u03b5 M:x.g = r.g} = {x \u03b5 M:x.g = 9} = {2}"},{"entry":"M= M= {x \u03b5 M:x.h = r.h} = {x \u03b5 M:x.h = 5} = {2}"},{"entry":"M = M= {x \u03b5 M:x.k = y.k for some y \u03b5 M} = {x \u03b5 M:x.k = 2} = {3}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Similarly, the 2-tuple (r, r) could possibly be completed to a full 7-tuple (r, r, r, r, r, r, r) because of the same reasons: 1) the second partial specialization \u0393is not False, thus the complete specialization \u0393could become True; and 2) all matching sets depending exactly on rwere computed and proven to be non-empty sets. Therefore, the tuple construction counter t is increased again to t=3, as in block . The method  continues the loop considering the descending chain RMMMMMwith t=3, gets r=3 and itpointing to the end of M={3}. Using the attribute value r\u00b7x=14 the next partial specialization \u0393=\u0393(r) is computed:\n\n\u0393=14+()+()+()+()<=894\n\nAND\n\n((1422.222) OR (140))\n\nThis expression can be simplified to:\n\n\u0393=()+()+()+()<=698\n\nAND\n\n((1.5873) OR (0))\n","As \u0393is not False, all matching sets with tail t(M)=5 (those matching sets that depend exactly on r) are computed:",{"@attributes":{"id":"p-0125","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Computed Matching Sets Depending on (r= 2, r= 4, r= 3)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= M= {x \u03b5 M:x.i = r.i} = {x \u03b5 M:x.i = 14} = {3}"},{"entry":"M= M= {x \u03b5 M:x.j = r.j} = {x \u03b5 M:x.j = 12} = {2, 4}"},{"entry":"M= M= {x \u03b5 M:x.k = r.k} = {x \u03b5 M:x.k = 2} = {2}"},{"entry":"M = M= {x \u03b5 M:x.l = y.l for some y \u03b5 M} = {x \u03b5 M:x.l = 15} = {3}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Similarly, the tuple construction counter is increased once more to t=4. Considering the descending chain RMMMMM, on the next entry on the loop, r=3 and itpointing to the end of M={3}. Using the attribute value r\u00b7z=10, the next partial specialization \u0393=\u0393(r) is computed:\n\n\u0393=10+()+()+()<=698\n\nAND\n\n((10>=1.5873) OR (10=0))\n\nThis expression can be simplified to:\n\n\u0393=()+()+()<=598\n\nAND\n\n(True OR False)\n","The second part of the expression becomes True, since one sub-part of it is True. Therefore: \u0393=(R\u00b7z)+(R\u00b7z)+(R\u00b7z)<=598. The AND node contains no branch that is False, therefore it does not become False. In this case all True branches of the operator tree can be removed: \u0393=(R\u00b7z)+(R\u00b7z)+(R\u00b7z)<=598. AND. Now, the AND node contains exactly one branch and can therefore be replaced by this branch, decreasing the height of \u0393and making it a tree of one node: \u0393=(R\u00b7z)+(R\u00b7z)+(R\u00b7z)<=598.","Since \u0393is still not constant, hence different from False, all matching sets with tail t(M)=4 are computed (those matching sets that depend exactly on r=2, r=4, r=3, r=3). This is only one set:\n\n()={15}={2}\n","Further, the tuple construction counter is increased to t=5. Considering the matching set chain RMMM, and the iterator itpoints to the end of M={2}. Using the attribute value r\u00b7z=12, the next partial specialization \u0393=\u0393(r) is computed: \u0393=12+(R\u00b7z)+(R\u00b7z)<=598, which simplified leads to: \u0393=(R\u00b7z)+(R\u00b7z)<=454. Since there are no matching sets to compute, steps  and  of the algorithm  are skipped and the algorithm proceeds with increasing the counter t to t=6 (as in step ). Considering the descending chain RMMM, on the next entry in the loop, r=2 and itpoints to row ID=2\u2208M={2,4}. Using the attribute value r\u00b7z=25, the next partial specialization \u0393=\u0393(R) is computed: \u0393=25+(R\u00b7z)<=454, which simplified leads to: \u0393=(R\u00b7z)<=\u2212171. All attributes values of the relations are integer values, hence real numbers, and a square of a real number can never be negative. Thus, the partial specialization \u0393is False.","At this point of the example, one of the partially specialized operator trees \u0393is False. The tuple construction counter remains unchanged at t=6, since at block  itpoints to 4\u2208M={2,4}. Therefore, the constructed tuple (r=2, r=4, r=3, r=3, r=2) also remains unchanged and the computed matching sets with tail t(M)<=5 are not recomputed. At block , r=4 and itpointing to the end of Mare set. At this point, the algorithm has to compute \u0393for r=4. However, the attribute value is the same for both rows of the table: again, r\u00b7z=25. Thus, the recomputation of \u0393becomes unnecessary as the partial specialization \u0393is still False. At this point, there is no other ravailable (meaning no other rows in the matching set M={2,4}). The current iterator positions are: itpoints to the end of M={2,4}; itpoints to the end of M={2}; itpoints to the end of M={3}; itpoints to the end of M={3}; itpoints to the end of M={4}; itpoints to 3\u2208M={2,3}. Therefore, the first iterator in this sequence pointing to any row within its matching set is it.","This means that the 6-tuple (r=2, r=4, r=3, r=3, r=2, r=4) cannot be completed to any 7-tuple satisfying the complete WHERE clause. Additionally, when (r=2, r=4, r=3, r=3, r=2) are fixed, there is no choice of a next r. Therefore, even the 5-tuple (r=2, r=4, r=3, r=3, r=2) cannot be completed to 7-tuple. Again, when (r=2, r=4, r=3, r=3) are fixed, there is no choice of a next r. Therefore, even the 4-tuple (r=2, r=4, r=3, r=3) cannot be completed. This continues until it becomes evident that even the 1-tuple (r=2) cannot be completed. Thus, a new ris needed and since in the current scenario, in contrast to the scenarios before, a new rexists, the algorithm decides to continue and not to stop as join tuples satisfying the WHERE clause could exist. Algorithm  reflects this situation, in step , by decreasing the tuple construction counter from t=6 to t=1.","Method  is then returned to block , where tire loop is entered again. At this point r=3 and iterator itpointing to the end of Mare set. The last partial specialization used was \u0393=\u0393. From this, using the attribute value r\u00b7z=10, the next partial specialization \u0393=\u0393(r), is computed:\n\n\u0393=10+()+()+()+()+()+()<=1000\n\nAND\n\n((101000) OR (100))\n\nThis expression can be simplified to:\n\n\u0393=()+()+()+()+()+()<=900\n\nAND\n\n((100) OR (0))\n","Since \u0393is not the constant expression False and t=1 did not yet reach the required level of N=7, the matching sets with tail t(M)=1, i.e., those matching sets that depend exactly on r=3 are recomputed. It should be noted that this cannot be avoided since rchanged and its attribute values also changed. At the same time all matching sets with tail less than t are not recomputed. In the specific examples, where t scaled down from t=6 to t=1, this could be unnoticed, since this leads to the event that only the reduction results Mare not recomputed, having a tail ( ) of 0. If however t had only scaled down from t=6 to t=5, which indeed is the typical case, all matching sets of tails 0, 1, 2, 3 or 4, that is, all matching sets would remain valid:",{"@attributes":{"id":"p-0134","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Computed Matching Sets Depending on (r= 3)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= M= {x \u03b5 M:x.a = r.a} = {x \u03b5 M:x.a = 3} = {5}"},{"entry":"M= M= {x \u03b5 M:x.b = r.b} = {x \u03b5 M:x.b = 6} = {2}"},{"entry":"M= M= {x \u03b5 M:x.c = r.c} = {x \u03b5 M:x.c = 9} = {4}"},{"entry":"M = M= {x \u03b5 M:x.f = y.f for some y \u03b5 M} = {x \u03b5 M:x.f = 14} = {5}"},{"entry":"M= M= {x \u03b5 M:x.d = r.d} = {x \u03b5 M:x.d = 12} = {3}"},{"entry":"M = M= {x \u03b5 M:x.g = y.g for some y \u03b5 M} = {x \u03b5 M:x.g = 9} = {5}"},{"entry":"M= M= {x \u03b5 M:x.e = r.e} = {x \u03b5 M:x.e = 15} = {1, 5}"},{"entry":"M = M= {x \u03b5 M:x.j = y.j for some y \u03b5 M} = {x \u03b5 M:x.j = 15} = {2}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Following algorithm , the tuple construction counter is increased to t=2; r=5, and the iterator itpoints to the end of M={5}. Using the attribute value r\u00b7z=0, the next partial specialization \u0393=\u0393(r) is computed, as in block . Substituting the attribute value r\u00b7z=0 into \u0393leads to:\n\n\u0393=0+()+()+()+()+()<=900\n\nAND\n\n((0\u00b7z>=1000) OR (0\u00b7z*R0))\n\nAs the second part of the Boolean expression is True, the height of the operator tree \u0393decreases and \u0393becomes a one-node tree:\n\n\u0393=()+()+()+()+()<=900\n","Since \u0393is not the constant expression False, tire matching sets with tail t(M)=2 are:",{"@attributes":{"id":"p-0137","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Computed Matching Sets Depending on (r= 3, r= 5)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= M= {x \u03b5 M:x.f = r.f} = {x \u03b5 M:x.f = 14} = {4}"},{"entry":"M = M= {x \u03b5 M:x.i = y.i for some y \u03b5 M} = {x \u03b5 M:x.i = 16} = {2}"},{"entry":"M= M= {x \u03b5 M:x.g = r.g} = {x \u03b5 M:x.g = 9} = {3}"},{"entry":"M= M= {x \u03b5 M:x.h = r.h} = {x \u03b5 M:x.h = 10} = {1}"},{"entry":"M = M= {x \u03b5 M:x.k = y.k for some y \u03b5 M} = {x \u03b5 M:x.k = 1} = {2}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Analogously, the tuple construction counter is increased to t=3; r=2, and the iterator itpoints to the end of M={2}. Using the attribute value r\u00b7z=12, the next partial specialization \u0393=\u0393(r) is computed, as in block . Substituting the attribute value r\u00b7z=12 into \u0393leads to:\n\n\u0393=12+()+()()+()<=900\n","This expression can be simplified to:\n\n\u0393=()+()+()+()<=756\n","As \u0393is not identical to False, all matching sets with tail t(M)=3 are computed:",{"@attributes":{"id":"p-0141","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Computed Matching Sets Depending on (r= 3, r= 5, r= 2)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"M= M= {x \u03b5 M:x.i = r.i} = {x \u03b5 M:x.i = 16} = {4}"},{"entry":"M= M= {x \u03b5 M:x.j = r.j} = {x \u03b5 M:x.j = 15} = {1, 5}"},{"entry":"M= M= {x \u03b5 M:x.k = r.k} = {x \u03b5 M:x.k = 1} = {1}"},{"entry":"M = M= {x \u03b5 M:x.l = y.l for some y \u03b5 M} = {x \u03b5 M:x.l = 20} = {4}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Further, the tuple construction counter is increased to t=4; r=4, and the iterator itpoints to the end of M={4}. Using the attribute value r\u00b7z=12, the next partial specialization \u0393=\u0393(r) is computed, as in block . Substituting the attribute value r\u00b7z=12 into \u0393leads to:\n\n\u0393=12+()+()+()<=756\n\nThis expression can be simplified to:\n\n\u0393=()+()+()<=612\n\nAs \u0393is not False, all matching sets with tail t(M)=4 are computed. This is only one set: M=M={x\u2208M:x\u00b7l=r\u00b7l}={x\u2208M:x\u00b7l=20}={1}.\n","Further, the tuple construction counter is increased to t=5, r=3, and the iterator itpoints to row the end of \u2208M={3}. Using the attribute value r\u00b7z=4, the next partial specialization \u0393=\u0393(r) is computed, as in block . Substituting the attribute value r\u00b7z=4 in \u0393leads to:\n\n\u0393=4+()+()<=612\n\nThis expression can be simplified to:\n\n\u0393=()+()<=596\n","Since \u0393is not False and there are no matching sets to compute, step  of method  is skipped and the algorithm proceeds with increasing the counter t, as in step . Thus, the tuple construction counter is increased to t=6, r=1 and the iterator itpoints to the end of \u2208M={1,5}. Using the attribute value r\u00b7z=20, the next partial specialization \u0393=\u0393(r) is computed. Substituting the attribute value r\u00b7z=20 into \u0393leads to:\n\n\u0393=20+()<=596\n\nThis expression can be simplified to:\n\n\u0393=()<=196\n","Since \u0393is not False and there are no matching sets to compute, step  of method  is skipped and the algorithm proceeds with increasing the counter t, as in step . Thus, the tuple construction counter is increased to t=7, r=1, and the iterator itpoints to tire end of \u2208M={1} Using the attribute value r\u00b7z=14, the next partial specialization \u0393=\u0393(r) is computed. Substituting the attribute value r\u00b7z=14 into \u0393leads to: \u0393=14<=196, which makes: \u0393True. According to block  of algorithm , the value of the counter t is equal to the number N of nodes in the materialization graph MG . The first full 7-tuple (r=3, r=5, r=2, r=4, r=3, r=1, r=1) \u2208R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7R\u00d7Rsatisfying the complete WHERE clause has been constructed (at block ).","However, there may be more than one full 7-tuple satisfying the complete WHERE clause of the join query. The algorithm  continues to search for any other possible tuples. At block , the tuple construction counter is decreased to t=6, so that all matching sets with tail t(M)<=5 can be reused (which are all matching sets). Thus, the tuple construction counter is t=6; r=5; and the iterator itpoints to the end of M. Using the attribute value r\u00b7z=21, from the old partial specialization \u0393=(R\u00b7z)+(R\u00b7z)<=596, which is also reused, the next partial specialization \u0393is computed. Substituting the attribute value r\u00b7z=21 into \u0393leads to: \u0393=21+(R\u00b7z)<=596, which is: \u0393=(R\u00b7z)<=155.","Similarly, the partial specialization \u0393is not False and since there are no matching sets to compute, the algorithm proceeds with increasing the counter t, as in step . Again, the tuple construction counter is increased to t=7 and iterator itpoints to 1\u2208M={1}. It should be noted that the matching set Mis also reused without being recomputed since t(M)=4, the matching set Mdepends exactly on (r=3, r=5, r=2, r=4), which did not change. The tuple construction counter is t=7; r=1; and the iterator itpoints to the end of M. Using the attribute value r\u00b7z=14, the partial specialization \u0393=\u0393(r) is computed. Substituting the attribute value r\u00b7z=14 into leads to: \u0393=14<=155, which makes: \u0393=False. This means that the algorithm reached t=7 for the second time, but \u0393=False implies that the second full 7-tuple (r=3, r=5, r=1, r=4, r=3, r=5, r=1) that satisfies all join conditions, does yet not satisfy the complete WHERE clause. Since the current iterator positions are: itpointing to the end of M; itpointing to the end of M; itpointing to the end of M; itpointing to the end of M; itpointing to the end of M; itpointing to the end of M; and itpointing to the end of M, no more 7-tuples can be created. In view of these iterator positions, the algorithm decreases from t=7 fully down to t=0, causing the algorithm to finally terminate. At this point, the already found 7-tuple (r=3, r=5, r=2, r=4, r=3, r=1, r=1) is in fact the only 7-tuple satisfying the complete WHERE clause.","It should be noted that in the example describing methods  and , in most cases the general relation MMwas satisfied by equality and that no matching set was ever encountered empty. This was due to the fact that the previous reduction of the full relations Rto the reduction results Mto was considered as \u201cperfect\u201d. This means that the reduction results Mto were as small as possible\u2014every Mequaled the projection of the solution of the join conditions alone to R. However, a perfect reduction is not possible for all join graphs and all distributions of data. In the current example, the failure of a partial tuple to complete to a full tuple was only caused by some partially specialized operator tree becoming False. However, in other embodiments this could also be caused by some matching set becoming empty.","The algorithm for join tuple assembly by partial specializations () handles the assembly phase of the method for join query evaluation by semijoin reduction. It improves it simultaneously with regard to time and space consumption. The algorithm is applicable to outer joins as well as to inner joins, since the differences in the evaluation procedure derived from the join type occur only in the reduction phase, which is before the join tuple assembly phase. Further, the algorithm does not require flattening the join graph into a tree in the reduction phase, by showing how to handle cycles in the assembly phase. In an embodiment, the algorithm is suitable for first-k queries and is applicable to pure join queries (\u0393=True). Moreover, algorithm  is not limited to the method of semi-join reduction: it can be used as a general method for evaluating any join query, as previous reductions accelerate the method, but are not a prerequisite; the algorithm stays correct if in place of Many set S with M=SRis taken. Finally, algorithm  is well suited to distributed computation. The row IDs in Mcan be distributed to distinct processors for possible completion to a join tuple; if |M| is too small for this distribution, the pairs of M\u00d7Mcan be distributed, and so on.","Some embodiments of the invention may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. Examples of computer readable storage media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (\u201cASICs\u201d), programmable logic devices (\u201cPLDs\u201d) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment of the invention may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment of the invention may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":"FIG. 9","b":["900","900","905","955","900","940","955","910","915","910","915","905","915","900","925","930","900","925","930","900","935","900","950","950","900","945","900","920","960","960","960","950","960"]},"A data source  is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a markup language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as, Open DataBase Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however that the invention can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.","Although the processes illustrated and described herein include series of steps, it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps, as some steps may occur in different orders, some concurrently with other steps apart from that shown and described herein. In addition, not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover, it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.","The above descriptions and illustrations of embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather, the scope of the invention is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments of the invention with particularity. The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2","b":"140"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3","b":"140"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4","sub":["1","2","3","4","5","6","7 "]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 8A and 8B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9","b":"900"}]},"DETDESC":[{},{}]}
