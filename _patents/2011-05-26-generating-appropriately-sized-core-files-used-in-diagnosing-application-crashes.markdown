---
title: Generating appropriately sized core files used in diagnosing application crashes
abstract: A method, system and computer program product for generating appropriately sized core files used in diagnosing application crashes. An instruction pointer corresponding to the instruction that led to the application crash is identified. Address ranges of the garbage collection module and the compiler module are obtained. A determination is made as to whether the address of the instruction pointer lies within any of these address ranges for each stack frame in a crash stack. If it does not, then read or write instructions executed prior to the instruction that led to the application crash are identified for each stack frame in the crash stack. If a value of a register involved in such read or write instructions is within the address range of the compiled code buffers and/or heap, then the compiled code buffers and/or heap need to be included in the core file; otherwise, they do not.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08607098&OS=08607098&RS=08607098
owner: International Business Machines Corporation
number: 08607098
owner_city: Armonk
owner_country: US
publication_date: 20110526
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to diagnosing application crashes, and more particularly to generating appropriately sized core files used in diagnosing application crashes.","In certain operating systems, the applications (i.e., processes) run in their own address space and any attempt made by an application to access address space that does not belong to the application (i.e., a memory-address violation) results in abnormal termination of the application. Abnormal termination of an application may also result from an illegal instruction, a bus error, or a user-generated quit signal. Upon the abnormal termination of an application, a device within the kernel of the operating system causes process state information to be written or \u201cdumped\u201d to a local permanent storage device. The file that is written to the local permanent storage device is typically named \u201ccore\u201d and is generally referred to as the \u201ccore file.\u201d The process of saving the core file to a local permanent storage device is often referred to as a \u201ccore dump\u201d or a \u201ccrash dump.\u201d","The core file may include information that may be used to diagnose the cause of the application crash. In the context of a Java\u00ae runtime environment, the core file may include the processor registers (e.g., program counter, stack pointer), processor and operating system flags, a list of loaded modules (along with information regarding where they are loaded) from the application as well as memory management information, which may include the Java\u00ae heap and the native heap. A Java\u00ae heap refers to the area of memory which contains all of the objects created by an application running on a Java\u00ae virtual machine. A \u201cnative heap,\u201d as used herein, refers to the area of memory which contains the code compiled by a compiler (e.g., Just-in-Time (JIT) compiler). The source code of a Java\u00ae program is compiled into an intermediate language called \u201cbytecode,\u201d which cannot run by itself. The bytecode is converted (interpreted) into machine code at runtime by a compiler, such as a JIT compiler. This native machine code may then be stored in the native heap.","The core file may be used to diagnose the cause of the application crash, especially in situations where the problem can be re-created only in the customer environment, where the crashes are due to object or memory corruption or when the interactive debugger cannot be used in the failing environment.","Due to the complexity in diagnosing the cause of an application crash, multiple core files may have to be collected. For example, a core file may have to be collected at every instance an application crashes in diagnosing corruption issues. In another example, a core file may have to be collected at various intervals of time when a memory leak occurs. A memory leak occurs when a program consumes memory but is unable to release it back to the operating system. If too many memory leaks occur, these memory leaks can usurp all of memory and bring everything to a halt or slow the processing considerably.","The difficulty in using these core files to analyze and diagnose application crashes is their considerable size. Core files may span anywhere from a few 100 megabytes to a few gigabytes. As a result, core files may be difficult to store or transfer to a diagnostics environment.","If unnecessary information (unnecessary in analyzing and diagnosing the application crash) in the core file could be filtered from the core file, then the core file could be more appropriately sized thereby enabling core files to be more easily stored or transferred to a diagnostic environment.","In one embodiment of the present invention, a method for generating an appropriately sized core file comprises obtaining an address range of compiled code buffers and\/or a heap. The method further comprises identifying one or more read or write instructions prior to an instruction that led to an application crash. Additionally, the method comprises generating a record indicating whether the compiled code buffers and\/or the heap need to be included in a core file in response to whether a value of a register involved in the one or more read or write instructions is within the address range of the compiled code buffers and\/or the heap. In addition, the method comprises generating, by a processor, the core file in response to the record.","Other forms of the embodiment of the method described above are in a system and in a computer program product.","The foregoing has outlined rather generally the features and technical advantages of one or more embodiments of the present invention in order that the detailed description of the present invention that follows may be better understood. Additional features and advantages of the present invention will be described hereinafter which may form the subject of the claims of the present invention.","The present invention comprises a method, system and computer program product for generating appropriately sized core files used in diagnosing application crashes. In one embodiment of the present invention, an instruction pointer corresponding to the instruction that led to the application crash is identified. Address ranges of various chunks of memory, such as the address ranges of the garbage collection module, the compiler module, the compiled code buffers and the heap, are obtained. A determination is then made as to whether the address of the instruction pointer lies within the address range of the garbage collection module or the compiler module for each stack frame in a crash stack (functions that were being executed at the point of the crash are encapsulated within a stack, referred to herein as the \u201ccrash stack\u201d). If so, then chunks of memory (e.g., compiled code buffers, heap) need to be included in the core file. Otherwise, one or more read or write instructions executed prior to the instruction that led to the application crash are identified for each stack frame in a crash stack to determine if the heap or compiled code buffers were accessed during the application crash. If a value of a register involved in such read or write instructions is within the address range of the compiled code buffers and\/or heap, then the compiled code buffers and\/or heap need to be included in the core file; otherwise, they do not. The information as to which chunks of memory, if any, need to be included in the core file is provided in a record which is sent to a module in the operating system to generate the appropriately sized core file. In this manner, chunks of memory that are not necessary in diagnosing an application crash may be excluded from the core file thereby generating a more appropriately sized core file which can be more easily stored or transferred to a diagnostic environment.","While the following discusses the present invention in connection with a Java\u00ae runtime environment, the principles of the present invention may be applied to any managed runtime environment, such as Microsoft's\u00ae Common Language Runtime (CLR) platform and Intel's\u00ae open runtime platform. A person of ordinary skill in the art would be capable of applying the principles of the present invention to such implementations. Further, embodiments applying the principles of the present invention to such implementations would fall within the scope of the present invention.","In the following description, numerous specific details are set forth to provide a thorough understanding of the present invention. However, it will be apparent to those skilled in the art that the present invention may be practiced without such specific details. In other instances, well-known circuits have been shown in block diagram form in order not to obscure the present invention in unnecessary detail. For the most part, details considering timing considerations and the like have been omitted inasmuch as such details are not necessary to obtain a complete understanding of the present invention and are within the skills of persons of ordinary skill in the relevant art.","Referring now to the Figures in detail,  illustrates a hardware configuration of a computer system  which is representative of a hardware environment for practicing the present invention. Referring to , computer system  has a processor  coupled to various other components by system bus . An operating system  runs on processor  and provides control and coordinates the functions of the various components of . An application  in accordance with the principles of the present invention runs in conjunction with operating system  and provides calls to operating system  where the calls implement the various functions or services to be performed by application . Application  may include, for example, an application for generating appropriately sized core files used in diagnosing application crashes as discussed further below in association with FIGS.  and A-B.","Referring again to , read-only memory (\u201cROM\u201d)  is coupled to system bus  and includes a basic input\/output system (\u201cBIOS\u201d) that controls certain basic functions of computer device . Random access memory (\u201cRAM\u201d)  and disk adapter  are also coupled to system bus . It should be noted that software components including operating system  and application  may be loaded into RAM , which may be computer system's  main memory for execution. Disk adapter  may be an integrated drive electronics (\u201cIDE\u201d) adapter that communicates with a disk unit , e.g., disk drive. It is noted that the program for generating appropriately sized core files used in diagnosing application crashes, as discussed further below in association with FIGS.  and A-B, may reside in disk unit  or in application .","Computer system  may further include a communications adapter  coupled to bus . Communications adapter  interconnects bus  with an outside network thereby enabling computer system  to communicate with other similar devices.","I\/O devices may also be connected to computer system  via a user interface adapter  and a display adapter . Keyboard , mouse  and speaker  may all be interconnected to bus  through user interface adapter . Data may be inputted to computer system  through any of these devices. A display monitor  may be connected to system bus  by display adapter . In this manner, a user is capable of inputting to computer system  through keyboard  or mouse  and receiving output from computer system  via display  or speaker .","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u2018module\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or flash memory), a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the C programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention are described below with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the present invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to product a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the function\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the function\/acts specified in the flowchart and\/or block diagram block or blocks.","As stated in the Background section, the core file may be used to diagnose the cause of the application crash, especially in situations where the problem can be re-created only in the customer environment, where the crashes are due to object or memory corruption or when the interactive debugger cannot be used in the failing environment. Due to the complexity in diagnosing the cause of an application crash, multiple core files may have to be collected. For example, a core file may have to be collected at every instance an application crashes in diagnosing corruption issues. In another example, a core file may have to be collected at various intervals of time when a memory leak occurs. A memory leak occurs when a program consumes memory but is unable to release it back to the operating system. If too many memory leaks occur, these memory leaks can usurp all of memory and bring everything to a halt or slow the processing considerably. The difficulty in using these core files to analyze and diagnose application crashes is their considerable size. Core files may span anywhere from a few 100 megabytes to a few gigabytes. As a result, core files may be difficult to store or transfer to a diagnostics environment. If unnecessary information (unnecessary in analyzing and diagnosing the application crash) in the core file could be filtered from the core file, then the core file could be more appropriately sized thereby enabling core files to be more easily stored or transferred to a diagnostic environment.","The principles of the present invention provide a means for generating appropriately sized core files that can be more easily stored or transferred to a diagnostic environment by not including chunks of memory (e.g., heap, compiled code buffers) in the core file when they are not necessary or pertinent for diagnosing the cause of an application crash as discussed below in connection with FIGS.  and A-B.  is a stack model of the software components used in generating appropriately sized core files used in diagnosing application crashes.  are a flowchart of a method for generating appropriately sized core files used in diagnosing application crashes.","As stated above,  is a stack model of the software components used in generating appropriately sized core files used in diagnosing application crashes in accordance with an embodiment of the present invention.","Referring to , in conjunction with , application  (e.g., Java\u00ae application) can call at runtime a Java\u00ae class library , which is a set of dynamically loadable libraries. Java\u00ae class library  runs on a virtual machine , such as a Java\u00ae Virtual Machine (\u201cJVM\u201d). JVM  is one software application that may execute in conjunction with operating system . JVM  provides a Java\u00ae run-time environment with the ability to execute a Java\u00ae application or applet, which is a program, servlet, or software component written in the Java\u00ae programming language.","JVM  is a virtual computer component that executes Java\u00ae programs . Java\u00ae programs  are not run directly by the central processor (e.g., processor  of ) but instead by JVM , which is itself a piece of software running on the processor. JVM  allows Java\u00ae programs to be executed on different platforms, as opposed to only the one platform for which the code was compiled. Java\u00ae programs are compiled for JVM . In this manner, Java\u00ae is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating system architectures. To enable a Java\u00ae application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format (i.e., the compiled code is executable on many processors, given the presence of the Java\u00ae run-time system). The Java\u00ae compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java\u00ae compiler and executed by a Java\u00ae interpreter . Java\u00ae interpreter  is part of JVM  that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Bytecodes may be translated into native code by a Just-In-Time (JIT) compiler .","JVM  loads class files and executes the bytecodes within them. JVM  contains a class loader , which loads class files from an application and the class files from the Java\u00ae application programming interfaces (APIs) which are needed by the application.","One type of software-based execution engine is JIT compiler . With this type of execution, the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for just-in-time compiling a method. The native machine code for the method is then cached in what is referred to herein as \u201cJIT compiled code buffers,\u201d (discussed further below) and reused upon the next invocation of the method.","Interpreting code provides an additional benefit. Rather than instrumenting the Java\u00ae source code, interpreter  may be instrumented. Trace data may be generated via selected events and timers through the instrumented interpreter  without modifying the source code.","When an application  is executed on JVM , a Java\u00ae application may interact with the host operating system  by involving native methods. A Java\u00ae method is written in the Java\u00ae language, compiled to bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.","Referring again to , JVM  further includes runtime data areas . Runtime data areas  contain Java\u00ae stacks , Program Counter (PC) registers , native method stacks , JIT compiled code buffers , a Java\u00ae heap  and memory management . These different data areas represent the organization of memory needed by JVM  to execute a program.","Java\u00ae stacks  are used to store the state of Java\u00ae method invocations. When a new thread is launched, JVM  creates a new Java\u00ae stack for the thread. JVM  performs only two operations directly on Java stacks : it pushes and pops frames. A thread's Java\u00ae stack stores the state of Java\u00ae method invocations for the thread. The state of a Java\u00ae method invocation includes its local variables, the parameters with which it was invoked, its return value, if any, and intermediate calculations. Java\u00ae stacks are composed of stack frames. A stack frame contains the state of a single Java\u00ae method invocation. When a thread invokes a method, JVM  pushes a new frame onto the Java\u00ae stack of the thread. When the method completes, JVM  pops the frame for that method and discards it. JVM  does not have any registers for holding intermediate values; any Java\u00ae instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner, the Java\u00ae instruction set is well defined for a variety of platform architectures.","PC registers  are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register (program counter) and Java\u00ae stack. If the thread is executing a JVM method, the value of the PC register indicates the next instruction to execute. If the thread is executing a native method, then the contents of the PC register are undefined.","Native method stacks  store the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some JVM implementations, native method stacks  and Java\u00ae stacks  are combined.","As discussed above, bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for just-in-time compiling a method. The native machine code for the method is then cached in JIT compiled code buffers .","Java\u00ae heap  contains all instantiated objects. Each time a class instance or array is created, the memory for the new object is allocated from heap . JVM  includes an instruction that allocates memory space within the memory for heap  but includes no instruction for freeing that space within the memory. Memory management  in the depicted example manages memory space within the memory allocated to heap . Memory management  may include a \u201cgarbage collector,\u201d which automatically reclaims memory used by objects that are no longer referenced. Additionally, a garbage collector also may move objects to reduce heap fragmentation.","Additionally, JVM  includes what is referred to herein as the \u201cmemory filter module\u201d , which is configured to determine if chunks of memory, such as heap  and JIT compiled code buffers , are not needed to be included in the core file for diagnosing the cause of an application crash thereby minimizing the size of the core file so as to make the core file more easily stored or transferred to a diagnostic environment. A more detail description of the functionality of memory filter module  is discussed below in connection with .","The software components further include a component referred to herein as the \u201ccore file generating module\u201d  within operating system . Core file generating module  is configured to receive a record from memory filter module  that includes an indication as to whether the core file needs to include chunks of memory, such as heap  and JIT compiled code buffers . Upon receipt of this record, core file generating module  generates an appropriately sized core file. A more detail description of the functionality of core file generating module  is discussed below in connection with .","As stated above,  are a flowchart of a method  for generating appropriately sized core files used in diagnosing application crashes in accordance with an embodiment of the present invention.","Referring to , in conjunction with , in step , memory filter module  receives a segmentation violation indication. In one embodiment, the Java\u00ae runtime environment installs a handler to handle the segmentation violation. An application crash may generate a segmentation violation which occurs when a program attempts to access a memory location that is not allowed to access or attempts to access a memory location in a way that is not allowed. When the crash occurs, typically a thread within the application is executing a set of method calls. The executing thread which led to the crash is referred to herein as the \u201ccrash thread.\u201d The functions that were being executed by the crash thread at the point of the crash are encapsulated within a stack, referred to herein as the \u201ccrash stack.\u201d The crash stack includes multiple stack frames, where each stack frame represents an individual method call that invokes a method above it and is invoked by the method below it. Each stack frame includes instructions which are used for the actual execution.","In step , memory filter module  identifies the instruction pointer at the top of the stack method (method at the top of the crash stack) corresponding to the address of the instruction that led to the application crash.","In step , memory filter module  obtains the contents of the registers involved in the instruction that led to the application crash.","In step , memory filter module  obtains the address range of the garbage collection module, which refers to the module for controlling the runtime garbage collector.","In step , memory filter module  obtains the address range of the compiler module of JVM . The compiler module refers to the module for controlling the JIT compiler .","In step , memory filter module  obtains the address range of the JIT compiled code range, referring to the address range of the JIT compiled code buffers .","In step , memory filter module  obtains the address range of heap .","In step , memory filter module  determines if the address of the instruction pointer lies within the address range of the garbage collection module (obtained in step ) or of the compiler module of JVM  (obtained in step ).","If the address of the instruction pointer lies within either the address range of the garbage collection module or the compiler module of JVM , then, in step , memory filter module  generates a record to be sent to core file generating module  indicating that JIT compiled code buffers  and heap  need to be included the core file.","If, however, the address of the instruction pointer does not lie within the address range of the garbage collection module or of the compiler module of JVM , then, in step , a determination is made by memory filter module  as to whether there are any more stack frames within the crash stack to be evaluated. If so, then, in step , memory filter module  identifies the instruction pointer of the last invoked instruction for the next stack frame in the crash stack.","Upon identifying the instruction pointer of the last invoked instruction for the next stack frame in the crash stack, memory filter module  determines if the address of this instruction pointer lies within the address range of the garbage collection module (obtained in step ) or of the compiler module of JVM  (obtained in step ) in step .","If, however, there are no more stack frames of the crash stack to be evaluated, then, referring to , in conjunction with , in step , memory filter module  identifies one or more read or write executed instructions at the top of the stack method that were executed prior to the instruction that led to the application crash to be analyzed in connection with the address ranges of JIT compiled code  and heap . In this manner, a determination can be made as to whether the contents of any of the registers that are being used by these instructions are in the JIT compiled code buffers  or in heap . If so, then JIT compiled code buffers  and\/or heap  need to be retained in the core file. Otherwise, JIT compiled code buffers  and heap  do not need to be included in the core file.","In one embodiment, Java\u00ae stacks  is a call stack where the caller pushes the return address onto the stack and the called subroutine, when it finishes, pops the return address off the call stack and transfers control to that address. If a called subroutine calls on to yet another subroutine, it will push another return address onto the call stack, and so on, with the information stacking up and unstacking as the program dictates. Adding a subroutine's entry to the call stack is referred to as \u201cwinding;\u201d conversely, removing entries is referred to as \u201cunwinding.\u201d","As a result, every unwinding may be tracked where each read and write operation in connection with the unwinding is analyzed against the address range of JIT compiled code buffers  and heap  to determine if JIT compiled code buffers  and\/or heap  need to be included in the core file. Any number of frames (a stack frame contains the state of a single Java\u00ae method invocation) may be unwound where each read and write operation in connection with the unwinding is analyzed against the address ranges of JIT compiled code buffers  and heap  to determine if JIT compiled code buffers  and\/or heap  were accessed during the context in which the application crash occurred thereby determining if JIT compiled code buffers  and\/or heap  need to be included in the core file.","If the value(s) of the register contents involved in the read or write instruction(s) that are identified in step  are not within the address range of JIT compiled code buffers  or heap , then JIT compiled code buffers  and heap  do not need to be included in the core file. Otherwise, if the value(s) of the contents involved in the read or write instruction(s) that are identified in step  are within the address range of JIT compiled code buffers , then the JIT compiled code buffers  need to be included in the core file. Furthermore, if the value(s) of the contents involved in the read or write instruction(s) that are identified in step  are within the address range of heap , then heap  needs to be included in the core file.","For example, a sample trace from Java stacks  showing the instructions that led up to the instruction causing the application crash is shown as follows:",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Register Contents"},{"entry":"RDI: 0000003C3072E8C0"},{"entry":"RBX: FFFFFFFFBD0008F0"},{"entry":"(gdb) x\/20i 0x0000002abd10cd00"},{"entry":"0x2abd10cd00 <NET_IsBlocked>: push %rbp"},{"entry":"0x2abd10cd01 <NET_IsBlocked+1>: mov %rsp,%rbp << STACK"},{"entry":"WRITE : No Need to Track! Move stack pointer to base pointer"},{"entry":"0x2abd10cd04 <NET_IsBlocked+4> : push %rbx"},{"entry":"0x2abd10cd05 <NET_IsBlocked+5> : mov %rdi,%rbx << DATA"},{"entry":"WRITE : Move the contents of rdi to rbx"},{"entry":"RDI at this point has the value 0000003C3072E8C0 which is not in the"},{"entry":"Java Heap Range (2a9a530000 -2aaa530000) and not in the Java Compiled"},{"entry":"Code Range (2abb3e4000 - 2abbde4000)"},{"entry":"0x2abd10cd08 <NET_IsBlocked+8>: lea 22208(%rip),%rdi #"},{"entry":"0x2abd1123cf"},{"entry":"<opts.0+1199>"},{"entry":"0x2abd10cd0f <NET_IsBlocked+15>: sub $0x8,%rsp << Updating Stack"},{"entry":"pointer"},{"entry":"0x2abd10cd13 <NET_IsBlocked+19>: callq 0x2abd1043a8"},{"entry":"<NET_Bind@plt+144> << Calling Net_Bind function"},{"entry":"0x2abd10cd18 <NET_IsBlocked+24>: test %rbx,%rbx << Testing the"},{"entry":"value of RBX, which points to an inaccessible address"},{"entry":"0x2abd10cd1b <NET_IsBlocked+27>: je 0x2abd10cd23"},{"entry":"<NET_IsBlocked+35>"},{"entry":"0x2abd10cd1d <NET_IsBlocked+29>: cmpl $0x2,0x8(%rbx) << Crashes"},{"entry":"here"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As illustrated, the instruction \u201c0x2abd10cd05<NET_IsBlocked+5>: mov % rdi,% rbx\u201d is a write instruction where the contents of register RDI is not within the address range of heap  (2a9a530000-2aaa530000). Neither are the contents of register RDI within the address range of the JIT compiled code buffers (2abb3e4000-2abbde4000). This instruction occurs prior to the instruction \u201c0x2abd10cd1d <NET_IsBlocked+29>: cmpl $0x2,0x8(% rbx)\u201d where the crash occurred.","In step , memory filter module  determines if the value(s) of the register contents involved in the read or write instruction(s) are within the address range of either JIT compiled code buffers  or heap . If the value(s) of the register contents involved in the read or write instruction(s) that are identified in step  are within either the address range of JIT compiled code buffers  and\/or heap , then, in step , memory filter module  keeps track of whether JIT compiled code buffers  and\/or heap  need to be included in the core file. For example, if the value(s) of the register contents involved in the read or write instruction(s) that are identified in step  are within the address range of JIT compiled code buffers , then JIT compiled code buffers  need to be included in the core file. If the value(s) of the register contents involved in the read or write instruction(s) that are identified in step  are within the address range of heap , then heap  needs to be included in the core file.","Upon executing step , or if the value(s) of the register contents involved in the read or write instruction(s) that are identified in step  are not within the address range of JIT compiled code buffers  or heap , then, in step , a determination is made by memory filter module  as to whether there are any more stack frames within the crash stack to be evaluated. If so, then, in step , memory filter module  identifies one or more read or write instructions that were executed prior to the instruction that led to the application crash for the next stack frame in the crash stack.","Upon identifying the one or more read or write instructions that were executed prior to the instruction that led to the application crash for the next stack frame in the crash stack, memory filter module  determines if the value(s) of the register contents involved in the read or write instruction(s) are within the address range of either JIT compiled code buffers  or heap  in step .","If, however, there are no more stack frames of the crash stack to be evaluated, then, in step , memory filter module  generates a record to be sent to core file generating module  indicating whether JIT compiled code buffers  and\/or heap  need to be included in the core file.","Upon memory filter module  providing the information to core file generating module  as discussed above in steps  and , core file generating module , in step , generates the appropriately sized core file based on the received information from memory filter module . Such information may allow core file generating module  to not include chunks of memory, such as heap  and JIT compiled code buffers , that are not needed to be included in the core file for diagnosing the cause of an application crash thereby minimizing the size of the core file so as to make the core file more easily stored or transferred to a diagnostic environment.","In some implementations, method  may include other and\/or additional steps that, for clarity, are not depicted. Further, in some implementations, method  may be executed in a different order presented and that the order presented in the discussion of  is illustrative. Additionally, in some implementations, certain steps in method  may be executed in a substantially simultaneous manner or may be omitted.","Although the method, system and computer program product are described in connection with several embodiments, it is not intended to be limited to the specific forms set forth herein, but on the contrary, it is intended to cover such alternatives, modifications and equivalents, as can be reasonably included within the spirit and scope of the invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained when the following detailed description is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 3A-3B"}]},"DETDESC":[{},{}]}
