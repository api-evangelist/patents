---
title: System and method for state-based profiling of multiprocessor systems
abstract: The present application describes a system and method of profiling a computer system based on a profiling state machine. The profiling state machine defines various states in which the system data can be collected for a particular application. The state machine allows system data collection regardless of timing intervals or event counters. When a state is identified for system data collection, the profiler application collects system data for the user. A profiling application driver monitors the state machine and manages the data collection based on the state machine. The profiling application driver controls the profiling configurations thus allowing a correlated data collection for timing intervals and event counter.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07305663&OS=07305663&RS=07305663
owner: Advanced Micro Devices, Inc.
number: 07305663
owner_city: Sunnyvale
owner_country: US
publication_date: 20021218
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DESCRIPTION OF THE PREFERRED EMBODIMENT(S)"],"p":["1. Field of the Invention","The present application relates to computer system profiling and more specifically to profiling application codes executed in the computer system.","2. Description of the Related Art","Generally, system profiling applications on a computer system allow users to collect data regarding various elements of the computer system at different execution stages of an application code. Typically, users collect system data to determine the performance of the application code. The system data can include states of different components (e.g., various registers, internal states of processors, selected memory locations, various controllers and the like) at various data collection points in the application code. The data collection is typically driven by timer or performance\/event counters. The user can specify a timing interval and\/or identify a number of selected events for which the profiling application can collect system data.","When specified timing interval or number of identified events occur, interrupts are generated and the interrupt service routines collect system data. The interrupts are generated based on the timing interval and\/or event counters. After the data is collected, the user can correlate the data collected based on the timing intervals with the data collected based on the event counters. In a multiprocessing system, where many processors run independently, it is difficult to determine the exact timing interval when a specified number of events may occur. Thus, to profile a computer system, the user has to ran many cycles of data collection to be able to correlate data collected based on timing intervals with the data collected based on event counters. A system and method is needed to efficiently profile a computer system.","The present application describes a system and method of profiling a computer system based on a profiling state machine. The profiling state machine defines various states in which the system data can be collected for a particular application. The state machine allows system data collection regardless of timing intervals or event counters. When a state is identified for system data collection, the profiler application collects system data for the user. A profiling application driver monitors the state machine and manages the data collection based on the state machine. The profiling application driver controls the profiling configurations thus allowing a correlated data collection for timing intervals and event counters.","In some embodiments, the present invention describes a state machine in connection with computer system profiling. The state machine includes a set of state variables representing one or more profiling behaviors of one or more profiling applications; and a set of profiling objects, wherein each one of the profiling objects representing one or more profiling events causing a transition in association of the one or more profiling application from a first state variable to a second state variable. In some variations, the profiling object represents configuration of at least one profiling session for the profiling application.","In some embodiments, the profiling objects represent at least one of a predetermined profiling application event, a timing event and an input from a user. In some variations, the predetermined profiling application event includes execution of one or more elements of the profiling application for a predetermined number. In some variations, the timing event includes a predetermined execution timing interval of one or more elements of the profiling application. In some embodiments, the state machine is embodied in a software driver in the computer system.","In some embodiments, the present invention describes a method in connection with profiling on a computer system. In some variations, the method includes configuring one or more profiling objects for at least one profiling application, wherein the profiling application associating with at least one state variable representing a behavior of the profiling application in a profiling state machine. In some variations, the profiling objects cause a transition in the association of the profiling application from a first state variable to a second state variable. In some embodiments, the configuring the profiling objects represents configuration of at least one profiling session for the profiling application.","In some variations, the profiling objects represent at least one of a predetermined profiling application event, a timing event and an input from a user. In some variations, the predetermined profiling application event includes execution of one or more elements of the profiling application for a predetermined number. In some variations, the timing event includes a predetermined execution timing interval of one or more elements of the profiling application. In some embodiments, the method includes collecting data representing a profile of the computer system incident with a first event represented by the profiling object. In some variations, the method includes pausing the collection of data incident with a second event represented by the profiling object; and resuming the collection of data incident with a third event represented by the profiling object. In some variations, the method includes stopping the collection of data incident with a fourth event represented by the profiling object. In some variations, the method includes storing the collected data.","The foregoing is a summary and thus contains, by necessity, simplifications, generalizations and omissions of detail. Consequently, those skilled in the art will appreciate that the foregoing summary is illustrative only and that it is not intended to be in any way limiting of the invention. Other aspects, inventive features, and advantages of the present invention, as defined solely by the claims, may be apparent from the detailed description set forth below.","The use of the same reference symbols in different drawings indicates similar or identical items.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":"100"},"The software environment of computer system  includes an operating system . Operating system  can facilitate the execution of multiple user applications ()-(). When user applications are initiated, the corresponding application codes ()-() are executed. A user can run profiling applications ()-() to profile computer system  during the execution of corresponding application code. The profiling applications ()-() collect data, at specified instances of application code execution, about system elements (e.g., status of the hardware and software or the like) during the execution of the application code. The system data can help a user determine the code execution efficiency of the corresponding application.","Generally, the access to system elements (e.g., hardware registers, software pointers or the like) is secured to protect system integrity so the user applications do not directly access the protected elements of the system. Typically, the software applications execute calls to a system driver, driver , to access system hardware . When a user initiates an application, for example application (), the corresponding application code, for example application code () is executed. The user can execute a profiling application, for example profiling application (), to collect system data while application code () is executing.","The user can execute application code () on various processors in a multiprocessing system to determine the performance of application code (). The user can also execute various portions of application code () on various different processors in the system. However, to collect system data, the user can configure a profiling application, for example profiling application () to collect system data during various stages of the execution of application code (). Traditionally, profiling application () can collect system data based on timing, (e.g., at predetermined timing intervals or the like) or event based (e.g., at every predetermined number of predefined events or the like) and execute calls to driver  to program data collection.","When multiple profiling applications execute in a system then multiple data collection criteria can be configured and driver  can collect data for each profiling application according to the configured criteria. However, traditionally, the timing and event based data is collected independently which requires correlation for analysis purposes. According to an embodiment of the present invention, driver  collects system data based on a profiling state machine. The profiling state machine allows a user to configure the profiling of the system during application code execution using timing and event based triggering for data collection. The profiling state machine facilitates correlated system profiling to determine the efficiency of the application code.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","200","140"]},"The computer system begins in a state of \u2018not configured\u2019 (). In \u2018not configured\u2019 state, the driver (e.g., driver  or the like) can block any profiling attempt by a profiling application. Traditionally, a user application can set profiling event (e.g., setting a timer interval, event counter or the like) to start collecting profiling data at any time regardless of the state of the computer system. For example, in a multiprocessor computer system, one or more processors may not be ready to collect data because of the state of the processor such as, reconfiguration (e.g., re-boot, re-initialize or the like), resource constraints mode (e.g., not enough processing capability, storage, or the like) and the like. Attempting to collect profiling data under these circumstances can severely affect the performance of the computer system.","Thus initializing the system environment in a \u2018not configured\u2019 state not only requires a user application to configure the profiling session but also allows the computer system to be prepared for the profiling configuration. The user application can initialize the system for profiling by configuring the profiling parameters (e.g., events, timer intervals, type of data to be collected, devices to monitor or the like) for more than one processor. For example, the user application can execute different portions of a program on different processors. The state machine can allow profiling data collection for various different processors thus enabling the user application to determine the information regarding the code execution on different processors.","When a user application (e.g., user application  or the like) configures the system for profiling, the profiling state machine transitions from \u2018not configured\u2019 state to \u2018configured\u2019 state (). A user application can be any application configured to be executed on the computer system (e.g., word processing, games, video or the like). The profiling configuration can be determined according to the system and software architecture. For example, some of the transitioning conditions (objects) can be for the user application to provide the name of a disk file to store the profiled data, identify specific events and\/or timing intervals to initiate profiling when in profiling state, timer resolution, or the like. When a user application configures the profiling parameters, then the profiling state can transition from \u2018not configured\u2019 to \u2018configured\u2019.","When the profiling state machine is executed by a system driver (e.g., driver  or the like) then the driver can verify the profiling configuration parameters before beginning the profiling. One skilled in the art will appreciate that the profiling conditions (objects that cause state transition) can be implementation specific. For example, a particular system requirement can be to program certain predetermined parameters (e.g., data file name, devices to monitor, type\/amount of data to collect or the like) before a profiling can begin. However, after programming the required parameters, additional optional application specific parameters can also be configured (e.g., data block size in the memory, data file size, specific memory locations for data storage or the like).","The profiling configuration can be programmed using profiling parameters provided by the user. One skilled in the art will appreciate that the configuration information can be provided using various programming methods (e.g., manual data input, program driven configuration, application instrumentation, or combination thereof or the like). When appropriate configuration information is inputted in the profiling application (e.g., using manual programming, pre-programmed software scripts or combination thereof or the like), the configuration information can be used by driver routines to initialize system parameters (e.g., set timers, counters or the like). The \u2018not configured\u2019 state of the computer system requires a user application to follow predetermined configuration sequences (e.g., configuring required profiling parameters or the like) required to profile the system. When the profiling state machine transitions to \u2018configured\u2019 state, the system can be ready for profiling.","In the present example, the system exits from \u2018configured\u2019 state by transitioning to the state of \u2018profiling\u2019 (). The state transition can occur when one or more profiling criteria (objects) are established. For example, when one or more profiling criteria are met (e.g., number of predetermined events occur, predetermined timing interval or the like) an interrupt can be generated and the associated interrupt service routine can start collecting system data. The data to be collected by the interrupt service routine can be predetermined during the configuration state. A user can identify specific information to collect about the application code that is being executed. For example the interrupted code segments of the application code, interrupted instruction pointers, process and thread identifications, time stamp counter value at interrupt, the processor that got interrupted, the source of the interrupt (e.g., timer, event or the like) and the like or combination thereof.","The type of data collected can depend upon specific profiling requirement of the application code. For example, when a user application desires to identify the resources used during the execution of a specific portion or element of an application code (e.g., code writing data to memory, code opening\/closing internet sessions, coded transferring data to network, code managing internet requests or the like) then the user application can identify the states of all the system resources during the execution of that specific portion of the application code. Further, by profiling the system using profiling state machine , the profiling data can be collected based on timing intervals and the number of predetermined events (e.g., cache misses, data access or the like). As long as the system stays in the state of \u2018profiling\u2019 the required data can be collected according to the profiling configuration.","The data collected can be stored in local storage (e.g., associated memory or the like) or can be transferred to peripheral storage (e.g., magnetic\/optical storage, transferred to remote location or the like). The memory management and storage schemes of the computer system can determine the processing (e.g., transfer from one storage to another or the like) of the profiling data.","The profiling can be executed in the background while the user application executes on the system. The profiling information can be used to determine the processor(s) spending most of its time executing the user application code. One skilled in the art will appreciate that the profiling can be done without any user application. In such case, the operating system can be profiled.","In the present example, the state of \u2018profiling\u2019 has two exit points, one to transition to a state of \u2018paused\u2019 () or a transition to a state of \u2018stopped\u2019 (). The user application (e.g., user application ) can pause the data collection by transitioning to the \u2018paused\u2019 state. In the \u2018paused\u2019 state, the system maintains configuration information for profiling as initially configured by the user application. The data file for the collected data remains open and the profiling data is maintained in the appropriate storage. The transition from the \u2018paused\u2019 state can be either to the state of \u2018profiling\u2019 to resume data collection or to the state of \u2018stopped\u2019 ().","During the application code development, the target application code can be configured (e.g., using application programming interfaces or the like) by the developer of that application to assist profiling the function of the application. For example, a developer of a web server application may configure that application to \u201cresume\u201d the profiling when a web request is received across the network, and \u201cpause\u201d the profiling when the processing of that request is completed. In this manner, a profile taken over a period of time will only show the data of relevance to that application and will not contain profile data of large parts of system inactivity not related to the web server application.","The transition to \u2018paused\u2019 state and return can be determined initially during the configuration or can be dynamically enforced upon predetermined events. For example, a user can manually enforce \u2018paused\u2019 state by executing a system command, pressing a predefined key or the like. Similarly, the profiling application can execute commands to force the driver (e.g., driver  or the like) to enter into \u2018paused\u2019 state and perform predetermined actions (e.g., display certain data, transfer data, update profiling parameters or combination thereof or the like). When the user application forces the driver (e.g., driver  or the like) to transition to the state of \u2018profiling\u2019 from the \u2018paused\u2019 state, the data collection can begin immediately or upon next profiling event (e.g., timing interval, event counter or the like) according to the profiling configuration.","When the profiling state  machine transitions to \u2018stopped\u2019 state, the collection of profiling data stops and open files for collected data are closed and the profiling session end. The system returns to \u2018not configured\u2019 state so the user application can configure the profiling system for the next profiling session. One skilled in the art will appreciate that while for purposes of illustration, particular transitions from one state to another are shown, the state machine can be configured to transition to any state as required by the application. For example, the state machine can return to \u2018configured\u2019 state from the \u2018stopped\u2019 state to use the same configuration as the previous session. Similarly, for fault tolerance purpose, each state can be configured to return to the \u2018configured\u2019 or \u2018not configured\u2019 state to allow flexibility of profiling.","The states can be tracked using any state machine implementation known in the art. In some embodiments of the present invention, each state shown in  is implemented by a driver routine. The states are assigned a unique value, in a state variable, represented by different bit position settings for each state. The state variable defined in the driver stores the current state of the profiler. Before transitioning to another state, the current state is checked to determine whether the new state is valid and allowable. If validated, the transition occurs and the state variable is updated to reflect the new state. For example, if an application attempts to initiate profiling by requesting the driver to start profiling without configuring\/initializing the driver then the driver will terminate the request for profiling because the appropriate state was not set (e.g., respective bits were not set in the state variable or the like).","Various triggering conditions can be defined for profiling. For purposes of illustrations, in the present example, two profiler types, event-based profile (EBP) and timer-based profile (TBP) are used. To differentiate these two types, a bit position can be defined in the state variable for each profile type. Following is an example of bit positions defined for each state and profile type according to an embodiment of the present invention:","#define STATE_CONFIGURED_EBP 0x0010","#define STATE_CONFIGURED_TBP 0x0020","#define STATE_PROFILING_EBP 0x1000","#define STATE_PROFILING_TBP 0x2000","#define STATE_PAUSED_EBP 0x4000","#define STATE_PAUSED_TBP 0x8000","Each state is defined using the particular type of profiling (e.g., event or timer based or the like). The state machine can be configured using the exemplary representation of each state. Following is an example of pseudo code for state machine implementation according to an embodiment of the present invention. One skilled in the art will appreciate the exemplary implementation of the state machine using exemplary state definitions is for illustrative purpose only and that the state machines can be implemented based on application specific requirements and variable definitions.","SetEventProperties\n\n","StartProfiler\n\n","StopProfiler\n\n",{"@attributes":{"id":"p-0043","num":"0073"},"figref":"FIG. 3"},"Initially, the system environment begins in a \u2018not configured\u2019 state and the user configures the profiling session (). As stated herein, the profiling session can be configured using various programming methods for example, a user can manually configure the profiling parameters, a software script can provide pre-programmed configuration parameters, or the information can be provided by application instrumentation, or combination thereof or the like. The profiling sessions can be initiated by executing appropriate profiling driver routines to program profiling parameters.","When the profiling environment in the system is configured, the profiling state transitions to \u2018configured\u2019 and begins monitoring appropriate profiling parameters. The profiling drivers determine whether a triggering event has occurred (). The triggering event can be an occurrence of any configured event. For example, the configuration can require the profiling application to collect predetermined data based on timing intervals (e.g., the execution of a specified portion of the application code every 10 milliseconds or the like) or certain event counts (e.g., every tenth cache miss or the like). One skilled in the art will appreciate that the profiling parameters can be set based on the analysis of the application code that is being executed and profiled. If the triggering event does not occur, the profiling application continues to monitor the configured profiling parameters to determine the triggering.","When a triggering event occurs, the state machine transitions to \u2018profiling\u2019 state and system profiling data collection begins (). As stated herein, the profiling data collection can be paused for various reasons (e.g., to prevent cluttering the profile data with uninteresting records at a time when the system is not performing any activity of interest, typically under control of the user application or the like). The profiling application monitors the pausing events (). If a pausing event does not occur, the profiling application determines whether the data collection has completed based on the predetermined criteria (). If the data collection has not completed, the profiling application continues to collect data (). One skilled in the art will appreciate that the determination of the completion of data collection can be made as configured by the user. For example, the profiling application can be configured to collect certain amount of data during the \u2018profiling\u2019 state and stop collecting data even when the triggering events are still valid. In such case, when the required amount of data is not collected, the profiling application continues to collect the data instead of proceeding to monitor the next triggering event.","If the data collection has completed, the profiling state machine transitions to \u2018stopped\u2019 state and finalizes the data collection (). The finalizing of the data collection can include various profiling related close-up events. For example, the profiling application can transfer collected data from temporary storage to identified storage devices, closing any open files, releasing resources or the like.","While for purposes of illustration, in the present example a \u2018pause\u2019 event is described (), one skilled in the art will appreciate that the profiling application does not need to determine the pausing event during the data collection. The pausing event can be a manual event (e.g., pressing of a key or the like) which may not require a continuous monitoring. The determination of pausing event does not need to be a separate event from profiling. For example, the pausing event can be any interrupt (e.g., manual, software driven, execution of a break point in the code or the like) during the profiling or any predetermined event in the profiling application (e.g., collection of a predetermined amount of data, expiration of internal timers or the like). In such cases, the pause step can be interrupt driven and may not require monitoring as described herein.","When a pausing event occurs (e.g., user manually pauses the data collection, a predetermined event triggers pausing or the like) the profiling state machine transitions to \u2018paused\u2019 state and determines whether to transition out of the \u2018paused\u2019 state (). The exit from the \u2018paused\u2019 state can be determined during the configuration. For example, if the profiling application is paused using a manual event (e.g., pressing a key or the like) then the transition can occur upon an occurrence of certain pre-determined events (e.g., pressing another key, expiration of a predetermined timer or the like). The profiling state machine  stays in the \u2018paused\u2019 state until the predetermined transitional event occurs.","One skilled in the art will appreciate that the application code for profiling can be configured to allow user intervention for analysis purpose. For example, an application can be configured to pause\/resume profiling around interesting pieces of the application code (e.g., codes executing predetermined routines, recently modified code or the like). The user can manually stop the profiling and the resume\/pause calls can fail due to the manual intervention. Alternatively, the user application (e.g., user application  or the like) can be configured to include the configuration calls within the application itself (e.g., to configure the resolution of the timer or to control the performance-counter registers or the like).","According to an embodiment of the present invention, in the present example, the transition out of the \u2018paused\u2019 state can be to either a \u2018stopped\u2019 state or to \u2018profiling\u2019 state. One skilled in the art will appreciate that the state transitions can be determined according to the profiling application and the profiling state machine can be configured to enter and exit out of various states as the profiling application requires. When a transitional event occurs in the \u2018paused\u2019 state, it is determined whether the transition to \u2018stopped\u2019 state is required ().","The transition from \u2018paused\u2019 state to \u2018stopped\u2019 state can be determined based on various profiling application requirements. For example, if the profiling application is programmed to display collected data during the \u2018paused\u2019 state then after reviewing the data, a user can determine to stop the profiling application. Similarly, if the profiling application is programmed to analyze certain parameters during the \u2018paused\u2019 state then based on the programmed algorithm the profiling application can determine to continue or stop profiling. One skilled in the art will appreciate that various profiling related events can determine the transition from the \u2018paused\u2019 state.","If the transition to \u2018stopped\u2019 state is not required, the profiling application continues to the \u2018profiling\u2019 state and monitors for a next triggering event (). While for purposes of illustration, a transition to triggering event () is described, the profiling application can be either configured to wait for the next triggering event or resume data collection from the pausing event (). If the transition to \u2018stopped\u2019 state is required, the profiling state machine transitions to \u2018stopped\u2019 state and finalizes the data collection (). The finalizing of the data collection can include various profiling related close-up events. For example, the profiling application can transfer collected data from temporary storage to identified storage devices, closing any open files, releasing resources or the like.","The above description is intended to describe at least one embodiment of the invention. The above description is not intended to define the scope of the invention. Rather, the scope of the invention is defined in the claims below. Thus, other embodiments of the invention include other variations, modifications, additions, and\/or improvements to the above description.","The above described method, the operations thereof and modules therefore may be executed on a computer system configured to execute the operations of the method and\/or may be executed from computer-readable media. Computer systems may be found in many forms including but not limited to mainframes, minicomputers, servers, workstations, personal computers, notepads, personal digital assistants, various wireless devices and embedded systems, just to name a few. A typical computer system includes at least one processing unit, associated memory and a number of input\/output (I\/O) devices. A computer system processes information according to a program and produces resultant output information via I\/O devices. A program is a list of instructions such as a particular application program and\/or an operating system.","A computer program is typically stored internally on computer readable storage media or transmitted to the computer system via a computer readable transmission medium. A computer process typically includes an executing (running) program or portion of a program, current program values and state information, and the resources used by the operating system to manage the execution of the process. A parent computer process may spawn other, child processes to help perform the overall functionality of the parent process. Because the parent process specifically spawns the child processes to perform a portion of the overall functionality of the parent process, the functions performed by child processes (and grandchild processes, etc.) may sometimes be described as being performed by the parent process.","The method described above may be embodied in a computer-readable medium for configuring a computer system to execute the method. The computer readable media may be permanently, removably or remotely coupled to system  or another system. The computer readable media may include, for example and without limitation, any number of the following: magnetic storage media including disk and tape storage media; optical storage media such as compact disk media (e.g., CD-ROM, CD-R, etc.) and digital video disk storage media; holographic memory; nonvolatile memory storage media including semiconductor-based memory units such as FLASH memory, EEPROM, EPROM, ROM; ferromagnetic digital memories; volatile storage media including registers, buffers or caches, main memory, RAM, etc.; and data transmission media including permanent and intermittent computer networks, point-to-point telecommunication equipment, carrier wave transmission media, the Internet, just to name a few. Other new and various types of computer-readable media may be used to store and\/or transmit the software modules discussed herein.","Because the above detailed description is exemplary, when \u201cone embodiment\u201d is described, it is an exemplary embodiment. Accordingly, the use of the word \u201cone\u201d in this context is not intended to indicate that one and only one embodiment may have a described feature. Rather, many other embodiments may, and often do, have the described feature of the exemplary \u201cone embodiment.\u201d Thus, as used above, when the invention is described in the context of one embodiment, that one embodiment is one of many possible embodiments of the invention.","While particular embodiments of the present invention have been shown and described, it will be clear to those skilled in the art that, based upon the teachings herein, various modifications, alternative constructions, and equivalents may be used without departing from the invention claimed herein. Consequently, the appended claims encompass within their scope all such changes, modifications, etc. as are within the spirit and scope of the invention. Furthermore, it is to be understood that the invention is solely defined by the appended claims. The above description is not intended to present an exhaustive list of embodiments of the invention. Unless expressly stated otherwise, each example presented herein is a nonlimiting or nonexclusive example, whether or not the terms nonlimiting, nonexclusive or similar terms are contemporaneously expressed with each example. Although an attempt has been made to outline some exemplary embodiments and exemplary variations thereto, other embodiments and\/or variations are within the scope of the invention as defined in the claims below."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features, and advantages made apparent to those skilled in the art by referencing the accompanying drawings.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
