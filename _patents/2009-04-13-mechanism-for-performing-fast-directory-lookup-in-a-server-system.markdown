---
title: Mechanism for performing fast directory lookup in a server system
abstract: Embodiments of the present invention provide a novel technique for maintaining directory-based quota, for performing directory notification to a client system, and performing other such operations by efficiently finding ancestral directory associations on a server system without performing multiple accesses to data structures associated with the directory associations. Since data structures do not need to be accessed multiple times, performance of the server system can be improved.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08266136&OS=08266136&RS=08266136
owner: NetApp, Inc.
number: 08266136
owner_city: Sunnyvale
owner_country: US
publication_date: 20090413
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to operation of a server system and more particularly to a technique for performing directory notification to a client system, maintaining directory-based quota, and other such operations by efficiently finding ancestral directory associations.","A server system is a processing system utilized to store and retrieve data on behalf of one or more clients. A server system operates on behalf of the one or more client systems to store and manage shared data in a set of mass storage devices, such as magnetic or optical storage-based disks or tapes. A server system may include an operating system that implements a file system for storing and organizing computer files and the data they contain. A file system is any organization of data in a structured manner, which is typically organized as a hierarchical set of stored files, directories and\/or other types of data containers. Data stored by a server system may be stored in the form of multiple blocks that each contains data. A block is the unit used by a file system in a server system to manipulate and transfer data. A typical file system may contain thousands (or even hundreds of thousands) of directories. Related files are stored in the same directory. A directory contained inside another directory is called a subdirectory. For efficient data processing of a data structure, a directory can be represented as a tree having a plurality of nodes.","With reference now to , an exemplary directory structure  stored on a server system is illustrated. Those skilled in the art would understand that  is described herein to briefly introduce a concept of a file directory structure.  will be described in more detail later to describe various embodiments of the invention. A node (e.g., a data container, directory, or a subdirectory) within a directory structure has zero or more child nodes. A node that has a child is called a parent node. A node typically has at most one parent, except for the root node, which does not have a parent node. A parent node is associated with one or more links (such as links l1 and l2), which point to its child nodes. These links indicate a logical association between the parent nodes and the child nodes. For example, node X is a root node of the data structure  and it is a parent of child nodes A and B. Being the topmost node, the root node X does not have parents. In directory structure , root node X and nodes A, B, D, E, and G are directory nodes. Nodes C, F, H, and I are leaf nodes (e.g., nodes at the bottom level of the data structure). In the directory structure , G and H are data containers within directory D. H and I are data containers within directory E, and F is a data container within directory B. Each node, whether it is a directory node or a data container node, has an inode number associated with it. Ancestors of a node include all parents, grandparents, etc. An inode is a data structure storing information about a data container, such as, for example, an identifier of the device where the inode resides, locking information, a type of the data container, the number of links to the data container, the owner's user and group identification, the number of bytes in the data container, access and modification times, the time the inode itself was last modified, as well as other data. An inode number refers to a pointer of an inode data structure, and thus its associated data container. An inode number is used to look up an entry in the inode data structure. A root inode is an entry point used during processing of the node tree, and is located at a readily identified location on a storage device, e.g., disk.","Finding out all ancestral directory associations (i.e., direct or indirect parent nodes) of a data container given the data container identifier has been a common problem in implementing some operations of a computer system, such as performing directory notification to a client, maintaining directory-based quotas, and other such operations.","Directory notification service is a mechanism by which a client system can register with a file system for notifications about accesses, changes, or modifications to a file within a particular directory. For example, an application resident on a client system can register with the server system by exposing Application Programming Interfaces (API) to the file system. Server system may maintain mappings between directories being watched for modifications and applications that are registered to receive updates regarding modifications to directories. An application can specify a set of conditions that trigger notification, such as changes to data container names, directory names, attributes, data container size, time of last write, and security. Notification service typically suffers from severe performance penalties. Currently, a Network File System (NFS) client can access a particular data container at a server system using a data container handler that typically encapsulates the inode number of the data container. However, in order to determine all parent nodes of the data container (and thus its path name to the root node), each inode data structure, which is associated with a data container and thus maintains a pointer to its parent, needs to be accessed. Once the immediate parent node is identified, the next immediate parent node needs to be determined (again by accessing a corresponding inode data structure for that node that identifies its parent) and so forth until the complete path name of the node up to the root node is established. Accessing inode data structures in order to retrieve a pointer may require multiple accesses to storage devices where the inode data structures reside. When the path of a data container is determined, the server system compares the path to the names of the directories for which notifications are requested by the client system. Such a comparison may be performed by using, for example, a text based match. If a match is found, the server system issues notifications to clients registered for notifications. Thus, identifying a complete path name of a data container that was accessed and modified may involve multiple accesses to storage devices, which in turn, leads to compromised performance.","Maintaining directory quota by a server system involves setting a data container and block (storage) usage limit on a per directory basis, e.g., a limit on the usage by a particular user at a client system or a group for data containers files and sub-directories that reside under a given directory. Thus, if a data container is modified by a client system (e.g., file system allocates more data blocks or frees data blocks) and a directory that includes a particular data container has a quota which cannot be exceeded, client systems need to be notified by the server system about the changes. Again, finding parent directories of a data container or directory by a server system may involve finding an upward path of the modified data container or directory in the file system all the way up to the root node. Upward traversal can be costly because it involves accessing by the file system one node at a time in a directory structure. Every node access results in a new access to a storage device in order to retrieve a pointer to a parent node. Moreover, maintaining hard links by the file system make the above tasks even more difficult. A node in a file system is said to have a hard link if it has more than one parent directory so that more than one parent node has a pointer to the node. As such, hard links lead to more than one way to reach to the node in the directory tree from the root, and thus may potentially lead to multiple accesses of data structures associated with a node (e.g., inode data structures).","Accordingly, what is a needed is a mechanism that performs directory notification to a client, maintains directory-based quota and other such operations more efficiently.","Embodiments of the present invention provide a novel technique for maintaining directory-based quota, for performing directory notification to a client system, and performing other such operations by efficiently finding ancestral directory associations of directories and data containers on a server system without performing multiple accesses to data structures of ancestors of the data containers or directories. Rather, to determine ancestral directory associations of a data container or a directory, a data structure of the data container or the directory can be accessed. Since data structures of all ancestors do not need to be accessed, performance of the server system can be improved.","The server system includes an index generation engine configured to generate an index for each node of a file system including a plurality of nodes, each node can be a data container having an associated data structure (i.e., inode data structure, which stores data describing a data container). To generate the indices for a node, the index generation engine only accesses inode data structures of immediate parent nodes of the data container and does not need to access inode data structures associated with ancestors of the node, thereby reducing the number of accesses to the inode data structure stored in memory or on a storage device. The index generation engine uses the property of the prime number (that is a number divisible only by one and by itself without leaving a remainder) to generate indices for the nodes in the file system. The server system also includes an index manipulation engine configured to mathematically manipulate the indices of a data container or a directory node to determine ancestor nodes of a data container in a directory watched by the client system for modifications. To this end, the index manipulation engine only needs to access inode data structure associated with a data container rather than accessing inode data structures associated with all ancestor nodes.","The server system also includes a directory notification engine configured to send a notification to the client system of a modification to the data container. Index generation engine, index manipulation engine, and directory notification engine may be implemented in software executed on a programmable processor, hardware or a combination of hardware and software. That is, in an alternative embodiment, these engines be implemented as logic circuitry embodied, for example, within a microprocessor, controller, like programmable gate array or an application specific integrated circuit (ASIC).","Other aspects of the invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings, which illustrate the principles of the invention by way of example.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1","FIG. 1"],"b":["100","150","110","120","150","150"]},"In operation, the server system  services data access requests from the client system (client) . Each client  may be a general-purpose computer configured to execute applications and interact with the server system  in accordance with a client\/server model of data delivery. That is, the client  may request the services of the server system , and the server system may return the results of the services requested by the client by exchanging packets over the network . The clients  may issue packets using file-based access protocols, such as the Common Internet File System (CIFS) protocol or Network File System (NFS) protocol, over TCP\/IP when accessing data in the form of data containers, such as files and directories. Alternatively, the client may issue packets including block-based access protocols, such as the Small Computer Systems Interface (SCSI) protocol encapsulated over TCP (iSCSI) and SCSI encapsulated over Fibre Channel (FCP), when accessing data in the form of data containers, such as blocks. Also, connected to the server system  are one or more mass storage devices , such as disks organized as a storage array . Storage devices  may comprise a writable storage device media, such as magnetic disks, optical or magnetic tape, flash, and any other similar media adapted to store information (including data and parity information).","As described herein, one application of the above-illustrated technique is to notify applications (such as applications  executed at a client system , as shown in ) about modifications to a data container within a directory of a file system (e.g., file system ) of a server system . An application can be, for example, Windows Explorer\u00ae, provided by Microsoft Corporation of Redmond, Wash. Those skilled in the art would understand that other applications may register for notification services. Applications  can register with file system  at the server system  by exposing Application Programming Interfaces (API) to the file system at the server system. Server system  maintains a mapping (not shown in figures) between applications that are registered to receive updates and directories that are being watched. An application can specify a set of conditions that trigger notification. The conditions may include changes to data container names, directory names, attributes, data container size, time of last write, and\/or security.","Referring now to , it illustrates various components of server system  shown in . Server system  may be a device or a combination of devices that provides storage service relating to the organization of data on mass storage devices , such as disks. Server system  illustratively comprises a processor , a memory , one or more network adapters  and one or more storage adapters  interconnected by a system bus  or the like. Each network adapter  comprises the mechanical, electrical and signaling circuitry needed to connect the server system  to clients  over the network . Server system  also includes the operating system  that includes or interacts with various engines (as described in reference to  or ). The processor and adapters may, in turn, comprise processing elements and\/or logic circuitry configured to execute software code and manipulate data structures. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable media, may be used for executing and storing program instructions pertaining to the inventive technique described herein.","The storage adapter  cooperates with the operating system  executing on server system  to store and retrieve data requested on any type of attached array of writable storage device media such as magnetic disks, optical or magnetic tape, flash, and any other similar media adapted to store information (including data and parity information). However, as illustratively described herein, the data are stored on the disks, such as hard disk drive (HDD) and\/or Direct Access Storage Device (DASD). The storage adapter includes input\/output (I\/O) interface circuitry that couples to the storage devices over an I\/O interconnect arrangement, such as a conventional high-performance, Fibre Channel (FC) serial link topology. In the illustrative embodiment, the memory  comprises storage locations that are addressable by the processor and adapters for storing software program code, such as operating system .","Referring now to , it illustrates a schematic block diagram of components of operating system  of server system  that may be advantageously used with embodiments of the present invention. Server system  may implement a file system . The file system  comprises a set of data containers and directories stored on one or more of the mass storage devices . In one embodiment, the file system stores data containers (such as files) on disks as blocks, for example, using, e.g., 4 kilobyte (KB) data blocks, and using inodes to describe the data containers. An inode is a data structure (shown in  and described above), e.g., a 128-byte structure, which may be used to store metadata about a data container. Metadata describes a data container and may include a number of attributes, such as ownership of the data container, access permission for the data container, size of the data container, data container type and location of the file on disk, as described below. According to embodiments described herein, metadata also stores Parent_Index and Immediate Parent_Index of a node, which are generated by an index generation engine shown in . An inode number refers to a pointer of an inode data structure.","In the illustrative embodiment, the operating system  can be the NetApp\u00ae Data ONTAP\u2122 operating system available from NetApp, Inc., of Sunnyvale, Calif., that implements a Write Anywhere File Layout (WAFL\u2122) file system, such as file system . However, it is expressly contemplated that any appropriate file system may be enhanced for use in accordance with the inventive principles described herein. As used herein, the term \u201coperating system\u201d generally refers to the computer-executable code operable on a computer that manages data access, although some or all of its functions can be otherwise implemented in logic circuitry and other devices.","The operating system  executes index generation engine , quota updates engine , directory notification engine , and index manipulation engine . Index generation engine  is configured to generate an index for each node of a file system, comprising a plurality of nodes. Each node has a data container. Index generation engine stores the generated indices in an inode data structure associated with a node. Index generation engine  generates indices for directory nodes and data container nodes at the time of their creation. A first index of the directory node can be expressed as an inode number (e.g., a unique number associated with a directory node and used to lookup an inode data structure which stores information about the directory, such as its type, size, and location). A second index is a Parent_Index generated as a result of performing mathematical manipulation on two indices of the immediate parent nodes. Those skilled in the art would understand that in other embodiments, mathematical manipulations can be performed on more than two indices.","Index generation engine  is also responsible for generating a tuple of indices for each leaf node. A first index is a Parent_Index, which is generated as a result of mathematical manipulation of indices of the immediate parents of the leaf node (such as by multiplying two indices of the immediate parents). A second index is Immediate Parent_Index, which is generated by performing mathematical manipulation by e.g., multiplying inode numbers of immediate parents of the leaf node.","Index manipulation engine  is responsible for mathematically manipulating the generated indices stored in corresponding inode data structure to determine an ancestor node of a data container, in response to receiving a request from the client computer system. Importantly, index manipulation engine  determines an ancestor node of a data container without accessing an inode data structure associated with all ancestors of the data container. For example, index manipulation engine  is configured to determine whether a client registered for modifications within a directory needs to be notified. To this end, index manipulation engine accesses an inode data structure associated with a modified data container and mathematically manipulates indices of the data container to determine ancestors (e.g., directories) where the data container resides. Index manipulation engine  is further configured to determine inode numbers of the directories that are on a path to a data container in the directory structure. If the directories that are on the path to the data container are the directories being watched for modifications by a client computer system, directory notification engine  sends notifications to the client computer system of a modification to the data container within the directory watched by the client system for modifications. The client system will typically have subscribed for such watch service from the server system by requesting such service at an earlier point in time.","Quota updates engine  is configured to send to client systems quota updates for directories watched by client systems. Again, the client systems typically will have subscribed for such quota watch services. Maintaining directory quota by a server system involves setting a data container and storage usage limit on a per directory basis, e.g., a limit on the usage by a particular user at a client system or a group for data containers files and sub-directories that reside under a given directory. Thus, if a data container is modified by a client system (e.g., file system allocates more data blocks or frees data blocks) and a directory that includes a particular data container has a quota which cannot be exceeded, client systems need to be notified by the server system about the changes.","Referring now to , it illustrates a directory structure  of an exemplary instance of a file system. Such a directory structure can be illustratively stored on mass storage devices  shown in . The directory structure is implemented as a tree hierarchy with a set of linked nodes. Each node in the tree represents a directory under the corresponding file system, a sub-directory, or a data container within a directory. Some of the nodes in the directory structure have child nodes, which represent sub-directories in the parent directory or a data container within a directory. For example, in data structure , the topmost node in the tree represents the root directory of the file system. Nodes A and B are directories of the file system. Nodes D, E, and G are sub-directories since each of these nodes have a parent node and one or more child nodes (node D has a parent node A and child nodes G and H; node E has a parent node B and child nodes H and I; node G has a parent node D and child nodes (not shown in )). Nodes C, H, I and F are data containers within respective directories since each of them have a parent node, but does not have a child node (thus, node C has a parent node A, but does not have a child node; node H has two parent nodes, D and E, but does not have a child node; node I has a parent node E, but does not have a child node; F has parent B but no child node). An ancestor node of any node A is any node above A in a tree data structure, where \u201cabove\u201d means \u201ctoward the root.\u201d Thus, root is an ancestor of A and B. As described herein, each data container or directory has an inode number associated with it that is provided by the file system upon creation of the data container or directory. An inode number is a unique number associated with a data container or a directory and is used to lookup an inode data structure which stores metadata about a data container.","In prior art systems, typically the file system cannot determine all ancestors of the data container without accessing data structures (e.g., an inode data structure associated with a data container) that maintain a list of immediate parents of a data container, etc, until the data structures for all the direct and indirect parents are accessed. At that time, the full path for the file can be reconstructed. As described herein, an application (such as ) can register with the file system to receive notifications regarding changes to a particular directory identified by a directory name. The file system maintains a data structure (not shown in figures) identifying the name of each watched directory. Thus, to determine whether a directory needs to be notified, in prior art implementations, a text-based comparison would have been performed between the data container name or directory name path and a name of a directory that is watched by client systems for modifications. This mechanism is inefficient since it requires multiple accesses to data structures.","According to embodiments described herein, a technique is provided for performing operations of a server system, such as providing directory notification to a client, maintaining directory-based quotas and other such operations by efficiently finding ancestral directory associations. According to the technique, ancestor nodes of a data container or a directory node can be performed efficiently without performing costly accesses of data structures associated with ancestor nodes of a data container in a server system.","With reference now to , according to the computer-implemented method described in , a tuple of indices is generated for a root node, directory nodes (nodes that have children), and sub-directory nodes (nodes that have children and parent nodes as directory nodes) as follows (step ). For a directory node, in one embodiment, the first index is an inode number (provided by the file system at the node creation) expressed as a unique prime number. The prime number is a number that is divisible without a remainder only by one and by itself. The second index (referred to herein as a Parent_Index) is generated as a result of performing mathematical manipulation on the two indices of an immediate parent node (step ). For example, in one implementation, the second index is generated by multiplying two indices of an immediate parent node.","The above step can be illustrated in the example shown in . According to embodiments described herein, a first index is stored with the Root, directory and sub-directory nodes A, B, D, E, and G (step ). In one implementation, the first index serves as an inode number, which can be provided by a file system (e.g.,  shown in ). For example, Root's inode number is \u201c1\u201d, A's inode number is \u201c2\u201d, B's inode number is \u201c3\u201d, and G's inode number is \u201c11\u201d and so on. In an exemplary embodiment, the first index is expressed as a prime number. The choice of prime numbers in the exemplary embodiment is explained by the known properties of the prime numbers such that a prime number is divisible only by one or itself without leaving a remainder and a product of the prime numbers is also divisible only by its prime factors. Thus, to determine whether a given directory is a parent of a data container, the product of the prime numbers associated with the data container can be divided by the unique prime number assigned to the directory. If the product of the prime numbers is divisible by the prime number assigned to the directory without leaving a remainder, it follows that the directory is an ancestor of the data container.","Those skilled in the art would understand that mechanism for computing indices and storing the indices can be performed by index manipulation engine  and index generation engine . Further, those skilled in the art would understand that index generation engine  manipulate various fields of inode data structures of immediate parents of a node within a directory watched for modifications to generate indices and to store the indices on storage devices. Each node in the tree structure is associated with an inode data structure. Thus, there could be as many inode data structures as there are nodes (directories and data containers).","Still with reference to , Parent_Index of each directory and sub-directory node shown in  can be generated as follows:","A's first index is inode number (i.e., 2), which can be provided by the file system. Parent_Index of A is a product of multiplication of indices of the immediate parents of A. Root is an immediate parent of A. Its indices are (1,1). Since the root node does not have immediate parents, its Parent_Index is an inode number. Thus, to generate Parent_Index of A, index generation engine  reads the two indices from the inode data structure associated with the root and generates a product of the multiplication of the two indices, e.g., 1. Index generation engine then stores the Parent_Index of A=1 in the inode data structure associated with A.","Parent_Index of B is a product of multiplication of indices of the immediate parents of B. Root is immediate parent of B. Its indices are (1,1). Thus, to generate Parent_Index of B, index generation engine  reads the two indices from the inode data structure associated with the root and generates a product of the multiplication of the two indices, e.g., 1. Index generation engine then stores the Parent_Index of B=1 in the inode data structure associated with B.","Parent_Index of D is a product of multiplication of indices of the immediate parent of D. A is immediate parent of D. Its indices are (2,1). Thus, to generate Parent_Index of D, index generation engine  reads the two indices from the inode data structure associated with A and generates a product of the multiplication of the two indices, e.g., 2. Index generation engine then stores the Parent_Index of D=2 in the inode data structure associated with 2.","Parent_Index of E is a product of multiplication of indices of the immediate parent of E. B is immediate parent of E. Its indices are (3,1). Thus, to generate Parent_Index of B, index generation engine  reads the two indices from the inode data structure associated with the root and generates a product of the multiplication of the two indices, e.g., 3. Index generation engine then stores the Parent_Index of E=3 in the inode data structure associated with E.","As shown in , the following tuples of indices are generated and stored at a mass storage device (e.g., ) for the directory and sub-directory nodes A, B, D, E, and G: A(2,1), B(3,1), D(5,2), E(7,3), and G(11,10). Inode indexes can be provided by file system (e.g., ).","Thus, for the Root and each directory and sub-directory node in the directory structure, the following tuples of indices are generated and stored. A first index (which can serve as inode number and can be expressed as a unique prime number) can be provided by a file system upon creation of the node. The second index is generated by the index generation engine by mathematically manipulating indices of the immediate parent of the node.","Still with reference to the flow diagram illustrated in , at step , for each leaf node (i.e., a node that does not have a child node(s)), the following tuple of indices is generated (Parent_Index, Immediate_Parent_Index), wherein:","The first index, Parent_Index, is generated as a product of multiplication of the Parent_Index and inode number of immediate parents of the leaf node. To this end, index generation engine reads Parent_Index of an immediate parent of the leaf node and an inode number of the parent node and generates Parent_Index of a leaf node as a product of multiplication of the two indices.","The second index, Immediate Parent_Index, is a product of multiplication of inode numbers of the immediate parents of the leaf node. To this end, index generation engine reads inode numbers of immediate parents of the leaf node from the inode data structures associated with the immediate parents and generates a product of the multiplication of the inode numbers.","When a hard link is added by a file system (e.g., file system  shown in ) to a leaf node from another directory, the leaf node can have more than one parent. When a hard link is added to a leaf file node, index generation engine generates a new tuple of indices for a leaf node as follows:","Parent_Index is a product of multiplication of inode numbers with Parent_Index of all immediate parents of the leaf node.","Immediate Parent_Index is a product of multiplication of inode numbers of all immediate parents of the leaf node.","The above described step of generating indices for leaf nodes can be explained in using the exemplary directory structure  shown in . Nodes C, H, I, and F are leaf nodes since none of these nodes has a child node. These nodes correspond to data containers within a respective directory. For example, C is a data container in directory A; H is a data container within sub-directory D and subdirectory E; F is a data container within directory B; and I is a data container within sub-directory E of the directory B. Applying the technique described in step , the indices are generated for leaf nodes as follows:","Parent_Index of C is a product of multiplication of inode number and Parent Index of immediate parents. C has one parent, A. A's tuple of indices is (2,1). The product of multiplication is 2. Thus, C's Parent_Index is 2. To this end, index generation engine reads inode number and Parent_Index of A from the inode data structure associated with A, generates Parent_Index, and stores the generated Parent_Index in the inode data structure associated with C.","Parent_Index of I is a product of multiplication of inode number and Parent Index of immediate parents. Data container I has one parent, E. E's tuple of indices is (7,3). The product of multiplication is 21. Thus, I's Parent_Index is 21. To this end, index generation engine reads inode number and Parent_Index of E from the inode data structure associated with E, generates Parent_Index, and stores the generated Parent_Index in the inode data structure associated with I.","Parent_Index of F is a product of multiplication of inode number and Parent Index of immediate parents. F has one parent, B. B's tuple of indices is (3,1). The product of multiplication is 3. Thus, F's Parent_Index is 3. To this end, index generation engine reads inode number and Parent_Index of B from the inode data structure associated with B, generates Parent_Index, and stores the generated Parent_Index in the inode data structure associated with F.","Parent_Index is generated for other nodes in a similar fashion by performing mathematical manipulations on the indices of the immediate parents of the nodes.","Parent_Index of H is a product of multiplication of inode number and Parent Index of immediate parents. H has two parents, D and E. E's tuple of indices is (7,3). D\u2032 tuple of indices is (5,2). The product of multiplication of all the indices is 7\u00d73\u00d75\u00d72=210. Thus, H's Parent_Index is . To this end, index generation engine reads inode number and Parent_Index of D and E from the inode data structure associated with D and E respectively, generates Parent_Index, and stores the generated Parent_Index in the inode data structure associated with H.","As indicated earlier, Immediate Parent_Index is a product of multiplication of all the immediate parents directory inode numbers. To this end, index generation engine reads inode numbers of immediate parents of the leaf node from the inode data structures associated with the immediate parents and generates a product of the multiplication of the inode numbers.","Immediate_Parent_Index of C is a product of multiplication of inode numbers of immediate parents of C. C has only one parent, A. A's inode number is 2. Thus, Immediate Parent_Index of C=2","Immediate_Parent_Index of I is a product of multiplication of inode numbers of immediate parents of I. I has only one parent, E. E's inode number is 7. Thus, Immediate Parent_Index of I=7.","Immediate Parent_Index for other leaf nodes is generated in a similar fashion. Importantly, to generate indices for directory and leaf nodes, index generation engine merely accesses inode data structure associated with an immediate parent of a node for which indices are generated rather than accessing data structures for all ancestors of the node from the root node.","Thus, for leaf nodes C, H, I, and F, the following tuples of indices are generated by index generation engine and stored into corresponding inode data structure for these leaf nodes: C(2,2), H(210,35), I(21,7), and F(3,3).","In one implementation, the generated indices are stored in an inode data structure (as shown in  and will be described below) corresponding to a node (whether it is a data container or a directory). In some implementations, rather than choosing an inode number to be a unique prime number, any number can be chosen. In such implementations, a mapping data structure (not shown in Figs.) between the directory inode number and its corresponding assigned unique prime number can be maintained in memory and\/or on mass storage devices, such as disks.","Referring again to , once a tuple of indices is generated for each directory node, sub-directory node, and leaf node, by the index generation engine, the generated indices can be mathematically manipulated (step ) to determine whether a node is an ancestor of another node without performing multiple data accesses to the inode data structures of all the ancestor nodes of a given node. As described herein, an ancestor node of any node A is any node above A in a tree model, where \u201cabove\u201d means \u201ctoward the root.\u201d For example, using the novel technique described herein, a Parent_Index of a leaf node can be used to determine all of its ancestor nodes by, for example, generating prime factors of the Parent_Index. The prime factors of a positive integer are the prime numbers that divide into that integer exactly, without leaving a remainder. The process of finding these numbers is called integer factorization, or prime factorization. Given the property of the prime numbers (e.g., a prime number is divisible only by one or itself), a product of the prime numbers is also divisible only by its prime factors. One without leaving a remainder, then the directory is one of the parents of the data container. The following example illustrates this point. Parent_Index of H, , can be factorized by the index manipulation engine and results into the following factors: 1,2,3,5,7. These are prime numbers that divide into  fully, without leaving a remainder. These prime numbers represent inode numbers of the Root, A, B, D, and E respectively, which are ancestors of the node H.","Still with reference to the flow diagram of , at step , the index manipulation engine reads the Parent_Index field of the inode data structure associated with a leaf node. Index manipulation engine further reads the inode number of a directory watched by a client(s) for modifications. Index manipulation engine determines whether Parent_Index of a leaf node is fully divisible by an inode number of a directory that is being watched by the client system for modifications. When a result of the division of two integers cannot be expressed with an integer quotient, the remainder is the amount \u201cleft over.\u201d If the Parent_Index is fully divisible (having a quotient without the remainder), it indicates that the directory is an ancestor of a leaf node and thus modifications to this directory need to be reported to a client.","If the directory is an ancestor of a leaf node, directory notification engine () sends a notification to client system  that watches the directory for modifications (step ). Importantly, in prior art implementations, to determine a complete path of a leaf node (i.e., all ancestors of a leaf node up to the root node), an inode data structure for the leaf node would have to be accessed to read a pointer to the inode data structure of its parent node and so forth. Then a text base search might have to be performed to compare a path of a node with a name of a directory that is being watched for notification purposes. Rather than performing multiple accesses to inode data structures associated with ancestors of the modified leaf node (i.e., a data container), the index manipulation engine merely accesses a Parent_Index field in the inode data structure (e.g., ) associated with the data container and mathematically manipulates the Parent_Index to determine ancestors of the data container. In one implementation, index manipulation engine divides Parent_Index by an inode number of a directory watched by the client system for modifications. If the result of the division does not leave a remainder, the registered directory is in fact an ancestor of the leaf node (and is on a path to the root node from the leaf node). Thus, notification engine notifies a client registered to receive notifications about changes within that directory.","The following example illustrates the above-described step. Assume that exemplary client  is registered with the file system to receive notifications about changes within directories A, B, and E. Assume that data container \u201cI\u201d has been recently accessed and modified. Parent_Index of I is \u201c21.\u201d In order to determine whether directories A, B, and E are affected by the changes, a determination is made whether these directories are ancestors of data container \u201cI.\u201d To this end, using the novel steps described herein, index manipulation engine accesses Parent_Index field in the inode data structure associated with the data container I. Index manipulation engine reads inode numbers of directories A, B, and E. Index manipulation engine then divides the Parent_Index by inode numbers of directories A, B, and E respectively. If the Parent_Index is fully divisible to the inode numbers of each directory without leaving a remainder, then it is said that these directories are ancestors of data container I. Parent_Index of I is 21, and inode numbers of A, B, and E are 2, 3, and 7 respectively:","21\u00f72=10.5","21\u00f73=7","21\u00f77=3.","As shown above, Parent_Index of I is fully divisible by inode number of B and E, but is not fully divisible by inode number of A (21 is not fully divisible by 2 since it leaves a remainder). This operation indicates that B and E are ancestor directories of I and client  should be notified about recent changes within directories B and E. In contrast, since A is not an ancestor of I and thus changes in I do not affect A, client  registered to receive notifications about changes to A will not receive notification concerning changes to data container I. Directory notification services updates can be performed by directory notification engine .","Referring now to , an exemplary inode data structure  stored on mass storage devices (e.g., ) is shown. Triode data structure  may include a metadata section  and a data section . The information stored in metadata section  of each inode describes a data container and, as such, may include the following attributes: the data container type (e.g., regular or directory) , size  of the data container, time stamps  (e.g., access and\/or modification) for the data container, ownership, i.e., user identifier (UID ) and group ID (GID ), of the data container, as well as other attributes. The metadata section  further includes a pointer  that points to a parent node.","According to novel techniques described herein, when indices are generated and stored for directory nodes and leaf nodes, they can be stored in the inode data structure corresponding to the node. Thus, as shown in , metadata section  can also store a Parent_Index  and Immediate Parent_Index . Those skilled in the art would understand that metadata section may include other attributes that are not shown in .","Using the techniques described above (e.g., generating and storing a tuple of indices to files and directories), directory quota maintenance can be performed in a more efficient manner. As described herein, maintaining directory quota involves setting a data container and a storage usage limit on a per directory basis, e.g., a limit on the usage by a particular user or a group for all data containers and sub-directories that reside under a given directory. Thus, if a data container is modified (e.g., blocks are allocated or freed), accounting related actions need to be performed for quota maintenance on one or more of its parent directories.","Referring now to , it illustrates steps performed by a server system to determine whether quota of a particular directory needs to be updated according to novel embodiments described herein. In step , index generation engine generates indices for each node in the file system similar to the step  in . In step , index generation engine generates indices for directory nodes, similar to step  in . In step , index generation engine generates the first index (Parent_Index) for the leaf nodes similar to the step  in . In step , index generation engine generates a second index, Immediate Parent_Index, for the leaf node, similarly to step  described in reference to .","A leaf node that was updated in the file system is identified by the file system using the known functionalities of the file system. Typically, when a data container is modified or new blocks are allocated or freed, the file system is notified. At step , Parent_Index is mathematically manipulated to determine inode numbers of directories that need quota updates. In one implementation, mathematical manipulation comprises generating factors of the Parent_Index of that node. The generated factors represent inode numbers of directory nodes that need quota updates. If Parent_Index of a leaf node is generated as a product of multiplication of Parent_Index and inode number of immediate parent nodes, prime factors represent inode numbers of directory nodes that are on a path to a modified data container from the root node. Thus, at step , quota updates are sent by the file system to the directories having inode numbers equal to the generated factors.","The following example will illustrate how inode numbers of the nodes that need quota updates are determined. Assume data blocks are allocated to leaf node H corresponding to a data container. Generating factors of Parent_Index of data container H involves computing prime numbers that are divided into Parent_Index of H exactly, without leaving a remainder. Since Parent_Index of H, , was computed as a product of multiplication of indices for E and D (7,3) and (5,2), then computed prime factors represent inode numbers of the following nodes: Root, A, B, D, and E.","The generated prime factors provide inode numbers of all directories and subdirectories that are ancestors of H: 210=1\u00d72\u00d73\u00d75\u00d77. These prime factors correspond to inode numbers of the following directory nodes: Root, A, B, D, and E.","In another implementation, rather than generating prime factors, when a leaf node is modified, its Parent_Index is divided with the inode numbers of directories that are registered with the file system for quota maintenance. If the result of the division does not leave a remainder, the directory quota is updated by the file system for that directory.","The above-described technique of generating indices and mathematically manipulating indices for leaf nodes and directory nodes in a file system can be used to perform reverse path name lookup. A path is the route through a file system to a particular data container. Thus, finding a reverse path involves identifying all nodes up to the root node from a data container node. Using novel mechanisms described herein all different paths to a particular node are computed without performing multiple accesses to the inode data structure.","Referring now to , it illustrates computer implemented steps for generating all different paths to a particular node according to novel techniques. At step , the index manipulation engine reads Immediate Parent_Index from an inode data structure associated with a node to which directory paths need to be generated. Then, Immediate Parent_Index is mathematically manipulated by index manipulation engine. For example, in one embodiment, prime factors of the Immediate Parent_Index are generated. Since Parent_Index of a leaf node is a product of multiplication of indices of immediate parent nodes, the generated prime factors represent inode numbers of immediate parents of the node. The generated prime factors are stored, for example, at mass storage devices.","At step , the index manipulation engine reads the generated inode numbers. For each generated inode number corresponding to a node, a Parent_Index of each immediate parent of that node is read by the index manipulation engine from the inode data structure associated with that node.","At step , Parent_Index is mathematically manipulated by the index manipulation engine. In one implementation, prime factors of the Parent_Index are generated. Since a Parent_Index of a leaf node is a product of multiplication of indices of immediate parent nodes of the leaf node, which in turn represents a product of multiplication of inode numbers of all nodes on the path to the leaf node, generated prime factors of the Parent_Index represent inode numbers of all directory nodes from the root node on the path to the leaf node.","The above-described steps can be illustrated using the directory structure shown in . To generate different paths to leaf node H, its Immediate Parent_Index (35) is determined. The prime factors of the Immediate Parent_Index are generated as follows: 35=5,7. These prime factors are divided into 35 exactly, without a remainder. These prime factors represent inode numbers of two nodes (D and E) that are immediate parent nodes of H and thus are on the path to H from the root node.","As a next step, Parent_Index for nodes D and E are generated. Parent_Index of D is \u201c2\u201d and Parent_Index of E is \u201c3\u201d. Since a Parent_Index of a leaf node is a product of multiplication of Parent_Index and inode number of immediate parents of the leaf node, prime factors of the Parent_Index represent inode numbers of all the directory nodes from the root node to the leaf node. Thus, prime factors for each Parent_Index are generated as follows:","For Directory D, prime factors of Parent_Index 2=2, 1","For Directory E, prime factors of Parent_Index 3=3, 1","Prime factors 2 and 1 represent inode numbers of the following directory nodes:","Root and A. Prime factors 3 and 1, in turn, represent inode numbers of the following directory nodes: Root and B.","Thus, one path to node H includes the nodes having the following tuples: Root (1,1), A(2,1), and D(5,2). Another path to node H includes the nodes having the following tuples: Root (1,1). B(3,1), and E(7,3). Importantly, finding a path to a leaf node is accomplished without performing multiple read operations to inode data structures associated with all nodes on the path to a leaf node. Instead, data structures associated with immediate parents of the leaf node are accessed.","Thus, embodiments described herein provide a mechanism for efficiently identifying ancestry associations for a data container or a directory in a file system without accessing data structures associated with all the ancestors of a particular data container or a directory. This novel technique can be used to provide notification services to client systems that are registered to receive notifications about changes to directories in the file system without performing multiple accesses to data structures residing on mass storage devices. Furthermore, if a data container is modified (e.g., blocks allocated or freed), the above-described technique to quickly identify parent directories can be used for quota maintenance on one or more of parent directories. Moreover, using this technique, all parent nodes that are on a path to a data container from the root node can be quickly identified without performing costly data structure accesses. The efficiency of the mechanism is provided by using the known properties of the prime numbers (e.g., a prime number is divisible only by one or itself and a product of the prime numbers is also divisible only by its prime factors). Furthermore, the above-described technique can be extended to determine all the different paths to access a given data container if the data container has multiple hard links (e.g., has more than one parent directory). To accomplish this, Immediate Parent_Index is generated and stored with a data container (for example, in an inode data structure associated with a data container). Those skilled in the art would understand that the generated indices can be stored in a separate data structure, such as a table for storing indices for all the nodes. The Immediate Parent_Index is generated by the index generation engine by reading inode numbers of immediate parents of a data container and performing mathematical manipulations on the inode numbers of immediate parents of the leaf node. While the Parent_Index can be used to determine all the parents of a given data container, the Immediate Parent_Index can be used to determine all the immediate parents of a given data container. Knowing the immediate parents of the data container, all different paths to the data container can be identified.","Those skilled in the art would understand that the invention is not limited to the embodiments described, but can be practiced with modifications. For example, in alternative embodiments, not every directory node in the file system needs to be associated with a prime number. Thus, some embodiments may store prime numbers only with those parent directories that have set up a directory quota or directory notification service. Furthermore, in these embodiments, directory inode numbers do not need to be unique prime numbers. As an alternative, a unique prime number can be assigned to the parent directories that have set up a directory quota or directory notification service. This unique prime number can be stored as a metadata in an inode data structure. A one-to-one mapping (not shown in Figs.) can be maintained between a directory inode (that has setup directory quota or directory notification service) and a unique prime number. Such mapping can be stored on a storage device or in memory. In such implementations, Parent_Index of the inode can be expressed as a multiplication of unique prime numbers of all the parent directories which have directory quota setup or which have signed up for directory notification service.","According to yet another embodiment of the present invention, indices for each directory node can be stored at a leaf node residing in that directory node rather than being stored at the directory node. Thus, in reference to , indices for Root and directory A can be stored at the leaf node C or leaf node D. Similarly, indices for the Root node, directory B, and directory E can be stored at the leaf node H. This embodiment thus does not require using properties of prime numbers when providing inode numbers to the nodes by the file system.","Index generation engine, index manipulation engine, and directory notification engine may be implemented in software executed on a programmable processor, hardware or a combination of hardware and such software. That is, in an alternative embodiment, these engines can be implemented as logic circuitry embodied, for example, within a microprocessor, controller, like a programmable gate array or an application specific integrated circuit (ASIC).","The present invention can be implemented by apparatuses for performing the operations herein. These apparatuses may comprise a machine, which may be a general-purpose machine selectively activated or reconfigured by a computer program (such as a collection of instructions for execution by a machine or processor for example) and stored in a computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to any type of mass storage device, e.g., magnetic disks, optical disks, read-only memories, random access memories, EPROMS, EEPROMS, magnetic or optical cards or any type of media suitable for storing physical (e.g. electronic) constructions and each capable of communicating with a computer system for execution of the instructions by e.g., through use of an appropriate device for reading and\/or for writing the media."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["One or more embodiments of the present invention are illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 8","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 9","FIG. 1"]}]},"DETDESC":[{},{}]}
