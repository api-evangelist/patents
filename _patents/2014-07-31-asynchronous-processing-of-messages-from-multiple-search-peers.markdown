---
title: Asynchronous processing of messages from multiple search peers
abstract: Systems and methods for asynchronous processing of messages that are received from multiple servers. An example method may comprise: receiving, by a first processing thread, in a non-blocking mode, a plurality of sub-application layer protocol packets from a plurality of servers; processing one or more sub-application layer protocol packets received from a first server of the plurality of servers, to produce a first application layer message; writing the first application layer message to a message queue; processing one or more sub-application layer protocol packets received from a second server of the plurality of servers, to produce a second application layer message; writing the second application layer message to the message queue; and reading, by two or more processing threads of a processing thread pool, two or more application layer messages including the first application layer message and the second application layer message from the message queue, to produce two or more memory data structures based on the read application layer messages.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09509765&OS=09509765&RS=09509765
owner: SPLUNK INC.
number: 09509765
owner_city: San Francisco
owner_country: US
publication_date: 20140731
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["The present disclosure is generally related to data processing systems, and is more specifically related to processing of messages from multiple servers.","Modern data centers often comprise thousands of hosts that operate collectively to service requests from even larger numbers of remote clients. During operation, components of these data centers can produce significant volumes of machine-generated data. The unstructured nature of much of this data has made it challenging to perform indexing and searching operations because of the difficulty of applying semantic meaning to unstructured data. As the number of hosts and clients associated with a data center continues to grow, processing large volumes of machine-generated data in an efficient manner continues to be a priority.","Disclosed herein are systems and methods for processing of messages that are asynchronously being received from multiple servers.","An example data aggregation and analysis system may aggregate heterogeneous machine-generated data received from various sources, including servers, databases, applications, networks, etc. The system may be configured to perform real-time indexing of the source data and to execute real-time, scheduled, or historic searches on the source data. A search query may comprise one or more search terms specifying the search criteria. Search terms may include keywords, phrases, Boolean expressions, regular expressions, field names, name-value pairs, etc. The search criteria may comprise a filter specifying relative or absolute time values, to limit the scope of the search by a specific time value or a specific time range.","In certain implementations, the source data may be distributed among a plurality of search servers (also referred to as \u201csearch peers\u201d) so that each search peer may be responsible for searching the corresponding subset of the source data (also referred to as a \u201cbucket\u201d of data). In various illustrative examples, data buckets may be associated with certain time ranges and\/or data sources. Due to the source data being distributed among multiple search servers, two or more search servers may execute certain search requests in parallel, for example using map-reduce techniques, wherein each search peer returns partial results based on the corresponding subset of the source data to a result aggregating server (also referred to as \u201csearch head\u201d) that produces a combined result corresponding to the search request, as described in more details herein below with references to .","In an illustrative example, a search head may comprise a search daemon and an optional web proxy component. \u201cSearch daemon\u201d herein refers to a process that is configured to accept incoming search requests, directly or via the web proxy, from one or more clients and initiate distributed processing of those search requests by one or more search peers. Responsive to receiving a search request, the search daemon may optionally perform certain pre-processing operations on the request, as described in more details herein below. The search daemon may then transmit the pre-processed search request to one or more search peers (e.g., one or more indexers) via one or more transport layer connections.","The search daemon may then aggregate a plurality of response packets received from the search peers into corresponding application layer-messages, and transform the application layer messages into one or more memory data structures representing the search results. The latter operation may involve splitting a payload of each application layer message into two or more parts based on pre-defined bit positions and\/or separators, decoding and\/or encoding binary data according to certain application-specific encoding rules, and assigning the encoded results to certain fields of one or more resulting memory data structures.","Processing of responses received from a single search peer may include operations having significantly different computational complexities, ranging from a relatively lightweight operation of receiving the network packets to a relatively heavyweight operation of transforming application layer messages into memory data structures representing the search results. Thus, combining those operations into a response processing loop to be performed by a single processing thread may lead to a suboptimal efficiency of the response processing loop: if a new network packet arrives when the processing thread is busy performing the result conversion, the newly arrived network packets would need to be buffered until the current result conversion operation would be completed. Furthermore, having a dedicated thread per search peer may lead to degrading the overall system performance due to a very large number of simultaneously active threads.","Aspects of the present disclosure address the above referenced and other deficiencies by providing efficient mechanisms for processing of messages that are being asynchronously received from multiple servers. While the below description illustrates and refers to processing search results by a search daemon of an example data aggregation and analysis system, same and\/or similar systems and methods may be utilized by various data processing systems for processing of messages originated by various types of servers, including application servers, messaging servers, database servers, etc. Various aspects of the methods and systems are described herein by way of examples, rather than by way of limitation. The methods described herein may be implemented by hardware (e.g., general purpose and\/or specialized processing devices, and\/or other devices and associated circuitry), software (e.g., instructions executable by a processing device), or a combination thereof.","In the below description and examples, references are made to Open Systems Interconnection (OSI) model layers, including network (layer 3), transport (layer 4), session (layer 5), presentation (layer 6), and application (layer 7), as defined by Recommendation X.200 (07\/94) by International Telecommunications Union (ITU). In the below description and examples, OSI model layers 4-6 may be, for clarity and conciseness of the description, collectively referred to as \u201csub-application layers\u201d.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["120","120","104","104","108","109","108","112","108","112","108","112"]},"In certain implementations, processing a search query by the example data aggregation and analysis system may be structured as a map-reduce computation, wherein the \u201cmap\u201d operations are delegated to search peers A-Z, while the corresponding \u201creduce\u201d operations are performed by search head , as described in more details below with references to .","In an illustrative example, client  may transmit, to web proxy , a search request  that may be wrapped into one or more HTTP requests. In an illustrative example, search request  may comprise a query string that may comply with the syntax of a certain query language supported by the data aggregation and analysis system, such as SPLUNK\u00ae Search Processing Language (SPL) which is further described herein below.","Responsive to receiving search request , web proxy  may strip the HTTP payload of various network, transport and HTTP layer headers, and forward the search request  to search daemon . Responsive to receiving search request , search daemon  may optionally perform certain pre-processing operations on the request. In certain implementations, search daemon  may replace, within the search request, identifiers of certain functions that are supposed to return aggregated parameters of a dataset of interest (such as averages, or other statistical functions applied to specified fields of a plurality of data items) with identifiers of certain corresponding functions, based on the distributed nature of executing the search request. In an illustrative example, responsive to determining that the search request calls for an average of certain values, search daemon  may replace, within the search request to be forwarded to search peers A-Z, the average calculation with the sum and the count of those values, since the final aggregation operation (i.e., the averaging operation comprising the summing operation followed by the division operation by the count of the summed values) will be performed by search daemon  upon receiving partial search results from each of search peers A-Z. In various other illustrative examples, search daemon  may perform various additional pre-processing of search request  before forwarding it to search peers A-Z.","Responsive to completing the pre-processing of search request , search daemon  may forward the resulting pre-processed search request  to one or more search peers A-Z. In the illustrative example of , identical search requests  are forwarded by search daemon  to one or more search peers A-Z. In various other illustrative examples, the search daemon may forward different search requests to different search peers.","In certain implementations, search daemon  may communicate to each of search peers A-Z via one or more Transmission Control Protocol (TCP) connections. In an illustrative example, the TCP connections may be initiated by search daemon  for each search request and may be terminated upon the full result set has been received from search peers A-Z, as described in more details with references to . Alternatively, the TCP connections may be dynamically allocated for each request from a connection pool. In various other implementations, search daemon  may communicate to each of search peers A-Z using a connectionless transport layer protocol (e.g., User Datagram Protocol (UDP)).","Responsive to processing search request , each of search peers A-Z may transmit, back to search daemon , a respective response  comprising a partial search result. Search daemon  may receive and process a plurality of partial search results , as described in more details below with references to . Responsive to completing the processing of partial results , search daemon  may transmit, to web proxy , a search response  corresponding to search request . Web proxy  may wrap search response  into HTTP response  to be transmitted to client , thus completing the flow of requests and responses initiated by search request .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIGS. 2A-2B","FIG. 1","FIG. 1","FIGS. 2A-2B"],"b":["109","108","109","210","215","225","235","235","240","240","260","250","230","210","235","235","240","240","210","120","120","210","250","230","210","260","210","260","250","250","230"]},"Search daemon  may transmit, via one or more TCP connections, a search request to one or more search peers A-Z. As noted herein above, while the illustrative examples of  refer to TCP connections, other connection-oriented or connectionless transport layer protocols may be employed by search daemon  for communicating to search peers A-Z. Each of search peers A-Z is expected to respond by transmitting a long lived streaming response that may comprise multiple network packets (e.g., TCP packets).","Search daemon  may operate in the asynchronous mode of operation or priority-based mode of operation. In certain implementations, the mode of operation may be selected by search daemon  based on the type of expected results to be returned by the search, as described in more details herein below. Depending on the chosen mode of operation, collator object  may initialize one or more worker threads of thread pool  for transforming chunks of data in the form of messages received from search peers A-Z into search results to be placed into result queue , as described in more details herein below.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2A","b":["230","230","255","255","260","250","230"]},"The asynchronous mode of operation may be used for searches that do not depend on a particular ordering of the data items returned by search peers (e.g., if the search query is expected to return one or more aggregated parameters of a dataset of interest, such as counts, averages, or other statistical functions applied to specified fields of a plurality of data items having the timestamps falling within a certain time range).","Search daemon  may create one or more distributed search result collector objects A-Z to be executed within a single processing thread. Each distributed search result collector object A-Z may comprise an HTTP transaction object  and a parser object . Each HTTP transaction object  may be configured with an identifier (e.g., a Universal Resource Identifier (URI)) of a corresponding search peer , thus establishing a one-to-one mapping between the distributed search collector object  (including its components , ) and the search peer .","In either asynchronous or priority-based mode of operation, search daemon  may implement an event loop  to read the data received via one or more sockets which provide endpoints for the TCP connections to the search peers A-Z. Event loop  may be executed in a single processing thread and may asynchronously, in a non-blocking mode, read sub-application layer protocol packets (e.g., TCP packets) received via one or more sockets. \u201cAsynchronous non-blocking mode\u201d herein shall refer to a mode of operation in which event loop  would not wait on any of the sockets for the data to be received, but would only read the data from any socket where one or more incoming packets are available. In certain implementations, event loop  may process the incoming packets in the order they were received over the plurality of TCP connections.","In certain implementations, event loop  may be executed in a dedicated processing thread. Alternatively, a single processing thread may comprise event loop  and distributed search result collector objects A-Z.","As a TCP packet is received by event loop  from a search peer , its payload comprising at least a part of an HTTP response may be forwarded to HTTP transaction object  corresponding to search peer  that has originated the packet. A payload of at least a part of an HTTP response may comprise at least a part of an application layer message (also referred to as a \u201cfully formed chunk of data\u201d). Parser  corresponding to HTTP transaction object  that has received payloads of one or more TCP packets originated by the corresponding search peer  may package the payloads into one or more application layer messages.","While the illustrative examples described herein employ HTTP protocol over TCP, other OSI sub-application layer (transport, session, and\/or presentation layer) protocols may be employed by the example data aggregation and analysis system operating in accordance with one or more aspects of the present disclosure and\/or implementing one or more methods described herein.","In the asynchronous mode of operation, parsers A-Z may place the application layer messages into a single message queue . Collator object  may monitor message queue . Responsive to detecting an incoming application layer message in message queue , collator object  may invoke a worker thread  of thread pool . The worker thread may convert the application layer message comprising a fully-formed chunk of data into one or more memory data structures storing the search results, and place the data structures into result queue . The conversion process may comprise splitting an application layer message into two or more parts based on pre-defined bit positions and\/or separators, decoding and\/or encoding binary data according to certain application-specific encoding rules, and assigning the encoded results to certain fields of one or more memory data structures to be placed into result queue .","In the asynchronous mode of operation, two or more application layer messages may be processed in parallel by two or more worker threads A-B, if such threads are available in worker thread pool . Thus, the search results may be placed into result queue  in the order they were processed by worker threads A-B of worker thread pool  reading application layer messages from message queue  and transforming each of the application layer messages into one or more memory data structures to be placed into result queue .","In certain implementations, collator object  may throttle the incoming messages received by event loop  responsive to determining that the total size of application layer messages in message queue  exceeds a certain threshold value. Collator object  may notify event loop  that the socket corresponding to distributed search result collector object  that placed the last message into message queue  should not be read from until a further notification. Responsive to receiving such a notification, event loop  may suspend reading the incoming packets from the specified socket.","Responsive to determining that the total size of application layer messages in message queue  falls below the threshold value, collator object  may direct event loop  to resume reading the incoming packets from the previously suspended socket.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 2B","b":["230","109","215","242","244"]},"The priority-based mode of operation may be used for searches that require that the data items returned by search peers be ordered (e.g., if the search query is expected to retrieve specified fields of a plurality of data items having the timestamps falling within a certain time range).","Search daemon  may create one or more distributed search collector objects A-Z to be executed within a single processing thread. Each distributed search collector object  may comprise an HTTP transaction object , a parser object , and a dedicated message queue  for storing application layer messages produced by the corresponding parser . Each HTTP transaction object  may be configured with an identifier (e.g., a Universal Resource Identifier (URI)) of a corresponding search peer , thus establishing a one-to-one mapping between the distributed search collector object  (including its components , ) and the search peer .","As noted above, search daemon  may implement an event loop  to read the data received via one or more sockets which provide endpoints for the TCP connections to the search peers A-Z. Event loop  may be executed in a single processing thread and may asynchronously, in the non-blocking mode, read sub-application layer protocol packets (e.g., TCP packets) received via one or more sockets. \u201cAsynchronous non-blocking mode\u201d herein shall refer to a mode of operation in which event loop  would not wait on any of the sockets for the data to be received, but would only read the data from any socket where one or more incoming packets are available. In certain implementations, event loop  may process the incoming packets in the order they were received over the plurality of TCP connections.","In certain implementations, event loop  may be executed in a dedicated processing thread. Alternatively, a single processing thread may comprise event loop  and distributed search result collector objects A-Z.","As a TCP packet is received by event loop  from a search peer , its payload comprising at least a part of an HTTP response may be forwarded to HTTP transaction object  corresponding to search peer  that has originated the packet. A payload of at least a part of an HTTP response may comprise at least a part of an application layer message (also referred to as a \u201cfully formed chunk of data\u201d). Parser  corresponding to HTTP transaction object  that has received payloads of one or more TCP packets originated by the corresponding search peer  may package the payloads into one or more application layer messages.","While the illustrative examples described herein employ HTTP protocol over TCP, other OSI sub-application layer (transport, session, and\/or presentation layer) protocols may be employed by the example data aggregation and analysis system operating in accordance with one or more aspects of the present disclosure and\/or implementing one or more methods described herein.","In the priority-based mode of operation, each of parsers A-Z may place the application layer messages into the corresponding message queue A-Z. Collator object  may monitor message queues A-Z. Responsive to detecting an incoming application layer message in one of message queues A-Z, collator object  may invoke worker thread  to convert the application layer message comprising a fully-formed chunk of data into one or more memory data structures storing the search results, and place the data structures into result queue . If application layer messages are available in two or more message queues , worked thread  would read the application layer message having the most recent timestamp. As the memory data structures should be placed into result queue  in the order of their respective timestamps, application layer messages in the plurality of message queues A-Z are processed by a dedicated single worker thread , thus providing serialization of the results being placed into result queue .","In certain implementations, collator object  may throttle the incoming messages received by event loop  responsive to determining that the total size of application layer messages in one of message queues A-Z exceeds a certain threshold value. Collator object  may notify event loop  that the TCP connection corresponding to distributed search result collector object that has overflown the message queue  should not be read from until a further notification. Responsive to determining that the total size of application layer messages in the message queue  falls below the threshold value, collator object  may notify event loop  that the incoming messages may now be processed.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIGS. 3A-3D","FIG. 11"],"b":["300","300","300","300","300","300","300","300","300","300","300","300","300","300","300","300","1000","300","300","1000"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 3A","b":"300"},"Referring to , at block , a processing thread of the computer system implementing the method may receive, from a search peer, a sub-application layer protocol packet (e.g., a TCP packet).","At block , the processing thread may strip the payload of the received TCP packet of the headers of one or more sub-application layers (e.g., TCP headers, IP headers, and Ethernet headers).","At block , the processing thread may forward the payload of the received TCP packet to an HTTP transaction object corresponding to the search peer that has originated the TCP packet. The method may loop back to block .",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 3B","b":"300"},"At block , a processing thread of the computer system implementing the method may receive the payloads of one or more sub-application layer packets (e.g., TCP packets).","At block , the processing thread may form one or more application layer messages based on the payloads of the received sub-application layer packets. In an illustrative example, one or more payloads of sub-application layer packets may be grouped into a single application layer message based on detecting one or more pre-defined application layer message separators (i.e., certain characters or groups of characters) within the payloads of sub-application layer packets.","At block , the processing thread may put one or more application layer messages into a message queue. In the asynchronous mode of operation, the application layer messages formed by parsers corresponding to different search peers are placed in a single message queue. In the priority mode of operation, the application layer messages formed by parsers corresponding to different search peers are placed in different message queues. The method may loop back to block .",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 3C","b":"300"},"In the asynchronous mode of operation, two or more application layer messages may be processed in parallel by two or more worker threads. Thus, the search results may be placed into the result queue in the order they were processed by one or more worker threads reading application layer messages from the global message queue and transforming each of the application layer messages into one or more memory data structures to be placed into the result queue.","At block , a worker thread may read a next available application layer message from a message queue. The worker thread may be one of multiple worker threads reading available application layer messages from a single message queue.","At block , the worker thread may convert the application layer message into one or more memory data structures storing the search results. The conversion process may comprise splitting an application layer message into two or more parts based on pre-defined bit positions and\/or separators, decoding and\/or encoding binary data according to certain application-specific encoding rules, and assigning the encoded results to certain fields of one or more resulting memory data structures. The worker thread may be one of the multiple worker threads processing, in parallel, the application layer messages read from the single message queue.","At block , the worker thread may place the resulting memory data structures into the result queue. The resulting memory data structures processed by multiple worker threads may be placed into the result queue in the order they were processed by the multiple worker threads. The method may loop back to block .",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 3D","b":"300"},"At block , the worker thread may read a next available application layer message from two or more message queues. If application layer messages are available in two or more message queues, the worked thread reads the application layer message having the most recent timestamp. A single worker thread may be used to read application layer messages from multiple message queues in the order of their timestamps.","At block , the worker thread may convert the application layer message into one or more memory data structures storing the search results. The conversion process may comprise splitting an application layer message into two or more parts based on pre-defined bit positions and\/or separators, decoding and\/or encoding binary data according to certain application-specific encoding rules, and assigning the encoded results to certain fields of one or more resulting memory data structures. Multiple application layer messages from the multiple message queues are processed by the same worker thread.","At block , the worker thread may place the resulting memory data structures into the result queue. As the memory data structures are being put into the result queue by a single worker thread, the memory data structure are found in the result queue in the order of their respective timestamps, as described in more details herein above. The method may loop back to block .","The systems and methods described herein above may be employed by various data processing systems, e.g., data aggregation and analysis systems. In certain implementations, the example data aggregation and analysis system may perform search queries on performance data that stored as \u201cevents,\u201d wherein each event comprises a collection of performance data and\/or diagnostic information that is generated by a computer system and is correlated with a specific point in time. In various illustrative examples, the data processing system may be represented by the SPLUNK\u00ae ENTERPRISE system produced by Splunk Inc. of San Francisco, Calif., to store and process performance data. The data processing system may be configured to execute search queries as correlational searches, as described in more details herein below.","Modern data centers often comprise thousands of host computer systems that operate collectively to service requests from even larger numbers of remote clients. During operation, these data centers generate significant volumes of performance data and diagnostic information that can be analyzed to quickly diagnose performance problems. In order to reduce the size of this performance data, the data is typically pre-processed prior to being stored based on anticipated data-analysis needs. For example, pre-specified data items can be extracted from the performance data and stored in a database to facilitate efficient retrieval and analysis at search time. However, the rest of the performance data is not saved and is essentially discarded during pre-processing. As storage capacity becomes progressively cheaper and more plentiful, there are fewer incentives to discard this performance data and many reasons to keep it.","This plentiful storage capacity is presently making it feasible to store massive quantities of minimally processed performance data at \u201cingestion time\u201d for later retrieval and analysis at \u201csearch time.\u201d Note that performing the analysis operations at search time provides greater flexibility because it enables an analyst to search all of the performance data, instead of searching pre-specified data items that were stored at ingestion time. This enables the analyst to investigate different aspects of the performance data instead of being confined to the pre-specified set of data items that were selected at ingestion time.","However, analyzing massive quantities of heterogeneous performance data at search time can be a challenging task. A data center may generate heterogeneous performance data from thousands of different components, which can collectively generate tremendous volumes of performance data that can be time-consuming to analyze. For example, this performance data can include data from system logs, network packet data, sensor data, and data generated by various applications. Also, the unstructured nature of much of this performance data can pose additional challenges because of the difficulty of applying semantic meaning to unstructured data, and the difficulty of indexing and querying unstructured data using traditional database systems.","These challenges can be addressed by using an event-based system, such as the SPLUNK\u00ae ENTERPRISE system produced by Splunk Inc. of San Francisco, Calif., to store and process performance data. The SPLUNK\u00ae ENTERPRISE system is the leading platform for providing real-time operational intelligence that enables organizations to collect, index, and harness machine-generated data from various websites, applications, servers, networks, and mobile devices that power their businesses. The SPLUNK\u00ae ENTERPRISE system is particularly useful for analyzing unstructured performance data, which is commonly found in system log files. Although many of the techniques described herein are explained with reference to the SPLUNK\u00ae ENTERPRISE system, the techniques are also applicable to other types of data server systems.","In the SPLUNK\u00ae ENTERPRISE system, performance data is stored as \u201cevents,\u201d wherein each event comprises a collection of performance data and\/or diagnostic information that is generated by a computer system and is correlated with a specific point in time. Events can be derived from \u201ctime series data,\u201d wherein time series data comprises a sequence of data points (e.g., performance measurements from a computer system) that are associated with successive points in time and are typically spaced at uniform time intervals. Events can also be derived from \u201cstructured\u201d or \u201cunstructured\u201d data. Structured data has a predefined format, wherein specific data items with specific data formats reside at predefined locations in the data. For example, structured data can include data items stored in fields in a database table. In contrast, unstructured data does not have a predefined format. This means that unstructured data can comprise various data items having different data types that can reside at different locations. For example, when the data source is an operating system log, an event can include one or more lines from the operating system log containing raw data that includes different types of performance and diagnostic information associated with a specific point in time. Examples of data sources from which an event may be derived include, but are not limited to: web servers; application servers; databases; firewalls; routers; operating systems; and software applications that execute on computer systems, mobile devices, and sensors. The data generated by such data sources can be produced in various forms including, for example and without limitation, server log files, activity log files, configuration files, messages, network packet data, performance measurements and sensor measurements. An event typically includes a timestamp that may be derived from the raw data in the event, or may be determined through interpolation between temporally proximate events having known timestamps.","The SPLUNK\u00ae ENTERPRISE system also facilitates using a flexible schema to specify how to extract information from the event data, wherein the flexible schema may be developed and redefined as needed. Note that a flexible schema may be applied to event data \u201con the fly,\u201d when it is needed (e.g., at search time), rather than at ingestion time of the data as in traditional database systems. Because the schema is not applied to event data until it is needed (e.g., at search time), it is referred to as a \u201clate-binding schema.\u201d","During operation, the SPLUNK\u00ae ENTERPRISE system starts with raw data, which can include unstructured data, machine data, performance measurements or other time-series data, such as data obtained from weblogs, syslogs, or sensor readings. It divides this raw data into \u201cportions,\u201d and optionally transforms the data to produce timestamped events. The system stores the timestamped events in a data store, and enables a user to run queries against the data store to retrieve events that meet specified criteria, such as containing certain keywords or having specific values in defined fields. Note that the term \u201cfield\u201d refers to a location in the event data containing a value for a specific data item.","As noted above, the SPLUNK\u00ae ENTERPRISE system facilitates using a late-binding schema while performing queries on events. A late-binding schema specifies \u201cextraction rules\u201d that are applied to data in the events to extract values for specific fields. More specifically, the extraction rules for a field can include one or more instructions that specify how to extract a value for the field from the event data. An extraction rule can generally include any type of instruction for extracting values from data in events. In some cases, an extraction rule comprises a regular expression, in which case the rule is referred to as a \u201cregex rule.\u201d","In contrast to a conventional schema for a database system, a late-binding schema is not defined at data ingestion time. Instead, the late-binding schema can be developed on an ongoing basis until the time a query is actually executed. This means that extraction rules for the fields in a query may be provided in the query itself, or may be located during execution of the query. Hence, as an analyst learns more about the data in the events, the analyst can continue to refine the late-binding schema by adding new fields, deleting fields, or changing the field extraction rules until the next time the schema is used by a query. Because the SPLUNK\u00ae ENTERPRISE system maintains the underlying raw data and provides a late-binding schema for searching the raw data, it enables an analyst to investigate questions that arise as the analyst learns more about the events.","In the SPLUNK\u00ae ENTERPRISE system, a field extractor may be configured to automatically generate extraction rules for certain fields in the events when the events are being created, indexed, or stored, or possibly at a later time. Alternatively, a user may manually define extraction rules for fields using a variety of techniques.","Also, a number of \u201cdefault fields\u201d that specify metadata about the events rather than data in the events themselves can be created automatically. For example, such default fields can specify: a timestamp for the event data; a host from which the event data originated; a source of the event data; and a source type for the event data. These default fields may be determined automatically when the events are created, indexed or stored.","In some embodiments, a common field name may be used to reference two or more fields containing equivalent data items, even though the fields may be associated with different types of events that possibly have different data formats and different extraction rules. By enabling a common field name to be used to identify equivalent fields from different types of events generated by different data sources, the system facilitates use of a \u201ccommon information model\u201d (CIM) across the different data sources.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 4","b":["100","100","101","105","102","103"]},"During operation, the forwarders  identify which indexers  will receive the collected data and then forward the data to the identified indexers. Forwarders  can also perform operations to strip out extraneous data and detect timestamps in the data. The forwarders next determine which indexers  will receive each data item and then forward the data items to the determined indexers .","Note that distributing data across different indexers facilitates parallel processing. This parallel processing can take place at data ingestion time, because multiple indexers can process the incoming data in parallel. The parallel processing can also take place at search time, because multiple indexers can search through the data in parallel.","System  and the processes described below with respect to  are further described in \u201cExploring Splunk Search Processing Language (SPL) Primer and Cookbook\u201d by David Carasso, CITO Research, 2012, and in \u201cOptimizing Data Analysis With a Semi-Structured Time Series Database\u201d by Ledion Bitincka, Archana Ganapathi, Stephen Sorkin, and Steve Zhang, SLAML, 2010, each of which is hereby incorporated herein by reference in its entirety for all purposes.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 5","b":["201","202"]},"Next, the indexer determines a timestamp for each event at block . As mentioned above, these timestamps can be determined by extracting the time directly from data in the event, or by interpolating the time based on timestamps from temporally proximate events. In some cases, a timestamp can be determined based on the time the data was received or generated. The indexer subsequently associates the determined timestamp with each event at block , for example by storing the timestamp as metadata for each event.","Then, the system can apply transformations to data to be included in events at block . For log data, such transformations can include removing a portion of an event (e.g., a portion used to define event boundaries, extraneous text, characters, etc.) or removing redundant portions of an event. Note that a user can specify portions to be removed using a regular expression or any other possible technique.","Next, a keyword index can optionally be generated to facilitate fast keyword searching for events. To build a keyword index, the indexer first identifies a set of keywords in block . Then, at block  the indexer includes the identified keywords in an index, which associates each stored keyword with references to events containing that keyword (or to locations within events where that keyword is located). When an indexer subsequently receives a keyword-based query, the indexer can access the keyword index to quickly identify events containing the keyword.","In some embodiments, the keyword index may include entries for name-value pairs found in events, wherein a name-value pair can include a pair of keywords connected by a symbol, such as an equals sign or colon. In this way, events containing these name-value pairs can be quickly located. In some embodiments, fields can automatically be generated for some or all of the name-value pairs at the time of indexing. For example, if the string \u201cdest=10.0.1.2\u201d is found in an event, a field named \u201cdest\u201d may be created for the event, and assigned a value of \u201c10.0.1.2.\u201d","Finally, the indexer stores the events in a data store at block , wherein a timestamp can be stored with each event to facilitate searching for events based on a time range. In some cases, the stored events are organized into a plurality of buckets, wherein each bucket stores events associated with a specific time range. This not only improves time-based searches, but it also allows events with recent timestamps that may have a higher likelihood of being accessed to be stored in faster memory to facilitate faster retrieval. For example, a bucket containing the most recent events can be stored as flash memory instead of on hard disk.","Each indexer  is responsible for storing and searching a subset of the events contained in a corresponding data store . By distributing events among the indexers and data stores, the indexers can analyze events for a query in parallel, for example using map-reduce techniques, wherein each indexer returns partial responses for a subset of events to a search head that combines the results to produce an answer for the query. By storing events in buckets for specific time ranges, an indexer may further optimize searching by looking only in buckets for time ranges that are relevant to a query.","Moreover, events and buckets can also be replicated across different indexers and data stores to facilitate high availability and disaster recovery as is described in U.S. patent application Ser. No. 14\/266,812 filed on 30 Apr. 2014, and in U.S. application patent Ser. No. 14\/266,817 also filed on 30 Apr. 2014.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 6","b":["301","302","303"]},"Then, at block , the indexers to which the query was distributed search their data stores for events that are responsive to the query. To determine which events are responsive to the query, the indexer searches for events that match the criteria specified in the query. This criteria can include matching keywords or specific values for certain fields. In a query that uses a late-binding schema, the searching operations in block  may involve using the late-binding scheme to extract values for specified fields from events at the time the query is processed. Next, the indexers can either send the relevant events back to the search head, or use the events to calculate a partial result, and send the partial result back to the search head.","Finally, at block , the search head combines the partial results and\/or events received from the indexers to produce a final result for the query. This final result can comprise different types of data depending upon what the query is asking for. For example, the final results can include a listing of matching events returned by the query, or some type of visualization of data from the returned events. In another example, the final result can include one or more calculated values derived from the matching events.","Moreover, the results generated by system  can be returned to a client using different techniques. For example, one technique streams results back to a client in real-time as they are identified. Another technique waits to report results to the client until a complete set of results is ready to return to the client. Yet another technique streams interim results back to the client in real-time until a complete set of results is ready, and then returns the complete set of results to the client. In another technique, certain results are stored as \u201csearch jobs,\u201d and the client may subsequently retrieve the results by referencing the search jobs.","The search head can also perform various operations to make the search more efficient. For example, before the search head starts executing a query, the search head can determine a time range for the query and a set of common keywords that all matching events must include. Next, the search head can use these parameters to query the indexers to obtain a superset of the eventual results. Then, during a filtering stage, the search head can perform field-extraction operations on the superset to produce a reduced set of search results.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":["FIG. 7","FIG. 7"],"b":["402","404","404","104","102","402","402"]},"Upon receiving search query , query processor  sees that search query  includes two fields \u201cIP\u201d and \u201ctarget.\u201d Query processor  also determines that the values for the \u201cIP\u201d and \u201ctarget\u201d fields have not already been extracted from events in data store , and consequently determines that query processor  needs to use extraction rules to extract values for the fields. Hence, query processor  performs a lookup for the extraction rules in a rule base , wherein rule base  maps field names to corresponding extraction rules and obtains extraction rules -, wherein extraction rule  specifies how to extract a value for the \u201cIP\u201d field from an event, and extraction rule  specifies how to extract a value for the \u201ctarget\u201d field from an event. As is illustrated in , extraction rules - can comprise regular expressions that specify how to extract values for the relevant fields. Such regular-expression-based extraction rules are also referred to as \u201cregex rules.\u201d In addition to specifying how to extract field values, the extraction rules may also include instructions for deriving a field value by performing a function on a character string or value retrieved by the extraction rule. For example, a transformation rule may truncate a character string, or convert the character string into a different data format. In some cases, the query itself can specify one or more extraction rules.","Next, query processor  sends extraction rules - to a field extractor , which applies extraction rules - to events - in a data store . Note that data store  can include one or more data stores, and extraction rules - can be applied to large numbers of events in data store , and are not meant to be limited to the three events - illustrated in . Moreover, the query processor  can instruct field extractor  to apply the extraction rules to all the events in a data store , or to a subset of the events that have been filtered based on some criteria.","Next, field extractor  applies extraction rule  for the first command \u201cSearch IP=\u201c10*\u201d to events in data store  including events -. Extraction rule  is used to extract values for the IP address field from events in data store  by looking for a pattern of one or more digits, followed by a period, followed again by one or more digits, followed by another period, followed again by one or more digits, followed by another period, and followed again by one or more digits. Next, field extractor  returns field values  to query processor , which uses the criterion IP=\u201c10*\u201d to look for IP addresses that start with \u201c10\u201d. Note that events  and  match this criterion, but event  does not, so the result set for the first command is events -.","Query processor  then sends events - to the next command \u201cstats count target.\u201d To process this command, query processor  causes field extractor  to apply extraction rule  to events -. Extraction rule  is used to extract values for the target field for events - by skipping the first four commas in events -, and then extracting all of the following characters until a comma or period is reached. Next, field extractor  returns field values  to query processor , which executes the command \u201cstats count target\u201d to count the number of unique values contained in the target fields, which in this example produces the value \u201c2\u201d that is returned as a final result  for the query.","Note that query results can be returned to a client, a search head, or any other system component for further processing. In general, query results may include: a set of one or more events; a set of one or more values obtained from the events; a subset of the values; statistics calculated based on the values; a report containing the values; or a visualization, such as a graph or chart, generated from the values.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 9A","FIG. 9B"],"b":["600","600","602","612","600"]},"After the search is executed, the search screen  can display the results through search results tabs , wherein search results tabs  includes: an \u201cevents tab\u201d that displays various information about events returned by the search; a \u201cstatistics tab\u201d that displays statistics about the search results; and a \u201cvisualization tab\u201d that displays various visualizations of the search results. The events tab illustrated in  displays a timeline graph  that graphically illustrates the number of events that occurred in one-hour intervals over the selected time range. It also displays an events list  that enables a user to view the raw data in each of the returned events. It additionally displays a fields sidebar  that includes statistics about occurrences of specific fields in the returned events, including \u201cselected fields\u201d that are pre-selected by the user, and \u201cinteresting fields\u201d that are automatically selected by the system based on pre-specified criteria.","The above-described system provides significant flexibility by enabling a user to analyze massive quantities of minimally processed performance data \u201con the fly\u201d at search time instead of storing pre-specified portions of the performance data in a database at ingestion time. This flexibility enables a user to see correlations in the performance data and perform subsequent queries to examine interesting aspects of the performance data that may not have been apparent at ingestion time.","However, performing extraction and analysis operations at search time can involve a large amount of data and require a large number of computational operations, which can cause considerable delays while processing the queries. Fortunately, a number of acceleration techniques have been developed to speed up analysis operations performed at search time. These techniques include: (1) performing search operations in parallel by formulating a search as a map-reduce computation; (2) using a keyword index; (3) using a high performance analytics store; and (4) accelerating the process of generating reports. These techniques are described in more detail below.","To facilitate faster query processing, a query can be structured as a map-reduce computation, wherein the \u201cmap\u201d operations are delegated to the indexers, while the corresponding \u201creduce\u201d operations are performed locally at the search head. For example,  illustrates how a search query  received from a client at search head  can split into two phases, including: (1) a \u201cmap phase\u201d comprising subtasks  (e.g., data retrieval or simple filtering) that may be performed in parallel and are \u201cmapped\u201d to indexers  for execution, and (2) a \u201creduce phase\u201d comprising a merging operation  to be executed by the search head when the results are ultimately collected from the indexers.","During operation, upon receiving search query , search head  modifies search query  by substituting \u201cstats\u201d with \u201cprestats\u201d to produce search query , and then distributes search query  to one or more distributed indexers, which are also referred to as \u201csearch peers.\u201d Note that search queries may generally specify search criteria or operations to be performed on events that meet the search criteria. Search queries may also specify field names, as well as search criteria for the values in the fields or operations to be performed on the values in the fields. Moreover, the search head may distribute the full search query to the search peers as is illustrated in , or may alternatively distribute a modified version (e.g., a more restricted version) of the search query to the search peers. In this example, the indexers are responsible for producing the results and sending them to the search head. After the indexers return the results to the search head, the search head performs the merging operations  on the results. Note that by executing the computation in this way, the system effectively distributes the computational operations while minimizing data transfers.","As described above with reference to the flow charts in , event-processing system  can construct and maintain one or more keyword indices to facilitate rapidly identifying events containing specific keywords. This can greatly speed up the processing of queries involving specific keywords. As mentioned above, to build a keyword index, an indexer first identifies a set of keywords. Then, the indexer includes the identified keywords in an index, which associates each stored keyword with references to events containing that keyword, or to locations within events where that keyword is located. When an indexer subsequently receives a keyword-based query, the indexer can access the keyword index to quickly identify events containing the keyword.","To speed up certain types of queries, some embodiments of system  make use of a high performance analytics store, which is referred to as a \u201csummarization table,\u201d that contains entries for specific field-value pairs. Each of these entries keeps track of instances of a specific value in a specific field in the event data and includes references to events containing the specific value in the specific field. For example, an exemplary entry in a summarization table can keep track of occurrences of the value \u201c94107\u201d in a \u201cZIP code\u201d field of a set of events, wherein the entry includes references to all of the events that contain the value \u201c94107\u201d in the ZIP code field. This enables the system to quickly process queries that seek to determine how many events have a particular value for a particular field, because the system can examine the entry in the summarization table to count instances of the specific value in the field without having to go through the individual events or do extractions at search time. Also, if the system needs to process all events that have a specific field-value combination, the system can use the references in the summarization table entry to directly access the events to extract further information without having to search all of the events to find the specific field-value combination at search time.","In some embodiments, the system maintains a separate summarization table for each of the above-described time-specific buckets that stores events for a specific time range, wherein a bucket-specific summarization table includes entries for specific field-value combinations that occur in events in the specific bucket. Alternatively, the system can maintain a separate summarization table for each indexer, wherein the indexer-specific summarization table only includes entries for the events in a data store that is managed by the specific indexer.","The summarization table can be populated by running a \u201ccollection query\u201d that scans a set of events to find instances of a specific field-value combination, or alternatively instances of all field-value combinations for a specific field. A collection query can be initiated by a user, or can be scheduled to occur automatically at specific time intervals. A collection query can also be automatically launched in response to a query that asks for a specific field-value combination.","In some cases, the summarization tables may not cover all of the events that are relevant to a query. In this case, the system can use the summarization tables to obtain partial results for the events that are covered by summarization tables, but may also have to search through other events that are not covered by the summarization tables to produce additional results. These additional results can then be combined with the partial results to produce a final set of results for the query. This summarization table and associated techniques are described in more detail in U.S. Pat. No. 8,682,925, issued on Mar. 25, 2014.","In some embodiments, a data server system such as the SPLUNK\u00ae ENTERPRISE system can accelerate the process of periodically generating updated reports based on query results. To accelerate this process, a summarization engine automatically examines the query to determine whether generation of updated reports can be accelerated by creating intermediate summaries. (This is possible if results from preceding time periods can be computed separately and combined to generate an updated report. In some cases, it is not possible to combine such incremental results, for example where a value in the report depends on relationships between events from different time periods.) If reports can be accelerated, the summarization engine periodically generates a summary covering data obtained during a latest non-overlapping time period. For example, where the query seeks events meeting a specified criteria, a summary for the time period includes only events within the time period that meet the specified criteria. Similarly, if the query seeks statistics calculated from the events, such as the number of events that match the specified criteria, then the summary for the time period includes the number of events in the period that match the specified criteria.","In parallel with the creation of the summaries, the summarization engine schedules the periodic updating of the report associated with the query. During each scheduled report update, the query engine determines whether intermediate summaries have been generated covering portions of the time period covered by the report update. If so, then the report is generated based on the information contained in the summaries. Also, if additional event data has been received and has not yet been summarized, and is required to generate the complete report, the query can be run on this additional event data. Then, the results returned by this query on the additional event data, along with the partial results obtained from the intermediate summaries, can be combined to generate the updated report. This process is repeated each time the report is updated. Alternatively, if the system stores events in buckets covering specific time ranges, then the summaries can be generated on a bucket-by-bucket basis. Note that producing intermediate summaries can save the work involved in re-running the query for previous time periods, so only the newer event data needs to be processed while generating an updated report. These report acceleration techniques are described in more detail in U.S. Pat. No. 8,589,403, issued on Nov. 19, 2013, and U.S. Pat. No. 8,412,696, issued on Apr. 2, 2011.","The SPLUNK\u00ae ENTERPRISE platform provides various schemas, dashboards and visualizations that make it easy for developers to create applications to provide additional capabilities. One such application is the SPLUNK\u00ae APP FOR ENTERPRISE SECURITY, which performs monitoring and alerting operations and includes analytics to facilitate identifying both known and unknown security threats based on large volumes of data stored by the SPLUNK\u00ae ENTERPRISE system. This differs significantly from conventional Security Information and Event Management (SIEM) systems that lack the infrastructure to effectively store and analyze large volumes of security-related event data. Traditional SIEM systems typically use fixed schemas to extract data from pre-defined security-related fields at data ingestion time, wherein the extracted data is typically stored in a relational database. This data extraction process (and associated reduction in data size) that occurs at data ingestion time inevitably hampers future incident investigations, when all of the original data may be needed to determine the root cause of a security issue, or to detect the tiny fingerprints of an impending security threat.","In contrast, the SPLUNK\u00ae APP FOR ENTERPRISE SECURITY system stores large volumes of minimally processed security-related data at ingestion time for later retrieval and analysis at search time when a live security threat is being investigated. To facilitate this data retrieval process, the SPLUNK\u00ae APP FOR ENTERPRISE SECURITY provides pre-specified schemas for extracting relevant values from the different types of security-related event data, and also enables a user to define such schemas.","The SPLUNK\u00ae APP FOR ENTERPRISE SECURITY can process many types of security-related information. In general, this security-related information can include any information that can be used to identify security threats. For example, the security-related information can include network-related information, such as IP addresses, domain names, asset identifiers, network traffic volume, uniform resource locator strings, and source addresses. (The process of detecting security threats for network-related information is further described in U.S. patent application Ser. Nos. 13\/956,252, and 13\/956,262.) Security-related information can also include endpoint information, such as malware infection data and system configuration information, as well as access control information, such as login\/logout information and access failure notifications. The security-related information can originate from various sources within a data center, such as hosts, virtual machines, storage devices and sensors. The security-related information can also originate from various sources in a network, such as routers, switches, email servers, proxy servers, gateways, firewalls and intrusion-detection systems.","During operation, the SPLUNK\u00ae APP FOR ENTERPRISE SECURITY facilitates detecting so-called \u201cnotable events\u201d that are likely to indicate a security threat. These notable events can be detected in a number of ways: (1) an analyst can notice a correlation in the data and can manually identify a corresponding group of one or more events as \u201cnotable;\u201d or (2) an analyst can define a \u201ccorrelation search\u201d specifying criteria for a notable event, and every time one or more events satisfy the criteria, the application can indicate that the one or more events are notable. An analyst can alternatively select a pre-defined correlation search provided by the application. Note that correlation searches can be run continuously or at regular intervals (e.g., every hour) to search for notable events. Upon detection, notable events can be stored in a dedicated \u201cnotable events index,\u201d which can be subsequently accessed to generate various visualizations containing security-related information. Also, alerts can be generated to notify system operators when important notable events are discovered.","The SPLUNK\u00ae APP FOR ENTERPRISE SECURITY provides various visualizations to aid in discovering security threats, such as a \u201ckey indicators view\u201d that enables a user to view security metrics of interest, such as counts of different types of notable events. For example,  illustrates an exemplary key indicators view  that comprises a dashboard, which can display a value , for various security-related metrics, such as malware infections . It can also display a change in a metric value , which indicates that the number of malware infections increased by 63 during the preceding interval. Key indicators view  additionally displays a histogram panel  that displays a histogram of notable events organized by urgency values, and a histogram of notable events organized by time intervals. This key indicators view is described in further detail in pending U.S. patent application Ser. No. 13\/956,338 filed Jul. 31, 2013.","These visualizations can also include an \u201cincident review dashboard\u201d that enables a user to view and act on \u201cnotable events.\u201d These notable events can include: (1) a single event of high importance, such as any activity from a known web attacker; or (2) multiple events that collectively warrant review, such as a large number of authentication failures on a host followed by a successful authentication. For example,  illustrates an exemplary incident review dashboard  that includes a set of incident attribute fields  that, for example, enables a user to specify a time range field  for the displayed events. It also includes a timeline  that graphically illustrates the number of incidents that occurred in one-hour time intervals over the selected time range. It additionally displays an events list  that enables a user to view a list of all of the notable events that match the criteria in the incident attributes fields . To facilitate identifying patterns among the notable events, each notable event can be associated with an urgency value (e.g., low, medium, high, critical), which is indicated in the incident review dashboard. The urgency value for a detected event can be determined based on the severity of the event and the priority of the system component associated with the event. The incident review dashboard is described further in \u201chttp:\/\/docs.splunk.com\/Documentation\/PCI\/2.1.1\/","User\/IncidentReviewdashboard.\u201d","As mentioned above, the SPLUNK\u00ae ENTERPRISE platform provides various features that make it easy for developers to create various applications. One such application is the SPLUNK\u00ae APP FOR VMWARE\u00ae, which performs monitoring operations and includes analytics to facilitate diagnosing the root cause of performance problems in a data center based on large volumes of data stored by the SPLUNK\u00ae ENTERPRISE system.","This differs from conventional data-center-monitoring systems that lack the infrastructure to effectively store and analyze large volumes of performance information and log data obtained from the data center. In conventional data-center-monitoring systems, this performance data is typically pre-processed prior to being stored, for example by extracting pre-specified data items from the performance data and storing them in a database to facilitate subsequent retrieval and analysis at search time. However, the rest of the performance data is not saved and is essentially discarded during pre-processing. In contrast, the SPLUNK\u00ae APP FOR VMWARE\u00ae stores large volumes of minimally processed performance information and log data at ingestion time for later retrieval and analysis at search time when a live performance issue is being investigated.","The SPLUNK\u00ae APP FOR VMWARE\u00ae can process many types of performance-related information. In general, this performance-related information can include any type of performance-related data and log data produced by virtual machines and host computer systems in a data center. In addition to data obtained from various log files, this performance-related information can include values for performance metrics obtained through an application programming interface (API) provided as part of the vSphere Hypervisor\u2122 system distributed by VMware, Inc. of Palo Alto, Calif. For example, these performance metrics can include: (1) CPU-related performance metrics; (2) disk-related performance metrics; (3) memory-related performance metrics; (4) network-related performance metrics; (5) energy-usage statistics; (6) data-traffic-related performance metrics; (7) overall system availability performance metrics; (8) cluster-related performance metrics; and (9) virtual machine performance statistics. For more details about such performance metrics, please see U.S. patent Ser. No. 14\/167,316 filed 29 Jan. 2014, which is hereby incorporated herein by reference. Also, see \u201cvSphere Monitoring and Performance,\u201d Update 1, vSphere 5.5, EN-001357-00, http:\/\/pubs.vmware.com\/vsphere-55\/topic\/com.vmware.ICbase\/PDF\/vsphere-esxi-vcenter-server-551-monitoring-performance-guide.pdf.","To facilitate retrieving information of interest from performance data and log files, the SPLUNK\u00ae APP FOR VMWARE\u00ae provides pre-specified schemas for extracting relevant values from different types of performance-related event data, and also enables a user to define such schemas.","The SPLUNK\u00ae APP FOR VMWARE\u00ae additionally provides various visualizations to facilitate detecting and diagnosing the root cause of performance problems. For example, one such visualization is a \u201cproactive monitoring tree\u201d that enables a user to easily view and understand relationships among various factors that affect the performance of a hierarchically structured computing system. This proactive monitoring tree enables a user to easily navigate the hierarchy by selectively expanding nodes representing various entities (e.g., virtual centers or computing clusters) to view performance information for lower-level nodes associated with lower-level entities (e.g., virtual machines or host systems). Exemplary node-expansion operations are illustrated in , wherein nodes  and  are selectively expanded. Note that nodes - can be displayed using different patterns or colors to represent different performance states, such as a critical state, a warning state, a normal state or an unknown\/offline state. The ease of navigation provided by selective expansion in combination with the associated performance-state information enables a user to quickly diagnose the root cause of a performance problem. The proactive monitoring tree is described in further detail in U.S. patent application Ser. No. 14\/235,490 filed on 15 Apr. 2014, which is hereby incorporated herein by reference for all possible purposes.","The SPLUNK\u00ae APP FOR VMWARE\u00ae also provides a user interface that enables a user to select a specific time range and then view heterogeneous data, comprising events, log data and associated performance metrics, for the selected time range. For example, the screen illustrated in  displays a listing of recent \u201ctasks and events\u201d and a listing of recent \u201clog entries\u201d for a selected time range above a performance-metric graph for \u201caverage CPU core utilization\u201d for the selected time range. Note that a user is able to operate pull-down menus  to selectively display different performance metric graphs for the selected time range. This enables the user to correlate trends in the performance-metric graph with corresponding event and log data to quickly determine the root cause of a performance problem. This user interface is described in more detail in U.S. patent application Ser. No. 14\/167,316 filed on 29 Jan. 2014, which is hereby incorporated herein by reference for all possible purposes.",{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 11","b":["1000","1000","1000","1000","1000","300","300"]},"The example computing device  may include a processing device (e.g., a general purpose processor) , a main memory  (e.g., synchronous dynamic random access memory (DRAM), read-only memory (ROM)), a static memory  (e.g., flash memory and a data storage device ), which may communicate with each other via a bus .","The processing device  may be provided by one or more general-purpose processing devices such as a microprocessor, central processing unit, or the like. In an illustrative example, the processing device  may comprise a complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, or a processor implementing other instruction sets or processors implementing a combination of instruction sets. The processing device  may also comprise one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), a network processor, or the like. The processing device  may be configured to execute the methods A-D for processing of messages that are asynchronously being received from multiple servers, in accordance with one or more aspects of the present disclosure.","The computing device  may further include a network interface device , which may communicate with a network . The computing device  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)), an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse) and an acoustic signal generation device  (e.g., a speaker). In one embodiment, video display unit , alphanumeric input device , and cursor control device  may be combined into a single component or device (e.g., an LCD touch screen).","The data storage device  may include a computer-readable storage medium  on which may be stored one or more sets of instructions (e.g., instructions of the methods A-D for processing of messages that are asynchronously being received from multiple servers, in accordance with one or more aspects of the present disclosure) implementing any one or more of the methods or functions described herein. Instructions implementing methods A-D may also reside, completely or at least partially, within main memory  and\/or within processing device  during execution thereof by computing device , main memory  and processing device  also constituting computer-readable media. The instructions may further be transmitted or received over a network  via network interface device .","While computer-readable storage medium  is shown in an illustrative example to be a single medium, the term \u201ccomputer-readable storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database and\/or associated caches and servers) that store one or more sets of instructions. The term \u201ccomputer-readable storage medium\u201d shall also be taken to include any medium that is capable of storing, encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform the methods described herein. The term \u201ccomputer-readable storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, optical media and magnetic media.","Unless specifically stated otherwise, terms such as \u201cupdating,\u201d \u201cidentifying,\u201d \u201cdetermining,\u201d \u201csending,\u201d \u201cassigning,\u201d or the like refer to actions and processes performed or implemented by computing devices that manipulate and transform data represented as physical (electronic) quantities within the computing device's registers and memories into other data similarly represented as physical quantities within the computing device memories or registers or other such information storage, transmission or display devices. Also, the terms \u201cfirst,\u201d \u201csecond,\u201d \u201cthird,\u201d \u201cfourth,\u201d etc. as used herein are meant as labels to distinguish among different elements and may not necessarily have an ordinal meaning according to their numerical designation.","Examples described herein also relate to an apparatus for performing the methods described herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computing device selectively programmed by a computer program stored in the computing device. Such a computer program may be stored in a computer-readable non-transitory storage medium.","The methods and illustrative examples described herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used in accordance with the teachings described herein, or it may prove convenient to construct more specialized apparatus to perform the required method operations. The required structure for a variety of these systems will appear as set forth in the description above.","The above description is intended to be illustrative, and not restrictive. Although the present disclosure has been described with references to specific illustrative examples, it will be recognized that the present disclosure is not limited to the examples described. The scope of the disclosure should be determined with reference to the following claims, along with the full scope of equivalents to which the claims are entitled."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present disclosure is illustrated by way of examples, and not by way of limitation, and may be more fully understood with references to the following detailed description when considered in connection with the figures, in which:",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIGS. 3A-3D","b":["300","300"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10C"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10D"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
