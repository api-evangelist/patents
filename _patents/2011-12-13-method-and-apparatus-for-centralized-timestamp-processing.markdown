---
title: Method and apparatus for centralized timestamp processing
abstract: Method and apparatus for centralized timestamp processing is described herein. A graphics processing system includes multiple graphics engines and a timestamp module. For each task, a graphics driver assigns the task to a graphics engine and writes a task command packet to a memory buffer associated with the graphics engine. The graphics driver also writes a timestamp command packet for each task to a timestamp module memory buffer. A command processor associated with the graphics engine signals the timestamp module memory buffer upon completion of the task. If the read pointer is at the appropriate position in the timestamp module memory buffer, the timestamp module/timestamp module memory buffer executes the timestamp command packet and writes the timestamp to a timestamp memory. The timestamp memory is accessible by the graphics driver.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08959296&OS=08959296&RS=08959296
owner: ATI Technologies ULC
number: 08959296
owner_city: Markham, Ontario
owner_country: CA
publication_date: 20111213
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","BACKGROUND","SUMMARY OF EMBODIMENTS","DETAILED DESCRIPTION"],"p":["The present invention is generally directed to processors.","Graphics processing systems are using multiple engines to increase graphics and computing performance. Each engine has a ring buffer and a timestamp for processing task requests. The graphic driver will therefore have to maintain and account for every timestamp. This may become complicated and inefficient. Other processors face similar issues.","Method and apparatus for centralized timestamp processing is described herein. A processing system includes multiple engines and a timestamp module. For each task, a driver assigns the task to an engine and writes a task command packet to a memory buffer associated with the engine. The driver also writes a timestamp command packet for each task to a timestamp module memory buffer. A command processor associated with the engine signals the timestamp module memory buffer upon completion of the task. If the read pointer is at the appropriate position in the timestamp module memory buffer, the timestamp module\/timestamp module memory buffer executes the timestamp command packet and writes the timestamp to a timestamp memory. The timestamp memory is accessible by the driver.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","100","100","100","105","115","110","120","125","100","100"]},"The CPU  and GPU  may be located on the same die, (accelerated processing unit (APU)). The CPU  may be any commercially available CPU, a digital signal processor (DSP), application specific integrated processor (ASIC), field programmable gate array (FPGA), or a customized processor. The CPU  and\/or GPU  may comprise of one or more processors coupled using a communication infrastructure, such as communication infrastructure . The CPU  and\/or GPU  may also include one or more processors that have more than one processing core on the same die such as a multi-core processor. The memory  may be located on the same die as the CPU  and\/or GPU , or may be located separately from the CPU  and\/or GPU . The memory  may include a volatile or non-volatile memory, for example, random access memory (RAM), dynamic RAM, or a cache.","The CPU  executes an operating system (not shown) and one or more applications, and is the control processor for system . The operating system executing on CPU  controls, facilitates access and coordinates the accomplishment of tasks with respect to system .","The driver , (e.g., a graphics driver), may comprise software, firmware, hardware, or any combination thereof. In an embodiment, the graphics driver  may be implemented entirely in software. The driver  may provide an interface and\/or application programming interface (API) for the CPU  and applications executing on the CPU  to access the GPU .","The communication infrastructure  may provide coupling between the components of system  and may include one or more communication buses such as Peripheral Component Interconnect (PCI), Advanced Graphics Port (AGP), and the like.","The GPU  provides graphics acceleration functionality and other compute functionality to system . The GPU  may include multiple command processors (CP) CP  . . . CP n , a stamp module  and multiple graphics engines (Engines) Engine  . . . Engine n , for example, 3D engines, unified video decoder (UVD) engines, and digital rights management (DRM) direct memory access (DMA) engines. GPU  may include a plurality of processors including processing elements such as arithmetic and logic units (ALU). It is understood that the GPU  may include additional components not shown in .","The CP  . . . CP n  control the processing within GPU  and may be connected to Engine  . . . Engine n  and stamp module . Each CP  . . . CP n  may be associated with Engine  . . . Engine n  and each pair is an engine block (EB) EB  . . . EB n . In another embodiment, the CP  . . . CP n  may be a single command processor. In general, the CP  . . . CP n  receives instructions to be executed from the CPU , and coordinate the execution of those instructions on Engine  . . . Engine n  in GPU . In some instances, the CP  . . . CP n  may generate one or more commands to be executed in GPU , that correspond to each command received from CPU . Logic instructions implementing the functionality of the CP  . . . CP n  may be implemented in hardware, firmware, or software, or a combination thereof.","The memory  may include a one or more memory devices and may be a dynamic random access memory (DRAM) or a similar memory device used for non-persistent storage of data. The memory  may include a timestamp memory buffer  corresponding to stamp module , a timestamp memory  and indirect buffers . During execution, memory  may have residing within it, one or more memory buffers  through which CPU  communicates commands to GPU . The memory buffers  may correspond to the graphics engines  or the engine blocks , as appropriate. Timestamp memory buffer  and memory buffers  may be ring buffers or other data structures suitable for efficient queuing of work items or command packets. In the instance of a ring buffer, command packets may be placed into and taken away from the memory buffers  in a circular manner. For purposes of illustration, memory buffers  may be referred to as ring buffers  herein.","The indirect buffers  may be used to hold the actual commands, (e.g., instructions and data). For example, when CPU  communicates a command packet to the GPU , the command packet may be stored in an indirect buffer  and a pointer to that indirect buffer  may be inserted in a ring buffer . As described herein below with respect to , the CPU , via driver , as a writer of the commands to ring buffers  and GPU  as a reader of such commands, may coordinate a write pointer and read pointer indicating the last item added, and last item read, respectively, in ring buffers .","The stamp module , timestamp memory buffer , and the timestamp memory  enable the use of one timestamp for all the graphic engines and still allow the graphic engines to run concurrently, when applicable. As described herein below, the graphic engines notify the stamp module  upon completion of an assigned task. A command packet stored in the timestamp memory buffer  is then executed, which writes the timestamp in timestamp memory . The timestamp memory is accessible by the graphics driver  and may also be used by the operating system in the CPU .",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2A","FIG. 2B","FIG. 2C"],"b":["200","210","215","235","200","202","204","205","208","204","212","214","215","220","222","224","230","270","272","274","276","235","235","240","200"]},"The above architecture provides a one-way communication from a host processor, (the writer as represented by driver ), to the GPU , (the reader as represented by the command processor ). Initially the read pointer  and the write pointer  point to the same location indicating that GFX ring  is empty. The GFX ring  has free space  into which the driver  may write a command packet corresponding to a task. The driver  then updates the write pointer  to one position past the last command packets or the first available space. The write pointer  and read pointer  are now pointing to different locations. The command processor  may fetch command packets at the read pointer  position and walks the read pointer  until it is equal to the write pointer .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 3A","FIG. 1"],"b":["300","110","105","1","135","1","145","305","110","150","310","160"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3B","b":["380","380","382","1","384","2","386","3","388","382","1","384","160","2","386","160","3","388"]},"Upon completion of the task by one of the engine blocks  . . . n  and in particular the associated command processor, the associated command processor signals the timestamp module  to execute the command packet in the timestamp ring  associated with the task (). In a non-limiting example, the signaling may be implementing using a semaphore. In particular, the timestamp module \/timestamp ring  waits for a semaphore bit to be set to one for the particular task. Other signaling methods may also be used. The timestamp module  determines the position of the read pointer (). If the read pointer is at the appropriate position in the timestamp ring , the timestamp module \/timestamp ring  executes the timestamp command packet and writes the timestamp to the timestamp memory  (). If the read pointer is not at the right position, then timestamp module \/timestamp ring  will wait until the read pointer is at the position of the completed task to write the timestamp ().",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4","b":["400","405","400","410","415","420","425","430","435","440","445"],"sub":["\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014"]},"For example, the task distributor  may distribute or submit task t_ to the DRMDMA2 engine and write a command packet to the DRMDMA2 ring . If a ring is traversed in a clockwise direction, task submission may be determined by a position of a write pointer (wp). In this instance, the wp is at the end of the ring block signifying that the t_ has been written to the DRMDMA2 ring . Again, if the ring is traversed in a clockwise direction, task completion may be evident from a particular ring by the position of a read pointer (rp). In this instance, the DRMDMA2 engine has consumed the commands to complete the task and has signaled the stamp ring  to output a timestamp, which in this case is \u201c19\u201d.","Similarly, task t_ was distributed and completed by the 3D2 engine corresponding to 3D2 ring , task t_ was distributed and completed by the 3D3 engine corresponding to 3D3 ring  and task t_ was distributed and completed by the DRMDMA1 engine corresponding to DRMDMA1 ring . The stamp ring  has therefore outputted timestamps \u201c20\u201d, \u201c21\u201d and \u201c22\u201d.","Task t_ was distributed to but not consumed by engine 3D4 corresponding to 3D4 ring . This may be seen by the position of the rp. The stamp ring  rp is also stopped and waiting for the signal from the engine 3D4 corresponding to 3D4 ring . In the meantime, task t_ which was distributed and completed by the 3D1 engine corresponding to 3D1 ring  and task t_ which was distributed and completed by the 3D3 engine corresponding to 3D3 ring , have signaled the stamp ring . The stamp ring  will wait until task t_ has been consumed by the 3D t4 engine. At that time, the stamp ring  will proceed to output the associated timestamps up to timestamp \u201825\u2019. The stamp ring  will then wait for the 3D2 engine corresponding to the 3D2 ring  to signal completion of the next task, which is task t_.","Embodiments of the present invention may be represented as instructions and data stored in a computer-readable storage medium. For example, aspects of the present invention may be implemented using Verilog, which is a hardware description language (HDL). When processed, Verilog data instructions may generate other intermediary data, (e.g., netlists, GDS data, or the like), that may be used to perform a manufacturing process implemented in a semiconductor fabrication facility. The manufacturing process may be adapted to manufacture semiconductor devices (e.g., processors) that embody various aspects of the present invention.","Although features and elements are described above in particular combinations, each feature or element may be used alone without the other features and elements or in various combinations with or without other features and elements. The methods provided may be implemented in a general purpose computer, a processor or any IC that utilizes timestamps. The methods or flow charts provided herein may be implemented in a computer program, software, or firmware incorporated in a computer-readable storage medium for execution by a general purpose computer or a processor. Examples of computer-readable storage mediums include a read only memory (ROM), a random access memory (RAM), a register, cache memory, semiconductor memory devices, magnetic media such as internal hard disks and removable disks, magneto-optical media, and optical media such as CD-ROM disks, and digital versatile disks (DVDs).","Suitable processors include, by way of example, a general purpose processor, a special purpose processor, a conventional processor, a digital signal processor (DSP), a plurality of microprocessors, one or more microprocessors in association with a DSP core, a controller, a microcontroller, Application Specific Integrated Circuits (ASICs), Field Programmable Gate Arrays (FPGAs) circuits, any other type of integrated circuit (IC), and\/or a state machine. Such processors may be manufactured by configuring a manufacturing process using the results of processed hardware description language (HDL) instructions (such instructions capable of being stored on a computer readable media). The results of such processing may be maskworks that are then used in a semiconductor manufacturing process to manufacture a processor which implements aspects of the present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A more detailed understanding may be had from the following description, given by way of example in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
