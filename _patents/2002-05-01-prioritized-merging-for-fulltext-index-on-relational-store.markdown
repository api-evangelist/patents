---
title: Prioritized merging for full-text index on relational store
abstract: A full-text search index system and method is generated by creating instances of a database index from an in-memory inverted list of keywords associated with a text identifier and the occurrences of the keyword in the text. Instances of the index are placed in a priority queue. A merge scheduling process determines when a merge should be initiated, selects instances of the index to be merged and selects a type of merge to perform.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07007015&OS=07007015&RS=07007015
owner: Microsoft Corporation
number: 07007015
owner_city: Redmond
owner_country: US
publication_date: 20020501
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention relates generally to the field of computing and in particular to full-text indexing in a database environment.","Full-text searching of unstructured and semi-structured data is becoming more and more important in the world of computing. For many years, the information-retrieval community has had to deal with the storage of documents and with the retrieval of documents based on one or more keywords. Since the burgeoning of the World Wide Web, and the feasibility of storing documents on-line, retrieval of documents based on keywords has become a thorny problem. A number of software solutions have been developed, such as those available from Hummingbird Software and IBM (e.g., LOTUS NOTES), which have attempted to address some of these problems.","A large portion of digitally stored information is presently stored in the form of unstructured textual data, both in plain text files and in formatted documents. Although the bulk of this textual data is stored in file systems, there are advantages to storing such data in relational databases. By doing so, the advantages of a database, including high-performance access, query capability, simple application-based user interfaces for end users, and secure remote access, are made available.","Relational Databases","Database management systems (DBMSs) such as Oracle and SQL Server are widely used to search structured data. It is impractical, however, to search unstructured data (e.g., text documents) the same way structured data is searched because doing so is too expensive.","For example, in order to retrieve information from structured data in a database, a user typically provides a query (written in a query language such as SQL), where the query specifies the structured information to be retrieved (the search term or terms), the field in which the search term is to be found and the manner in which the retrieved information is to be manipulated or evaluated in order to provide a useful result. To process the query, the database system typically converts the query into a relational expression that describes algebraically the result specified by the query. The relational expression is used to produce an execution plan, which describes particular steps to be taken by a computer to produce the requested result. Because the search term and the field where the search term is sought are specified, such results can be returned quickly. Indexes based on key fields, (e.g., an index based on name or social security number for a personnel database), routinely assist in efficient searching.","A similarly-conducted search for the same search term in unstructured data would require a word-by-word search of the entire text database and is unworkable.","Typically, today, an inverted index for searching documents is created by building a custom data structure external to the database system before a search query is entered. These solutions usually involve pulling data out of the database via bridges or gateways and storing the data as files in the file system so that textual indexing can be applied. Some systems actually store index data in a database but use an external engine to build and query the index. This approach does not provide a seamless way for a user to combine a textual query with a regular structured relational query and limits the extent to which a query can be optimized.","Typically, a full-text index is organized as a tree where internal nodes represent keywords and whose external nodes contain document identifiers and occurrences. When searched, the keyword(s) are looked up in the index and the documents containing the keyword(s) are retrieved. Naturally, whenever the collection of documents changes, a new index must be built or the existing index must be updated.","Although full text searching is frequently a capability of database management systems, the implementation of full-text search is typically unable to take advantage of the features of the database management system, which is to say, relational database management systems generally are unable to accommodate full-text searching of documents within the structure of the database. Typically, the index created to search the document database is not itself part of the database system (i.e., is separate from the database's index system). Because the index created is not part of the database system, certain limitations arise and certain highly advantageous aspects of database systems do not apply to typical full-text search systems.","Limitations associated with a full-text search system that relies on an external index include the following:\n\n","Similarly, some of the advantages of database management systems are not applicable to a full-text search system based on a custom index. For example, most database systems have excellent facilities for data recovery in the event of database degradation, however, these data recovery systems do not work for the index file because the index file is not a DBMS data store. Hence data corruption can be a frequent problem with a file system index file. If there is a hardware malfunction it is very difficult to efficiently reach a point where the documents database and the documents index are in sync because the two different systems have different protocols.","Backup and restore mechanisms for the index file generally do not have the advanced features typically available for database files, as discussed above.","Scalability issues exist for the index file. Scalability refers to partitioning one logical table into multiple physical tables on the same machine or on different machines in order to accommodate very large collections of data. For example, instead of storing a large database on a single resource, it is frequently desirable to split or partition the database across a number of resources. Database data stores generally maintain data in tables that can reside locally on a single data store or can be distributed among several data stores in a distributed database environment.","Advantages to partitioning are the reduction of processing load on a single resource, faster access to data and if a particular machine experiences a hardware failure, only part of the data is lost. Partitioning, however, is typically not available for a file system index file, because partitioning a file system file requires a separate infrastructure. Thus, typically the index file, although frequently very large, cannot be partitioned, so a single resource must be dedicated to the index.","Hence, a need exists in the art to provide a full-text searching system wherein the index is built upon standard database technology.","A full-text indexing system and method is built using standard database technology, (e.g., the Microsoft SQL SERVER storage and query engine). An inverted list is generated comprising keywords contained in data, (e.g., text), an identifier associated with the data and the occurrence(s) of the keyword in the list. An instance of a database index (part of the DBMS indexing system) is created and stored in a priority queue. A scheduling process determines when instances of the index are to be merged. Instances are prioritized by number of rows (keywords) and size. One of three types of merges is selected and the instances are merged.","Exemplary Computing Environment",{"@attributes":{"id":"p-0031","num":"0038"},"figref":"FIG. 1"},"Although not required, the invention can be implemented via an application programming interface (API), for use by a developer, and\/or included within the network browsing software which will be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers, or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0033","num":"0040"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . A graphics interface , such as Northbridge, may also be connected to the system bus .","Northbridge is a chipset that communicates with the CPU, or host processing unit , and assumes responsibility for accelerated graphics port (AGP) communications. One or more graphics processing units (GPUs)  may communicate with graphics interface . In this regard, GPUs  generally include on-chip memory storage, such as register storage and GPUs  communicate with a video memory . GPUs , however, are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","One of ordinary skill in the art can appreciate that a computer  or other client device can be deployed as part of a computer network. In this regard, the present invention pertains to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. The present invention may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.","Full-Text Indexing System","Full-text search indexing systems utilizing an external index may be implemented as shown in . Typically a group of documents  includes individual documents , , etc., one or more of which may be loaded into a database basetable of a DBMS . In general, a document is loaded into the columns of a row in the basetable, one document per column. The database system , including database management system engine  and data stores (databases) , typically associates document with a unique document identifier (called herein full-text key) which is used to identify the row in the basetable that contains the document. The text of document is provided to word breaker  by search engine . Word breaker  determines which words of the text of document should be keywords (also known as tokens). Word breaker  also determines the location(s) of the keyword in the document, as a number representing byte offset from the beginning of the document. In other words, if word breaker  determines that a key word of document is \u201cinnovation\u201d and the word \u201cinnovation\u201d is the first, fourteenth and twenty-fifth word in document , the word breaker  would typically return the keyword \u201cinnovation\u201d and the byte offsets at which the first, fourteenth and twenty-fifth words are located, to search engine . An index  of tokens or keywords is generated by an external executable such as a search engine . For each keyword associated with the text of document , an entry in index  would be created, typically containing the keyword and the occurrences of the keyword in document for each keyword in document ","For example, and referring now to , suppose a document of a collection of documents , including document , , etc., is loaded into a database basetable . Document is assigned a full-text key by the database management system . For example, database management system  may assign document the full-text key \u201c\u201d . The full-text key assigned by the database management system  typically is alphanumeric and can be rather large. Assume document full-text key   contains the text \u201cThis innovation is a significant step towards search and indexing technology.\u201d  somewhere within the document. When full-text key   is loaded into basetable , \u201cThis innovation is a significant step towards search and indexing technology\u201d is loaded into basetable  of database management system . The words \u201cThis innovation is a significant step towards search and indexing technology\u201d, for example, might be loaded into word locations  through  of a row in the content field  of basetable .","External search engine  may retrieve data associated with full-text key   from basetable  and send this data to word breaker . Typically a word breaker  would be invoked to pick out the keywords or tokens from the text of document . In the example, word breaker  has determined that the keywords contained in document include \u201cinnovation\u201d and \u201csignificant\u201d.","Word breaker  also typically determines the byte offset from the beginning of the document at which the keywords (also referred to as \u201ctokens\u201d) are found. For example, word breaker  may determine that \u201cinnovation\u201d can be found in document at byte offsets 237587100, 446861513 and 687771617, and that \u201csignificant\u201d can be found in document at byte offsets 237587778, 687888200, 687888514 and 852531700. This information may be passed back to search engine .","Search engine  typically uses this information to create index  and may convert byte offset to word offset. In the example described above, index  would contain keyword \u201cinnovation\u201d  followed by full-text key   followed by the locations (word offset)  at which \u201cinnovation\u201d can be found in the document, (i.e., , , ). Suppose another document (assigned a full-text key of \u201c\u201d) also contains the word \u201cinnovation\u201d at word locations ,  and . The index  in this case would contain an entry for full-text key   followed by the locations  at which \u201cinnovation\u201d can be found (i.e., , , ) in full-text key . Similar entries ,  for keyword \u201csignificant\u201d would also be generated for full-text key  and full-text key  (, ). Thus a file system index typically is created containing keywords, full-text keys for documents containing each keyword and the locations within each document containing the keyword specifying the location by word offset of the keyword in that document.","A user querying the database might ask, for example, for all the documents containing the words \u201cinnovation\u201d located near the word \u201csignificant\u201d. Depending on the specific query form, a table of results might be returned, listing the document numbers containing the words \u201cinnovation\u201d located near \u201csignificant\u201d. Additionally, a \u201crank\u201d for each document is also typically returned, where the rank is based on some proprietary formula, (such as, ranked by number of times the word(s) appeared in the document, whether the requested word(s) appeared in the title of the document, etc.). Rank typically reflects the relevance of the document to the search query.","Index  is typically a structure built on the file system and is not a database file and therefore is subject to the limitations in recoverability, reliability, management and scalability described above.","Full-text Indexing on Relational Store",{"@attributes":{"id":"p-0050","num":"0057"},"figref":["FIG. 4","FIG. 4"],"b":["210","210","210","416","202","210","406","406","406","416","402","206","207","406","404","206","406","406","406","410","410","410","410","410","410","408","414","414","414","412","412","412","412","408"],"i":["a","b","a","b","a","b ","a","b","a","b","a","b","a","b"]},{"@attributes":{"id":"p-0051","num":"0058"},"figref":["FIG. 5","FIG. 5"],"b":["406","406","406","406","406","410","410","410","416"],"i":["a","b","a","b ","a","b"]},"At step , a new batch scan transaction is begun. Each batch begins with a new transaction. At step , a row of data is retrieved from basetable . A thread from thread pool  scans basetable  and stores data (i.e., text) from a row of basetable  in text shared memory . For example, thread may scan row 1 of basetable , storing the row in chunks in shared text memory  at some location in the shared memory associated with thread ","At step  a unique numeric document identifier, (referred to as DocId henceforth), is generated, which preferably translates a (sometimes) large full-text key that is not necessarily numeric in nature to a compact numerical identifier, called herein \u201cDocId\u201d. For example, full-text key  may be translated to DocId \u201c1\u201d and full-text key  may be translated to DocId \u201c2\u201d. A table that maps full-text keys to DocIds is maintained, preferably keyed on full-text key. As each row is crawled, the new unique DocId generated is stored as well in text shared memory .","Text shared memory  preferably can be accessed by word breaker . As the rows are crawled, the full-text columns stored in shared memory  are parsed by filters and word breakers, collectively represented by reference numeral  of . Filters typically are modules that parse formatted documents, (e.g., WORD documents or POWERPOINT documents) and emit chunks of text to be parsed by word breaker .","Word breaker  may retrieve, for example, the data contained in row 1 of basetable  stored in shared text memory , and determine which of the words in the document are keywords. For each of the words determined by word breaker  to be a keyword, the location(s) of that keyword in the document is determined. Word breaker  writes the keyword and occurrence information for each DocId to keyword shared memory .","At step , a thread (e.g., thread ) picks up the keyword, the DocId and the occurrences of the keyword from keyword shared memory and inserts them into an inverted list, called herein InvertedList, associated with the batch.","InvertedList preferably is a short in-memory list of keywords and keyword occurrences. An inverted list is generated for the batch of documents processed by the thread, transaction by transaction. Alternatively, more than one inverted list is generated per batch of documents.","InvertedList, as illustrated by , is preferably implemented as an in-memory balanced tree,  of keywords , , etc. found in the documents processed in the batch. In one embodiment, for each keyword, a heap of DocIds ,  and ,  containing that keyword is maintained. For each DocId ,  and ,  in the heap, a sorted list of locations ,  and ,  (word position, preferably implemented as word offset, which is the same as the basetable  word location) is maintained, where the respective keyword appears in the document. This information is preferably stored in local memory (not shown) associated with thread ","Rows from the basetable  are processed until it is determined that the batch is complete (step ). Batches may be determined to be complete because the available memory space is waning (amount of free memory has reached some configurable parameter) or when some configurable parameter representing a number of documents processed has been reached. When the batch is complete, at step , thread creates an instance of index , (e.g., index ). Index  is a standard database table, (e.g., a SQL B-tree). A database table containing meta-data about instances of index  is also updated. In the example, the meta-data table is updated to reflect index instance . This table is called herein FtIndex_Dictionary. The relevant structure of an exemplary FtIndex_Dictionary is depicted in , (i.e., FtIndex_Dictionary may include additional entries).\n\n","After the inverted list is persisted into an instance of an index and DocIdMap has been updated for the batch of rows processed by the thread, the batch is committed (e.g., SQL commit) at step . The 2-part commit transaction ascertains that all locks and resources are acquired and then performs the disk writes. The commit transaction guarantees that no document in a batch is partially committed. If all locks and resources are not acquired, the database changes are entirely backed out. As soon as an instance of an index is committed the index is queryable.",{"@attributes":{"id":"p-0061","num":"0074"},"figref":"FIG. 8","b":"800"},"Keyword  represents a normalized keyword from the document as determined by word breaker . Preferably Keyword  is a variable-length binary of maximum length 132 bytes. Keyword preferably is normalized for case and diacritical marks, based on a user's configuration. Propertyld  represents the column id of an attribute such as Title, Author, Content, etc. DocIdList  is a list of DocIds in which Keyword  appears. Preferably, the list of DocIds is compressed bit-wise as a BLOB, a Binary Large Object (i.e., a collection of binary data stored as a single entity). DocCount  is the number of documents containing the keyword, DocIdMin  is the smallest DocId stored in DocIdList . DocIdMax  is the largest DocId stored in DocIdList . OccListList  is a list of occurrence lists, one occurrence list for each DocId in DocIdList . OccCountList  is the number of occurrences in the corresponding occurrence lists for corresponding DocIds. Index fragments are indexed by a cluster index on (Keyword , PropertyId  and DocIdMin ).","An InvertedList is persisted by inserting one or more rows for each keyword in InvertedList into a new instance of FtIndex. DocIdList  is generated by compressing sorted DocIds from InvertedList into a binary stream. Occurrences of the keyword from InvertedList are also compressed into a binary stream for each DocId containing the keyword. Occurrence lists of two consecutive DocIds stored in OccListList  are preferably separated by a sentinel in the compressed stream to delimit the end of one occurrence list from the beginning of the next occurrence list. When the InvertedList is persisted into an instance of FtIndex and FtIndex is committed, the state of that instance of FtIndex becomes StateClosed. The number of DocIdList BLOBs stored in a row in an instance of FtIndex is preferably limited by a parameter. At step , the instance of FtIndex is added to priority queue .","Merging","Periodically, instances of index  (e.g., FtIndex) are merged into fewer instances. Merging instances of the index improves query performance because fewer indexes have to be checked when a query is processed. Merging instances into fewer instances also optimizes the amount of storage and memory required because data repeated in index instances is eliminated (e.g., FtIndex_A and FtIndex_B may both contain the keyword \u201cinnovation\u201d so that two rows (one in FtIndex_A and one in FtIndex_B) can be combined into one row in FtIndex_X). Finally, the number of I\/O (input\/output) operations is reduced because when the merged index is rewritten, related data is physically located closer together.",{"@attributes":{"id":"p-0065","num":"0078"},"figref":"FIG. 9","b":["900","901","902"]},"It is desirable to merge indexes of approximately the same size for efficiency considerations. The priority queue of indexes is preferably implemented as a heap data structure having the sort order: (IndRows, IndDataSize) so that the smallest index in that order is located at the top of the heap. Hence, as indexes are selected from the priority queue in step  for merging, indexes containing less data are selected before those containing more data. It will be appreciated that an alternative to sorting in ascending order and selecting from the top of the queue is sorting in descending order and selecting from the bottom of the queue. At step  an index is selected to merge. Indexes are pulled from priority queue  until any of the following conditions occur. It should be understood that the order of the steps ,  and  has been selected for exemplary purposes only and in practice any ordering or combination of these steps may be implemented by the conceived invention. A counter, called herein SelectedIndexCounter, that tracks the number of indexes selected to merge, is incremented. In one embodiment of the invention, a configurable parameter referred to herein as MergeFanout determines the preferred number of indexes to be merged in one merge. At step , SelectedIndexCounter is compared to MergeFanout. If MergeFanout is reached or exceeded, processing continues at step . If MergeFanout is not reached, processing continues at step .","It is desirable to merge indexes of approximately the same size; however, even indexes of the same overall size may merge inefficiently. For example, FtIndex001 and FtIndex002 may be approximately the same size but FtIndex001 may have a small number of keywords (rows) with a large number of associated DocIds and associated data while FtIndex002 may have a larger number of keywords (rows) with a smaller number of documents associated therewith. Alternatively, FtIndex001 and FtIndex002 may have approximately the same number of unique keys (rows) but FtIndex001 may reflect the indexing of far more documents than does FtIndex002. Hence, steps  and  are performed. At step  IndRows  for the selected index is compared to the average number of rows in the other selected indexes. If IndRows  for the selected index is much greater than the average, processing continues at step . If not, processing continues at step . At step , IndDataSize for the last index selected is compared to the average IndDataSize of the other selected indexes. If IndDataSize for the last index selected is much greater than the average, processing continues at step . If IndDataSize for the last index selected is not much greater than the average, processing continues at step  in which the index is added to MergeList and the next index is selected from the merge queue (step ).","At step , the last selected index is returned to the priority queue and processing continues at step . At step , the selected indexes (in MergeList) are merged. Merging preferably can occur in one of three ways. illustrates a first merge strategy in accordance with one aspect of the invention. In MergeOutOfPlace, indexes selected from the priority queue  (represented by exemplary indexes I, I, . . . I) are merged in the order of (Keyword, Propertyld) to form a merged DocIdList, OccListList and OccCountList and the merged rows are inserted into a new index (e.g., In ). This type of merge is preferably performed when most of the rows need to be updated. MergeOutOfPlace is typically very fast because a bulk insert can be performed.",{"@attributes":{"id":"p-0069","num":"0082"},"figref":"FIG. 10","i":"b ","sub":["0 ","1 ","n-1 ","n ","0 ","1 ","n-1 ","n "],"b":["1002","1004","1006","1008","1008","1010","1002","1004","1006","1008"]},{"@attributes":{"id":"p-0070","num":"0083"},"figref":"FIG. 10","i":"c ","sub":["0 ","1 ","n-1 ","n ","n ","n ","0 ","1 ","n-1 "],"b":["1002","1004","1006","1008","1008","1008","1002","1004","1006"]}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0019","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0028"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0022","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0031"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0032"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0033"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0034"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0035"},"figref":"FIG. 10","i":"a "},{"@attributes":{"id":"p-0029","num":"0036"},"figref":"FIG. 10","i":"b "},{"@attributes":{"id":"p-0030","num":"0037"},"figref":"FIG. 10","i":"c "}]},"DETDESC":[{},{}]}
