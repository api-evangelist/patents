---
title: Automatic kernel migration for heterogeneous cores
abstract: A system and method for automatically migrating the execution of work units between multiple heterogeneous cores. A computing system includes a first processor core with a single instruction multiple data micro-architecture and a second processor core with a general-purpose micro-architecture. A compiler predicts execution of a function call in a program migrates at a given location to a different processor core. The compiler creates a data structure to support moving live values associated with the execution of the function call at the given location. An operating system (OS) scheduler schedules at least code before the given location in program order to the first processor core. In response to receiving an indication that a condition for migration is satisfied, the OS scheduler moves the live values to a location indicated by the data structure for access by the second processor core and schedules code after the given location to the second processor core.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08683468&OS=08683468&RS=08683468
owner: Advanced Micro Devices, Inc.
number: 08683468
owner_city: Sunnyvale
owner_country: US
publication_date: 20110516
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF EMBODIMENTS OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","This invention relates to computing systems, and more particularly, to automatically migrating the execution of work units between multiple heterogeneous cores.","2. Description of the Relevant Art","The parallelization of tasks is used to increase the throughput of computer systems. To this end, compilers may extract parallelized tasks from program code to execute in parallel on the system hardware. With a single-core architecture, a single core may include deep pipelines configured to perform multi-threading. To further increase parallel execution on the hardware, a multi-core architecture may include multiple general-purpose cores. This type of architecture may be referred to as a homogeneous multi-core architecture. This type of architecture may provide higher instruction throughput than a single-core architecture.","Some software applications may not be divided frequently into parallel tasks. In addition, specific tasks may not efficiently execute on a general-purpose core. Particular instructions for a computational intensive task may cause a disproportionate share of a shared resource, which delays a deallocation of the shared resource. Examples of such specific tasks may include cryptography, video graphics rendering and garbage collection.","To overcome the performance limitations of conventional general-purpose cores, a computer system may offload specific tasks to special-purpose hardware. This hardware may include a single instruction multiple data (SIMD) parallel architecture, a field-programmable gate array (FPGA), and other specialized cores. A type of architecture with different types of cores may be referred to as a heterogeneous multi-core architecture. Depending on the scheduling of tasks, this type of architecture may provide higher instruction throughput than a homogeneous multi-core architecture.","In many cases, particular software applications have data parallelism in which the execution of each work item, or parallel function call, is data dependent within itself. For example, a first work item may be data independent from a second work item, and each of the first and the second work items are scheduled on separate paths within a core with a SIMD micro-architecture. However, an amount of instructions executed within each of the first and the second work items may be data-dependent. A conditional test implemented as a branch instruction may pass for the first work item, but fail for the second work item dependent on the data for each work item.","The efficiency of parallel execution may be reduced as the second work item halts execution and waits as the first work item continues with its ongoing execution. The inefficiency grows when only a few work items continue execution due to passed tests whereas most of the work items are idle due to failed tests. After efficient, functionality-matching assignment of the work items by an OS scheduler in a heterogeneous multi-core architecture, system performance may still be reduced due to the data-dependent behavior of particular software applications.","Systems and methods for automatically migrating the execution of work units between multiple heterogeneous cores are contemplated.","In one embodiment, a computing system includes a first processor core with a first micro-architecture and a second processor core with a second micro-architecture different from the first micro-architecture. In one embodiment, the first micro-architecture is a single instruction multiple data (SIMD) micro-architecture and the second micro-architecture is a general-purpose micro-architecture. The computing system includes a memory coupled to each of the first and the second processor cores. The memory stores a computer program comprising one or more compute kernels, or function calls. As a compiler traverses the instructions of a given function call, the compiler is configured to predict execution of the function call migrates at a given location to a different processor core. The compiler creates a data structure to support moving live values associated with the execution of the function call at the given location. Such live values may be referred to as a \u201ccontext\u201d.","A scheduler within an operating system (OS) schedules at least code before the given location in program order to the first processor core. In response to receiving an indication that a condition for migration is satisfied, the OS scheduler moves the live values to a location indicated by the data structure for access by the second processor core and schedules code after the given location in program order to the second processor core. In order to determine whether a migration condition is satisfied, each of the first and the second processor core is configured to determine whether a number of parallel executing iterations of the function call that have reached an exit point is above a given threshold.","These and other embodiments will be further appreciated upon reference to the following description and drawings.","While the invention is susceptible to various modifications and alternative forms, specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood, however, that drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the invention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","In the following description, numerous specific details are set forth to provide a thorough understanding of the present invention. However, one having ordinary skill in the art should recognize that the invention might be practiced without these specific details. In some instances, well-known circuits, structures, and techniques have not been shown in detail to avoid obscuring the present invention.","Referring to , one embodiment of an exemplary processing node  with a heterogeneous multi-core architecture is shown. Processing node  may include one or more processing units , which may include one or more processor cores  and an associated cache memory subsystem . In one embodiment, processor core  utilizes a general-purpose micro-architecture.","Processing node  may also include one or more processing units , which may comprise one or more processor cores  and data storage buffers . Processor core  may not be a mirrored silicon image of processor core . Processor core  may have a micro-architecture different from the micro-architecture used by processor core . In one embodiment, the processor core  may be a different generation of a same processor family as processor core . In another embodiment, the processor core  may be a voltage and\/or frequency scaled version of processor core . In other words, the processor core  is not a silicon copy of the processor core  with a same functionality and instruction set architecture (ISA), a same clock frequency, same cache sizes, a same memory model, and so forth.","Continuing with the micro-architecture of processor core , in yet another embodiment, the processor core  may comprise a micro-architecture that provides high instruction throughput for a computational intensive task. Processor core  may have a parallel architecture. For example, the processor core  may be a single instruction multiple data (SIMD) core. Examples of SIMD cores include graphics processing units (GPUs), digital signal processing (DSP) cores, or other. In one embodiment, the processing node  comprises a single instruction set architecture (ISA). Typically, as is well known in the art, single-ISA multi-core architectures have been shown to provide higher power and throughput performances for chip multiprocessors (CMP).","High instruction throughput on processing node  may be achieved with measured power consumption within a given power limit when threads of software applications are efficiently scheduled. The threads may be scheduled on one of processor cores  and  in a manner that each thread has the highest instruction throughput based at least in part on the runtime hardware resources of the processor cores  and .","Continuing with the components in the processing node , the processing node  may include memory controller , and interface logic . In one embodiment, the illustrated functionality of processing node  is incorporated upon a single integrated circuit. In one embodiment, processor cores  include circuitry for executing instructions according to a predefined general-purpose instruction set. For example, the SPARC\u00ae instruction set architecture (ISA) may be selected. Alternatively, the x86, x86-64\u00ae, Alpha\u00ae, PowerPC\u00ae, MIPS\u00ae, PA-RISC\u00ae, or any other instruction set architecture may be selected. Generally, processor core  accesses the cache memory subsystems , respectively, for data and instructions. If the requested block is not found in cache memory subsystem  or in shared cache memory subsystem , then a read request may be generated and transmitted to the memory controller within the node to which the missing block is mapped.","In one embodiment, processing unit  is a graphics processing unit (GPU). Modern GPUs are very efficient at manipulating and displaying computer graphics. The highly parallel structure of GPUs makes them more effective than general-purpose central processing units (CPUs), such as processing unit , for a range of complex algorithms. Typically, a GPU executes calculations used for graphics and video and a CPU executes calculations for many more system processes than graphics alone. Conventional GPUs utilize very wide single instruction multiple data (SIMD) architectures to achieve high throughput in image-rendering applications. Such applications generally entail executing the same programs, such as vertex shaders or pixel shaders, on large numbers of objects (vertices or pixels). Since each object is processed independently of other objects, but the same sequence of operations is used, a SIMD micro-architecture provides considerable performance enhancement. GPUs have also been considered for non-graphical calculations.","In one embodiment, the GPU  may be located on a video card. In another embodiment, the GPU  may be integrated on the motherboard. In yet another embodiment, the illustrated functionality of processing node  may be incorporated upon a single integrated circuit. In such an embodiment, the CPU  and the GPU  may be proprietary cores from different design centers. Also, the GPU  may now be able to directly access both local memories  and  and main memory via memory controller  from the processing node , rather than perform memory accesses off-chip via interface . This embodiment may lower latency for memory accesses for the GPU , which may translate into higher performance.","Continuing with the components of processing node  in , cache subsystems  and  may comprise high-speed cache memories configured to store blocks of data. Cache memory subsystems  may be integrated within respective processor cores . Alternatively, cache memory subsystems  may be coupled to processor cores  in a backside cache configuration or an inline configuration, as desired. Still further, cache memory subsystems  may be implemented as a hierarchy of caches. Caches that are located nearer processor cores  (within the hierarchy) may be integrated into processor cores , if desired. In one embodiment, cache memory subsystems  each represent L2 cache structures, and shared cache subsystem  represents an L3 cache structure. Both the cache memory subsystem  and the shared cache memory subsystem  may include a cache memory coupled to a corresponding cache controller.","Generally, packet processing logic  is configured to respond to control packets received on the links to which processing node  is coupled, to generate control packets in response to processor cores  and\/or cache memory subsystems , to generate probe commands and response packets in response to transactions selected by memory controller  for service, and to route packets for which node  is an intermediate node to other nodes through interface logic . Interface logic  may include logic to receive packets and synchronize the packets to an internal clock used by packet processing logic .","Tuning now to , one embodiment of source code utilizing compute kernels is shown. OpenCL\u2122 (Open Computing Language) is one example of a low-level application programming interface (API) for heterogeneous computing. OpenCL includes a C-like language that defines execution queues, wherein each queue is associated with an OpenCL device. An OpenCL device may be a CPU, a GPU, or other unit with at least one processor core within the heterogeneous multi-core architecture. A function call may be referred to as an OpenCL kernel, or simply a \u201ccompute kernel\u201d. The OpenCL framework may improve computing performance for a wide variety of data-parallel applications used in gaming, entertainment, science and medical fields. For a heterogeneous architecture, a computer program typically comprises a collection of compute kernels and internal functions. A software programmer may define the compute kernels, whereas the internal functions may be defined in a given library.","For a data-parallel software application, an N-Dimensional computation domain may define an organization of an \u201cexecution domain\u201d. The N-Dimensional computation domain may also be referred to as an N-Dimensional grid or an N-Dimensional Range (\u201cNDRange\u201d). The NDRange may be a one-, two-, or three-dimensional space. Note that some embodiments may allow more than three-dimensional data. This dimensional space may also be referred to as an index space. For example, a software application may perform data processing on a two-dimensional (2D) array of data, such as an image file. The software application may perform an algorithm developed by a software programmer on a pixel-by-pixel basis of a 2D image or an element-by-element basis of a two-dimensional matrix. A given compute kernel may be invoked over the index space (the NDRange). In other embodiments, a software application may include an algorithm that utilizes data-parallel programming for electrostatic potentials mapping on a 3D lattice and direct coulomb summation used in macromolecular modeling.","Typically after compilation, the arguments and parameters of each compute kernel are set. Additionally, associated memory objects and buffers are created. A given instance of the compute kernel may be executed as its own software thread. However, a compute kernel may include control flow transfer instructions that create forks, whereas a fork in a computer program typically creates a software thread, by common definition. A given instance of the compute kernel at a given point in the index space may be referred to as a \u201cwork item\u201d. A work item may also be referred to as a work unit. A work unit may operate with the one or more instructions in the compute kernel on a record of data corresponding to a given pixel (a given index) of the 2D image. Typically, work units have an associated unique identifier (ID). In another example, an introductory computer program processing the string \u201cHello World\u201d may have one work unit for computing each letter in the string.","The NDRange may define a total number of work units that execute in parallel if there is sufficient hardware support. For example, the NDRange may define a number of 280 work units, but a GPU may support the simultaneous execution of 64 work units at any given time. The total number of work units may define a global work size. As is well known to those skilled in the art, the work units may be further grouped into work groups. Each work group may have a unique identifier (ID). The work units within a given work group may be able to communicate with each other and synchronize execution and coordinate memory accesses. A number of work units may be clustered into a wave front for simultaneous execution on a GPU in a SIMD manner. Regarding the example above for 280 total work units, a wave front may include 64 work units.","The OpenCL framework is an open programming standard for various compute thereby improving code portability. Other frameworks are available and may offer more vendor-specific coding for heterogeneous architectures. For example, NVIDIA offers Compute Unified Device Architecture (CUDA\u00ae) and AMD offers ATI Stream\u00ae. With a CUDA framework, a compute kernel is typically statically compiled when the computer program is compiled. With an OpenCL framework, a compute kernel is typically compiled with a Just-In-Time (JIT) method. The JIT method may generate an appropriate binary code after obtaining the system configuration. With a JIT compilation method, the compilation time is included with the total execution time. Therefore, compiler optimizations may increase the execution time. In addition, at run time the OpenCL compiler may generate multiple versions of compute kernels. One version of a compute kernel may be generated for each type of OpenCL device type, such as a general-purpose CPU, a SIMD GPU, and so forth.","The two frameworks, OpenCL and CUDA, have a difference in terminology between their respective execution models. For example, a work unit, a work group, a wave front and an NDRange in OpenCL have corresponding terms in CUDA such as a thread, a thread block, a warp and a grid. Throughout the rest of the description, the terms corresponding to OpenCL are used. However, the systems and methods described may apply to CUDA, ATI Stream and other frameworks.","As shown in , code  defines two function calls generally titled \u201cdoWorkA\u201d and \u201cdoWorkB\u201d. Each function call may be referred to as a \u201ccompute kernel\u201d. A compute kernel may be matched with one or more records of data to produce one or more work units of computation. Therefore, two or more work units may utilize the same instructions of the single function call, but operate on different records of data. For example, the function call \u201cPower2\u201d in code  may be used to execute  work units, one for each data value in the array \u201cINPUT\u201d. Here, a record comprises a single data value. In other examples, a record may comprise two or more fields, wherein each field includes a data value. A SIMD micro-architecture may efficiently execute the instructions of the kernel \u201cPower2\u201d, calculate the power of 2 for the values in the INPUT array and write the output to the RESULT array.","The OpenCL framework may invoke an instance of a compute kernel multiple times in parallel. Each call to the compute kernel has one associated unique ID (a work unit ID) that may be fetched by calling an internal function named get_global_id(). Regarding the above example in code , the compute kernel \u201cPower2\u201d is invoked once for each data value in the INPUT array. In this case, the compute kernel \u201cPower2\u201d is invoked 10 times. Accordingly, ten unique work unit IDs are fetched. With a JIT compiling method, these instances are invoked at runtime. The OpenCL framework may differentiate between these different instances by utilizing the unique work unit IDs. The data to be operated on (a record) may also be specified, such as a specific data value in the INPUT array. Therefore, at runtime, a work unit may be scheduled by default to the same OpenCL device as the associated compute kernel is scheduled.","Turning now to , one embodiment of source code defining compute kernels with conditional statements is shown. Similar to code , the code  shown in  defines two function calls generally titled \u201cdoWorkA\u201d and \u201cdoWorkB\u201d. Again, each function call may be referred to as a \u201ccompute kernel\u201d. Here, only one of the two compute kernels is executed during runtime. The selection of which compute kernel is executed is based on a conditional test provided by the function call \u201cEvaluateFunction\u201d. A result of a given instruction or whether the given instruction is executed is data-dependent on the execution of previous instructions and data corresponding to an associated record. If the result of the conditional test is not consistent among a wave front of work units, the benefits of a SIMD micro-architecture may be reduced. For example, a given SIMD core may have 64 parallel computation units available for simultaneous execution of 64 work units. However, if half of the 64 work units pass the conditional test while the other half fails the conditional test, then only half of the parallel computation units are utilized during a given stage of processing.","Turning now to , a generalized block diagram illustrating one embodiment of scheduled assignments  between hardware resources and compute kernels is shown. Here, the partitioning of hardware and software resources and their interrelationships and assignments during the execution of one or more software applications  is shown. In one embodiment, an operating system  allocates regions of memory for compute kernels -and -. When applications , or computer programs, execute, each application may comprise multiple compute kernels. For example, a first executing application may comprise compute kernels -and a second executing application may comprise compute kernels -. Each one of the kernels -may be used to generate one or more work units by being combined with one or more records of data (not shown). For example, compute kernel may produce work units -, compute kernel may produce work units -, compute kernel may produce work units -and compute kernel may produce work units -. A work unit may execute independently of other work units and execute concurrently with other work units.","Each of the compute kernels shown in  may own its own resources such as an image of memory, or an instance of instructions and data before application execution. Each of the compute kernels may also comprise process-specific information such as address space that addresses the code, data, and possibly a heap and a stack; variables in data and control registers such as stack pointers, general and floating-point registers, program counter, and otherwise; operating system descriptors such as stdin, stdout, and otherwise; and security attributes such as a set of permissions.","In one embodiment, hardware computing system  incorporates a general-purpose processor core  and a SIMD processor core , each configured to process one or more work units. In another embodiment, system  includes two other heterogeneous processor cores. In general, for a given application, operating system  sets up an address space for the application, loads the application's code into memory, sets up a stack for the program, branches to a given location inside the application, and begins execution of the application. Typically, the portion of the operating system  that manages such activities is the operating system (OS) kernel . The OS kernel  is referred to as \u201cOS kernel\u201d in order not to confuse it with a compute kernel, or a function call. The OS kernel  may further determine a course of action when insufficient memory is available for the execution of the application. As stated before, an application may be divided into more than one compute kernel and system  may be running more than one application. Therefore, there may be several compute kernels running in parallel. The OS kernel  may decide at any time which of the simultaneous executing compute kernels is allocated to the processor cores  and . The OS kernel  may allow a process to run on a core of a processor, which may have one or more cores, for a given amount of time referred to as a time slice. An OS scheduler  in the operating system  may comprise decision logic for assigning compute kernels to cores.","In one embodiment, only one compute kernel can execute at any time on any one of the hardware computation units -and -. These hardware computation units comprise hardware that can handle the execution of a given instruction of a given work unit with associated data. This hardware may include an arithmetic logic unit that is configured to perform addition, multiplication, zero detect, a bit-wise shift, division, video graphics and multimedia instructions or other operations known to those skilled in the art of processor design. These hardware computation units may include a hardware thread in a multi-threaded processor, a parallel hardware column in a SIMD micro-architecture, and so forth.","The dashed lines in  denote assignments and do not necessarily denote direct physical connections. Thus, for example, hardware computation unit may be assigned to execute work unit . However, later (e.g., after a context switch), the hardware computation unit may be assigned to execute work unit . In one embodiment, the OS scheduler  may schedule the work units -to the hardware computation units -with a round-robin scheme. Alternatively, the OS scheduler  may schedule the work units -to the cores  and  with a round-robin scheme. An assignment of a given work unit to a given hardware computation unit may be performed by an associated processor core. In another embodiment, the OS scheduler  may perform the scheduling based on availability of the processor cores  and . In yet another embodiment, the OS scheduler  may perform the scheduling according to assignments created by a programmer utilizing the OpenCL\u2122 API or another similar API. These scheduling schemes may restrict portability and performance when there is a mismatch between the work unit assignments and hardware resources.","Referring to , a generalized block diagram illustrating one embodiment of a logical layout of micro-architectures for two types of processor cores is shown. Although each of a general-purpose core  and a single instruction multiple data (SIMD) core  is shown, other types of heterogeneous cores are possible and contemplated. Each of the cores  and  have a dynamic random access memory (DRAM) and for storage of data and instructions. In one embodiment, the cores  and  share a same DRAM. In another embodiment, a given level of a cache memory subsystem (not shown) is shared in addition to the DRAM. For example, referring again to , the cache memory subsystem  is shared by the cores  and .","Each of the cores  and  may include a cache memory subsystem . As shown, the general-purpose core  logically has the cache memory subsystem  separate from the control logic  and the arithmetic logic units (ALUs) . The data flow within the core  may be pipelined, although storage elements, such as pipeline registers, are not shown in order to simplify the illustration. In a given pipeline stage, an ALU may be unused if instructions in this stage do not utilize a certain type of ALU or if another work unit (or another thread for a general-purpose core) consumes the ALUs during this stage.","As shown, the SIMD core  has the cache memory subsystem  grouped with control logic  for each row of computation units . The data flow within the core  may be pipelined, although storage elements, such as pipeline registers, are not shown in order to simplify the illustration. In a given pipeline stage, a computation unit may be unused if an associated instruction in this stage is not executed based on a previous failed test, such as a not-taken branch.","Referring now to , a generalized block diagram illustrating one embodiment of a general-purpose pipeline execution flow  is shown. Instructions - may be fetched and enter a general-purpose pipeline. Instruction  may be a computation intensive instruction. During particular stages of the pipeline execution flow, one or more of the instructions - consume resources in the general-purpose processor core , such as decoder logic, instruction scheduler entries, reorder buffer entries, ALUs, register file entries, branch prediction units, and so forth.","In a balanced scheme, each of the instructions - consume an equal amount of resources each stage. However, typically, a general-purpose core does not replicate resources for each instruction due to semiconductor real-estate cost, power consumption and other design considerations. Therefore, the workload may become unbalanced. For example, the instruction  may consume more resources for one or more pipe stages due to its computation intensive behavior. As shown, the resources  consumed by this instruction may become far greater than the resources consumed by other instructions. In fact, the computation intensive instruction may block the usage of hardware resources by other instructions.","Some computation intensive tasks may place pressure on shared resources within the general-purpose core  shown in . Thus, throughput losses occur for both the computational intensive process and other processes waiting for the shared resources. In addition, some instructions may occupy the shared resource and other resources to support the computation being performed on the shared resource. Such a long latency instruction may concurrently block other processes from using several resources during a long latency.","Referring now to , a generalized block diagram illustrating one embodiment of a SIMD pipeline execution flow  is shown. Instructions - may be fetched and enter a SIMD pipeline with associated data. Instruction  may be a control flow transfer instruction, such as a conditional branch. The instruction  may be a first instruction in a path executed when the condition is true. The instruction  may be a first instruction in a path executed when the condition is false. For example, the branch instruction  may be associated with an IF statement in a high-level language program. The instruction  may be associated with a THEN statement in the high-level language program. The instruction  may be associated with an ELSE statement in the high-level language program.","Each of the computation units within a given row may be a same computation unit. Each of these computation units may operate on a same instruction, but different data associated with a different work unit. As shown, some of the work units pass the test provided by the conditional branch instruction  and other work units fail the test. The SIMD core  may execute each of the available paths and selectively disable the execution units, such as the computation units, corresponding to work items that did not choose the current path. For example, during execution of an If-Then-Else construct statement, within each column of a SIMD architecture are execution units configured to execute the \u201cThen\u201d (Path A) and the \u201cElse\u201d (Path B) paths. The efficiency of parallel execution may be reduced as the first and the second work units pause execution and wait as the third work unit continues with its ongoing execution. Therefore, not all of the computation units are active computation units  in a given row after execution of the branch instruction . As shown, one or more computation units are inactive computation units  that have been disabled for execution. If a large number of computation units are inactive during a given pipe stage, the efficiency and throughput of the SIMD core is reduced.","In one embodiment, an \u201cElse\u201d path is a return for the compute kernel. Execution of the compute kernel ends and the corresponding work unit becomes idle. However, neighboring work units in the SIMD core may continue executing. Referring now to , a generalized block diagram illustrating another embodiment of a SIMD pipeline execution flow  is shown. Similar to execution flow , instructions - may cause one or more computation units to be disabled in a particular row of the SIMD core. Here, each \u201cElse\u201d path may be a return for a compute kernel. Therefore, for a given work unit, a branch resolving in a not-taken direction may cause the given work unit to cease further execution of the compute kernel. In execution flow , only one instruction is shown between a first branch instruction  and a second branch instruction  for ease of illustration. However, multiple instructions may be between the branch instructions  and . Regardless of the number of instructions between the branches  and , work units that resolve the first branch  in a not-taken direction may complete execution. Similarly for branch , work units that resolve the second branch in a not-taken direction may complete execution. Computation units for later stages of a SIMD core may be disabled for these work units. If a large number of computation units are inactive during a given pipe stage, the efficiency and throughput of the SIMD core is reduced.","One example of an application that may cause multiple work units to fail a test and cease execution while neighboring work units may continue is face detection. As known to those skilled in the art, face detection as implemented in OpenCv (Open Computer Vision library) is one application of the Viola-Jones object detection algorithm. The Viola-Jones algorithm exhibits a data-dependent execution pattern. A search compute kernel is applied to a record of data, which may include one or more pixels. The search compute kernel searches for faces in a sub-window of a two-dimensional (2D) or a three-dimensional (3D) image. Within the compute kernel, there may be a cascade of tests implemented as control flow transfer instructions, such as branch instructions. In one typical example, a cascade of tests comprises 22 stages, or 22 tests. This cascade of tests may determine whether an input window contains a face.","The cascade of tests in the Viola-Jones algorithm may be designed to prune unpromising paths quickly. Therefore, most work units may determine the non-existence of a face and finish. The execution of work units continues on the remaining pixels that are likely to contain a face. A small fraction of pixels (i.e. work unit executions) may continue through the 22 stages, whereas most pixels are found not to contain faces after a few initial stage tests. Even with large task parallelism, the presence of a few continuing work units on a wavefront may cause low SIMD core utilization. One method described below utilizes a separate heterogeneous core while releasing the SIMD core for further processing. This method may increase overall computing performance when it is detected that a small amount of SIMD parallelism is present.","Turning now to , one embodiment of code  including a tagged branch to define a migration point is shown. The code  comprises a compute kernel generally titled \u201cfoo\u201d. During execution, a portion of the code  may be migrated to a separate heterogeneous core. In the example shown, the outer loop is data dependent. In one embodiment, a compiler informs the SIMD core of the data dependence by using a tag bit in the branch instruction corresponding to the \u201cwhile\u201d loop test. During execution, when a condition for migration is detected, such as a measured SIMD utilization is below a given threshold, the intermediate local values may be moved to a data structure in memory to be accessed by a separate heterogeneous core. For example, a general-purpose core may continue execution of the compute kernel from the point of the tagged branch migration point. For example, the implicit conditional branch in the while statement is tagged with the label \u201csecondary_entry\u201d. The separate heterogeneous core may use a compiler-generated data structure. In another embodiment, this data may be cached, alleviating migration costs. In one example, the live data may include both a local slice of the \u201ctmp\u201d array, as well as a current value of the local_temp variable. During migration, this data may be communicated to the runtime environment, which directs continued execution of the compute kernel to the secondary entry point indicated by the label \u201csecondary_entry\u201d.","Turning now to , one embodiment of a method  for optimizing parallel execution of multiple work units in a processor by utilizing pre-runtime data information is shown. The components embodied in the processing node  and the hardware resource assignments shown in  described above may generally operate in accordance with method . For purposes of discussion, the steps in this embodiment and subsequent embodiments of methods described later are shown in sequential order. However, in other embodiments some steps may occur in a different order than shown, some steps may be performed concurrently, some steps may be combined with other steps, and some steps may be absent.","In block , a software program or subroutine may be located and analyzed. This software program may be written for compilation and execution on a heterogeneous multi-core architecture. Program code may refer to any portion of a software application, subroutine, dynamic linked library, or otherwise. A pathname may be entered at a command prompt by a user, a pathname may be read from a given directory location, or other, in order to begin compiling the source code. The program code may be written by a designer in a high-level language such as C, a C-like language such as OpenCL\u2122, and so forth. In one embodiment, the source code is statically compiled. In such an embodiment, during a static front-end compilation, the source code may be translated to an intermediate representation (IR). A back-end compilation step may translate the IR to machine code. The static back-end compilation may perform more transformations and optimizations. In another embodiment, the source code is compiled with a Just-In-Time (JIT) method. The JIT method may generate an appropriate binary code after obtaining the system configuration. With either method, the compiler may identify a compute kernel in the program code. In one embodiment, the compiler, such as the OpenCL compiler, may generate multiple versions of compute kernels. One version of a compute kernel may be generated for each type of OpenCL device type, such as a general-purpose CPU, a SIMD GPU, and so forth.","In block , the compiler may read one or more instructions of the compute kernel and analyze them. A conditional statement may be a control flow transfer instruction, such as a branch. Different types of control flow transfer instructions may include forward\/backward branches, direct\/indirect branches, jumps, and so forth. It may be possible for a compiler or other tool to statically determine a direction of a branch and\/or a target of a branch. However, in one embodiment, some processing typically performed during runtime on associated data may be performed during compilation. For example, a simple test to determine a direction (taken, not-taken) of a branch may be performed. Although, compilation may be referred to as \u201cstatic compilation\u201d, one or more small dynamic operations may be performed. This compilation may also be referred to as \u201cpre-runtime compilation\u201d. Another example of a dynamic step performed at this time is identifying a next instruction to execute in each of a THEN, ELSE IF and ELSE blocks of an If-Then-ElseIf-Else construct. For example, if a conditional branch fails, a return statement may be executed. Therefore, the compiler knows that during execution, a corresponding work unit for this computer kernel may become idle when the branch test fails.","In block , particular lines of code in a compute kernel are selected for creating a migration point. A migration point may be a location in the computer kernel where in-flight execution transfers to a different heterogeneous core. In one embodiment, this compute sub-kernel migration may be achieved by a mechanism similar to process migration, wherein an execution state is moved from a first heterogeneous core to a second heterogeneous core with a possibly different micro-architecture than the first core. In another embodiment, this compute sub-kernel migration may be achieved by creating multiple compute sub-kernels that are later dispatched.","In one embodiment, the compiler may automatically identify migration points. As used herein, migration points may also be referred to as switch points. The compiler may use control flow analysis. Identifying a migration point may include utilizing static control flow analysis to find data-dependent loops leading to a compute kernel exit or return. Rather than identify each branch with a path including an exit or return, the compiler may use a count to reduce a number of migration points. For example, the first five branches found in a compute kernel may not be candidates for tagging as a migration point. Every third branch after the first five branches may be candidates for tagging as a migration point. Other filtering algorithms based on a count are possible and contemplated.","In addition, the compiler may use profile input from previous executions to identify migration points. For example, a conditional test associated with a given branch may fail for a number of records of data above a given threshold. Therefore, this branch may be identified as a migration point. Further, programmer annotations to indicate migration points may be added as \u201cpragmas\u201d or as an extension to the OpenCL framework.","In block , the compiler may tag the selected points in the code for each version of the compiled code. Each version may be referred to as a destination compute kernel for a respective OpenCL device. Again, the compiler may compile an identified compute kernel to produce two or more versions of compiled code, each capable of running on a respective one of the OpenCL devices. Referring again to code  in , the secondary entry point indicated by the label \u201csecondary_entry\u201d is an example of a migration tag for a branch. A code generator within the compiler may insert the tag and insert other code to invoke the live values during migration. Invoking the live values may include transferring the live values to a destination OpenCL device and initializing the values on the destination OpenCL device. The code generating and inserting process may be similar to debugger code being inserted at debut points and instrumentation for measuring dynamic behavior.","In one embodiment, a compute kernel may be tagged to identify migration points as described above. In another embodiment, the compute kernel may be divided into multiple compute sub-kernels that are scheduled and dispatched independently. Runtime profile information or compiler static estimation may be used to determine pass\/fail statistics for conditional tests implemented by branch instructions. A \u201chot\u201d execution path may comprise a large number of passes above a given threshold of the conditional test for multiple records of data. A \u201ccold\u201d execution path may comprise a small number of passes below a second given threshold of the conditional test for multiple records of data. A compute kernel may be divided into compute sub-kernels based on the \u201chot\u201d and \u201ccold\u201d execution paths.","Generation of the corresponding compute sub-kernels may utilize similar runtime code generation mechanisms in addition to creation of a corresponding execution range (NDRange) for those compute sub-kernels, such as the \u201ccold\u201d execution paths, that continue execution on a general-purpose core. This may be done by creating a potentially sparse array containing the compute sub-kernel identifiers (IDs), which may utilize an OpenCL designation, to be executed on the general-purpose core. A given compute kernel may utilize indirect access to this array to identify a proper compute sub-kernel and later work unit. Alternatively, the compiler may generate a list of these IDs, and a corresponding compute sub-kernel to be invoked and mapped for each of the executing work units.","After a profile run or a static estimation, a compute sub-kernel corresponding to a \u201chot\u201d execution path may be compiled for a SIMD core. A compute sub-kernel corresponding to a \u201ccold\u201d execution path may be compiled for a general-purpose core. The early stages of a cascade of tests may have a high probability of passing. Therefore, these execution paths may be implemented in the \u201chot\u201d compute sub-kernels executed on the SIMD core. After execution of these particular \u201chot\u201d compute sub-kernels, the associated produced data may be moved in memory. This data movement promotes the local data that is live to global data. The work units corresponding to the \u201chot\u201d compute sub-kernels may write a bit array based on its work unit ID to indicate whether an associated \u201ccold\u201d compute sub-kernel subsequently continues execution on a general-purpose core.","In block , the compiler identifies a set of live values at the identified migration points. The live values may include intermediate computation values and local arrays. Referring again to code  in , the live data may include both a local slice of the \u201ctmp\u201d array within the code, as well as a current value of the local_temp variable. If migration occurs later during execution of an associated work unit, the live values may be transferred and initialized on a destination OpenCL device. As described above, the code generator within the compiler may insert the tag and insert other code to invoke the live values during migration. At the destination OpenCL device, code generation for migration entry points initializes data structures containing live values and proceeds with kernel execution. Alternatively, the compiler may create compute sub-kernels to proceed with the execution as described above. In block , the compiler completes compilation of the compute kernel for at least two heterogeneous processor cores. Other debug and instrumentation code may be inserted.","In one embodiment, the compiler generates multiple data structures. Two or more data structures include executable object code for each compute sub-kernel on a given target OpenCL device, such as a general-purpose core and a SIMD core. Another data structure includes the live data to be transferred and accessed at the time of migration. Given a label designated as a potential migration point in a compute kernel, the compiler utilizes data flow analysis to determine live values that may be transferred. Live values that are not defined at that point in the execution, such as being cached in a register, are placed in a location accessible to a runtime environment. Examples of these locations include associated original memory locations and registers that hold contents that are preserved. In one embodiment, a heuristic check may be utilized to determine whether the size of the data transfer allows a profitable change execution between heterogeneous cores.","Additionally the compiler may generate another data structure that is interpreted by the runtime environment to transfer the live data to an associated destination OpenCL device. This data structure may provide the locations and sizes of the live data to be transferred and their locations in an address space of both the source and destination OpenCL devices. Also, the compiler generates a corresponding version of the kernel for the destination device. The respective compiled code for each of the OpenCL devices accesses the live data at the designated locations and begins execution at the migration points.","Turning now to , one embodiment of a method  for optimizing parallel execution of multiple work units in a processor by utilizing pre-runtime data information is shown. The components embodied in the processing node  and the hardware resource assignments shown in  described above may generally operate in accordance with method . For purposes of discussion, the steps in this embodiment and subsequent embodiments of methods described later are shown in sequential order. However, some steps may occur in a different order than shown, some steps may be performed concurrently, some steps may be combined with other steps, and some steps may be absent in another embodiment.","In block , an associated record of data is assigned to each work unit of a given compute kernel. In block , the OS scheduler  schedules the work units to heterogeneous cores. In block , the heterogeneous processor cores execute the corresponding scheduled work units.","In block , a given tagged migration point is reached. In one embodiment, a measurement of the utilization of a currently used OpenCL device may be performed. If the measurement indicates the utilization or performance is below a given threshold, then the associated compute kernel or compute sub-kernel may be migrated to another OpenCL device, such as a heterogeneous core with a different micro-architecture. In one embodiment, this measurement is a count of a number of currently executing work units on a SIMD core that reached an exit or return within an associated compute kernel or compute sub-kernel. Alternatively, a count of a number of disabled computation units in a wavefront may provide the same number. If this count is above a given threshold, then the work units that have not yet reached an exit point may be migrated to another heterogeneous core, such as a general-purpose core. Then the wavefront on the SIMD core may be released and is available for other scheduled work units.","In other embodiments, the above technique may be extended to initiate migrations at any situation in which it is determined that a large fraction of the parallel executing work units in a wavefront on a SIMD core are idle and the remaining work units are expected to continue substantial execution. For example, the generated data structures may be in shared memory and in one or more caches. In a system with virtual memory support, a subset of the work units may hit the cache whereas the remaining work units experience virtual memory misses, which are long latency events. In this case, overall computing performance may be better with continued execution on a general-purpose core since further execution may benefit from prefetching techniques enabled by the current execution.","If execution efficiency is not determined to be below a given threshold (conditional block ), then control flow of method  returns to block  and execution continues. If execution efficiency is determined to be below a given threshold (conditional block ), then in block , one or more work units are identified to migrate to a second processor core with a micro-architecture different from a micro-architecture of the first processor core. The identified work units may have caused the above measurement to be below the given threshold. In block , the associated local data produced by the first processor core is promoted to global data. In block , the compiled versions of the migrated work units are scheduled to be executed on the second processor core beginning at the migration tagged point.","It is noted that the above-described embodiments may comprise software. In such an embodiment, the program instructions that implement the methods and\/or mechanisms may be conveyed or stored on a computer readable medium. Numerous types of media which are configured to store program instructions are available and include hard disks, floppy disks, CD-ROM, DVD, flash memory, Programmable ROMs (PROM), random access memory (RAM), and various other forms of volatile or non-volatile storage. Generally speaking, a computer accessible storage medium may include any storage media accessible by a computer during use to provide instructions and\/or data to the computer. For example, a computer accessible storage medium may include storage media such as magnetic or optical media, e.g., disk (fixed or removable), tape, CD-ROM, or DVD-ROM, CD-R, CD-RW, DVD-R, DVD-RW, or Blu-Ray. Storage media may further include volatile or non-volatile memory media such as RAM (e.g. synchronous dynamic RAM (SDRAM), double data rate (DDR, DDR2, DDR3, etc.) SDRAM, low-power DDR (LPDDR2, etc.) SDRAM, Rambus DRAM (RDRAM), static RAM (SRAM), etc.), ROM, Flash memory, non-volatile memory (e.g. Flash memory) accessible via a peripheral interface such as the Universal Serial Bus (USB) interface, etc. Storage media may include microelectromechanical systems (MEMS), as well as storage media accessible via a communication medium such as a network and\/or a wireless link.","Additionally, program instructions may comprise behavioral-level description or register-transfer level (RTL) descriptions of the hardware functionality in a high level programming language such as C, or a design language (HDL) such as Verilog, VHDL, or database format such as GDS II stream format (GDSII). In some cases the description may be read by a synthesis tool which may synthesize the description to produce a netlist comprising a list of gates from a synthesis library. The netlist comprises a set of gates which also represent the functionality of the hardware comprising the system. The netlist may then be placed and routed to produce a data set describing geometric shapes to be applied to masks. The masks may then be used in various semiconductor fabrication steps to produce a semiconductor circuit or circuits corresponding to the system. Alternatively, the instructions on the computer accessible storage medium may be the netlist (with or without the synthesis library) or the data set, as desired. Additionally, the instructions may be utilized for purposes of emulation by a hardware based type emulator from such vendors as Cadence\u00ae, EVE\u00ae, and Mentor Graphics\u00ae.","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
