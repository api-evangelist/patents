---
title: Systems and methods for scalable N-core stats aggregation
abstract: The present invention is directed towards systems and methods for aggregating and providing statistics from cores of a multi-core system intermediary between one or more clients and servers. The system may maintain in shared memory a global device number for each core of the multi-core system. The system may provide a thread for each core of the multi-core system to gather data from the corresponding core. A first thread may generate aggregated statistics from a corresponding core by parsing the gathered data from the corresponding core. The first thread may transfer the generated statistics to a statistics log according to a schedule. The system may adaptively reschedule the transfer by monitoring the operation of each computing thread. Responsive to a request from a client, an agent of the client may obtain statistics from the statistics log.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08949414&OS=08949414&RS=08949414
owner: Citrix Systems, Inc.
number: 08949414
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20111227
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE DISCLOSURE","BACKGROUND OF THE DISCLOSURE","BRIEF SUMMARY OF THE DISCLOSURE","DETAILED DESCRIPTION OF THE DISCLOSURE"],"p":["The present application claims priority to U.S. Provisional Patent Application No. 61\/428,124, entitled \u201cSYSTEMS AND METHODS FOR SCALABLE N-CORE STATS AGGREGATION\u201d, filed Dec. 29, 2010, which is incorporated herein by reference in its entirety for all purposes.","The present application generally relates to data communication networks. In particular, the present application relates to systems and methods for providing scalable unified data representation of the aggregate performance records and statistics of a multi-core network appliance.","In certain conventional network systems, an appliance or intermediary device is disposed in a network between one or more clients requesting web content or a network service, and one or more servers providing the requested web content or service. In some cases, the appliance establishes connections with the clients and servers and manages the connections and flow of information between the clients and servers. The appliance may employ security rules to ensure a measure of secure communications, monitor response time of servers, configure network connections to balance loads to servers, maintain user session data, and attend to other tasks which assure or improve the quality of communications supported by the appliance. In various implementations, an appliance or intermediary device may track and\/or provide data about its operations or performance.","The present invention is directed towards systems and methods for aggregating and providing statistics from cores of a multi-core system intermediary between one or more clients and servers. The system may maintain, in shared memory, a global device number for each core of the multi-core system. The system may provide a thread for each core of the multi-core system to gather data from the corresponding core. A first thread may generate aggregated statistics from a corresponding core by parsing the gathered data from the corresponding core. The first thread may transfer the generated statistics to a statistics log. In some aspects, the present application is directed towards systems and methods for providing unified performance data and unified trace data for a multi-core appliance disposed in a network. In a multi-core appliance, a plurality of packet engines in operation on the appliance can manage network traffic between one or more clients and one or more servers. The systems and methods herein describe how the plurality of performance and trace data generated by the plurality of packet engines can be efficiently managed and consolidated to provide an aggregate set of performance data or trace data.","In one aspect, the present disclosure is directed to a method for aggregating performance statistics from multiple cores of a system intermediary between one or more clients and servers. The multiple cores may process multiple network traffic streams between one or more clients and servers. The method may include maintaining, in shared memory of a multi-core system intermediary between one or more clients and servers, a global device number for each core of the multi-core system. Each core may include one or more packet engines processing network traffic between the one or more clients and servers. An aggregator of the multi-core system may execute a computing thread for each core of the multi-core system. A first computing thread of the aggregator may collect statistics of network traffic processed by one or more packet engines on a first core. The first computing thread may transfer the statistics with a marker to a statistics log of the multi-core system. The marker may correspond to a global device number of the first core.","In some embodiments, the aggregator may assign, for each core of the multi-core system, a global device number to a virtual machine executing on the core. The aggregator may assign, for each core of the multi-core system, a global device number to each virtual machine of the core, each virtual machine comprising one or more packet engines processing network traffic between the one or more clients and servers. The aggregator may consolidate at least a portion of statistics collected from two or more cores of the multi-core system into a buffer. The first computing thread may write the collected statistics to the statistics log according to a schedule of the aggregator. The aggregator may adaptively reschedule the transfer by monitoring the operation of the first core.","In some embodiments, the first computing thread may transfer the collected statistics unchanged to the statistics log. The multi-core system may maintain the statistics log for two or more cores of the multi-core system. The aggregator may send a notification to a first client of the one or more clients responsive to the transfer. The multi-core system may provide to the one or more clients access to the statistics log.","In another aspect, the present disclosure is directed to a system for aggregating performance statistics from multiple cores of a device intermediary between one or more clients and servers. The multiple cores may process multiple network traffic streams between one or more clients and servers. The system may include shared memory between multiple cores of the intermediary device, for maintaining a global device number for each core of the multi-core system. Each core may include one or more packet engines processing network traffic between the one or more clients and servers. An aggregator of the intermediary device may execute a computing thread for each core of the multi-core system. The aggregator may execute a first computing thread collecting statistics of network traffic processed by one or more packet engines on a first core. The aggregator may transfer the statistics with a marker to a statistics log of the multi-core system. The marker may correspond to a global device number of the first core.","In some embodiments, the aggregator assigns a global device number to a virtual machine executing on each core. The aggregator may assign a global device number to each virtual machine of each core. Each virtual machine may include one or more packet engines processing network traffic between the one or more clients and servers. The aggregator may further consolidate at least a portion of statistics collected from two or more cores of the multi-core system into a buffer. The first computing thread may write the collected statistics to the statistics log according to a schedule of the aggregator.","In some embodiments, the aggregator adaptively reschedules the transfer by monitoring the operation of the first core. The first computing thread may transfer the collected statistics unchanged to the statistics log. The aggregator may maintain the statistics log for two or more cores of the device. The aggregator may send a notification to a first client of the one or more clients responsive to the transfer. The aggregator may provide the one or more clients access to the statistics log.","In various embodiments, a system for aggregating network performance data or trace data comprises an appliance disposed in a network between a plurality of clients and a plurality of servers providing web content or network services for clients, a plurality of packet engines in operation on a plurality of cores of the appliance, and an aggregator in operation on the appliance. In certain embodiments, a system for aggregating performance data of an appliance, which is intermediary to a plurality of clients and one or more servers in a networked system, comprises a plurality of packet engines executing on a plurality of cores configured for operation with the appliance. Each packet engine, executing on a respective core, can collect performance data identifying statistics of a service provided by a server in communication with the packet engine as well as data identifying statistics of a virtual service provided by the packet engine. One or more of the packet engines can manage network traffic associated with the service. In various embodiments, the system further comprises an aggregator which executes on a core of the multi-core, multi-packet-engine appliance. The aggregator can store to a buffer packet engine performance data obtained from each packet engine, and consolidate all packet engine performance data to identify unified performance data. In various embodiments, the unified performance data identifies statistics for network services managed by the appliance, in some embodiments as though the appliance comprised a single-core processing device. Further, the aggregator can receive a request from an agent for performance data of the appliance, and transmit the unified performance data in response to the request.","In certain embodiments, the system described above is adapted to aggregate trace data and provide a unified record of trace data for the multi-core, multi-packet-engine appliance. In such embodiments, each packet engine can capture trace information for network traffic received and\/or transmitted by the packet engine. The aggregator can store to a buffer the trace information obtained from each packet engine, and consolidate all trace information from the plurality of packet engines to provide unified trace data of network traffic managed by the appliance. The unified trace data can be representative of the appliance as though the appliance were a single-core, single-packet-engine system. The aggregator can further receive a request from an agent for network trace data of the appliance, and transmit the unified trace data of network traffic in response to the request.","An embodiment of a method for aggregating performance data of a multi-core, multi-packet-engine appliance can comprise collecting, by each packet engine executing on a respective core of the appliance, packet engine performance data identifying statistics of a service provided by a server as managed by each packet engine, storing to a buffer, by the aggregator executing on a core of the appliance, the packet engine performance data obtained from each of the packet engines, and consolidating, by the aggregator, the packet engine performance data to identify unified performance data. The unified performance data can identify statistics for the service as managed by the appliance. The method can further comprise receiving, by the aggregator, a request from an agent for performance data of the appliance, and transmitting, by the aggregator, the unified performance data in response to the request.","In some embodiments, the step of collecting, by each packet engine, further comprises storing, by the aggregator, a first command in a first location of memory shared by the aggregator and a first core. The first command can identify a first request for packet engine statistics from a first packet engine of the first core. The collecting can further comprise storing, by the aggregator, a second command in a second location of memory shared by the aggregator and a second core. The second command can identify a second request for packet engine statistics from a second packet engine of the second core. The step of storing, by the aggregator, can further comprise reading, by the aggregator, packet engine statistical data stored by the first packet engine in the memory shared between the aggregator and first core. The reading can be executed in response to detecting, by the aggregator, a change to a first flag in the shared memory. The storing can additionally comprise reading, by the aggregator, packet engine statistical data stored by the second packet engine in the memory shared between the aggregator and second core. The reading can be executed in response to detecting, by the aggregator, a change to a second flag in the shared memory.","In some embodiments, the step of collecting further comprises collecting, by each packet engine, local statistics of a virtual server of each packet engine. The virtual server can be configured to operate on the packet engine and manage the service provided by a server in communication with the packet engine. The step of storing can further comprise storing to a buffer, by the aggregator, the local statistics of each packet engine's virtual server obtained from each of the packet engines, and the step of consolidating of the method can further comprise consolidating, by the aggregator, each of the local statistics of each packet engine's virtual server to provide unified performance data identifying statistics for the appliance as a virtual server.","In some implementations, the step of collecting further comprises collecting, by each packet engine, a number of connections to the service of a server as packet engine performance data, and the step of consolidating, by the aggregator, further comprises consolidating, by the aggregator, the number of connections to the service from the plurality of packet engines. The aggregator can then provide a total number of connections to the service from the appliance. In some instances, the step of collecting further comprises collecting, by each packet engine, an average response time to the service as packet engine performance data, and the step of consolidating further comprises consolidating, by the aggregator, the average response to the service from the plurality of packet engines. The aggregator can provide a system-wide average response time to the service from the appliance. In some embodiments, the step of collecting further comprises collecting, by each packet engine, a number of bytes passed for the service as packet engine performance data, and the step of consolidating further comprises consolidating, by the aggregator, the number of bytes passed for the service from the plurality of packet engines. The aggregator can provide a total number of bytes passed for the service from the appliance. In certain embodiments, the step of collecting further comprises collecting, by each packet engine, a number of different servers providing service as packet engine performance data, and the step of consolidating further comprises consolidating the number of different servers from the plurality of packet engines. The aggregator can provide a total number of distinct servers providing service managed by the appliance.","An embodiment of a method for aggregating trace data of a multi-core, multi-packet-engine appliance can comprise capturing, by each packet engine executing on a respective core of the appliance, trace information for network traffic received or transmitted by the packet engine, storing to a buffer, by the aggregator, the trace information obtained from each packet engine of the plurality of packet engines, and consolidating, by the aggregator, the trace information from each packet engine to provide unified trace data of network traffic managed by the appliance. The method for aggregating trace data can further comprise receiving, by the aggregator, a request from an agent for network trace data of the appliance, and transmitting, by the aggregator, the trace data of network traffic in response to the request. In various embodiments, the trace data may not identify the plurality of cores of the appliance. The agent requesting the data may not discern that the appliance comprises a plurality of cores and packet engines managing network traffic. In some embodiments, the method further comprises converting or structuring, by the aggregator, the trace data to a format recognizable by the agent requesting the data.","In some embodiments, the capturing, by each packet engine, further comprises storing, by the aggregator, a first command in a first location of memory shared with a first core. The first command can identify a first request for trace information from a first packet engine of the first core. The step of capturing can further comprise storing, by the aggregator, a second command in a first location of memory shared with a second core. The second command can identify a second request for trace information from a second packet engine of the second core. The step of storing, by the aggregator, can further comprise reading, by the aggregator, trace information stored by the first packet engine in the memory shared between the aggregator and the first core. The reading can be executed in response to detecting a change to a first flag in the shared memory monitored by the aggregator. The step of storing can further comprise reading, by the aggregator, trace information stored by the second packet engine in the memory shared between the aggregator and the second core. The reading can be executed in response to detecting a change to a second flag in the shared memory monitored by the aggregator.","In some embodiments, the step of capturing further comprises filtering, by each packet engine, trace information for network traffic, and the step of consolidating further comprises consolidating, by the aggregator, all the filtered trace information and providing a unified record of trace information for the appliance in accordance with the filtering. In some implementations, the step of capturing further comprises capturing, by each packet engine, trace information for network traffic from an identified source IP address, and the step of consolidating further comprises consolidating, by the aggregator, all the captured trace information and providing a unified record of network traffic from the identified source IP address managed by the appliance. In some instances of the method, the step of capturing further comprises capturing, by each packet engine, trace information for network traffic to an identified destination IP address, and the step of consolidating further comprises consolidating, by the aggregator, all the captured trace information and providing a unified record of network traffic to the identified destination IP address managed by the appliance.","The details of various embodiments of the invention are set forth in the accompanying drawings and the description below.","The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings, in which like reference characters identify corresponding elements throughout. In the drawings, like reference numbers generally indicate identical, functionally similar, and\/or structurally similar elements.","For purposes of reading the description of the various embodiments below, the following descriptions of the sections of the specification and their respective contents may be helpful:\n\n","Prior to discussing the specifics of embodiments of the systems and methods of an appliance and\/or client, it may be helpful to discuss the network and computing environments in which such embodiments may be deployed. Referring now to , an embodiment of a network environment is depicted. In brief overview, the network environment comprises one or more clients -(also generally referred to as local machine(s) , or client(s) ) in communication with one or more servers -(also generally referred to as server(s) , or remote machine(s) ) via one or more networks , \u2032 (generally referred to as network ). In some embodiments, a client  communicates with a server  via an appliance .","Although  shows a network  and a network \u2032 between the clients  and the servers , the clients  and the servers  may be on the same network . The networks  and \u2032 can be the same type of network or different types of networks. The network  and\/or the network \u2032 can be a local-area network (LAN), such as a company Intranet, a metropolitan area network (MAN), or a wide area network (WAN), such as the Internet or the World Wide Web. In one embodiment, network \u2032 may be a private network and network  may be a public network. In some embodiments, network  may be a private network and network \u2032 a public network. In another embodiment, networks  and \u2032 may both be private networks. In some embodiments, clients  may be located at a branch office of a corporate enterprise communicating via a WAN connection over the network  to the servers  located at a corporate data center.","The network  and\/or \u2032 be any type and\/or form of network and may include any of the following: a point to point network, a broadcast network, a wide area network, a local area network, a telecommunications network, a data communication network, a computer network, an ATM (Asynchronous Transfer Mode) network, a SONET (Synchronous Optical Network) network, a SDH (Synchronous Digital Hierarchy) network, a wireless network and a wireline network. In some embodiments, the network  may comprise a wireless link, such as an infrared channel or satellite band. The topology of the network  and\/or \u2032 may be a bus, star, or ring network topology. The network  and\/or \u2032 and network topology may be of any such network or network topology as known to those ordinarily skilled in the art capable of supporting the operations described herein.","As shown in , the appliance , which also may be referred to as an interface unit  or gateway , is shown between the networks  and \u2032. In some embodiments, the appliance  may be located on network . For example, a branch office of a corporate enterprise may deploy an appliance  at the branch office. In other embodiments, the appliance  may be located on network \u2032. For example, an appliance  may be located at a corporate data center. In yet another embodiment, a plurality of appliances  may be deployed on network . In some embodiments, a plurality of appliances  may be deployed on network \u2032. In one embodiment, a first appliance  communicates with a second appliance \u2032. In other embodiments, the appliance  could be a part of any client  or server  on the same or different network ,\u2032 as the client . One or more appliances  may be located at any point in the network or network communications path between a client  and a server .","In some embodiments, the appliance  comprises any of the network devices manufactured by Citrix Systems, Inc. of Ft. Lauderdale Fla., referred to as Citrix NetScaler devices. In other embodiments, the appliance  includes any of the product embodiments referred to as WebAccelerator and BigIP manufactured by F5 Networks, Inc. of Seattle, Wash. In another embodiment, the appliance  includes any of the DX acceleration device platforms and\/or the SSL VPN series of devices, such as SA 700, SA 2000, SA 4000, and SA 6000 devices manufactured by Juniper Networks, Inc. of Sunnyvale, Calif. In yet another embodiment, the appliance  includes any application acceleration and\/or security related appliances and\/or software manufactured by Cisco Systems, Inc. of San Jose, Calif., such as the Cisco ACE Application Control Engine Module service software and network modules, and Cisco AVS Series Application Velocity System.","In one embodiment, the system may include multiple, logically-grouped servers . In these embodiments, the logical group of servers may be referred to as a server farm . In some of these embodiments, the serves  may be geographically dispersed. In some cases, a farm  may be administered as a single entity. In other embodiments, the server farm  comprises a plurality of server farms . In one embodiment, the server farm executes one or more applications on behalf of one or more clients .","The servers  within each farm  can be heterogeneous. One or more of the servers  can operate according to one type of operating system platform (e.g., WINDOWS NT, manufactured by Microsoft Corp. of Redmond, Wash.), while one or more of the other servers  can operate on according to another type of operating system platform (e.g., Unix or Linux). The servers  of each farm  do not need to be physically proximate to another server  in the same farm . Thus, the group of servers  logically grouped as a farm  may be interconnected using a wide-area network (WAN) connection or medium-area network (MAN) connection. For example, a farm  may include servers  physically located in different continents or different regions of a continent, country, state, city, campus, or room. Data transmission speeds between servers  in the farm  can be increased if the servers  are connected using a local-area network (LAN) connection or some form of direct connection.","Servers  may be referred to as a file server, application server, web server, proxy server, or gateway server. In some embodiments, a server  may have the capacity to function as either an application server or as a master application server. In one embodiment, a server  may include an Active Directory. The clients  may also be referred to as client nodes or endpoints. In some embodiments, a client  has the capacity to function as both a client node seeking access to applications on a server and as an application server providing access to hosted applications for other clients -","In some embodiments, a client  communicates with a server . In one embodiment, the client  communicates directly with one of the servers  in a farm . In another embodiment, the client  executes a program neighborhood application to communicate with a server  in a farm . In still another embodiment, the server  provides the functionality of a master node. In some embodiments, the client  communicates with the server  in the farm  through a network . Over the network , the client  can, for example, request execution of various applications hosted by the servers -in the farm  and receive output of the results of the application execution for display. In some embodiments, only the master node provides the functionality required to identify and provide address information associated with a server \u2032 hosting a requested application.","In one embodiment, the server  provides functionality of a web server. In another embodiment, the server receives requests from the client , forwards the requests to a second server and responds to the request by the client  with a response to the request from the server . In still another embodiment, the server  acquires an enumeration of applications available to the client  and address information associated with a server  hosting an application identified by the enumeration of applications. In yet another embodiment, the server  presents the response to the request to the client  using a web interface. In one embodiment, the client  communicates directly with the server  to access the identified application. In another embodiment, the client  receives application output data, such as display data, generated by an execution of the identified application on the server .","Referring now to , an embodiment of a network environment deploying multiple appliances  is depicted. A first appliance  may be deployed on a first network  and a second appliance \u2032 on a second network \u2032. For example a corporate enterprise may deploy a first appliance  at a branch office and a second appliance \u2032 at a data center. In another embodiment, the first appliance  and second appliance \u2032 are deployed on the same network  or network . For example, a first appliance  may be deployed for a first server farm , and a second appliance  may be deployed for a second server farm \u2032. In another example, a first appliance  may be deployed at a first branch office while the second appliance \u2032 is deployed at a second branch office'. In some embodiments, the first appliance  and second appliance \u2032 work in cooperation or in conjunction with each other to accelerate network traffic or the delivery of application and data between a client and a server","Referring now to , another embodiment of a network environment deploying the appliance  with one or more other types of appliances, such as between one or more WAN optimization appliance , \u2032 is depicted. For example a first WAN optimization appliance  is shown between networks  and \u2032 and a second WAN optimization appliance \u2032 may be deployed between the appliance  and one or more servers . By way of example, a corporate enterprise may deploy a first WAN optimization appliance  at a branch office and a second WAN optimization appliance \u2032 at a data center. In some embodiments, the appliance  may be located on network \u2032. In other embodiments, the appliance \u2032 may be located on network . In some embodiments, the appliance \u2032 may be located on network \u2032 or network \u2033. In one embodiment, the appliance  and \u2032 are on the same network. In another embodiment, the appliance  and \u2032 are on different networks. In another example, a first WAN optimization appliance  may be deployed for a first server farm  and a second WAN optimization appliance \u2032 for a second server farm \u2032","In one embodiment, the appliance  is a device for accelerating, optimizing or otherwise improving the performance, operation, or quality of service of any type and form of network traffic, such as traffic to and\/or from a WAN connection. In some embodiments, the appliance  is a performance enhancing proxy. In other embodiments, the appliance  is any type and form of WAN optimization or acceleration device, sometimes also referred to as a WAN optimization controller. In one embodiment, the appliance  is any of the product embodiments referred to as WANScaler manufactured by Citrix Systems, Inc. of Ft. Lauderdale, Fla. In other embodiments, the appliance  includes any of the product embodiments referred to as BIG-IP link controller and WANjet manufactured by F5 Networks, Inc. of Seattle, Wash. In another embodiment, the appliance  includes any of the WX and WXC WAN acceleration device platforms manufactured by Juniper Networks, Inc. of Sunnyvale, Calif. In some embodiments, the appliance  includes any of the steelhead line of WAN optimization appliances manufactured by Riverbed Technology of San Francisco, Calif. In other embodiments, the appliance  includes any of the WAN related devices manufactured by Expand Networks Inc. of Roseland, N.J. In one embodiment, the appliance  includes any of the WAN related appliances manufactured by Packeteer Inc. of Cupertino, Calif., such as the PacketShaper, iShared, and SkyX product embodiments provided by Packeteer. In yet another embodiment, the appliance  includes any WAN related appliances and\/or software manufactured by Cisco Systems, Inc. of San Jose, Calif., such as the Cisco Wide Area Network Application Services software and network modules, and Wide Area Network engine appliances.","In one embodiment, the appliance  provides application and data acceleration services for branch-office or remote offices. In one embodiment, the appliance  includes optimization of Wide Area File Services (WAFS). In another embodiment, the appliance  accelerates the delivery of files, such as via the Common Internet File System (CIFS) protocol. In other embodiments, the appliance  provides caching in memory and\/or storage to accelerate delivery of applications and data. In one embodiment, the appliance  provides compression of network traffic at any level of the network stack or at any protocol or network layer. In another embodiment, the appliance  provides transport layer protocol optimizations, flow control, performance enhancements or modifications and\/or management to accelerate delivery of applications and data over a WAN connection. For example, in one embodiment, the appliance  provides Transport Control Protocol (TCP) optimizations. In other embodiments, the appliance  provides optimizations, flow control, performance enhancements or modifications and\/or management for any session or application layer protocol.","In another embodiment, the appliance  encoded any type and form of data or information into custom or standard TCP and\/or IP header fields or option fields of network packet to announce presence, functionality or capability to another appliance \u2032. In another embodiment, an appliance \u2032 may communicate with another appliance \u2032 using data encoded in both TCP and\/or IP header fields or options. For example, the appliance may use TCP option(s) or IP header fields or options to communicate one or more parameters to be used by the appliances , \u2032 in performing functionality, such as WAN acceleration, or for working in conjunction with each other.","In some embodiments, the appliance  preserves any of the information encoded in TCP and\/or IP header and\/or option fields communicated between appliances  and \u2032. For example, the appliance  may terminate a transport layer connection traversing the appliance , such as a transport layer connection from between a client and a server traversing appliances  and \u2032. In one embodiment, the appliance  identifies and preserves any encoded information in a transport layer packet transmitted by a first appliance  via a first transport layer connection and communicates a transport layer packet with the encoded information to a second appliance \u2032 via a second transport layer connection.","Referring now to , a network environment for delivering and\/or operating a computing environment on a client  is depicted. In some embodiments, a server  includes an application delivery system  for delivering a computing environment or an application and\/or data file to one or more clients . In brief overview, a client  is in communication with a server  via network , \u2032 and appliance . For example, the client  may reside in a remote office of a company, e.g., a branch office, and the server  may reside at a corporate data center. The client  comprises a client agent , and a computing environment . The computing environment  may execute or operate an application that accesses, processes or uses a data file. The computing environment , application and\/or data file may be delivered via the appliance  and\/or the server .","In some embodiments, the appliance  accelerates delivery of a computing environment , or any portion thereof, to a client . In one embodiment, the appliance  accelerates the delivery of the computing environment  by the application delivery system . For example, the embodiments described herein may be used to accelerate delivery of a streaming application and data file processable by the application from a central corporate data center to a remote user location, such as a branch office of the company. In another embodiment, the appliance  accelerates transport layer traffic between a client  and a server . The appliance  may provide acceleration techniques for accelerating any transport layer payload from a server  to a client , such as: 1) transport layer connection pooling, 2) transport layer connection multiplexing, 3) transport control protocol buffering, 4) compression and 5) caching. In some embodiments, the appliance  provides load balancing of servers  in responding to requests from clients . In other embodiments, the appliance  acts as a proxy or access server to provide access to the one or more servers . In another embodiment, the appliance  provides a secure virtual private network connection from a first network  of the client  to the second network \u2032 of the server , such as an SSL VPN connection. It yet other embodiments, the appliance  provides application firewall security, control and management of the connection and communications between a client  and a server .","In some embodiments, the application delivery management system  provides application delivery techniques to deliver a computing environment to a desktop of a user, remote or otherwise, based on a plurality of execution methods and based on any authentication and authorization policies applied via a policy engine . With these techniques, a remote user may obtain a computing environment and access to server stored applications and data files from any network connected device . In one embodiment, the application delivery system  may reside or execute on a server . In another embodiment, the application delivery system  may reside or execute on a plurality of servers -. In some embodiments, the application delivery system  may execute in a server farm . In one embodiment, the server  executing the application delivery system  may also store or provide the application and data file. In another embodiment, a first set of one or more servers  may execute the application delivery system , and a different server may store or provide the application and data file. In some embodiments, each of the application delivery system , the application, and data file may reside or be located on different servers. In yet another embodiment, any portion of the application delivery system  may reside, execute or be stored on or distributed to the appliance , or a plurality of appliances.","The client  may include a computing environment  for executing an application that uses or processes a data file. The client  via networks , \u2032 and appliance  may request an application and data file from the server . In one embodiment, the appliance  may forward a request from the client  to the server . For example, the client  may not have the application and data file stored or accessible locally. In response to the request, the application delivery system  and\/or server  may deliver the application and data file to the client . For example, in one embodiment, the server  may transmit the application as an application stream to operate in computing environment  on client .","In some embodiments, the application delivery system  comprises any portion of the Citrix Access Suite\u2122 by Citrix Systems, Inc., such as the MetaFrame or Citrix Presentation Server\u2122 and\/or any of the Microsoft\u00ae Windows Terminal Services manufactured by the Microsoft Corporation. In one embodiment, the application delivery system  may deliver one or more applications to clients  or users via a remote-display protocol or otherwise via remote-based or server-based computing. In another embodiment, the application delivery system  may deliver one or more applications to clients or users via steaming of the application.","In one embodiment, the application delivery system  includes a policy engine  for controlling and managing the access to, selection of application execution methods and the delivery of applications. In some embodiments, the policy engine  determines the one or more applications a user or client  may access. In another embodiment, the policy engine  determines how the application should be delivered to the user or client , e.g., the method of execution. In some embodiments, the application delivery system  provides a plurality of delivery techniques from which to select a method of application execution, such as a server-based computing, streaming or delivering the application locally to the client  for local execution.","In one embodiment, a client  requests execution of an application program and the application delivery system  comprising a server  selects a method of executing the application program. In some embodiments, the server  receives credentials from the client . In another embodiment, the server  receives a request for an enumeration of available applications from the client . In one embodiment, in response to the request or receipt of credentials, the application delivery system  enumerates a plurality of application programs available to the client . The application delivery system  receives a request to execute an enumerated application. The application delivery system  selects one of a predetermined number of methods for executing the enumerated application, for example, responsive to a policy of a policy engine. The application delivery system  may select a method of execution of the application enabling the client  to receive application-output data generated by execution of the application program on a server . The application delivery system  may select a method of execution of the application enabling the local machine  to execute the application program locally after retrieving a plurality of application files comprising the application. In yet another embodiment, the application delivery system  may select a method of execution of the application to stream the application via the network  to the client .","A client  may execute, operate or otherwise provide an application, which can be any type and\/or form of software, program, or executable instructions such as any type and\/or form of web browser, web-based client, client-server application, a thin-client computing client, an ActiveX control, or a Java applet, or any other type and\/or form of executable instructions capable of executing on client . In some embodiments, the application may be a server-based or a remote-based application executed on behalf of the client  on a server . In one embodiments the server  may display output to the client  using any thin-client or remote-display protocol, such as the Independent Computing Architecture (ICA) protocol manufactured by Citrix Systems, Inc. of Ft. Lauderdale, Fla. or the Remote Desktop Protocol (RDP) manufactured by the Microsoft Corporation of Redmond, Wash. The application can use any type of protocol and it can be, for example, an HTTP client, an FTP client, an Oscar client, or a Telnet client. In other embodiments, the application comprises any type of software related to VoIP communications, such as a soft IP telephone. In further embodiments, the application comprises any application related to real-time data communications, such as applications for streaming video and\/or audio.","In some embodiments, the server  or a server farm  may be running one or more applications, such as an application providing a thin-client computing or remote display presentation application. In one embodiment, the server  or server farm  executes as an application, any portion of the Citrix Access Suite\u2122 by Citrix Systems, Inc., such as the MetaFrame or Citrix Presentation Server\u2122, and\/or any of the Microsoft\u00ae Windows Terminal Services manufactured by the Microsoft Corporation. In one embodiment, the application is an ICA client, developed by Citrix Systems, Inc. of Fort Lauderdale, Fla. In other embodiments, the application includes a Remote Desktop (RDP) client, developed by Microsoft Corporation of Redmond, Wash. Also, the server  may run an application, which for example, may be an application server providing email services such as Microsoft Exchange manufactured by the Microsoft Corporation of Redmond, Wash., a web or Internet server, or a desktop sharing server, or a collaboration server. In some embodiments, any of the applications may comprise any type of hosted service or products, such as GoToMeeting\u2122 provided by Citrix Online Division, Inc. of Santa Barbara, Calif., WebEx\u2122 provided by WebEx, Inc. of Santa Clara, Calif., or Microsoft Office Live Meeting provided by Microsoft Corporation of Redmond, Wash.","Still referring to , an embodiment of the network environment may include a monitoring server A. The monitoring server A may include any type and form performance monitoring service . The performance monitoring service  may include monitoring, measurement and\/or management software and\/or hardware, including data collection, aggregation, analysis, management and reporting. In one embodiment, the performance monitoring service  includes one or more monitoring agents . The monitoring agent  includes any software, hardware or combination thereof for performing monitoring, measurement and data collection activities on a device, such as a client , server  or an appliance , . In some embodiments, the monitoring agent  includes any type and form of script, such as Visual Basic script, or Javascript. In one embodiment, the monitoring agent  executes transparently to any application and\/or user of the device. In some embodiments, the monitoring agent  is installed and operated unobtrusively to the application or client. In yet another embodiment, the monitoring agent  is installed and operated without any instrumentation for the application or device.","In some embodiments, the monitoring agent  monitors, measures and collects data on a predetermined frequency. In other embodiments, the monitoring agent  monitors, measures and collects data based upon detection of any type and form of event. For example, the monitoring agent  may collect data upon detection of a request for a web page or receipt of an HTTP response. In another example, the monitoring agent  may collect data upon detection of any user input events, such as a mouse click. The monitoring agent  may report or provide any monitored, measured or collected data to the monitoring service . In one embodiment, the monitoring agent  transmits information to the monitoring service  according to a schedule or a predetermined frequency. In another embodiment, the monitoring agent  transmits information to the monitoring service  upon detection of an event.","In some embodiments, the monitoring service  and\/or monitoring agent  performs monitoring and performance measurement of any network resource or network infrastructure element, such as a client, server, server farm, appliance , appliance , or network connection. In one embodiment, the monitoring service  and\/or monitoring agent  performs monitoring and performance measurement of any transport layer connection, such as a TCP or UDP connection. In another embodiment, the monitoring service  and\/or monitoring agent  monitors and measures network latency. In yet one embodiment, the monitoring service  and\/or monitoring agent  monitors and measures bandwidth utilization.","In other embodiments, the monitoring service  and\/or monitoring agent  monitors and measures end-user response times. In some embodiments, the monitoring service  performs monitoring and performance measurement of an application. In another embodiment, the monitoring service  and\/or monitoring agent  performs monitoring and performance measurement of any session or connection to the application. In one embodiment, the monitoring service  and\/or monitoring agent  monitors and measures performance of a browser. In another embodiment, the monitoring service  and\/or monitoring agent  monitors and measures performance of HTTP based transactions. In some embodiments, the monitoring service  and\/or monitoring agent  monitors and measures performance of a Voice over IP (VoIP) application or session. In other embodiments, the monitoring service  and\/or monitoring agent  monitors and measures performance of a remote display protocol application, such as an ICA client or RDP client. In yet another embodiment, the monitoring service  and\/or monitoring agent  monitors and measures performance of any type and form of streaming media. In still a further embodiment, the monitoring service  and\/or monitoring agent  monitors and measures performance of a hosted application or a Software-As-A-Service (SaaS) delivery model.","In some embodiments, the monitoring service  and\/or monitoring agent  performs monitoring and performance measurement of one or more transactions, requests or responses related to application. In other embodiments, the monitoring service  and\/or monitoring agent  monitors and measures any portion of an application layer stack, such as any .NET or J2EE calls. In one embodiment, the monitoring service  and\/or monitoring agent  monitors and measures database or SQL transactions. In yet another embodiment, the monitoring service  and\/or monitoring agent  monitors and measures any method, function or application programming interface (API) call.","In one embodiment, the monitoring service  and\/or monitoring agent  performs monitoring and performance measurement of a delivery of application and\/or data from a server to a client via one or more appliances, such as appliance  and\/or appliance . In some embodiments, the monitoring service  and\/or monitoring agent  monitors and measures performance of delivery of a virtualized application. In other embodiments, the monitoring service  and\/or monitoring agent  monitors and measures performance of delivery of a streaming application. In another embodiment, the monitoring service  and\/or monitoring agent  monitors and measures performance of delivery of a desktop application to a client and\/or the execution of the desktop application on the client. In another embodiment, the monitoring service  and\/or monitoring agent  monitors and measures performance of a client\/server application.","In one embodiment, the monitoring service  and\/or monitoring agent  is designed and constructed to provide application performance management for the application delivery system . For example, the monitoring service  and\/or monitoring agent  may monitor, measure and manage the performance of the delivery of applications via the Citrix Presentation Server. In this example, the monitoring service  and\/or monitoring agent  monitors individual ICA sessions. The monitoring service  and\/or monitoring agent  may measure the total and per session system resource usage, as well as application and networking performance. The monitoring service  and\/or monitoring agent  may identify the active servers for a given user and\/or user session. In some embodiments, the monitoring service  and\/or monitoring agent  monitors back-end connections between the application delivery system  and an application and\/or database server. The monitoring service  and\/or monitoring agent  may measure network latency, delay and volume per user-session or ICA session.","In some embodiments, the monitoring service  and\/or monitoring agent  measures and monitors memory usage for the application delivery system , such as total memory usage, per user session and\/or per process. In other embodiments, the monitoring service  and\/or monitoring agent  measures and monitors CPU usage the application delivery system , such as total CPU usage, per user session and\/or per process. In another embodiments, the monitoring service  and\/or monitoring agent  measures and monitors the time required to log-in to an application, a server, or the application delivery system, such as Citrix Presentation Server. In one embodiment, the monitoring service  and\/or monitoring agent  measures and monitors the duration a user is logged into an application, a server, or the application delivery system . In some embodiments, the monitoring service  and\/or monitoring agent  measures and monitors active and inactive session counts for an application, server or application delivery system session. In yet another embodiment, the monitoring service  and\/or monitoring agent  measures and monitors user session latency.","In yet further embodiments, the monitoring service  and\/or monitoring agent  measures and monitors measures and monitors any type and form of server metrics. In one embodiment, the monitoring service  and\/or monitoring agent  measures and monitors metrics related to system memory, CPU usage, and disk storage. In another embodiment, the monitoring service  and\/or monitoring agent  measures and monitors metrics related to page faults, such as page faults per second. In other embodiments, the monitoring service  and\/or monitoring agent  measures and monitors round-trip time metrics. In yet another embodiment, the monitoring service  and\/or monitoring agent  measures and monitors metrics related to application crashes, errors and\/or hangs.","In some embodiments, the monitoring service  and monitoring agent  includes any of the product embodiments referred to as EdgeSight manufactured by Citrix Systems, Inc. of Ft. Lauderdale, Fla. In another embodiment, the performance monitoring service  and\/or monitoring agent  includes any portion of the product embodiments referred to as the TrueView product suite manufactured by the Symphoniq Corporation of Palo Alto, Calif. In one embodiment, the performance monitoring service  and\/or monitoring agent  includes any portion of the product embodiments referred to as the TeaLeaf CX product suite manufactured by the TeaLeaf Technology Inc. of San Francisco, Calif. In other embodiments, the performance monitoring service  and\/or monitoring agent  includes any portion of the business service management products, such as the BMC Performance Manager and Patrol products, manufactured by BMC Software, Inc. of Houston, Tex.","The client , server , and appliance  may be deployed as and\/or executed on any type and form of computing device, such as a computer, network device or appliance capable of communicating on any type and form of network and performing the operations described herein.  depict block diagrams of a computing device  useful for practicing an embodiment of the client , server  or appliance . As shown in , each computing device  includes a central processing unit , and a main memory unit . As shown in , a computing device  may include a visual display device , a keyboard  and\/or a pointing device , such as a mouse. Each computing device  may also include additional optional elements, such as one or more input\/output devices -(generally referred to using reference numeral ), and a cache memory  in communication with the central processing unit .","The central processing unit  is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments, the central processing unit is provided by a microprocessor unit, such as: those manufactured by Intel Corporation of Mountain View, Calif.; those manufactured by Motorola Corporation of Schaumburg, Ill.; those manufactured by Transmeta Corporation of Santa Clara, Calif.; the RS\/6000 processor, those manufactured by International Business Machines of White Plains, N.Y.; or those manufactured by Advanced Micro Devices of Sunnyvale, Calif. The computing device  may be based on any of these processors, or any other processor capable of operating as described herein.","Main memory unit  may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor , such as Static random access memory (SRAM), Burst SRAM or SynchBurst SRAM (BSRAM), Dynamic random access memory (DRAM), Fast Page Mode DRAM (FPM DRAM), Enhanced DRAM (EDRAM), Extended Data Output RAM (EDO RAM), Extended Data Output DRAM (EDO DRAM), Burst Extended Data Output DRAM (BEDO DRAM), Enhanced DRAM (EDRAM), synchronous DRAM (SDRAM), JEDEC SRAM, PC100 SDRAM, Double Data Rate SDRAM (DDR SDRAM), Enhanced SDRAM (ESDRAM), SyncLink DRAM (SLDRAM), Direct Rambus DRAM (DRDRAM), or Ferroelectric RAM (FRAM). The main memory  may be based on any of the above described memory chips, or any other available memory chips capable of operating as described herein. In the embodiment shown in , the processor  communicates with main memory  via a system bus  (described in more detail below).  depicts an embodiment of a computing device  in which the processor communicates directly with main memory  via a memory port . For example, in  the main memory  may be DRDRAM.",{"@attributes":{"id":"p-0082","num":"0088"},"figref":["FIG. 1F","FIG. 1F","FIG. 1F","FIG. 1F"],"b":["101","140","101","140","150","140","122","101","130","150","101","130","124","101","124","100","101","130","101","130","130"],"i":["b ","b ","a "]},"The computing device  may support any suitable installation device , such as a floppy disk drive for receiving floppy disks such as 3.5-inch, 5.25-inch disks or ZIP disks, a CD-ROM drive, a CD-R\/RW drive, a DVD-ROM drive, tape drives of various formats, USB device, hard-drive or any other device suitable for installing software and programs such as any client agent , or portion thereof. The computing device  may further comprise a storage device , such as one or more hard disk drives or redundant arrays of independent disks, for storing an operating system and other related software, and for storing application software programs such as any program related to the client agent . Optionally, any of the installation devices  could also be used as the storage device . Additionally, the operating system and the software can be run from a bootable medium, for example, a bootable CD, such as KNOPPIX\u00ae, a bootable CD for GNU\/Linux that is available as a GNU\/Linux distribution from knoppix.net.","Furthermore, the computing device  may include a network interface  to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., 802.11, T1, T3, 56 kb, X.25), broadband connections (e.g., ISDN, Frame Relay, ATM), wireless connections, or some combination of any or all of the above. The network interface  may comprise a built-in network adapter, network interface card, PCMCIA network card, card bus network adapter, wireless network adapter, USB network adapter, modem or any other device suitable for interfacing the computing device  to any type of network capable of communication and performing the operations described herein. A wide variety of I\/O devices -may be present in the computing device . Input devices include keyboards, mice, trackpads, trackballs, microphones, and drawing tablets. Output devices include video displays, speakers, inkjet printers, laser printers, and dye-sublimation printers. The I\/O devices  may be controlled by an I\/O controller  as shown in . The I\/O controller may control one or more I\/O devices such as a keyboard  and a pointing device , e.g., a mouse or optical pen. Furthermore, an I\/O device may also provide storage  and\/or an installation medium  for the computing device . In still other embodiments, the computing device  may provide USB connections to receive handheld USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry, Inc. of Los Alamitos, Calif.","In some embodiments, the computing device  may comprise or be connected to multiple display devices -, which each may be of the same or different type and\/or form. As such, any of the I\/O devices -and\/or the I\/O controller  may comprise any type and\/or form of suitable hardware, software, or combination of hardware and software to support, enable or provide for the connection and use of multiple display devices -by the computing device . For example, the computing device  may include any type and\/or form of video adapter, video card, driver, and\/or library to interface, communicate, connect or otherwise use the display devices -. In one embodiment, a video adapter may comprise multiple connectors to interface to multiple display devices -. In other embodiments, the computing device  may include multiple video adapters, with each video adapter connected to one or more of the display devices -. In some embodiments, any portion of the operating system of the computing device  may be configured for using multiple displays -. In other embodiments, one or more of the display devices -may be provided by one or more other computing devices, such as computing devices and connected to the computing device , for example, via a network. These embodiments may include any type of software designed and constructed to use another computer's display device as a second display device for the computing device . One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a computing device  may be configured to have multiple display devices -","In further embodiments, an I\/O device  may be a bridge  between the system bus  and an external communication bus, such as a USB bus, an Apple Desktop Bus, an RS-232 serial connection, a SCSI bus, a FireWire bus, a FireWire  bus, an Ethernet bus, an AppleTalk bus, a Gigabit Ethernet bus, an Asynchronous Transfer Mode bus, a HIPPI bus, a Super HIPPI bus, a SerialPlus bus, a SCI\/LAMP bus, a FibreChannel bus, or a Serial Attached small computer system interface bus.","A computing device  of the sort depicted in  typically operate under the control of operating systems, which control scheduling of tasks and access to system resources. The computing device  can be running any operating system such as any of the versions of the Microsoft\u00ae Windows operating systems, the different releases of the Unix and Linux operating systems, any version of the Mac OS\u00ae for Macintosh computers, any embedded operating system, any real-time operating system, any open source operating system, any proprietary operating system, any operating systems for mobile computing devices, or any other operating system capable of running on the computing device and performing the operations described herein. Typical operating systems include: WINDOWS 3.x, WINDOWS 95, WINDOWS 98, WINDOWS 2000, WINDOWS NT 3.51, WINDOWS NT 4.0, WINDOWS CE, and WINDOWS XP, all of which are manufactured by Microsoft Corporation of Redmond, Wash.; MacOS, manufactured by Apple Computer of Cupertino, California; OS\/2, manufactured by International Business Machines of Armonk, N.Y.; and Linux, a freely-available operating system distributed by Caldera Corp. of Salt Lake City, Utah, or any type and\/or form of a Unix operating system, among others.","In other embodiments, the computing device  may have different processors, operating systems, and input devices consistent with the device. For example, in one embodiment the computer  is a Treo 180, 270, 1060, 600 or 650 smart phone manufactured by Palm, Inc. In this embodiment, the Treo smart phone is operated under the control of the PalmOS operating system and includes a stylus input device as well as a five-way navigator device. Moreover, the computing device  can be any workstation, desktop computer, laptop or notebook computer, server, handheld computer, mobile telephone, any other computer, or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.","As shown in , the computing device  may comprise multiple processors and may provide functionality for simultaneous execution of instructions or for simultaneous execution of one instruction on more than one piece of data. In some embodiments, the computing device  may comprise a parallel processor with one or more cores. In one of these embodiments, the computing device  is a shared memory parallel device, with multiple processors and\/or multiple processor cores, accessing all available memory as a single global address space. In another of these embodiments, the computing device  is a distributed memory parallel device with multiple processors each accessing local memory only. In still another of these embodiments, the computing device  has both some memory which is shared and some memory which can only be accessed by particular processors or subsets of processors. In still even another of these embodiments, the computing device , such as a multi-core microprocessor, combines two or more independent processors into a single package, often a single integrated circuit (IC). In yet another of these embodiments, the computing device  includes a chip having a CELL BROADBAND ENGINE architecture and including a Power processor element and a plurality of synergistic processing elements, the Power processor element and the plurality of synergistic processing elements linked together by an internal high speed bus, which may be referred to as an element interconnect bus.","In some embodiments, the processors provide functionality for execution of a single instruction simultaneously on multiple pieces of data (SIMD). In other embodiments, the processors provide functionality for execution of multiple instructions simultaneously on multiple pieces of data (MIMD). In still other embodiments, the processor may use any combination of SIMD and MIMD cores in a single device.","In some embodiments, the computing device  may comprise a graphics processing unit. In one of these embodiments, depicted in , the computing device  includes at least one central processing unit  and at least one graphics processing unit. In another of these embodiments, the computing device  includes at least one parallel processing unit and at least one graphics processing unit. In still another of these embodiments, the computing device  includes a plurality of processing units of any type, one of the plurality of processing units comprising a graphics processing unit.","In some embodiments, a first computing device executes an application on behalf of a user of a client computing device . In other embodiments, a computing device executes a virtual machine, which provides an execution session within which applications execute on behalf of a user or a client computing devices . In one of these embodiments, the execution session is a hosted desktop session. In another of these embodiments, the computing device  executes a terminal services session. The terminal services session may provide a hosted desktop environment. In still another of these embodiments, the execution session provides access to a computing environment, which may comprise one or more of: an application, a plurality of applications, a desktop application, and a desktop session in which one or more applications may execute.","B. Appliance Architecture",{"@attributes":{"id":"p-0093","num":"0099"},"figref":["FIG. 2A","FIG. 2A","FIG. 2"],"b":["200","200","200","206","202","204"]},"Hardware layer  provides the hardware elements upon which programs and services within kernel space  and user space  are executed. Hardware layer  also provides the structures and elements which allow programs and services within kernel space  and user space  to communicate data both internally and externally with respect to appliance . As shown in , the hardware layer  includes a processing unit  for executing software programs and services, a memory  for storing software and data, network ports  for transmitting and receiving data over a network, and an encryption processor  for performing functions related to Secure Sockets Layer processing of data transmitted and received over the network. In some embodiments, the central processing unit  may perform the functions of the encryption processor  in a single processor. Additionally, the hardware layer  may comprise multiple processors for each of the processing unit  and the encryption processor . The processor  may include any of the processors  described above in connection with . For example, in one embodiment, the appliance  comprises a first processor  and a second processor \u2032. In other embodiments, the processor  or \u2032 comprises a multi-core processor.","Although the hardware layer  of appliance  is generally illustrated with an encryption processor , processor  may be a processor for performing functions related to any encryption protocol, such as the Secure Socket Layer (SSL) or Transport Layer Security (TLS) protocol. In some embodiments, the processor  may be a general purpose processor (GPP), and in further embodiments, may have executable instructions for performing processing of any security related protocol.","Although the hardware layer  of appliance  is illustrated with certain elements in , the hardware portions or components of appliance  may comprise any type and form of elements, hardware or software, of a computing device, such as the computing device  illustrated and discussed herein in conjunction with . In some embodiments, the appliance  may comprise a server, gateway, router, switch, bridge or other type of computing or network device, and have any hardware and\/or software elements associated therewith.","The operating system of appliance  allocates, manages, or otherwise segregates the available system memory into kernel space  and user space . In example software architecture , the operating system may be any type and\/or form of Unix operating system although the invention is not so limited. As such, the appliance  can be running any operating system such as any of the versions of the Microsoft\u00ae Windows operating systems, the different releases of the Unix and Linux operating systems, any version of the Mac OS\u00ae for Macintosh computers, any embedded operating system, any network operating system, any real-time operating system, any open source operating system, any proprietary operating system, any operating systems for mobile computing devices or network devices, or any other operating system capable of running on the appliance  and performing the operations described herein.","The kernel space  is reserved for running the kernel , including any device drivers, kernel extensions or other kernel related software. As known to those skilled in the art, the kernel  is the core of the operating system, and provides access, control, and management of resources and hardware-related elements of the application . In accordance with an embodiment of the appliance , the kernel space  also includes a number of network services or processes working in conjunction with a cache manager , sometimes also referred to as the integrated cache, the benefits of which are described in detail further herein. Additionally, the embodiment of the kernel  will depend on the embodiment of the operating system installed, configured, or otherwise used by the device .","In one embodiment, the device  comprises one network stack , such as a TCP\/IP based stack, for communicating with the client  and\/or the server . In one embodiment, the network stack  is used to communicate with a first network, such as network , and a second network . In some embodiments, the device  terminates a first transport layer connection, such as a TCP connection of a client , and establishes a second transport layer connection to a server  for use by the client , e.g., the second transport layer connection is terminated at the appliance  and the server . The first and second transport layer connections may be established via a single network stack . In other embodiments, the device  may comprise multiple network stacks, for example  and \u2032, and the first transport layer connection may be established or terminated at one network stack , and the second transport layer connection on the second network stack \u2032. For example, one network stack may be for receiving and transmitting network packet on a first network, and another network stack for receiving and transmitting network packets on a second network. In one embodiment, the network stack  comprises a buffer  for queuing one or more network packets for transmission by the appliance .","As shown in , the kernel space  includes the cache manager , a high-speed layer - integrated packet engine , an encryption engine , a policy engine  and multi-protocol compression logic . Running these components or processes , , ,  and  in kernel space  or kernel mode instead of the user space  improves the performance of each of these components, alone and in combination. Kernel operation means that these components or processes , , ,  and  run in the core address space of the operating system of the device . For example, running the encryption engine  in kernel mode improves encryption performance by moving encryption and decryption operations to the kernel, thereby reducing the number of transitions between the memory space or a kernel thread in kernel mode and the memory space or a thread in user mode. For example, data obtained in kernel mode may not need to be passed or copied to a process or thread running in user mode, such as from a kernel level data structure to a user level data structure. In another aspect, the number of context switches between kernel mode and user mode are also reduced. Additionally, synchronization of and communications between any of the components or processes , , ,  and  can be performed more efficiently in the kernel space .","In some embodiments, any portion of the components , , ,  and  may run or operate in the kernel space , while other portions of these components , , ,  and  may run or operate in user space . In one embodiment, the appliance  uses a kernel-level data structure providing access to any portion of one or more network packets, for example, a network packet comprising a request from a client  or a response from a server . In some embodiments, the kernel-level data structure may be obtained by the packet engine  via a transport layer driver interface or filter to the network stack . The kernel-level data structure may comprise any interface and\/or data accessible via the kernel space  related to the network stack , network traffic or packets received or transmitted by the network stack . In other embodiments, the kernel-level data structure may be used by any of the components or processes , , ,  and  to perform the desired operation of the component or process. In one embodiment, a component , , ,  and  is running in kernel mode  when using the kernel-level data structure, while in another embodiment, the component , , ,  and  is running in user mode when using the kernel-level data structure. In some embodiments, the kernel-level data structure may be copied or passed to a second kernel-level data structure, or any desired user-level data structure.","The cache manager  may comprise software, hardware or any combination of software and hardware to provide cache access, control and management of any type and form of content, such as objects or dynamically generated objects served by the originating servers . The data, objects or content processed and stored by the cache manager  may comprise data in any format, such as a markup language, or communicated via any protocol. In some embodiments, the cache manager  duplicates original data stored elsewhere or data previously computed, generated or transmitted, in which the original data may require longer access time to fetch, compute or otherwise obtain relative to reading a cache memory element. Once the data is stored in the cache memory element, future use can be made by accessing the cached copy rather than refetching or recomputing the original data, thereby reducing the access time. In some embodiments, the cache memory element may comprise a data object in memory  of device . In other embodiments, the cache memory element may comprise memory having a faster access time than memory . In another embodiment, the cache memory element may comprise any type and form of storage element of the device , such as a portion of a hard disk. In some embodiments, the processing unit  may provide cache memory for use by the cache manager . In yet further embodiments, the cache manager  may use any portion and combination of memory, storage, or the processing unit for caching data, objects, and other content.","Furthermore, the cache manager  includes any logic, functions, rules, or operations to perform any embodiments of the techniques of the appliance  described herein. For example, the cache manager  includes logic or functionality to invalidate objects based on the expiration of an invalidation time period or upon receipt of an invalidation command from a client  or server . In some embodiments, the cache manager  may operate as a program, service, process or task executing in the kernel space , and in other embodiments, in the user space . In one embodiment, a first portion of the cache manager  executes in the user space  while a second portion executes in the kernel space . In some embodiments, the cache manager  can comprise any type of general purpose processor (GPP), or any other type of integrated circuit, such as a Field Programmable Gate Array (FPGA), Programmable Logic Device (PLD), or Application Specific Integrated Circuit (ASIC).","The policy engine  may include, for example, an intelligent statistical engine or other programmable application(s). In one embodiment, the policy engine  provides a configuration mechanism to allow a user to identify, specify, define or configure a caching policy. Policy engine , in some embodiments, also has access to memory to support data structures such as lookup tables or hash tables to enable user-selected caching policy decisions. In other embodiments, the policy engine  may comprise any logic, rules, functions or operations to determine and provide access, control and management of objects, data or content being cached by the appliance  in addition to access, control and management of security, network traffic, network access, compression or any other function or operation performed by the appliance . Further examples of specific caching policies are further described herein.","The encryption engine  comprises any logic, business rules, functions or operations for handling the processing of any security related protocol, such as SSL or TLS, or any function related thereto. For example, the encryption engine  encrypts and decrypts network packets, or any portion thereof, communicated via the appliance . The encryption engine  may also setup or establish SSL or TLS connections on behalf of the client -, server -, or appliance . As such, the encryption engine  provides offloading and acceleration of SSL processing. In one embodiment, the encryption engine  uses a tunneling protocol to provide a virtual private network between a client -and a server -. In some embodiments, the encryption engine  is in communication with the Encryption processor . In other embodiments, the encryption engine  comprises executable instructions running on the Encryption processor .","The multi-protocol compression engine  comprises any logic, business rules, function or operations for compressing one or more protocols of a network packet, such as any of the protocols used by the network stack  of the device . In one embodiment, multi-protocol compression engine  compresses bi-directionally between clients -and servers -any TCP\/IP based protocol, including Messaging Application Programming Interface (MAPI) (email), File Transfer Protocol (FTP), HyperText Transfer Protocol (HTTP), Common Internet File System (CIFS) protocol (file transfer), Independent Computing Architecture (ICA) protocol, Remote Desktop Protocol (RDP), Wireless Application Protocol (WAP), Mobile IP protocol, and Voice Over IP (VoIP) protocol. In other embodiments, multi-protocol compression engine  provides compression of Hypertext Markup Language (HTML) based protocols and in some embodiments, provides compression of any markup languages, such as the Extensible Markup Language (XML). In one embodiment, the multi-protocol compression engine  provides compression of any high-performance protocol, such as any protocol designed for appliance  to appliance  communications. In another embodiment, the multi-protocol compression engine  compresses any payload of or any communication using a modified transport control protocol, such as Transaction TCP (T\/TCP), TCP with selection acknowledgements (TCP-SACK), TCP with large windows (TCP-LW), a congestion prediction protocol such as the TCP-Vegas protocol, and a TCP spoofing protocol.","As such, the multi-protocol compression engine  accelerates performance for users accessing applications via desktop clients, e.g., Microsoft Outlook and non-Web thin clients, such as any client launched by popular enterprise applications like Oracle, SAP and Siebel, and even mobile clients, such as the Pocket PC. In some embodiments, the multi-protocol compression engine  by executing in the kernel mode  and integrating with packet processing engine  accessing the network stack  is able to compress any of the protocols carried by the TCP\/IP protocol, such as any application layer protocol.","High speed layer - integrated packet engine , also generally referred to as a packet processing engine or packet engine, is responsible for managing the kernel-level processing of packets received and transmitted by appliance  via network ports . The high speed layer - integrated packet engine  may comprise a buffer for queuing one or more network packets during processing, such as for receipt of a network packet or transmission of a network packet. Additionally, the high speed layer - integrated packet engine  is in communication with one or more network stacks  to send and receive network packets via network ports . The high speed layer - integrated packet engine  works in conjunction with encryption engine , cache manager , policy engine  and multi-protocol compression logic . In particular, encryption engine  is configured to perform SSL processing of packets, policy engine  is configured to perform functions related to traffic management such as request-level content switching and request-level cache redirection, and multi-protocol compression logic  is configured to perform functions related to compression and decompression of data.","The high speed layer - integrated packet engine  includes a packet processing timer . In one embodiment, the packet processing timer  provides one or more time intervals to trigger the processing of incoming, i.e., received, or outgoing, i.e., transmitted, network packets. In some embodiments, the high speed layer - integrated packet engine  processes network packets responsive to the timer . The packet processing timer  provides any type and form of signal to the packet engine  to notify, trigger, or communicate a time related event, interval or occurrence. In many embodiments, the packet processing timer  operates in the order of milliseconds, such as for example 100 ms, 50 ms or 25 ms. For example, in some embodiments, the packet processing timer  provides time intervals or otherwise causes a network packet to be processed by the high speed layer - integrated packet engine  at a 10 ms time interval, while in other embodiments, at a 5 ms time interval, and still yet in further embodiments, as short as a 3, 2, or 1 ms time interval. The high speed layer - integrated packet engine  may be interfaced, integrated or in communication with the encryption engine , cache manager , policy engine  and multi-protocol compression engine  during operation. As such, any of the logic, functions, or operations of the encryption engine , cache manager , policy engine  and multi-protocol compression logic  may be performed responsive to the packet processing timer  and\/or the packet engine . Therefore, any of the logic, functions, or operations of the encryption engine , cache manager , policy engine  and multi-protocol compression logic  may be performed at the granularity of time intervals provided via the packet processing timer , for example, at a time interval of less than or equal to 10 ms. For example, in one embodiment, the cache manager  may perform invalidation of any cached objects responsive to the high speed layer - integrated packet engine  and\/or the packet processing timer . In another embodiment, the expiry or invalidation time of a cached object can be set to the same order of granularity as the time interval of the packet processing timer , such as at every 10 ms.","In contrast to kernel space , user space  is the memory area or portion of the operating system used by user mode applications or programs otherwise running in user mode. A user mode application may not access kernel space  directly and uses service calls in order to access kernel services. As shown in , user space  of appliance  includes a graphical user interface (GUI) , a command line interface (CLI) , shell services , health monitoring program , and daemon services . GUI  and CLI  provide a means by which a system administrator or other user can interact with and control the operation of appliance , such as via the operating system of the appliance . The GUI  or CLI  can comprise code running in user space  or kernel space . The GUI  may be any type and form of graphical user interface and may be presented via text, graphical or otherwise, by any type of program or application, such as a browser. The CLI  may be any type and form of command line or text-based interface, such as a command line provided by the operating system. For example, the CLI  may comprise a shell, which is a tool to enable users to interact with the operating system. In some embodiments, the CLI  may be provided via a bash, csh, tcsh, or ksh type shell. The shell services  comprises the programs, services, tasks, processes or executable instructions to support interaction with the appliance  or operating system by a user via the GUI  and\/or CLI .","Health monitoring program  is used to monitor, check, report and ensure that network systems are functioning properly and that users are receiving requested content over a network. Health monitoring program  comprises one or more programs, services, tasks, processes or executable instructions to provide logic, rules, functions or operations for monitoring any activity of the appliance . In some embodiments, the health monitoring program  intercepts and inspects any network traffic passed via the appliance . In other embodiments, the health monitoring program  interfaces by any suitable means and\/or mechanisms with one or more of the following: the encryption engine , cache manager , policy engine , multi-protocol compression logic , packet engine , daemon services , and shell services . As such, the health monitoring program  may call any application programming interface (API) to determine a state, status, or health of any portion of the appliance . For example, the health monitoring program  may ping or send a status inquiry on a periodic basis to check if a program, process, service or task is active and currently running In another example, the health monitoring program  may check any status, error or history logs provided by any program, process, service or task to determine any condition, status or error with any portion of the appliance .","Daemon services  are programs that run continuously or in the background and handle periodic service requests received by appliance . In some embodiments, a daemon service may forward the requests to other programs or processes, such as another daemon service  as appropriate. As known to those skilled in the art, a daemon service  may run unattended to perform continuous or periodic system wide functions, such as network control, or to perform any desired task. In some embodiments, one or more daemon services  run in the user space , while in other embodiments, one or more daemon services  run in the kernel space.","Referring now to , another embodiment of the appliance  is depicted. In brief overview, the appliance  provides one or more of the following services, functionality or operations: SSL VPN connectivity , switching\/load balancing , Domain Name Service resolution , acceleration  and an application firewall  for communications between one or more clients  and one or more servers . Each of the servers  may provide one or more network related services -(referred to as services ). For example, a server  may provide an http service . The appliance  comprises one or more virtual servers or virtual internet protocol servers, referred to as a vServer, VIP server, or just VIP -(also referred herein as vServer ). The vServer  receives, intercepts or otherwise processes communications between a client  and a server  in accordance with the configuration and operations of the appliance .","The vServer  may comprise software, hardware or any combination of software and hardware. The vServer  may comprise any type and form of program, service, task, process or executable instructions operating in user mode , kernel mode  or any combination thereof in the appliance . The vServer  includes any logic, functions, rules, or operations to perform any embodiments of the techniques described herein, such as SSL VPN , switching\/load balancing , Domain Name Service resolution , acceleration  and an application firewall . In some embodiments, the vServer  establishes a connection to a service  of a server . The service  may comprise any program, application, process, task or set of executable instructions capable of connecting to and communicating to the appliance , client  or vServer . For example, the service  may comprise a web server, http server, ftp, email or database server. In some embodiments, the service  is a daemon process or network driver for listening, receiving and\/or sending communications for an application, such as email, database or an enterprise application. In some embodiments, the service  may communicate on a specific IP address, or IP address and port.","In some embodiments, the vServer  applies one or more policies of the policy engine  to network communications between the client  and server . In one embodiment, the policies are associated with a vServer . In another embodiment, the policies are based on a user, or a group of users. In yet another embodiment, a policy is global and applies to one or more vServers -, and any user or group of users communicating via the appliance . In some embodiments, the policies of the policy engine have conditions upon which the policy is applied based on any content of the communication, such as internet protocol address, port, protocol type, header or fields in a packet, or the context of the communication, such as user, group of the user, vServer , transport layer connection, and\/or identification or attributes of the client  or server .","In other embodiments, the appliance  communicates or interfaces with the policy engine  to determine authentication and\/or authorization of a remote user or a remote client  to access the computing environment , application, and\/or data file from a server . In another embodiment, the appliance  communicates or interfaces with the policy engine  to determine authentication and\/or authorization of a remote user or a remote client  to have the application delivery system  deliver one or more of the computing environment , application, and\/or data file. In yet another embodiment, the appliance  establishes a VPN or SSL VPN connection based on the policy engine's  authentication and\/or authorization of a remote user or a remote client  In one embodiment, the appliance  controls the flow of network traffic and communication sessions based on policies of the policy engine . For example, the appliance  may control the access to a computing environment , application or data file based on the policy engine .","In some embodiments, the vServer  establishes a transport layer connection, such as a TCP or UDP connection with a client  via the client agent . In one embodiment, the vServer  listens for and receives communications from the client . In other embodiments, the vServer  establishes a transport layer connection, such as a TCP or UDP connection with a client server . In one embodiment, the vServer  establishes the transport layer connection to an internet protocol address and port of a server  running on the server . In another embodiment, the vServer  associates a first transport layer connection to a client  with a second transport layer connection to the server . In some embodiments, a vServer  establishes a pool of transport layer connections to a server  and multiplexes client requests via the pooled transport layer connections.","In some embodiments, the appliance  provides a SSL VPN connection  between a client  and a server . For example, a client  on a first network  requests to establish a connection to a server  on a second network \u2032. In some embodiments, the second network \u2032 is not routable from the first network . In other embodiments, the client  is on a public network  and the server  is on a private network \u2032, such as a corporate network. In one embodiment, the client agent  intercepts communications of the client  on the first network , encrypts the communications, and transmits the communications via a first transport layer connection to the appliance . The appliance  associates the first transport layer connection on the first network  to a second transport layer connection to the server  on the second network . The appliance  receives the intercepted communication from the client agent , decrypts the communications, and transmits the communication to the server  on the second network  via the second transport layer connection. The second transport layer connection may be a pooled transport layer connection. As such, the appliance  provides an end-to-end secure transport layer connection for the client  between the two networks , \u2032.","In one embodiment, the appliance  hosts an intranet internet protocol or IntranetIP  address of the client  on the virtual private network . The client  has a local network identifier, such as an internet protocol (IP) address and\/or host name on the first network . When connected to the second network \u2032 via the appliance , the appliance  establishes, assigns or otherwise provides an IntranetIP address , which is a network identifier, such as IP address and\/or host name, for the client  on the second network \u2032. The appliance  listens for and receives on the second or private network \u2032 for any communications directed towards the client  using the client's established IntranetIP . In one embodiment, the appliance  acts as or on behalf of the client  on the second private network . For example, in another embodiment, a vServer  listens for and responds to communications to the IntranetIP  of the client . In some embodiments, if a computing device  on the second network \u2032 transmits a request, the appliance  processes the request as if it were the client . For example, the appliance  may respond to a ping to the client's IntranetIP . In another example, the appliance may establish a connection, such as a TCP or UDP connection, with computing device  on the second network  requesting a connection with the client's IntranetIP .","In some embodiments, the appliance  provides one or more of the following acceleration techniques  to communications between the client  and server : 1) compression; 2) decompression; 3) Transmission Control Protocol pooling; 4) Transmission Control Protocol multiplexing; 5) Transmission Control Protocol buffering; and 6) caching. In one embodiment, the appliance  relieves servers  of much of the processing load caused by repeatedly opening and closing transport layers connections to clients  by opening one or more transport layer connections with each server  and maintaining these connections to allow repeated data accesses by clients via the Internet. This technique is referred to herein as \u201cconnection pooling\u201d.","In some embodiments, in order to seamlessly splice communications from a client  to a server  via a pooled transport layer connection, the appliance  translates or multiplexes communications by modifying sequence number and acknowledgment numbers at the transport layer protocol level. This is referred to as \u201cconnection multiplexing\u201d. In some embodiments, no application layer protocol interaction is required. For example, in the case of an in-bound packet (that is, a packet received from a client ), the source network address of the packet is changed to that of an output port of appliance , and the destination network address is changed to that of the intended server. In the case of an outbound packet (that is, one received from a server ), the source network address is changed from that of the server  to that of an output port of appliance  and the destination address is changed from that of appliance  to that of the requesting client . The sequence numbers and acknowledgment numbers of the packet are also translated to sequence numbers and acknowledgement numbers expected by the client  on the appliance's  transport layer connection to the client . In some embodiments, the packet checksum of the transport layer protocol is recalculated to account for these translations.","In another embodiment, the appliance  provides switching or load-balancing functionality  for communications between the client  and server . In some embodiments, the appliance  distributes traffic and directs client requests to a server  based on layer  or application-layer request data. In one embodiment, although the network layer or layer  of the network packet identifies a destination server , the appliance  determines the server  to distribute the network packet by application information and data carried as payload of the transport layer packet. In one embodiment, the health monitoring programs  of the appliance  monitor the health of servers to determine the server  for which to distribute a client's request. In some embodiments, if the appliance  detects a server  is not available or has a load over a predetermined threshold, the appliance  can direct or distribute client requests to another server .","In some embodiments, the appliance  acts as a Domain Name Service (DNS) resolver or otherwise provides resolution of a DNS request from clients . In some embodiments, the appliance intercepts a DNS request transmitted by the client . In one embodiment, the appliance  responds to a client's DNS request with an IP address of or hosted by the appliance . In this embodiment, the client  transmits network communication for the domain name to the appliance . In another embodiment, the appliance  responds to a client's DNS request with an IP address of or hosted by a second appliance \u2032. In some embodiments, the appliance  responds to a client's DNS request with an IP address of a server  determined by the appliance .","In yet another embodiment, the appliance  provides application firewall functionality  for communications between the client  and server . In one embodiment, the policy engine  provides rules for detecting and blocking illegitimate requests. In some embodiments, the application firewall  protects against denial of service (DoS) attacks. In other embodiments, the appliance inspects the content of intercepted requests to identify and block application-based attacks. In some embodiments, the rules\/policy engine  comprises one or more application firewall or security control policies for providing protections against various classes and types of web or Internet based vulnerabilities, such as one or more of the following: 1) buffer overflow, 2) CGI-BIN parameter manipulation, 3) form\/hidden field manipulation, 4) forceful browsing, 5) cookie or session poisoning, 6) broken access control list (ACLs) or weak passwords, 7) cross-site scripting (XSS), 8) command injection, 9) SQL injection, 10) error triggering sensitive information leak, 11) insecure use of cryptography, 12) server misconfiguration, 13) back doors and debug options, 14) website defacement, 15) platform or operating systems vulnerabilities, and 16) zero-day exploits. In an embodiment, the application firewall  provides HTML form field protection in the form of inspecting or analyzing the network communication for one or more of the following: 1) required fields are returned, 2) no added field allowed, 3) read-only and hidden field enforcement, 4) drop-down list and radio button field conformance, and 5) form-field max-length enforcement. In some embodiments, the application firewall  ensures cookies are not modified. In other embodiments, the application firewall  protects against forceful browsing by enforcing legal URLs.","In still yet other embodiments, the application firewall  protects any confidential information contained in the network communication. The application firewall  may inspect or analyze any network communication in accordance with the rules or polices of the engine  to identify any confidential information in any field of the network packet. In some embodiments, the application firewall  identifies in the network communication one or more occurrences of a credit card number, password, social security number, name, patient code, contact information, and age. The encoded portion of the network communication may comprise these occurrences or the confidential information. Based on these occurrences, in one embodiment, the application firewall  may take a policy action on the network communication, such as prevent transmission of the network communication. In another embodiment, the application firewall  may rewrite, remove or otherwise mask such identified occurrence or confidential information.","Still referring to , the appliance  may include a performance monitoring agent  as discussed above in conjunction with . In one embodiment, the appliance  receives the monitoring agent  from the monitoring service  or monitoring server  as depicted in . In some embodiments, the appliance  stores the monitoring agent  in storage, such as disk, for delivery to any client or server in communication with the appliance . For example, in one embodiment, the appliance  transmits the monitoring agent  to a client upon receiving a request to establish a transport layer connection. In other embodiments, the appliance  transmits the monitoring agent  upon establishing the transport layer connection with the client . In another embodiment, the appliance  transmits the monitoring agent  to the client upon intercepting or detecting a request for a web page. In yet another embodiment, the appliance  transmits the monitoring agent  to a client or a server in response to a request from the monitoring server . In one embodiment, the appliance  transmits the monitoring agent  to a second appliance \u2032 or appliance .","In other embodiments, the appliance  executes the monitoring agent . In one embodiment, the monitoring agent  measures and monitors the performance of any application, program, process, service, task or thread executing on the appliance . For example, the monitoring agent  may monitor and measure performance and operation of vServers A-N. In another embodiment, the monitoring agent  measures and monitors the performance of any transport layer connections of the appliance . In some embodiments, the monitoring agent  measures and monitors the performance of any user sessions traversing the appliance . In one embodiment, the monitoring agent  measures and monitors the performance of any virtual private network connections and\/or sessions traversing the appliance , such an SSL VPN session. In still further embodiments, the monitoring agent  measures and monitors the memory, CPU and disk usage and performance of the appliance . In yet another embodiment, the monitoring agent  measures and monitors the performance of any acceleration technique  performed by the appliance , such as SSL offloading, connection pooling and multiplexing, caching, and compression. In some embodiments, the monitoring agent  measures and monitors the performance of any load balancing and\/or content switching  performed by the appliance . In other embodiments, the monitoring agent  measures and monitors the performance of application firewall  protection and processing performed by the appliance .","C. Client Agent","Referring now to , an embodiment of the client agent  is depicted. The client  includes a client agent  for establishing and exchanging communications with the appliance  and\/or server  via a network . In brief overview, the client  operates on computing device  having an operating system with a kernel mode  and a user mode , and a network stack  with one or more layers -. The client  may have installed and\/or execute one or more applications. In some embodiments, one or more applications may communicate via the network stack  to a network . One of the applications, such as a web browser, may also include a first program . For example, the first program  may be used in some embodiments to install and\/or execute the client agent , or any portion thereof. The client agent  includes an interception mechanism, or interceptor , for intercepting network communications from the network stack  from the one or more applications.","The network stack  of the client  may comprise any type and form of software, or hardware, or any combinations thereof, for providing connectivity to and communications with a network. In one embodiment, the network stack  comprises a software implementation for a network protocol suite. The network stack  may comprise one or more network layers, such as any networks layers of the Open Systems Interconnection (OSI) communications model as those skilled in the art recognize and appreciate. As such, the network stack  may comprise any type and form of protocols for any of the following layers of the OSI model: 1) physical link layer, 2) data link layer, 3) network layer, 4) transport layer, 5) session layer, 6) presentation layer, and 7) application layer. In one embodiment, the network stack  may comprise a transport control protocol (TCP) over the network layer protocol of the internet protocol (IP), generally referred to as TCP\/IP. In some embodiments, the TCP\/IP protocol may be carried over the Ethernet protocol, which may comprise any of the family of IEEE wide-area-network (WAN) or local-area-network (LAN) protocols, such as those protocols covered by the IEEE 802.3. In some embodiments, the network stack  comprises any type and form of a wireless protocol, such as IEEE 802.11 and\/or mobile internet protocol.","In view of a TCP\/IP based network, any TCP\/IP based protocol may be used, including Messaging Application Programming Interface (MAPI) (email), File Transfer Protocol (FTP), HyperText Transfer Protocol (HTTP), Common Internet File System (CIFS) protocol (file transfer), Independent Computing Architecture (ICA) protocol, Remote Desktop Protocol (RDP), Wireless Application Protocol (WAP), Mobile IP protocol, and Voice Over IP (VoIP) protocol. In another embodiment, the network stack  comprises any type and form of transport control protocol, such as a modified transport control protocol, for example a Transaction TCP (T\/TCP), TCP with selection acknowledgements (TCP-SACK), TCP with large windows (TCP-LW), a congestion prediction protocol such as the TCP-Vegas protocol, and a TCP spoofing protocol. In other embodiments, any type and form of user datagram protocol (UDP), such as UDP over IP, may be used by the network stack , such as for voice communications or real-time data communications.","Furthermore, the network stack  may include one or more network drivers supporting the one or more layers, such as a TCP driver or a network layer driver. The network drivers may be included as part of the operating system of the computing device  or as part of any network interface cards or other network access components of the computing device . In some embodiments, any of the network drivers of the network stack  may be customized, modified or adapted to provide a custom or modified portion of the network stack  in support of any of the techniques described herein. In other embodiments, the acceleration program  is designed and constructed to operate with or work in conjunction with the network stack  installed or otherwise provided by the operating system of the client .","The network stack  comprises any type and form of interfaces for receiving, obtaining, providing or otherwise accessing any information and data related to network communications of the client . In one embodiment, an interface to the network stack  comprises an application programming interface (API). The interface may also comprise any function call, hooking or filtering mechanism, event or call back mechanism, or any type of interfacing technique. The network stack  via the interface may receive or provide any type and form of data structure, such as an object, related to functionality or operation of the network stack . For example, the data structure may comprise information and data related to a network packet or one or more network packets. In some embodiments, the data structure comprises a portion of the network packet processed at a protocol layer of the network stack , such as a network packet of the transport layer. In some embodiments, the data structure  comprises a kernel-level data structure, while in other embodiments, the data structure  comprises a user-mode data structure. A kernel-level data structure may comprise a data structure obtained or related to a portion of the network stack  operating in kernel-mode , or a network driver or other software running in kernel-mode , or any data structure obtained or received by a service, process, task, thread or other executable instructions running or operating in kernel-mode of the operating system.","Additionally, some portions of the network stack  may execute or operate in kernel-mode , for example, the data link or network layer, while other portions execute or operate in user-mode , such as an application layer of the network stack . For example, a first portion of the network stack may provide user-mode access to the network stack  to an application while a second portion of the network stack  provides access to a network. In some embodiments, a first portion of the network stack may comprise one or more upper layers of the network stack , such as any of layers -. In other embodiments, a second portion of the network stack  comprises one or more lower layers, such as any of layers -. Each of the first portion and second portion of the network stack  may comprise any portion of the network stack , at any one or more network layers, in user-mode , kernel-mode, , or combinations thereof, or at any portion of a network layer or interface point to a network layer or any portion of or interface point to the user-mode  and kernel-mode .","The interceptor  may comprise software, hardware, or any combination of software and hardware. In one embodiment, the interceptor  intercept a network communication at any point in the network stack , and redirects or transmits the network communication to a destination desired, managed or controlled by the interceptor  or client agent . For example, the interceptor  may intercept a network communication of a network stack  of a first network and transmit the network communication to the appliance  for transmission on a second network . In some embodiments, the interceptor  comprises any type interceptor  comprises a driver, such as a network driver constructed and designed to interface and work with the network stack . In some embodiments, the client agent  and\/or interceptor  operates at one or more layers of the network stack , such as at the transport layer. In one embodiment, the interceptor  comprises a filter driver, hooking mechanism, or any form and type of suitable network driver interface that interfaces to the transport layer of the network stack, such as via the transport driver interface (TDI). In some embodiments, the interceptor  interfaces to a first protocol layer, such as the transport layer and another protocol layer, such as any layer above the transport protocol layer, for example, an application protocol layer. In one embodiment, the interceptor  may comprise a driver complying with the Network Driver Interface Specification (NDIS), or a NDIS driver. In another embodiment, the interceptor  may comprise a mini-filter or a mini-port driver. In one embodiment, the interceptor , or portion thereof, operates in kernel-mode . In another embodiment, the interceptor , or portion thereof, operates in user-mode . In some embodiments, a portion of the interceptor  operates in kernel-mode  while another portion of the interceptor  operates in user-mode . In other embodiments, the client agent  operates in user-mode  but interfaces via the interceptor  to a kernel-mode driver, process, service, task or portion of the operating system, such as to obtain a kernel-level data structure . In further embodiments, the interceptor  is a user-mode application or program, such as application.","In one embodiment, the interceptor  intercepts any transport layer connection requests. In these embodiments, the interceptor  execute transport layer application programming interface (API) calls to set the destination information, such as destination IP address and\/or port to a desired location for the location. In this manner, the interceptor  intercepts and redirects the transport layer connection to a IP address and port controlled or managed by the interceptor  or client agent . In one embodiment, the interceptor  sets the destination information for the connection to a local IP address and port of the client  on which the client agent  is listening. For example, the client agent  may comprise a proxy service listening on a local IP address and port for redirected transport layer communications. In some embodiments, the client agent  then communicates the redirected transport layer communication to the appliance .","In some embodiments, the interceptor  intercepts a Domain Name Service (DNS) request. In one embodiment, the client agent  and\/or interceptor  resolves the DNS request. In another embodiment, the interceptor transmits the intercepted DNS request to the appliance  for DNS resolution. In one embodiment, the appliance  resolves the DNS request and communicates the DNS response to the client agent . In some embodiments, the appliance  resolves the DNS request via another appliance \u2032 or a DNS server .","In yet another embodiment, the client agent  may comprise two agents  and \u2032. In one embodiment, a first agent  may comprise an interceptor  operating at the network layer of the network stack . In some embodiments, the first agent  intercepts network layer requests such as Internet Control Message Protocol (ICMP) requests (e.g., ping and traceroute). In other embodiments, the second agent \u2032 may operate at the transport layer and intercept transport layer communications. In some embodiments, the first agent  intercepts communications at one layer of the network stack  and interfaces with or communicates the intercepted communication to the second agent \u2032.","The client agent  and\/or interceptor  may operate at or interface with a protocol layer in a manner transparent to any other protocol layer of the network stack . For example, in one embodiment, the interceptor  operates or interfaces with the transport layer of the network stack  transparently to any protocol layer below the transport layer, such as the network layer, and any protocol layer above the transport layer, such as the session, presentation or application layer protocols. This allows the other protocol layers of the network stack  to operate as desired and without modification for using the interceptor . As such, the client agent  and\/or interceptor  can interface with the transport layer to secure, optimize, accelerate, route or load-balance any communications provided via any protocol carried by the transport layer, such as any application layer protocol over TCP\/IP.","Furthermore, the client agent  and\/or interceptor may operate at or interface with the network stack  in a manner transparent to any application, a user of the client , and any other computing device, such as a server, in communications with the client . The client agent  and\/or interceptor  may be installed and\/or executed on the client  in a manner without modification of an application. In some embodiments, the user of the client  or a computing device in communications with the client  are not aware of the existence, execution or operation of the client agent  and\/or interceptor . As such, in some embodiments, the client agent  and\/or interceptor  is installed, executed, and\/or operated transparently to an application, user of the client , another computing device, such as a server, or any of the protocol layers above and\/or below the protocol layer interfaced to by the interceptor .","The client agent  includes an acceleration program , a streaming client , a collection agent , and\/or monitoring agent . In one embodiment, the client agent  comprises an Independent Computing Architecture (ICA) client, or any portion thereof, developed by Citrix Systems, Inc. of Fort Lauderdale, Fla., and is also referred to as an ICA client. In some embodiments, the client  comprises an application streaming client  for streaming an application from a server  to a client . In some embodiments, the client agent  comprises an acceleration program  for accelerating communications between client  and server . In another embodiment, the client agent  includes a collection agent  for performing end-point detection\/scanning and collecting end-point information for the appliance  and\/or server .","In some embodiments, the acceleration program  comprises a client-side acceleration program for performing one or more acceleration techniques to accelerate, enhance or otherwise improve a client's communications with and\/or access to a server , such as accessing an application provided by a server . The logic, functions, and\/or operations of the executable instructions of the acceleration program  may perform one or more of the following acceleration techniques: 1) multi-protocol compression, 2) transport control protocol pooling, 3) transport control protocol multiplexing, 4) transport control protocol buffering, and 5) caching via a cache manager. Additionally, the acceleration program  may perform encryption and\/or decryption of any communications received and\/or transmitted by the client . In some embodiments, the acceleration program  performs one or more of the acceleration techniques in an integrated manner or fashion. Additionally, the acceleration program  can perform compression on any of the protocols, or multiple-protocols, carried as a payload of a network packet of the transport layer protocol.","The streaming client  comprises an application, program, process, service, task or executable instructions for receiving and executing a streamed application from a server . A server  may stream one or more application data files to the streaming client  for playing, executing or otherwise causing to be executed the application on the client . In some embodiments, the server  transmits a set of compressed or packaged application data files to the streaming client . In some embodiments, the plurality of application files are compressed and stored on a file server within an archive file such as a CAB, ZIP, SIT, TAR, JAR or other archive. In one embodiment, the server  decompresses, unpackages or unarchives the application files and transmits the files to the client . In another embodiment, the client  decompresses, unpackages or unarchives the application files. The streaming client  dynamically installs the application, or portion thereof, and executes the application. In one embodiment, the streaming client  may be an executable program. In some embodiments, the streaming client  may be able to launch another executable program.","The collection agent  comprises an application, program, process, service, task or executable instructions for identifying, obtaining and\/or collecting information about the client . In some embodiments, the appliance  transmits the collection agent  to the client  or client agent . The collection agent  may be configured according to one or more policies of the policy engine  of the appliance. In other embodiments, the collection agent  transmits collected information on the client  to the appliance . In one embodiment, the policy engine  of the appliance  uses the collected information to determine and provide access, authentication and authorization control of the client's connection to a network .","In one embodiment, the collection agent  comprises an end-point detection and scanning mechanism, which identifies and determines one or more attributes or characteristics of the client. For example, the collection agent  may identify and determine any one or more of the following client-side attributes: 1) the operating system an\/or a version of an operating system, 2) a service pack of the operating system, 3) a running service, 4) a running process, and 5) a file. The collection agent  may also identify and determine the presence or versions of any one or more of the following on the client: 1) antivirus software, 2) personal firewall software, 3) anti-spam software, and 4) internet security software. The policy engine  may have one or more policies based on any one or more of the attributes or characteristics of the client or client-side attributes.","In some embodiments, the client agent  includes a monitoring agent  as discussed in conjunction with . The monitoring agent  may be any type and form of script, such as Visual Basic or Java script. In one embodiment, the monitoring agent  monitors and measures performance of any portion of the client agent . For example, in some embodiments, the monitoring agent  monitors and measures performance of the acceleration program . In another embodiment, the monitoring agent  monitors and measures performance of the streaming client . In other embodiments, the monitoring agent  monitors and measures performance of the collection agent . In still another embodiment, the monitoring agent  monitors and measures performance of the interceptor . In some embodiments, the monitoring agent  monitors and measures any resource of the client , such as memory, CPU and disk.","The monitoring agent  may monitor and measure performance of any application of the client. In one embodiment, the monitoring agent  monitors and measures performance of a browser on the client . In some embodiments, the monitoring agent  monitors and measures performance of any application delivered via the client agent . In other embodiments, the monitoring agent  measures and monitors end user response times for an application, such as web-based or HTTP response times. The monitoring agent  may monitor and measure performance of an ICA or RDP client. In another embodiment, the monitoring agent  measures and monitors metrics for a user session or application session. In some embodiments, monitoring agent  measures and monitors an ICA or RDP session. In one embodiment, the monitoring agent  measures and monitors the performance of the appliance  in accelerating delivery of an application and\/or data to the client .","In some embodiments and still referring to , a first program  may be used to install and\/or execute the client agent , or portion thereof, such as the interceptor , automatically, silently, transparently, or otherwise. In one embodiment, the first program  comprises a plugin component, such an ActiveX control or Java control or script that is loaded into and executed by an application. For example, the first program comprises an ActiveX control loaded and run by a web browser application, such as in the memory space or context of the application. In another embodiment, the first program  comprises a set of executable instructions loaded into and run by the application, such as a browser. In one embodiment, the first program  comprises a designed and constructed program to install the client agent . In some embodiments, the first program  obtains, downloads, or receives the client agent  via the network from another computing device. In another embodiment, the first program  is an installer program or a plug and play manager for installing programs, such as network drivers, on the operating system of the client .","D. Systems and Methods for Providing Virtualized Application Delivery Controller","Referring now to , a block diagram depicts one embodiment of a virtualization environment . In brief overview, a computing device  includes a hypervisor layer, a virtualization layer, and a hardware layer. The hypervisor layer includes a hypervisor  (also referred to as a virtualization manager) that allocates and manages access to a number of physical resources in the hardware layer (e.g., the processor(s) , and disk(s) ) by at least one virtual machine executing in the virtualization layer. The virtualization layer includes at least one operating system  and a plurality of virtual resources allocated to the at least one operating system . Virtual resources may include, without limitation, a plurality of virtual processors , , (generally ), and virtual disks , , (generally ), as well as virtual resources such as virtual memory and virtual network interfaces. The plurality of virtual resources and the operating system  may be referred to as a virtual machine . A virtual machine  may include a control operating system  in communication with the hypervisor  and used to execute applications for managing and configuring other virtual machines on the computing device .","In greater detail, a hypervisor  may provide virtual resources to an operating system in any manner which simulates the operating system having access to a physical device. A hypervisor  may provide virtual resources to any number of guest operating systems , (generally ). In some embodiments, a computing device  executes one or more types of hypervisors. In these embodiments, hypervisors may be used to emulate virtual hardware, partition physical hardware, virtualize physical hardware, and execute virtual machines that provide access to computing environments. Hypervisors may include those manufactured by VMWare, Inc., of Palo Alto, Calif.; the XEN hypervisor, an open source product whose development is overseen by the open source Xen.org community; HyperV, VirtualServer or virtual PC hypervisors provided by Microsoft, or others. In some embodiments, a computing device  executing a hypervisor that creates a virtual machine platform on which guest operating systems may execute is referred to as a host server. In one of these embodiments, for example, the computing device  is a XEN SERVER provided by Citrix Systems, Inc., of Fort Lauderdale, Fla.","In some embodiments, a hypervisor  executes within an operating system executing on a computing device. In one of these embodiments, a computing device executing an operating system and a hypervisor  may be said to have a host operating system (the operating system executing on the computing device), and a guest operating system (an operating system executing within a computing resource partition provided by the hypervisor ). In other embodiments, a hypervisor  interacts directly with hardware on a computing device, instead of executing on a host operating system. In one of these embodiments, the hypervisor  may be said to be executing on \u201cbare metal,\u201d referring to the hardware comprising the computing device.","In some embodiments, a hypervisor  may create a virtual machine -(generally ) in which an operating system  executes. In one of these embodiments, for example, the hypervisor  loads a virtual machine image to create a virtual machine . In another of these embodiments, the hypervisor  executes an operating system  within the virtual machine . In still another of these embodiments, the virtual machine  executes an operating system .","In some embodiments, the hypervisor  controls processor scheduling and memory partitioning for a virtual machine  executing on the computing device . In one of these embodiments, the hypervisor  controls the execution of at least one virtual machine . In another of these embodiments, the hypervisor  presents at least one virtual machine  with an abstraction of at least one hardware resource provided by the computing device . In other embodiments, the hypervisor  controls whether and how physical processor capabilities are presented to the virtual machine .","A control operating system  may execute at least one application for managing and configuring the guest operating systems. In one embodiment, the control operating system  may execute an administrative application, such as an application including a user interface providing administrators with access to functionality for managing the execution of a virtual machine, including functionality for executing a virtual machine, terminating an execution of a virtual machine, or identifying a type of physical resource for allocation to the virtual machine. In another embodiment, the hypervisor  executes the control operating system  within a virtual machine  created by the hypervisor . In still another embodiment, the control operating system  executes in a virtual machine  that is authorized to directly access physical resources on the computing device . In some embodiments, a control operating system on a computing device may exchange data with a control operating system on a computing device , via communications between a hypervisor and a hypervisor . In this way, one or more computing devices  may exchange data with one or more of the other computing devices  regarding processors and other physical resources available in a pool of resources. In one of these embodiments, this functionality allows a hypervisor to manage a pool of resources distributed across a plurality of physical computing devices. In another of these embodiments, multiple hypervisors manage one or more of the guest operating systems executed on one of the computing devices .","In one embodiment, the control operating system  executes in a virtual machine  that is authorized to interact with at least one guest operating system . In another embodiment, a guest operating system  communicates with the control operating system  via the hypervisor  in order to request access to a disk or a network. In still another embodiment, the guest operating system  and the control operating system  may communicate via a communication channel established by the hypervisor , such as, for example, via a plurality of shared memory pages made available by the hypervisor .","In some embodiments, the control operating system  includes a network back-end driver for communicating directly with networking hardware provided by the computing device . In one of these embodiments, the network back-end driver processes at least one virtual machine request from at least one guest operating system . In other embodiments, the control operating system  includes a block back-end driver for communicating with a storage element on the computing device . In one of these embodiments, the block back-end driver reads and writes data from the storage element based upon at least one request received from a guest operating system .","In one embodiment, the control operating system  includes a tools stack . In another embodiment, a tools stack  provides functionality for interacting with the hypervisor , communicating with other control operating systems  (for example, on a second computing device ), or managing virtual machines , on the computing device . In another embodiment, the tools stack  includes customized applications for providing improved management functionality to an administrator of a virtual machine farm. In some embodiments, at least one of the tools stack  and the control operating system  include a management API that provides an interface for remotely configuring and controlling virtual machines  running on a computing device . In other embodiments, the control operating system  communicates with the hypervisor  through the tools stack .","In one embodiment, the hypervisor  executes a guest operating system  within a virtual machine  created by the hypervisor . In another embodiment, the guest operating system  provides a user of the computing device  with access to resources within a computing environment. In still another embodiment, a resource includes a program, an application, a document, a file, a plurality of applications, a plurality of files, an executable program file, a desktop environment, a computing environment, or other resource made available to a user of the computing device . In yet another embodiment, the resource may be delivered to the computing device  via a plurality of access methods including, but not limited to, conventional installation directly on the computing device , delivery to the computing device  via a method for application streaming, delivery to the computing device  of output data generated by an execution of the resource on a second computing device \u2032 and communicated to the computing device  via a presentation layer protocol, delivery to the computing device  of output data generated by an execution of the resource via a virtual machine executing on a second computing device \u2032, or execution from a removable storage device connected to the computing device , such as a USB device, or via a virtual machine executing on the computing device  and generating output data. In some embodiments, the computing device  transmits output data generated by the execution of the resource to another computing device \u2032.","In one embodiment, the guest operating system , in conjunction with the virtual machine on which it executes, forms a fully-virtualized virtual machine which is not aware that it is a virtual machine; such a machine may be referred to as a \u201cDomain U HVM (Hardware Virtual Machine) virtual machine\u201d. In another embodiment, a fully-virtualized machine includes software emulating a Basic Input\/Output System (BIOS) in order to execute an operating system within the fully-virtualized machine. In still another embodiment, a fully-virtualized machine may include a driver that provides functionality by communicating with the hypervisor . In such an embodiment, the driver may be aware that it executes within a virtualized environment. In another embodiment, the guest operating system , in conjunction with the virtual machine on which it executes, forms a paravirtualized virtual machine, which is aware that it is a virtual machine; such a machine may be referred to as a \u201cDomain U PV virtual machine\u201d. In another embodiment, a paravirtualized machine includes additional drivers that a fully-virtualized machine does not include. In still another embodiment, the paravirtualized machine includes the network back-end driver and the block back-end driver included in a control operating system , as described above.","Referring now to , a block diagram depicts one embodiment of a plurality of networked computing devices in a system in which at least one physical host executes a virtual machine. In brief overview, the system includes a management component  and a hypervisor . The system includes a plurality of computing devices , a plurality of virtual machines , a plurality of hypervisors , a plurality of management components referred to variously as tools stacks  or management components , and a physical resource , . The plurality of physical machines  may each be provided as computing devices , described above in connection with  and A.","In greater detail, a physical disk  is provided by a computing device  and stores at least a portion of a virtual disk . In some embodiments, a virtual disk  is associated with a plurality of physical disks . In one of these embodiments, one or more computing devices  may exchange data with one or more of the other computing devices  regarding processors and other physical resources available in a pool of resources, allowing a hypervisor to manage a pool of resources distributed across a plurality of physical computing devices. In some embodiments, a computing device  on which a virtual machine  executes is referred to as a physical host  or as a host machine .","The hypervisor executes on a processor on the computing device . The hypervisor allocates, to a virtual disk, an amount of access to the physical disk. In one embodiment, the hypervisor  allocates an amount of space on the physical disk. In another embodiment, the hypervisor  allocates a plurality of pages on the physical disk. In some embodiments, the hypervisor provisions the virtual disk  as part of a process of initializing and executing a virtual machine .","In one embodiment, the management component is referred to as a pool management component . In another embodiment, a management operating system , which may be referred to as a control operating system , includes the management component. In some embodiments, the management component is referred to as a tools stack. In one of these embodiments, the management component is the tools stack  described above in connection with . In other embodiments, the management component  provides a user interface for receiving, from a user such as an administrator, an identification of a virtual machine  to provision and\/or execute. In still other embodiments, the management component  provides a user interface for receiving, from a user such as an administrator, the request for migration of a virtual machine from one physical machine  to another. In further embodiments, the management component identifies a computing device on which to execute a requested virtual machine and instructs the hypervisor on the identified computing device to execute the identified virtual machine; such a management component may be referred to as a pool management component.","Referring now to , embodiments of a virtual application delivery controller or virtual appliance  are depicted. In brief overview, any of the functionality and\/or embodiments of the appliance  (e.g., an application delivery controller) described above in connection with  may be deployed in any embodiment of the virtualized environment described above in connection with . Instead of the functionality of the application delivery controller being deployed in the form of an appliance , such functionality may be deployed in a virtualized environment  on any computing device , such as a client , server  or appliance .","Referring now to , a diagram of an embodiment of a virtual appliance  operating on a hypervisor  of a server  is depicted. As with the appliance  of , the virtual appliance  may provide functionality for availability, performance, offload and security. For availability, the virtual appliance may perform load balancing between layers  and  of the network and may also perform intelligent service health monitoring. For performance increases via network traffic acceleration, the virtual appliance may perform caching and compression. To offload processing of any servers, the virtual appliance may perform connection multiplexing and pooling and\/or SSL processing. For security, the virtual appliance may perform any of the application firewall functionality and SSL VPN function of appliance .","Any of the modules of the appliance  as described in connection with  may be packaged, combined, designed or constructed in a form of the virtualized appliance delivery controller  deployable as one or more software modules or components executable in a virtualized environment  or non-virtualized environment on any server, such as an off the shelf server. For example, the virtual appliance may be provided in the form of an installation package to install on a computing device. With reference to , any of the cache manager , policy engine , compression , encryption engine , packet engine , GUI , CLI , shell services  and health monitoring programs  may be designed and constructed as a software component or module to run on any operating system of a computing device and\/or of a virtualized environment . Instead of using the encryption processor , processor , memory  and network stack  of the appliance , the virtualized appliance  may use any of these resources as provided by the virtualized environment  or as otherwise available on the server .","Still referring to , and in brief overview, any one or more vServers A-N may be in operation or executed in a virtualized environment  of any type of computing device , such as any server . Any of the modules or functionality of the appliance  described in connection with  may be designed and constructed to operate in either a virtualized or non-virtualized environment of a server. Any of the vServer , SSL VPN , Intranet UP , Switching , DNS , acceleration , App FW  and monitoring agent may be packaged, combined, designed or constructed in a form of application delivery controller  deployable as one or more software modules or components executable on a device and\/or virtualized environment .","In some embodiments, a server may execute multiple virtual machines -in the virtualization environment with each virtual machine running the same or different embodiments of the virtual application delivery controller . In some embodiments, the server may execute one or more virtual appliances  on one or more virtual machines on a core of a multi-core processing system. In some embodiments, the server may execute one or more virtual appliances  on one or more virtual machines on each processor of a multiple processor device.","E. Systems and Methods for Providing A Multi-Core Architecture","In accordance with Moore's Law, the number of transistors that may be placed on an integrated circuit may double approximately every two years. However, CPU speed increases may reach plateaus, for example CPU speed has been around 3.5-4 GHz range since 2005. In some cases, CPU manufacturers may not rely on CPU speed increases to gain additional performance. Some CPU manufacturers may add additional cores to their processors to provide additional performance. Products, such as those of software and networking vendors, that rely on CPUs for performance gains may improve their performance by leveraging these multi-core CPUs. The software designed and constructed for a single CPU may be redesigned and\/or rewritten to take advantage of a multi-threaded, parallel architecture or otherwise a multi-core architecture.","A multi-core architecture of the appliance , referred to as nCore or multi-core technology, allows the appliance in some embodiments to break the single core performance barrier and to leverage the power of multi-core CPUs. In the previous architecture described in connection with , a single network or packet engine is run. The multiple cores of the nCore technology and architecture allow multiple packet engines to run concurrently and\/or in parallel. With a packet engine running on each core, the appliance architecture leverages the processing capacity of additional cores. In some embodiments, this provides up to a 7\u00d7 increase in performance and scalability.","Illustrated in  are some embodiments of work, task, load or network traffic distribution across one or more processor cores according to a type of parallelism or parallel computing scheme, such as functional parallelism, data parallelism or flow-based data parallelism. In brief overview,  illustrates embodiments of a multi-core system such as an appliance \u2032 with n-cores, a total of cores numbers  through N. In one embodiment, work, load or network traffic can be distributed among a first core A, a second core B, a third core C, a fourth core D, a fifth core E, a sixth core F, a seventh core G, and so on such that distribution is across all or two or more of the n cores N (hereinafter referred to collectively as cores .) There may be multiple VIPs  each running on a respective core of the plurality of cores. There may be multiple packet engines  each running on a respective core of the plurality of cores. Any of the approaches used may lead to different, varying or similar work load or performance level  across any of the cores. For a functional parallelism approach, each core may run a different function of the functionalities provided by the packet engine, a VIP  or appliance . In a data parallelism approach, data may be paralleled or distributed across the cores based on the Network Interface Card (NIC) or VIP  receiving the data. In another data parallelism approach, processing may be distributed across the cores by distributing data flows to each core.","In further detail to , in some embodiments, load, work or network traffic can be distributed among cores  according to functional parallelism . Functional parallelism may be based on each core performing one or more respective functions. In some embodiments, a first core may perform a first function while a second core performs a second function. In functional parallelism approach, the functions to be performed by the multi-core system are divided and distributed to each core according to functionality. In some embodiments, functional parallelism may be referred to as task parallelism and may be achieved when each processor or core executes a different process or function on the same or different data. The core or processor may execute the same or different code. In some cases, different execution threads or code may communicate with one another as they work. Communication may take place to pass data from one thread to the next as part of a workflow.","In some embodiments, distributing work across the cores  according to functional parallelism , can comprise distributing network traffic according to a particular function such as network input\/output management (NW I\/O) A, secure sockets layer (SSL) encryption and decryption B and transmission control protocol (TCP) functions C. This may lead to a work, performance or computing load  based on a volume or level of functionality being used. In some embodiments, distributing work across the cores  according to data parallelism , can comprise distributing an amount of work  based on distributing data associated with a particular hardware or software component. In some embodiments, distributing work across the cores  according to flow-based data parallelism , can comprise distributing data based on a context or flow such that the amount of work A-N on each core may be similar, substantially equal or relatively evenly distributed.","In the case of the functional parallelism approach, each core may be configured to run one or more functionalities of the plurality of functionalities provided by the packet engine or VIP of the appliance. For example, core  may perform network I\/O processing for the appliance \u2032 while core  performs TCP connection management for the appliance. Likewise, core  may perform SSL offloading while core  may perform layer  or application layer processing and traffic management. Each of the cores may perform the same function or different functions. Each of the cores may perform more than one function. Any of the cores may run any of the functionality or portions thereof identified and\/or described in conjunction with . In this the approach, the work across the cores may be divided by function in either a coarse-grained or fine-grained manner. In some cases, as illustrated in , division by function may lead to different cores running at different levels of performance or load .","In the case of the functional parallelism approach, each core may be configured to run one or more functionalities of the plurality of functionalities provided by the packet engine of the appliance. For example, core  may perform network I\/O processing for the appliance \u2032 while core  performs TCP connection management for the appliance. Likewise, core  may perform SSL offloading while core  may perform layer  or application layer processing and traffic management. Each of the cores may perform the same function or different functions. Each of the cores may perform more than one function. Any of the cores may run any of the functionality or portions thereof identified and\/or described in conjunction with . In this the approach, the work across the cores may be divided by function in either a coarse-grained or fine-grained manner. In some cases, as illustrated in  division by function may lead to different cores running at different levels of load or performance.","The functionality or tasks may be distributed in any arrangement and scheme. For example,  illustrates a first core, Core  A, processing applications and processes associated with network I\/O functionality A. Network traffic associated with network I\/O, in some embodiments, can be associated with a particular port number. Thus, outgoing and incoming packets having a port destination associated with NW I\/O A will be directed towards Core  A which is dedicated to handling all network traffic associated with the NW I\/O port. Similarly, Core  B is dedicated to handling functionality associated with SSL processing and Core  D may be dedicated handling all TCP level processing and functionality.","While  illustrates functions such as network I\/O, SSL and TCP, other functions can be assigned to cores. These other functions can include any one or more of the functions or operations described herein. For example, any of the functions described in conjunction with  may be distributed across the cores on a functionality basis. In some cases, a first VIP A may run on a first core while a second VIP B with a different configuration may run on a second core. In some embodiments, each core  can handle a particular functionality such that each core  can handle the processing associated with that particular function. For example, Core  B may handle SSL offloading while Core  D may handle application layer processing and traffic management.","In other embodiments, work, load or network traffic may be distributed among cores  according to any type and form of data parallelism . In some embodiments, data parallelism may be achieved in a multi-core system by each core performing the same task or functionally on different pieces of distributed data. In some embodiments, a single execution thread or code controls operations on all pieces of data. In other embodiments, different threads or instructions control the operation, but may execute the same code. In some embodiments, data parallelism is achieved from the perspective of a packet engine, vServers (VIPs) A-C, network interface cards (NIC) D-E and\/or any other networking hardware or software included on or associated with an appliance . For example, each core may run the same packet engine or VIP code or configuration but operate on different sets of distributed data. Each networking hardware or software construct can receive different, varying or substantially the same amount of data, and as a result may have varying, different or relatively the same amount of load .","In the case of a data parallelism approach, the work may be divided up and distributed based on VIPs, NICs and\/or data flows of the VIPs or NICs. In one of these approaches, the work of the multi-core system may be divided or distributed among the VIPs by having each VIP work on a distributed set of data. For example, each core may be configured to run one or more VIPs. Network traffic may be distributed to the core for each VIP handling that traffic. In another of these approaches, the work of the appliance may be divided or distributed among the cores based on which NIC receives the network traffic. For example, network traffic of a first NIC may be distributed to a first core while network traffic of a second NIC may be distributed to a second core. In some cases, a core may process data from multiple NICs.","While  illustrates a single vServer associated with a single core , as is the case for VIP A, VIP B and VIP C. In some embodiments, a single vServer can be associated with one or more cores . In contrast, one or more vServers can be associated with a single core . Associating a vServer with a core  may include that core  to process all functions associated with that particular vServer. In some embodiments, each core executes a VIP having the same code and configuration. In other embodiments, each core executes a VIP having the same code but different configuration. In some embodiments, each core executes a VIP having different code and the same or different configuration.","Like vServers, NICs can also be associated with particular cores . In many embodiments, NICs can be connected to one or more cores  such that when a NIC receives or transmits data packets, a particular core  handles the processing involved with receiving and transmitting the data packets. In one embodiment, a single NIC can be associated with a single core , as is the case with NIC D and NIC E. In other embodiments, one or more NICs can be associated with a single core . In other embodiments, a single NIC can be associated with one or more cores . In these embodiments, load could be distributed amongst the one or more cores  such that each core  processes a substantially similar amount of load. A core  associated with a NIC may process all functions and\/or data associated with that particular NIC.","While distributing work across cores based on data of VIPs or NICs may have a level of independency, in some embodiments, this may lead to unbalanced use of cores as illustrated by the varying loads  of .","In some embodiments, load, work or network traffic can be distributed among cores  based on any type and form of data flow. In another of these approaches, the work may be divided or distributed among cores based on data flows. For example, network traffic between a client and a server traversing the appliance may be distributed to and processed by one core of the plurality of cores. In some cases, the core initially establishing the session or connection may be the core for which network traffic for that session or connection is distributed. In some embodiments, the data flow is based on any unit or portion of network traffic, such as a transaction, a request\/response communication or traffic originating from an application on a client. In this manner and in some embodiments, data flows between clients and servers traversing the appliance \u2032 may be distributed in a more balanced manner than the other approaches.","In flow-based data parallelism , distribution of data is related to any type of flow of data, such as request\/response pairings, transactions, sessions, connections or application communications. For example, network traffic between a client and a server traversing the appliance may be distributed to and processed by one core of the plurality of cores. In some cases, the core initially establishing the session or connection may be the core for which network traffic for that session or connection is distributed. The distribution of data flow may be such that each core  carries a substantially equal or relatively evenly distributed amount of load, data or network traffic.","In some embodiments, the data flow is based on any unit or portion of network traffic, such as a transaction, a request\/response communication or traffic originating from an application on a client. In this manner and in some embodiments, data flows between clients and servers traversing the appliance \u2032 may be distributed in a more balanced manner than the other approached. In one embodiment, data flow can be distributed based on a transaction or a series of transactions. This transaction, in some embodiments, can be between a client and a server and can be characterized by an IP address or other packet identifier. For example, Core  A can be dedicated to transactions between a particular client and a particular server, therefore the load A on Core  A may be comprised of the network traffic associated with the transactions between the particular client and server. Allocating the network traffic to Core  A can be accomplished by routing all data packets originating from either the particular client or server to Core  A.","While work or load can be distributed to the cores based in part on transactions, in other embodiments load or work can be allocated on a per packet basis. In these embodiments, the appliance  can intercept data packets and allocate them to a core  having the least amount of load. For example, the appliance  could allocate a first incoming data packet to Core  A because the load A on Core  is less than the load B-N on the rest of the cores B-N. Once the first data packet is allocated to Core  A, the amount of load A on Core  A is increased proportional to the amount of processing resources needed to process the first data packet. When the appliance  intercepts a second data packet, the appliance  will allocate the load to Core  D because Core  D has the second least amount of load. Allocating data packets to the core with the least amount of load can, in some embodiments, ensure that the load A-N distributed to each core  remains substantially equal.","In other embodiments, load can be allocated on a per unit basis where a section of network traffic is allocated to a particular core . The above-mentioned example illustrates load balancing on a per\/packet basis. In other embodiments, load can be allocated based on a number of packets such that every 10, 100 or 1000 packets are allocated to the core  having the least amount of load. The number of packets allocated to a core  can be a number determined by an application, user or administrator and can be any number greater than zero. In still other embodiments, load can be allocated based on a time metric such that packets are distributed to a particular core  for a predetermined amount of time. In these embodiments, packets can be distributed to a particular core  for five milliseconds or for any period of time determined by a user, program, system, administrator or otherwise. After the predetermined time period elapses, data packets are transmitted to a different core  for the predetermined period of time.","Flow-based data parallelism methods for distributing work, load or network traffic among the one or more cores  can comprise any combination of the above-mentioned embodiments. These methods can be carried out by any part of the appliance , by an application or set of executable instructions executing on one of the cores , such as the packet engine, or by any application, program or agent executing on a computing device in communication with the appliance .","The functional and data parallelism computing schemes illustrated in  can be combined in any manner to generate a hybrid parallelism or distributed processing scheme that encompasses function parallelism , data parallelism , flow-based data parallelism  or any portions thereof. In some cases, the multi-core system may use any type and form of load balancing schemes to distribute load among the one or more cores . The load balancing scheme may be used in any combination with any of the functional and data parallelism schemes or combinations thereof.","Illustrated in  is an embodiment of a multi-core system , which may be any type and form of one or more systems, appliances, devices or components. This system , in some embodiments, can be included within an appliance  having one or more processing cores A-N. The system  can further include one or more packet engines (PE) or packet processing engines (PPE) A-N communicating with a memory bus . The memory bus may be used to communicate with the one or more processing cores A-N. Also included within the system  can be one or more network interface cards (NIC)  and a flow distributor  which can further communicate with the one or more processing cores A-N. The flow distributor  can comprise a Receive Side Scaler (RSS) or Receive Side Scaling (RSS) module .","Further referring to , and in more detail, in one embodiment the packet engine(s) A-N can comprise any portion of the appliance  described herein, such as any portion of the appliance described in . The packet engine(s) A-N can, in some embodiments, comprise any of the following elements: the packet engine , a network stack ; a cache manager ; a policy engine ; a compression engine ; an encryption engine ; a GUI ; a CLI ; shell services ; monitoring programs ; and any other software or hardware element able to receive data packets from one of either the memory bus  or the one of more cores A-N. In some embodiments, the packet engine(s) A-N can comprise one or more vServers A-N, or any portion thereof. In other embodiments, the packet engine(s) A-N can provide any combination of the following functionalities: SSL VPN ; Intranet UP ; switching ; DNS ; packet acceleration ; App FW ; monitoring such as the monitoring provided by a monitoring agent ; functionalities associated with functioning as a TCP stack; load balancing; SSL offloading and processing; content switching; policy evaluation; caching; compression; encoding; decompression; decoding; application firewall functionalities; XML processing and acceleration; and SSL VPN connectivity.","The packet engine(s) A-N can, in some embodiments, be associated with a particular server, user, client or network. When a packet engine  becomes associated with a particular entity, that packet engine  can process data packets associated with that entity. For example, should a packet engine  be associated with a first user, that packet engine  will process and operate on packets generated by the first user, or packets having a destination address associated with the first user. Similarly, the packet engine  may choose not to be associated with a particular entity such that the packet engine  can process and otherwise operate on any data packets not generated by that entity or destined for that entity.","In some instances, the packet engine(s) A-N can be configured to carry out any of the functional and\/or data parallelism schemes illustrated in . In these instances, the packet engine(s) A-N can distribute functions or data among the processing cores A-N so that the distribution is according to the parallelism or distribution scheme. In some embodiments, a single packet engine(s) A-N carries out a load balancing scheme, while in other embodiments one or more packet engine(s) A-N carry out a load balancing scheme. Each core A-N, in one embodiment, can be associated with a particular packet engine  such that load balancing can be carried out by the packet engine. Load balancing may in this embodiment, require that each packet engine A-N associated with a core  communicate with the other packet engines associated with cores so that the packet engines A-N can collectively determine where to distribute load. One embodiment of this process can include an arbiter that receives votes from each packet engine for load. The arbiter can distribute load to each packet engine A-N based in part on the age of the engine's vote and in some cases a priority value associated with the current amount of load on an engine's associated core .","Any of the packet engines running on the cores may run in user mode, kernel or any combination thereof. In some embodiments, the packet engine operates as an application or program running is user or application space. In these embodiments, the packet engine may use any type and form of interface to access any functionality provided by the kernel. In some embodiments, the packet engine operates in kernel mode or as part of the kernel. In some embodiments, a first portion of the packet engine operates in user mode while a second portion of the packet engine operates in kernel mode. In some embodiments, a first packet engine on a first core executes in kernel mode while a second packet engine on a second core executes in user mode. In some embodiments, the packet engine or any portions thereof operates on or in conjunction with the NIC or any drivers thereof.","In some embodiments the memory bus  can be any type and form of memory or computer bus. While a single memory bus  is depicted in , the system  can comprise any number of memory buses . In one embodiment, each packet engine  can be associated with one or more individual memory buses .","The NIC  can in some embodiments be any of the network interface cards or mechanisms described herein. The NIC  can have any number of ports. The NIC can be designed and constructed to connect to any type and form of network . While a single NIC  is illustrated, the system  can comprise any number of NICs . In some embodiments, each core A-N can be associated with one or more single NICs . Thus, each core  can be associated with a single NIC  dedicated to a particular core . The cores A-N can comprise any of the processors described herein. Further, the cores A-N can be configured according to any of the core  configurations described herein. Still further, the cores A-N can have any of the core  functionalities described herein. While  illustrates seven cores A-G, any number of cores  can be included within the system . In particular, the system  can comprise \u201cN\u201d cores, where \u201cN\u201d is a whole number greater than zero.","A core may have or use memory that is allocated or assigned for use to that core. The memory may be considered private or local memory of that core and only accessible by that core. A core may have or use memory that is shared or assigned to multiple cores. The memory may be considered public or shared memory that is accessible by more than one core. A core may use any combination of private and public memory. With separate address spaces for each core, some level of coordination is eliminated from the case of using the same address space. With a separate address space, a core can perform work on information and data in the core's own address space without worrying about conflicts with other cores. Each packet engine may have a separate memory pool for TCP and\/or SSL connections.","Further referring to , any of the functionality and\/or embodiments of the cores  described above in connection with  can be deployed in any embodiment of the virtualized environment described above in connection with . Instead of the functionality of the cores  being deployed in the form of a physical processor , such functionality may be deployed in a virtualized environment  on any computing device , such as a client , server  or appliance . In other embodiments, instead of the functionality of the cores  being deployed in the form of an appliance or a single device, the functionality may be deployed across multiple devices in any arrangement. For example, one device may comprise two or more cores and another device may comprise two or more cores. For example, a multi-core system may include a cluster of computing devices, a server farm or network of computing devices. In some embodiments, instead of the functionality of the cores  being deployed in the form of cores, the functionality may be deployed on a plurality of processors, such as a plurality of single core processors.","In one embodiment, the cores  may be any type and form of processor. In some embodiments, a core can function substantially similar to any processor or central processing unit described herein. In some embodiment, the cores  may comprise any portion of any processor described herein. While  illustrates seven cores, there can exist any \u201cN\u201d number of cores within an appliance , where \u201cN\u201d is any whole number greater than one. In some embodiments, the cores  can be installed within a common appliance , while in other embodiments the cores  can be installed within one or more appliance(s)  communicatively connected to one another. The cores  can in some embodiments comprise graphics processing software, while in other embodiments the cores  provide general processing capabilities. The cores  can be installed physically near each other and\/or can be communicatively connected to each other. The cores may be connected by any type and form of bus or subsystem physically and\/or communicatively coupled to the cores for transferring data between to, from and\/or between the cores.","While each core  can comprise software for communicating with other cores, in some embodiments a core manager (not shown) can facilitate communication between each core . In some embodiments, the kernel may provide core management. The cores may interface or communicate with each other using a variety of interface mechanisms. In some embodiments, core to core messaging may be used to communicate between cores, such as a first core sending a message or data to a second core via a bus or subsystem connecting the cores. In some embodiments, cores may communicate via any type and form of shared memory interface. In one embodiment, there may be one or more memory locations shared among all the cores. In some embodiments, each core may have separate memory locations shared with each other core. For example, a first core may have a first shared memory with a second core and a second share memory with a third core. In some embodiments, cores may communicate via any type of programming or API, such as function calls via the kernel. In some embodiments, the operating system may recognize and support multiple core devices and provide interfaces and API for inter-core communications.","The flow distributor  can be any application, program, library, script, task, service, process or any type and form of executable instructions executing on any type and form of hardware. In some embodiments, the flow distributor  may any design and construction of circuitry to perform any of the operations and functions described herein. In some embodiments, the flow distributor distribute, forwards, routes, controls and\/ors manage the distribution of data packets among the cores  and\/or packet engine or VIPs running on the cores. The flow distributor , in some embodiments, can be referred to as an interface master. In one embodiment, the flow distributor  comprises a set of executable instructions executing on a core or processor of the appliance . In another embodiment, the flow distributor  comprises a set of executable instructions executing on a computing machine in communication with the appliance . In some embodiments, the flow distributor  comprises a set of executable instructions executing on a NIC, such as firmware. In still other embodiments, the flow distributor  comprises any combination of software and hardware to distribute data packets among cores or processors. In one embodiment, the flow distributor  executes on at least one of the cores A-N, while in other embodiments a separate flow distributor  assigned to each core A-N executes on an associated core A-N. The flow distributor may use any type and form of statistical or probabilistic algorithms or decision making to balance the flows across the cores. The hardware of the appliance, such as a NIC, or the kernel may be designed and constructed to support sequential operations across the NICs and\/or cores.","In embodiments where the system  comprises one or more flow distributors , each flow distributor  can be associated with a processor  or a packet engine . The flow distributors  can comprise an interface mechanism that allows each flow distributor  to communicate with the other flow distributors  executing within the system . In one instance, the one or more flow distributors  can determine how to balance load by communicating with each other. This process can operate substantially similarly to the process described above for submitting votes to an arbiter which then determines which flow distributor  should receive the load. In other embodiments, a first flow distributor \u2032 can identify the load on an associated core and determine whether to forward a first data packet to the associated core based on any of the following criteria: the load on the associated core is above a predetermined threshold; the load on the associated core is below a predetermined threshold; the load on the associated core is less than the load on the other cores; or any other metric that can be used to determine where to forward data packets based in part on the amount of load on a processor.","The flow distributor  can distribute network traffic among the cores  according to a distribution, computing or load balancing scheme such as those described herein. In one embodiment, the flow distributor can distribute network traffic according to any one of a functional parallelism distribution scheme , a data parallelism load distribution scheme , a flow-based data parallelism distribution scheme , or any combination of these distribution scheme or any load balancing scheme for distributing load among multiple processors. The flow distributor  can therefore act as a load distributor by taking in data packets and distributing them across the processors according to an operative load balancing or distribution scheme. In one embodiment, the flow distributor  can comprise one or more operations, functions or logic to determine how to distribute packers, work or load accordingly. In still other embodiments, the flow distributor  can comprise one or more sub operations, functions or logic that can identify a source address and a destination address associated with a data packet, and distribute packets accordingly.","In some embodiments, the flow distributor  can comprise a receive-side scaling (RSS) network driver, module  or any type and form of executable instructions which distribute data packets among the one or more cores . The RSS module  can comprise any combination of hardware and software, In some embodiments, the RSS module  works in conjunction with the flow distributor  to distribute data packets across the cores A-N or among multiple processors in a multi-processor network. The RSS module  can execute within the NIC  in some embodiments, and in other embodiments can execute on any one of the cores .","In some embodiments, the RSS module  uses the MICROSOFT receive-side-scaling (RSS) scheme. In one embodiment, RSS is a Microsoft Scalable Networking initiative technology that enables receive processing to be balanced across multiple processors in the system while maintaining in-order delivery of the data. The RSS may use any type and form of hashing scheme to determine a core or processor for processing a network packet.","The RSS module  can apply any type and form hash function such as the Toeplitz hash function. The hash function may be applied to the hash type or any the sequence of values. The hash function may be a secure hash of any security level or is otherwise cryptographically secure. The hash function may use a hash key. The size of the key is dependent upon the hash function. For the Toeplitz hash, the size may be 40 bytes for IPv6 and 16 bytes for IPv4.","The hash function may be designed and constructed based on any one or more criteria or design goals. In some embodiments, a hash function may be used that provides an even distribution of hash result for different hash inputs and different hash types, including TCP\/IPv4, TCP\/IPv6, IPv4, and IPv6 headers. In some embodiments, a hash function may be used that provides a hash result that is evenly distributed when a small number of buckets are present (for example, two or four). In some embodiments, hash function may be used that provides a hash result that is randomly distributed when a large number of buckets were present (for example, 64 buckets). In some embodiments, the hash function is determined based on a level of computational or resource usage. In some embodiments, the hash function is determined based on ease or difficulty of implementing the hash in hardware. In some embodiments, the hash function is determined based on the ease or difficulty of a malicious remote host to send packets that would all hash to the same bucket.","The RSS may generate hashes from any type and form of input, such as a sequence of values. This sequence of values can include any portion of the network packet, such as any header, field or payload of network packet, or portions thereof. In some embodiments, the input to the hash may be referred to as a hash type and include any tuples of information associated with a network packet or data flow, such as any of the following: a four tuple comprising at least two IP addresses and two ports; a four tuple comprising any four sets of values; a six tuple; a two tuple; and\/or any other sequence of numbers or values. The following are example of hash types that may be used by RSS:\n\n","The hash result or any portion thereof may used to identify a core or entity, such as a packet engine or VIP, for distributing a network packet. In some embodiments, one or more hash bits or mask are applied to the hash result. The hash bit or mask may be any number of bits or bytes. A NIC may support any number of bits, such as seven bits. The network stack may set the actual number of bits to be used during initialization. The number will be between 1 and 7, inclusive.","The hash result may be used to identify the core or entity via any type and form of table, such as a bucket table or indirection table. In some embodiments, the number of hash-result bits are used to index into the table. The range of the hash mask may effectively define the size of the indirection table. Any portion of the hash result or the hast result itself may be used to index the indirection table. The values in the table may identify any of the cores or processor, such as by a core or processor identifier. In some embodiments, all of the cores of the multi-core system are identified in the table. In other embodiments, a port of the cores of the multi-core system are identified in the table. The indirection table may comprise any number of buckets for example 2 to 128 buckets that may be indexed by a hash mask. Each bucket may comprise a range of index values that identify a core or processor. In some embodiments, the flow controller and\/or RSS module may rebalance the network rebalance the network load by changing the indirection table.","In some embodiments, the multi-core system  does not include a RSS driver or RSS module . In some of these embodiments, a software steering module (not shown) or a software embodiment of the RSS module within the system can operate in conjunction with or as part of the flow distributor  to steer packets to cores  within the multi-core system .","The flow distributor , in some embodiments, executes within any module or program on the appliance , on any one of the cores  and on any one of the devices or components included within the multi-core system . In some embodiments, the flow distributor \u2032 can execute on the first core A, while in other embodiments the flow distributor \u2033 can execute on the NIC . In still other embodiments, an instance of the flow distributor \u2032 can execute on each core  included in the multi-core system . In this embodiment, each instance of the flow distributor \u2032 can communicate with other instances of the flow distributor \u2032 to forward packets back and forth across the cores . There exist situations where a response to a request packet may not be processed by the same core, i.e. the first core processes the request while the second core processes the response. In these situations, the instances of the flow distributor \u2032 can intercept the packet and forward it to the desired or correct core , i.e. a flow distributor instance \u2032 can forward the response to the first core. Multiple instances of the flow distributor \u2032 can execute on any number of cores  and any combination of cores .","The flow distributor may operate responsive to any one or more rules or policies. The rules may identify a core or packet processing engine to receive a network packet, data or data flow. The rules may identify any type and form of tuple information related to a network packet, such as a 4-tuple of source and destination IP address and source and destination ports. Based on a received packet matching the tuple specified by the rule, the flow distributor may forward the packet to a core or packet engine. In some embodiments, the packet is forwarded to a core via shared memory and\/or core to core messaging.","Although  illustrates the flow distributor  as executing within the multi-core system , in some embodiments the flow distributor  can execute on a computing device or appliance remotely located from the multi-core system . In such an embodiment, the flow distributor  can communicate with the multi-core system  to take in data packets and distribute the packets across the one or more cores . The flow distributor  can, in one embodiment, receive data packets destined for the appliance , apply a distribution scheme to the received data packets and distribute the data packets to the one or more cores  of the multi-core system . In one embodiment, the flow distributor  can be included in a router or other appliance such that the router can target particular cores  by altering meta data associated with each packet so that each packet is targeted towards a sub-node of the multi-core system . In such an embodiment, CISCO's vn-tag mechanism can be used to alter or tag each packet with the appropriate meta data.","Illustrated in  is an embodiment of a multi-core system  comprising one or more processing cores A-N. In brief overview, one of the cores  can be designated as a control core A and can be used as a control plane  for the other cores . The other cores may be secondary cores which operate in a data plane while the control core provides the control plane. The cores A-N may share a global cache . While the control core provides a control plane, the other cores in the multi-core system form or provide a data plane. These cores perform data processing functionality on network traffic while the control provides initialization, configuration and control of the multi-core system.","Further referring to , and in more detail, the cores A-N as well as the control core A can be any processor described herein. Furthermore, the cores A-N and the control core A can be any processor able to function within the system  described in . Still further, the cores A-N and the control core A can be any core or group of cores described herein. The control core may be a different type of core or processor than the other cores. In some embodiments, the control may operate a different packet engine or have a packet engine configured differently than the packet engines of the other cores.","Any portion of the memory of each of the cores may be allocated to or used for a global cache that is shared by the cores. In brief overview, a predetermined percentage or predetermined amount of each of the memory of each core may be used for the global cache. For example, 50% of each memory of each code may be dedicated or allocated to the shared global cache. That is, in the illustrated embodiment, 2 GB of each core excluding the control plane core or core  may be used to form a 28 GB shared global cache. The configuration of the control plane such as via the configuration services may determine the amount of memory used for the shared global cache. In some embodiments, each core may provide a different amount of memory for use by the global cache. In other embodiments, any one core may not provide any memory or use the global cache. In some embodiments, any of the cores may also have a local cache in memory not allocated to the global shared memory. Each of the cores may store any portion of network traffic to the global shared cache. Each of the cores may check the cache for any content to use in a request or response. Any of the cores may obtain content from the global shared cache to use in a data flow, request or response.","The global cache  can be any type and form of memory or storage element, such as any memory or storage element described herein. In some embodiments, the cores  may have access to a predetermined amount of memory (i.e. 32 GB or any other memory amount commensurate with the system ). The global cache  can be allocated from that predetermined amount of memory while the rest of the available memory can be allocated among the cores . In other embodiments, each core  can have a predetermined amount of memory. The global cache  can comprise an amount of the memory allocated to each core . This memory amount can be measured in bytes, or can be measured as a percentage of the memory allocated to each core . Thus, the global cache  can comprise 1 GB of memory from the memory associated with each core , or can comprise 20 percent or one-half of the memory associated with each core . In some embodiments, only a portion of the cores  provide memory to the global cache , while in other embodiments the global cache  can comprise memory not allocated to the cores .","Each core  can use the global cache  to store network traffic or cache data. In some embodiments, the packet engines of the core use the global cache to cache and use data stored by the plurality of packet engines. For example, the cache manager of  and cache functionality of  may use the global cache to share data for acceleration. For example, each of the packet engines may store responses, such as HTML data, to the global cache. Any of the cache managers operating on a core may access the global cache to server caches responses to client requests.","In some embodiments, the cores  can use the global cache  to store a port allocation table which can be used to determine data flow based in part on ports. In other embodiments, the cores  can use the global cache  to store an address lookup table or any other table or list that can be used by the flow distributor to determine where to direct incoming and outgoing data packets. The cores  can, in some embodiments read from and write to cache , while in other embodiments the cores  can only read from or write to cache . The cores may use the global cache to perform core to core communications.","The global cache  may be sectioned into individual memory sections where each section can be dedicated to a particular core . In one embodiment, the control core A can receive a greater amount of available cache, while the other cores  can receiving varying amounts or access to the global cache .","In some embodiments, the system  can comprise a control core A. While  illustrates core  A as the control core, the control core can be any core within the appliance  or multi-core system. Further, while only a single control core is depicted, the system  can comprise one or more control cores each having a level of control over the system. In some embodiments, one or more control cores can each control a particular aspect of the system . For example, one core can control deciding which distribution scheme to use, while another core can determine the size of the global cache .","The control plane of the multi-core system may be the designation and configuration of a core as the dedicated management core or as a master core. This control plane core may provide control, management and coordination of operation and functionality the plurality of cores in the multi-core system. This control plane core may provide control, management and coordination of allocation and use of memory of the system among the plurality of cores in the multi-core system, including initialization and configuration of the same. In some embodiments, the control plane includes the flow distributor for controlling the assignment of data flows to cores and the distribution of network packets to cores based on data flows. In some embodiments, the control plane core runs a packet engine and in other embodiments, the control plane core is dedicated to management and control of the other cores of the system.","The control core A can exercise a level of control over the other cores  such as determining how much memory should be allocated to each core  or determining which core  should be assigned to handle a particular function or hardware\/software entity. The control core A, in some embodiments, can exercise control over those cores  within the control plan . Thus, there can exist processors outside of the control plane  which are not controlled by the control core A. Determining the boundaries of the control plane  can include maintaining, by the control core A or agent executing within the system , a list of those cores  controlled by the control core A. The control core A can control any of the following: initialization of a core; determining when a core is unavailable; re-distributing load to other cores  when one core fails; determining which distribution scheme to implement; determining which core should receive network traffic; determining how much cache should be allocated to each core; determining whether to assign a particular function or element to a particular core; determining whether to permit cores to communicate with one another; determining the size of the global cache ; and any other determination of a function, configuration or operation of the cores within the system .","F. Systems and Methods for Aggregating Multi-Core Performance and Trace Data","The systems and methods described in this section are directed towards aggregating performance and trace data of a multi-core, multi-packet-engine appliance which manages network traffic. In various embodiments, the appliance is disposed in a network intermediary to a plurality of clients and a plurality of servers which can provide network services or web content to the clients. The multi-core appliance can manage connections between plural clients and plural servers as well as manage web content exchanged between clients and servers.","In overview and referring now to , an embodiment of a system  for aggregating performance or trace data is depicted in block diagram form. The system  can be configured for operation on an appliance . The appliance , as described elsewhere herein, can be adapted to operate with the system  and provide information about network performance and trace data of the appliance. In various embodiments, the performance and trace aggregating system  comprises packet engines A-N, shared memory allocations B-N, an aggregator , and an agent interface . Each packet engine can manage network traffic between one or more clients  and one or more servers . The aggregator  can communicate with the packet engines A-N via shared memory allocations B-N, as well as collect data through the shared memory allocations. The aggregator  can further communicate with agents A, B, which can request and receive information about the appliance's performance and trace data through the agent interface . The agent interface  can function as an intermediary between the agents  and the aggregator .","In various embodiments and in further detail, the packet engines A-N execute on a plurality of cores A-N of the appliance . Each packet engine can execute on a respective core and manage network traffic, e.g., exchange of web content, between one or more clients  and one or more servers  in communication with the appliance . Aspects of the packet engines A-N and cores A-N are described elsewhere herein. Web content can include, without being limited to, HTTP or HTTPS requests, HTTP or HTTPS responses, electronic mail, web pages, video data, music or audio data, web forms, statistical data, plots, maps, books, advertisements, news or journal text, pictures, compiled data descriptive of an item, event, weather, individual, group, organization, business, or geographical area. Each packet engine A-N can manage services provided by servers . Web services can include, without being limited to, providing HTTP or HTTPs responses in reply to a request, searching for specified information, carrying out calculations, compiling data, compiling statistics, providing for purchasing or sale of an item, executing a computer game, providing for electronic communication with another networked entity, etc. In various embodiments, each packet engine A-N communicates with an allocation B-N in memory .","In certain embodiments, each packet engine A-N is adapted to maintain one or more records PA-N, TA-N (generally ) of certain aspects of its operation, e.g., certain statistics or data about its operation as a virtual server (VIP A-N), data about servers to which each packet engine is currently maintaining active connections or has had connections to, data about a service managed by each packet engine, etc. In some embodiments, each packet engine maintains separate records for performance data P and trace data T. In some embodiments, each packet engine maintains separate records for types of performance data, e.g., a record for VIP data, a record for subscribed service data. In some embodiments, each packet engine maintains combined data records, e.g., one record for performance and trace data. In various embodiments, the records  provide information about performance statistics of each packet engine, and\/or contain trace data captured by each packet engine. Each record A-N can comprise a data structure containing multiple records and types of data. Each record can be maintained with each core in memory , cache , in a data buffer, or any type of data storage element accessible to each packet engine or its core.","Performance data P of the VIP  aspects of operation and\/or performance data for each packet engine can include, without being limited to, any of the following elements: the IP address and port configuration of the VIP, the state of the VIP, e.g., up, down, out of service, an indication of load balancing configuration of the VIP, number of hits on the VIP requesting web content, a measure of traffic passed through the VIP, e.g., kbps, Mbps, Gbps, the persistence configuration for the VIP, a measure of the number of times an error page was generated by the VIP, a measure of the volume of traffic passing through the VIP, e.g., number of packets passing through the VIP, average size of a packet, number of active services that are bound to the VIP, the number of client connections to the VIP, the rate at which client connections are added or deleted from the VIP, the number of server connections from the VIP in an \u201copen\u201d state, the number of current server connections from the VIP, and any combination thereof.","In some embodiments, the records  are maintained by each packet engine during operation, e.g., each packet engine can record the information periodically at selected time intervals. In some instances, each packet engine periodically overwrites data when recording the information, e.g., the data is written to the same space in a record at periodic intervals, new data overwriting old data. In some instances, the data is written to memory in a manner to provide historical data, e.g., the data is recorded to a circular buffer having M sections. After M time intervals, older data is overwritten, however the buffer retains a historical record of M time intervals at any instant. In various embodiments, each packet engine can record the information stored in its respective record  or a portion thereof to a shared memory allocation B-N or to non-shared memory. In some embodiments, the record is generated by the packet engine after it receives a request for information. A record generated after request can include information about all VIP operational aspects reportable by the packet engine, or can include information about operational aspects specified in the request.","Information about servers or service of a server for which the packet engine is managing service can include without being limited to, any of the following elements, which may be included in the performance data P: the IP address and port configuration of the server, the state of the service provided by the server, e.g., up, down, out of service, the number of hits directed to the service, the number of hits directed to the service due to configured server persistence, the number of active connections to the service, a measure of traffic to the service, e.g., kbps, Mbps, Gbps, a bandwidth limit for the service, an average response time of the service, a measure of traffic volume to the service, e.g., number of packets, average size of packets, a weight index used in load balancing for the service, a running hits count which can be used in a round-robin load balancing algorithm, a number of connections to the service, a rate at which connections to the service are added or deleted, a maximum number of connections to the service at one time that has been reached, a number of connections to the service in an \u201copen\u201d state, e.g., an open and active state, a number of connections to the service residing in a reuse pool, e.g., open but not active, a number of connections to the service waiting in a serge queue, and any combination thereof. In some embodiments, each record  of server or service information is maintained by each packet engine during operation, e.g., each packet engine can record the information periodically at selected time intervals. In some instances, each packet engine periodically overwrites data when recording the information, e.g., the data is written to the same space in the record at periodic intervals, new data overwriting old data. In some instances, the data is written to memory in a manner to provide historical data, e.g., the data is recorded to a circular buffer having M sections. After M time intervals, older data is overwritten, however the buffer retains a historical record of M time intervals at any instant. In various embodiments, each packet engine can record the information from the records  to a shared memory allocation B-N or to non-shared memory. In some embodiments, each record  is generated by the packet engine after it receives a request for information. A record generated after a request can include all service information reportable by the packet engine, or can include service information specified in the request.","In various embodiments, each packet engine A-N is adapted to capture trace data. Trace data can identify network traffic or any portion thereof flowing through the packet engine during a selected time interval. Trace data can include any information related to the receipt, transmittal and processing of network packets and any hardware and\/or software related thereto, such as the packet engine, network stack and NIC. Trace data can include, without being limited to, any of the elements from the following list: requests for content, responses to requests for content, encrypted content, non-encrypted content, and any combination thereof. Trace data can include identification of headers, fields and\/or payload of a packet. Trace data can include identification of a protocol of packet. Trace data can include identification of a layer of the network stack of a packet. Trace data can include identification of a NIC. Trace data include any temporal information related to receipt, transmittal or processing of a network packet, such any granularity of timestamp. Trace data include any information identifying operations, functions or actions of the packet engine in processing a network packet. Trace data may be represented in any format, arrangement, structure or representation.","In certain embodiments, each packet engine is further adapted to filter web content passed by the packet engine in assembling trace data. As an example, each packet engine can select for trace data web content in accordance with a filtering criterion selected from the following list: source IP address, source port number, destination IP address, destination port number, service name, virtual server name, state of service, and any combination thereof. Combinations of these elements can include boolean combinations and compound expressions, e.g., sourceip=105.2.1.2 AND servicename=map\/boston. In various embodiments, trace data is generated after the packet engine receives a request for trace data, the request specifying information desired in the trace and a time interval during which the trace is to be taken. If no information is specified, all available trace data can be reported for a current selected time interval. Trace data can be stored in separate trace records TA-N for each packet engine.","Memory allocations B-N can be defined in memory . Details of memory  are described elsewhere herein. Memory allocations B-N can comprise locations and space in memory reserved for use by each packet engine and for use by the aggregator . The memory allocations B-N can be defined by each packet engine A-N, e.g., by using an IOCTL, a system call, a subroutine, a function call, an API routine, a remote procedure call, etc., upon initialization of each packet engine, or can be defined by the aggregator  upon initialization of the aggregator. The memory allocations can reside in kernel space or in user space. In some embodiments, memory allocations are defined in kernel space and mapped to user space, or vice versa. The memory allocations can be local to the appliance , e.g., in cache or main memory of the appliance. In some implementations, memory allocations are not local to the appliance, e.g., reserved on a storage device in communication with the appliance  over a network .","In various embodiments, the memory allocations are shared between the packet engines and the aggregator , e.g., both the aggregator and a packet engine  C can write and\/or read data to and from a shared allocation D. In some embodiments, each packet engine has its own memory allocation, e.g., engine A accesses only allocation B. As such, no two packet engines share a memory allocation, as depicted in . In some embodiments, two or more packet engines share a memory allocation. Sharing of memory allocations by packet engines can reduce the amount of memory reserved for performance and trace data.","In various embodiments, the performance and trace aggregating system  further comprises an aggregator . The aggregator can comprise firmware, software or any type and form of executable instructions executing on a core of the multi-core appliance . In some embodiments, the aggregator  comprises executable instructions in distributed operation on plural cores of the appliance . When configured in distributed operation, communication between the cores by core-to-core messaging, socket connections, or any other mode of data interface can be used to coordinate operation of the aggregator . In some embodiments, the aggregator  comprises executable instructions executing on a processor dedicated for the aggregator. The dedicated processor can be local to the appliance  or located apart from the appliance and in communication with the appliance over a network .","In some embodiments, the system  comprises two aggregators (not shown). One aggregator, e.g., a performance aggregator, can consolidate performance data obtained from a plurality of packet engines A-B to produce unified performance data A. One aggregator, e.g., a trace aggregator, can consolidate trace data obtained from a plurality of packet engines A-B to produce unified trace data B. In certain embodiments, the performance and trace aggregators operate independently. For example, the aggregators may not communicate with each other. In certain implementations, the performance and trace aggregators are in communication with each other. In some embodiments, the performance and trace aggregators are configured to operate on a same core of the multi-core appliance . In some embodiments, the performance aggregator operates on a first core, and the trace aggregator operates on a second core of the multi-core appliance .","For embodiments where the appliance  has a performance aggregator and a separate trace aggregator, two sets of memory allocations B-N can be established for each packet engine A-B. A first set of memory allocations can store performance data from each packet engine, and the second set of memory allocations can store trace data from each packet engine. In such an embodiment, the performance aggregator shares access to the first set of memory allocations with the packet engines, and the trace aggregator shares access to the second set of memory allocations.","In certain embodiments, only one set of memory allocations B-N is established for an appliance  having a performance aggregator and a trace aggregator. In such an embodiment, the performance aggregator, trace aggregator, and packet engines can communicate with each other through the shared memory allocations. Communications can be established by the setting of data flags, with or without accompanying commands, in the shared memory allocation by each device. For example, the performance aggregator can set a first flag to indicate a request for performance data. Each packet engine can be configured to recognize the first flag and provide the requested data to its memory allocation, and set a second flag indicating the data is available. The trace aggregator can be configured to recognize the first flag and second flag and not set any flags while the request from the performance aggregator is pending. The performance aggregator can read data from the memory allocations and set a third flag indicating that its request has been completed. The trace aggregator can recognize the third flag and set a fourth flag in the shared memory indicating a request for trace data. Each packet engine can recognize the fourth flag, provide the requested data, and write a fifth flag to the shared memory indicating the data has been written. The performance aggregator can recognize the fourth and fifth flags and not set any flags while the request from the trace aggregator is pending. The trace aggregator can read data from the memory allocations and set a sixth flag indicating that its request has been completed. When the third or sixth flags are present in the shared memory allocations B-N, either the performance aggregator or trace aggregator may set a flag in the shared memory requesting data. In this manner, the memory allocations B-N can be shared by the performance aggregator and trace aggregator, as well as by the packet engines A-N.","In various embodiments, the aggregator further comprises a buffer A for storing data obtained from the packet engines A-N via the shared memory allocations B-N. The data obtained from the packet engines can be stored directly into the buffer A, or processed before storing into the buffer. Data stored in the buffer A can be exported, or processed and exported to agents  requesting data from the aggregator . In certain embodiments, buffer A comprises a circular buffer, e.g., a circular page buffer, of sufficient size to store a selected amount of operational data or web content obtained from each packet engine. In some cases, the size of the aggregator's buffer A is substantially equivalent to the total size of all shared memory allocations B-N. In some embodiments, the buffer A is mapped by the aggregator upon its initialization, e.g., using IOCTL's, system calls, subroutines, function calls, API routines, remote procedure calls, etc. In some embodiments, the buffer A is divided into two sections, one for performance data and one for trace data. In such embodiments, additional space can be reserved for trace data.","In various embodiments, the aggregator  produces unified performance data A or unified trace data B (hereafter sometimes generally referred to as \u201cunified data\u201d ). The unified data  can be exported to the interface agent  for forwarding to one or more agents  requesting performance or trace data from the appliance . In various embodiments, the unified data does not identify the plurality of cores A-N and packet engines A-N of the appliance. As an example, an agent B receiving unified data  is unaware of the number of cores  or packet processing engines  in operation on the appliance . The unified data  can comprise a data structure having multiple records and multiple data types. The unified data  can be stored in any data format on any memory device accessible to the aggregator. In some embodiments, the unified data  is not stored by the aggregator, but exported to one or more agents . The unified data  can include performance statistics and trace data, described above, but representative of the appliance  as though the appliance comprised a single core. As an example, unified data  can include any aspect and type of data about the appliance's operation as a virtual server (VIP ), data about servers to which the appliance is currently maintaining active connections or has had connections to, data about a service managed by the appliance, and\/or trace data as described above in relation to the packet engines. In various embodiments, the unified performance or trace data  is representative of the appliance's network performance or web content handled by the appliance as a whole. In some embodiments, the unified performance data is a collective representation of the local performance data from each of the packet engines and\/or cores. In some embodiments, the unified performance data is a collective representation of the local trace data from each of the packet engines and\/or cores.","By way of an example, the aggregator  can produce the following unified performance data A for a multi-core, multi-packet engine appliance :","VIP(141.128.58.149:80:UP:WEIGHTEDRR): Hits(38200495, 18\/sec) Mbps(1.02) Pers(OFF) Err(0)","Pkt(186\/sec, 610 bytes) actSvc(2) DefPol(NONE)","Conn: Clt(253, 1\/sec, OE[252]) Svr(1)","SER1(141.128.49.40:80:UP) Hits(9443063, 4\/sec, P[2602342, 0\/sec]) ATr(5) Mbps(0.23) BW1mt(0 kbits)","RspTime(112.58 ms)","Other: Pkt(36\/sec, 712 bytes) Wt(10000) RHits(31555)","Conn: CSvr(42, 0\/sec) MCSvr(20) OE(16) RP(11) SQ(0)","SER2(141.128.49.39:80:UP) Hits(9731048, 4\/sec, P[2929279, 0\/sec]) ATr(9) Mbps(0.27) BW1mt(0 kbits)","RspTime (161.69 ms)","Other: Pkt(41\/sec, 756 bytes) Wt(10000) RHits(31555)","Conn: CSvr(32, 0\/sec) MCSvr(19) OE(13) RP(4) SQ(0)","In this example, the unified performance data comprises a record about virtual service \u201cVIP\u201d provided by the appliance  and two records about two servers \u201cSER\u201d providing services at the time the performance data was requested. In the example, the VIP record contains the following information or statistics: (IP address:port:state of the VIP:load balancing method configured for the VIP); (number of hits handled by the VIP in a time interval, current rate of hits on the VIP); (rate of flow of traffic managed by the VIP in Mbps); (state of persistence configured for the VIP); (number of times an error page was generated by the VIP in the time interval); (number of packets per second passing through the VIP, average size of the packets flowing through the VIP); (number of active services that are bound to the VIP); (an indication of whether a default load balancing method is active); (the number of current client connections to the VIP, the current rate at which client connections are established or terminated); (the number of server connections from the VIP in an established state); and (the number of servers actively providing service via the VIP). In the example, each server record contains the following information or statistics: (IP address:port:state of the service); (number of hits directed to the service in a time interval, current rate of hits, [number of hits directed to the service during the time interval due to configured server persistence, current rate of hits due to configured server persistence]), (number of active connections to the service); (rate of traffic flow passed to the service in Mbps); (a bandwidth limit defined by the service); (an average response time of the service); (an average rate of traffic flow in terms of packets during the time interval, average size of the packets); (a weight index used in a load balancing algorithm); (a running hits counter used in round-robin load balancing); (the number of connections to the service, the current rate at which connections are established or terminated); (a maximum number of connections to the service that has been reached); (a number of connections to the service in an established state); (a number of connections to the service residing in a reuse pool); (a number of connections to the service waiting in a serge queue). In this example, each of the values reported in a record can be obtained by totaling, averaging, or taking a weighted average of values from each packet engine A-N. For example, the number of client connections () to the VIP can be determined by the aggregator  by summing client connections obtained from each of the packet engine's performance record PA-N. In some embodiments, multiple occurrences of an aspect are singly counted by the aggregator  in the reported value in the unified data. As such, a particular client having multiple connections with the VIP via different packet engines may only be counted as one client connection. Furthering the example, an average response time of a service can be determined by the aggregator  by taking a weighted average of response times obtained from each packet engine's performance record PA-N. As such, each packet engine's recorded response time for the service can be weighted by the number of hits directed by each packet engine to the service.","The aggregator  can also accumulate and provide unified trace data B. In various embodiments, each packet engine A-N provides its own record of trace data TA-N, which can be written to shared memory allocations B-N. The aggregator  can read each packet engine's trace data and compile an aggregated or unified trace data structure B. In some embodiments, the unified trace data B comprises a concatenation of trace data from each packet processing engine A-N. The concatenation can be compiled according to one of several methods. The method used for concatenation can be specified during system development time or specified in an agent request for unified trace data.","In certain embodiments, unified trace data B comprises trace data from each packet engine concatenated by the core for the entire time interval of the trace. By way of an example in which a one-second time interval was specified for the trace and three packet engines A-C were actively passing web content during the interval, the unified trace data comprises the web content passed by a first packet engine A, followed by the web content passed by a second packet engine B, followed by the web content passed by a third packet engine C, during the one-second interval. Although the concatenated trace data might represent a three-second time frame, the unified trace data can be reported in \u201ccompressed\u201d time, e.g., time scaled by the number of packet engines passing data at the same time.","In certain embodiments, unified trace data B comprises trace data from each packet engine concatenated by core for sub-intervals of the entire time interval of the trace. In the above example, the concatenation method can be employed at each 100 ms, 10 ms, 1 ms, or any other sub-interval of time. As such, the trace data recorded by each packet engine would be interleaved when compiling the unified trace data B.","In some embodiments, unified trace data B comprises trace data substantially assembled according to streams of data exchanged between a particular server and a particular client. In such embodiments, the aggregator  can group and concatenate packets of web content according to source and destination IP addresses.","In certain aspects, the aggregator  communicates with each packet engine A-N using the shared memory allocations B-N. Communication can be carried out by setting and detecting the status of data flags in the shared memory. As an example, the aggregator  can communicate a request for performance data or trace data from a particular packet engine C by setting a data flag in the shared memory D. The packet engine C can monitor the memory D for the data flag, and upon detecting the flag write to the shared memory the requested data. After completing the writing, the packet engine can change the data flag or write a new data flag to the memory in a different location indicating the requested data has been written to the shared memory. The aggregator  can also monitor the memory D for a change in status of the flag, or the addition of a new flag. Upon detecting a changed or new flag, the aggregator can read the data from the shared memory D.","It will be appreciated that a flag set by the aggregator can include information identifying the requested data, e.g., performance data, certain elements of performance data, trace data, certain filtered elements of trace data. In some embodiments, the flag itself identifies the requested data or command to be carried out by each packet engine A-N. For example, a first flag can identify a request for all performance data, a second flag can identify a request for a first subset of elements of performance data, e.g., elements of virtual service, a third flag can identify a request for a second subset of elements of performance data, e.g., elements of a first service or a first server, a fourth flag can identify a request for trace data, etc. In such embodiments, each packet engine A-N can be configured to recognize the one or more flags and identify the requested elements from the flag itself. In some embodiments, the flag is accompanied by data written in the shared memory by the aggregator , wherein the accompanying data identifies the requested data or command to be carried out by each packet engine. It will be appreciated that the aggregator  can set the same flags in all memory allocations B-N shared with the packet engines A-N, or can set different flags in the memory allocations.","When shared memory is further shared by packet engines, e.g., packet engines A and B share allocation B, communication via flags and time multiplexing can be employed to manage data written to and read from the shared memory. As an example, the aggregator  can request sequentially data from the two packet engines A and B in this example. A first flag identifying a first packet engine A and a data request can be written by the aggregator to the shared memory B. Packet engine A monitoring the memory can detect the flag, write the requested data to the memory B, and alter the flag or add a new flag to indicate it has written the data to the memory, while packet engine B ignores the flag since the flag does not identify engine B. Aggregator  can read the data provided by the first packet engine A from the memory B, and write a second flag identifying the second packet engine B and data requested. The second flag can replace the first flag or altered flag. Packet engine B can detect the flag, write the requested data to the memory B, and alter the flag or add a new flag to indicate it has written the data to the memory, while packet engine A ignores the flag. Aggregator  can then read the data provided by the second packet engine B.","In various embodiments, aggregator  is adapted to communicate with agents . The communication with agents  can be via an agent interface . The agent interface can comprise software, firmware or any type and form of executable instructions executing on a core of the appliance. In some embodiments, the agent interface  comprises a set of instructions which are part of the aggregator . In some embodiments, the agent interface  comprises a set of instructions operating separately from the aggregator . In some instances, the agent interface is in operation on the same core as that for the aggregator, and in some cases the agent interface  is in operation on a different core from that on which the aggregator  operates. In various embodiments, the agent interface  communicates with the aggregator  via socket connections.","In certain embodiments, the agent interface  comprises two IP ports, e.g., port  and port , and software associated with establishing and maintaining socket connections on these ports. One port can be used for receiving requests from and transmitting data to one or more agents , such as the data relating to performance statistics. One port can be used for receiving requests from and transmitting data to one or more agents, such as the data relating to trace data. In certain embodiments, the aggregator  is configured to listen for socket connections on ports of the agent interface . In some embodiments, the agent interface comprises one or more data files. As an example, data requests can be written to a \u201cdata request\u201d file by an agent A and read from the file by the aggregator . The aggregator can write the requested data to a \u201cdata return\u201d file, which can be read by the agent. In some embodiments, the agent interface  comprises software which translates requests received from one or more applications into a format recognizable by the aggregator .","An agent A, B (generally ) can comprise any entity requesting performance or trace data from the appliance . An agent can be a system operator or administrator entering commands in a command line interface (CLI) in communication with the appliance. An agent can comprise a graphical user interface, dashboard, proprietary software, or publicly available software, e.g., TCPDUMP, Wireshark, NETSVC, SNMP, etc., configured to communicate with the appliance . In some embodiments, an agent comprises another networked device, e.g., a server , a client , or another appliance \u2032, which periodically interrogates the appliance  for performance or trace data. In certain embodiments, an agent is a connection, module or agent of a client for interfacing with and\/or gathering information from the aggregator.","Referring now to , an embodiment of method  for use with the performance and trace aggregating system  is depicted. In various embodiments, the method  comprises collecting or capturing  data by each packet engine, storing  data to a buffer by the aggregator, consolidating  the data by the aggregator, receiving  a request for data by the aggregator, and transmitting  the consolidated data by the aggregator in response to the request. This and other steps-based depictions in this disclosure are not intended to portray a specific sequence of the steps, and certain steps can be performed before or after other steps. The method can comprise a subset of the steps depicted, and in some embodiments include additional steps as described below.","In certain embodiments, the step of collecting  comprises collecting by each packet engine performance data identifying statistics of a service provided by a server for which each packet engine manages network traffic. In some embodiments, the performance data identifies statistics of a server or service only associated with a current or active connection between each packet engine and the server providing the service. In some embodiments, the performance data identifies statistics of a server or service associated with a past connection to a server. In certain embodiments, the collected performance data identifies statistics of virtual service provided by each packet engine. The performance data can include any element of information about virtual service of each packet engine as described above, e.g., the IP address and port configuration of the VIP, the state of the VIP, etc. The performance data can include, alternatively or in addition to the VIP data, any element of information about the server or service of the server as describe above, e.g., the IP address and port configuration of the server, the state of the service provided by the server, etc. In some embodiments, the step of capturing  comprises capturing, by each packet engine, trace information for network traffic received or transmitted by each packet engine. Trace data can include, without being limited to, any element from the following list: requests for web content, responses to requests for web content, encrypted web content, non-encrypted web content, and any combination thereof as described above. In some embodiments, the collecting  of performance data is done periodically, e.g., every 10 seconds, every 7 seconds, every 3 seconds, every 1 second, by each packet engine. In various embodiments, the step of collecting  further comprises determining, by each packet engine A-N, performance statistics and recording the statistics to performance records PA-N. In various embodiments, the step of capturing  comprises recording, by each packet engine, trace data to trace records TA-N. In some embodiments, collecting  of performance data is done in response to a request for performance data indicated by the aggregator . In certain embodiments, the capturing  of trace data is done in response to a request for trace data indicated by the aggregator .","Further aspects of an embodiment of the step of collecting or capturing  are depicted in . In certain embodiments, the step of collecting or capturing  comprises sending or storing command and setting  a flag by the aggregator in each shared memory allocation B-N for each of the plurality of packet engines. In some embodiments, the data flag comprises an indicator and a command. The indicator can identify a status of the request, e.g., data requested, no data requested, data requested at a specified time, data requested for a specified time interval, data requested for a particular packet engine, etc. The command can comprise details about the elements of data requested as well as specific types of actions, e.g., provide virtual service data, dump all data immediately, terminate data collection, terminate data capturing, begin data capturing, filter data in accordance with specified filtering criteria. In various embodiments, the step of collecting or capturing  further comprises changing, by each packet engine, the data flag in shared memory allocations B-N when each packet engine completes the step of collecting or capturing .","The step of collecting or capturing  can further comprise detecting, by each packet engine, the data flag set by the aggregator  in memory shared between the packet engine and the aggregator. Each packet engine A-N can monitor the shared memory for the data flag. Each packet engine can further interpret any data, e.g., a command set by the aggregator , included with the flag and identifying certain aspects of data requested, e.g., performance data, certain elements of performance data, trace data, filtered elements of trace data, time intervals associated with the data. Data included with the flag can also include IOCTLs, objects, data structures, function calls, procedure calls, routines, macros, and the like.","The step of collecting  can comprise executing, by each packet engine, diagnostic routines to compile performance statistics for each packet engine. The diagnostic routines can identify performance data or certain elements of performance data as requested by the aggregator . In some embodiments, the routines can comprise maintaining counters which determine any of the following types of values, total number, maximum number, minimum number, average number, frequency, etc. The step of collecting  can comprise collecting data for current active connections between active clients and servers actively providing service. In some embodiments, the step of collecting  can comprise collecting data historical data of performance statistics stored in an archive accessible to the packet engine. The step of capturing  can further comprise executing routines by the packet engine to record during a selected time interval network traffic passed by the packet engine, e.g., record trace data during a specified time interval. In some embodiments, the capturing further comprises filtering the captured data. The filtering can comprise recording, by each packet engine, only network traffic which meets a filter criterion, e.g., from a particular source IP address, during a particular time interval, to a particular destination IP address, etc.","In various embodiments, the step of collecting or capturing  further comprises collecting or capturing data by each packet engine for a selected time interval. The selected time interval can be identified by the aggregator , and established with the data flag and\/or command set by the aggregator in shared memory B-N. In certain embodiments, a default time interval is used for instances when no time interval is specified by the aggregator. In various embodiments, the step of collecting or capturing  further comprises writing, by each packet engine, performance data or trace data to the shared memory allocations B-N. The performance data can be written, by each packet engine, to the shared memory allocations B-N from each packet engine's performance record PA-N. The trace data can be written, by each packet engine, to the shared memory allocations B-N from each packet engine's trace record TA-N.","Referring again to , the step of collecting or capturing  can further comprise monitoring, by the aggregator, the status of the data flags set in each shared memory allocation B-N to determine A whether each flag's status has changed. If it is determined that a flag's status has changed, the aggregator  can read  performance data or trace data from the shared memory allocation indicated by the changed flag status. If it is determined that a flag's status has not changed, the aggregator  can determine B whether a packet engine is slow in providing the requested data, e.g., the packet engine has not provided the requested data within a specified time window. If it is determined that the packet engine is not slow, the aggregator can execute  another task and return to checking A the flag status at a later time. If it is determined B that the packet engine is slow in providing the data, the aggregator  can issue a command which forces  the packet engine to dump its performance data or trace data. The aggregator  can then read  the dumped data. In cases where a forced dump is executed by a packet engine and the packet engine has not complete all of its data acquisition, any remaining data values to be acquired or any remaining data trace to be acquired can be represented as zero values when the packet engine writes the acquired data to the shared memory allocation.","The step of storing data  can comprise storing to a buffer A by the aggregator  performance data or trace data from each packet engine. In some embodiments, the step of storing  comprises storing, by the aggregator, performance or trace data to a file or location external to memory . In various embodiments, the step of storing can include detecting, by the aggregator, a change to a data flag set in shared memory allocations B-N by the aggregator. If the aggregator detects a change in a data flag for a particular memory allocation C, the aggregator can read data from the shared memory having a changed flag and write the data to the aggregator's buffer A. If the aggregator does not detect a change in a data flag for a particular memory allocation B, the aggregator can attend to other processing tasks, e.g., detect the status of a data flag for the next shared memory allocation, and return to check A the data flag for the particular memory allocation B at a later time.","The step of storing  can comprise writing data from a shared memory allocation directly to the aggregator's buffer A. In some embodiments, the step of storing  further comprises processing the data from the shared memory allocation before writing the processed data to the aggregator's buffer. In some embodiments, the step of storing  comprises reading data from shared memory allocations B-N, processing the data, and exporting results from the processed data directly to an agent without storing the data in the aggregator's buffer A. In some embodiments, the processing of data comprises consolidating the data obtained from the plurality of packet engines.","In some embodiments, the step of storing  further comprises maintaining data structures representative of per core statistics and data structures representative of global statistics. For example, the aggregator  can maintain a per core data structure which identifies individual services currently managed by each core. The aggregator  can further maintain a global data structure which identifies on how many cores a particular service is handled. In certain embodiments, when a new service is added on any packet engine, the packet engine dumps its performance data to its shared memory allocation. The aggregator  can then detect the addition of a service and update its per core and global data structures. In some embodiments, the addition of a new service is detected when each packet engine writes its performance or trace data to shared memory in response to a request for performance or trace data. In some implementations, when a service is deleted from any packet engine, the packet engine dumps its performance data to its shared memory allocation. The aggregator  can then detect the deletion of a service and update its per core and global data structures. In some embodiments, the aggregator  removes the service from all per core data structures and the global structure. In some embodiments, the aggregator  only removes the service from the global data structure when all packet engines indicate that they no longer manage the service.","In various embodiments, methods  for aggregating performance or trace data comprise consolidating , by the aggregator, the performance or trace data to provide unified performance data A or unified trace data B of the multi-core, multi-packet-engine appliance . The unified data can be representative of the appliance as though the appliance comprised a single core. As an example of consolidation, a case where two packet engines A, B provide service to a plurality of clients A-N from the same server A is considered. A first packet engine B may record in shared memory C that it has 3 active connections with server A for the service and that its traffic volume to the service is 85 packets per second. The second packet engine A may record in shared memory B that is has 4 active connections with server A for the service and its traffic volume to the service is 37 packets per second. For this example, the unified data  obtained from the step of consolidating  would represent the appliance  as having 7 active connections with server A for the service and a traffic volume of 122 packets per second.","In some embodiments, the step of consolidating  comprises processing performance data P or trace data T obtained from the plurality of packet engines A-N. The processing can include executing macros, functions, routines, or sets of instructions to compile unified performance statistics A or unified trace data B representative of the appliance . As an example, the processing can comprise totaling a number of connections to distinct servers, totaling traffic volume to each distinct server, totaling a number of hits on each distinct server, obtaining averages or weighted averages of traffic volume to each distinct server, interleaving trace data to provide a unified trace, etc. as described above in reference to unified performance data A and unified trace data B. In various embodiments, the aggregator  consolidates the data from the plurality of packet engines A-N after the data is written to buffer A. The step of consolidating can further comprise writing the consolidated data  to a separate location in memory  or to a location reserved in the buffer A for consolidated data. In some embodiments, the aggregator consolidates  the data from the plurality of packet engines after reading the data from shared memory allocations B-N, and writes the consolidated data  to buffer A, or exports the unified data  directly to an agent A or to a file external to memory . In certain embodiments, the step of consolidating  is repeated periodically, e.g., at time intervals between about 50 milliseconds (ms) and about 500 ms, between about 500 ms and about 5 seconds, between about 5 seconds and about 60 seconds.","When consolidating  trace data, the aggregator  can further represent the consolidated data in terms of actual processing time, compressed time, or both. As an example, the processing by the multi-core appliance of a stream of packets from a particular server is considered. In various embodiments, the stream of packets flows through and is processed by the multi-core appliance . In some embodiments, the packets are parsed to different packet engines which can process their allotted portions of the stream at the same time or different times from the other packet engines. A trace representation of the packet stream in terms of actual processing time would comprise consolidating the trace data to reflect the total amount of processing time of each core used in processing the stream of packets, e.g., concatenating each core's processing segment. A trace representation of the packet stream in terms of compressed time would comprise consolidating the trace data to reflect the time at which each portion of the stream was processed by the appliance. Compressed time could provide an indication of multi-packet-engine processing, e.g., a high rate of content handling for a particular time interval (multi-processing) and a low rate of content handling at another time interval (single-core-processing) for a stream of packets.","In some embodiments, the step of consolidating  further comprises consolidating the number of connections to a service from the plurality of packet engines A-N and providing a total number of connections to the service from the appliance . The service can be provided by one or more servers  over the network . The total number of connections can be a raw total or represent a number of connections from distinct clients. (Some clients may have more than one connection to a service.) In some embodiments, the consolidating  further comprises consolidating the average response to a service from the plurality of packet engines A-N, and providing a unified average response time to the service from the appliance . The unified average response time can be calculated in any one of several ways, e.g., averaging average response times obtained from each packet engine, calculating a weighted average such as weighting the average response obtained from each packet engine by the number of connections made to the service by the packet engine.","In some embodiments, the step of consolidating  further comprises consolidating the number of bytes passed for a service from the plurality of packet engines A-N, and providing a total number of bytes passed for the service by the appliance . In some implementations, the step of consolidating  further comprises consolidating the number of different servers obtained from the plurality of packet engines A-N, and providing as a portion of unified data a number of distinct servers providing network service via the appliance . The number of different servers may include all active servers on each packet engine, all recently active servers, servers in a reserve or reuse pool, all past servers, or any combination thereof. The number of distinct servers can comprise a subset of the different servers having distinct IP addresses.","The step of receiving a request  can comprise receiving, by the aggregator, a request for performance data or trace data of the appliance. The request can be received from one or more agents . The request can be received by the aggregator through an IP port, e.g., via an established socket connection managed by the agent interface . In certain embodiments, the step of receiving a request  comprises listening  on one or more IP ports for a socket connection and receiving data representative of a request through an IP port. The step of receiving  can further comprise monitoring activities on IP ports managed by the agent interface . In certain embodiments, the step of receiving a request  comprises monitoring a data file or location in memory for a newly entered request and reading the request from the file or location in memory. In various embodiments, the request comprises data identifying elements of performance statistics or trace data desired by the entity issuing the request, and identifies a destination for transmitting a response to the request. In some implementations, a request comprises command line code, IOCTL's, objects, function calls, or any type and form of executable instructions. The step of receiving  a request can comprise executing, by the aggregator, the received instructions, or providing the received instructions, or a portion thereof, to each packet processing engine A-N.","In various embodiments, the aggregator  is adapted to transmit  consolidated or unified data  in response to a received request for the data. The unified data  can be transmitted in any format. In particular embodiments, the step of transmitting  further comprises converting the unified data  to a format specified by the agent  issuing the request. In certain embodiments, the step of transmitting  comprises exporting the unified data  from buffer A to agent interface , which in turn can forward the unified data to the agent  requesting the data. In some embodiments, the step of transmitting comprises identifying, by the aggregator, a memory location holding the unified data . The memory location can be identified to the agent interface and\/or the agent requesting the data whereupon either the agent interface or agent requesting the data can read the unified data  from the identified memory location.","G. Systems and Methods For Scalable N-Core Stats Aggregation","Referring now to , one embodiment of a system for aggregating data or statistics from cores of a multi-core appliance is depicted. In brief overview, the system includes a plurality of cores A-N, shared memory , and an aggregator . In various embodiments, one or more clients may make a request to the aggregator for data or statistics (e.g., performance statistics and trace data) associated with one or more cores of the multi-core system. The depicted system may be implemented as a variation, combination, reconfiguration and\/or improvement over any of the embodiments of features described above in connection with .","In certain embodiments, the agent interface and\/or agent allows a client to access data or statistics (hereafter sometimes generally referred to as \u201cdata\u201d or \u201cstatistics\u201d) collected by the aggregator . A client may be any network device (e.g., client , server , appliance , etc), service, virtual machine, virtual service or program that uses the statistics or provides the statistics to another entity either processed or unprocessed. In certain embodiments, a client may be a device transmitting and\/or receiving traffic via one or more cores or packet engines of the appliance. In some embodiments, a client may be an administrative service, monitoring service or other type of service, e.g., an nsnetsvc associated with CITRIX NETSCALER. In other embodiments, nsnetsvc may be an agent interface for the aggregator and an agent of a client. In still another embodiments, nsnetsvc may be an agent of a client. A nsnetsvc, as a client and\/or client agent, may generate and\/or deliver commands for requesting statistics from the aggregator. A nsnetsvc, as an agent, may deliver or convey client commands for requesting statistics from the aggregator.","In some embodiments, a client may request certain events to be reported in real-time or substantially in real-time. These events may be represented by statistics of packet processing engines, virtual servers and\/or associated member services processed and\/or tracked by one or more cores of the multi-core system. A client may also request for statistics from performance records, e.g., using a stat command. A client may include or provide a dashboard or other interface for organizing, summarizing and\/or presenting statistics to a user or program. In some embodiments, a dashboard may process and\/or provide data in real-time or substantially in real-time. A client request may comprise a request for statistics associated with two or more cores of a multi-core system, or statistics for the multi-core system as a single unit. In one embodiment, for example in the NETSCALER context, a client may use a nsconmsg and\/or nscollect command in a request. Another client request may comprise a request for statistics associated with a particular core of a multi-core system.","The system may support and interface with any number of different types of clients. In some embodiments, and by way of illustration, the different types of clients may be categorized into at least (1) streaming or non-filtered clients, and (2) filtered request-response clients. Streaming or non-filtered clients may transmit requests that are sometimes referred to as kernel mode packet engine (KMPE) type requests. Such requests may include commands such as nsconmsg. These requests may communicate with an aggregator on a particular port (such as ), instead of sending IOCTL calls to the kernel of the appliance. The aggregator may be assigned to and\/or listening on the particular port. In some embodiments, streaming clients may parse raw and\/or full performance data streams (sometimes generally referred to as \u201cperf-streams\u201d or \u201cdata streams\u201d) into statistics and\/or records. Streaming clients may create and\/or maintain the data structures for the statistics and\/or records. Thus, streaming clients may have the same or substantially the same access to statistics and information that an aggregator or a packet engine may have. By way of illustration, requests from streaming clients can include nsconmsg, dashboard and nscollect requests.","The aggregator may support one or more filtered request-response clients. Request-response clients may send a request for statistics for one or more particular devices (i.e., vservers, packet engines and\/or cores). These devices may already be known or identified by the client. The client may already be in communication with these devices. For example, the multi-core system may have assigned a particular core to process network traffic associated with the client, or the client may have previously communicated a packet via a specific packet engine or core. Responsive to such a request, the aggregator may filter and\/or process the statistics gathered at the aggregator, generate a response and\/or send the response responsive to a client request. In some embodiments, however, per-entity, e.g., per-core or per-packet-engine statistics may not be available. For example, per-core statistics may not be available because statistics for two or more cores or packet engines may have already been merged together. By way of illustration, and not intended to be limiting in any way, requests from request-response clients may include stat, snmpd, nslcd and show commands or requests.","As discussed above, the aggregator may collect statistics from entities such as packet engines and consolidate the statistics, for example, based on counter definitions. The counter definitions may specify an interval, schedule and\/or sequence for collecting statistics from each packet engine. The statistics may be of any type or form, such as summation, average, minimum and maximum per-packet-engine (sometimes referred to generally as \u201cper-PE\u201d) values. The aggregator may create per-PE records based on the collected statistics and may consolidate these records to an internal buffer of the aggregator. The aggregator may parse statistics from each of the packet engines. The aggregator may store or maintain the per-PE statistics prior to consolidation. In certain embodiments, the aggregator consolidates and stores the packet engine statistics into the internal buffer. In some embodiments, one or more clients may access information from the internal buffer. In other embodiments, the aggregator generates a response to a client request using information from the internal buffer. The internal buffer may be or incorporate any type or form of memory device such as cache , storage , memory , , buffer  and disks  described above in connection with , A and A. The aggregator may also perform multi-tasking or interleaving between any of the above tasks to check for client requests and\/or respond to client requests.","In some embodiments, the aggregator may allocate memory and\/or data structures to maintain or manage mappings between local device identifiers and global device identifiers. Local device identifiers may be assigned on a per-PE or per core basis. In certain embodiments, the aggregator may assign a local device identifier to a entity such as a packet engine, virtual service, virtual machine, service, application or some other packet processing module in a core. In some embodiments, each entity may be assigned one or more device identifiers. For example, each packet engine or core may execute, provide or be associated with one or more devices (e.g., virtual servers executing in the core). For example, a vserver v executing in connection with PE-0 may have a local device number , while a similar vserver executing in connection with PE-1 may have local device number that is the same (e.g., 100) or different (e.g., 200) from the vserver v. Thus, across a plurality of cores, local device numbers of such entities may not be unique. In some of these embodiments, the aggregator translates per-PE or local device identifiers to a global device identifier when consolidating statistics from each packet engine. A global device identifier may uniquely identify an entity across a plurality of cores.","In some embodiments, each core may operate with the aggregator via shared memory . For example, the aggregator may request pages or information from a core by writing the request into the shared memory. The core may receive the request by accessing the shared memory . The aggregator  may read the requested pages or information from the shared memory. The aggregator may process the requested pages or information and store them in an internal buffer of the aggregator, which may be local memory (e.g., of the aggregator, not shared memory). In response to a client request, the aggregator may establish a socket connection with the corresponding client or client agent. The socket connection may be used to read and\/or write IOCTL messages, e.g., from the client to a nsnetsvc, and from the nsnetsvc to the aggregator.","One core may provide data to the aggregator using one or more dedicated memory locations. In certain embodiments, an aggregator may share or reuse one or more memory locations between different cores, e.g., at different times.","The aggregator, in processing the statistics, may have certain memory requirements. For example and in some embodiments, processing absolute records from a packet engine may involve the following:","Collecting stats=100 ms.","Parse the stats=1200 ms.","Dump the stats into client buffer=400 ms.","Processing absolute statistics, which may exclude some records such as devicename, devlink, codeinfo records, may involve the following:","Collecting stats=100 ms.","Parse the stats=1045 ms.","Dump the stats into client buffer=400 ms.","Processing differential statistics (e.g., incremental changes or updates to the statistics) may involve the following:","Collecting stats=10 ms.","Parse the stats=200 ms.","Dump the stats into client buffer=400 ms.","The total number of devices established, created, deployed and\/or monitored in a configuration may be 200K=2*10. The total number of device statistics records maintained in the aggregator may be 2M=2*10. The per device counter may be set to 10. Each batch of device statistics may take up at least 24 bytes (current, previous and earlier batches) for example. Earlier batches of data may be used for maintaining rate calculations. The total per-PE statistics space requirement in the aggregator may be 24*2*10bytes=48 MB. In some embodiments, under normal traffic patterns, per device counters may be assumed to be approximately 20-30 (e.g., instead of 10). According to this scenario, the per-PE statistics memory requirement may be around 100-150 MB or more. In some embodiments, memory requirements may increase, for example, when features such as configuration scaling, core scaling and counter scaling, are added.","In some embodiments, the aggregator may be configured to aggregate statistics without allocating memory for maintaining per-PE statistics. Each packet engine or packet processing entity may be assigned at least one global device identifier, e.g., by the appliance or a server, for transferring or dumping per-PE statistics. The aggregator may store data structures that map local device identifiers to global device identifiers in shared memory with each core. In certain embodiments, the aggregator may use a single block of shared memory shared across a plurality of cores. In some embodiments, the aggregator may allocate or assign specific memory locations or segments for shared access with a particular core. By way of illustration and not intended to be limiting in any way, an embodiment of data structures maintained in shared memory for managing device identifiers is as follows:",{"@attributes":{"id":"p-0302","num":"0313"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"u32bits nspm_cur_global_devno ; \/* global devnumber for incrementing *\/"},{"entry":"\/* structure for handling the device name <-> devnumber mapping*\/"},{"entry":"typedef struct nspm_devnamerec"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NS_LIST_ENTRY(nspm_devnamerec) dn_list; \/* next in chain *\/"]},{"entry":[{},"struct nspm_devnamerec *dn_next_free; \/* to maintain the number of devices in the"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"free list*\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"u32bits dn_devno;","\/* global device number *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"u08bits dn_devname_len; \/* length of this device name *\/"]},{"entry":[{},"u08bits reserved_1[3];"]},{"entry":[{},"u08bits *dn_devname;\u2003\/*Max 192 characters, for example*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} nspm_devnamerec_t;"},{"entry":"typedef struct {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct type *lh_first; \/* first element *\/"]},{"entry":[{},"u32bits devname_slck; \/*lock for this bucket *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} nspm_devnamehead_t;"},{"entry":"nspm_devnamehead_t nspm_devnamehashheads[NSPM_DEVNAMEHASHSIZE];"},{"entry":"u32bits nspm_getdevnamedevno(u08bits *name);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"These structures or application processing interfaces (APIs) may be used by a packet engine to obtain a unique mapping between a device (e.g., device name or local device identifier) and a global device identifier. In some embodiments, by using global device identifiers, the aggregator may directly add per-PE differential statistics and\/or assign absolute statistics to aggregated values. This may enable the aggregator to bypass certain steps, such as the steps of updating per-PE data structures before updating aggregated values.\n\n","In certain embodiments, the aggregator may provide a computing or process thread (hereafter sometimes generally referred to as \u201cthread\u201d) to a packet engine, e.g., for collecting and updating per-PE statistics. A thread may be any type or form of processing unit, task, code, application, agent, module or computing step(s). A thread may execute independently of another thread, or may communicate or interoperate with another thread. A given thread may collect a data or statistics stream from a respective packet engine, e.g., directly or via shared memory. The thread may parse, analyze or process the data stream and may update some portion of aggregated statistics (e.g., of a given device, packet engine or core). The thread may process or track a respective data stream according to a global device identifier. The thread may write the data stream or statistics into a logfile or memory unchanged (e.g., as generated or recorded by a packet processing engine or a monitor executing on a corresponding core) or substantially unchanged. The thread may write the data stream to a logfile or memory without consolidating data from one or more other entities, devices, packet engines or cores. This multi-threading process, supporting multiple entities across one or more cores, may improve overall processing time. For example, processing time may be reduced because the aggregator writes data streams directly into a logfile instead of to an internal buffer requiring proper formats. Concurrent or parallel processing via multi-threading may also reduce processing time.","In some embodiments, the aggregator may receive a request from a client. The aggregator may identify the request as a dashboard request for an aggregated data stream. The aggregator may be built, designed and\/or configured to parse, collect and\/or consolidate a plurality of data streams. The aggregator may generate an aggregated data stream from one or more data streams or cores. The aggregator may, for example, generate an aggregated data stream in real time, or in response to receiving a request. Responsive to the request, the aggregator may read or access one or more data streams and\/or modify processing on an aggregated data stream.","The aggregator may create and assign a thread to generate, update, handle or process this aggregated data stream. The aggregator may process and\/or write at least a portion of the aggregated data stream to the internal buffer. The aggregator, client and\/or client agent may establish a dashboard connection to the internal buffer to access the stored data. In some embodiments, the client or client agent may send a message to the aggregator when the dashboard connection is closed or no longer required. Responsive to this message, the aggregator may stop writing or generating the data stream to the internal buffer. Independent of and\/or concurrent with this thread, another aggregator thread (e.g., a main aggregator thread) may serve one or more client requests of the same or a different type (e.g., stat, snmpd, nslcd, show requests).","In some embodiments, a client may seek access to a data stream handled by the aggregator. The client may initiate the request via a nsconsmg or nscollect request. The corresponding client or agent may access the data stream by connecting to a port of the aggregator (e.g., NSAGG_LISTEN_PORT). The client or agent may issue IOCTL calls via the port (e.g., NSAPI_ADD_RET_PERFDATAHEADER, NSAPI_ADDPERFDATAHEADER, NSAPI_WAITRACEDATA, NSAPI_GETRACEDATA and NSAPI_GETFIRSTRACEDATA) to access the internal buffers of the aggregator.","In other embodiments, a client or client agent may access a performance stream from a logfile (e.g., a newnslog file) or a storage device that receives or buffers the data stream. The logfile or storage device may reside anywhere on the network, such as on the aggregator or in communication with the aggregator. The data streams or statistics may be retrieved from the logfile or storage device instead of from the aggregator (e.g., from local buffers of the aggregator). The aggregator may directly write at least a portion of the data stream into the logfile or storage device. A network service or agent, for example operating on behalf of the client, may access the data stream from the logfile or storage device.","In some embodiments, a client request may initiate or execute a program or instructions to collect information from one or more data streams. For example, a nsconmsg request may be associated with a set of instructions. These instructions may be compiled into a binary file, executable and\/or program file. The compiled instructions may be incorporated or added to a library (e.g., libnsapps). The compiled instructions may reside or be installed in the aggregator, or accessible by the aggregator. Instructions associated with various types of client requests may be used for debugging purposes, for collecting data streams from the aggregator, and for writing a data stream to a logfile, for example.","In certain embodiments, the instructions may be executed as a process. A process, such as one associated with the nsconmsg instructions, may be made event-aware. Such a process may receive a notification when the logfile or storage device is updated with newer data. The process may parse or access the newer data responsive to the notification. In some embodiments, and by way of illustration, a disk access may occur every 7 seconds for a process to parse new pages added to the logfile or storage device. A large configuration may involve disk accesses of 300 pages per packet engine, for example. On a 7-packet-engine system, for example, 8*300 pages may be accessed, which may translate to about 19 MB per 7 seconds, or about 2.5 MB per second. These are page reads, which may be preferred over socket reads. In certain embodiments, a system having a typical configuration may handle about 1-20 pages per 7 seconds.","Storage requirements may be reduced by not having the logfile or storage device contain an aggregated data stream. In some embodiments, storage space levels or savings of 1\/(num of PE+1) with respect to the alternative may be achieved. An aggregated data stream may include data collected in real time and\/or from all or some cores and their entities. In some embodiments, portions of data streams (e.g., representative, estimated or sample statistics) are collected from each PE for storage in the logfile or storage device. If aggregated statistics are needed or preferred, the requesting client may obtain the different data streams and perform the aggregation (e.g., at the client or by the client agent). In some embodiments, counter information for doing so can include different types of counters (e.g., _TNC\/_TNAVG\/_TNMAX\/_TNMIN, etc.). Each counter may add or provide a data construct, format and\/or location (e.g., codevalformat) for holding or tracking this information. These counters may be implemented in or by the aggregator.","In some embodiments, a counter may be used to partition and\/or identify a data stream from one or more PEs. Data streams from each PE may be interleaved using the counter, e.g., according to a predetermined sequence and\/or time period for data collection\/logging. In certain embodiments, a counter may generate a marker (e.g., a count or identifier) for insertion with a particular data stream. The marker may be used to uniquely identify a data stream from a particular source entity (e.g., core, packet engine or virtual server). In some embodiments, a marker is generated based on (e.g., to uniquely correspond to) a global device identifier of an entity. A marker may, for example, include a global device identifier, or be uniquely mapped or translated into a global device identifier using a mapping table or other means.","In some other embodiments, an aggregated stream may be stored or maintained in the logfile or storage device. This may reduce the amount of time for a client to obtain consolidated values. Moreover, in certain embodiments that store or maintain an interleaved or aggregated stream in the logfile or storage device, markers for the respective aggregated streams may be used for jumping or identifying between data of different streams, such that parsing time within the logfile or storage device can be saved.","In some embodiments, the aggregator may adaptively inform or communicate with a packet engine to adjust the data stream transfer, dumping interval or schedule. For example, there may be situations in which some aggregator threads are operating slower than the data stream dumping interval in the packet engine, such as when the processor handling the multi-threads have higher loads or is handling more threads than usual. The dumping interval may be decreased or increased to synchronize the packet engine data transfer with the aggregator threads. In some embodiments, the aggregator may use flags or other monitoring means to track operating speed and\/or transfer readiness, for example, using the flags described above in connection with .","The aggregator may adaptively adjust the transfer interval based on the logfile generation rate. In some embodiments, a packet engine may dump 300 pages every 7 seconds. Based on an eleven-PE, for example, logfile generation may involve the following: Absolute records without statistics (X) may cover about 1800 pages, which translates to about 1800*8*1024 byte or 14 MB of memory. Absolute stats from one PE (Y) may cover about 1200 pages, which translates to about 9.37 MB. Differential stats from one PE (Z) may cover about 300 pages, which translates to about 2.34 MB. Based on the above, one set of absolute record for clients on an 11-PE system may translate to about X+(11+1)Y or 126.44 MB. An extra unit of memory (Y), as indicated, may be allocated to account for the aggregator. In some embodiments, absolute statistics (e.g., dumped when a configuration change happens) may translate to about (11+1)Y or 112.44 MB. Differential statistics (e.g., at every 7 seconds) may translate to about (11+1)Z or 28 MB. In this case, a differential record may consume about 4 MB per second. If, the logfile is compressed (gzipped) when it reaches a threshold, e.g., 40 MB, compression may be triggered every 70 seconds. Thus, the aggregator may adaptively or accordingly adjust the rate of transfer or data stream dump between the packet engines, threads and\/or the logfile. For example, if the aggregator determines that the logfile size is incrementing too fast (e.g., beyond a threshold rate), the aggregator may lengthen the interval between transfers\/dumps.","Referring now to , an embodiment of steps of a method  for aggregating performance statistics from cores of a multi-core system is depicted. In brief overview, a multi-core system intermediary between one or more clients and servers maintains in shared memory of the multi-core system a global device number for each core of the multi-core system (). Each core may include one or more packet engines processing network traffic between the one or more clients and servers. The multi-core system may provide, via an aggregator, a computing thread for each core of the multi-core system to gather data from the corresponding core (). A first computing thread of the aggregator may collect statistics of network traffic processed by one or more packet engines on a first core (). The first computing thread may transfer the statistics with a marker to a statistics log of the multi-core system (). The marker may correspond to a global device number of the first core. The multi-core system may adaptively reschedule the transfer by monitoring the operation of each computing thread (). In further details of step , a multi-core system intermediary between one or more clients and servers maintains in shared memory a global device identifier (or number) for each core of the multi-core system. Each core may include one or more packet engines processing network traffic between the one or more clients and servers. An aggregator of the system may provide and\/or maintain the shared memory. The aggregator may provide and\/or maintain a block of shared memory for each core, or for a plurality of cores. The aggregator may provide and\/or maintain a block of shared memory for use with one or more packet engines, virtual machines, applications, services and\/or other entities of each core. For example, the aggregator may provide and\/or maintain a respective portion of the shared memory for use with each packet engine or other entity of a core.","The aggregator may generate, provide and\/or assign one or more global device identifiers to each core or packet engine. The aggregator may generate, provide and\/or assign one or more global device identifiers to each entity or device (e.g., packet engines, virtual machines, applications, services and\/or other entities of each core). The aggregator may generate, provide and\/or assign a unique global device identifier to each packet engine, virtual machine, application, service and\/or other entity of a core. For example, the aggregator may assign, for each core of the multi-core system, a global device number to a virtual machine executing on the core. The aggregator may assign, for each core of the multi-core system, a global device number to each virtual machine of the core. Each virtual machine may include one or more packet engines processing network traffic between the one or more clients and servers. The aggregator may generate, provide and\/or assign a global device identifier that is unique within and\/or between cores of the multi-core system. The aggregator may generate, provide and\/or assign a global device identifier that uniquely identifies an entity or device from others within a core and\/or between cores of the multi-core system.","The aggregator and\/or each packet engine may create, maintain and\/or manage a mapping of device names (e.g., local device names) or identifiers to global device identifiers in the shared memory. Each core or packet engine may assign a local device name or identifier to each device associated with the core or packet engine, for example, virtual servers executing on the core. The local device name of an entity or device may be unique within a core. The local device name may not be unique between cores. The aggregator may use the mapping to determine a global device identifier corresponding to a local device name referenced in or identified with a data stream received from a packet engine. The aggregator may, for example, parse or extract such a local device name from the data stream.","In some embodiments, a packet engine or other device writes or transfers a data or performance stream into the shared memory. The aggregator, via an assigned thread or otherwise, may receive, poll or transfer a data stream from the shared memory, according to a schedule or predetermined interval for example. The packet engine may write a data stream from one or more devices associated with a packet engine or core. The core or packet engine may provide, assign or reference a device name (e.g., local device identifier) associated with each data stream. The core or packet engine may dump or transfer a data stream, or part thereof, to the shared memory according to a schedule or predetermined interval. In certain embodiments, the core or packet engine may provide a global device identifier associated with a data stream to the aggregator by using the device-name to global-device-identifier mapping.","In some embodiments, the aggregator determines or identifies a global device identifier for the device or entity generating the data stream. The aggregator may determine a global device identifier based on a local device identifier referenced in the data stream and\/or the identity of the device or entity generating the data stream. The aggregator may associate the global device identifier with the data stream. In some embodiments, the aggregator stores the mapping and\/or global device identifiers in the shared memory. The mapping may comprise any type or form of table, database or data structure for storing and\/or organizing the global device identifiers. In further details of step , an aggregator of the multi-core system may execute a computing thread for each core of the multi-core system. An aggregator of the multi-core system may execute a computing thread on a processor or processing resource of the aggregator. In some embodiments, the aggregator executes a computing thread on a processor or processing resource assigned to the aggregator. In certain embodiments, the aggregator executes a corresponding thread in memory shared or associated with a core. The aggregator or multi-core system may provide a computing thread for each core of the multi-core system to gather data from the corresponding core. The computing thread may access shared memory to gather data or some portion of a data stream provided from a core.","The aggregator may provide a thread to operate with each active core or packet engine. The aggregator may create or execute a thread to operate with a core responsive to the core powering up, entering an active mode, or processing one or more packets. In some embodiments, the aggregator may provide a thread to operate with each entity or device of a core. A processor of the aggregator, or a processing resource assigned to the aggregator, may provide multi-threading support to handle a plurality of cores of the system. The aggregator may maintain one or more threads to handle data generated by one or more cores and\/or client requests (e.g., for performance statistics or trace data).","In certain embodiments, a block of shared memory is assigned to a corresponding thread and a packet engine or core. The aggregator may allocate or assign memory to a core that is accessible by both the core and a corresponding thread. A thread may perform polling on the shared memory to detect and receive data streams (e.g., statistics of network traffic) dumped by a respective packet engine, entity or device. In some embodiments, a packet engine, entity or device informs a respective thread that a data stream is available. The thread may identify a global device identifier for a data stream, either determined by a respective packet engine, or by translating a device number associated with the packet engine or data stream using the mapping information. In further details of step , a first computing thread of the aggregator may collect statistics of network traffic processed by one or more packet engines on a first core. A first computing thread may generate aggregated statistics from a corresponding core by parsing the gathered data from the corresponding core. The thread may parse one or more data streams from a core or packet engine for consolidation into aggregated statistics. In some embodiments, the first computing thread may buffer, interleave and\/or consolidate data streams or statistics from two or more packet engines or entities of a core. A thread may access one or more data stream dumps from the shared memory. The thread may access one or more data streams according to a schedule or predetermined interval. The thread may parse a data stream to identify one or more pieces of information. The thread may parse, sample or filter the data stream into a processed stream. The thread may extract information from a data stream to compute or determine statistics (e.g., performance and\/or trace statistics) for a device of the core. In some embodiments, a thread may be assigned to handle client requests, such as a request (e.g., stat, snmpd, show, nslcd) from a filtered request-response client. This thread may operate independently of any core or packet engine of the multi-core system. The thread may communicate with a client or agent, for example via an agent interface . In some embodiments, the thread communicates with a client or agent via a port (e.g., port ). The thread may access one or more data streams responsive to a client request. For example and in some embodiments, the thread may access a data stream (e.g., via shared memory) based on a global device number identified by a client or agent. The thread may parse, filter, extract or otherwise process a data stream to generate statistics responsive to the client request. This thread may execute and operate independent of other aggregator threads and\/or packet engines. In some embodiments, the thread may process data streams according to an adaptively-generated or adjusted schedule, which may depend on the processing speed of the thread and\/or the transfer rate of a packet engine.","In some embodiments, a thread may be assigned to handle client requests, such as a request (e.g., dashboard request) from a streaming client. The thread and\/or the aggregator may write at least a portion of a data stream into an internal buffer of the aggregator based on or responsive to the request. In some embodiments, the aggregator may generate aggregated statistics for one or more cores responsive to receiving a client request, e.g., identifying the one or more cores. For example, the aggregator may consolidate at least a portion of the statistics collected from two or more cores of the multi-core system into a buffer. In some embodiments, a data stream may be identified by a global device identifier in a client request. In certain embodiments, the thread and\/or the aggregator may parse, filter, extract and\/or process one or more identified data streams to generate statistics, e.g, aggregated statistics, for storing into the internal buffer.","A client or agent of the client may access the internal buffer for the requested information. In some embodiments, the thread buffers the requested information in the internal buffer for transmission (e.g., via a dashboard connection) to a dashboard, agent or client. In some embodiments, a client or agent may communicate to the thread that further information is no longer required or requested, or that the dashboard connection is closed. Responsive to this communication, the thread may halt aggregation and\/or writing of data into the internal buffer.","In further details of step , the first computing thread may transfer the statistics with a marker to a statistics log of the multi-core system. The marker may correspond to a global device number of the first core. The first computing thread may transfer the generated statistics to a statistics log according to a schedule. The first computing thread may write collected statistics to the statistics log according to a schedule generated and\/or maintained by the aggregator. The thread assigned to a core or packet engine may parse and\/or process one or more data streams from the core or packet engine into aggregated statistics or aggregated data streams. In some embodiments, the thread writes or stores the processed data into a logfile or storage device (e.g., residing on the appliance or another device). The thread may, in some embodiments, write or store the processed data in an internal or local buffer of the aggregator.","In certain embodiments, the thread writes or stores each data stream unchanged or substantially unchanged into the logfile or storage device. For example, the first computing thread may transfer the collected statistics unchanged to the statistics log. The thread may transfer a data stream directly from shared memory to the logfile or storage device. Each thread may store or interleave a respective data stream into the logfile or storage device accordingly to a schedule or predetermined interval. In certain embodiments, the aggregator may create an aggregated data stream from one or more data streams, for storing into the logfile or storage device.","The multi-core system may, for example via the aggregator, maintain the statistics log for two or more cores of the multi-core system. The multi-core system may separate, partition, segment the statistics log using the markers and\/or global device identifiers. The multi-core system may interleave, identify and\/or mark portions of the statistics log to record or store data from different cores or devices of the multi-core system. In some embodiments, a marker or global device identifier may mark the start of data specific to a corresponding core or device in the statistics log. In certain embodiments, a marker or global device identifier may mark the end of data specific to a corresponding core or device in the statistics log.","In some embodiments, the multi-core system provides one or more clients or their agents with access to the statistics log. The multi-core system may provide an interface, such as an applications processing interface, through which a client or agent can read or access the statistics log. In certain embodiments, the multi-core system provides the statistics log in text form. The multi-core system may provide the statistics log in any standardized format that a client can read, interpret and\/or process. The aggregator may, in some embodiments, generate and\/or send a notification to a first client of the one or more clients responsive to a transfer to the statistic log.","In further details of step , the multi-core system adaptively reschedules the transfer by monitoring the operation of each computing thread. The multi-core system may adaptively reschedule the transfer by monitoring the operation of each computing thread, core, packet engine and\/or other entity of a core. For example, the aggregator may adaptively reschedule the transfer by monitoring the operation of the first core. The aggregator or the system may adaptively modify or adjust a schedule or interval for transferring data by one or more packet engines and threads. The aggregator may determine that one or more threads are operating slower than the respective packet engines.","The aggregator may determine that the dumping schedule or interval should be adjusted to synchronize operation between one or more packet engines and threads. The aggregator may determine that the logfile size is increasing at a rate beyond a predetermined threshold. The aggregator may determine or detect a change in the creation rate or transfer rate of one or more data streams. The aggregator may determine a change in the frequency of client requests. Responsive to the determination, the aggregator may adaptively modify or adjust a schedule or interval for transferring data between one or more cores, packet engines, shared memory, threads, internal buffers and\/or logfiles.","A client or client agent may parse or extract particular portions of the statistics log using the markers or global device identifiers. For example, a client agent may extract statistics corresponding to a particular core or global device identifier for processing. In some embodiments, a client or client agent process the statistics log to generate aggregated statistics corresponding to one or more cores or global device identifiers. In some embodiments, responsive to a request from a client, an agent obtains data stored in the logfile for consolidation or aggregation at the client. In some embodiments, a client or agent may prefer or need consolidated or aggregated statistics for the multi-core system. The client or agent may access the logfile or storage device for one or more stored data streams. The client may process the one or more data streams, at the client, into aggregated data streams and\/or statistics. In some embodiments, the client or agent may access the logfile or storage device for an aggregated data stream. The client may process the aggregated data stream, at the client, into consolidated statistics.","In some embodiments, multiple client requests and\/or multiple type of client requests may occur concurrently or sequentially. A main thread of the aggregator for example, may process a request from a filtered request-response client, while another client or agent may access the logfile in connection with a nsconmsg\/nscollect request. In certain embodiments, a streaming client request (e.g., dashboard request) may be processed by providing the requested data via the internal buffer of the aggregator. The latter may be handled by another thread of the aggregator, in parallel with the other client requests. Various threads may operate independently or in a coordinated fashion (e.g., adaptively coordinated by the aggregator in sequence).","It should be understood that the systems described above may provide multiple ones of any or each of those components and these components may be provided on either a standalone machine or, in some embodiments, on multiple machines in a distributed system. In addition, the systems and methods described above may be provided as one or more computer-readable programs or executable instructions embodied on or in one or more articles of manufacture. The article of manufacture may be a floppy disk, a hard disk, a CD-ROM, a flash memory card, a PROM, a RAM, a ROM, or a magnetic tape. In general, the computer-readable programs may be implemented in any programming language, such as LISP, PERL, C, C++, C#, PROLOG, or in any byte code language such as JAVA. The software programs or executable instructions may be stored on or in one or more articles of manufacture as object code.","While the invention has been particularly shown and described with reference to specific embodiments, it should be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as disclosed herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["The foregoing and other objects, aspects, features, and advantages of the invention will become more apparent and better understood by referring to the following description taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1D"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 1E-1H"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4C"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 6D"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6E"}]},"DETDESC":[{},{}]}
