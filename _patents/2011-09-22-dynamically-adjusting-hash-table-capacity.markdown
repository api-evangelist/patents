---
title: Dynamically adjusting hash table capacity
abstract: An example hashing unit includes a plurality of hardware-based hash tables, wherein each of the hash tables comprises a plurality of buckets, and wherein the plurality of hash tables comprise a set of zero or more active hash tables and a set of one or more inactive hash tables. An example hashing unit controller is configured to receive a key value to be stored in the hashing unit, determine that one of the inactive hash tables should be activated, and, based on the determination, activate the one of the set of inactive hash tables as a recently activated hash table, determine one of the buckets of the recently activated hash table to which a hash function associated with the recently activated hash table maps the received key value, and store the key value in the determined one of the buckets of the recently activated hash table.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08938469&OS=08938469&RS=08938469
owner: Juniper Networks, Inc.
number: 08938469
owner_city: Sunnyvale
owner_country: US
publication_date: 20110922
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/485,079 and U.S. Provisional Application No. 61\/485,074 both filed May 11, 2011, the entire contents of which are incorporated by reference herein.","This disclosure relates to power management of hardware units in computing devices, such as routers.","Hash tables are generally used for providing a unique mapping between a set of input values, referred to as key values, and storage locations for corresponding output values, referred to as buckets. Hash tables are used in various contexts, such as, for example, database applications, implementing data structures such as associative arrays and sets, memory caches, networking applications, or other situations in which a unique mapping between input values and output values is desirable.","One technique for increasing the speed of hash tables is to provide a hardware-based hash table. When a hash table is implemented in hardware, the hash table draws power that may otherwise be budgeted to other hardware features of a hardware unit including the hash table. The amount of power consumed by the hardware-based hash table is approximately proportional to the silicon area covered by the hash table. Likewise, the amount of keys and buckets supported by the hardware-based hash table is also approximately proportional to the silicon area covered by the hash table. Thus, to support a large number of keys and buckets, a larger area of silicon must be devoted to the hash table, requiring a larger amount of power for the hash table. In many cases, hardware-based hash tables are implemented such that they support as large a set of values as possible to allow use in a wide range of applications, requiring a trade-off of chip area and power consumption for increased capacity.","In general, this disclosure describes techniques for dynamically adjusting the capacity of a hardware-based hash table. By adjusting the capacity of the hash table, power consumed by the hash table may be variably controlled. Inactive portions of the hash table need not be powered, and likewise, control circuitry for the inactive portions also need not be powered. Alternatively, the control circuitry may remain powered, but not actively perform calculations related to hashing. By remaining idle, the control circuitry generally utilizes less power than when actively processing data. In this manner, a hardware-based hash table in accordance with the techniques of this disclosure may provide a relative power savings when the full capacity of the hash table is not needed, yet still providing the ability to utilize a larger capacity when required.","A hardware-based hashing unit in accordance with the techniques of this disclosure includes a plurality of hardware-based hash tables. In general, each of the hash tables can be powered on or off as needed. When the hashing unit receives a new key value that cannot be stored in one of the currently active hash tables, the hashing unit activates one of the inactive hash tables and stores the new key value in the newly activated hash table. Similarly, when the hashing unit determines that the key values currently stored in a set of active hash tables could be stored effectively in a subset of the active hash tables, the hashing unit migrates the key values from at least one of the set of active hash tables to the other hash tables in the set, then disables the hash table(s) from which key values were migrated.","This disclosure provides techniques for determining when to enable an inactive hash table as well as when to deactivate an active hash table, and techniques for migrating key values from an active hash table to a subset of other active hash tables. In this manner, this disclosure provides techniques for dynamically adjusting the capacity of a hardware-based hash table that may conserve power as well as provide a relatively large capacity for key values.","In one example, a method includes receiving, by a hashing unit controller executed by a processing unit, a key value to be stored in a hashing unit comprising a plurality of hardware-based hash tables, wherein each of the hash tables comprises a plurality of buckets, and wherein the plurality of hash tables comprise a set of zero or more active hash tables and a set of one or more inactive hash tables, determining that one of the inactive hash tables should be activated to increase an available hash space of the hashing unit, wherein the available hash space comprises the buckets of the active hash tables, and, based on the determination, activating the one of the set of inactive hash tables as a recently activated hash table, determining one of the buckets of the recently activated hash table to which a hash function associated with the recently activated hash table maps the received key value, and storing the key value in the determined one of the buckets of the recently activated hash table.","In another example, a method includes receiving, by a routing device, information defining a route to a network destination comprising a destination address, determining a network interface of the routing device coupled to a next hop along the route to the network destination, sending data comprising the destination address and an indication of the network interface to a hashing unit controller executed by a processing unit of the routing device to be stored by a hashing unit of the routing device, wherein the hashing unit comprises a plurality of hardware-based hash tables, wherein each of the hash tables comprises a plurality of buckets, and wherein the plurality of hash tables comprise a set of zero or more active hash tables and a set of one or more inactive hash tables, determining that one of the inactive hash tables should be activated to increase an available hash space of the hashing unit, wherein the available hash space comprises the buckets of the active hash tables, and, based on the determination, activating the one of the set of inactive hash tables as a recently activated hash table, determining one of the buckets of the recently activated hash table to which a hash function associated with the recently activated hash table maps the received destination address, and storing the data comprising the destination address and the indication of the network interface in the determined one of the buckets of the recently activated hash table.","In another example, a device includes a hashing unit comprising a plurality of hardware-based hash tables, wherein each of the hash tables comprises a plurality of buckets, and wherein the plurality of hash tables comprise a set of zero or more active hash tables and a set of one or more inactive hash tables, a computer-readable storage medium comprising instructions for a hashing unit controller for the hashing unit, and a processing unit configured to execute the hashing unit controller to receive a key value to be stored in the hashing unit, determine that one of the inactive hash tables should be activated to increase an available hash space of the hashing unit, wherein the available hash space comprises the buckets of the active hash tables, and, based on the determination, activate the one of the set of inactive hash tables as a recently activated hash table, determine one of the buckets of the recently activated hash table to which a hash function associated with the recently activated hash table maps the received key value, and store the key value in the determined one of the buckets of the recently activated hash table.","In another example, a routing device includes a plurality of network interfaces, a hashing unit comprising a plurality of hardware-based hash tables, wherein each of the hash tables comprises a plurality of buckets, and wherein the plurality of hash tables comprise a set of zero or more active hash tables and a set of one or more inactive hash tables, a routing engine configured to receive information defining a route to a network destination comprising a destination address, and a forwarding engine configured to generate data that associates one of the network interfaces of the routing device coupled to a next hop along the route to the network destination with the destination address, and to store the data to the hashing unit via a hashing unit controller, wherein the hashing unit controller is configured to determine that one of the inactive hash tables should be activated to increase an available hash space of the hashing unit, wherein the available hash space comprises the buckets of the active hash tables, and, based on the determination, to activate the one of the set of inactive hash tables as a recently activated hash table, determine one of the buckets of the recently activated hash table to which a hash function associated with the recently activated hash table maps the received destination address, and store the data comprising the destination address and the indication of the network interface in the determined one of the buckets of the recently activated hash table.","In another example, a computer-readable storage medium includes instructions that, when executed, cause a processor to receive a key value to be stored in a hashing unit comprising a plurality of hardware-based hash tables, wherein each of the hash tables comprises a plurality of buckets, and wherein the plurality of hash tables comprise a set of zero or more active hash tables and a set of one or more inactive hash tables, determine that one of the inactive hash tables should be activated to increase an available hash space of the hashing unit, wherein the available hash space comprises the buckets of the active hash tables, and, based on the determination, activate the one of the set of inactive hash tables as a recently activated hash table, determine one of the buckets of the recently activated hash table to which a hash function associated with the recently activated hash table maps the received key value, and store the key value in the determined one of the buckets of the recently activated hash table.","The techniques of this disclosure may provide several advantages. For example, a hashing unit in accordance with this disclosure provides a relatively high capacity for key value storage. Additionally, the hashing unit provides a relative power savings over hash tables having a similar capacity, in that individual hash tables of the hashing unit of this disclosure can be powered on or off. In this manner, the hashing unit provides flexible configurability. A software-based controller can programmatically enable and disable individual hash tables within a set of hash tables of the hashing unit to provide sufficient capacity for key values of a particular application or environment while managing power consumption. In this manner, the power consumed by the hashing unit of this disclosure is roughly proportional to the size of the set of key values stored by the hashing unit rather than fixed at the maximum capacity of the hashing unit. Therefore, power consumption can be adjusted according to an application's requirements for hash storage capacity (also referred to in this disclosure as a hash space). In addition to reducing power consumption, when other data structures are stored in the same physical memory as a disabled hash table, these techniques may also reduce memory bandwidth and contention with other operations.","The details of one or more examples are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description and drawings, and from the claims.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1","FIG. 1"],"b":["2","14","16","10","10","12","12","12","2"]},"Client device , in this example, represents a device that submits requests for services to server device . Server device , likewise, represents an example of a device that provides services to client device  in response to requests. Client device  and server device  may also participate in a bidirectional communication session, in which server device  requests services from client device , and client device  provides the requested services to server device . In this manner, client device  and server device  can each act as both a server and a client. Client device  may represent an endpoint device, such as a mobile device (e.g., a laptop computer, tablet computer, or cellular phone), a personal computer, a computing terminal, an Internet-capable television or device for providing Internet-based television services, or other such devices. Server device  may represent a web server, a file server, a peer device (e.g., another user's computing device), a database server, a print server, or other device from which a client device requests services.","Client device  submits requests to server device  via network . In particular, in this example, client device  is communicatively coupled to router A. In other examples, client device  may be communicatively coupled to router A via additional network devices, such as access lines, wireless infrastructure and backhaul networks, and the like. Routers  of network  are configured to determine routes through network  to reach various destinations, such as server device . Routers  implement routing protocols to determine routes through network , as well as to share determined routes with other routers . In the example of , router A determines that two routes exist to reach server device . A first route beginning at router A to reach server device  includes router B, router E, and server . A second route beginning at router A to reach server device  includes router C, router D, router E, and server . In general, router A includes a control plane that executes routing protocols to learn the topology of network  and to select one of these routes over the other. Upon receiving a packet of data from client device  destined for server device , a data plane of router A performs a lookup function on keying information within the packet and forwards the data along the selected route.","In some examples, router A stores routing information for known routes in one or more routing tables or other data structures, also referred to as a routing information base (RIB). The control plane of router A generates forwarding information based on the routing tables in the form of one or more forwarding tables or other data structures, also referred to as a forwarding information base (FIB), and programs the data plane in accordance with the forwarding information. The FIB stores network addresses or other keying information (e.g., MPLS labels) and maps the keying information with particular logical or physical network interfaces of router A. Upon receiving a packet of data from client device , router A can determine a network interface through which to send the packet based on the keying information of the packet such that the packet ultimately reaches, for example, a destination address specified in the packet. In one example, the data plane of router A includes a packet forwarding engine having dedicated application-specific integrated circuits that are programmed in accordance with the FIB for forwarding network traffic.","In some examples, the forwarding engine implements a longest prefix match algorithm when forwarding an individual packet to identify an entry of the FIB that best matches the destination address of the packet. For example, the FIB typically stores network addresses in the form of network prefixes that are reachable through other routers within the network. As one example, router A may not necessarily learn the specific network address of individual server device  (e.g., 10.1.1.101), but instead may learn that a network prefix (i.e., a range of addresses) are reachable through router E (e.g., network prefix 10.1\/16). In general, the forwarding engine of router A uses the longest prefix match algorithm to determine the entry in the FIB having the longest prefix that matches the destination address of a received packet. Router A forwards the received packet through the network interface specified in the entry of the FIB identified as storing the longest matching prefix that is satisfied by the destination address of the received packet.","In one example, the hashing unit supports prefix lengths (which act as key values in the hashing unit) from \/0 to \/128. Prefixes with lengths from \/0 to \/64, in some examples, consume a single cell of a bucket of the hashing unit, while prefixes with prefix lengths from \/65 to \/128 consume two consecutive cells, referred to as a double cell, in the hashing unit. Hash tables of the hashing unit, in some examples, physically support 64K single cells, with two cells per bucket. In some examples, if all prefixes are of single cells, each hash table can support loads of approximately 80% to 90% (e.g., 51,000 to 57,600 entries). In some examples, if all prefixes are of double cells, each hash table of the hashing unit can support loads of approximately 40% to 45% (e.g., 28,800 entries). In some examples, the hashing unit includes a stash in addition to a plurality of hardware-based hash tables. In some examples, the stash includes four buckets with two cells in each bucket, for a total of eight single cells. Likewise, the stash can store four double cells in these examples. The physical hash tables of a hashing unit may be referred to as key hash tables or KHTs. In some examples, each KHT has a capacity of approximately 16K cells and associated results, which for four KHTs would provide approximately 64K cells total.","In accordance with the techniques if this disclosure, the FIB of router A is stored in a hashing unit having a plurality of physical (that is, hardware-based) hash tables. In accordance with the techniques of this disclosure, the hashing unit is able to activate or deactivate individual hash tables. In this manner, router A is able to dynamically increase or decrease the number of active hash tables, in order to increase or decrease a hash space for the hashing unit. The hash space generally corresponds to the number of entries that can be stored in the hashing unit. Accordingly, router A can determine whether additional storage space is needed, e.g., to increase the number of entries stored in the FIB, and if so, activate an inactive hash table. Similarly, router A can also determine whether to deactivate an active hash table, e.g., when the FIB does not need to store as many entries.","The number of physical hash tables provided by the hashing unit may be large enough to store a relatively large FIB. A FIB may typically vary between several thousand and several hundred thousand entries, and therefore, the hashing unit may provide a hash space capable of storing several hundred thousand entries, with the flexibility to decrease the available storage capacity to several thousand or tens of thousands of entries. For example, a hashing unit may include four hash tables, each capable of storing approximately 16K cells. When less than the full storage capacity is needed, one or more of the hash tables can be powered off. In this manner, the power consumed by the hash tables of the hashing unit may vary according to the number of entries needed to be stored. In general, the hash tables need not be capable of storing the same amount of entries, although in some examples, the hash tables may be capable of storing approximately equal numbers of entries.","More particularly, the hashing unit provides a hash function for each of the hash tables. The hash function receives a value, referred to as a key value, and outputs a value for a \u201cbucket,\u201d that is, an entry in the corresponding hash table. In some examples, the value corresponds to a memory address for the bucket in the hash table. Each bucket stores one or more cells. Therefore, the number of entries that can be stored in a particular hash table is equal to C*B, where B is an integer value representing the number of buckets in the hash table, while C is an integer value representing the number of cells in each bucket (assuming that the number of cells in each bucket is equal, and that an entry uses one cell for storage). Moreover, if each hash table of the hashing unit has an equal number of buckets and cells, the number of entries that can be stored by the hashing unit is H*C*B, where H is an integer value representing the number of hash tables in the hashing unit. In one example, H=4, B=8192, and C=2, such that the hashing unit can store 65,536 key value entries. Because the hash function for a hash table provides a direct mapping to a bucket of the hash table, the time to discover a cell storing a particular key value is O(H*C), where O(x) refers to big-oh timing function notation. In other examples, all cells are searched concurrently, which may allow discovery of an appropriate cell in approximately constant time.","When adding a value to the hash table, the hashing unit stores the key value and an associated value in one of the cells of the bucket mapped to the key value. For example, with respect to the FIB of router A, destination addresses (prefixes) act as key values, while associated values correspond to identifiers of network interfaces. Accordingly, router A stores a destination address or prefix and an associated identifier of a network interface in a cell of a bucket to which a hash function maps the destination address. By storing the destination address or prefix in the cell, if two or more destination addresses are mapped to the same bucket, router A can determine which of the cells stores the identifier of the network interface associated with a particular destination address.","As noted above, router A is capable of dynamically increasing or decreasing the hash space by activating or deactivating the hash tables. Therefore, the hashing unit includes a set of active hash tables and a set of inactive hash tables. Letting integer A represent the number of active hash tables and integer N represent the number of inactive hash tables, the size of the sets of active and inactive hash tables can be expressed as (0\u2266A, N\u2266H) such that A+N=H, where H again represents the number of hash tables in the hashing unit.","Accordingly, router A at times determines that one of the set of inactive hash tables should be activated in order to increase an available hash space. This determination can be based on a variety of factors. In some examples, router A makes the determination based on the number of entries currently stored in the hash space exceeding a threshold. In some examples, router A makes the determination when adding a new key value to the hashing unit results in collisions with all cells of all buckets to which the new key value is mapped (i.e., no unused cell is available in any of the candidate buckets in the set of hash tables that are currently active). In any case, when router A determines that one of the inactive hash tables should be activated, router A can activate an inactive hash table to increase the available hash space. Router A then stores the new key value in the recently activated hash table.","In this manner, the hashing unit of router A provides the capability to store a relatively large number of key values, while providing flexibility in the number of physical components that are active at a given time. Router A need not provide power to some or all components associated with the inactive hash tables (such as, for example, hashing logic circuitry and\/or physical storage units for storing key values). Therefore, the hashing unit of router A can have a large potential storage capacity, yet reduce power consumption when less than the full storage capacity is needed.","Though described primarily with respect to router A, it should be understood that the techniques of this disclosure may be implemented by any of routers , client device , server device , or any other computing device that would implement hashing functionality. Moreover, the hashing unit of this disclosure may be applied to other contexts and for other uses. For example, routers  may additionally or alternatively include one or more hashing units for implementing a Bloom filter. One example implementation of Bloom filters in network devices using hash tables is described in U.S. patent application Ser. No. 12\/425,517, entitled \u201cDYNAMIC LINK LOAD BALANCING,\u201d by Arun Kumar S P et al., filed Apr. 17, 2009, which is hereby incorporated by reference in its entirety.","In some examples, router A includes multiple hashing units to implement a Bloom filter. A Bloom filter is generally a data structure for storing an indication of whether a particular value has been stored (or been previously processed). The Bloom filter data structure is generally designed such that false negatives are avoided, while leaving open the (albeit small) possibility of false positives. That is, a well-designed Bloom filter can provide an indication of whether a particular value has not been stored, but in some cases may provide an incorrect indication that the value has been stored (when in fact, the value has not been stored).","In examples where router A includes a Bloom filter (which may be implemented using hashing units), when router A stores a key value in, e.g., the FIB, router A adds the key value to the Bloom filter. In general, when a Bloom filter is queried with a particular value, the Bloom filter provides an indication of whether the value is stored in the Bloom filter. While false positives are possible when using a Bloom filter, false negatives are typically not possible, due to the design of the Bloom filter. Therefore, upon receiving a key value comprising a destination address for a packet, router A first determines whether the key value is stored in the Bloom filter, and if so, determines whether the key value is actually available in forwarding information. Additional details regarding the use of Bloom filters to determine whether a key value is available in forwarding information is described in co-pending U.S. patent application entitled \u201cDYNAMIC BYPASS MECHANISM TO ALLEVIATE BLOOM FILTER BANK CONTENTION,\u201d by Keen et al., filed Sep. 22, 2011, which is hereby incorporated by reference in its entirety.","Routers , in some examples, use hashing units to perform packet filtering, in addition or in the alternative to the use of hashing units to implement Bloom filters. In some examples, filters specify one or more conditions and a set of actions to be performed on packets that match the conditions. In various examples, the conditions specify one or more of a source Internet protocol (IP) address, a destination IP address, a source port, a destination port, a protocol, and\/or other fields of a packet. Accordingly, a hashing unit in accordance with the techniques of this disclosure can be used to recognize any or all of the elements of a condition, e.g., the source IP address, destination IP address, source port, destination port, protocol, or other fields of a packet. The actions to perform when the hashing unit indicates that a packet satisfies the condition of a filter may include one or more of appending a label to the packet (for multiprotocol label switching (MPLS) to tunnel the packet), removing or swapping a label on the packet, inspecting the packet for viruses, performing deep packet inspection on the packet, performing quality of service processing on the packet (e.g., prioritizing the packet over other packets), blocking or dropping the packet (e.g., when the source or destination associated with the packet have been determined to be malicious) or other services.","Client device  and server device  may also include hashing units in accordance with the techniques of this disclosure. In some examples, server device  comprises a database server that uses a hashing unit to map input keys into storage locations. In some examples, client device  comprises a cellular phone that uses a hashing unit to store a contact list (e.g., including names, telephone numbers, e-mail addresses, or other information for contacts in the contact list). These and other computing devices may also use the hashing unit of this disclosure to provide hashing functionality having a dynamically adjustable capacity in order to reduce power consumption by physical hash tables.","The techniques of this disclosure may provide several advantages. For example, a hashing unit in accordance with this disclosure provides a relatively high capacity for key value storage. Additionally, the hashing unit provides a relative power savings over hash tables having a similar capacity, in that individual hash tables of the hashing unit of this disclosure can be powered on or off. In this manner, the hashing unit provides flexible configurability. A software-based controller can enable a set of hash tables of the hashing unit to provide sufficient capacity for key values of a particular application and disable the other hash tables. In this manner, the power consumed by the hashing unit of this disclosure is roughly proportional to the size of the set of key values stored by the hashing unit. Therefore, power consumption can be adjusted according to an application's requirements for hash storage capacity (also referred to in this disclosure as a hash space). In addition to reducing power consumption, when other data structures are stored in the same physical memory as a disabled hash table, these techniques may also reduce memory bandwidth and contention with other operations.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 2","FIG. 1","FIG. 1","FIG. 2"],"b":["20","50","20","12","12","20","22","22","22","28","30","30","32","40","32","38","34","50","66","66","66","40","42","44"]},"In other examples, RE  executes software that conforms substantially to the functionality of hashing unit controller , e.g., to add entries to and\/or remove entries from hashing unit , as explained below. In general, hashing unit controller  may be implemented as hardware or software, or a combination thereof. When implemented as software, control unit  also provides requisite hardware for storing and executing the software, such as memory and one or more processing units. As stated above, in some examples, routing engine  executes software instructions for performing all or a portion of the functionality of hashing unit controller .","IFCs  receive data via respective inbound links A-N (inbound links ) and send data via outbound links A-N (outbound links ). Inbound links  and outbound links  in some examples for common IFCs form common, physical communication media for the IFCs, which operate in full duplex mode. That is, in some examples, each of IFCs  are coupled to respective communication media that can send and receive data substantially simultaneously. In other examples, inbound links  and outbound links  form separate physical media for respective IFCs .","Control unit  includes processing hardware and, in some examples, software and\/or firmware executed by the processing hardware. In various examples, control unit  and the various elements thereof, e.g., PFE  and RE , are implemented in one or more processors, processing units, digital signal processors (DSPs), application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), or any combination thereof. When implemented in software or firmware, control unit  includes one or more processors or processing units for executing instructions for the software or firmware, as well as a computer-readable storage medium for storing the instructions. In some examples, elements of PFE  and RE  are implemented in discrete units or modules, while in other examples, PFE  and RE  are functionally integrated.","RE  includes instructions for one or more routing protocols . Routing protocols  include any or all of interior gateway routing protocols such as open shortest path first (OSPF), intermediate system to intermediate system (IS-IS), routing information protocol (RIP), interior gateway routing protocol (IGRP), enhanced IGRP (EIGRP), and\/or exterior gateway routing protocols, such as border gateway protocol (BGP). In general, interior gateway routing protocols are used to exchange routing information between routers of an autonomous system. When network  () forms an autonomous system, routers  exchange routing information according to an interior gateway routing protocol. Routers at the edge of an autonomous system, such as routers A and E () exchange routing information with routers of other autonomous systems (not shown) in accordance with exterior gateway routing protocols.","In general, RE  executes routing protocols  to collect routing information and select routes from router  to other network devices. That is, RE  provides an operating environment for one or more routing protocols that exchange messages to communicate routes and\/or link information. When router  receives a communication from another router, RE  receives the communication and stores the information in routing information  (also referred to as a routing information base). RE  then performs path selection to select a path from router  to each destination or prefix.","The selected route to reach the destination generally includes an indication of a \u201cnext hop\u201d along the route to reach the destination. This next hop typically corresponds to a network device, such as, for example, another router, switch, gateway, or other network device along the route to reach the destination. The next hop device is connected to router  via one of IFCs . Accordingly, using the selected route to reach a destination, control unit  can determine the one of IFCs  connected to the next hop along the route to the destination and update forwarding information stored by PFE  to indicate the one of IFCs  to which to send packets destined for the destination.","More specifically, PFE  maintains forwarding information base (FIB) . Then, in response to receiving information from routing engine , PFE  updates FIB  to map a destination address (typically a network prefix) to a logical or physical interface associated with one of IFCs  based on the next hop along the route to reach the destination address. In accordance with the techniques of this disclosure, PFE  stores FIB  in hashing unit , which includes one or more hardware-implemented hash tables . More particularly, next hop data for FIB , which may take the form of one or more radix trees, is stored in an available hash space of hashing unit  for high-speed access. A set of hash tables  are active at a given time, such that the storage space provided by the set of active hash tables forms the hash space of hashing unit .","Hashing unit controller  activates and deactivates hash tables  as necessary, e.g., based on the particular network environment and the number of FIB entries, to balance efficient storage of key values among hash tables  while also reducing the amount of power needed to operate hash tables . Hashing unit controller  determines whether an inactive one of hash tables  should be activated and whether an active one of hash tables  should be deactivated. In some examples, hashing unit controller  includes configuration data describing a threshold for an available hash space. For example, the threshold may correspond to a percentage of the available hash space currently in use.","The available hash space corresponds to the number of entries that can be stored by the active hash tables, while the available hash space currently in use corresponds to the number of entries actually stored in the available hash space. In some examples, when hashing unit controller  determines that the actual percentage of the available hash space in use exceeds the threshold, hashing unit controller  determines that an inactive one of hash tables  should be activated to increase the available hash space. In some examples, when hashing unit controller  receives a value that cannot be stored in the active hash tables, e.g., due to collisions, hashing unit controller  determines that an inactive one of hash tables  should be activated to increase the available hash space.","Accordingly, when PFE  receives an indication of a next hop to reach a network destination, PFE  stores an identifier for the network destination (e.g., an IP address of the network destination), along with an identifier for the one of IFCs  coupled to the next hop, to hashing unit . In some examples, hashing unit controller  provides an application programming interface (API) for PFE  and\/or routing engine  to add data to, remove data from, and query data of hashing unit . In this manner, PFE  and\/or routing engine  can add a new destination address, and an identifier for the corresponding one of IFCs , to FIB , stored in hashing unit . In some examples, PFE  sends the destination address and IFC identifier to hashing unit controller , which treats the destination address as a key value to be stored in an active one of hash tables . In some examples, hashing unit  provides both hardware and software interfaces for either or both of PFE  and routing engine . In one example, management software executing on routing engine  adds entries to and removes entries from hashing unit , while hardware elements of control unit  perform lookup operations within hashing unit .","In some examples, software executed by routing engine  adds keys to hashing unit  and\/or removes keys from hashing unit . With respect to the example of , hashing unit controller  determines whether the new key value can be stored in a currently active one of hash tables . For example, hashing unit controller  determines whether hashing functions for active ones of hash tables  map the new key value to a bucket including an empty cell. If there exists at least one empty cell of a bucket of one of an active one of hash tables  to which the hash functions map the key value, hashing unit controller  stores the key value, and corresponding IFC identifier, to the empty cell. On the other hand, if none of the active hash tables can store the new key value, hashing unit controller  activates an inactive hash table and stores the new key value and corresponding IFC identifier to a cell of a bucket to which a hash function for the recently activated hash table maps the key value.","In this manner, when one of IFCs  receives a packet, the one of IFCs  passes the packet to PFE . PFE  performs a lookup by querying hashing unit  using hashing unit controller  with a destination address or other keying information (e.g, MPLS header or VLAN tag) of the received packet, assuming that the destination address is an address other than the address of router . Hashing unit controller  sends the destination address as a key value to hashing unit  to determine a cell of a bucket of an active one of hash tables  and to return a next hop identifier for a physical or logical output interface to which to send the received packet. In some examples, PFE  executes longest prefix match algorithm  using the destination address of the packet and the entries of active hash tables of hashing unit . Accordingly, the one of output interfaces to which PFE  sends the packet may correspond to the interface associated with the longest prefix match for the specific destination address of the received packet.","In some examples, PFE  additionally stores a prefix length table. The prefix length table stores all different prefix lengths (corresponding to prefixes of network addresses and network address masks) that are stored in hashing unit . That is, the prefix length table stores a set of prefix lengths for a longest prefix match key. The prefix length indicates the number of upper bits of a mask-able key that should be used in comparison with a hash table prefix. As an example, a prefix length of \/128 means that all 128 bits of a mask-able key should be used in comparison with a hash table prefix. A prefix length of \/64 means that the upper 64 bits of a mask-able key should be used in comparison with a hash table prefix.","When present, the prefix length table is used for keys that require a longest prefix match. The prefix length table data structure can be stored in a random access memory, such as static random access memory (SRAM). In some examples, the prefix length table includes 4K entries.","At times, RE  determines that a route is either no longer available or is no longer the best route to reach a destination address. For example, RE  may determine that a link or a device along a selected route has failed, or that a new route has been discovered that is determined to be better for reaching a destination than a previously selected route. In any case, RE  may send information to PFE  to cause PFE  to remove data from FIB . In some examples, hashing unit controller  determines that hashing unit  is storing less than a threshold amount (or percentage) of data, prompting hashing unit controller  to attempt to disable one or more of the active hash tables of hashing unit . The threshold for disabling an active hash table may be different than the threshold for activating an inactive hash table.","Prior to disabling an active hash table, hashing unit controller  determines whether disabling the active hash table is feasible. In particular, hashing unit controller  determines whether all of the entries of at least one hash table to be disabled can be migrated to the remaining hash tables. If so, hashing unit controller  transfers all of the entries stored by the active hash table to the remaining hash tables, then disables the active hash table.","In some examples, FIB  maps a destination address (and\/or a source address) to one or more of service cards . For example, FIB  may map a source domain and\/or a destination domain to one of service cards  that performs virus detection or other malware detection services. As another example, FIB  may map a source and\/or destination address to one of service cards  that performs a tunneling service, such as appending or swapping a label associated with a tunnel to the packet. Accordingly, PFE  in some examples filters fields of a received packet to determine one or more services to apply to the packet prior to forwarding the packet. After receiving the packet from service cards  (after services have completed), PFE  determines the one of IFCs  to which to send the serviced packet, based on data of FIB .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 3","FIG. 2","FIG. 3","FIG. 2","FIG. 2","FIG. 3","FIG. 2"],"b":["50","20","50","52","54","56","68","60","60","60","60","62","62","62","64","64","64","66","34","32","40","34","32"]},"in the example of , sub-hashing unit A includes power gate A, hashing logic A, and hash table A. Hashing logic A represents a circuit for executing a hash function for sub-hash unit A. Hash functions for each of sub-hash units  are generally unique, such that, for a given key value, each of the hash functions for sub-hash units  map the key value to a different bucket within the hash table of the corresponding sub-hash unit. Hashing logic A may be implemented as dedicated hardware for the hash function, or as software executed by a hardware-based processing unit.","In one example, hash table A is stored in random access memory (RAM), such as static RAM (SRAM) or dynamic RAM (DRAM). In some examples, each of hash tables  is stored in a respective memory range of a RAM module. In such examples, power gate A can turn off power to hashing logic A to disable hash table A. In other examples, each of hash tables  is stored in a different RAM module, such that power gate A can turn off power to the RAM module for hash table A when hash table A is disabled. Hashing logic A maps key values to memory addresses within the RAM module (or portion thereof) for hash table A. Other power gates , hashing logics , and hash tables  conform substantially to power gate A, hashing logic A, and hash table A, respectively.","In this manner, power gates  for sub-hashing units  can activate hash tables  by powering on hashing logic circuitry for hash tables  and\/or storage media for hash tables . Likewise, power gates  for sub-hashing units  can deactivate (or disable) hash tables by powering off hashing logic circuitry for hash tables  and\/or storage media for hash tables . Accordingly, logic circuitry and\/or memory modules for inactive hash tables do not draw power when hashing unit  is performing operations for active hash tables.","Hash tables  generally represent a collection of separate, physical (that is, hardware-based) hash tables that maintain a set of key values. In the example of , the key values correspond to network addresses (or network masks). In other examples, however, the key values correspond to other unique identifiers that can act as input to hash functions. Contents of active ones of hash tables  constitute an entire set of data stored by hashing unit , while the available storage space of the active hash tables constitutes an available hash space. Any particular key value can reside in any of the active hash tables. In accordance with the techniques of this disclosure, hashing unit controller  can enable any or all of sub-hashing units , such that the enabled sub-hashing units provide sufficient capacity for a set of key values to be maintained. Likewise, hashing unit controller  can disable other sub-hashing units  not needed to store the set of key values to be maintained.","Because the disabled sub-hashing units do not need to perform operations associated with hashing (e.g., searching for a key value used to query hashing unit ), respective hashing logics  of disabled sub-hashing units can be powered off by power controller  via respective power gates , at the direction of hashing unit controller . In some examples, memory modules for hash tables  can also be powered off by power controller  via respective power gates , at the direction of hashing unit controller . In this manner, hashing unit  consumes less power than a single, physical hash table that has the combined storage capacity of hash tables . Likewise, hashing unit  provides a higher storage capacity than a single hash table the size of one of hash tables , in that any or all of hash tables  can be activated.","Alternatively, logical gates can prevent certain ones of hashing logics  and hash tables  from operating when a respective one of sub-hashing units  is disabled. Thus, although the respective hashing logic  and hash table  may remain powered, they may avoid drawing power by not processing data when disabled.","Key manager  stores key values to hash tables , deletes key values from hash tables , queries hash tables  using a key value to retrieve data associated with the key value, and migrates data from a hash table to be deactivated to remaining, active hash tables. In some examples, e.g., when all of hash tables  are currently active yet a new key value cannot be stored in any of hash tables , key manager  stores the new key value to stash . Stash  generally corresponds to a portion of memory separate from that for hash tables . In general, key manager  stores key values for which there exist unresolvable collisions to stash . The size of stash  typically remains fixed, and key manager  searches all cells in stash  for a key value (or empty cell to add a key value), rather than using a hash function. In other words, an entry for any key value can be placed in any cell in stash , without the use of a hash function. In some examples, when stash  is unused (e.g., no data is stored to stash ), power controller  disables power to stash .","In the example of , key values correspond to destination network addresses (or prefixes thereof, in some examples). Cells of hash tables  currently storing key values generally store the key values mapped to the cells, as well as information indicative of an output interface (e.g., one of IFCs ) through which packets destined for the destination address are to be sent. In some examples, each cell stores 128 bits of data, where the first 64 bits correspond to a mask entry corresponding to a mask key value, the next 24 bits store a non-mask entry corresponding to a constant portion of a key value that are not masked by a prefix length, the next 8 bits store a prefix length value that represents the prefix length associated with the mask key value, and the remaining 32 bits store an explicit result that is passed when a key value matches the entry. Table 1 below provides an example arrangement of data in a cell of hash tables .",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field Name","Field Size ","Field Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Mask-entry","64","A cell has up to 64 bits of mask key."]},{"entry":["Non-mask","Parameter","This is the constant part of the key which is "]},{"entry":["entry",{},"not masked by the prefix length."]},{"entry":["Prefix Length","8","This field stores the prefix length associated "]},{"entry":[{},{},"with the mask key."]},{"entry":["Explicit Result","Parameter","This field stores the explicit result that is "]},{"entry":[{},{},"passed if the key matches to this entry."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In some examples, buckets of hash tables  include two cells, cell 0 and cell 1. Hashing unit controller  sends commands to key manager  to manage data for cells of hash tables  to indicate whether the cells contain valid or invalid data. In some examples, hashing unit controller  causes key manager  to store data as a double cell, that is, data that forms a single logical unit but that occupies two cells, which may be two cells in the same bucket or cells of different buckets. In some examples, hashing unit controller  causes key manager  to manage cells of buckets of hash tables  such that each bucket having two cells has one of the following states:\n\n","In some cases, it is possible that the same cell exists in more than one of hash tables , e.g., due to cell replacement. Hashing unit controller  is configured to monitor data of hash tables  such that this is a temporary state of hash tables . In this manner, hashing unit controller  ensures that a cell exists at one location only in a final (stable) state of hash tables . When multiple copies of a cell are stored in hash tables , key manager  can choose results from any copy of the cell. Accordingly, hashing unit controller  is configured to ensure that if a cell exists at more than one location in hash tables , all locations have the same result.","Interface  receives various commands from hashing unit controller . For example, interface  receives commands to determine whether a key value can be added to an active hash table, add a key value to hashing unit , delete a key value from hashing unit , provide data associated with a key value as stored by hashing unit , activate an inactive one of hash tables , and\/or disable an active one of hash tables . In response to commands to activate or deactivate ones of hash tables , interface  provides a signal to power controller  to activate or deactivate sub-hashing units . In response to commands regarding adding, deleting, or querying hash tables  with a particular key value, interface  provides a signal to key manager  to perform the add, delete, or query command, receives a result (if any) from key manager , and returns the received result to hashing unit controller . Hashing unit controller , in turn, provides information for the returned result to PFE .","In accordance with the techniques of this disclosure, hashing unit controller  can dynamically increase and decrease available hash space. When hashing unit controller  receives a new key value to be stored to hashing unit , but cannot easily store the new key value (e.g., due to collisions or due to the filled entries of the hash space exceeding a threshold), hashing unit controller  sends a command to power controller , via interface , to activate an inactive one of sub-hashing units . Hashing unit controller  then sends a command to key manager  to add the new key value to the recently activated one of sub-hashing units . Key manager  adds the new key value by sending the key value to hashing logic of the recently activated sub-hashing unit to determine a bucket of the hash table to which the key value is mapped by the hash function implemented by the hashing logic. Key manager  stores the key value, as well as data associated with the key value, to a cell of the bucket of the hash table. When hashing unit controller  subsequently searches hashing unit  for a key value, the search will cover all active hash tables of hashing unit .","In some examples, key values stored by hash tables  correspond to prefix lengths, that is, prefixes of network addresses. Each of hash tables , in some examples, implement Panigrahy hashing, which is a generalization of cuckoo hashing. The concept of cuckoo hashing uses two hash functions to ensure that a key can always be looked up with a maximum of two accesses in a hash table by using two different hash functions. The theory of balanced allocations says that using two hash functions instead of a single hash function should improve the load of the largest bucket in the hash table dramatically, e.g., from O(log n) to O(log log n) with high probability.","Cuckoo hashing uses a hash table with hash functions h1 and h2 and one cell per bucket. A cell is defined as a place for a (key, value) pair in the hash table. Specifically, when hashing a new key x, hashing unit controller  checks whether the bucket h1(x) is occupied. If the bucket is empty, hashing unit controller  inserts x at h1(x). If h1(x) is occupied by some other key y, hashing unit controller  may still insert x at h1(x) but displace y by relocating it to h2(y). If h2(y) is empty, hashing unit controller  inserts y at h2(y). If h2(y) is occupied by yet another key z, hashing unit controller  displaces z by relocating it to h1(z). Cuckoo hashing thus undergoes a cascade of relocations during key insertion that alternate between h1 and h2 until an empty bucket is found.","In some examples, rather using only one cell per bucket as in the original cuckoo hashing algorithm, hash tables  implement  cells per bucket. Hashing unit , in some examples, implements four hash functions, rather than two hash functions as proposed by cuckoo hashing. The insertion of keys in the hash table is framed as a \u201cbread-first-search graph algorithm\u201d or \u201crandom walk\u201d algorithm. A stash (content-addressable memory, or CAM) of 4 buckets and 2 cells per bucket, e.g., stash , is supported with the structure of hash tables , in some examples. Stash  can store 8 single cells or 4 double cells, in some examples. Stash  is organized as 4 buckets deep and 2 cells per entry, in these examples. The prefixes with prefix length \/0 to \/64 occupy a single cell in stash . The prefixes with prefix length \/65 to \/128 take two cells within one bucket in stash . Stash 's cell format may be same as the cell format of hash tables . Stash  may help in rare \u201ckey insertion\u201d failure due to a cycle in hash tables , in some examples.","In some examples, during key lookup, the key value is compared to up to 8 cells of hash tables  (assuming four hash tables  and two cells per bucket in each of the hash tables) and 8 cells in stash . If the key matches with one of the cells of hash tables  or a cell of stash , the corresponding result is sent with the \u201cmatch\u201d bit set to hashing unit controller . In some examples, one key can exist at multiple places (different hash tables or stash) at the same time, e.g., due to the cell replacement nature of cuckoo hashing.","While  provides an example implementation of hashing unit  in router , it should be understood that other devices can also implement a hashing unit similar to hashing unit  in accordance with the techniques of this disclosure. As discussed above, physical hash tables can provide advantages in mobile devices, user endpoint devices, server devices, or in other contexts. In general, hashing unit  can be used anywhere a conventional hash table (whether implemented in hardware or software) would be used. Moreover, the techniques of this disclosure are generally applicable when power consumed by a storage unit is generally proportional to the amount of data to be stored in the storage unit.",{"@attributes":{"id":"p-0079","num":"0088"},"figref":["FIG. 4","FIG. 4"],"b":["82","82","80","82","82","82","82","82","82","82","82","82","82","80","84"]},"In the example of , hash table A includes buckets AA-AN, hash table B includes buckets BA-BN, and hash table C includes buckets CA-CN. The buckets of hash tables A-C are generally referred to as buckets . Buckets  of active hash tables A-C can be empty (e.g., invalid) or include key values. In the example of , bucket AA stores data for key value \u2018C,\u2019 bucket AD stores data for key value \u2018A,\u2019 bucket AN stores data for key value \u2018G,\u2019 bucket BB stores data for key value \u2018X,\u2019 bucket BD stores data for key value \u2018D,\u2019 bucket CB stores data for key value \u2018F,\u2019 bucket CC stores data for key value \u2018E,\u2019 and bucket CN stores data for key value \u2018B.\u2019 Buckets  without a key value are considered invalid, that is, to not store data for a key value, in this example.","As noted above, hash functions A-C are configured to produce different output values for the same input. In the example of , key value \u2018X\u2019  acts as input to each of hash functions A-C. In this example, hash function A maps key value \u2018X\u2019  to bucket AD, hash function B maps key value \u2018X\u2019  to bucket BB, and hash function C maps key value \u2018X\u2019  to bucket CN. Bucket AD, however, stores data for key value \u2018A,\u2019 including key value \u2018A\u2019 itself, while bucket CN stores data for key value \u2018B,\u2019including key value \u2018T\u2019 itself. In this manner, buckets AD and CN can be determined not to store data associated with key value \u2018X\u2019 . Bucket BB, on the other hand, stores data for key value \u2018X,\u2019 including key value \u2018X\u2019 itself. Therefore, querying each of hash tables A-C with key value \u2018X\u2019  yields the data stored in bucket BB.","In accordance with the techniques of this disclosure, hashing logic that executes hashing functions A-C can be independently powered on or off. Likewise, memory modules for hash tables A-C can be independently powered on or off. In this manner, the storage capacity (hash space) of active ones of hash tables  A-C can be dynamically adjusted, such that power consumption is generally proportional to the needed amount of storage capacity. Moreover, in this manner, separate hash functions for separate physical hash tables can be applied to the same key value, resulting in different outcomes, yet the entry data associated with the key value can be retrieved for the key value. In this manner, separate physical hash tables can form a unified, common hash space. That is, using these techniques, separate physical hash tables can contribute to a common hash storage capacity.",{"@attributes":{"id":"p-0083","num":"0092"},"figref":["FIG. 5","FIG. 3","FIGS. 2 and 3","FIG. 5"],"b":["50","20"]},"Initially, hashing unit controller  receives a new key value to be stored in hashing unit  (). With respect to the examples of , the new key value corresponds to a network destination address or network address prefix. Hashing unit controller  then determines whether the key value can be efficiently stored in active hash tables of hash tables  (). In one example, hashing unit controller  determines whether the new key value results in a collision with all cells of all buckets of all active hash tables to which the new key value is mapped. In another example, hashing unit controller  determines whether the amount of data currently stored in the active hash tables exceeds a threshold for the number of hash tables that are currently active.","When hashing unit controller  determines that the key value can be efficiently stored in one of the currently active hash tables (\u201cYES\u201d branch of ), hashing unit controller  stores data for the new key value in a currently active hash table (). In particular, hashing unit controller  stores the key value itself (e.g., a destination address) as well as data to which the key value corresponds (e.g., an indication of one of IFCs  to which to send a packet having the destination address) in one of the currently active hash tables. Hashing unit controller  causes key manager  to send the key value to hashing logics of the active hash tables to determine buckets to which the key value is mapped. Hashing unit controller  then determines an empty (invalid) cell of one of the buckets to which the key value is mapped and stores the data for the key value to the determined empty cell.","On the other hand, when hashing unit controller  determines that the key value cannot be efficiently stored in one of the currently active hash tables (\u201cNO\u201d branch of ), e.g., due to too many collisions or the amount of data stored by the active hash tables exceeding the threshold, hashing unit controller  activates an inactive hash table (). In the example of , hashing unit controller  causes power controller  to send power to the power gate for the inactive hash table. The power gate, in turn, provides power to the hashing logic circuitry and the hash table (assuming power can be independently gated to both the hashing logic circuitry and memory module storing the hash table). In other examples, such as when the hash table data is stored in a shared memory module, the power gate provides power only to the hashing logic circuitry, as the shared memory module receives power independently from the power gate.","After powering on the hashing logic circuit and\/or the memory module, hashing unit controller  stores data for the key value in the recently activated hash table (). In particular, hashing unit controller  stores the key value itself (e.g., a destination address) as well as data to which the key value corresponds (e.g., an indication of one of IFCs  to which to send a packet having the destination address) in the recently activated hash table. Hashing unit controller  causes key manager  to send the key value to hashing logic for the recently activated hash table to determine a bucket of the recently activated hash table to which the key value is mapped. Hashing unit controller  then stores the data for the key value to a cell of the bucket.",{"@attributes":{"id":"p-0088","num":"0097"},"figref":["FIG. 6","FIG. 3","FIGS. 2 and 3","FIG. 6"],"b":["50","20"]},"Initially, hashing unit controller  receives a new key value to be stored in hashing unit  (). In particular, hashing unit controller  receives the key value, as well as data associated with the key value. In the example of , the key value corresponds to a destination network address (or address prefix), and the data associated with the key value corresponds to information describing an output interface (such as one of IFCs ) to which to send packets specifying the destination network address of the key value.","After receiving the new key value, hashing unit controller  executes a hash function for a first hash table to map the key value to a first bucket (). In this manner, hashing unit controller  determines a bucket of a first hash table (e.g., hash table A) to which the new key value is mapped. For example, hashing unit controller  causes hashing logic A to execute a hash function, treating the new key value as input to the hash function executed by hashing logic A. Hashing logic A produces a result indicative of a bucket of hash table A after executing the hash function on the new key value.","In some examples, the result corresponds to an indication of a memory address of hash table A. The memory address corresponds to a memory address within a memory module storing data for each of hash tables , and in particular, within a memory space allocated to hash table A. Thus, the memory address may correspond to a global memory address within the memory module, or a relative offset from the address of the memory module corresponding to the beginning of hash table A. In other examples, in which hash table A is stored in a separate, dedicated memory module, the memory address may correspond to an actual memory address of the memory module.","Hashing unit controller  then determines whether at least one cell of the bucket is available (). That is, hashing unit controller  determines whether there is at least one cell in the bucket that is not currently storing a key value (e.g., is marked as including invalid data). If there is at least one cell of the bucket that is available (\u201cYES\u201d branch of ), hashing unit controller  stores the new key value in the bucket of the hash table (). Otherwise (\u201cNO\u201d branch of ), hashing unit controller  determines whether the previously checked active hash table is the last active hash table ().","If there is at least one active hash table remaining (\u201cNO\u201d branch of ), hashing unit controller  executes a hash function for a next hash table to map the key value to a next bucket (). In this manner, hashing unit controller  determines a bucket of a next one of the active hash tables to which the new key value is mapped. Hashing unit controller  then determines whether a cell of the determined bucket is available (). This process continues either until an available cell of a bucket to which the key value is mapped is found or until no more active hash tables are available. Although described as a sequential analysis of the active hash tables, it should be understood that in some examples, hashing logic for active hash tables execute respective hash functions in parallel (e.g., substantially simultaneously). When executed in parallel, the hashing logic also provides results for the hash functions applied to the new key value to key manager  at substantially the same time. Hardware elements of control unit  may be configured to perform substantially similar steps to those described with respect to  in parallel for each active hash table. In this manner, the hardware elements may concurrently search all active hash tables, rather than performing a sequential search.","After all active hash tables have been checked to determine whether a cell is available for a bucket to which the new key value is mapped, without discovering an available cell (\u201cYES\u201d branch of ), hashing unit controller  determines whether there is at least one inactive hash table of hashing unit  (). If there is an inactive hash table in hashing unit  (\u201cYES\u201d branch of ), hashing unit controller  activates the inactive hash table () and stores data for the new key value in a bucket of the recently activated hash table (). On the other hand, if there is not an inactive hash table, e.g., because all of the hash tables of hashing unit  were already active, hashing unit controller  would attempt to store the new key value to stash  (). For example, hashing unit controller  could store the new key value in a next available cell of stash . In cases where the stash has no empty cells available, hashing unit controller  may return an indication that the value currently cannot be stored. For example, if there is space available in the stash, hashing unit controller  may store the data for the key value, whereas if there is not space available, hashing unit controller  may return an indication of failure.","As an example, if hash table N were inactive and hashing unit controller  were to activate hash table N, hashing unit controller  would cause power controller  to enable power gate N. In turn, power gate N provides power to hashing logic N and hash table N. Then, hashing unit controller  determines a bucket of hash table N to which the new key value is mapped by causing hashing logic N to execute a corresponding hash function with the new key value as input. Hashing unit controller  could then store data for the new key value to a cell of the bucket to which the new key value is mapped.",{"@attributes":{"id":"p-0096","num":"0105"},"figref":["FIG. 7","FIG. 3","FIGS. 2 and 3","FIG. 7"],"b":["50","20"]},"Initially, hashing unit controller  determines one of the active hash tables to deactivate (). In some examples, hashing unit controller  first determines that the number of entries stored in the hash space provided by the active hash tables is below a threshold. In some examples, to determine one of the active hash tables to deactivate, hashing unit controller  determines one of the active hash tables that is currently storing the fewest key values. Hashing unit controller  also, in some examples, ensures that each entry currently stored in the hash table to be deactivated can be stored in the remaining active hash tables. In some examples, if a relatively small number of key values of the determined hash table cannot be stored in the remaining hash tables, e.g., due to collisions, hashing unit controller  stores these key values in stash .","In any case, after determining an active hash table to deactivate, hashing unit controller  extracts a first key value from the hash table chosen for deactivation (). Hashing unit controller  then determines a bucket of one of the remaining active hash tables to which the extracted key value is mapped (). That is, hashing unit controller  causes hashing logic for a first one of the active hash tables that are to remain active to execute the respective hash function using the extracted key value as input. Hashing unit controller  then determines whether there is at least one cell in the determined bucket of the first active hash table that is available to store the extracted key value ().","If a cell is not available (\u201cNO\u201d branch of ), hashing unit controller  determines a next available one of the active hash tables that are to remain active () and determines a bucket of the next active hash table to which the extracted key value is mapped (). That is, hashing unit controller  causes hashing logic of the next hash table to determine a bucket by executing the respective hash function using the extracted key value as input. This continues until either an available cell is discovered (\u201cYES\u201d branch of ) or no more active hash tables remain (not shown), in which case hashing unit controller  stores the key value to stash  (assuming that space is available in the stash).","Assuming that hashing unit controller  discovers an available cell of a bucket of one of the remaining active hash tables to which the extracted key value is mapped (\u201cYES\u201d branch of ), hashing unit controller  stores data for the extracted key value in the available cell of the bucket of the active hash table (). Hashing unit controller  then determines whether the last key value of the hash table to be deactivated has been merged into the remaining active hash tables (). If the previously extracted key value was not the last key value of the hash table to be deactivated (\u201cNO\u201d branch of ), hashing unit controller  extracts the next key value () and stores the extracted key value to one of the remaining active hash tables. However, after all key values of the hash table to be deactivated have been merged into the remaining active hash tables (or, in some examples, stash ) (\u201cYES\u201d branch of ), hashing unit controller  deactivates the hash table to be deactivated (). For example, hashing unit controller  causes the power gate for the hash table to be deactivated to stop supplying power to the hashing logic circuitry and\/or the hash table memory module for the hash table to be deactivated.","Again, it should be understood that although  illustrates a sequential example, the steps of , , , , and  may alternatively be performed substantially in parallel. That is, rather than iteratively searching each of the tables, each table may be checked in parallel (e.g., by hardware units) to find an available bucket of one of the tables having an available cell, in some examples. In some examples, when multiple buckets have available cells, hashing unit controller  may store the key value in the least loaded bucket, that is, the bucket having the fewest keys.","The techniques described in this disclosure may be implemented, at least in part, in hardware, software, firmware or any combination thereof. For example, various aspects of the described techniques may be implemented within one or more processors, including one or more microprocessors, digital signal processors (DSPs), application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), or any other equivalent integrated or discrete logic circuitry, as well as any combinations of such components. The term \u201cprocessor\u201d or \u201cprocessing circuitry\u201d may generally refer to any of the foregoing logic circuitry, alone or in combination with other logic circuitry, or any other equivalent circuitry. A control unit comprising hardware may also perform one or more of the techniques of this disclosure.","Such hardware, software, and firmware may be implemented within the same device or within separate devices to support the various operations and functions described in this disclosure. In addition, any of the described units, modules or components may be implemented together or separately as discrete but interoperable logic devices. Depiction of different features as modules or units is intended to highlight different functional aspects and does not necessarily imply that such modules or units must be realized by separate hardware or software components. Rather, functionality associated with one or more modules or units may be performed by separate hardware or software components, or integrated within common or separate hardware or software components.","The techniques described in this disclosure may also be embodied or encoded in a computer-readable medium, such as a computer-readable storage medium, containing instructions. Instructions embedded or encoded in a computer-readable medium may cause a programmable processor, or other processor, to perform the method, e.g., when the instructions are executed. Computer-readable media may include non-transitory computer-readable storage media and transient communication media. Computer readable storage media, which is tangible and non-transitory, may include random access memory (RAM), read only memory (ROM), programmable read only memory (PROM), erasable programmable read only memory (EPROM), electronically erasable programmable read only memory (EEPROM), flash memory, a hard disk, a CD-ROM, a floppy disk, a cassette, magnetic media, optical media, or other computer-readable storage media. It should be understood that the term \u201ccomputer-readable storage media\u201d refers to physical storage media, and not signals, carrier waves, or other transient media.","Various examples have been described. These and other examples are within the scope of the following claims."],"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
