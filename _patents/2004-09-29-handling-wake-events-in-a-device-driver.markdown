---
title: Handling wake events in a device driver
abstract: The present invention provides a unified layer for Plug and Play (PnP) components and power management components while relieving device drivers from system-level complexities associated with implementing PnP and/or power management functionality. The layer operates at a level between low-level device drivers and more complex operating system tasks. The subject invention simplifies designing device drivers having proper power management support by creating an infrastructure that allows a device driver to operate within a driver framework or model and without having to process Plug-and-Play or Power Management VO Request Packets (IRPs) directly.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07412609&OS=07412609&RS=07412609
owner: Microsoft Corporation
number: 07412609
owner_city: Redmond
owner_country: US
publication_date: 20040929
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation of U.S. patent application Ser. No. 10\/833,534 filed Apr. 28, 2004, entitled INTERLOCKED PLUG AND PLAY WITH POWER MANAGEMENT FOR OPERATING SYSTEMS. This application is also a continuation of U.S. patent application Ser. No. 10\/833,542 filed Apr. 28, 2004, entitled INTERLOCKED PLUG AND PLAY WITH POWER MANAGEMENT FOR OPERATING SYSTEMS, the entirety of both applications are incorporated herein by reference.","The present invention relates generally to systems and methods that facilitate power management between devices, drivers, systems, and processes. More particularly, the present invention relates to a middleware or system level layer that offloads power management decisions and processing from lower level device drivers to an operating system framework.","Some operating systems support the concepts of Plug and Play (PnP), Power Management and System Management for a plurality of different device drivers. Unfortunately, the complexity involved in implementing PnP and Power has caused thousands of device drivers to be written in a manner that may cause operating system problems (e.g., system crash). Beyond system failures, many designers of device drivers choose to simplify their drivers as much as possible, so that they do not have to complicate their designs with difficult programming problems, testing problems, and\/or verification problems. This often leads to drivers which perform Power Management in the simplest way possible, which is merely to leave the corresponding device turned on, consuming full power at all times. This consequently leads to laptop and tablet computers that consume more energy than they need to, thus causing shorter battery life than possible.","In one current operating system scenario, existing programming models do not always facilitate implementing PnP and Power management considerations in an efficient or robust manner. For example, a PnP \u201cstart\u201d event may be modeled as an implicit power-up event, even though the power manager did not send it. Similarly, PnP \u201cstop\u201d and \u201cremove\u201d events are implicit power-down events. This implies that coordination and synchronization between PnP and Power events would then be performed inside every device driver, and not merely inside PnP or Power Managers.","In another example, power management in some models may be broken into two separate concepts, system power management and device power management. Thus, the operating system (or components associated therewith) decides when the system is awake or asleep, and the individual device drivers decide when the devices should be awake or asleep. In many ways, this is desired, since it implies that device power policy can be managed by software components that have the most device domain knowledge. In many other ways, it's frustrating for a device driver designer, since it forces the designer to track system power states, responding to them by putting the device into appropriate device power states. This tracking and coordination is complex and error-prone at best.","In order to save battery power, it should be theoretically possible to turn off devices that aren't currently being used. This goal is difficult to achieve with existing models, since the device driver has to track system concepts such as general idleness, time since the device was last asked to perform a task, and so forth. Turning unused devices off can certainly save power, however many devices need to remain powered on in order that software can be aware that a human has interacted with them. A good example is a floppy disk drive. It would be desirable if the floppy were turned off when it is not being used, since it is very rarely used in many situations. The operating system can certainly turn it on before it starts writing to the floppy or reading from it. The problem arises when a user puts a new floppy into the drive. Software should typically respond by changing any windows that currently show the contents of the floppy, and updating them with the list of newly inserted files. If a \u201cdisk-change notification\u201d is not sent, then the device cannot be turned off.","The above floppy drive problem can be solved in a drivers framework by allowing each device to have a \u201cwake signal\u201d at the hardware level that can bring the device back into a working state. The problem is that almost all hardware in existence ties the wake signal into logic that controls the current power state, and the current power state is managed with a completely separate event. Thus, device drivers are forced to use two completely separate and unsynchronized events to manage a process that is essentially an interconnected and synchronized hardware subsystem. In view of the problems listed above and others, many machines such as laptop computers suffer from poor battery life.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key\/critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The present invention relates to systems and methods that support Plug and Play (PnP) and power management operations at a higher-level domain than at a device driver level. In one aspect, the present invention creates an infrastructure that allows a device driver to operate within an operating system framework or model without having to process Plug-and-Play or Power Management events (e.g., I\/O Request Packets (IRPs)) directly. The infrastructure provides system and device level synchronization of PnP and power related events that effectively coordinates and guides efficient power operations. Such operations include allowing devices to remain in low power states to conserve battery life while mitigating complex system level considerations for entering and returning from these states.","In one aspect, the present invention merges the concepts of PnP and Power, which are largely separate in various operating system models. One example implementation of the present invention includes employment of three state machines that act as a layer to bridge operating system components and device driver power requirements. This layer of state machines creates an environment for device drivers that processes operating system interactions on behalf of the driver, allowing the driver to only implement the components needed for desired driver functionality. Furthermore, the layer is rich enough to allow a device to save maximal power without much coding or design effort on the part of the driver designer.","The present invention offers several advantages over conventional operating system models such as: Significantly improving the quality of device drivers, which can directly reduce the number of system problems; Can be provided as part of a \u201cDriver Framework\u201d which mitigates code development for driver designers; Significantly improve opportunities for battery life savings including system tuning and power optimization algorithms; and Allowing a driver written for one style of operating system to be easily migrated to another style of operating system by removing power management and PnP processing from the device layer to middle or system level layers.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the invention may be practiced, all of which are intended to be covered by the present invention. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The present invention provides a unified layer for Plug and Play (PnP) components and power management components while relieving device drivers from system-level complexities associated with implementing PnP and\/or power management functionality. The layer operates at a level between low-level device drivers and more complex operating system tasks. The subject invention simplifies designing device drivers having proper power management support by creating an infrastructure that allows a device driver to operate within a driver framework or model and without having to process Plug-and-Play or Power Management I\/O Request Packets (IRPs) directly. This creates an environment for device drivers that process framework interactions on behalf of the driver, allowing the driver to implement desired functionality while mitigating overall driver complexities. These features can be achieved by defining multiple state machines that manage PnP and Power-related events that in turn promote energy savings on a system-wide level.","As used in this application, the terms \u201ccomponent,\u201d \u201cmodel,\u201d \u201csystem,\u201d \u201cframework,\u201d \u201cobject,\u201d \u201cstack,\u201d and the like are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers. Also, these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and\/or remote processes such as in accordance with a signal having one or more data packets (e.g., data from one component interacting with another component in a local system, distributed system, and\/or across a network such as the Internet with other systems via the signal).","Referring initially to , a power management system  is illustrated in accordance with an aspect of the present invention. The system  includes an operating system framework  that interacts with one or more device drivers  via a middleware layer  that coordinates Plug and Play (PnP) requirements and power requirements between the framework and the drivers. In general, the middleware layer  includes one or more state machines or processing components that control and synchronize power operations for the system . The state machines include a PnP state machine  that tracks events from a PnP manager (not shown) while coordinating with a power state machine  that manages device power events and a power policy state machine  that manages system power events. The state machines are described in more detail below with respect to .","By offloading power management considerations from the device driver level, and moving such processing to the middleware layer , several performance and design enhancements are achieved over conventional systems. One feature relates to simplifying the design of the drivers . For example, these drivers no longer have to attempt to account for system level considerations and can more simply respond to events, Interrupt Request Packets (IRPs), and call backs from the middleware layer  without substantial concern for coordination between other drivers and\/or other components of the system . Moreover, since complex functional requirements are effectively transferred from the drivers  to the middleware layer , the drivers can be implemented as essentially \u201coperating system-independent drivers.\u201d This implies that a driver in one operating system (e.g., Windows) can be easily transported and operated in another operating system (e.g., Linux) and vice versa.","Because of the flexibility and simplicity offered by the middleware layer , device drivers  can be put into low power states and returned to normal operating conditions in a straightforward and robust manner thus, conserving overall system power. As can be appreciated, the middleware layer  and state machines - can be implemented in various designs and can have all or portions thereof incorporated within the framework . Also, the drivers  can be designed for substantially any device such as network devices, memory devices (volatile or nonvolatile), acoustical devices, display devices, printers, bus devices, USB devices, infrared devices, power devices, keyboards, mice, and so forth. Furthermore, the state machines - can be implemented in substantially any language such as Unified Modeling Language (UML), Very High Speed Hardware Description Language (VHDL), programming languages such as C++ and so forth. In general, the following serve as general guidelines for the PnP, Power and framework components described herein:\n\n","Referring now to , a system  illustrates state machine interactions in accordance with an aspect of the present invention. As noted above, three formal state machines can be defined however, more or less than three can be employed. A first state machine, referred to as the PnP State Machine , tracks PnP events or I\/O Request Packets (IRPs) from a Plug and Play (PnP) manager . This machine responds by feeding events into other state machines and by calling PnP-related functions  supplied by a device driver , which fill in driver-specific behavior. A second state machine, referred to as the Power State Machine , tracks device Power Management events or IRPs at . This machine also manages device power states, by calling driver-supplied functions  where necessary.","A third state machine, referred to as the Power Policy State Machine , tracks system Power Management events or IRPs supplied by a system Power Manager . In one aspect, the Power Policy State Machine  manages tracking overall system state, along with device usage, deciding what power state the device should be in. The Power Policy Machine  sends device Power management IRPs at  that can become input events  for the Power State Machine . Generally, each of these state machines , , and  generate some events that are consumed by the other machines or other components. Together, they make up a larger system for implementing PnP and Power in the device driver  (or drivers). When the machines are integrated into a Driver Framework or operating system layer, they can be employed by a plurality of different device drivers, solving many problems such as system power consumption, driver complexity, and system robustness.","In general, the state machines can provide a plurality of different states that are entered into and\/or exited from via one or more events. For example, various sample states are illustrated at  including system power states that are derived from the Advanced Configuration and Power Interface (ACPI) specification that is conventionally known and available from a plurality of sources such as the Internet. These states are generally defined as follows:\n\n","System power states are primarily defined in terms of motherboard\/CPU\/core logic characteristics and generally do not relate to individual devices themselves. Each device in the system generally has its own power states. These are defined as follows:\n\n","To enter and exit these and other states, one or more events can occur. In general, there are several classes of events, those that are universal to all operating systems since they are dictated by hardware, and those that may be specific to a particular type of operating system (e.g., Windows). Some example events are illustrated at  include: Power Up, Power Down, Power Policy Start, Power Policy Stop, Power Implicit D, Power Implicit D, and so forth.","Generally the state machines support a system that implements a general mechanism for all PnP, Device Power and Device Power Policy events. The system includes entry into states in one state machine that can cause transitions to occur in other state machines or components. In one example, entry into the D state causes a Power Up event to be sent to the other state machines since these machines may have been sent events that caused the device to start being used. This would result in an \u201cImplicitD\u201d event sent to the Power state machine which unifies the PnP and Power machines. The PnP state machine, however, waits until the Power state machine has completed the move into D. In a multiprocessing operating system, components generally do not want to wait by sitting in a loop with the processor\u2014these components suspend operations. Thus, the \u201cPower Up\u201d event alerts the PnP state machine and causes it to start running again, finishing the PnP operation.","Specific state processing implementation examples include, entry into a lower power state in the Power state machine causes a Power Down event to be fed into the Power Policy and the PnP state machines. In another case, entry into the D state in the Power state machine causes some or all of the I\/O queues (not shown) in the driver (top-edge queues) to be released so that new requests can be processed.","As can be appreciated a plurality of state actions, events, IRP's, and processing can occur within or between state machines, drivers, and operating system components. Other examples of various actions include:\n\n","Turning to , an exemplary processing stack  is illustrated in accordance with an aspect of the present invention. The stack  can include one or more stack objects. For example, the objects can include a Functional Driver Object (FDO) , a filter object  supplied by an operating system framework, and a Physical Driver Object (PDO) . As illustrated, IRP's can be propagated up or down the stack  for respective processing, wherein framework components or drivers can be driven and synchronized from a respective IRP.","It is noted that some operating systems or frameworks support the concept of driver stacking. For example, when an application opens up a handle to a \u201cdevice,\u201d it controls the device by sending I\/O Request Packets (IRPs) to the stack of drivers at . Generally, each of those drivers in the stack  may react to, modify or otherwise handle the IRPs that it observes. When one driver is finished with an IRP, it passes it down to the driver below it. There is also an opportunity for a driver to see an IRP after the driver below it has completed it as illustrated in . These type of stack actions are relevant since each physical device may have several drivers acting on it in some manner. Typically, at the least, there will be a \u201cFunctional Driver,\u201d or \u201cFDO,\u201d and a \u201cPhysical Driver,\u201d or \u201cPDO.\u201d","Generally, in each driver stack , each driver handles PnP and Power events. However, one driver in the stack should track system power events and status, deciding when the device should be powered on or off. Consequently, the PnP State Machine and the Power State machine can be instantiated in any device driver. The Power Policy State Machine should be instantiated in the driver that is the \u201cpower policy owner\u201d for the device stack . Thus, the Power State Machine and the Power Policy State machine should exist or be implemented as separate entities or components. The following discussion describes various aspects of the state machines, events, IRP's, framework interactions, Application Programming Interfaces (APIs), and example system scenario's for which the state machines apply.","Referring now to , exemplary events  for a PNP state machine are illustrated in accordance with an aspect of the present invention. Before proceeding with a discussion of , it is noted that the respective state machines can process more or less events (or other events) than the example events discussed in these Figures. Generally, the PNP state machine responds to the following external events :\n\n","Turning to , exemplary events  for a Power state machine are illustrated in accordance with an aspect of the present invention. Generally, the Power state machine responds to the following external events :\n\n","Since there are generally fewer events that feed into the Power state machine, it is acceptable to look at side conditions when choosing a target state. Specifically, several transitions observe a POWER_STATE_TYPE. The Power state machine can be designed to process FDOs, PDOs, filters, bus filters and the like. It is valid whether or not the driver is also the power policy owner.","Referring to , exemplary events  for a Power Policy state machine are illustrated in accordance with an aspect of the present invention. Generally, the Power Policy state machine is instantiated when the driver decides to be the power policy owner for the stack. This will usually be true if the driver is an FDO. It will usually not be true otherwise. The Power Policy state machine is primarily responsible for deciding when the device should be in D, D, D or D. It also decides whether the device should be armed for wakeup. The Power Policy state machine sends IRP_MN_SET_POWER IRPs to the stack that have D-state information in them. It also sends IRP_MN_WAIT_WAKE.","The Power Policy state machine responds to the following external events :\n\n","The Power Policy state machine makes distinctions between waking from S and waking from S-not-, noted as \u201cSx.\u201d The distinction is relevant, since many devices have different usage scenarios for waking from S and waking from Sx. Consider a few examples:\n\n","For the above reasons, there can be separate callbacks related to Wait\/Wake for S and Sx. A similar approach as the Power state machine could be taken to automatically register the same callbacks for the S and Sx cases. But, unlike the power situation, the common case here is different behavior for S and Sx, which implies that most drivers may end up overriding the default callbacks. Also, the Power Policy state machine is similar to the Power state machine in that some of its callbacks should be called under the constraint that they will not generate a page fault.","When the Power Policy state machine chooses to move the device out of D, it selects between D, D and D. The device should be as deeply asleep as it can be without disabling functionality, both when the computer is remaining in S and when it is going to sleep. For the most part, latency differences between D, D and D are not as relevant, as they tend to be on the order of milliseconds. The ACPI specification, and other available power management documents imply that the differences between D, D and D mostly relate to wakeup latency. In practice, this has not been the case. There are, of course, some notable exceptions, (e.g., CRT monitors), but most devices have wakeup latencies that are mostly on the order of a few milliseconds.",{"@attributes":{"id":"p-0048","num":"0117"},"figref":"FIG. 7","b":["700","710","700"],"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":["WDF Objects relating to PnP\/Power","WDFDEVICE\n\nFramework Interfaces:\n","WdfDeviceInitSetPowerPolicyOwnership"]}},{"@attributes":{"id":"p-0049","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"WdfDeviceInitSetPowerPolicyOwnership("]},{"entry":[{},"\u2003IN PWDFDEVICEINIT DeviceInit,"]},{"entry":[{},"\u2003IN BOOLEAN \u2003\u2003Owner"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"By default, the Framework assumes that any FDO is the power policy owner, and any filter or PDO is not. If this is not true, then the driver can call this function to deterministically mark the device as either an owner or a non-owner. The Framework can instantiate a Power Policy state machine and corresponding WDFPOWERPOLICY object for any device that owns the power policy for its stack.\n\n",{"@attributes":{"id":"p-0051","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum _WDF_DEVICE_FAILED_ACTION {"]},{"entry":[{},"\u2003WdfDeviceFailedUndefined = 0,"]},{"entry":[{},"\u2003WdfDeviceFailedAttemptRestart,"]},{"entry":[{},"\u2003WdfDeviceFailedNoRestart,"]},{"entry":[{},"} WDF_DEVICE_FAILED_ACTION;"]},{"entry":[{},"VOID"]},{"entry":[{},"WdfDeviceFailed("]},{"entry":[{},"\u2003IN WDFDEVICE Device,"]},{"entry":[{},"\u2003IN WDF_DEVICE_FAILED_ACTION FailedAction"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If a driver calls this API, the device stack should be torn down. If the driver calls with WdfDeviceFailedAttemptRestart as the FaileDAction, then the Framework can attempt to cause the stack to be built up again. Either condition can cause the driver to experience a process such as a SurpriseRemove situation, for example.","It is expected that, for catastrophic software failures, the driver would set FailedAction to WdfDeviceFailedAttemptRestart and for catastrophic hardware failures, the driver would set FailedAction to WdfDeviceFailedNoRestart. If the hardware can be \u201cfixed\u201d by passing through a D uninitialized state, then a driver may specify TRUE for a hardware error.\n\n",{"@attributes":{"id":"p-0054","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum _WDF_STATE_NOTIFICATION_TYPE {"},{"entry":"\u2003StateNotificationInvalid =\u20030x0000,"},{"entry":"\u2003StateNotificationEnterState =\u20030x0001,"},{"entry":"\u2003StateNotificationPostProcessState = 0x0002,"},{"entry":"\u2003StateNotificationLeaveState =\u20030x0004,"},{"entry":"\u2003StateNotificationAllStates =\u2003StateNotificationEnterState |"},{"entry":"\u2003\u2003\u2003\u2003\u2003StateNotificationPostProcessState |"},{"entry":"\u2003\u2003\u2003\u2003\u2003StateNotificationLeaveState"},{"entry":"} WDF_STATE_NOTIFICATION_TYPE;"},{"entry":"typedef struct _WDF_DEVICE_PNP_NOTIFICATION_DATA {"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Type of data"},{"entry":"\u2003\/\/"},{"entry":"\u2003WDF_STATE_NOTIFICATION_TYPE Type;"},{"entry":"\u2003union {"},{"entry":"\u2003\u2003struct {"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The current state that is about to be exitted"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_PNP_STATE CurrentState;"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The new state that is about to be entered"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_PNP_STATE NewState;"},{"entry":"\u2003\u2003} EnterState;"},{"entry":"\u2003\u2003struct {"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The current state"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_PNP_STATE CurrentState;"},{"entry":"\u2003\u2003} PostProcessState;"},{"entry":"\u2003\u2003struct {"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The current state that is about to be exitted"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_PNP_STATE CurrentState;"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The state that is about to be entered"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_PNP_STATE NewState;"},{"entry":"\u2003\u2003} LeaveState;"},{"entry":"\u2003} Data;"},{"entry":"} WDF_DEVICE_PNP_NOTIFICATION_DATA;"},{"entry":"typedef const WDF_DEVICE_PNP_NOTIFICATION_DATA*"},{"entry":"PCWDF_DEVICE_PNP_NOTIFICATION_DATA;"},{"entry":"typedef struct _WDF_DEVICE_POWER_NOTIFICATION_DATA {"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Type of data"},{"entry":"\u2003\/\/"},{"entry":"\u2003WDF_STATE_NOTIFICATION_TYPE Type;"},{"entry":"\u2003union {"},{"entry":"\u2003\u2003struct {"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The current state that is about to be exitted"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_POWER_STATE CurrentState;"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The new state that is about to be entered"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_POWER_STATE NewState;"},{"entry":"\u2003\u2003} EnterState;"},{"entry":"\u2003\u2003struct {"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The current state"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_POWER_STATE CurrentState;"},{"entry":"\u2003\u2003} PostProcessState;"},{"entry":"\u2003\u2003struct {"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The current state that is about to be exitted"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_POWER_STATE CurrentState;"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The state that is about to be entered"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003WDF_DEVICE_POWER_STATE NewState;"},{"entry":"\u2003\u2003} LeaveState;"},{"entry":"\u2003} Data;"},{"entry":"} WDF_DEVICE_POWER_NOTIFICATION_DATA;"},{"entry":"typedef const WDF_DEVICE_POWER_NOTIFICATION_DATA*"},{"entry":"PCWDF_DEVICE_POWER_NOTIFICATION_DATA;"},{"entry":"typedef struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA {"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Type of data"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003WDF_STATE_NOTIFICATION_TYPE Type;"},{"entry":"\u2003\u2003union {"},{"entry":"\u2003\u2003\u2003struct {"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ The current state that is about to be exitted"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003WDF_DEVICE_POWER_POLICY_STATE CurrentState;"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ The new state that is about to be entered"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003WDF_DEVICE_POWER_POLICY_STATE NewState;"},{"entry":"\u2003\u2003\u2003} EnterState;"},{"entry":"\u2003\u2003\u2003struct {"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ The current state"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003WDF_DEVICE_POWER_POLICY_STATE CurrentState;"},{"entry":"\u2003\u2003\u2003} PostProcessState;"},{"entry":"\u2003\u2003\u2003struct {"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ The current state that is about to be exitted"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003WDF_DEVICE_POWER_POLICY_STATE CurrentState;"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ The state that is about to be entered"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003WDF_DEVICE_POWER_POLICY_STATE NewState;"},{"entry":"\u2003\u2003\u2003} LeaveState;"},{"entry":"\u2003} Data;"},{"entry":"} WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA;"},{"entry":"typedef const WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA*"},{"entry":"PCWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA;"},{"entry":"typedef"},{"entry":"VOID"},{"entry":"(*PFN_WDF_DEVICE_PNP_STATE_CHANGE_NOTIFICATION)("},{"entry":"\u2003WDFDEVICE Device,"},{"entry":"\u2003PCWDF_DEVICE_PNP_NOTIFICATION_DATA NotificationData"},{"entry":"\u2003);"},{"entry":"typedef"},{"entry":"VOID"},{"entry":"(*PFN_WDF_DEVICE_POWER_STATE_CHANGE_NOTIFICATION)("},{"entry":"\u2003WDFDEVICE Device,"},{"entry":"\u2003PCWDF_DEVICE_POWER_NOTIFICATION_DATA NotificationData"},{"entry":"\u2003);"},{"entry":"typedef"},{"entry":"VOID"},{"entry":"(*PFN_WDF_DEVICE_POWER_POLICY_STATE_CHANGE_NOTIFICATION)("},{"entry":"\u2003WDFDEVICE Device,"},{"entry":"\u2003PCWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA NotificationData"},{"entry":"\u2003);"},{"entry":"WDFSTATUS"},{"entry":"WdfDeviceInitRegisterPnpStateChangeCallback("},{"entry":"\u2003PWDFDEVICE_INIT DeviceInit,"},{"entry":"\u2003WDF_DEVICE_PNP_STATE PnpState,"},{"entry":"\u2003PFN_WDF_DEVICE_PNP_STATE_CHANGE_NOTIFICATION EvtPnpStateChange,"},{"entry":"\u2003ULONG CallbackTypes"},{"entry":"\u2003);"},{"entry":"WDFSTATUS"},{"entry":"WdfDeviceInitRegisterPowerStateChangeCallback("},{"entry":"\u2003PWDFDEVICE_INIT DeviceInit,"},{"entry":"\u2003WDF_DEVICE_POWER_STATE PowerState,"},{"entry":"\u2003PFN_WDF_DEVICE_POWER_STATE_CHANGE_NOTIFICATION"},{"entry":"EvtPowerStateChange,"},{"entry":"\u2003ULONG CallbackTypes"},{"entry":"\u2003);"},{"entry":"WDFSTATUS"},{"entry":"WdfDeviceInitRegisterPowerPolicyStateChangeCallback("},{"entry":"\u2003PWDFDEVICE_INIT DeviceInit,"},{"entry":"\u2003WDF_DEVICE_POWER_POLICY_STATE PowerPolicyState,"},{"entry":"\u2003PFN_WDF_DEVICE_POWER_POLICY_STATE_CHANGE_NOTIFICATION"},{"entry":"EvtPowerPolicyStateChange,"},{"entry":"\u2003ULONG CallbackTypes"},{"entry":"\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In general, the Framework may not provide callbacks for every state in its state machines, however, the driver can register for states that it wants to access. The above functions provide that capability.","Typically, the driver writer can register for three types of state change notifications such as:\n\n","These state machine related callbacks above generally do not replace formal event callbacks that a driver can register for using conventional registration APIs. For instance, if the driver registered for a state change notification on a RestartingSelfManagedIo state, it would not replace the EvtDeviceSelfManagedIoRestart callback related to this state.\n\n",{"@attributes":{"id":"p-0058","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS"]},{"entry":[{},"WdfDeviceSetStaticStopRemove("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003IN BOOLEAN Stoppable"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This function sets a property on a device. If TRUE, the Framework should allow a Stop or Remove of the device. If FALSE, it should not. The default is TRUE. A driver may change the setting. This function is generally intended for devices which must not stop their respective queues. They can inform the Framework, in advance, that their driver should run without substantial interruption.","Event Callbacks:",{"@attributes":{"id":"p-0060","num":"0000"},"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":"EvtDeviceDEntry"}},{"@attributes":{"id":"p-0061","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum _WDF_DEVICE_POWER_STATE {"]},{"entry":[{},"\u2003WdfPowerDeviceUnspecified = 0,"]},{"entry":[{},"\u2003WdfPowerDeviceD0,"]},{"entry":[{},"\u2003WdfPowerDeviceD1,"]},{"entry":[{},"\u2003WdfPowerDeviceD2,"]},{"entry":[{},"\u2003WdfPowerDeviceD3,"]},{"entry":[{},"\u2003WdfPowerDeviceD3Final."]},{"entry":[{},"\u2003WdfPowerDevicePrepareForHibernation,"]},{"entry":[{},"\u2003WdfPowerDeviceMaximum"]},{"entry":[{},"} WDF_DEVICE_POWER_STATE,"]},{"entry":[{},"*PWDF_DEVICE_POWER_STATE;"]},{"entry":[{},"NTSTATUS"]},{"entry":[{},"EvtDeviceD0Entry("]},{"entry":[{},"\u2003IN WDFDEVICE Device,"]},{"entry":[{},"\u2003IN WDF_DEVICE_POWER_STATE PreviousState"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the Power state machine enters the D state.","The driver then performs desired normal operations when power is first applied to the device. This may include downloading firmware to the device, unmasking internal interrupt sources, and so forth. Since the Framework takes care of unblocking queues and other aspects, the driver should generally perform hardware-related operations in this callback.","PreviousState can indicate the state that the device was most recently in, which may be useful when waking. If the device was previously unstarted, it likely had no valid D-state, so PreviousState should be WdfPowerDeviceUnspecified. This can be called when the device gets an IRP_MN_START_DEVICE or IRP_MN_SET_POWER-D, for example.\n\n",{"@attributes":{"id":"p-0065","num":"0146"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS"]},{"entry":[{},"EvtDeviceD0Exit("]},{"entry":[{},"\u2003IN WDFDEVICE Device,"]},{"entry":[{},"\u2003IN WDF_DEVICE_POWER_STATE TargetState"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the Power state machine enters a Dx state where 0<x<=3. Note that the Power state machine can transition to this state before the actual Dx IRP passes through to the PDO. (Or, if this driver is the PDO, before power is removed.) This facilitates that the driver can still interact with hardware in this callback. The driver performs operations which should be performed when power is about to be removed. This may involve saving some register state, masking internal interrupt sources, and so forth.","If the TargetState is WdfPowerDeviceDFinal, the device is being stopped or removed. If the driver needs to perform any actions on the device that will assume the device will not return to D, they should be performed here.","TargetState should only be WdfPowerDevicePrepareForHibernation if the device is on the hibernation path (e.g., it got IRP_MN_DEVICE_USAGE_NOTIFCATION-Hibernation) and the target S-state is S.","If the TargetState is WdfPowerDevicePrepareForHibernation, the driver should perform suitable operations to quiet the device without shutting it off. It should also gather states that may be necessary for putting the device back in D after the system resumes from hibernation. It is noted that the device should not be powered off, since this device may be used to save the hibernation file to disk. This callback can be called when the device gets IRP_MN_STOP_DEVICE, IRP_MN_REMOVE_DEVICE or IRP_MN_SET_POWER-Dx.\n\n",{"@attributes":{"id":"p-0070","num":"0152"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS"]},{"entry":[{},"EvtDevicePrepareHardware("]},{"entry":[{},"\u2003IN WDFDEVICE Device,"]},{"entry":[{},"\u2003IN WDFCOLLECTION ResourcesRaw,"]},{"entry":[{},"\u2003IN WDFCOLLECTION ResourcesTranslated"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the device is assigned a new set of PnP resources. The driver should take note of them, and possibly map them, using them for device control routines. This is also a place to call USB-related functions that have to wait until the device has gotten a Start command. Examples of these USB functions are:\n\n","If the driver returns failure, the stack should be torn down. While the hardware is available and the driver may access it in this state, it is probably more suitable for the driver to wait for EvtDeviceDEntry before access the hardware. Exceptions include operations that involve finding out exactly which version of the hardware is actually present.\n\n",{"@attributes":{"id":"p-0073","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"EvtDeviceContextCleanup("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when a device is being removed. Hardware is no longer accessible at this point. There should be no outstanding I\/O\u2014it should have been flushed and the queues should be canceling operations by this point. The driver should be concerned with freeing memory, tearing down structures and cleaning up software states, for example at this point. The driver should not access hardware in this callback.\n\n",{"@attributes":{"id":"p-0075","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"EvtDeviceSelfManagedIoCleanup("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked after the driver has stopped driver operations that are not being managed by the Framework. It is invoked on Remove and Surprise Remove. The driver should perform outstanding cleanup work. The driver should not access hardware during this callback.\n\n",{"@attributes":{"id":"p-0077","num":"0168"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS"]},{"entry":[{},"EvtDeviceSelfManagedIoInit("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the driver should start operations that are not being managed by the Framework. This callback should be the first in the \u201cSelfManagedIo\u201d group invoked as the driver starts. It should be invoked once when the device is started.","If a driver fails this callback, the Framework should inform the PnP manager that the device has failed, which should cause the PnP manager to tear the stack down. EvtDeviceSelfManagedIoCleanup will be called if failure is returned from this function.\n\n",{"@attributes":{"id":"p-0080","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS"]},{"entry":[{},"EvtDeviceSelfManagedIoSuspend("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the driver should pause operations that are not being managed by the Framework. It should be invoked on Dx transitions, except when EvtDeviceSelfManagedIoStop has been called but EvtDeviceSelfManagedIoRestart has not. This callback differs from EvtDeviceSelfManagedIoStop in that failure should be interpreted as fatal, causing the stack to be torn down. Hardware may be available while this callback is invoked. If the device is surprise removed while it is in the D state, this function will be called when hardware is not available.\n\n",{"@attributes":{"id":"p-0082","num":"0175"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS"]},{"entry":[{},"EvtDeviceSelfManagedIoRestart("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the driver should resume operations that are not being managed by the Framework. It should be invoked after EvtDeviceSelfManagedIoSuspend or EvtDeviceSelfManagedIoStop was invoked. Hardware is available while this callback is invoked.\n\n",{"@attributes":{"id":"p-0084","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"WDFSTATUS"]},{"entry":[{},"EvtDeviceSelfManagedIoStop("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"This callback is invoked when the driver should stop queues that are not being managed by the Framework, since the device is being stopped, in response to IRP_MN QUERY_STOP or IRP_MN_QUERY_REMOVE. This should occur before the Framework stops Framework-managed queues, which is before the device exits the D state. If a driver fails this callback, the Framework should fail the IRPs. This is intended to be a valid way to indicate that temporal conditions exist wherein the driver cannot be stopped or removed. Hardware is available while this callback is invoked.\n\n",{"@attributes":{"id":"p-0086","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"EvtDeviceSurpriseRemoval("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the device is pulled out of the system\u2014physically or logically. This is largely informational, as the Framework can still process queues, and the callback EvtDeviceRemove should be invoked later. It is expected that, if drivers register for this callback, they will use it for reporting specific error conditions. Hardware is not available while this callback runs.\n\n",{"@attributes":{"id":"p-0088","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS"]},{"entry":[{},"EvtDeviceReleaseHardware("]},{"entry":[{},"\u2003IN WDFDEVICE Device,"]},{"entry":[{},"\u2003IN WDFCOLLECTION ResourcesTranslated"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the device is losing ownership of its PnP resources, and the driver should un-map items that it has previously mapped. If the driver returns failure, then the stack should be torn down. The driver may not access hardware during this callback. The device has already been moved into the D state.","Pnp State Machine Input Events:",{"@attributes":{"id":"p-0090","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":"PnpEventAddDevice"}},"This event is generated from the driver's PnP AddDevice routine. This event is pertinent to FDOs.\n\n","This event is generated when the device has initially received an IRP_MN_START_DEVICE request. The event is sent before the request itself is sent down the device stack if the device is an FDO or completed immediately if the device is a PDO. The IRP at this point is neither queued nor pended.\n\n","This event is generated when the device has sent the IRP_MN_START_DEVICE request down the stack and it has been completed successfully. Before sending the event, the IRP is queued and pended. If the device generating this event is a PDO, this event is generated after the PnpEventStartDevice event without further IRP processing. Upon completion of processing this event, the state machine will complete the start request up the stack.\n\n","This event is generated when the device receives the IRP_MN_QUERY_REMOVE_DEVICE request. Before sending the event, the IRP will be queued and pended. Upon completion of processing this event, the IRP will be processed accordingly. If the event was processed successfully, the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO. If the event was processed unsuccessfully, the IRP will be completed immediately with error.\n\n","This event is generated when the device receives the IRP_MN_QUERY_STOP_DEVICE request. Before sending the event, the IRP will be queued and pended. Upon completion of processing this event, the IRP will be processed accordingly. If the event was processed successfully, the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO. If the event was processed unsuccessfully, the IRP will be completed with error.\n\n","This event is generated when the device receives the IRP_MN_CANCEL_REMOVE_DEVICE request. Before sending the event, the IRP will be queued and pended. Upon completion of processing this event, the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.\n\n","This event is generated when the device receives the IRP_MN_CANCEL_STOP_DEVICE request. Before sending the event, the IRP will be queued and pended. Upon completion of processing this event, the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.\n\n","This event is generated when the device receives the IRP_MN_STOP_DEVICE request. Before sending the event, the IRP will be queued and pended. Upon completion of processing this event, the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.\n\n","This event is generated when the device receives the IRP_MN_REMOVE_DEVICE request. Before sending the event, the IRP will be queued and pended. Upon completion of processing this event, the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.\n\n","This event is generated when the device receives the IRP_MN_SURPRISE_REMOVAL request. Before sending the event, the IRP will be queued and pended. Upon completion of processing this event, the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.\n\n","This event is generated when the PDO receives the IRP_MN_EJECT request. Before sending the event, the IRP will be queued and pended. Upon completion of processing this event, the IRP will be sent down the stack if the device is an FDO or completed immediately if the device is a PDO.\n\n","This event is generated by the power state machine to indicate that the device has returned to D, either implicitly or explicitly. This event may have been in response to a power up request made by the pnp state machine to power up the device.\n\n","This event is generated by the power state machine to indicate that the device been put into a Dx state, either implicitly or explicitly. This event may have been in response to a power up request made by the pnp state machine to power down the device.\n\n","This event is generated by the power state machine to indicate that a request for the device to return to D has failed. Reception of this event will lead to the device stack being torn down.\n\n","This event is generated by the power state machine to indicate that a request for the device to go into a Dx state has failed. Reception of this event will lead to the device stack being torn down\n\n","This event is sent by the parent PnP state machine to all of its enumerated children that are still present. This event is sent when the parent is being removed from the system. The parent will wait for each child to send a PnpEventChildrenRemovalComplete event to it before finishing processing of the PnpEventRemove event. The PnpEventChildrenRemovalComplete event is sent by the child PnP state machine to its parent when it has been successfully removed.\n\n",{"@attributes":{"id":"p-0107","num":"0220"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum_WDF_POWER_POLICY_S0_IDLE_CAPABILITIES {"},{"entry":"\u2003IdleCapsInvalid = 0,"},{"entry":"\u2003IdleCannotWakeFromS0,"},{"entry":"\u2003IdleCanWakeFromS0,"},{"entry":"} WDF_POWER_POLICY_S0_IDLE_CAPABILITIES;"},{"entry":"typedef enum_WDF_POWER_POLICY_S0_IDLE_USER_CONTROL {"},{"entry":"\u2003IdleUserControlInvalid = 0,"},{"entry":"\u2003IdleDoNotAllowUserControl,"},{"entry":"\u2003IdleAllowUserControl,"},{"entry":"} WDF_POWER_POLICY_S0_IDLE_USER_CONTROL;"},{"entry":"typedef struct_WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS {"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Size of this structure in bytes"},{"entry":"\u2003\/\/"},{"entry":"\u2003ULONG Size;"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Indicates whether the device can wake itself up while the machine is in"},{"entry":"\u2003\/\/ S0."},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ This value is only read the first time WdfDeviceUpdateS0IdleSettings is"},{"entry":"\u2003\/\/ called."},{"entry":"\u2003\/\/"},{"entry":"\u2003WDF_POWER_POLICY_S0_IDLE_CAPABILITIES IdleCaps;"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ The low power state in which the device will be placed when it is idled"},{"entry":"\u2003\/\/ out while the machine is in S0."},{"entry":"\u2003\/\/"},{"entry":"\u2003DEVICE_POWER_STATE DxState;"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Amount of time the device must be idle before idling out. Timeout is in"},{"entry":"\u2003\/\/ milliseconds."},{"entry":"\u2003\/\/"},{"entry":"\u2003ULONG IdleTimeout;"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Inidcates whether a user can control the idle policy of the device."},{"entry":"\u2003\/\/ By default, a user is allowed to change the policy."},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ This value is only read the first time WdfDeviceUpdateS0IdleSettings is"},{"entry":"\u2003\/\/ called."},{"entry":"\u2003\/\/"},{"entry":"\u2003WDF_POWER_POLICY_S0_IDLE_USER_CONTROL UserControlOfIdleSettings;"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ If TRUE, idling out while the machine is in S0 will be enabled."},{"entry":"\u2003\/\/ If FALSE, idling out will be disabled."},{"entry":"\u2003\/\/"},{"entry":"\u2003WDF_TRI_STATE Enabled;"},{"entry":"} WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS,"},{"entry":"*PWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS;"},{"entry":"WDFSTATUS"},{"entry":"WdfDeviceUpdateS0IdleSettings("},{"entry":"\u2003WDFDEVICE Device,"},{"entry":"\u2003PWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS Settings"},{"entry":"\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"This function specifies the S idle capabilities and associated settings of the device. The function allows the driver writer to specify the following:\n\n",{"@attributes":{"id":"p-0109","num":"0230"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"WdfDevicePowerReference("]},{"entry":[{},"\u2003IN WDFDEVICE Device,"]},{"entry":[{},"\u2003IN BOOLEAN WaitForD0"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This function is called by the driver or a Framework component to indicate that the device has I\/O to process. If the count changes from 0 to non-zero, and if the device is in a low-power state, then the Power Policy state machine may send IRP_MN_SET_POWER-D in order to bring the device into the working state, so that it can handle the I\/O requests. If WaitForD is TRUE, the device will be in D when the function returns to the caller. If FALSE is specified, the device will be brought back into the D state asynchronously.\n\n",{"@attributes":{"id":"p-0111","num":"0233"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"WdfDevicePowerDereference("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This function is called by the driver or a Framework component to indicate that the I\/O referred to by a previous call to WdfDevicePowerReference is complete. When the total count of outstanding I\/O drops to 0, it causes an event to be fed into the Power Policy state machine, possibly causing it to send IRP_MN_SET_POWER-Dx, so that the device moves into a low-power state.\n\n",{"@attributes":{"id":"p-0113","num":"0236"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum_WDF_POWER_POLICY_SX_WAKE_USER"},{"entry":"CONTROL {"},{"entry":"\u2003WakeUserControlInvalid = 0,"},{"entry":"\u2003WakeDoNotAllowUserControl,"},{"entry":"\u2003WakeAllowUserControl,"},{"entry":"} WDF_POWER_POLICY_SX_WAKE_USER_CONTROL;"},{"entry":"typedef struct_WDF_DEVICE_POWER_POLICY_WAKE"},{"entry":"SETTINGS {"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Size of this structure in bytes"},{"entry":"\u2003\/\/"},{"entry":"\u2003ULONG Size;"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ The low power state in which the device will be placed when it is"},{"entry":"\u2003\/\/ armed for wake from Sx."},{"entry":"\u2003\/\/"},{"entry":"\u2003DEVICE_POWER_STATE DxState;"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Inidcates whether a user can control the idle policy of the device."},{"entry":"\u2003\/\/ By default, a user is allowed to change the policy."},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ This value is only read the first time WdfDeviceUpdateS0IdleSettings"},{"entry":"\u2003\/\/ is called."},{"entry":"\u2003\/\/"},{"entry":"\u2003WDF_POWER_POLICY_SX_WAKE_USER_CONTROL"},{"entry":"UserControlOfWakeSettings;"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ If TRUE, arming for wake while the machine is asleep will be"},{"entry":"\u2003enabled."},{"entry":"\u2003\/\/ If FALSE, arming will be disabled."},{"entry":"\u2003\/\/"},{"entry":"\u2003WDF_TRI_STATE Enabled;"},{"entry":"} WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS,"},{"entry":"*PWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS;"},{"entry":"WDFSTATUS"},{"entry":"WdfDeviceUpdateSxWakeSettings("},{"entry":"\u2003WDFDEVICE Device,"},{"entry":"\u2003PWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS Settings"},{"entry":"\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"This function specifies the wake from Sx capabilities and associated settings of the device. The function allows the driver writer to specify the following:\n\n","This event is sent by the PnP state machine when the power policy state machine needs to be start. This start will be from the created or stopped [Normal] state. The PnP state machine sends this event after it has successfully processed the PnpEventStartDeviceCompleted event and while processing a PnpEventCancelStop from the query stopped state.\n\n","This event is sent by the PnP state machine when the power policy state machine is to stopped. This event will be sent when PnP state machine receives an IRP_MN_QUERY_STOP_DEVICE or IRP_MN_QUERY_REMOVE_DEVICE request. In response to this event, the power policy state machine will disarm the device if armed for wake from S. Upon completion of processing of this event, the power policy owner and the non owner state machines will send a PowerImplicitD event to the power state machine\n\n","This event is generated by the operating system when it is notifying system components that the machine is about to enter a lower power state. If the device has idled out and is in a low device (Dx) state, the power policy state machine will attempt to bring the device back into D so that the device can be put into the correct Dx state for the new system state. This event differs from the PwrPolSx even in that the transition to a lower system power state can fail at this point. When a PwrPolSx event is generated, the transition to a low system power state is not reversible.\n\n","This event is generated by the operating system when the system has returned from a lower system power state (Sx) or an attempt to enter a lower system power state has failed. The power policy state machine will put the device back into a power policy started state.\n\n","This event is generated when the device receives an IRP_MN_SET_POWER [SystemPowerState] that is not for the PowerSystemWorking state. In response to this event, the power policy state machine will decide what the appropriate Dx state the device should be put into and if the device should be armed to wake the machine from the state from which the machine is going into.\n\n","This event is generated when the device receives an IRP_MN_SET_POWER [SystemPowerState] that is for the PowerSystemWorking state. In response to this event, the power policy state machine can bring the device back into the D state or keep it in the Dx state if it was not armed for wake from Sx and the device is enabled for idle with out wake and is currently idle.\n\n","This event is generated by the power state machine when the device has been moved into a Dx state. This event is used as the synchronization mechanism between the power and power policy state machines between the actual request of the Dx IRP and the completion of the transition into that state.\n\n","This event is generated by the power state machine when the device has been moved into a D state. This event is used as the synchronization mechanism between the power and power policy state machines between the actual request of the D IRP and the completion of the transition into that state.\n\n","This event is generated when the device receives an IRP_MN_WAIT_WAKE request. In response to this event, the power policy state machine will invoke the EvtDeviceArmWakeFromS or EvtDeviceArmWakeFromSx event callback, depending on the current state of the state machine.\n\n","This event is generated by the device when an IRP_MN_WAIT_WAKE request is completed successfully by the wait wake owner of the stack. In response to this event, the power policy state machine make invoke the EvtDeviceWakeFromSTriggered or EvtDeviceWakeFromSxTriggered event callback, depending on the current state of the state machine.\n\n","This event is generated by the device when an IRP_MN_WAIT_WAKE request is completed unsuccessfully by the wait wake owner of the stack. In response to this event, the power policy state machine will invoke either the EvtDeviceDisarmWakeFromS or EvtDeviceDisarmWakeFromSx event callbacks to undo the arming performed in EvtDeviceArmWakeFromS or EvtDeviceArmWakeFromSx.\n\n","This event is generated by the device when the device has idled out into a Dx state and there is a need to bring the device back into D. For instance, this need may be the arrival of a request into a power managed queue or the driver calling WdfDevicePowerReference. In response to this event, the power policy state machine may bring the device back into the D state, disarming it from wake if it had been previously armed.\n\n","This callback is invoked when the device has triggered its wake signal from Sx. The Framework should process the aspects of wake, including moving the device back into D, the system back into S, restarting I\/O queues, and so forth. Thus, the driver probably does not have to register for this. It's mostly informational.\n\n","This event is generated when the device either receives a WMI request to change the S idle policy or the driver has called WdfDeviceUpdateSIdleSettings. In response to this event, the power policy state machine may bring the device back into D, disable the idle timer, and put the device into the new power policy state as specified by the event source.\n\n","This event is sent by the PnP state machine when the device receives an IRP_MN_SURPRISE_REMOVAL request. In response to this event, the power policy state machine will not invoke any driver event callbacks which may touch hardware. Upon completion of processing of this event, the power policy owner and the non owner state machines will send a PowerImplicitD event to the power state machine.","Callbacks:",{"@attributes":{"id":"p-0130","num":"0000"},"ul":{"@attributes":{"id":"ul0074","list-style":"none"},"li":"EvtDeviceWakeArmS"}},{"@attributes":{"id":"p-0131","num":"0272"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS"]},{"entry":[{},"EvtDeviceArmWakeFromS0("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the driver should arm its device to wake from S. Note that this does not include setting the bits in the PCI Power Management Capability structure. The PCI driver should perform that function. A driver should register for this callback if it needs to do additional operations, such as reconfiguration of internal interrupt signals, to wake, for example.\n\n",{"@attributes":{"id":"p-0133","num":"0275"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"EvtDeviceDisarmWakeFromS0("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the driver should disarm internal wake sources. This does not include setting bits in the PCI Power Management Capability structure. The driver generally only needs to undo operations it performed in EvtDeviceWakeArm.\n\n",{"@attributes":{"id":"p-0135","num":"0278"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"EvtDeviceWakeFromS0Triggered("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the device has triggered its wake signal from S. The Framework will handle the components of wake, including moving the device back into D, restarting I\/O queues, and so forth. Thus the driver probably does not have to register for this. It's mostly informational.\n\n",{"@attributes":{"id":"p-0137","num":"0281"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS"]},{"entry":[{},"EvtDeviceArmWakeFromSx("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the driver should arm its device to wake from Sx. Note that this does not include setting the bits in the PCI Power Management Capability structure. The PCI driver should perform that function. A driver should register for this callback if it needs to perform additional operations, such as reconfiguration of internal interrupt signals, to wake, for example.\n\n",{"@attributes":{"id":"p-0139","num":"0284"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"EvtDeviceDisarmArmFromSx("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the driver should disarm internal wake sources. Again, this should not include setting bits in the PCI Power Management Capability structure. The driver performs \u201cundo\u201d top operations performed in EvtDeviceWakeArm.\n\n",{"@attributes":{"id":"p-0141","num":"0287"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID"]},{"entry":[{},"EvtDeviceWakeFromSxTriggered("]},{"entry":[{},"\u2003IN WDFDEVICE Device"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This callback is invoked when the device has triggered its wake signal from Sx. The Framework should process the aspects of wake, including moving the device back into D, the system back into S, restarting I\/O queues, and so forth. This function is not guaranteed to be called if the device has actually triggered wake because there is an inherent race condition between the system power notification arriving to the device and the wake notification completing from the bus below it. Thus the driver probably does not have to register for this. It's mostly informational.","Power State Machine Input Events:",{"@attributes":{"id":"p-0143","num":"0000"},"ul":{"@attributes":{"id":"ul0080","list-style":"none"},"li":"PowerD"}},"This event is sent by the device when it receives an IRP_MN_SET_POWER [DevicePowerState\/PowerDeviceD] request. In response to this event, the power state machine will bring the device into the D state, calling the appropriate callbacks to restore the device's state. Upon successful processing of this event, the power state machine sends a PnpEventPowerUp event to the PnP state machine and a PwrPolPowerUp event to the power policy state machine Upon failure to process this event, the power state machine will send a PnpEventPowerDownUp event to the PnP state machine.\n\n","This event is sent by the device when it receives an IRP_MN_SET_POWER [DevicePowerState\/PowerDeviceDx] request. In response to this event, the power state machine will put the device into the Dx state, calling the appropriate callbacks to save the device's state. Upon successful processing of this event, the power state machine will send a PnpEventPowerDown event to the PnP state machine and a PwrPolPowerDown event to the power policy state machine Upon failure to process this event, the power state machine will send a PnpEventPowerDownFailed event to the PnP state machine.\n\n","When device is the wait wake owner for the stack, this event is sent by the device when it receives an IRP_MN_WAIT_WAKE request. Before sending this event, the wake request is pended. In response to this event, the EvtDeviceEnableWakeAtBus event callback may be invoked.\n\n","This event is sent when the driver calls the WdfDeviceCompleteWaitWakeRequest API with a successful NTSTATUS value and the device is currently armed for wake at the bus level. In response to this event, the power state machine may call EvtDeviceDisableWakeAtBus and complete the previously pended wake request. It is the power policy owner's responsibility to bring the device back into the D state.\n\n","This event is sent when the driver calls the WdfDeviceCompleteWaitWakeRequest API with an unsuccessful NTSTATUS value and the device is currently armed for wake for wake at the bus level. In response to this event, the power state machine may call EvtDeviceDisableWakeAtBus and complete the previously pended wake request.\n\n","This event is sent when the power policy owner attempts to cancel an outstanding wait wake request. In response to this event, the power state machine may call EvtDeviceDsiableWakeAtBus and complete the previously pended wake request.\n\n","This event is sent by both the power policy owner and non-owner state machines. In response to this event, the power state machine will bring the device into a D state. Upon completion of processing this event, the power state machine will send a PnpEventPowerUp event to the PnP state machine and a PwrPolPowerUp event to the power policy state machine.\n\n","This event is sent by both the power policy owner and non owner state machines. In response to this event, the power state machine will bring the device into the Dx state. Upon completion of processing this event, the power state machine will send a PnpEventPowerDown event to the PnP state machine and a PwrPolPowerDown event to the power policy state machine.\n\n","This event is sent by the parent power state machine to each child state machine when the parent enters the D state.\n\n","This event is sent by the PnP state machine when the device receives an IRP_MN_QUERY_STOP_DEVICE or IRP_MN_QUERY_REMOVE_DEVICE. In response to this event, the power state machine moves to a state where it will expect a PowerImplicitD event to be sent by the power policy state machine. When the PowerImplicitD event is received, the device will be moved into the Dx state and the appropriate callbacks will be called.\n\n","This event is sent by the PnP state machine when the device receives an IRP_MN_SURPRISE_REMOVAL. In response to this event, the power state machine will move to a state where it will expect a PowerImplicitD event to be sent by the power policy state machine. When the PowerImplicitD event is received, the device will not be moved into the Dx state since it is no longer present in the system. No event callback which is allowed to touch hardware will be called.\n\n","This event is sent by the device when it receives an IRP_MN_DEVICE_USAGE_NOTIFICATION request disabling a device usage (such as being on the paging path). In response to this event, the power state machine may move from a non-pageable D state to a pageable D state if the device initially had the D_POWER_PAGABLE flag set.\n\n","This event is sent by the device when it receives an IRP_MN_DEVICE_USAGE_NOTIFICATION request enabling a device usage (such as being on the paging path). In response to this event, the power state machine may move from a pageable D state to a non-pageable D state if the device initially had the DO_POWER_PAGABLE flag set.\n\n","A Framework queue object is generally involved in PnP\/Power in at least two ways. First, it should be possible for the Power state machine to cause certain device's queues to hold or release depending on what power state the device is in. Second, the queue should report to a Power Policy object when the queue transitions from idle to busy (by calling WdfDevicePowerReference) and from busy to idle (by calling WdfDevicePowerDereference.) In general, a driver should be able to stipulate that a queue is one that participates in power decisions or, it should stipulate that a queue is one that should not affect power decisions.","Framework Interfaces:",{"@attributes":{"id":"p-0158","num":"0000"},"ul":{"@attributes":{"id":"ul0094","list-style":"none"},"li":"WDFFILEOBJECT"}},"A Framework file object should be involved in PnP\/Power in one instance at least. For example, it should allow for a driver to indicate that the device should not be put in a low power state while a particular file handle is open (by calling WdfDevicePowerReference and WdfDevicePowerDereference.)","This is mostly true for devices which do not have a clear way of knowing when they are active or when there is something plugged into them. The most common example would be a serial port, which may mark every open file handle as needing to keep the device active. This should generally be a rare requirement.",{"@attributes":{"id":"p-0161","num":"0320"},"figref":"FIG. 8","b":"800"},"The process  depicts some example considerations and system interactions such as device type considerations, filter considerations, and device operations. This process discussion is followed by some specific examples of the respective process components. In general, state processing in accordance with the present invention can be provided in accordance with a plurality of conditions and\/or applications. Proceeding to  of the process , such conditions or state processes can change depending on several factors such as the type of device and associated driver that is interacting with the state machines previously described. For example, this can include interactions with software only type objects where there is no actual hardware to control and thus state processing is somewhat minimized. Other type devices can include self-contained devices having no internal power management considerations but are targets for other type operations such as a \u201cselective suspend\u201d state, and yet other devices interact with more directly with the various states and events previously described. Some examples of these and other situations are described below.","At , driver determinations and state processes can be affected by considerations of whether or not certain objects are present in a stack such as whether a Functional Driver Object (FDO) or filter object is present in the stack. At , various state processes are possible depending on the power management situation at hand. These can include normal state operations at , system sleep operations at , system wake operations at , and device removal operations at , whereby the following discussion illustrates various exemplary situations that may occur with respect to the process . It is to be appreciated that a plurality of PnP or Power Management processes can occur that are in accordance with the event and state processes previously described.","Example State Processing Considerations:",{"@attributes":{"id":"p-0164","num":"0000"},"ul":{"@attributes":{"id":"ul0095","list-style":"none"},"li":"Software-Only \u201cDevice\u201d"}},"In this aspect, there is no actual hardware, thus there is no power to manage, and no \u201cplug\u201d to \u201cplay\u201d with. Therefore, this device driver generally only needs to respond minimally to PnP and power IRPs.","Analysis for a Driver that is the FDO in this Stack","Since software only devices are not particularly interested in hardware related aspects, it generally only provides callbacks for:\n\n","Normal Operation:\n\n","Device Removal Example:\n\n","This type device generally consists of a single device (e.g., PCI, USB or ISA) with no internal concept of power. It generally has no hardware states corresponding to D, D, D or D. It may or may not be enumerable. It may or may not be removable.","Analysis for a Driver that is the FDO in this Stack","This driver would register for:\n\n","Since this driver is instantiated e.g., within Windows via an AddDevice call, and since this driver does not call WdfFdoInitSetFilter, it is automatically marked as the Power Policy Owner. This implies that the Framework will automatically create an instantiation of the Power Policy state machine to go along with it. This driver generally instantiates one WDFQUEUE object and lets the defaults remain, which implies that it responds to changes in power states.","System going to sleep example:\n\n","System waking example:\n\n","This device can be moved between \u201coff\u201d and \u201con.\u201d If there are no open handles to the device, it can be moved into D. If a handle is opened when the device is in D, then it will be moved to D. At times the device is in D, an external event may occur that will trigger PME#. This can result in the device being moved back into D. This may happen when the machine is in S, or when the machine is asleep. This type device may correspond roughly to a modem, for example.","Analysis for a Driver that is the FDO in this Stack","This driver would register for:\n\n","Normal Startup:\n\n","One of at least two sub-scenarios may happen next. First, bringing the device on line may cause an application or service that is registered for device notification to open a handle to this device. Second, no handles may be opened.","Handle Immediately Opened Case:\n\n","Handle Not Opened Case:\n\n","This above situation leads to at least two cases, the wake signal fires and a handle is opened. First, what happens when a handle is opened:\n\n","If, instead, a wake signal is triggered:\n\n","With reference to , an exemplary environment  for implementing various aspects of the invention includes a computer . The computer  includes a processing unit , a system memory , and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures including, but not limited to, 11-bit bus, Industrial Standard Architecture (ISA), Micro-Channel Architecture (MSA), Extended ISA (EISA), Intelligent Drive Electronics (IDE), VESA Local Bus (VLB), Peripheral Component Interconnect (PCI), Universal Serial Bus (USB), Advanced Graphics Port (AGP), Personal Computer Memory Card International Association bus (PCMCIA), and Small Computer Systems Interface (SCSI).","The system memory  includes volatile memory  and nonvolatile memory . The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer , such as during start-up, is stored in nonvolatile memory . By way of illustration, and not limitation, nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), or flash memory. Volatile memory  includes random access memory (RAM), which acts as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), and direct Rambus RAM (DRRAM).","Computer  also includes removable\/non-removable, volatile\/non-volatile computer storage media.  illustrates, for example a disk storage . Disk storage  includes, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-100 drive, flash memory card, or memory stick. In addition, disk storage  can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage devices  to the system bus , a removable or non-removable interface is typically used such as interface .","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system , which can be stored on disk storage , acts to control and allocate resources of the computer system . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.","A user enters commands or information into the computer  through input device(s) . Input devices  include, but are not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, TV tuner card, digital camera, digital video camera, web camera, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . Interface port(s)  include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB). Output device(s)  use some of the same type of ports as input device(s) . Thus, for example, a USB port may be used to provide input to computer , and to output information from computer  to an output device . Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers, and printers, among other output devices , that require special adapters. The output adapters  include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device  and the system bus . It should be noted that other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as remote computer(s) . The remote computer(s)  can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to computer . For purposes of brevity, only a memory storage device  is illustrated with remote computer(s) . Remote computer(s)  is logically connected to computer  through a network interface  and then physically connected via communication connection . Network interface  encompasses communication networks such as local-area networks (LAN) and wide-area networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet\/IEEE 1102.3, Token Ring\/IEEE 1102.5 and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . While communication connection  is shown for illustrative clarity inside computer , it can also be external to computer . The hardware\/software necessary for connection to the network interface  includes, for exemplary purposes only, internal and external technologies such as, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.",{"@attributes":{"id":"p-0190","num":"0412"},"figref":"FIG. 10","b":["1000","1000","1010","1010","1000","1030","1030","1030","1010","1030","1000","1050","1010","1030","1010","1060","1010","1030","1040","1030"]},"What has been described above includes examples of the present invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly, the present invention is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
