---
title: Converting logical aspects of common warehouse model to design elements for relational database
abstract: A method and a system for converting logical aspects of a common warehouse model (CWM) to corresponding design items for a relational database by processing in a hierarchical manner the logical aspects and creating the corresponding design items. The logical aspects comprise entity-relationship (ER) libraries. The ER libraries comprise ER models. The corresponding design items comprise design libraries. The design libraries comprise design models.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07958165&OS=07958165&RS=07958165
owner: Unisys Corporation
number: 07958165
owner_city: Blue Bell
owner_country: US
publication_date: 20031118
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is related to patent application Ser. No 10\/716,287, entitled \u201cConverting Physical Aspects Of Common Warehouse Model To Elements Of Relational Database\u201d, filed on the same date and assigned to the same assignee as the present application, the content of which is herein incorporated by reference.","This application is also related to patent application Ser. No. 09\/894,785, filed on Jun. 28, 2001, entitled \u201cSystem and Method for Representing Relational Database Designs using CWM\u201d.","1. Field of the Invention","The present invention relates generally to methods and systems for converting common warehouse model (CWM) representations to corresponding elements in a relational database, and more particularly to methods and systems for converting the logical aspects of the CWM representations to corresponding elements for database design.","2. Description of Related Art","The Common Warehouse Model (CWM), which is based on the Unified Modeling Language (\u201cUML\u201d), is an industry standard data warehouse interchange protocol. With the use of a data warehouse aware tool that supports CWM, warehouse metadata can be represented in an open standard way. The CWM standard allows users to represent, transform, exchange or otherwise process warehouse metadata. This provides the users with the capability of exchanging, optimizing or debugging software systems that interact with databases.","In contrast, relational database design elements, such as those defined by Structured Query Language (SQL) Server or Oracle databases, are not based on open standards; and, thus are not easily exchanged, processed or represented in a standard way. A database designer's view is limited to that of the proprietary design tools provided by the database manufacturer or that of third party tools.","Thus, a database model that has been designed using the CWM standard cannot be easily transformed into design elements for a relational database or into elements of a relational database. Accordingly, there is a need to translate and represent CWM information as design elements for a relational database or as elements of a relational database, at the database level.","One embodiment of the present invention is a method for converting logical aspects of a common warehouse model (CWM) to corresponding design items for a relational database by processing in a hierarchical manner the logical aspects and creating the corresponding design items. The logical aspects comprise entity-relationship (ER) libraries. The ER libraries comprise ER models. The corresponding design items comprise design libraries. The design libraries comprise design models.","One embodiment of the present invention is a method and a system to transform data stored in the common warehouse model (CWM) into design elements for a relational database. Another embodiment of the present invention is a method and a system to transform data stored in the common warehouse model (CWM) into elements of a relational database.","In a first embodiment of the present invention, logical information, also called logical aspects, of the CWM are transformed into database design elements that are outputted to a database design tool.","In a second embodiment of the present invention, the physical information, also called physical aspects, of the CWM are transformed into elements that are outputted to a database management system.","In a third embodiment of the present invention, the logical and physical aspects of the CWM are transformed into database design elements and DBMS elements, respectively, which are outputted to a database design tool and a DBMS, respectively.","Database designs typically have two levels of information, which are logical information and physical information. In the Common Warehouse Model (CWM), the logical information or aspects are usually represented by entity-relationship (ER) diagrams, while the physical aspects are represented by relational elements in the relational design process where the end product is the structure of the database itself. Many of the terms from the ER world (logical) have near-equivalents in the relational world (physical). The following ER terms (logical) in descending hierarchical order: model library, model, entity, attribute, are near-equivalents of these relational terms (physical): catalog, schema, table, column.","The data to be transformed is stored in the common warehouse model (CWM) which defines a structure for the data. This data can be stored in the XML metadata interchange (XMI) format. Alternatively, the data can also be stored in an object-oriented repository.","There are two different types of output from the CWM transformation process. The first type of output is to a database design tool. A database design tool typically uses graphical elements to represent a database. The tool usually provides an application programming interface (API) that enables the programmatic modification of the database design. For this type of output, only the logical aspects of the CWM data need to be transformed.","The second output is to a database management system (DBMS). In this case, the output would typically be in the form of a script, such as Structured Query Language (SQL) script, containing instructions to modify existing or create new elements in the relational database. For this second type of output, only the physical aspects of the CWM data need to be transformed.","Since related items with the same names can be found in both the CWM (i.e., the input) and a database design (i.e., the output), a prefix will be added to the names of related items to distinguish them from one another. The CWM and its extensions contain a number of database, data-warehousing and data-mining related models. Only the ER (i.e., logical) and the relational (i.e., physical) models will be used as inputs. To retain clarity in the description below, items in the CWM will be referred to as ER <name> for items in logical aspects, or relational <name> for items in physical aspects. Some items from the CWM that are common to both ER and relational worlds will be prefixed by CWM. For the output, logical elements typically found in design tools with logical modeling support will be referred to as design <name>. Physical elements typically found in a DBMS or in the physical modeling of DBMS provided in database design tools will be referred to as DBMS <name>.","Throughout the following discussion on the process of processing a CWM item, instructions such as \u201cenumerate all . . . \u201d and \u201cget the properties of . . . \u201d mean reading information from CWM and then storing this information (or pointers to it) in memory structures. Any reference to a design tool or a DBMS is meant to include any alternative recipient of the CWM transformation output. Furthermore, instructions such as \u201ccreate a DBMS table . . . \u201d may not involve the programmatic creation of an object, but rather the insertion of \u201ccreate table\u201d statements in a script that can be used to create the output database.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 1","b":["100","100","110","120","130","140","150","155","170","180","180","100"],"sub":["1 ","K"]},"The processor  represents a central processing unit of any type of architecture, such as embedded processors, mobile processors, micro-controllers, digital signal processors, superscalar computers, vector processors, single instruction multiple data (SIMD) computers, complex instruction set computers (CISC), reduced instruction set computers (RISC), very long instruction word (VLIW), or hybrid architecture.","The processor bus  provides interface signals to allow the processor  to communicate with other processors or devices, e.g., the MCH . The host bus  may support a uni-processor or multiprocessor configuration. The host bus  may be parallel, sequential, pipelined, asynchronous, synchronous, or any combination thereof.","The MCH  provides control and configuration of memory and input\/output devices such as the system memory  and the ICH . The MCH  may be integrated into a chipset that integrates multiple functionalities such as the isolated execution mode, host-to-peripheral bus interface, memory control. The MCH  interfaces to the peripheral bus . For clarity, not all the peripheral buses are shown. It is contemplated that the system  may also include peripheral buses such as Peripheral Component Interconnect (PCI), accelerated graphics port (AGP), Industry Standard Architecture (ISA) bus, and Universal Serial Bus (USB), etc.","The system memory  stores system code and data. The system memory  is typically implemented with dynamic random access memory (DRAM) or static random access memory (SRAM). The system memory may include program code or code segments implementing one embodiment of the invention. The system memory includes a Common Warehouse Model (CWM) conversion system . Any one of the elements of the CWM conversion system  may be implemented by hardware, software, firmware, microcode, or any combination thereof. The system memory  may also include other programs or data that are not shown, such as an operating system. The CWM conversion system  may implement all or part of the CWM conversion functions. The CWM conversion system  may also simulate the CWM conversion functions. The CWM conversion system  contains instructions that, when executed by the processor , causes the processor to perform the tasks or operations as described in the following.","The ICH  has a number of functionalities that are designed to support I\/O functions. The ICH  may also be integrated into a chipset together or separate from the MCH  to perform I\/O functions. The ICH  may include a number of interface and I\/O functions such as PCI bus interface to interface to the peripheral bus , processor interface, interrupt controller, direct memory access (DMA) controller, power management logic, timer, system management bus (SMBus), universal serial bus (USB) interface, mass storage interface, low pin count (LPC) interface, etc.","The mass storage device  stores archive information such as code, programs, files, data, databases, applications, and operating systems. The mass storage device  may include compact disk (CD) ROM , a digital video\/versatile disc (DVD) , floppy drive , and hard drive , and any other magnetic or optic storage devices such as tape drive, tape library, redundant arrays of inexpensive disks (RAIDs), etc. The mass storage device  provides a mechanism to read machine-accessible media. The machine-accessible media may contain computer readable program code to perform tasks as described in the following.","The I\/O devices  to K may include any I\/O devices to perform I\/O functions. Examples of I\/O devices  to K include controller for input devices (e.g., keyboard, mouse, trackball, pointing device), media card (e.g., audio, video, graphics), network card such as Institute of Electrical and Electronics Engineers (IEEE) 802.3, IEEE-1394, IEEE-802.11x, Bluetooth, and any other peripheral controllers.","Elements of one embodiment of the invention may be implemented by hardware, firmware, software or any combination thereof. The term hardware generally refers to an element having a physical structure such as electronic, electromagnetic, optical, electro-optical, mechanical, electro-mechanical parts, etc. The term software generally refers to a logical structure, a method, a procedure, a program, a routine, a process, an algorithm, a formula, a function, an expression, etc. The term firmware generally refers to a logical structure, a method, a procedure, a program, a routine, a process, an algorithm, a formula, a function, an expression, etc., that is implemented or embodied in a hardware structure (e.g., flash memory, ROM, EROM). Examples of firmware may include microcode, writable control store, micro-programmed structure. When implemented in software or firmware, the elements of an embodiment of the present invention are essentially the code segments to perform the necessary tasks. The software\/firmware may include the actual code to carry out the operations described in one embodiment of the invention, or code that emulates or simulates the operations. The program or code segments can be stored in a processor or machine accessible medium or transmitted by a computer data signal embodied in a carrier wave, or a signal modulated by a carrier, over a transmission medium. The \u201cprocessor readable or accessible medium\u201d or \u201cmachine readable or accessible medium\u201d may include any medium that can store, transmit, or transfer information. Examples of the processor readable or machine accessible medium include an electronic circuit, a semiconductor memory device, a read only memory (ROM), a flash memory, an erasable ROM (EROM), a floppy diskette, a compact disk (CD) ROM, an optical disk, a hard disk, a fiber optic medium, a radio frequency (RF) link, etc. The computer data signal may include any signal that can propagate over a transmission medium such as electronic network channels, optical fibers, air, electromagnetic, RF links, etc. The code segments may be downloaded via computer networks such as the Internet, Intranet, etc. The machine accessible medium may be embodied in an article of manufacture. The machine accessible medium may include data that, when accessed by a machine, cause the machine to perform the operations described in the following. The machine accessible medium may also include program code embedded therein. The program code may include machine-readable code to perform the operations described in the following. The term \u201cdata\u201d here refers to any type of information that is encoded for machine-readable purposes. Therefore, it may include program, code, data, file, etc.","All or part of an embodiment of the invention may be implemented by hardware, software, or firmware, or any combination thereof. The hardware, software, or firmware element may have several modules coupled to one another. A hardware module is coupled to another module by mechanical, electrical, optical, electromagnetic or any physical connections. A software module is coupled to another module by a function, procedure, method, subprogram, or subroutine call, a jump, a link, a parameter, variable, and argument passing, a function return, etc. A software module is coupled to another module to receive variables, parameters, arguments, pointers, etc. and\/or to generate or pass results, updated variables, pointers, etc. A firmware module is coupled to another module by any combination of hardware and software coupling methods above. A hardware, software, or firmware module may be coupled to any one of another hardware, software, or firmware module. A module may also be a software driver or interface to interact with the operating system running on the platform. A module may also be a hardware driver to configure, set up, initialize, send and receive data to and from a hardware device. An apparatus may include any combination of hardware, software, and firmware modules.","One embodiment of the invention may be described as a process which is usually depicted as a flowchart, a flow diagram, a structure diagram, or a block diagram. Although a flowchart may describe the operations as a sequential process, many of the operations can be performed in parallel or concurrently. In addition, the order of the operations may be re-arranged. A process is terminated when its operations are completed. A process may correspond to a method, a program, a procedure, etc.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 2","FIG. 1"],"b":["45","45","203","202","204","202","202","206","45","45","206","208","206","210","45","45","210","212","210","45"]},"The CWM conversion system  processes a CWM representation in a hierarchical manner in order to transform the CWM representation into elements of a relational database. The CWM conversion system  processes the topmost (logical or physical) elements first. The high-level structure generated so far is outputted to the database design tool  or the DBMS . This sets up the framework for the output of the rest of the conversion of the CWM.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 3","FIG. 2"],"b":["300","300","206"]},"Process  scans through the ER libraries. For each of the ER libraries, that is being scanned, process  creates a corresponding design library in the relational database. For each of the ER models in the ER library being scanned, process  creates a corresponding design model in the corresponding design library to hold the corresponding information. Process  processes each of the ER models to produce the corresponding information for the corresponding design model. Process  processes each of the ER models independently of the other ER models. After all the ER models are processed, process  determines if there are any references between the ER models, that is, references across the boundaries of the ER models. If there are any such cross-model references, process  makes corresponding cross-model references in the corresponding design models then terminates. Detailed description of process  is as follows.","Upon Start, process  sets a first pointer to the first ER library (block ). Process  checks whether this ER library exists (block ). If it does not exist, process  checks whether there are any references between the ER models, that is, references across the boundaries of the ER models (block ). If there is no such cross-model reference, process  terminates. If there are any cross-model references, process  makes corresponding cross-model references in the corresponding design models (block ) then terminates. If the ER library being pointed to exists, process  creates a corresponding design library (). Process  sets a second pointer to the first ER model in the ER library (block ). Process  checks whether this ER model exists (block ). If it does not exist, process  increases the first pointer to point to the next ER library (block ) and goes back to block . If the ER model exists, process  creates a corresponding design model (block ). Process  processes the ER model (block ). This processing of the ER model is described in detail later in connection with  through . Process  then increases the second pointer to point to the next ER model (block ) and goes back to block .",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 4","FIG. 3"],"b":["400","316"]},"Upon Start, process  processes the ER subject areas included in the ER model (block ). Subject areas constitute a way of organizing the tables for understanding purposes (note that tables are only linked to the subject areas, not included therein). For this reason, subject areas can only exist in the logical aspects of the CWM, not in the physical aspects of the CWM. It is possible for a CWM to have no subject area. For this reason, the operation of process  in block  is optional. Block  is used only when the CWM includes subject areas. Process  processes the ER domains included in the ER model (block ). Process  processes domain inheritance for each of the ER domains (block ), then processes ER entities included in the ER model (block ). Process  processes the entity subtype relationships for each of the ER entities (block ), and processes the non-subtype relationships for each of the ER relationships (block ).",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 5","FIG. 4"],"b":["402","500"]},"Upon Start, process  sets a pointer to the first subject area in the ER model (block ). Process  checks whether the ER subject area exists (block ). If it does not exist, process  terminates. Otherwise, process  creates a corresponding design subject area to represent this ER subject area (block ). The design subject area includes all the properties of the ER subject area. Process  increases the pointer to point to next subject area in the ER model (block ) and goes back to block .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 6","FIG. 4"],"b":"404"},"Upon Start, process  points to the first ER domain in the ER model (block ). Process  checks whether this ER domain exists (block ). If it does not exist, process  terminates. Otherwise, process  creates a corresponding design domain to represent this ER domain (block ). Process  obtains the parameters for the ER domain, including the basetype, default and constraint (block ). Process  uses this information to set the corresponding parameters for the design domain (block ). Process  increases the pointer to the next ER domain (block ) and goes back to block .","It is noted that, domains in general and particularly those related to textual base types are sometimes placed in a separate ER model. Other ER models would reference this separate ER model if needed information are to be found there. This is an example of the cross-model references that need to be resolved after all the ER libraries have been processed (see block  of ).",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 7","FIG. 4"],"b":"406"},"Upon Start, process  sets a first pointer to the first ER domain in the ER model (block ). Process  checks whether the ER domain exists (block ). If it does not exist, process  terminates. Otherwise, process  sets a second pointer to the first CWM generalization that links this ER domain (block ). If there is no such generalization, process  increases the first pointer to point to the next ER domain (block ) and goes back to block . If there is such CWM generalization, process  determines which are the parent and child ER domains for this CWM generalization, that is, the ends of the link of which the ER domain in question represents one end (block ). The parent and child ER domains correspond to corresponding parent and child design domains in the relational database. To represent the generalization in the relational database, process  creates an inheritance link from the corresponding child design domain to the corresponding parent design domain (block ). This inheritance link in the relational database corresponds to the inheritance link in the CWM. Process  increases the second pointer to point to the next CWM generalization that links this ER domain (block ) and goes back to block .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 8","FIG. 4"],"b":"408"},"Upon Start, process  sets a pointer to the first ER entity in the ER model (block ). Process  checks whether there the ER entity exists (block ). If it does not exist, process  terminates. Otherwise, process  creates for this ER entity a corresponding design entity in the design model that corresponds to the ER model (block ). Process  obtains the list of all the ER subject areas that include this ER entity as a member (block ). The ER subject areas have corresponding design subject areas in the relational database. Process  adds the corresponding design entity as a member of the corresponding design subject areas (block ). Process  invokes process  to process the attributes associated with the ER entity (block ). Process  is shown in  and will be described in detail later. Process  increases the pointer to point to the next ER entity (block ) and goes back to block .",{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 9","FIG. 8"],"b":"810"},"Upon Start, process  sets a pointer to the first ER attribute specific to the ER entity (block ). Process  checks whether the ER attribute exists (block ). If it does not exist, process  terminates. Otherwise, process  creates a design attribute to represent the ER attribute (block ). Process  attaches the design attribute to the design entity (block ) that was created by process  (block  of ) to correspond to this ER entity. Process  sets the \u201ctype\u201d reference of the design attribute (block ) based on the \u201ctype\u201d reference of the ER attribute. Note that the \u201ctype\u201d reference of the ER attribute links the ER attribute to an ER domain. This ER domain in the CWM has a corresponding design domain in the relational database. By setting the \u201ctype\u201d reference of the design attribute, process  links the design attribute to this corresponding design domain. It is noted that the \u201ctype\u201d reference can point to either one of the design domains previously created or a basic data type supported by the database design tool.","Process  determines whether the ER attribute is part of the ER primary key associated with the ER entity (block ). If it is not part of the ER primary key, process  proceeds to block . If the ER attribute is part of the ER primary key, process  flags the design attribute as part of the design primary key associated with the design entity (block ). Process  then increases the pointer to point to the next ER attribute (block ) and goes back to block .",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 10","FIG. 4"],"b":"410"},"Upon Start, process  sets a pointer to the first CWM generalization that links the ER entities of this ER model (block ). Process  determines whether the CWM generalization exists (block ). If it does not exist, process  terminates. Otherwise, process  determines which are the parent and child ER entities for this generalization (block ). The parent and child ER entities correspond to corresponding parent and child design entities in the relational database. To represent this generalization in the relational database, process  creates an inheritance link from the corresponding child design entity to the corresponding parent design entity (block ). Process  increases the pointer to point to the next CWM generalization (block ) and goes back to block .",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 11A","FIG. 11B","FIG. 4"],"b":"412"},"Upon Start, process  sets a pointer to the first ER relationship in the ER model (block ). Process  checks whether the ER relationship exists (block ). If it does not exist, process  terminates. Otherwise, process  obtains the references to the parent and child ER entities for this ER entity non-subtype relationship (block ). The parent and child ER entities are represented by corresponding parent and child design entities in the relational database. To represent the ER non-subtype relationship in the relational database, process  creates links between the corresponding child design entity (or entities) and the corresponding parent design entity or entities (block ). Due to the wide diversity in database design tools, this link could be established directly as a two-way link or by the creation of a design relationship to which each of the involved design entities is linked. Process  sets the cardinality of the design relationship and sets the relationship type to \u201cidentifying\u201d or \u201cnon-identifying\u201d based on information stored as CWM \u201ctagged elements\u201d associated with the ER relationship (block ). The cardinality could be \u201c1 to 1\u201d or \u201c* to 1\u201d where * is an integer (can be zero). Process  examines the ends of this ER relationship to determine whether this ER relationship has any referential rule (block ). Referential rules are also called integrity constraints. If there is no referential rule, process  increases the pointer to point to the next ER relationship (block ) and goes back to block . Otherwise, process  proceeds to process the associated referential rule or rules ().","Referring to , process  obtains the values of the referential rules including \u201cInsert\u201d, \u201cUpdate\u201d, and \u201cDelete\u201d from the CWM (block ), then sets the values of the corresponding referential rules for the design link (or design relationship) that corresponds to the ER relationship (block ). Process  scans the child ER entity to determine whether any of the ER attributes of the child ER entity has migrated from the parent ER entity (block ). If there is none, process  goes back to block  () to process the next ER relationship. If there are ER attributes in the child ER entity that have migrated from the parent ER entity, then process  creates a design foreign key under the child design entity (block ). It is noted that only one foreign key is created for all the attributes that have migrated from the parent entity to the child entity. Process  creates references to the design attributes that correspond respectively to the ER attributes that have migrated (block ). Process  then goes back to block  () to process the next ER relationship. It is noted that all of the ER items identified above may have their own diagram and annotated text information attached to them. In such case, these diagrams and annotated text information are also stored for the corresponding design items.","The physical aspects of the CWM are processed differently than the logical aspects of the CWM. Instead of creating the corresponding elements in the output (DBMS) on the fly while simultaneously processing the CWM input, more of the CWM information is processed first before creating the output elements. The main reason for this is the \u201cobject-oriented\u201d nature of CWM as opposed to the \u201csequential, script-like\u201d process typically involved in working with a DBMS.","Data types are processed first, followed by the relational tables, views, indexes, triggers, and procedures. This is due to the fact that the columns in the latter elements have references to the data types.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 12","b":["1200","1200"]},"Process  scans through the relational catalogs. For each of the relational catalogs, that is being scanned, process  creates a corresponding DBMS catalog to be outputted to the DBMS. For each of the relational schemas in each of the relational catalogs, process  creates a corresponding DBMS schema in the corresponding DBMS catalog to hold the corresponding information. Process  processes each of the relational schemas to produce the corresponding information for the corresponding DBMS schema. Process  processes each of the relational schemas in the CWM independently of the other relational schemas. Detailed description of process  is as follows.","Upon Start, process  sets a first pointer to the first relational catalog (block ). Process  checks whether this relational catalog exists (block ). If it does not exist, process  terminates. Otherwise, process  creates a corresponding DBMS catalog (). Process  sets a second pointer to the first relational schema in the relational catalog (block ). Process  checks whether this relational schema exists (block ). If it does not exist, process  increases the first pointer to point to the next relational catalog (block ) and goes back to block . If the relational schema exists, process  creates a corresponding DBMS schema (block ). Process  processes the relational schema (block ). This processing of the relational schema is described in detail later in connection with  through . Process  then increases the second pointer to point to the next relational schema (block ) and goes back to block .",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 13","FIG. 12"],"b":["1300","1216"]},"Upon Start, process  processes CWM data types included in the CWM (block ). Process  creates DBMS data types corresponding to the CWM data types (block ). Process  processes relational tables included in the relational schema (block ). Process  processes relational foreign key relationships for each of the relational tables (block ). Process  processes the checkconstraints for the relational schema (block ). Process  creates the DBMS tables corresponding to the relational tables (block ). Process  processes the relational views for the relational schema (block ). Process  processes the relational indices for the relational schema (block ). Process  processes the relational triggers for the relational schema (block ). Process  processes the relational procedures for the relational schema (). Process  then terminates.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 14","FIG. 13"],"b":["1400","1302","1400"]},"Upon Start, process  sets pointer to the first CWM data type (block ). Process  determines whether the CWM data type is a default data type, i.e., matches with a DBMS-provided data type, or a user-defined data type (block ). A user-defined data type has a base type (which should match one of the default DBMS-provided data types) and at least one rule or constraint. If the CWM data type is user-defined, process  obtains the base type and the constraint(s) (block ). A constraint is also called a rule. A data type can be dates, numbers, text, or Boolean. Process  checks whether the CWM data type is text (block ). If it is not, process  proceeds to block . Otherwise, process  obtains the character set, name of language and collation sets associated with the CWM data type (block ). The name of language and the collation sets together define textual characteristics and sorting order. Process  then increases the pointer (block ). Process  determines if there is another CWM data type from the list of data types to be processed (block ). If there is, process  loops back to block . Otherwise, process  specifies the default character set for the DBMS output (block ) then terminates.","It is noted that it is usually not possible to add character sets to a DBMS. If the DBMS supported character sets are more limited than what is required, the default character set or a closely related character set will be used instead.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 15","FIG. 14","FIG. 14"],"b":["1500","1500","1502","1504","1500","1500","1506","1500","1406","1508","1406","1500","1510","1504"]},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 16","b":"1600"},"Upon Start, process  sets a first pointer to the first element of the list of relational tables in the relational schema being considered (block ). Process  determines whether the relational table exists (block ). If it does not exist, process  terminates. Otherwise, process  sets a second pointer to the first column of this relational table (block ). Process  obtains the properties of the column (block ). These properties include the type, precision, scale, length, IsNullable, CollationName, and CharacterisetName. Process  verifies that the type of this column matches one of the existing DBMS data types (block ) which include the default DBMS-provided data types and the user-defined DBMS data types previously created by process  (). Note that, if the type of this column does not match an existing DBMS data types, process  would flag an error. The relational table has a relational primary key. Process  determines whether this relational column is part of the relational primary key (block ). If it is not, process  proceeds to block . If the relational column is part of the relational primary key, process  flags this column to so indicate (). Process  then increases the second pointer (block ) and checks whether such column exists (block ). If the column exists, process  goes back to block  and proceeds as previously described. Otherwise, process  increases the first pointer to point to the next relational table (block ) and goes back to block  to process this next relational table.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 17","b":["1700","1700","1700","1700","1700","1700"]},"Upon Start, process  sets a first pointer to the first element in the list of the child relational tables (block ). Process  determines whether this is a child relational table (block ). If it is not, process  terminates. Otherwise, process  sets a second pointer to the first column of the child relational table (block ). Process  obtains the properties of this relational column, including the \u201cupdate\u201d and \u201cdelete\u201d referential integrity rules and deferability type (block ). Process  increases the second pointer to point at the next column (block ). Process  checks whether this column exists (block ). If the column exists, process  goes back to block  and proceeds as previously described. Otherwise, process  increases the first pointer to point to the next child relational table (block ) and goes back to block  to process the next foreign key relationship, that is, the next child relational table.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 18","b":["1800","1800","1800","1800","1800"]},"Upon Start, process  sets pointer to the first element of the list of relational checkconstraints (block ). Process  checks whether the checkconstraint exists (block ). If there is no checkconstraint, process  terminates. Otherwise, process  obtains the parameters that describe and are associated with this checkconstraint (block ). Process  enumerates all the relational columns that have constrained element references to this checkconstraint (block ). These are the relational columns that are operated on by this checkconstraint. The checkconstraint has pointers to the relational columns that it affects. Process  increases the pointer to the next element in the list of relational checkconstraints (block ) and goes back to block .",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 19A","FIG. 19B","FIG. 17"],"b":["1900","1900","1900","1900"]},"Upon Start, process  set the pointer to the first relational table of the list of relational tables of the relational schema (block ). Process  checks whether this relational table has any dependency on any other tables in the list (block ). If it has, process  proceeds to block . If it has no dependency on other relational tables, process  creates a corresponding DBMS table and flags this relational table to indicate that it has been selected (block ) and proceeds to block . Process  increases the pointer to point to the next element in the list of relational tables (block ). Process  checks whether this relational table exists (block ). If it exists, meaning the end of the list has not been reached, process  goes back to block . If it does not exist, process  sets the pointer to the first unflagged relational table (block ). Process  initializes counter and counter to zero (block ). Process  checks whether the unflagged relational table exists (block ). If it does not exist, process  terminates.","If the unflagged relational table exists, process  creates a corresponding DBMS table, flags this previously unflagged relational table, and increases counter by 1 (block ). Counter is used to keep count of the number of DBMS tables created during this phase of process . Process  increases the pointer to point to the next unflagged relational table (block ). Process  checks whether this unflagged relational table exists (block ). If it does exists, process  goes back to block . If it does not exists, this means the first iteration through the list of relational tables is complete. Process  checks whether counter is strictly greater than counter (block ). If counter is strictly greater than counter, this means that there were DBMS tables created during the iteration. In this case, process  sets counter equal to counter, so that a comparison can be made for the next iteration (block ). Process  resets the pointer to the first unflagged relational table (block ), and goes back to block .","If counter is not strictly greater than counter, this means that no DBMS table was created during the iteration. This means that there is no relational table left in the list that depends only on at least one of the previously flagged tables. Process  resets the pointer to the first unflagged relational table (block ). Process  checks whether this unflagged relational table exists (block ). If it does not exist, process  terminates. Otherwise, process  creates a corresponding DBMS table using forward references (block ). Process  increases the pointer to the next unflagged relational table (block ), then goes back to block .",{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIG. 20A","FIG. 20B","FIG. 20"],"b":["2000","2006","2000"]},"Upon Start, process  creates a DBMS table (block ). This can be done by, for example, issuing a script \u201ccreate table\u201d statement. Process  sets pointer to the first column of the relational table (block ). Process  creates a DBMS column to represent this relational column (block ). Process  sets the properties, including precision, scale, length, data type, IsNullable, CollationName, and CharacterisetName for the newly created DBMS column in accordance with the respective properties of the corresponding relational column (block ).","Process  queries whether this relational column is (1) neither a primary key nor a foreign key, or (2) part of the primary key or foreign key but not the only one representing the primary key or foreign key, or (3) the only column that represents the primary key or foreign key (block ). If it is (1) neither a primary key nor a foreign key, process  proceeds to block . If it is (2) part of the primary key or foreign key but not the only one representing the primary key, process  flags the DBMS column to so indicate (block ) then proceeds to block . If it is (3) the only column that represents the primary key or foreign key, then process  specifies this property of \u201cprimary key\u201d or \u201cforeign key\u201d for the DBMS column (block ) and proceeds to block . Process  specifies a DBMS primary key by specifying the properties of the DBMS primary key in accordance with the properties of the relational primary key as stored in the CWM. Process  specifies a DBMS foreign key by specifying the \u201cchild\u201d DBMS table and the DBMS columns of this child DBMS table that are being imported, and specifies the properties of DBMS foreign key, including the \u201cupdate\u201d and \u201cdelete\u201d referential integrity rules and the deferability type, in accordance with the properties of the corresponding relational foreign key.","Process  queries whether there is any checkconstraint associated with this relational column (block ). The result of this query can only be one of the following: (1) there is no checkconstraint associated with this relational column, (2) there is a checkconstraint(s) associated with this relational column that does not involve any of the other relational columns, (3) there is a checkconstraint(s) associated with this relational column that also involves one or more of the other relational columns. If the query result is (1), process  proceeds to block  (). If the query result is (2), the process  specifies the checkconstraint(s) at column-level in the DBMS column (block ) then proceeds to block . Process  specifies a checkconstraint by specifying the parameters, i.e., the constraint expressions that describe the checkconstraint. If the query result is (3), process  flags the DBMS column to so indicate (block ) then proceeds to block . Process  increases the pointer to the next column of the relational table (block ). Process  checks whether the column exists (block ). If the column exists, process  goes back to block  and proceeds as previously described.","If the relational column does not exist, this means that all the necessary DBMS columns have been created. Process  checks whether there is any checkconstraint(s) that involves multiple columns of the relational table, which consequently, involves multiple columns of the corresponding DBMS table (block ). If there is none, process  proceeds to block . Otherwise, process  specifies the checkconstraint(s) at the table level in the DBMS table and identifies the DBMS columns that are associated with this checkconstraint (block ), then proceeds to block . Process  checks whether there is a multi-column primary key or a multi-column foreign key in the relational table (block ). If there is none, process  terminates. Otherwise, process  specifies the multi-column primary key or the multi-column foreign key in the DBMS table at table level and identifies the DBMS columns that represent the multi-column primary key or the multi-column foreign key (block ). Process  then terminates.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 21","b":["2100","2100"]},"Upon Start, process  sets a pointer to the first element in the list of relational views (block ). Process  checks whether this relational view exists (block ). If it does not exist, process  terminates. If it exists, process  creates a DBMS view to represent this relational view (block ). A relational view has two properties, namely, query expression and updatability. Query expression defines the relational view and is the main property of the relational view. Updatability is based on the IsReadOnly property. Process  reads the query expression of the relational view and specifies the query expression for the DBMS view accordingly (block ). Process  reads the updatability of the relational view and specifies the updatability for the DBMS view accordingly (block ). Process  increases the pointer to point to the next relational view (block ), checks whether this next relational view exists (block ) and proceeds as previously described.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 22","b":["2200","2200"]},"Upon Start, process  sets a pointer to the first element in the list of relational indices (block ). Process  checks whether this relational index exists (block ). If it does not exist, process  terminates. If it exists, process  creates a DBMS index to represent this relational index (block ). This relational index uses certain relational columns. Process  specifies all the DBMS columns that correspond to these relational columns (block ). Process  sets the parameters for the DBMS index, including IsNullable, FilterCondition, and AutoUpdate parameters, in accordance with the parameters of the relational index (block ). Process  increases the pointer to point to the next relational index (block ), checks whether this next relational index exists (block ) then proceeds as previously described.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 23","b":["2300","2300"]},"Upon Start, process  sets a pointer to the first element in the list of relational triggers (block ). Process  checks whether this relational trigger exists (block ). If it does not exist, process  terminates. If it exists, process  creates a DBMS trigger to represent this relational trigger (block ). The relational trigger's properties are described by parameters. The parameters specify when the relational trigger is invoked and what action is to be taken when it is invoked. Process  sets the parameters for the DBMS trigger that corresponds to the relational trigger in accordance with the relational triggers parameters (block ). The relational trigger monitors a specific relational table that corresponds to a specific DBMS table. Process  sets this specific DBMS table for the DBMS trigger, i.e., provides the DBMS trigger with a link to this DBMS table (block ). Process  increases the pointer to point to the next relational trigger (block ), checks whether this next relational trigger exists (block ) and proceeds as previously described.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 24","b":["2400","2400"]},"Upon Start, process  sets a pointer to the first element in the list of relational procedures (block ). Process  checks whether this relational procedure exists (block ). If it does not exist, process  terminates. If it exists, process  creates a DBMS procedure to represent this relational procedure (block ). The relational procedure is described by a set of arguments. Process  sets the arguments for the DBMS procedure in accordance with the arguments of relational procedure (block ). Process  increases the pointer to point to the next relational procedure (block ), checks whether this next relational procedure exists (block ) then proceeds as previously described.","While certain exemplary embodiments have been described in detail and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive on the broad invention. It will thus be recognized that various modifications, such as those mentioned above, may be made to the illustrated and other embodiments of the invention described above, without departing from the broad inventive scope thereof. It will be understood, therefore, that the invention is not limited to the particular embodiments or arrangements disclosed, but is rather intended to cover any changes, adaptations or modifications which are within the scope and spirit of the invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The features and advantages of the present invention will become apparent from the following detailed description of the present invention in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 2","FIG. 1"],"b":"45"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3","b":"300"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 4","FIG. 3"],"b":["400","316"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 5","FIG. 4"],"b":"402"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 7","FIG. 4"],"b":"406"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 8","FIG. 4"],"b":"408"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 9","FIG. 8"],"b":"810"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 10","FIG. 4"],"b":"410"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 11A","FIG. 11B","FIG. 4"],"b":"412"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12","b":"1300"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 13","FIG. 12"],"b":["1300","1216"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 14","FIG. 13"],"b":["1400","1302"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15","b":"1500"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16","b":"1600"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 17","b":"1700"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 18","b":"1800"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 19A","FIG. 19B"],"b":"1900"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 20A","FIG. 20B"],"b":"2000"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 21","b":"2100"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 22","b":"2200"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 23","b":"2300"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 24","b":"2400"}]},"DETDESC":[{},{}]}
