---
title: Apparatus and methods for copying, backing up and restoring logical objects in a computer storage system by transferring blocks out of order or in parallel
abstract: Method and apparatus are disclosed for copying and backing up logical objects in a computer storage system. The logical objects are comprised of data blocks. The data blocks may be copied in any order. The data blocks may be copied or written from a storage media, such as a tape, in parallel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06920537&OS=06920537&RS=06920537
owner: EMC Corporation
number: 06920537
owner_city: Hopkinton
owner_country: US
publication_date: 20020717
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","DISCUSSION OF THE RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/223,897, filed Dec. 31, 1998 now abandoned, entitled Apparatus and Methods for Copying, Backing Up and Restoring Logical Objects in a Computer Storage System by Transferring Blocks Out of Order or in Parallel.","This invention relates to data storage for computers, and more particularly to an apparatus and methods for copying, backing up and restoring logical objects in a computer storage system by transferring blocks out of order or in parallel.","Virtually all computer applications (or programs) rely on storage. This storage can be used for both storing the computer code and for storing data manipulated by the code. (The term \u201cdata\u201d refers to any information, including formatting information, executable code and data for manipulation by an application program.)","Storage technology has developed in a variety or different directions. Accordingly, a wide variety of storage systems are available. It has become impractical, therefore, for the person writing the computer application to also be responsible for detailed control over how data is stored on the storage system.","For this (and other) reasons, application programs typically run on an operating system (e.g., Unix, Windows, MS DOS, Linux, and the many variations of each). Once again, however, the operating system may be used with a variety of storage systems.","It would be highly inefficient to have to change the operating system, or the application programs, every time a change is made to physical storage. As a result, various layers of abstraction have evolved for viewing how data is actually stored in the storage system.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1","b":"10"},"The application level  interfaces with the file system level . The file system level is concerned with how files are stored on disks and how to make everything work efficiently and reliably. Thus, the file system level may be responsible for storing directory structure, and for breaking up files into constituent data blocks for storage onto a physical storage system. For example, in most implementations of Unix, each file has an associated I-node. This node may contain accounting and protection information and, additionally, a set of pointers to data blocks.","Relatively early in the development of computer systems, disk drives became a fundamental device for storage. Accordingly, computer operating systems have been developed assuming that memory will rely on input\/output (\u201cI\/O\u201d) to a disk drive. The file system , therefore, may assume one or more \u201cvolumes\u201d which correspond to a physical storage unit such as a disk drive (or any other unit of storage), with data stored in blocks on the disk drive.","The demand for storage to be available for use by applications has sky rocketed. As a result, a number of separate physical devices may be required to accommodate the total amount of storage required for a system. In addition, storage systems are often changed or reconfigured.","To insulate the operating system from any changes within the physical device storage system, some mechanism is often employed to flexibly map a standard (volume) view of physical storage onto an actual physical storage system. The logical volume manager (\u201cLVM\u201d)  of  can help achieve this function by mapping the file system view of data storage into an intermediate layer.","Finally, the actual storage reading and writing (and, potentially, additional mapping onto physical storage devices) occurs within the physical storage system level , as illustrated in FIG. . Thus, for example, the logical volume manager may map the file system level view of data into volume sizes corresponding to fixed physical storage segment sizes for storage on a physical device (e.g, block sizes). The physical storage system level may then map the logical volume manager level volumes onto physical storage segments (e.g., hyper-volumes discussed below).","Logical volume managers have been implemented for use with the HP-UX by HP and by VERITAS operating systems, as examples. The Symmetrix line of storage systems, available from EMC Corporation, of Hopkinton, Mass., is one system capable of mapping hyper-volumes onto physical devices. (The Symmetrix product line of integrated cached disk arrays is described in numerous publications form EMC Corporation, including the Symmetrix model 55xx product manual, p-n200-810-550,rev.f, Feb., 1996.)","In the above examples, the mapping of application level data into actual physical storage occurs across four levels: application level to file system level; file system level to LVM level; LVM level to physical storage system level; and physical storage system level to the actual physical storage devices. More or fewer levels of mapping can be done. In some systems, for example, only one level of mapping is performed, e.g., mapping from the application level directly onto actual physical storage devices. In many systems, the mapping stage at the LVM level is omitted. Similarly, in many systems, no mapping is done at the physical storage level (e.g., data is stored directly onto actual devices corresponding to the format of the preceding level and without any further mapping onto physical storage components.)",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2A","b":["14","16","20","21","22","12","20","22","10","12","12"]},"As far as the file system level is concerned, the virtual volumes may be divided up into \u201cpartitions,\u201d which are continuous segments of storage. These partitions are, in fact, \u201cvirtual\u201d partitions, because the partition may actually be stored across a variety of physical storage segments (e.g., hyper-volumes).","In , the data is physically stored on the physical storage devices -. In this particular example, although there are three physical devices - and three volumes -, there is not a one to one mapping of the virtual volume to physical devices. In this particular example, the data in volume A  is actually stored on physical devices -, as indicated at ,and .In this example, volume B is stored entirely on physical device , as indicated at ,.Finally, volume C is stored on physical device  and physical device  as indicated at ,","In this particular example, the boxes -,-and -represent contiguous segments of storage within the respective physical devices -. These contiguous segments of storage may, but need not, be of the same size. The segments of storage may be referred to as \u201chyper-volumes,\u201d and correspond to segments of physical storage that can be used as components when constructing a virtual volume for use by the file system. A hypervolume may be comprised of a number of \u201cdata blocks.\u201d A data block is a unit of storage (e.g., a 512 byte block) that is written or read at one time from the physical storage device.","Array management software running on a general purpose processor (or some other mechanism such as a custom hardware circuit)  translates requests from a host computer (not shown) (made assuming the logical volume structure -) into requests that correspond to the way in which the data is actually stored on the physical devices -. In practice, the array management software  may be implemented as a part of a unitary storage system that includes the physical devices -, may be implemented on a host computer, or may be done in some other manner.","In  the array management software  performs the functions of both the logical volume manager  (if present) and the physical storage level , by mapping the file system's virtual volumes - into segments that can be stored onto physical devices -. The array management software  also performs the functions of the physical storage system level , by determining where to store the hyper-volumes A-C, A-B and A-B.","The physical storage devices shown in the example of  are disk drives. A disk drive may include one or more disks of a recording media (such as a magnetic recording medium or an optical recording medium). Information can be written and read from this storage medium for storage purposes. The recording medium is typically in the form of a disk that rotates. The disk generally includes a number of tracks on which the information is recorded and from which the information is read. Each track may include more than one \u201cdata block.\u201d A data block is a unit of data that can be read as a single unit. A data block may be a 512 by the block of data, an 8 k segment on a 32 k track, or some other structure. In these examples, the size of the block is fixed. In other cases, the block may be of variable size, such as a CKD record. In a disk drive that includes multiple disks, the disks are conventionally stacked so that corresponding tracks of each disk overlie each other. In this case, specification of a single track on which information is stored within the disk drive includes not only specification of an individual track on a disk, but also which of the multiple disks the information is stored on.","To identify an individual data block, an address may include a specification of the disk, (which may consist of several \u201cplatters\u201d), a specification of the track within the disk (or \u201ccylinder\u201d), a specification of the head (or which of the platters comprising the \u201cdisk\u201d) and a specification of the particular data block within the track. The specification of the position of the data block within the track may, for example, be addressed as an offset, e.g., this is the third data block appearing on the track. Thus, an address of ddcccch:offset may specify a block\u2014disk dd, cylinder cccc, head h and the specified offset. The physical storage devices for use with the present invention may, however, be formed in any other geometry, addressed in any other manner or even constitute a different type of storage mechanism.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2B","b":"200"},"When the application level file is mapped onto physical storage, the application level file may be converted into segments of the individual bits, e.g., segment . Thus, a segment of the application level file  is mapped (for example according to the general mapping structure described above with reference to ) onto actual physical storage devices -. In this example, the first segment of bits in  in the application level file  is mapped onto physical storage device , at a portion  of the physical storage device . As shown in , the individual segments of bits in the application level file  may be mapped anywhere among a plurality of actual physical storage devices. The granularity of the segments of bits (e.g., segment ) may correspond to one of a variety of different levels. For example, the granularity of the segments may be a 512 byte data block. In another embodiment, the granularity may correspond to the amount of data stored in a track of the physical storage device - (when the physical storage devices are disk drives).",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2C","b":["27","27","27","27","27"],"i":["a","f","a","f "]},"In the example of , the logical object is stored on a physical storage device . In this example, the storage device includes a number of columns, each representing a track of a disk.","Each row of the physical storage device represents a physical data or block element within the applicable column\/track. For example, row ,column ,stores a data block corresponding to the logical block element . Track would store physical data blocks that have the contents of logical block elements and . As can be seen from , the logical block elements can be stored in any order on the physical devices.","While the physical storage device  is illustrated as a contiguous array, this need not be the case. For example, each of the tracks, such as column ,may be stored on a different disk drive or be part of a different hypervolume.","In a system including an array of physical disk devices, such as disk devices - of , each device typically performs error detection and\/or correction for the data stored on the particular physical device. Accordingly, each individual physical disk device detects when it does not have valid data to provide and, where possible, corrects the errors. Even where error correction is permitted for data stored on the physical device, however, a catastrophic failure of the device would result in the irrecoverable loss of data.","Accordingly, storage systems have been designed which include redundant storage capacity. A variety of ways of storing data onto the disks in a manner that would permit recovery have developed. A number of such methods are generally described in the RAIDbook, A Source Book For Disk Array Technology, published by the RAID Advisory Board, St. Peter, Minn. (5th Ed., Feb., 1996). These systems include \u201cRAID\u201d storage systems. RAID stands for Redundant Array of Independent Disks.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3A","b":["31","33","1","31","31","32","32","33","33","31","32","33","1"],"i":["a ","a ","a ","a","a ","a "]},"In a mirror group, the copies are \u201clinked.\u201d That is, any update to one mirror causes an update to each other mirror in the group.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3A","b":["31","33"]},"\u201cRAID \u201d is an example of data redundancy through mirroring of data. In a RAID  architecture, a number of different mechanisms may be used for determining how to access and update data to improve, for example, performance of the storage system. In any event, a RAID  architecture certainly has the ability to recover lost data. Unfortunately, the RAID  architecture multiplies the cost of physical storage by the number of \u201cmirrors\u201d included in the mirror group.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 3B","FIG. 3B"],"b":["34","34","33","1","35","35","1","1","2"],"i":["a","d","a","b"]},"A variety of mechanisms are known for distributing the parity information on the physical devices. In the example shown in , all of the parity information is stored on a single physical device . In other cases, the parity information may be distributed across the physical devices.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 4","FIG. 4"],"b":["40","42","44","44","40","42"]},"In , a single virtual volume is stored on the fourth physical device , without any redundancy information, as indicated at .","Finally, a last group of data segments , on all four physical devices -, implement a parity redundancy scheme. In this particular example, the parity information is stored in segments of memory on two different physical devices -, as indicated at and ","The storage system of  contains redundant information that permits recovery from errors, including use of a mirror for data located at a remote facility, that also permits recoveries from catastrophic failure.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5","FIG. 5"],"b":["50","52","50","52","50","56"]},"A backup storage system  is also attached to the network . The backup storage system  includes a backup storage device (which may be disk drives, tape storage or any other storage mechanism), together with a system for placing data into the storage and recovering the data from that storage.","To perform a backup, the client  copies data from the storage system  across the network  to the backup storage system . This process can be explained in greater detail with reference to FIG. . The storage system  may correspond to the actual physical storage  of FIG. . For the client  to write the backup data over the network  to the backup storage system , the client  first converts the backup data into file data\u2014i.e. gets the data from the physical storage system level , and converts the data into application level format (e.g. a file) through the logical volume manager level , the file system level  and the application level . Thus, an actual data file may be communicated over the network  to the backup storage device . When the backup storage device  receives the data file, the backup storage system  can take the application level  data file, convert it to its appropriate file system level  format for the backup storage system, which can then be converted through a logical volume manager  level and into physical storage .","This form of backing up data may be referred to as \u201clogical-logical\u201d backup. That is, the logical data is backed up on the backup storage device . The data to be backed up is presented independent of the manner in which it is physically stored on storage system  at the physical storage system level , independent of the file system level mechanisms on the client , and independent of how data is stored on the backup storage device .","The EDM (EMC Data Manager) line of products is capable of logical-logical backup over a network, as described in numerous publications available from EMC, including the EDM User Guide (Network) \u201cBasic EDM Manual\u201d.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 6","FIG. 6"],"b":["60","52","54","60","56","60"]},"While the method and apparatus of the present invention may be described with reference to the systems and concepts described above and in the discussion of the related art, this is not intended to be limiting. The present invention has broader application. Certain aspects of the invention may be applied to any storage system. Accordingly, the invention is only limited by the claims set forth below.","Whether the restore and backup process is done at a logical level or at a physical level, backups in the prior art require copying a complete file (or in some instances even more, such as an entire partition) for the backup. Methods of backing up and restoring data on the system of  are described in co-pending and commonly owned U.S. patent application Ser. No. 09\/052,579, entitled \u201cLogical Restore From A Physical Backup In A Computer Storage System,\u201d filed Mar. 31, 1998, and naming John Deshayes and Madhav Mutalik as inventors, and which is hereby incorporated herein by reference in its entirety.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["70","52","6","50","71","50","71","70","6"]},"Within the storage system  is a host adapter . In this particular embodiment, the host adapter  is responsible for managing and translating read and write requests from the host computer (e.g., client  or backup storage system ), which are based on the virtual disk structure (e.g., from the file system or logical volume manager level), into one or more requests corresponding to how data is stored on the actual physical storage devices -of the storage system . Thus, in this embodiment, the host adapter  implements at least some of the array management software  functions of FIG. . The host adapter  can be implemented in any of a number of ways, including using a general purpose processor or a custom hardware implementation. In addition, multiple host adapters may be included to facilitate having additional I\/O channels for the storage system .","The host adapter  communicates with the other components of the storage system  using bus . The bus  may be any suitable communication element, including use of SCSI, ESCON, and other bus protocols.","Access to the physical storage devices -is controlled through the use of disk adapters -. The disk adapter -can also be implemented using a general purpose processor or custom hardware design. In the embodiment illustrated in , a disk adapter is provided for each physical storage device. A disk adapter can, of course, have more than one storage device attached to it. In addition, disk adapters may include secondary connections to the physical storage devices of another disk adapter. This permits recovery from failure of one disk adapter by shifting its functions to the second disk adapter.","In the embodiment of , reading and writing to the physical storage device -through the disk adapters -is facilitated through use of a cache . The cache  may be a random access memory having greater speed than the disk drives. When reading data, if the data is being temporarily stored in the cache, the read request can be fulfilled more quickly by taking the data from the cache . Similarly, when writing data, the data to be written can be stored in the cache. The other components of the system can proceed, while the data is written from the cache to the applicable physical storage device.","Any of a variety of mechanisms can be used to implement and manage the cache. An example of such a mechanism is included in U.S. Pat. No, 5,537,568, entitled \u201cSystem for dynamically controlling cache manager maintaining cache index and controlling sequential data access,\u201d issued on Jul. 16, 1996. Similarly, writes may be accomplished through the cache using any of a variety of mechanisms and strategies. One mechanism for writing from the cache is to store the data to be written in the cache, and mark a \u201cwrite pending\u201d bit. When the write pending bit is encountered, the applicable data can be written to the disk. This technique is described generally in U.S. Pat. No. 5,341,493, entitled \u201cDisk storage system with write preservation during power failure,\u201d issued on Aug. 23, 1994.","The cache may be divided into more than one area. For example, the cache may include an area for storing data being read or written from physical storage devices -. The cache may further include a \u201cmailbox\u201d area . The mailbox area may be used to facilitate communications among the disk adapters -and with the host adapter . For example, each disk adapter may have its own area within the mailbox . Each of the disk adapters -can post or read information from the applicable mailbox area , to communicate status and other information.","A remote adapter  may also be attached to the bus  of the storage system . The remote adapter may be employed for communication with remote data facilities (\u201cRDF\u201d), for example, connection to another storage device to maintain a mirror redundancy group. One form of RDF link and method of implementation is described in various publications available from EMC Corporation, including SYMMETRIX Remote Data Facility Product Manual, P\/N 200-999-554, rev. B, June 1995. RDF embodiments are also described in U.S. Pat. No. 5,544,347 (Yanai) which is hereby incorporated herein by reference in its entirety. It should be appreciated, however, that the present invention is not limited to the use of RDF or to a system that employs SYMMETRIX disk arrays, and can be employed with any of numerous other types of storage systems.","A service processor  may be coupled to the bus  of the storage system . The service processor  may include a display, keyboard and other I\/O devices to permit an operator to use the service processor  for configuring the components of the storage system  and for running or initiating diagnosis and maintenance facilities.","According to one embodiment of the present invention, a computer system is disclosed. According to this embodiment, the computer system includes a host domain that has at least one host computer. The computer system also includes a storage domain, coupled to the host domain, that comprises a plurality of primary storage devices, a secondary storage device and a switched network coupled to the primary storage nodes and to the secondary storage node.","According to another embodiment of the present invention, a computer system is disclosed that includes a plurality of host computers, each of the host computers constituting a different platform. The computer system further includes a plurality of primary storage devices, each being associated with at least one of the host computers. The system also includes a secondary storage device, coupled to a plurality of the primary storage devices, the secondary storage device being configured to receive backup data from each of the host computers.","According to another embodiment of the present invention, a method of transferring data from a primary storage node to a secondary storage node is disclosed. According to this embodiment, a connection is automatically established from one of the primary storage elements to a secondary storage element, for transferring data to the secondary storage element. Data is transferred from the primary storage element directly to the secondary storage element over the first connection.","According to another embodiment of the present invention, a method of sending a copy of data from a storage element of a computer system is disclosed. According to this embodiment, the data is first formulated into an abstract block set. The abstract block set is transmitted. In this and other embodiments, the steps of formulating and transmitting may be performed sequentially or concurrently.","According to another embodiment of the present invention, a method of storing a logical object is disclosed. According to this embodiment, the logical object is formulated into an abstract block set and stored.","According to another embodiment of the present invention, a storage device is disclosed. According to this embodiment, the storage device includes a memory and means for transmitting an abstract block set from the memory.","According to another embodiment of the present invention, a secondary storage system is disclosed. According to this embodiment, the secondary storage system includes a secondary storage media and means for storing an abstract block set on the secondary storage media.","According to another embodiment of the present invention, a computer readable media storing a logical object is disclosed. According to this embodiment, the media includes a plurality of data blocks, each storing on the readable media a portion of data from the logical object, and a metadata segment, stored on the readable media, to identify the order of data blocks in the logical object.","According to another embodiment of the present invention, a method of generating a backup for a logical object is disclosed. According to this embodiment, data blocks of the logical object that have changed since an earlier point in time are identified. The identified data blocks are stored as a differential abstract block set.","According to another embodiment of the present invention, a storage device is disclosed. According to this embodiment, the storage device includes a memory, means for identifying data blocks that have changed since an earlier point in time and means for transmitting a differential abstract block set from the memory.","According to another embodiment of the present invention, a method of forming an updated abstract block set is disclosed. According to this embodiment, a full abstract block set is provided. A differential abstract block set is also provided. The full abstract block set and the differential abstract block set are combined to form the updated abstract block set.","According to another embodiment of the present invention, a method of forming an updated backup of a logical object is disclosed. According to this embodiment, a first backup of the logical object is provided. A differential backup of the logical object is also provided, the differential backup including a plurality of backup data blocks that have changed since the first backup was formed. The backup data blocks are added to the first backup and metadata identifying an order of data blocks in the updated backup is added.","According to another embodiment of the present invention, a secondary storage device is disclosed. According to this embodiment, the storage device includes a secondary storage media and a controller programmed to combine a first backup and a differential abstract block set to form a full abstract block set.","According to another embodiment of the present invention, a method of copying a logical object is disclosed. According to this embodiment, a set of storage segments of a computer storage device are identified, each of the identified segments including data from at least one physical block of a logical object. The identified storage segments are copied. According to this embodiment, at least one of the copied storage segments includes a plurality of the physical data blocks. Thus, the size of the storage segment is not necessarily the same as the size of individual physical data blocks.","According to another embodiment of the present invention, a method of creating a backup of a logical object is disclosed. According to this embodiment, a set of backup segments is received, each backup segment including at least one physical block of a logical object. The received storage elements are stored, at least one of the storage segments including a plurality of the physical data blocks.","According to another embodiment of the present invention, a computer readable media storing a backup copy of a logical object is disclosed. According to this embodiment, a plurality of data segments are stored on the readable media, each data segment including at least one datablock of the logical object, and at least one of the data segments including a plurality of the logical data blocks. This embodiment further includes a metadata segment, stored on the readable media, to identify data blocks of the logical object in the data segments. In this embodiment, the data segment may, for example, be a track including a plurality of fixed size blocks.","According to another embodiment of the present invention, a computer storage system is disclosed. According to this embodiment, the system includes a computer storage device that includes a plurality of physical storage segments (which, in one embodiment, is a track) each storing at least one datablock. The system further includes means for identifying a set of storage elements, each storage segment of the set including at least one physical block of a logical object and means for transmitting the identified storage segments.","According to another embodiment of the present invention, a method of backing up a logical object at a fixed point in time is disclosed. According to this embodiment, a set of storage segments that include logical data blocks of the logical object are identified. These storage segments are copied to a backup storage device, out of order from the order of storage segments or logical data blocks appearing in the logical object. During the copying step, if a storage segment that includes a physical block of the logical object is to be modified, that storage segment is immediately backed up. In this and other embodiments, the storage segments may (but need not) correspond in size to the size of data blocks.","According to another embodiment of the present invention, a computer storage system is disclosed. According to this embodiment, the system includes a computer storage device that has a plurality of storage segments. The system further includes means for identifying a set of the storage segments that includes logical objects, logical data blocks; means for copying the identified storage segments, out of order from the order of logical data blocks and the logical object; and means for immediately copying storage segments to the backup storage device if an attempt is made to modify a physical block of the storage segment.","According to another embodiment of the present invention, a method of copying a logical object to a primary storage device is disclosed. According to this embodiment, a copy of the logical object is provided. Physical blocks of memory in the primary storage device are allocated for storing the logical object. A map of the data blocks of the copy of the logical object to the physical blocks of the primary storage device is created. The data blocks are copied to the physical blocks, based on the map.","According to another embodiment of the present invention, a method of copying a logical object to a primary storage device is disclosed. According to this embodiment, an abstract block set copy of the logical object is provided. Physical blocks of memory are allocated in the primary storage device to store the logical object. The data blocks of the copy of the logical object are mapped to the physical blocks of the primary storage device and the data blocks are copied to the physical blocks based on the mapping.","According to another embodiment of the present invention, a computer storage device is disclosed. According to this embodiment, the device includes a memory including a plurality of physical data blocks. The device further includes means for storing the data blocks of an abstract block set to the physical data blocks, based on a mapping of the data blocks to a set of the physical data blocks.","According to another embodiment of the present invention, a method of copying a logical object is disclosed. According to this embodiment, a set of storage segments that includes the logical data blocks are identified. The storage segments may correspond to the logical data blocks, or may be of a different size. The identified storage segments are copied to a second storage device, out of order from the order of logical data blocks in the logical object.","According to another embodiment of the present invention, a method of copying a logical object is disclosed. According to this embodiment, a set of storage segments that includes the logical data blocks of the logical object are identified. The identified storage segments are copied to a second computer storage device in parallel. Metadata is provided to identify the order of data stored in the identified storage segments in the logical object.","According to another embodiment of the present invention, a method of backing up a logical object that includes a plurality of logical blocks is disclosed. According to this embodiment, a first and a second backup media are provided. In one embodiment, each backup media is a digital storage tape. Logical blocks are written to the first and the second backup media in parallel.","According to another embodiment of the present invention, a secondary storage device is disclosed. According to this embodiment, the secondary storage device includes a plurality of storage components and means for writing portions of an abstract block set to the storage components, in parallel.","According to another embodiment of the present invention, a method of restoring a logical object is disclosed. According to this embodiment, a first and a second portion of a copy of the logical object are provided. Data blocks stored in the first portion and data blocks stored in the second portion are read in parallel. The logical object is restored from the read data blocks.","According to another embodiment of the present invention, a secondary storage device is disclosed. According to this embodiment, the secondary storage device includes means for reading data from a plurality of storage components, in parallel, and means for providing the read data to another device as an abstract block set.","Each of the above disclosed inventions and embodiments may be useful and applied separately and independently, or may be applied in combination. Description of one aspect of the inventions are not intended to be limiting with respect to other aspects of the inventions.","The architectures illustrated in FIG.  and  may be viewed as focusing on a network model for storage, or a \u201cnetwork-centric\u201d system. In such a system, the focus of data transfer is movement of logical data across a network. Moreover, the storage system  and backup storage system  are typically associated with a single client or host  architecture.","An alternative model focuses on a separation of the client or host domain and the storage domain.",{"@attributes":{"id":"p-0127","num":"0126"},"figref":["FIG. 8","FIG. 8"],"b":["80","80","80","80","80","89"],"i":"a"},"The host computers  in the enterprise host domain  may be connected over a network. This network may include switching nodes , although any other form of network may be used.","In the embodiment of , the host computers  are coupled to the enterprise storage  through a network or directly to primary storage nodes . A primary storage node is a memory device that can store significant amount of data for use by the host . For example, a Symmetrix system, such as the one described above with respect to , may be used as a primary storage node, although this is not intended as limiting.","In the embodiment of , each host computer is coupled to a subset of primary storage nodes , for use as a main memory for that host computer. For example, host computer is coupled directly to primary storage node . The host computer may rely on primary storage node for most of its memory intensive functions, such as for accessing a very large database.","The primary storage nodes  may also be coupled together through a network. In the example of , the network includes link  and switch network . The switch network  may, for example, be a fiber channel network. The link  may be an RDF link over an ESCON line.","The network between primary storage nodes may serve two purposes. The network may permit transfer of data between primary storage nodes. For example, a database being manipulated by host , and stored in primary storage node , may be transmitted to primary storage node for use by host . By transmitting the database across the enterprise storage network (using link  or switching network ), the computational resources of the host , , and the available bandwidth in the enterprise host domain network, can be preserved.","The enterprise storage network  may also include a secondary storage node . The secondary storage node may be used for backup functions, hierarchical storage management, virtual disks and other functions. Thus, the secondary storage node  may be coupled to a tape storage unit . The secondary storage node  would coordinate sophisticated transfer of data from the primary storage nodes  to the tapes stored in a tape storage unit . (Other embodiments may use additional or alternative media for secondary storage.)",{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 9","b":["97","97","90","90","90","90","96"],"i":["a","e","a ","c "]},"In the embodiment of , each host computer -is connected to a primary storage node -. In this embodiment, each primary storage node -is an iterative cached disk array, such as a Symmetrix memory system such as the one described above with respect to , although this is not intended to be limiting. Thus, for example, host computer interfaces primarily with storage node . Similarly, host computer uses primary storage node as a primary source of its data.","In the embodiment of , the host computer is connected to the primary storage node over a high speed fiber channel . The host , however, is connected to the primary storage node over a standard SCSI connection. Each of the hosts and are coupled to the same primary storage node . Other mechanisms could be used to connect the host computers -to the primary storage nodes -. For example, a complete switched network could be employed, for any of the host computers to access any of the primary storage nodes -","Each of the primary storage nodes -may also be coupled together using a network. In the example of , the only link among the primary storage nodes is an ESCON remote data facility (ESCON \u201cRDF\u201d) link . Such a link may be used for transferring of data or maintaining a mirror of data either on-line or as a periodically updated mirror. Such a link may be implemented as described in U.S. Pat. No. 5,544,347 (Yanai), which is incorporated herein by reference in its entirety. Each of the primary storage nodes -may be coupled together using any other mechanism. For example, an RDF link could be used to fully connect each of the primary storage nodes -. In the alternative, a switch network could be used, assuming that the network is of sufficiently high speed to support the data operations among the primary storage nodes -","The storage network  in the embodiment of  further includes a secondary storage node . The secondary storage node is used for backup (and other) functions, for example by storing and restoring information to and from a tape library .","In the embodiment of , each of the primary storage nodes is connected or connectable (by a network) to the secondary storage node . In this example, primary storage nodes and are coupled to secondary storage node  each using an RDF link (and respectively) which may be implemented as described above.","The primary storage node is connected (together with other primary storage nodes, not shown) to the secondary storage node  over a switched network, which will permit each of the systems to access the secondary storage node .","Using an RDF (or other) link that permits high speed transfer of data over long distances, the primary storage nodes -and the secondary storage device  may be physically located at great distances apart.","Of course, other topologies and other mechanisms may be used without departing from the scope of the invention.","Many of the applications for computers now focuses as much or more on memory than on the ability of the system to perform computations. For example, access to very large databases has become an extremely important and valuable application for computers.","In the past, the focus of computer systems has been on interconnecting host computers each having their own associated memory, or providing network access to a single memory. This focus demands host computer and network resources.","In the storage-centric model, however, the storage component of the computer system is elevated to a status of equal importance. In such a model, the storage components of the system are capable interacting with each other with less involvement from the host domain. For example, it may be desirable to permit mirroring across one or more primary storage nodes. Similarly, data objects may need to be copied from one primary storage node to another primary storage node. Where additional levels of backup are desirable, the primary storage nodes may also transfer data to a secondary storage node for backup purposes. The primary storage nodes may, correspondingly receive data from the secondary storage nodes for restore. In a storage centric model, some or all of the resource intensive functions in such a system can be moved out of the host domain. Certain embodiments following this model can preserve host domain resources, increase scalability of memory (by adding to the storage domain without as much concern about affect on host domain resources) and reduce dependence on the particular platforms of the hosts in the host domain.",{"@attributes":{"id":"p-0146","num":"0145"},"figref":"FIG. 10","b":["100","102"]},"For example, for a copy, the physical elements that are to be copied are identified at step . In addition, the location of where the elements are to be copied to are identified. For a copy between primary storage nodes, this may involve identifying the copy from locations and the copied to locations. For a backup, this involves identifying the copy from locations and may be as simple as determining what tape or other backup storage element will receive the backup data.","For a copy between primary storage nodes, the physical elements are transferred from the identified copy from locations to the identified copy to locations. For a backup, the physical elements are copied to tapes. (Although reference is made to tapes as secondary storage, this is not intended to be limiting. Any other storage media may be used).","The step  can, however, be extremely complicated. In many cases, it is not desirable to copy the entire contents of a primary storage node. Rather, only a subset of the physical elements in the primary storage node may need to be copied. As one example, consider backing up a database stored in primary storage node of FIG. . This database may occupy only a small portion of the total data stored in the primary storage device \u2014in fact, there may be an extremely large segment of data accessible primarily by the host computer which host may not even be capable of reading (because it is a different platform than the host computer ).","In short, it may be desirable to backup a logical object stored within a primary storage node. In this case, the step  requires mapping the logical object onto the physical elements in the primary storage node in order to identify the physical elements that need to be copied from . As described above with reference to , these physical elements may be located in disparate locations within the primary storage device.","The step  may similarly be complicated. Even after all of the physical elements in the primary storage device have been identified, simply transferring the physical elements is insufficient. The relationship between the physical elements may need to be preserved for the copied or backed-up logical object to be read by the host computer coupled to the receiving primary storage node. One mechanism for use of mapping a logical object to physical elements and preserving the logical relationship between those physical elements is discussed below. This is not intended as limiting with respect to other aspects of the present invention.","In any event, under a storage-centric model of computer storage, it may be desirable to permit as much of the data transfer process (e.g., the one shown in ) to be performed within the storage network\u2014and without requiring resources from the host domain. Accordingly, the primary storage nodes and the secondary storage nodes in the network may include sufficient intelligence to handle aspects of the data transfer process. For example, the primary storage nodes may be capable, at a minimum, of managing the transfer of identified physical elements in a logical object even when those physical elements are stored in disparate locations within the primary storage device. In a storage centric model of a computer system, it may be desirable to move some (or as much as possible, in some cases) of the data transfer functions to be performed using resources among primary and secondary storage nodes within the storage domain.","The computer system may include a storage management application (\u201cSMAPP\u201d) for managing manipulation of storage within the storage domain. The SMAPP can be implemented using software on the host computers, primary storage nodes, a separate storage controller or in some combination of these, as described below with reference to , below.","The storage management application can be implemented using three primary components\u2014a management component, server component and client component.","The management component controls configuration of the backup, control and monitoring of the backup and copying processes in the storage domain. The management component also tracks location of copies of logical objects in the storage system including, for example, what tape or tapes contain backups of each particular logical object.","The server component controls the hardware functions of the memory process, such as acts of mounting and dismounting tapes, opening and closing, reading and writing tapes and other memory media.","The client component of the SMAPP handles manipulation and identification of the backup or copy-from source. For example, the client component is responsible for identifying the applicable logical object (e.g., file system, file or database) and determining what operating system level (or logical volume manager level) physical elements are involved. (As described above, an additional layer of mapping may be performed within the storage domain at the primary storage element of . For example, if the primary storage element  is a Symmetrix product as described above, the identified physical tracks may be re-mapped within the primary storage element .)",{"@attributes":{"id":"p-0158","num":"0157"},"figref":["FIG. 11A","FIG. 11A"],"b":["110","111","112","113"]},"In the example of , a storage management application (\u201cSMAPP\u201d)  is primarily a resident on the host computer . Thus, the host computer would include an Application Programming Interface (\u201cAPI\u201d) which would permit management of copying, backup and restore (and other) operations. In addition, the storage management application  on the host  includes a server component . Again, the host would include an API permitting management of server operations. Finally, the storage management application , in this example, includes a client component . The client component would be responsible for identifying and manipulating logical objects and identifying (from the operating system or logical volume management level view of) the physical elements that comprise the logical object.","For simplicity, the operation of performing a backup from the primary storage element  to the secondary storage element  will be described. A similar process would apply for setting up mirroring or copying functions between primary storage elements in a network.","In this example, the primary storage element includes an SMAPP interface . Similarly, the secondary storage element  includes an SMAPP interface . The copying of a logical object from the primary storage element  to the secondary storage element  in the embodiment shown in  may proceed as follows. First, a \u201cvirtual circuit\u201d or \u201cconnection\u201d is set up between the primary storage element  and the secondary storage element . This may be a virtual circuit established through a network coupling the primary storage element to the secondary storage element  (including a single RDF link between the primary storage element  and the secondary storage , for example). In addition to establishing a physical connection between the nodes, the virtual circuit identifies a session for copying a series of data (comprising, e.g., the logical object) over the identified connection.","Thus, the management component on the SMAPP  on the host computer  may begin a backup session by instructing the primary storage element to establish a virtual circuit with the secondary storage element . The actual establishment of the virtual circuit may then be performed by the SMAPP interface of the primary storage element  in combination with the SMAPP interface of the secondary storage element .","The client component of the host computer  identifies a logical object for backup. The client component then maps that logical object to the operating system (or a logical volume manager level) set of physical elements. This mapping may be performed in one step. The client component of the host  may then identify the elements for copying to the primary storage element , as communicated through the SMAPP interface ","The server component of the host  would identify and mount the appropriate tapes in the tape library unit . In this particular example, the server component performs these commands by passing them to the SMAPP interface of the secondary storage element , through the SMAPP interface of the primary storage element , which then mounts the tapes.","The actual performance of the backup process may proceed, without further control by the host  of the host domain (except, in some embodiments, monitoring the process and managing the backup media, e.g., controlling changing of tapes in a tape drive). The primary storage element  may copy the identified physical segments to the secondary storage element .",{"@attributes":{"id":"p-0166","num":"0165"},"figref":"FIG. 11B","b":["118","110","111","112","119","118","118"],"i":["a ","a ","a "]},"In this example, a significant portion of the SMAPP software is resident on the storage network controller . Thus, the SMAPP of the storage network controller includes a management component and a server component. Thus, management of the hardware and media can be performed by the storage network controller , independent of the host computer .","In this example, the host  includes an SMAPP  to perform client functions. Thus, logical to physical mapping is still performed in the host domain by the host computer . As the client component of the SMAPP  is responsible for identifying logical objects and performing logical to physical mapping, this can be a sensible arrangement. The logical to physical mapping depends on the particular host platform and the host necessarily has elements capable of performing the requisite mapping.","In other embodiments, however, the client component can be included in the storage network controller , or in a separate device capable of performing logical to physical mapping for one or more platforms. Where this is done, the identification and transfer of data for copying and backup purposes can be performed completely separately from the host domain. In many systems, however, it will be more efficient to use the memory mapping mechanisms (client component) on the host computer.","Other arrangements of the SMAPP software are possible. For example, the components of the SMAPP software may be distributed across the primary storage elements in the storage domain, the secondary storage element or elements in the host domain or some combination thereof.",{"@attributes":{"id":"p-0171","num":"0170"},"figref":["FIG. 12","FIGS. 11A and 11B"],"b":["120","120"]},"At a step , the logical object is mapped to identify the physical elements being copied from. For performing a backup, this would correspond to mapping an identified logical object at the application level to a set of physical elements at the storage level.","To restore from a tape, this would correspond to identifying the logical locations of the segments of memory on the tape. If the tape contains a logical bit file, this step is straightforward. No actual mapping needs to take place. In other circumstances, such as the abstract block sets described below, a table or other structure may identify the mapping of portions of the physical elements to their order in the logical object. The actual mapping from the logical level to the physical level may have been performed at the time of the backup and saved.","At a step , update to physical elements is prevented. For example, if a database is being backed up from a primary storage element to tape, updates of the logical object should be prevented so that the backup can correspond to a single point in time. Of course, if the copying is from a backup tape to a primary storage element, the freezing of updating the physical elements is rather simple\u2014the tape will not be written while it is being read from in the restore. In one embodiment, a method for concurrent copying described below may be used to prevent the update of physical elements during the copying process.","At a step , the copy-to memory is managed. For a backup from a primary storage element to tape, this may correspond to mounting and disbounding the appropriate tapes, as well as managing the tape library, catalog information, as well as writing appropriate tape headers and trailers. Where the information is being copied to another primary storage element, this may correspond to managing the receiving physical elements of the primary storage element being copied to. In addition, it may involve setting up an appropriate storage area to receive the information.","At a step , the actual physical elements are copied. The copying may be done in the appropriate order for the logical object, such as when an ordinary data file is sent at the application level between two host computers. In the context of a backup, one such system is described in U.S. patent application Ser. No. 09\/107,679, which is incorporated herein in its entirety. In an alternative embodiment, the physical data blocks may be copied out of order, together with appropriate metadata identifying the correct order of the physical elements in the logical object. An embodiment of this type of system is described below.","At a step , the physical elements of the logical object, in the copy-from memory, are unfrozen\u2014allowing updates of the logical object. The backup is complete and the physical elements can be unfrozen.","Finally, at a step , the virtual circuit may be closed.","Logical Object Translation to Abstract Block Sets","As described above, there are at least two different ways of passing data blocks of a logical object to a storage element\u2014transferring the blocks in order as a logical object (as is done over a network between host computers) and a pure physical copy (which may not preserve the logical relationship among the data). Each of these possibilities has advantages and disadvantages. For example, copying each data block of a logical object in order preserves the relationship between data blocks. On the other hand, copying the blocks in order may result in delays as the storage elements sequentially retrieve the data blocks or sort the data blocks for writing, as a part of the copy process. On the other hand, pure copying of physical elements can be unnecessarily slow if unused physical elements are copied. In addition, the logical relationship between the data blocks that are copied may be lost.","An alternative is to use an abstract block set structure, as described more fully below. This type of structure is useful not only in the storage network architecture as described above, but has greater applicability. For example, the abstract block set concept may be employed in any system where logical objects are copied from one storage element to another storage element. The abstract block set can also be used to particular advantage when used for backing up and restoring data from a secondary storage device, such as a tape drive.","The abstract block set permits storage of the data blocks in any order. The abstract block set includes information about the ordering of those elements.",{"@attributes":{"id":"p-0182","num":"0181"},"figref":["FIG. 13","FIG. 13"],"b":["130","130","130","130"],"i":["a","f "]},"The logical object is stored in a physical memory , as generally described above with reference to FIG. C. Each column may be viewed as a track (although this is not intended as limiting), and each row as a row of blocks within the tracks. As shown in , the logical data blocks may be scattered throughout the physical memory .","An abstract block set  may be constructed from the data blocks -.In the abstract block set , the data blocks are not necessarily stored in the same order as they appear in the logical object. In this example, they are in a random or pseudo-random order. (As a practical matter, the order of data blocks may reflect the way that the data blocks are stored in a physical storage . For example, if data blocks A and B are stored on one track they would probably be read and written to abstract block set  in the order they appear on that same track. The abstract block set  appearing in  is for illustration only.)","Because the logical data blocks are not in order in the abstract block set , it may not be possible to reconstruct the logical object given only the data blocks -","Accordingly, the abstract block set  includes metadata . The metadata is any recorded information that provides a mechanism to reconstruct the order of logical data blocks as they appear in the logical object .","In the example of , the metadata  includes an ordering of logical block elements (the column labeled LBEL) with the physical element location. Thus, logical block element  has metadata corresponding to the address of that logical data block in the physical memory \u2014the physical element address. Using the metadata illustrated at , each of the stored data blocks -in the stored abstract block set  would need to include a label with the corresponding physical address. Thus, for example, to locate the first logical data block of the logical object , one could examine the metadata  and determine that the first abstract block set (as shown in the first column of the metadata ) has a physical address ADDR-A. This data block could then be found in the abstract block set  by examining the physical addresses of the data blocks -(the physical addresses appearing within the data blocks ), until the appropriate block is found.","Of course, there are a variety of other formats that could be used for the metadata. As one example, a label other than the physical address could be used. As another the metadata  could just describe the order of the logical block elements in the abstract block set . In this case, the second column of the first row of the metadata  could indicate that the first logical data block (corresponding to A) is stored as the sixth block in the abstract block set .","For each of these alternatives, the first column of the metadata  is not required. The order of the elements in the second column corresponds to their location within the logical object ; the address for the first logical block element appears first in the table, the address for the second logical data block appears as the second entry in the second column, etc.","Metadata  illustrates another way of storing the metadata associated with the logical block . In this table of metadata, a first column corresponds to the ordering of data blocks as they appear in the abstract block set (as above, unnecessary as the order that the rows appear implies this information\u2014the first row is the first block in the abstract block set). The second column indicates the position of the data block within the logical object . Thus, the first entry in the first row of the metadata  corresponds to the data block of the abstract block set . This is the second data block of the logical object . Accordingly, the second column has a \u201c2\u201d indicating that this data block is the second data block of the logical object . The last column of the metadata  provides the physical address for the applicable data block in the physical memory .","Using the metadata shown at , there would be no need to store the physical address of the data block with (or other tag) with the data blocks as stored with the abstract block set .","As above, using the metadata , it is not strictly necessary to store the physical address within physical memory  of the applicable data block. This may, however, be useful information to include within the metadata . In many cases, restores will be made to the same memory locations from which the information was backed up. In this case, it will be easier to restore to those addresses in the physical memory \u2014that information was not available. Otherwise, a logical to physical mapping step may be required to determine again where the appropriate addresses are for the restored data blocks.","Other formats of metadata may be used. For example, metadata may be tracked for extents (sequences of blocks) rather than individual blocks.",{"@attributes":{"id":"p-0194","num":"0193"},"figref":"FIG. 14","b":"140"},"At a step , the logical block elements or logical data blocks of the logical object are identified. This may precede as generally described above.","At step , the logical block elements are mapped to physical backup segments. The physical backup segments may correspond to the physical elements that store the logical data blocks. In the event that the abstract block set is to include metadata of the form illustrated at table , the mapping step  may include formulating that information into whatever format the metadata is stored in.","As described above, the steps - may be performed by a client component of a storage management application. In some systems, this may require the resources of a host computer.","The remainder of the copying process may proceed without significant involvement of the client component of the storage management application.","At a step , is to determine whether all physical backup segments have been copied. If so, the copying process is complete at step .","If not all of the physical backup segments have been copied, the next available backup segment is copied at step . As described above, this copying need not be performed in the order appearing in the logical object identified at step .","In the event that the metadata is being stored as shown at table  of , then the metadata may be updated after the applicable backup segment has been copied into the medium holding the abstract block set. For this form of metadata (but not the form shown at  of FIG. ). This may not occur until the applicable backup segment is copied to the medium storing the abstract block set because, until that time, the order of appearance for the applicable physical backup segment is not known.",{"@attributes":{"id":"p-0202","num":"0201"},"figref":"FIG. 15"},"At a step , the metadata for the abstract block set is retrieved. This may be in the form of a map for the abstract block set such as those illustrated at  of  or may be a set of labels associated with the individual data blocks stored in the abstract block set, such as in table  of FIG. .","At a step , memory is allocated in the target storage device for receiving the logical object. The amount and configuration of the memory required to receive the logical object can be determined from the metadata for the abstract block set. Thus, the metadata will include sufficient information to determine the characteristics of storage required. For example, in the event that the abstract block set indicates use of fixed size blocks, the total number of (fixed size) blocks required to store the logical object can be determined by the number of entries and a metadata table or maybe separately stored as a part of the metadata for the abstract block set.","At a step , dummy metadata is created for the newly allocated physical memory for the logical object to be restored. The result can be a new table such as the one shown at  of FIG. .","At a step , a re-mapping table is created. The re-mapping table specifies a correspondence between the data blocks of the abstract block set is the source of data and the allocated data blocks in the physical memory. An example of a re-mapping table is described with reference to FIG. . Although shown in tabular form, the data can be stored in other forms and formats.","At a step , it is determined whether all of the physical backup segments have been restored from. If so, the restore is complete at a step .","If not, at a step , the next physical backup segment is retrieved. At a step , the location and the newly allocated memory for receiving the logical object is determined. This can be done by examining the re-mapping table created at step . In addition, the retrieval of segments done at step  need not be in any specific order. The re-mapping table permits restoration of the entire logical object even when the data blocks are provided in a random order.","At a step , the data from the physical backup segment is restored to the appropriate locations. Steps - then continue until all of the data blocks have been properly restored.",{"@attributes":{"id":"p-0210","num":"0209"},"figref":"FIG. 16"},"In , metadata  is provided for the abstract block set that is serving as the source for the restore. This table corresponds to the metadata  of FIG. .",{"@attributes":{"id":"p-0212","num":"0211"},"figref":"FIG. 16","b":["161","160","161"]},"A simple merging of these two tables can result in a re-mapping table . The re-mapping table  specifies the physical location from the data in the abstract block set and the destination for the that logical data block.","Of course, other formats may result in other tables. For example, it would be possible not to specify any physical addresses in the re-mapping table . The re-mapping table could simply map the sequential location in the abstract block set being restored from to the physical address or to the sequential location on the receiving storage element.","In other embodiments, each entry in the metadata remapping table may correspond to extents in the physical memories restored from and to.","Physical Backup Segment Granularity","In the discussion with respect to , it was assumed that the backup, copy and restore was performed at the data block level. Thus, the physical backup segment corresponded in size to the size of a data block. Those data blocks that are part of the logical object, and only those data blocks were copied for backup and were restored.","Granularity of the physical backup segments need not, however, correspond to the granularity of the data blocks. For example, a track may store a number of physical data blocks. In some instances, not all of the data blocks within a track are necessarily a part of the same logical object. Thus, in a track that stores four data blocks, only two of those data blocks maybe a part of a logical object, the other two data blocks being unused or part of a different logical object. Backing up of data in a logical object may, however, be performed at the track level rather than the physical data block level. The result would be an abstract block set that includes some data blocks that are not a part of the logical object.","Thus, in the preceding example, the physical backup segment size corresponds to the size of a track. The actual physical data blocks that may store the data of a logical object are smaller, e.g, four data blocks per physical backup segment of one track.",{"@attributes":{"id":"p-0219","num":"0218"},"figref":["FIG. 17","FIG. 17"],"b":"170"},"At the application level, the logical object  is viewed as a continuous file. This file may be partitioned into a number of logical data blocks, shown in  as vertical bars within the logical object .","At the file system level, a file system image  holds that data in each of the logical data blocks of . As shown in the file system image , the order of the logical data blocks at the file system level may not correspond to the order of their appearance within the logical object . As described above, a mapping process maps the logical data blocks to appropriate locations within the file system image .","The file system image  may be mapped to a logical volume of hypervolume level -","The logical volumes are then stored on a physical storage device in hypervolumes and . As shown in , the hypervolumes may not be physically adjacent. (Of course, as described above, other techniques for mapping the logical data blocks of the logical object  to the physical storage device are possible and within the scope of the present inventions.)","The first hypervolume stores data across seven tracks -. These tracks may, but need not, be contiguous segments of memory.","In this example, the entire track contains physical data blocks that are part of the logical object  (given the assumption that only three data blocks are stored per track). The track , however, includes only one data block that is a part of the logical object \u2014the other data blocks in the track either being unused or containing data belonging to a different logical object. In addition, some of the tracks within the hypervolume do not contain any data from logical object , e.g., tracks , and . The hypervolume similarly contains some tracks that include data from the logical object and some tracks that do not.","Given that the physical backup segment granularity is chosen to be track size in this example, the physical segments that would be part of a backup process would include tracks , , , , , and . These tracks make up the physical backup segment set (here, a \u201ctrackset\u201d) that would be copied when the logical object is backed up. Since, in the example of , the physical backup segment granularity is by tracks, this may be referred to as a track set.","Thus, the track set for a backup of logical object  would include tracks -, which in turn correspond to those of the physical tracks -that include data blocks from the logical object .","The backup process using a physical backup segment size that is different than the data block size can proceed generally as described with reference to FIG. . At step , however, identification of the physical backup segments includes not just identifying the logical block elements but using the identified logical block elements and their physical data block locations to determine the physical backup segment set, e.g., the track set -of FIG. .","In addition, the copying of the available backup segments at step  would involve copying the larger granularity segment (e.g., a complete track rather than just the particular physical data blocks on the track). As in , the physical backup segments (e.g., tracks) may be copied in any order.","Returning to , an abstract block set signature track  may be stored. This signature track includes the metadata for the abstract block set. In this embodiment, specification of the metadata for the abstract block set may include a specification of the particular data blocks in the abstract block set and their location within the logical object .",{"@attributes":{"id":"p-0231","num":"0230"},"figref":"FIG. 18","b":"180"},"The second column of the metadata  specifies the physical address of that logical object. In this example, that physical address includes a specification of where within the physical backup segment the applicable data block is located. For example, this information may be included as an offset within the physical backup segment. Thus, an address of dd:cccc:h:offset includes a specification of the physical backup segment (dd:cccc:h), which in this example specifies a track and a location within that physical backup segment (track), and an offset. For example, the first row of metadata  corresponds to the first logical data block in the logical object. It also happens to appear as the first data block in the specified physical backup segment address, e.g., as an offset from the beginning of the physical backup segment (here, a track) of just zero. The second row of the metadata  specifies the same address, but has an offset of 1\u2014it is a data block appearing in that physical backup segment (track) immediately following the data block corresponding to the first logical data block of the logical object.","In this example, it may be assumed that the track that includes the first two logical data blocks (first two rows of metadata ) has additional room within the track, but that those additional data blocks in the track are not a part of the logical object. Accordingly, there is no entry in the metadata table  specifying a corresponding logical data block for that portion of the track. (In an alternative embodiment, of course, an entry could be made which indicates that that portion of the track is unused in this abstract block set.)","As described above with reference to , many other forms and formats for storing metadata may be applied.","Restoring (or copying) from an abstract block set that has a physical backup segment granularity larger than the data block size may proceed as generally prescribed above with reference to FIG. . At step , however, the locations of the logical data blocks within the backup segment are identified\u2014including determining whether any portions of that backup segment may be omitted. At step , only those data blocks that are actually used in the logical object are restored.","Selecting a physical backup granularity larger than the size of data block can require transfer of more memory than if the physical backup segment size is the same as the data block\u2014some unused data blocks are included as a part of the copy or backup process.","A larger physical granularity size can, however, result in certain advantages. For example, less overhead may be required in the copying process\u2014fewer segments for copying need to be specified. In addition, other resources may be preserved. For example, if high demand memory is used for storing information identifying the physical backup segments to be copied, less such memory is required. In the event that the physical data blocks of logical objects are prevented form being updated during a copy or backup process, this can be done by protecting updates at the physical backup segment level rather than the data block level\u2014again requiring less overhead. In some systems, this can reduce the complexity of avoiding updates. Some embodiments of the invention employing different physical backup granularity than data block size may achieve some or all of these advantages, depending on the context and system in which it is implemented. None of these advantages is intended to limit the scope of the invention, which is defined by the claims below.","Concurrent Copy or Snapshot Facility.","As described above with reference to , certain systems embodying one or more aspects of the present invention will allow copying or backup, of a logical object at a specified point in time. To do this, updates to the logical object need to be prevented during the copying or backup process. There are many ways to do this, including taking the application that uses the logical object off-line until the backup process is complete. While certain embodiments of the present invention will use this and other techniques, it may be advantageous to be able to continue processing during the backup.",{"@attributes":{"id":"p-0239","num":"0238"},"figref":"FIG. 19"},"At a step , the logical object (or system using the logical object) is quiesced. There are at least two ways to quiesce the system. One way is to take the application off-line, and update the logical object off-line. This prevents any further updates (or reads) to the applicable logical object. Taking the application off-line can be undesirable\u2014resulting in loss of time and system availability.","An alternative way of quiescing a system is to place the application in on-line backup mode. For example, if the application is using an oracle database, writes to the database can be stored in a re-do log, rather than actually writing the data to a physical storage system. When the application is brought back to on-line mode, the updates to the logical object that are stored in the re-do log may then be applied to the current copy of the logical object.","At a step , those physical backup segments that contain data from the logical object are marked for copying. This may be done in a number of ways. For example, a bit may be associated with each potential physical backup segment in the system. The bit may be set to a \u201cone\u201d if the corresponding physical backup segment is part of a logical object to be copied. Of course, the methods for identifying the physical backup segments that are part of the abstract block set being copied can be used. As just one example, a list of the physical backup segments could be maintained.",{"@attributes":{"id":"p-0243","num":"0242"},"figref":["FIG. 20","FIG. 20"],"b":["28","28","27","28","29","28","29","28","27"],"i":["b","b "]},"Returning to , the application using the logical object can be returned to the active state. This may, for example, involve the step of returning the application to on-line mode from off-line mode. If the application was held in on-line backup mode, any elements in the re-do log may be applied to updating the logical object.","An attempt to write to a physical backup segment included in this set of segments to be backed up will, however, momentarily stall. Before the write takes place, that segment is copied or backed up, e.g., according to the illustrative embodiment described below.","At a step , it is determined whether there is a hit on a physical backup segment that is included in the backup segment set in the abstract block set. If so, that segment is copied out of turn\u2014and before the update is made. After the segment has been copied, that segment can be unmarked\u2014further updates may be allowed for that segment. After the segment has been unmarked, the update may be performed. Processing will then continue at step  in case there are additional hits (attempts to write to) a physical backup segment included in the abstract block set.","The copying of the segment may occur directly to the target (receiving primary storage element or receiving secondary storage element such as a tape) or may be copied to a cache for later copying to the target destination of the abstract block set.","If there are no pending hits on the physical backup segments of the logical object that remain to be copied, then processing may then continue at a step . At this step, it is determined whether all of the physical backup segments have been copied. If so, the formation of the abstract block set is complete and processing may conclude at step .","If there is additional copying to be done, the next available physical backup segment may be copied, at a step . Where abstract block sets are used, which permit the physical backup segments to be included in any order, the selection of the next segment may focus on whichever segment is next available, independent of order.","As before, after the segment has been copied, it may be unmarked. Accordingly, any incoming writes to that segment, which occur after the segment has been copied, may be performed\u2014even if the backup process is continuing with other physical backup segments.","In situations where the physical backup segment granularity is larger than the physical data block size, a write may occur to a physical backup segment that does not correspond to a write to a logical object. For example, consider a physical backup segment that has one physical data block that is in the logical object that is being backed up and three other physical data blocks that belong to other logical objects. A write to one of the physical data blocks corresponding to different logical object would trigger backup of the physical data segment, even though the logical object being backed up is not being updated.","One alternative for handling such a circumstance is to examine each write to a marked physical backup segment to determine whether the write is to a physical data block that is a part of the logical object. While this method may be employed in some embodiments of the present invention, it can incur a heavy overhead penalty in the event of writes to physical backup segments.","In an alternative embodiment, the physical backups segments are treated the same whether or not a write occurs to a physical data block in the logical object being copied or the physical data block in a different logical object. The overhead associated with this alternative may not be great, particularly if implemented in a system where the copied physical backup segments are being stored in an abstract block set that permits physical backup segments to be transferred in any order.","In most cases, it will be easiest to mark and prevent updates to portions of physical memory based on physical backup segment granularity\u2014e.g., using tracks on a disk for physical backup segment size and also for marking and preventing premature updates to the stored logical object. Other alternatives may be implemented. As just one example, in a disk system, tracks could be used as physical backup segments, but prevention of updates marked or tracked at the data block level (rather than the track level).","Differential Backups.","Systems similar to FIG.  and  conventionally backup an entire logical construct or element (\u201clogical object\u201d) specified by the user. For example, a user may specify a partition to be backed up. When this is done, the entire partition is copied to the backup storage system. Similarly, the user may specify a database or file to be backed up. In this case, the entire database or file is copied to the backup storage system.","This can require a significant amount of time, which is ultimately unnecessary. For example, an extremely large file may be backed up at one point in time. A second backup may then be performed at a later time. Very little of the file may have been changed between the two backups. Generating a new backup of the complete file can, therefore, be wasteful.",{"@attributes":{"id":"p-0257","num":"0256"},"figref":"FIG. 21"},"At a step , a level zero backup is performed. A level zero backup is a complete backup of the logical construct. For example, a level zero backup of a file backs up the entire file. A level zero backup of a (virtual) partition backs up this entire partition. Thus, a level zero backup can be used to restore the logical object without any further information.","At a step , the system tracks changes in data from the last level zero backup. For example, referring to , the segments that included any changed data may be tracked. If segments ,  and  include data that was changed, a corresponding bit or other record could be set indicating that these segments have changed (and not the others). As described more fully below, the segments may be defined by how the data is physically stored (e.g., by storage blocks) rather than based on logical level information, and may (but need not) correspond to the granularity of physical back-up segment of abstract block sets or the granularity of physical segments marked to prevent updates.","At a step , those data segments that have been changed are backed up. By backing up only changed data segments, rather than the entire file, the generation of the backup may be performed much more quickly. One embodiment of a method for storing and recovering files using records of just changed data segments is discussed below. This backup may be referred to as a \u201cdifferential backup\u201d because less than all of the logical data blocks are backed up, e.g., some data segments that have not been changed are not backed up.","At a step , it is determined whether a new level zero backup should be generated. If not, the system continues tracking changes from the last level zero backup, at step . In this embodiment, therefore, the differential backup generated at step  always records changed data from the last level zero backup\u2014not from the last differential backup. An alternative embodiment is to track changes from the last differential backup.","If a new level zero backup is to be generated, at a step , the tracking of changed data is reset. This may be performed, for example, by resetting \u201cchange bits\u201d associated with the data segments, described below. While this is done, the system may be taken off-line or placed in backup mode to assure that data is not changed while the change bits are being reset (and the level zero backup performed). When a new level zero backup is performed, future changes will be tracked from that level zero backup rather than an earlier one.","In another embodiment, resetting tracking of changed data may be performed after the step  of backing up changed data segments. In this case, each differential backup tracks changes only from the last differential backup. As discussed below, to restore data when this is done, multiple differential backup files may need to be examined, rather than just the one differential backup performed at the time of interest.","The complete or level  backup may be performed as described above. For example, an abstract block set may be created, using physical backup segments stored in any order, together with metadata as the level of backup.","The step  may be performed at either the logical or the physical level. At the logical level, the client  may track the segments that include changed data. At the physical level, the storage system  may track which segments of data have been changed. In either case, the segments of data may correspond to physical segments of data that are stored on the storage system, rather than units of data (e.g., files within a partition) determined at the logical level and associated with a logical construct.","The physical segment may be a 512 byte block that is written to or read from the physical storage device at one time. In another embodiment, the granularity of the physical segment may be the amount of data stored in a track of the physical storage devices used (particularly when the physical storage devices are disk drives). The size of this may depend on the particular format for storing data in applicable operating system. For example, in a fixed block architecture environment, the track may be 32 kilobytes (64 SCSI blocks). On IBM main frames implementing a count-key-data (\u201cCKD\u201d) system, the segment size may be the size of one CKD track. As above, the granularity of the physical segments for which changes are recorded may, but need not, correspond to the physical backup segment size or the granularity at which updates are prevented during the copying or backup process. In many cases, however, it will be most efficient to use the same granularity for each of these functions, e.g., using a physical track on a disk for the granularity of the entire system.","In certain embodiments, the changed segments may be tracked at the physical storage level. Thus, whenever a physical segment is written to a physical storage device, the fact that the segment was changed can be recorded. This may be done using a single bit associated with each physical segment. When the system is initiated, all of the bits are set to zero (for example). When a physical segment is changed (or written), the associated bit may be set.","Thus, referring again to , data changes may be tracked at the level of the actual physical storage devices -. When data is changed in one of the data segments, a bit may be set (or some other mechanism used) to track that that segment has been changed. For example, if data is changed within the first segment of the application file at the application level, e.g., , the data in actual physical storage device at  will be modified. A bit (or other mechanism) associated with data segment  will be set when this write is performed.",{"@attributes":{"id":"p-0269","num":"0268"},"figref":"FIG. 2","b":["201","412","114","114","412","412","412","50","5"],"i":["a ","a ","b ","a ","b "]},"The actual physical storage devices - may, but need not, have any idea of what is being done at the application level. In this embodiment, the physical storage devices need only be aware that data within the applicable segment of data (e.g., ) is being modified.","(While many of the embodiments described herein use bit masks to represent changes in data, e.g., a physical bit mask or a logical bit mask, other mechanisms (lists being just one example) may be used.)","In the embodiment described above, the changes to data segments are tracked at the physical storage level (although, in alternative embodiments, the changes could be tracked at any of the other levels, e.g., the application level, file system level, logical volume or logical volume manager level, as illustrated and discussed with respect to FIG. ).","In one embodiment of performing a \u201cdifferential\u201d backup, data about changes at the physical level is converted to correspond to changes at the logical (e.g., application file) level. The differential backup then stores the data at the logical level.",{"@attributes":{"id":"p-0274","num":"0273"},"figref":"FIG. 22","b":["412","413","414","204","206"]},"When data is written to a data segment, a corresponding bit and the corresponding physical bit mask is changed from a zero to a one. Accordingly, at any point in time, the physical bit masks indicate all of the data that has been changed since the last backup. As described above, the actual physical storage devices - may not know how this corresponds to logical objects at the application level. Indeed, the actual physical storage devices may have no way to determine what data segments are associated with each other. As indicated in , in this embodiment, data segments -have been changed. Accordingly, corresponding bits , , , in bit masks ,  and  have been set to one. (Other data segments in the actual physical storage devices may also have been changed, but are not shown in FIG. ).","A logical bit mask  may be constructed, which indicates what data segments within the application level file have been modified. Thus, logical bit masks  may include entries -indicating that the corresponding data segments -have been altered. (In an alternative embodiment, the segment changes may be tracked at the logical level, even though the segment size corresponds to a physical storage amount, such as block or track size.)","The logical bit mask  can be constructed using mapping . In particular, the mapping  may convert the application level object to a group of data blocks in the actual physical storage (as this needs to be done to store the application level file in physical storage in the first place). Thus, the mapping  may be performed using the same mechanisms for mapping application level data into physical storage devices (through, e.g., levels , ,  and  of FIG. ). The physical bit masks associated with these data segments on actual physical storage may then be examined. A logical bit mask can be constructed by setting each entry in the logical bit mask to a one only where the actual physical storage device indicates that that data segment has been changed.",{"@attributes":{"id":"p-0278","num":"0277"},"figref":"FIG. 23","b":"231"},"At a step , a logical to physical mapping is performed to determine which physical data segments within the physical storage device are of interest. The step  may be performed as generally described above. That is, using the application, file system and logical volume manager (where present, and additional levels of mapping if present) to map all of the data segments within the application file onto physical storage. As described above, this may map the object all the way down to actual physical storage. In other embodiments an additional level of mapping may occur before reaching the actual physical devices storing data; for example, in a Symmetrix product as described above, the Symmetrix product may present what appears to be a three volume storage device. This Symmetrix product could present change data based on that three volume set. On the other hand the way the data is actually physically stored within the Symmetrix may not correspond to that three volume set provided to the application or operating system level. Thus, an additional level of mapping for both data segments and bit masks may be performed within the storage device.)","The granularity at which the changes to data is tracked may be based on the size of the data blocks or on a different granularity, such as the size of physical backup segments. For example, change data may be tracked corresponding to physical tracks, when the physical data block size is less than an entire track.","At a step , the physical data segments that have been changed since the last time mark are identified. This may be done by examining the physical bit masks associated with the physical storage devices. Any entry marking changed data in the physical bit mask that corresponds to a physical backup segment within the application that includes a physical data block in the applicable logical object corresponds to data that may have been changed. At step , a logical bit mask may be constructed, such as the logical bit mask  of FIG. .","At a step , a differential abstract block set is created. This step involves copying only those physical backup segments that may include changed data. In one embodiment, as for the abstract block sets above, the abstract block set may record the physical backup segments in any order.","Accordingly, at a step , metadata for the differential abstract block set is also stored. This metadata records information sufficient to identify the applicable location of the physical data blocks stored in the differential abstract block set within the logical object being backed up or copied.","Finally, at a step , the application is returned to active mode. That is, the system is allowed to continue updating the physical data blocks on the actual physical storage devices.","As described above, before returning the system to active mode, the bits corresponding to the backed up data segments on the actual physical storage device may be reset to zero. This is only done if the differential backups are being performed with respect to the last differential backup. Otherwise, the bits may only be reset after the construction of the real (or merged, as described below) level zero backup.",{"@attributes":{"id":"p-0286","num":"0285"},"figref":"FIG. 24","b":["23","240","24"]},"At an earlier point in time, an abstract block set  was formed. As above, the abstract block set stores each of the logical data blocks of logical object , but in any order. The abstract block set  may include metadata, specifying the locations of the data blocks within the logical object.","After the abstract block set  was formed, additional changes may have been made to the data within the logical object . In this example, logical bit mask  reflects those changes. In particular, logical bit mask  indicates that the second and last logical data blocks within logical object  have been changed.","The differential abstract block set  stores those data blocks that have been changed (the second and the fifth). As described above, these may be stored in any order. The differential abstract block set may include metadata for the differential abstract block set. In the example of , the metadata is of the same general format as the metadata for the full abstract block set . The metadata includes an extra column, however, that specifies which of the logical blocks have been changed since the last backup (again, the second and the fifth, in this example).","To restore a logical object from a full abstract block set backup and a differential abstract block set, the two may be combined or merged. In fact, an abstract block set and one or more differential abstract block sets may be merged at any point in time, off-line. This permits formation of a synthetic full abstract block set that reflects the state of the logical object at the point in time when the differential abstract block set was formed.",{"@attributes":{"id":"p-0291","num":"0290"},"figref":"FIG. 25","b":["24","242","242","243","253"],"i":"a-b "},{"@attributes":{"id":"p-0292","num":"0291"},"figref":["FIG. 26","FIG. 26"]},"At a step , the most recent full or differential abstract block set is selected. Of course, this selection is made from those logical objects that were recorded before the target restore time (differential abstract block sets more recent than the target restore time reflect more recent data than should be restored.) At a step , all of the logical data blocks that are not in the merged abstract block set are appended to the merged abstract block set.","Referring to , the first abstract block set selected at step  is the differential abstract block set . As there are no blocks in the merged abstract block set yet, the two data blocks of differential abstract block set  are added to the merged abstract block set \u2014corresponding to the first two data blocks ","At a step , it is determined whether all of the differential and full abstract block sets have been examined. If not, processing continues at a step .","Returning to the example of , the next abstract block set to be selected is the full abstract block set . At step , those logical data blocks that are already in the merged LBO may be added. This corresponds to each of the data blocks, other than and ","At this point, once all of the abstract block sets have been examined, processing continues at a step . At step , the metadata for the merged abstract block set is created. Using the example of , the metadata may be of the same format\u2014the physical address of the logical block elements has not changed. Accordingly, the metadata is the same. In other embodiments for formatting metadata, the metadata table may be updated and correspondence with its format.","The merged abstract block set may be used for copying and restore in the same manner as an original, level zero abstract block set.","Primary to Secondary Storage Node Transfers, Example of One Secondary Storage Node.","As described above with respect to , one aspect of storage systems involves transfer of data from primary storage elements or nodes to secondary storage elements or nodes.",{"@attributes":{"id":"p-0300","num":"0299"},"figref":["FIG. 27","FIG. 27"]},{"@attributes":{"id":"p-0301","num":"0300"},"figref":"FIG. 27","b":["270","270","270","270"],"i":["a ","c ","b "]},{"@attributes":{"id":"p-0302","num":"0301"},"figref":"FIG. 27","b":["271","271","271","271","271","271","271","271"],"i":["a","b","e ","f","a ","a ","e"]},"As shown in , more than one pair of front end and back end data movers may be provided for parallel transfer of data. In this example, two pairs are shown\u2014-, and -","The actual backup media in the example of  is a tape library  (other backup media may be used in other embodiments). The tape library may include a plurality of tape drives ,each of which is capable of reading and writing data from a tape (and which may include an appropriate communications adapter, e.g., a SCSI adapter). The tape library  may also include robotics capable of selecting tapes from a tape library and inserting those tapes into the drives -. A robotics interface may control the selection process.","Returning to the secondary storage node , the secondary storage node may include an internal storage device for buffering data received from the front end data mover (e.g., ), before being written to tape by the back end data mover (e.g., ) during a backup (or, conversely, for buffering data during a restore by placing the data in the internal memory (by a backbend data mover ) and forwarding the data to a primary storage node (by front end data mover ).","The data movers , , and may be Intel based personal computers, running software permitting the data movers to transfer data from the primary storage node to the tape library unit during backup, and vice versa during a restore.","As described above, the data movers are configured in pairs, e.g., front end data mover and back end data mover . Each pair of data movers may be used to define one or more virtual circuits or streams.","The front end data mover (e.g., ) may be connected to the primary storage node  using any of a variety of connections. For example, in the example of , two ESCON cables are used to connect each front end data mover to the ports of a remote adapter of a single primary storage node (e.g., a Symmetrix storage device).","In the example of , the back end data movers , are connected to the tape library unit  using SCSI cables. In this example, each SCSI connection goes to a single read\/write drive -of the tape library . Of course, the SCSI connections may be daisy chained, permitting more than one drive to be connected to each back end data mover port. Other connections could be used, including other links or even a switched network.","The internal storage memory may itself be an iterative cached disk array, such as a Symmetrix. Thus, a Symmetrix product may be included as an internal caching memory for movement of data from the front end to the back end. The internal memory device may include a service processor, such as a laptop personal computer for local control of the internal storage device . The internal storage device may also store the operating system and application programs running on the data movers , , , and the control station ","The control station may be an Intel machine, running any of a number of operating systems, such as SCO UNIX. The control station may also include a keyboard and screen for local operation of the control station ","The control station controls operation of the data movers , , and . The control station includes controller software to perform this function. The controller also is used for system configuration and monitoring system performance. The control station includes a database (which may, in the alternative, be stored on the internal memory ). The database stores information about all pending backup streams or sessions, the contents of tapes in the tape library unit and other control information for managing the backup process and backup media.","The control station may also include an interface for manipulating and controlling the robotics of , of the tape library unit .","As described above, the primary storage node  may be used as the interface between host connectors (e.g., host computers connected to host adapter ) and secondary storage node, . In these embodiments, and where the storage management application resides primarily on the host computer, the primary storage node  may be used to pass commands from the host computer to the secondary storage node . Such commands may include instructions directed to mounting and dismounting tapes, reading and writing tape headers and trailers and other commands.","The primary storage node  may simply pass appropriate commands to the secondary storage node . In the alternative, the primary storage node  may perform some functions based on those commands, such as format checking.","As described above, the backup restore process can be performed by establishing a virtual channel between a primary storage node  and the tape library , through the secondary storage node . As described above, this may involve formulating a connection through a network between primary storage node  and secondary storage node . This may also involve establishing a connection with a tape drive and applicable tapes ",{"@attributes":{"id":"p-0317","num":"0316"},"figref":"FIG. 28","b":["271","280","271","271"],"i":["a ","e. "]},"A function to be performed by the storage management application may require opening a tape. The result would be to place the secondary storage node  into state \u2014virtual channel beginning of tape. This transition would involve mounting the appropriate tape, using similar techniques to what is known in the art. At the beginning of tape state , tape headers and trailers may be read or written, as a part of the tape management process.","When it is time to record information on the tape, the secondary storage node  (or at least the applicable data movers within the secondary storage node) enter the virtual channel write state . When in this state, the recording part of a backup is performed, such as writing one or more abstract block sets, or portions of an abstract block set, to tape.","If the end of a tape is encountered, the applicable data movers in the secondary storage node  enter the virtual channel end of tape state . In this state, the applicable catalog information may be read and an appropriate tape trailer written. When the end of the tape is encountered (or end of data), the applicable virtual channel needs to close that tape, returning the data movers and the secondary storage node to the initial state when the channel was formed\u2014state .","If an error is encountered, during writing from state , the virtual channel can enter into an error state . The tape may be closed (returning to state ), an error log created, and a system operator notified.","As discussed above, the storage management application is responsible for issuing the appropriate commands to change the state of the secondary storage node . The storage management application may be resident on the host computer, primary storage nodes, separate network storage controller or even on the secondary node .",{"@attributes":{"id":"p-0323","num":"0322"},"figref":"FIG. 29","b":["271","291","292"]},"The actual reading of data can be controlled using a tape read command, causing the secondary storage node  to enter into the virtual channel read state . At end of tape (or data) or log-out, the secondary node may return to the virtual channel end of tape state . The tape may then be closed, returning the secondary storage node  to the virtual channel opened state.","If an error is encountered during reading, the node  may enter the error state , similar to the error state described above with reference to FIG. . When an error occurs, the tape may be closed, an error log created, and the system operator notified.","For both backup and restore, the cataloging and identification of tapes can be handled by the storage management application, as is done for other mechanisms for formatting data stored on a storage system. The control station of the secondary storage node  assists in identification and mounting and dismounting of the appropriate tapes, using the control station database ","The backup and restore state diagrams of  constitute example embodiments of placing the system (e.g., the primary storage node and\/or the secondary storage node) in an asynchronous transfer state. In particular, the nodes of the storage domain enter a state where data is transferred independent of control from any host computer or host domain element, even when much of the storage management application process (and software) is being performed on the host computer.","Certain embodiments of this facet of the invention allow the advantage of independent control and transfer of copying, backup and restore. In certain embodiments of the invention, this can alleviate the dependence on particular host platforms and conserve host resources. Certain embodiments of this aspect of the present invention also allow for increased scalability\u2014allowing addition of memory, with less dependence on host configuration.","One Embodiment of Data Transfer.",{"@attributes":{"id":"p-0329","num":"0328"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0330","num":"0329"},"figref":"FIG. 30","b":["300","300","301","7","300","305","7"]},"Data is stored among a plurality of disks within the primary storage node , one of which is shown in FIG. \u2014disk .","The disk  may include protection bits, as described above with reference to FIG. . These protection bits may be used to designate tracks to be copied\u2014and also tracks which should not be updated before they are copied. The protection bits  may be stored, in one embodiment, on a cylinder header for the disk device . The disk device  may also include a physical bit mask (not shown) as generally described above with reference to FIG. . Other mechanisms may be used for marking or recording, which tracks are protected.","In the embodiment of , the disk adapter  receives instructions from the storage management application as to what physical backup elements (here, which of the tracks ) are part of the backup process. The disk adapter may then write the protection bits at the time of backup is initiated.","Those physical backup segments (e.g., tracks , and ) that were designated as part of a backup process may then be copied to a side file  in a cache  of the primary storage node . Thus, the side file  may receive the designated tracks , and for copying to another storage node. The side file, therefore, may contain copies of these tracks.","In addition, the disk adapter  may post, to a request queue, a request that the physical backup segments that have been copied to the side file  be transferred to another node. Thus, requests may be posted in the request queue , corresponding to those physical backup segments in the side file .","The remote adapter  may pickup requests from the queue and transfer copies of the applicable track to the receiving storage node, e.g., a secondary storage node.","The applicable storage backup segments held in the side file  may be part of more than one copy of backup process being performed. For example, more than one abstract block set may be in the process of being backed up over more than one virtual channel connected to the remote adapter . In this case, the applicable metadata for the abstract block set can be used to identify a specific abstract block set and virtual channel for the copying or backup process.","In an alternative embodiment, the receiving storage node may classify physical backup segments based on the abstract block set to which they belong. For example, the front end data movers described above could receive physical backup segments corresponding to tracks, including a physical address for the track. The front end data move may be aware of the metadata for the abstract block set, which was formulated by the storage management application (which identified all of the physical locations for the applicable logical object being backed up). This would permit the front end data mover to classify the physical backup segment based on its physical address.","Of course, a variety of alternative structures and methods could be employed for transfer through a side file. As just one example, the physical backup segments could be sorted into separate side files for each abstract block set (or other structure) being copied or backed up. In addition, side files may be used to accumulate segments of data for transfer. For example, a side file could be created that includes at least ten megabits of data before transfer through the remote adapter  to a secondary, or other, storage node.",{"@attributes":{"id":"p-0340","num":"0339"},"figref":["FIG. 31","FIG. 30"],"b":["30","310","307"]},"In addition, metadata for the applicable logical object may be transferred to the receiving storage node, e.g., the secondary storage node. Thus, if the metadata is of the form shown at  of , this metadata may be specified and advance the backup process. This metadata may (or may not) be reformulated during backup for incorporation into the logical backup object, such as reformulation into the form shown at  of FIG. . In any event, this metadata may be used by the disk adapter , remote adapter  and\/or the receiving storage node to accumulate and organize the applicable physical segments associated with the logical object being copied or backed up.","At a step , the protected segments are transferred to a side file in a cache. As this is done, requests for the transfer of the physical backup segments are logged into a request queue. As described above, this may be performed by a disk adapter of the primary storage node. At this point in time, the disk adapter  may also reset the applicable protection bit of the protection bits  of the disk device , allowing future updates of the data.","The segments in the side file can then be transferred to another storage node by the remote adapter , such as transfer to a secondary storage node. This may be done be reading requests for transfer from the requests queue .","After the transfer (e.g., after the transfer has been acknowledged) the applicable entries for the segment in the request queue in the side file may be removed. Of course, this can simply be done by allocating the storage as unused.",{"@attributes":{"id":"p-0345","num":"0344"},"figref":"FIG. 32","b":["320","322","27"]},"The front end processor  stores the received physical backup segments in internal memory  in files associated with the applicable entity being backed up. For example, if an abstract block set LBO # is being backed up, the physical segments are stored in a file  associated with that abstract block set. Where more than one abstract block set is being transmitted at the same time over a virtual channel, the front end processor may sort the applicable physical data segments into the appropriate file, e.g., files  and .","When a file reaches a certain threshold size, for example 10 megabits, the front end processor  may notify the back end processor  that a segment of the abstract block set is ready for copying to tape. The back end data mover  may then copy that portion of the abstract block set from the internal memory  to the tape library unit .","In the event that the internal memory  is an iterative cached disk array, such as a Symmetrix, the physical back up segments may be copied from the applicable file ,  by the back end data mover  in last-in-first-out order. This may be done to increase the chance that the data is copied from a cache within the internal memory , rather than from disk within the internal memory .","As described above, more than one abstract block set may be backed up at one point in time over a virtual channel. In addition, the segments of an abstract block set may be written in fixed sized pieces. For example, if an accumulation file ,  accumulates physical back up segments until a threshold size (for example 10 meg) is reached, the abstract block set may be stored in interleaved segments of a tape. The controller and control station (and ) can maintain a database for this information. In addition, the applicable information can be written to appropriate headers and trailers on the tape.",{"@attributes":{"id":"p-0350","num":"0349"},"figref":"FIG. 33"},"In  the tape has a beginning portion  and an ending portion . The beginning portion  includes the usual tape header , and perhaps a specific tape header for the secondary storage node . After the tape headers , , the tape includes interleaved segments of abstract block sets (including metadata) , separated with file marks. For example, the interleaved segments may include a record  that includes a series of copies of physical backup segments . A segment header and segment trailer may identify and separate this portion of the abstract block set from other portions of the tape.","Interleaved with the portion of the abstract block set that includes data blocks  may be other abstract block set physical backup segment records for this and other abstract block sets. In addition, a record  may be written that includes abstract block set metadata. This metadata may be of any of the forms described above, or other formats. As a part ol the segment header information and , the applicable abstract block set can be identified, for example, using an abstract block set identifier uniquely assigned to each abstract block set. This permits identification and coordination of the records interleaved on the applicable tape , .","At the end of the tape , a tape directory  may be written. Similarly, server tape trailer information  may be written. At the end of the tape, a tape catalog  and a secondary storage device tape trailer marking the end of the tape  may be written.","Using a database of tapes, the applicable information may be retrieved from a backup tape. Because abstract block sets may include data blocks written in any order, a restore process can efficiently retrieve and write the portions of an abstract block set being restored, in any order. This permits the storage management application to identify each of the tapes that include portions of an abstract block set and to mount (and read all of the applicable portions of) those tapes only once. Of course, the first tape to be mounted may be the tape that includes the metadata records for the abstract block set being restored. For this reason, it may also be preferable to record the metadata at one end of all of the segments of an abstract block set written on the tape holding the metadata\u2014making the reading of metadata at the beginning process simpler. This permits formation of the appropriate mapping table, described above, for the restoration process to proceed independent of the order in which data blocks are retrieved.","For the reasons described above, the reading and restoring of data blocks within an abstract block set can be done in any order. As a result, where tapes are used and as a component of the secondary storage element, the tapes can be mounted and dismounted in any order for both storing and retrieving data. As a result, where more than one tape drive is present in the secondary storage element, it is shown in the embodiments described above, data blocks can be written during backup and read during restore and parallel using multiple drives.","Referring to , parallel writing of data may be performed as followed. In this example, the updating of metadata (step ) may be performed entirely in advance. In this example, the metadata may be the physical addresses of the data being read in a primary storage element. Accordingly, all of the metadata can be determined in advance of the actual backup process. Since this is the case, the steps ,  and  may be performed in parallel. That is, after the physical backup segments have all been identified and the metadata determined (e.g., at step ), all of the data blocks may be read in parallel and written to multiple tapes in parallel. In one embodiment, the last tape (which may be randomly selected) can store the metadata at the end of all of the data blocks that are part of the abstract block set on that tape.","One example of a parallel restore operation may be described with reference to FIG. . As described above, at steps -, the mapping for the restore of the logical object is determined. Where this restore is coming from a tape, the metadata for the abstract block set can be retrieved in advance. As described above, after this has been done, the abstract block sets can be restored in any order. Accordingly, the abstract block sets may also be retrieved in parallel using multiple tape drives for a restore. In this case, the steps - may be performed in parallel using multiple tapes (or other media) for retrieving data blocks of the abstract block set being restored.","In embodiments employing virtual channels, a separate virtual channel may be established for each of the parallel paths for transfer of data. For example, a separate virtual channel may be established for each tape drive. In another embodiment, a single virtual channel may be established, but permitting multiple tape drives to channel data into that virtual channel. This may be particularly advantageous where the speed of reading data from the tape drive is slower than the ability to transfer data from the secondary storage node to a primary storage node. Allowing parallel reading of tape drives permits the speed of the restore to approach the ability of the connections to transfer data and the primary storage element to receive that data.","While many of the above embodiments have been described with respect to backup and restore operations between a primary storage element and a secondary storage element, many aspects of the invention have much broader application. As just one example, an abstract block set can be used for any transfer of data. As another example, the application of a secondary storage node can be greater than simply backup and restore operations. Such storage nodes may also be used for hierarchical storage management applications, operation of virtual disks, and other applications.","The various methods above may be implemented as software on a floppy disk, compact disk, or other storage device, for use in programming or controling a computer. The computer may be a general purpose computer such as a work station, main frame or personal computer, that performs the steps of the disclosed processes or implements equivalents to the disclosed block diagrams. The software may be included on a diskette as a complete system or as enhancements to an existing system, permitting the system to perform the methods described herein.","Having thus described at least illustrative embodiments of the invention, various modifications and improvements will readily occur to those skilled in the art and are intended to be within the scope of the invention. Accordingly, the foregoing description is by way of example only and is not intended as limiting. The invention is limited only as defined in the following claims and the equivalents thereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0110","num":"0109"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0112","num":"0111"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0114","num":"0113"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0118","num":"0117"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0119","num":"0118"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0120","num":"0119"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 33"}]},"DETDESC":[{},{}]}
