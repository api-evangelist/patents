---
title: Partial initialization of divided programs in response to pre-boot and post-boot activation events to rapidly boot a computer system
abstract: A method for booting up a computer is disclosed. Initially, a memory image of a boot program is stored in a main memory of a computer. The memory image includes a first initialization code and a second initialization code. During the booting process of the computer, first initialization code is executed. In response to the completion of the execution of the first initialization code, the boot program is shifted to an idle state. In response to an activation event, the second initialization code is executed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08661236&OS=08661236&RS=08661236
owner: Lenovo (Singapore) Pte Ltd
number: 08661236
owner_city: Singapore
owner_country: SG
publication_date: 20110929
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["PRIORITY CLAIM","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT","DEFINITIONS"],"p":["The present application claims benefit of priority under 35 U.S.C. \u00a7\u00a7120, 365 to the previously filed Japanese Patent Application No. JP2010-246971 entitled, \u201cMETHOD FOR BOOTING COMPUTER IN A SHORT TIME AND COMPUTER\u201d with a priority date of Nov. 4, 2010, which is incorporated by reference herein.","1. Technical Field","The present invention relates to computer boot time in general, and in particular to a method for booting up a computer in a relative short time.","2. Description of Related Art","When a computer is switched on, the computer starts a boot process (also known as bootstrapping or boot) to automatically load a predetermined boot program from a boot disk into a main memory and then executes the boot program. After a series of boot files has been loaded and executed, the computer is then ready for a user to execute any application program on the computer.","When a computer is brand new from the manufacturer, the boot process of the computer can be completed in a relatively short time because the sizes of the boot programs are relatively small. However, after the computer has been in use for many years, during which the user might have installed various application programs therein, these application programs would be incorporated into the boot files and the auto-run files, typically without the knowledge of the user. As a result, the time to complete the boot process is lengthened.","One prior art solution for speeding up the boot time of a computer system is to numerically limit task objects (static generation) generated during initialization of an operating system (OS). More specifically, while a task object with a relatively short initial access time between boot completion and access is statically generated, a task object with an initial access time longer than a certain time is generated by calling a specific system call in an application after boot completion (dynamic generation). Another prior art solution is to shorten a boot time of an OS by running applications to be activated with the OS at different timings on the basis of various conditions. In one example, after completion of the boot of the OS, each application is auto-run at a different timing.","For instance, an application called from another application for running and a certain type of service program of an OS are required to be activated prior to the running of a caller application. In this way, in the case of a program with an execution order depending on another program, the activation order cannot be changed freely. Therefore, the above-mentioned two prior art solutions have to be modified to make a confirmation whether the activation order of a program depends on another program or not or to keep the dependence of the activation order, and so there is a restriction on programs that can be activated after boot completion. Such a restriction arises every time a special program tries to control execution timing of other programs during booting.","A boot program includes a body code playing the original function as well as an initialization code initializing the body code. The initialization code runs only at the beginning of the running the program to configure information of a registry and other databases at the body code. While the body code runs, the registry tends to accumulate unnecessary information that should be deleted and gradually become bloated. If the initialization code configures the body code in accordance with the information of the bloated registry, a boot time becomes further longer because of redundant consumption of hardware resources such as a disk drive and a processor.","A tool known as registry cleaner can be utilized to delete unnecessary information from a registry. The registry cleaner can delete information from a registry when the information can be evidently regarded as deletable with even a program other than a target program. For instance, information such as a shortcut without a link and a temporary cache file can be deleted. When the registry cleaner deletes information in the registry without consideration given to the situation of a target program, the operation of the program will be unstable. Further, whether or not to execute a registry cleaner depends on a user's operation, thus, the registry cleaner is not always executed for shortening a boot time.","Consequently, it would be desirable to provide an improved method for booting up a computer in a relative short time.","In accordance with a preferred embodiment of the present invention, a memory image of a boot program is initially stored in a main memory of a computer. The memory image includes a first initialization code and a second initialization code. During the booting process of the computer, first initialization code is executed. In response to the completion of the execution of the first initialization code, the boot program is shifted to an idle state. In response to an activation event, the second initialization code is executed.","All features and advantages of the present invention will become apparent in the following detailed written description.","[Configuration of a Computer System]",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["10","10","11","13","15","17","19","21","23","15","19","17"]},"Definitions of terms used in the present specification are as follows. A boot program refers to a ready program, which may be called a module, a code or a file, or a DLL file automatically loaded in the main memory  for running after a computer is switched on. To load a program refers to the operation where a linker links an object code read from a disk drive with another object code and a library to generate a memory image and such a memory image is stored in a main memory. Such loading of a program does not include the processing to run the program. A run state of a program is a state where, in an operating system (OS) performing preemptive multitasking, a process to run the program transits between a run state and a ready state under the control of a task scheduler of the OS.","An idle state of a program refers to a state where a process to run the program is out of a run state because the process is called by a specific Application Programming Interface (API) function and the process transits to a suspend state or a wait state. An OS does not allocate a time slice of the CPU  to a process in a suspend state or in a wait state, but can resume the process and make the process transit to a run state while monitoring a window message generated by an event in response to an input through a keyboard or a mouse or an interprocess communication when calling a specific API function to call the process generated by an OS or another program.","A not-run state of a program refers to a state where a process to load the program is not yet created or although the program is loaded, a process to run the program is not yet created. With the exception of a special program, a program in a not-run state cannot be called from another program and activated, but a program in an idle state can be called from another program and run.","Activation completion of a program refers to a state where initialization of the program is totally completed and a body code to implement the original function is about to be run or a state where initialization is totally completed and the program shifts to an idle state. When a program has a window as a user interface, timing when the window is displayed may be called activation completion of the program.","Activation completion of a program in the present embodiment further includes a state where a part of an initialization code of the program runs so that initialization is partially completed and a body code with the original function corresponding to a part of where initialization is completed runs or a state where initialization is partially completed and the program shifts to an idle state. Such a state where activation is not completed thoroughly but initialization of a part of the body code is completed is called a partial activation completion. Dependence of programs refer to a state where a program and another program have a relationship for the activation order such that when a program is called to run another program, the former program is required to be activated prior to the latter program so as to provide a service.","Boot completion refers to a state where a CPU usage of the computer as a whole is kept at a predetermined value or lower during a predetermined time period. The CPU usage Y of the computer as a whole can be calculated by the following expression with a predetermined program of an OS:\n\n=(1\u2212()\/)\u00d7100%,\n\nwhere Ui denotes a user mode time of an idle process, Ki denotes a kernel mode time of the idle process, and Et denotes an elapsed time.\n","Herein, boot completion has the same meaning as activation completion of a computer. On the basis of the aforementioned definitions, activation completion of all of the boot programs means to boot completion of the computer. However, timing for activation completion of individual boot programs does not agree with timing for boot completion of a computer, and activation of a part of the boot programs is completed prior to boot completion.","[Software Configuration]",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 2"],"b":["10","101","102","103","107","117","119","101","102","103","107","17","13","11","10"]},"The OS  includes a registry , an auto-run list , an API  and a kernel module . When a module is not a divided-type program  illustrated in , the OS  may be an existing OS such as Windows\u00ae or MAC\u00ae. However, since the data structure of the divided-type program  can be used as the module of the OS  as well, modification of the corresponding part is required for the existing OS.","The registry  is an internal database of the OS  to store configuration information of hardware of the computer , configuration information of software, security information, user information and the like. The configuration information of software contains configuration information of the OS , configuration information of an application a user installs and configuration information of a device driver installed in association with peripheral equipment. The auto-run list  stores information on names and the loading order of the boot programs. The auto-run list  includes a list published to a user so as to allow the user to register a boot program as well as a list for registration by a system only that is not published to a user.","The API  is an interface letting the divided-type applications  and  and the non divided-type application  use a service of the kernel module . The kernel module  is made up of multiple modules providing basic functions of the OS , such as a virtual memory, a device driver, process management and a file system. The optimization control program  sends, to the OS , an optimization event to run an optimization code  (see ) of the divided-type application ,  regularly. The device driver  is a special program to configure a hardware interface for the HDD  or to control data transfer between the HDD  and the OS .","[Process Transition]",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3","b":["10","107","11"]},"The ready state (READY) is a state where the process is ready and waits for running in the order of priority, where a process scheduler of the OS  dispatches PCBs registered in a ready queue to the CPU  in a predetermined order. The running wait state (WAIT) is a state where the process waits for running by calling a function stopping the running by itself until a certain condition such as I\/O holds. The suspend state (SUSPEND) is a state where the process is forced to be in a wait state by another process.","In order for a certain process to make another process shift from a run state or a ready state to a suspend state or resumed from a suspend state to shift to a ready state, a specific API function can be called. At this time, when the OS does not provide an API function to directly suspend or resume a process, an API function covering all threads created by the process as a target of suspending and resuming can be called to implement suspending\/resuming.","[Configuration of Divided-Type Program and Non-Divided-Type Program]",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["150","101","102","170","103","107","13","17","107","13"]},"The memory image of the divided-type program  includes a section table , a first initialization code , a first body code , an optimization code , a second initialization code  and a second body code . The memory image of the non-divided-type program  includes a section table , an initialization code  and a body code .","In the divided-type program , the initialization code is divided into the first initialization code  and the second initialization code  having individual entry point  and , respectively. The non-divided-type program  is different from the divided-type program  in that the initialization code  has one entry point and is not divided. The data structure of the non-divided-type program  is well-known. The section table  of the divided-type program  includes entry points ,  and  storing virtual addresses of sections storing codes and data.","The entry point  indicates the leading virtual address of the first initialization code , the entry point  indicates the leading address of the optimization code  and the entry point  indicates the leading address of the second initialization code . The section table  of the non divided-type program  includes an entry point . The entry point  indicates the leading address of the initialization code .","The OS  can run a predetermined code only by designating any one of the entry points of the section tables  and . Therefore, the arrangement of the first initialization code , the optimization code  and the second initialization code  on the main memory  is not limited to . There is no need to divide blocks of the first body code  and the second body code , and both codes may be mixed in one block.","The function of the first body code  and the second initialization code  of the divided-type program  is the same as the function of the body code  of the non-divided-type program . The first initialization code  refers to the registry  or other databases to initialize the first body code  for running. The second initialization code  refers to the registry  or other databases to initialize the second body code  for running. The initialization code  refers to the registry  or other databases to initialize the body code  for running.","The first body code  and the second body code  are codes to implement a function as an object of a program. The first body code  and the second body code  create a process to be run during initialization, and further create a thread to run various functions. When a program is in an idle state, a run process transits to a suspend state or a wait state. When the scheduler of the OS  detects an event called by another process, the scheduler makes a run process in a suspend state or a wait process transit to a run state.","The divided-type program  is provided with a plurality of entry points for the initial codes, and such a data structure is effectively used during booting to shorten a boot time when the divided-type program  has dependence with another program. The first initialization code  is run during the booting to initialize the first body code . In order to shorten a boot time, the first initialization code  and the first body code  preferably are made up of codes that have to be run during the booting.","The first initialization code  may be configured so as to simply initialize the first body code  and to leave the final initialization including the complete initialization of the first body code  and the initialization of the second body code  to the second initialization code . In that case, the second initialization code  can initialize a part of the first body code  that is not initialized by the first initialization code . The second body code  may be made up of codes that can be initialized after completion of boot so as to allow the divided-type program  to implement a predetermined function.","The OS  can divide the first body code  of the divided-type program  from the second body code  for initialization, but cannot divide the body code  of the non divided-type program  for initialization. The first initialization code  and the second initialization code  are programs that may be run only once between loading and unloading, and can be deleted from the main memory  after running.","The first body code  is preferably made up of a code for a process having dependence with another program only. In order to secure the dependence, when the first body code  has an interface published to another program, the first initialization code  initializes the first body code . The first body code  further includes a code creating a process to load a succeeding program during booting. When many resources are consumed for running of the first initialization code  during booting, the boot time of the computer  will be lengthened. Therefore the first initialization code  is preferably created so as to consume minimum resources during running.","When the first initialization code  has to access the HDD  that is an only hardware resource incorporated in the computer  so as to initialize the first body code , the first initialization code  preferably performs such initialization so as to minimize the access to the HDD . For instance, when a large number of files have to be read from the HDD  to configure the first body code , the first initialization code  is preferably configured so that a minimum file for configuration is read without hindering the running of a program having dependence.","When the divided-type program  is a device driver, the first body code  may be a code configuring minimum hardware used by the divided-type program  itself or another program during booting. Services that the OS  provides are normally called by many applications. Accordingly, when the divided-type program  is an application, the first initialization code  may be a code configuring a service that the OS  provides such as port configuration.","In general, information configured in the registry  when a user uses the divided-type program  is used by the divided-type program  only. Such information is rarely required for running of another program. Accordingly, the first initialization code  can configure the first body code  so as not to use the information in the registry . In this case, a part of the first body code  that is not initialized by the first initialization code  can be initialized by the second initialization code  after completion of boot.","When the divided-type program  is of a type making the LCD  display an application window (hereinafter called a window) as a user interface, the first initialization code  may be configured so as to initialize the first body code  until the window can be displayed and enable reception of an activation event for complete activation through the window. The first body code  may create a process to run the second initialization code  and make the process transit to a suspend state, and make the process transit to a run state when the process is called by another program during loading. When running of the first initialization code  is completed, the first body code  creates a run process and partially activation of the divided-type program  is completed.","The second body code  may be made up of a code performing all processing not having dependence with another program. When the second initialization code  is run, the second body code  creates a run process and the divided-type program  is completely activated. When the divided-type program  is of an interactive type, the process shifts to an idle state after complete activation. At this time, the process running the first body code  also transits to a wait state or a suspend state. When the divided-type program  is a device driver, the second body code  may be a code configuring hardware used by a program operating after boot completion.","When the divided-type program  is an application, the second initialization code  may be a code configuring for the second body code  using user data that the divided-type program  has or a code configuring using information in the registry  configured while a user uses the divided-type program .","The divided-type program  is not created by simply providing an entry point during part of the conventional initialization code . A creator of the divided-type program  creates a code in the initialization code  that is to be run during booting as the first initialization code  and creates a code that may be run after boot completion as the second initialization code .","A program creator who knows the properties of the program the most can appropriately judge whether the conventional body code  is to be initialized with the first initialization code  or with the second initialization code . A trial to control run timing for initialization of the conventional body code  with another program will fail because such a code does not have separate entry points.","Additionally, unless coding of the first initialization code  and the second initialization code  is performed on the basis of the operation and the dependence during booting, a division method of the initialization code as in the present embodiment cannot be used for a program having dependence. Using the division method of the initialization code, when the OS  designates the entry point  at the same timing as in conventional one, the first initialization code  initializes the first body code  during booting to partially complete the boot, whereby a service can be provided in response to calling from another program during booting.","Then, when an activation event to use the second body code  is created after boot completion, the second initialization code  can perform final initialization of the first body code and initialization of the second body code . In this respect, the division method for the initialization code allows each boot program to shorten a boot time autonomously.","Since the information in the registry  used when the first initialization code is run is basic information for the operation of the computer , it is in general difficult to delete such information. Then, the optimization code  cleans up the information in the registry  used when the second initialization code  is run and user data for configuration that the divided-type program  has. When the divided-type program  is a Web browser, for example, the optimization code  may delete unnecessary information that the registry  or the Web browser itself has, such as Internet cache, browsing history or shortcuts without links.","The optimization code  enables a creator of the divided-type program  to set a criterion for judgment as to deletion of unnecessary information for the program in advance, and therefore much unnecessary information can be deleted with the optimization code  than in the case where information is deleted with a uniform criterion set by another program such as a registry cleaner. Further, a user is allowed to configure the optimization code  regarding optimum timing, temporal range and contents range of information to be deleted for the application.","For instance, a registry cleaner may delete browsing history of the Web browser back to one month ago. On the other hand, the optimization code  allows deletion of all browsing history for the divided-type program  to be at a predetermined time period. Since the amount of user data that the divided-type program  holds and has to be to read from the HDD  for initialization is reduced, a time occupying the HDD  during booting and a time slice that the CPU  provides to load the user data for running are reduced. As a result, a boot time can be shortened.","[Running Procedure of a Non-Divided-Type Application]","For comparison with the divided-type applications  and , loading and running procedure of the non divided-type application  is described below. When loading the non divided-type application , the OS  configures an entry point  including an image base and a RVA, and stores the initialization code  and the body code  at a section of a virtual address corresponding to the configured entry point . The image base referred to herein corresponds to an address as a reference when a program is loaded to a virtual address space.","The loaded memory image has a data structure, which can be displayed and confirmed using tdump.exe included in Borland C++ Compiler. After loading the non divided-type application  at a predetermined section, the OS  runs the application from the entry point . The initialization code  of the non divided-type application  initializes the body code . The initialized body code  creates a process to be run, and then activation of the non divided-type application  is completed.","When the non-divided-type application  is a program of an event driven type, a process to run the body code  once transits to a suspend state or a wait state after activation completion. Then, the non divided-type application  waits for a run event from a user through the input device  or a run event from the system. Receiving the run event, the OS  resumes the process to make the process transit to a ready state. When the non divided-type application  is a program to be run automatically without the need of a run event, the process does not shift to an idle state and the initialization code  and the body code  are successively run.","[Running Procedure of a Divided-Type Application]",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 5","b":["101","102","10","101","111","102","201","10","21","17"]},"A boot routine here may be cold boot where boot is performed from a power-off state or warm boot where the entire POST or a part thereof is omitted. The boot routine, however, does not include resume using a hibernation state and resuming a memory image immediately before from the HDD  to the main memory . At block , a boot system code of the OS  is firstly run, and the registry  and the auto-run list  are loaded at the early stage.","Furthermore, a code processing boot of the kernel module  is loaded in a predetermined order. Since many modules of the OS  loaded at the early stage are required to provide complete services to other programs during booting to complete the boot, such modules do not have to be made up of the divided-type program . Starting the boot, at block , the OS  determines whether each boot program is registered or not in the auto-run list . For processing of the divided-type application  registered in the auto-run list , the procedure shifts to block , and for processing of the divided-type application  not registered, the procedure shifts to block .","At block , the divided-type application  registered in the auto-run list  is read from the HDD  successively and is run. The divided-type application  loaded and run creates a process to load the following boot program. Subsequently, the following boot program creates a process to load a further following boot program. The OS  loads a memory image of the divided-type application  in the units of sections to an address space of a virtual memory corresponding to the main memory .","An object code of the divided-type application  stored in the HDD  is coded to be formed with a memory image illustrated in . A linker of the OS  performs linking with another code and a library in accordance with an instruction of the object code to create the memory image of the divided-type application , and a loader stores the memory image in the main memory .","When the divided-type application  is loaded, the OS  configures entry points ,  and  made up of an image base and a relative virtual address (RVA) at the section table . The OS  stores the first initialization code  and the first body code , the optimization code  and the second initialization code  and the second body code  at sections of virtual addresses corresponding to the configured entry points ,  and , respectively.","After loading of the memory image is completed, at block , the OS  designates the entry point  and runs the first initialization code . After loading is completed, the first initialization code  automatically starts running in response to an instruction from the OS  to initialize the first body code . The initialized first body code  creates a run process. The OS  makes the run process transit to a suspend state or a wait state. When the divided-type application  is of a type displaying a window as a user interface, the window may be displayed at this time to receive an activation event to run the second initialization code . The first body code  may be configured to create a process to run the second initialization code  so that the process can run when another program calls the process during booting. At block , when running of the first initialization code  is completed, the divided-type application  completes partial activation and shifts to an idle state.","In the divided-type application  shifting to an idle state, the process to run the first body code  transits to a suspend state or a wait state. When another program calls the divided-type application  in an idle state, the OS  makes the process transit to a run state. Therefore, at the time when running of the first initialization code  is completed, the divided-type application  starts a service to be provided to another program during loading.","Another divided-type program  is loaded in a similar procedure until the first initialization code  runs. In the case of the non divided-type application , upon being loaded, the initialization code  and the body code  are run. On the other hand, in the case of the divided-type application , partial activation is simply completed with running of the first initialization code , whereby resources consumed in the CPU  and the HDD  are reduced and so a boot time can be shortened.","At block , activation of all boot programs is partially completed so that CPU usage is reduced, and then boot of the computer  is completed. At block , the OS  monitors an activation event to finally activate the divided-type application  where partial activation is completed. Herein, since the timing of boot completion does not agree with the timing of partial activation completion of individual programs, the procedure at block  may be prior to the boot completion.","The activation event is an event to run the second initialization code  of the divided-type application  that completes partial activation and shifts to an idle state before complete activation. When the divided-type application  displays the window to receive an input instruction from a user at block , the activation event may be an event indicating a state where the window changes from background to foreground or an input event from the input device . Other examples of the activation event include an activation event at predetermined timing by the OS  and an activation event at boot completion timing of the computer . The latter activation event may be used also when the divided-type application  runs without waiting for an input from a user.","At block , the OS  receiving the activation event designates the entry point  to run the optimization code . The optimization code  deletes unnecessary information from the registry  and configuration data that the divided-type application  has for cleanup. Note here that the optimization code  does not have to run always before the second initialization code  runs. Running of the optimization code  at this stage can securely reduce resources used during running of the second initialization code . When the optimization code  does not run during booting, the entry point  is not provided, and the optimization code  may be incorporated in the second body code .","At block , the optimization code  finally designates the entry point  to run the second initialization code . The second initialization code  refers to the registry  subjected to cleanup and performs initialization of the second body code  and necessary initialization of the first body code . The OS  makes a process for run that the initialized second body code  creates transit to a suspend state or a wait state. The OS  further makes a process for run that the additionally initialized first body code  creates transit to a suspend state or a wait state.","In this state, activation of the divided-type application  is completely completed and the application shifts to a normal run state. When the application is of a type displaying a window on the LCD  to receive an input from a user, the window may be displayed at this stage. When another program calls the divided-type application , the OS  makes the process in a suspend state or a wait state transit to a run state. When the second body code  runs, the second body code  can create a process to run the optimization code  for which the entry point  is designated. At block , the OS  monitors whether the optimization control program  creates an optimization event or not.","When receiving the optimization event, the OS  notifies the divided-type application  of a specific group or all divided-type applications  of the optimization event. The optimization code  of the divided-type application  receiving the optimization event deletes predetermined information from the registry  and user data concerning configuration. The optimization code  can run at both of or either one of block  and block . The optimization control program  can generate the optimization event at regular timing after boot completion of the computer  or at power-off timing.","The divided-type application  not registered in the auto-run list  is not run during booting and is loaded by an activation event generated after boot completion for running. In this way, boot can be completed without registering the divided-type application  in the auto-run list , which means that the divided-type application  does not have dependence, and therefore the divided-type application  in principle may be configured as the non divided-type program .","The divided-type application  not having dependence can be activated after boot completion. However, when the divided-type application  has dependence in the future, the divided-type application  may be a boot program. At block , boot of the computer  is completed. At block , the OS  monitors an activation event for the divided-type application . Since the divided-type application  is in a not-run state at this time, an activation event is required to activate the divided-type application  completely. The activation event can be created by making an access to a file system of the OS  with the input device .","At block , when the divided-type application  is not loaded at this time, the OS  creates a process to read the divided-type application  from the HDD  in accordance with the activation event. The OS  detecting the activation event loads the divided-type application  to the main memory . After loading of a memory image is completed, the OS  designates the entry point  to run the first initialization code .","When the divided-type application  has been already loaded, the OS  may run the first initialization code  from the entry point  in accordance with the activation event. When the first initialization code  initializes the first body code , the first body code  creates a run process and notifies the OS  of the run process. Subsequently, at block , the OS  designates the entry point  to run the optimization code . After running of the optimization code  is completed, at block , the OS  designates the entry point  to run the second initialization code . In this way, the OS  continuously runs the first initialization code , the optimization code  and the second initialization code  of the divided-type application  not registered in the auto-run list  after boot completion without \u201csandwiching\u201d an idle state therebetween.","The method of  describes the running procedure of the divided-type applications  and . In the present invention, however, the OS  may load and run the non-divided-type application  in parallel with the divided-type applications  and  during booting. The data structure of the divided-type program  can be used for an application and a service program of an OS that are not required to undergo initialization of all body codes before boot completion.","A device driver may be divided into a code that has to initialize a register during booting for operation of another program and a code to initialize a register that is evidently used after boot completion. Such a device driver also may be configured as in the divided-type program , whereby a boot time can be shortened. A program of a type that can run on demand after boot completion can be removed from the divided-type program .","[Running Order of Programs]",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIGS. 6A-6C","FIG. 5","FIG. 6A","FIG. 6B","FIG. 6C"],"b":["101","102","103","101","102","170","111","101","153","107"]},"The divided-type application  is not a boot program, which never affects the delay of the boot time. The divided-type application  may be loaded during booting because influences on the delay of a boot time are small unless the divided-type application  is run. In the case of the non divided-type program , the entire initialization boot runs before boot completion, thus consuming many resources and greatly affecting the delay of a boot time.","As has been described, the present invention provides an improved method for booting up a computer in a relative short time.","Those skilled in the art will appreciate that the mechanisms of the present invention are capable of being distributed as a computer program product in a variety of computer-readable storage medium such as compact discs, digital versatile discs, etc.","While the invention has been particularly shown and described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention itself, as well as a preferred mode of use, further objects, and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
