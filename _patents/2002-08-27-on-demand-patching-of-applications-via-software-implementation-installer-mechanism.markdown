---
title: On demand patching of applications via software implementation installer mechanism
abstract: A method and mechanism for automatically patching software implementations such as applications as they are installed from an external source. A patch program is run for a software implementation that is advertised as available, or is otherwise available, though not yet installed (or fully installed). The mechanism maintains the patch information for that software implementation. Whenever the software implementation is installed, the mechanism determines that the software implementation has the patch information maintained therefor. The mechanism automatically applies the patch as part of the on-demand installation process. The patch may change the files, the values of registry entries and/or the installation logic associated with the software implementation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07073172&OS=07073172&RS=07073172
owner: Microsoft Corporation
number: 07073172
owner_city: Redmond
owner_country: US
publication_date: 20020827
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["The present application is a continuation of U.S. patent application Ser. No. 09\/261,732, filed on Mar. 3, 1999, which is a continuation-in-part of U.S. patent application Ser. No. 09\/158,021 entitled \u201cSoftware Implementation Installer Mechanism,\u201d filed on Sep. 21, 1998, now U.S. Pat. No. 6,418,554.","This application is related to the following U.S. Patent Applications and Patents, all of which are assigned to the same assignee as the present application:","\u201cUse of Relational Databases for Software Installation\u201d\u2014Ser. No. 09\/158,125, U.S. Pat. No. 6,237,144;","\u201cSystem and Method for Repairing a Damaged Application\u201d\u2014Ser. No. 09\/158,126, U.S. Pat. No. 6,397,381;","\u201cMethod and System for Restoring a Computer to its Original State After an Unsuccessful Installation Attempt\u201d\u2014Ser. No. 09\/158,124, U.S. Pat. No. 6,363,499;","\u201cA Method for Categorizing and Installing Selected Software Components\u201d\u2014Ser. No. 09\/157,695, U.S. Pat. No. 6,370, 686;","\u201cSystem and Method for Managing Locations of Software Components Via a Source List\u201d\u2014Ser. No. 09\/157,974, U.S. Pat. No. 6,269,377;","\u201cMethod for Optimizing the Installation of a Software Product onto a Target Computer System\u201d\u2014Ser. No. 09\/157,853;","\u201cSoftware Installation and Validation Using Custom Actions\u201d\u2014Ser. No. 09\/157,776, U.S. Pat. No. 6,378, 127;","\u201cInternal Database Validation\u201d\u2014Ser. No. 09\/157,828, U.S. Pat. No. 6,389,414;","\u201cManagement of Non-persistent Data in a Persistent Database\u201d\u2014Ser. No. 09\/157,883;","\u201cMethod and System for Advertising Applications Ser. No. 09\/158,967, U.S. Pat. No. 6,345,386;","\u201cMethod and System for On-Demand Installation of Software Implementations\u201d\u2014Ser. No. 09\/158,021, U.S. Pat. No. 6,418,554;","\u201cMethod and System for Assigning and Publishing Applications\u201d\u2014Ser. No. 09\/158,968 and","\u201cClass Store Schema\u201d\u2014Ser. No. 09\/158,023, U.S. Pat. No. 6,389,589.","The invention relates generally to computer systems, and more particularly to an improved method and system for patching software applications installed on computer systems.","In contemporary enterprises such as a corporation, one of the duties of a network administrator is to set up and maintain the corporation's computers so as to make employees more productive. Lost productivity at employees' computer desktops is a major cost for corporations, often resulting from user errors such as inadvertently removing some or all of a needed application or using an old application rather than an enterprise-specified one that is improved, secure and\/or compatible with others. Similarly, lost productivity often results from user errors such as removing or modifying other software implementations such as system configuration files, dynamic link libraries (DLLs), application files and object classes (e.g., COM objects) in ways that render the computer or applications unworkable. Productivity is also lost when a desktop is too complex, such as when the desktop has too many non-essential applications and offerings thereon. Much of the expense of administering distributed personal computer networks is spent at the desktop, performing tasks such as fixing the settings or reinstalling implementations that the user has incorrectly or inadvertently modified.","At the same time, an enterprise wants certain personnel to have access to various software implementations such as applications, while wanting other applications to be available to certain users for access if needed. For example, a corporate enterprise may declare a policy specifying that everyone in the company should use a particular electronic mail program, while in addition, those in the research department should be able to load a particular spreadsheet application if needed.","However, to implement such policy decisions, administrators or the like generally need to physically visit each workstation to load (or unload) the specified programs and other software implementations, adjust various system configurations, and so forth. In addition to initially setting the computers, the administrators must hope (or regularly check) that the users do not change the settings, however users regularly make modifications, leading to lost productivity. The administrator also needs to revisit the workstations to install new versions of implementations.","Such policies cause problems when multiple users share the same computer, since a policy instituted for one user of that computer may not be compatible with the policy for another. As can be readily appreciated, installing software implementations in an enterprise is a complex task that does not fit in well with existing systems and methods. In addition, installation for non-network users may also be improved.","Moreover, applications also sometimes have patches applied thereto. Patches are generally updates (e.g. fixes) that overwrite part of an application's code, append code to an application, change or add components (such as DLLs) used by an application and\/or change application-related entries in the system registry. At present, patch installation mechanisms are essentially standalone products custom-built generally as an afterthought for the applications they are patching, and are independent from the original application installation mechanism.","As a result, patch installation mechanisms do not communicate with the original application installation mechanism, and are not aware of the installed state of an application from the original application installation mechanism's perspective. This presents a number of problems. For example, if the user is required to reinstall the original application, via its original installation mechanism, the patch is not automatically reapplied. Similarly, if the user installs a portion of a number of available applications, such as two applications of a five application suite, applies a patch written for the suite, and then later installs one or more of the formerly uninstalled applications, the patch will not be applied to the newly installed applications. It is thus up to the user to recognize the need to rerun the patch installation mechanism. However, unless the user is sophisticated enough and also remembers to check the installed version number against the patched version number, the user has no way of knowing that the patch, which should be applied, has not been applied. In short, present application patching technology has many shortcomings.","Briefly, the present invention provides a method and mechanism for automatically patching a software implementation (e.g., application program) on demand. An installer mechanism receives a patch and associates the patch with one or more software implementations. The software implementation may be installed, in which event the installer mechanism will patch the implementation, but may not yet be installed. When the installer mechanism receives a request to install such a software implementation, the installer installs the software implementation, recognizes that the software implementation has a patch associated therewith, and patches the software implementation. For example, the patch may change the files and\/or the values of registry entries associated with the software implementation.","Because the patching is automatic following any installation of a software implementation having a patch associated therewith, the software implementation need not be installed when the patch application program is run. Moreover, because the patch is applied whenever an installation occurs, the patch is reapplied if part of the application is uninstalled and then reinstalled, if the application repairs its files, and\/or if an application of a patched suite of applications that was not previously installed is later installed.","Other benefits and advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environment",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 1"},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer  or the like, including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read-only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the personal computer , such as during start-up, is stored in ROM . The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD-ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read-only memories (ROMs) and the like may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system  (preferably Windows\u00ae 2000), one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers.","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, Intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","For purposes of the following description, a client workstation (e.g., ) may correspond to the computer system , while software implementations  such as applications or pieces thereof, (e.g., products, features and components as described below), objects and so on may reside on one or more of the remote computers . However as can be readily appreciated, no particular arrangement of the various files, interfaces, objects (classes), mechanisms, processes and so on described herein is necessary to the present invention. Indeed, as is understood in computing and networking in general, such files, interfaces, objects, mechanisms, processes and so, on may be combined, separated and\/or distributed in virtually any number of ways among the various network devices.","Also, as will become apparent below, there is no requirement to limit on-demand installation to networks, as other implementations such as standalone users may benefit from the present invention. The on-demand installation of implementations may be performed by the present invention for any number of users in many types of environments, from a single standalone user to an enterprise-wide network of policy recipients, i.e., users and machines. Indeed, although a deployment scheme is able to trigger the installation mechanism remotely and efficiently, thus leveraging it for enterprise-wide deployment, it is understood that the concept of install on demand is valid outside the scope of application deployment. Notwithstanding, many aspects of the present invention will be described hereinafter with respect to network application deployment, since network application deployment benefits significantly from on-demand installation.","In one embodiment, the present invention provides a method and system that facilitates deploying software implementations by automatically installing the software implementations throughout a computer network in a highly flexible, scalable, extensible and efficient manner. To this end, as shown in , the method and system leverage a highly flexible architecture wherein an administrator can tailor policies  to containers  (sites, domains, and organizational units of users and computers arranged in a hierarchical manner), by specifying one or more policies  therefor, such that the policy within an organization is centrally managed. Such group policies , including the prioritizing of multiple policies for policy recipients (e.g., users or machines) are described in U.S. patent application Ser. No. 09\/134,805, entitled \u201cSystem and Method for Implementing Group Policy,\u201d assigned to the assignee of the present invention and hereby incorporated by reference herein in its entirety.","Although not necessary to the present invention, group policies  are maintained via a Windows\u00ae 2000 directory service, known as the Active Directory , ordinarily maintained in a domain controller  (). More particularly, each group policy object  comprises a group policy container in the directory service and a group policy template in the \u201csysvol\u201d of the domain controller , but for purposes of simplicity are generically referred to herein as a group policy object. In general, the Active Directory  stores information about the objects of a domain, and makes this information easy for administrators to access, find and apply via a single, consistent and open set of interfaces. For example, with the Active Directory , administrators have a single point of administration for the objects on the network, which can be viewed in a hierarchical structure. A core unit in the Active Directory  is the domain, and the objects of a network exist within a domain. A single domain can span multiple physical locations or sites.","Thus, one aspect of the present invention is described herein with reference to the Microsoft\u00ae Windows\u00ae 2000 (formerly Windows NT\u00ae) operating system, and in particular to the flexible hierarchical structure of sites, domains and\/or organizational units of a Windows\u00ae 2000 Active Directory . Notwithstanding, there is no intention to limit the present invention to Windows\u00ae 2000 and\/or the Active Directory architecture, or even to networks, but on the contrary, the present invention is intended to operate with and provide benefits with any operating system, architecture and\/or mechanisms that install software implementations.","Software Implementation Installer Method and Mechanism","In general, a first aspect related to the present invention involves the on-demand installation of applications, such as for purposes of application deployment, i.e., initially making an application or some piece, thereof available (e.g., core code) to network policy recipients via policies . As described in the copending United States patent applications entitled \u201cMethod and System for Assigning and Publishing Applications\u201d and \u201cMethod and System for Advertising Applications,\u201d assigned to the assignee of the present invention, filed concurrently herewith and hereby incorporated by reference herein in their entireties, to initially deploy an application, an administrator can choose to either \u201cassign\u201d or \u201cpublish\u201d the application. To this end, as shown in , one or more group policy objects (templates)  associated with users or machines of a directory container may be associated with policy recipients, and a subcontainer of each group policy object, deemed a class store, may include application deployment information. Note that although separately shown in  for purposes of simplicity, a class store  is actually a subcontainer of the group policy container, as described in more detail in copending United States Patent Application entitled \u201cClass Store Schema,\u201d assigned to the same assignee as the present invention, filed concurrently herewith and hereby incorporated by reference herein in its entirety.","Via this centrally maintained deployment information in the class store , policy recipients (e.g., users and workstations\/machines) in a directory container  (e.g., organizational unit) are assigned applications, or applications are published thereto. An application typically is assigned to a group of users (or a group of machines) when it is deemed mandatory for that group to have that application, while published applications are those that are made optionally available to users who may benefit therefrom. For example, the same version of an electronic mail application program may be assigned to everyone in an organization, while a word processing program may be assigned to every group of users that needs some word processing capabilities. However, an application program for editing images may not be needed by everyone, and thus such a program may be published on a per-group basis so that those groups of users who may benefit from the program have it, while others who do not need it will not have it occupy resources of their workstations. Publishing is generally described below.","Assigned applications are advertised, i.e., they appear as available to a user at each logon (if assigned to a user) or at each re-boot (if assigned to a machine). Advertised applications are not necessarily installed on the workstation, but rather may only appear to be installed. To make an application appear installed, advertisements for an application include shortcuts that appear on the Start Menu, a collection of registry entries required primarily for OLE and shell activation, and icon files, (note that these concepts of advertising are valid for both network and standalone users). For example, to explicitly launch an application, users navigate the Start Menu looking for a shortcut representing the application, then click that shortcut. Thus, shortcuts placed on the Start Menu represent a blatant advertisement for an application. Users also implicitly launch applications by double-clicking a file (of a file system) having an extension associated with a particular application. Since associations between file extensions and applications are stored in the system registry  (), writing such associations to the registry  is another way in which the present invention may advertise applications. Other examples of how an application is advertised include writing class information (i.e., for OLE\/COM activation), MIME associations and shell verbs.","Assigned applications are also resilient, in that they will be re-advertised on the next logon (or machine re-boot as appropriate) if deleted from the local workstation (machine) . For purposes of simplicity, assignment will hereinafter ordinarily be described with reference to being applied to users via a policy at user logon, although it is understood that policies may be applied to a machine when the machine connects to the network, e.g., at machine re-boot, and thus applications may be assigned to machines (e.g., via a machine profile ) in the same general manner as users. Moreover, even if a user installs another program or different version of the application over an assigned application, because the advertise script is applied, the assigned application (the administrator-specified version) will return at the next logon. Only an administrator (and in particular a domain administrator) may permanently remove an assigned application, by doing so via the centralized location.","Another way in which applications are resilient, for example, is when the target of the shortcut has already been installed, but certain key files have been deleted. As described below and in the aforementioned patent application entitled \u201cSystem and Method for Repairing a Damaged Application,\u201d hereby incorporated by reference herein in its entirety, the application may cause the on-demand installation of the files, thereby repairing itself. Such resiliency applies to both network and standalone users, e.g., the application may repair itself from a network source or via a source such as a CD-ROM.","To assign an application, as generally shown in , the administrator, using an application deployment editor  or other suitable tool, selects an application package (e.g., ). The application deployment editor  causes an advertise script  (a file) to be generated and stored for one or more groups of users (or machines) in a group policy template (object), e.g., , of the Active Directory . More particularly, to generate the advertise script , the application deployment editor  calls the MsiADvertiseProduct( ) API (application programming interface) of a managed software installer mechanism (named the \u201cWindows installer\u201d in one preferred implementation) with the information as set forth in the table below:",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"UINT MsiAdvertiseProduct("}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LPCTSTR","szPackagePath","\/\/ Fully qualified path to a package"]},{"entry":["LPCTSTR","szScriptFilePath","\/\/ If NULL, product is advertised locally"]},{"entry":["LPCTSTR","szTransforms","\/\/ Semi-colon delimited list of transforms"]},{"entry":["LANGID","idLanguage","\/\/ Language of product being advertised"]},{"entry":");"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Upon successful completion, the result is the advertise script  containing records for creating advertisement information, e.g., including shortcuts, icon files, and OLE and shell activation registry entries. Note that in the network environment, szScriptFilePath may specify a file stored in the applications folder of the group policy object as represented in . In general, the advertise script  comprises information corresponding to a series of commands, API calls, or the like, such as resulting in standard API calls to write various information to the registry  at certain keys, add application shortcuts to the Start Menu, and so on. For purposes of simplicity, the usage of well-documented APIs to write information to a registry and add shortcuts to menu folders will not be described herein in detail.","As shown in , packages such as the packages  are stored and cataloged under the class stores , and may be available from various vendors for different platforms, activation modes, access control, setup, and installation information. For example, the package  may include an entire application (e.g., Microsoft\u00ae Word or Excel), a set of binary component implementations packaged together, or a standalone COM (Component Object Model) component (e.g., an ActiveX\u2122 control).","Once the advertise script  is generated and stored in the group policy template , a user having the group policy template applied thereto (e.g., at logon) receives the advertise script  in their user profile . Logon code  then calls a local managed software installer mechanism to process the advertise script , the result of which is the creation of a collection of advertisement information  including shortcuts on the Start Menu and registry entries required for shell and OLE activation. Advertisement information references the managed software installer mechanism , and, as described below, the operating system  knows what to do when it encounters such information. Lastly, in accordance with one aspect of the present invention and as described in detail below, the managed software installer mechanism is involved is when activation occurs, i.e., the managed software installer mechanism is called when an application is activated to install one or more components as needed to service the activation request.","In general, executing the advertising script  makes the application appear to be available to the user, including writing information to the system registry  and adding script information such as shortcuts to assigned programs to the user profile  (e.g., the Start Menu or desktop) on the workstation.  shows the steps taken by the logon process  at user logon, beginning at step  wherein as part of applying the group policy template (and any other templates), the logon process  writes the advertising script  (and any other scripts) to the user profile  in the local workstation . At step , an advertise script is selected from the user profile. To resolve potential conflicts in accordance with policy settings, the selection may be in a prioritized order, (as described in the aforementioned \u201cGroup Policy\u201d patent application). In any event, once selected, the installer mechanism is called at step  to process the script, e.g., populate the registry with information such as file-extension associations, write application shortcuts to the user's Start Menu or desktop and so on as represented by step . Step  repeats the processing of scripts (one of which will be the script ) until there are no more to process.","More particularly, each of these advertise scripts associated with the directory containers  to which the user belongs are handed to the managed software installer mechanism for processing, via the MsiAdvertiseScript( ) API, as set forth in the table below:",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"UINT WINAPI MsiAdvertiseScript ("}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LPCTSTR","szScriptFile, \/\/ path to script from MsiAdvertiseProduct"]},{"entry":["DWORD","dwFlags, \/\/ the SCRIPTFLAGS bit flags that control the"]},{"entry":[{},"script execution"]},{"entry":["PHKEY","phRegData, \/\/ optional parent registry key"]},{"entry":["BOOL","fRemoveItems); \/\/ TRUE if specified items are to be removed"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Typedef enum tagSCRIPTFLAGS",{}]},{"entry":"{"},{"entry":["SCRIPTFLAGS_CACHEINFO = 0\u00d700000001L,","\/\/ set if the icons need to be"]},{"entry":[{},"\/\/ created\/ removed"]},{"entry":["SCRIPTFLAGS_SHORTCUTS = 0\u00d700000004L,","\/\/ set if the shortcuts needs to"]},{"entry":[{},"\/\/ be created\/ deleted"]},{"entry":["SCRIPTFLAGS_MACHINEASSIGN = 0\u00d700000008L,","\/\/ set if product to be"]},{"entry":[{},"\/\/ assigned to machine"]},{"entry":["SCRIPTFLAGS_REGDATA_APPINFO = 0\u00d700000010L,","\/\/ set if the app advt"]},{"entry":[{},"\/\/ registry data needs to be written\/ removed"]},{"entry":["SCRIPTFLAGS_REGDATA_CNFGINFO = 0\u00d700000020L,","\/\/ set if the product cnfg"]},{"entry":[{},"\/\/ mgmt registry data needs to be"]},{"entry":[{},"written\/ removed"]},{"entry":"SCRIPTFLAGS_REGDATA = SCRIPTFLAGS_REGDATA_APPINFO |"},{"entry":["SCRIPTFLAGS_REGDATA_CNFGINFO,","\/\/ for source level backward compatibility"]},{"entry":"SCRIPTFLAGS_VALIDATE_TRANSFORMS LIST = 0\u00d700000040L"},{"entry":"} SCRIPTFLAGS;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"82"},"In accordance with one aspect of the present invention, assigned and published applications may be installed (and also patched, as described below) on the local workstation on an as-needed basis (on demand) by the managed software installer mechanism . For example, the first time that a user activates such an application (e.g., via the Start Menu), the managed software installer mechanism looks for it on the local machine but does not find it, after which the managed software installer mechanism installs the application, such as via a software implementation  maintained in the class store  and\/or via an application image  () on a network server . Note that the network server  may be the same server  on which the application package  was loaded, which may or may not be the domain controller , however as can be appreciated, this is not necessary. Thereafter, the application remains on the local workstation and need not be re-installed, unless deleted in some manner. However, even if deleted, the application will be re-advertised the next time policy is applied, e.g., at the next user logon, whereby if again activated, the application will again be re-installed. Note that if the application is installed but damaged, e.g., key files are deleted, the application may perform self-repair at this time. In this manner, assigned applications are automatically deployed in accordance with a policy, but for purposes of efficiency, initially may be only advertised rather than installed. Similarly, a standalone user may have programs advertised without taking up substantial storage on the user's machine. Thus, as can be readily appreciated, installing programs only if and when activated provides substantial benefits, including efficient use of workstation resources, rapid user-logon, and balancing of the load on the network servers.","To manage the advertised applications, the managed software installer mechanism uses the identifiers set forth in the following table:",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{ProductCode}","A standard GUID which uniquely identifies"]},{"entry":[{},"a product."]},{"entry":["FeatureID","A string which represents a feature. A FeatureID"]},{"entry":[{},"should be human readable and need"]},{"entry":[{},"only be unique within a given product."]},{"entry":["{ComponentCode}","A standard GUID which uniquely identifies"]},{"entry":[{},"a component."]},{"entry":["[Descriptor]","A descriptor is comprised of a {ProductCode},"]},{"entry":[{},"a FeatureID and a {ComponentCode}"]},{"entry":[{},"within square brackets, e.g.,"]},{"entry":[{},"[{ProductCode}FeatureIDdelimiter"]},{"entry":[{},"{ComponentCode}]. A"]},{"entry":[{},"delimiter exists between the FeatureID and the"]},{"entry":[{},"{ComponentCode} since a FeatureID"]},{"entry":[{},"is variable in length."]},{"entry":["Delimiter","ASCII value 2, chosen so as to not collide with"]},{"entry":[{},"characters that might appear as part of a FeatureID"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In certain cases \u201ccompressed\u201d descriptors, which have a slightly different format, may be used. Products, features components and descriptors are described in more detail below with particular respect to . The per-user configuration manager information is stored below the registry key HKEY_CURRENT_USER\\Software\\Microsoft\\Installer. General properties for each advertised product are stored under a Products key by {ProductCode}.","An association between the managed software installer mechanism and the operating system  (e.g., shell and essentially OLE) enables on-demand installation of software implementations. For example, as represented in , shell and OLE activation code (collectively ), as well as many shell and OLE-related registry entries, are preferably installer mechanism-aware.","To this end, managed shortcuts include a descriptor (based on a shortcut, classID, file extension and so on) that the shell activation code (of the operating system ) detects, and hands to the managed software installer mechanism , (to await resolution in the form of a path, which it may then process). Similarly, OLE activation is aware of such descriptors, and calls an API of the managed software installer mechanism to resolve them. Both of these operations are represented in  by the circled numeral one.","By way of a first example,  shows the general operation taken by the installer when a user attempts to activate an advertised application (e.g., ) by clicking a shortcut corresponding thereto, beginning at step . At step , the operating system  communicates with the managed software installer mechanism to determine if the application  is locally installed, one of the possible states of an advertised application as described below. As represented by the circled numeral two in , the managed software installer mechanism looks to the system (i.e., the registry or similar database) to determine if the state is locally installed (or broken, for purposes of self-repair), and receives this state information as represented by the circled numeral three. At step  (), if the application  is not locally installed, the installer installs it (or at least some core portion thereof) at step , as also represented by the circled numeral four in , wherein the dashed line beside the circled numeral four indicates an optional operation, and as described in more detail below. Also, the state of the application  is changed to locally installed, so that the next time activation thereof is requested, installation is not necessary. Moreover, the application may be patched if a patch has been applied thereto, as evaluated at step . , described below, represents the steps taken to patch an application on demand when a patch has been applied thereto, in accordance with the present invention. Lastly, the managed software installer mechanism provides the operating system\/OLE  with the information needed to execute the application (circled numeral five in ), and at step  () the operating system  executes the application. Note that except for possible installation delay times, in typical situations, the installation is essentially invisible to the requesting user. Of course, if the source cannot be located, e.g., the network is down or a CD-ROM source is not in the drive, the install may fail, look for another source, and\/or the user may see a prompt requesting some user action. More particularly, see the aforementioned U.S. patent application entitled \u201cSystem and Method for Managing Locations of Software Components Via a Source List.\u201d","An administrator may also choose to publish an application, essentially to make the application available to a user if needed. Published applications are just as manageable as assigned applications, however unlike assigned applications, a published application has no presence on a user's machine until invoked. Thus, a published application has no attributes on the client machine, but rather has its attributes stored in the Active Directory . A published application can be located in the Active Directory in a number of ways, including via an application name, a class ID serviced by the application, a program ID serviced by the application, a file extension serviced by the application, and MIME type or content type serviced by the application.","To this end, each of the above attributes may be used as the key to locate a published application in the Active Directory . Then, once a published application is located, the application's user-friendly (human readable) name is available, as well as enough information to assign the application to the user. Thus, until needed, a published application is not installed, nor does it appear to the user to be installed. For example, there are no shortcuts present to use for activating the application. Instead, published applications may be activated by the above-attributes such as file extension, in a two-step process as described below with particular reference to . First the operating system  shell (or similarly OLE) attempts to locate the application activation information in the local machine's registry . If the information is not found (as with a published application), an Active Directory  lookup occurs (as described in the aforementioned \u201cClass Store Schema\u201d patent application. This is alternatively shown by circled numerals one and two in . Note that the administrator may prioritize which application in the class stores handles which extension. If found, the application script is advertised as described above, i.e., the application is effectively assigned to the user, the registry is populated, the item added to the Start Menu, and so on as if the application was assigned. The process then launches the application. Conversely, if no associated application is found in the class stores , an appropriate error is returned (e.g., no association for this application for this user). Note that the user may be given a roaming profile, whereby such information roams with the user regardless of where the user logon takes place. If not, the information stays on the machine that triggered the assignment. In this manner, published applications as well as assigned applications essentially follow the user around. Once the application is assigned, activation continues as with normal assigned applications.","By way of another example of the on-demand installation of applications, both assigned and published applications may be activated by invoking (e.g., double-clicking) a file (document) having an extension with an associated application registered in the registry.  show how such an action may lead to the file being installed if needed, beginning at step  which represents the double-clicking (or similar operation such as right-click, open) of the document. At step , the operating system shell  looks to the local registry  for file extension information, i.e., an application associated with the file extension. If the information is found, step  branches to step  which then calls the installer to locate the associated application and return a file system path thereto () as described below. Note that the administrator may prioritize which application handles which extension since multiple applications may be capable of handling the same file type.","If not found in the local registry  at step , then an application corresponding to the extension has not been assigned, however an application corresponding to the extension may still be published to the requesting user. Published applications are just as manageable as assigned applications, however unlike assigned applications, a published application has no presence on a user's machine until invoked. Thus, a published application has no attributes on the client machine, but rather has its attributes stored in the Active Directory . Notwithstanding, a published application may be patched by maintaining information accessible to the installer indicating that a certain patch is to be applied if a published application is ever installed. In this case, the patch is considered to be applied to the application already, because enough of the application exists on the machine (e.g., some installer registry information) that allows the patch to be registered. Note that even though the patch is considered to be already applied to the product, no files, registry keys and so on for that product may be modified because they have not yet been installed.","Note that a published application can be located in the Active Directory in a number of ways, including via an application name, a class ID serviced by the application, a program ID serviced by the application, a file extension serviced by the application, an interface identifier serviced by the application and MIME type or content type serviced by the application. To this end, each of the above attributes may be used as the key to locate a published application in the Active Directory . Then, once a published application is located, the application's user-friendly (human readable) name is available, as well as enough information to assign the application to the user. Thus, until needed, a published application is not installed, nor does it appear to the user to be installed. For example, there are no shortcuts present to use for activating the application.","Thus, when a possibly-published application is invoked, step  branches to step  to look for the extension information in the Active Directory , i.e., the class stores  associated with this user. To determine this, at step , the operating system calls an application management service  to find the appropriate script or scripts and look in the scripts for the file association. To this end, a class store manager  is called by the application management service  to query the class stores  for an appropriate application as described in the aforementioned \u201cClass Store Schema\u201d patent application. This is alternatively shown by circled numerals one and two in . Note that the administrator may similarly prioritize which application in the class stores handles which extension. If found, the application script is advertised at step  as described above, i.e., the application is effectively assigned to the user, the registry is populated, the item added to the Start Menu, and so on as if the application was assigned. The process then returns to step  so that the application may be launched. Conversely, if no associated application is found in the class stores  at step , an appropriate error is returned (e.g., no association for this application for this user) at step .","Note that if the directory lookup is successful, the return information is used to assign the application to the user's profile. As a result, the user may be given a roaming profile, whereby such information roams with the user regardless of where the user logon takes place. If not, the information stays on the machine that triggered the assignment. In this manner, published applications as well as assigned applications essentially follow the user around. Once the application is assigned, activation continues as with normal assigned applications.","To launch an application, managed shortcuts include a descriptor (based on a shortcut, classID, file extension and so on) that the shell activation code (of the operating system ) detects, and hands to the managed software installer mechanism , (to await resolution in the form of a path, which it may then process). Similarly, OLE activation is aware of such descriptors, and calls an API of the managed software installer mechanism to resolve them.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 10","FIG. 7","FIG. 5"],"b":["84","84","1000","84","1002","84","1004","84","75"],"i":["b ","b ","b ","b ","b "]},"As part of the process that returns the file system path, the installer thus verifies that the application in question has been installed and\/or has its key files intact, as represented by step . If the application is not installed, or is determined to be damaged, the installer will install and\/or repair the application by installing any needed files, as represented by steps  and the steps of . , described below, represents the steps taken when a patch has been applied, wherein the installer handles the patching of the application.","Lastly, at step , the installer returns the application path to the operating system. Regardless of whether previously installed or not, and assuming no other errors, security problems and so forth, the application is launched at step  ( and circled numeral six, ), and the application appropriately opens the document.","Note that many file extensions are capable of being handled by multiple applications. The administrator or user may prioritize which applications open which files. To this end, each application sets forth the file extensions it is capable of handling, and this information is stored in the Active Directory . When a file extension is selected, a suitable mechanism may be employed to scan the application information in the Active Directory to locate those applications that handle that file type. Via a suitable user interface, the administrator may then determine which application association gets written into the registry for that file type, and also may rank the order of searching for a suitable application in the class store  to open the file in the event that the association is not found in the registry. The ability to recognize applications which service the same extension, and therefore the ability to prioritize them, stems largely from two features of the installer, i.e., the ability to create advertise scripts, and the fact that the extensions serviced by a given product can easily be read from .MSI packages.","In addition to installing applications, the managed software installer mechanism may install other software implementations such as an application's object classes  (). To this end, the class store  maintains the classes  (or the information needed to locate the classes on the network). When the operating system , OLE or the like receives a request for an object class, it first communicates with the managed software installer mechanism to determine if the object class is locally installed. If not found locally, the managed software installer mechanism looks for the object class in the class store . If found, the managed software installer mechanism installs the object class therefrom, instead of returning an error.","The managed software installer mechanism may also install software implementations based on information such as component categories . For example, a category to which an application belongs effectively may be \u201cspreadsheet.\u201d If the managed software installer mechanism receives a category request for a spreadsheet application, the mechanism may look to the component categories , also maintained in the class store , to determine if a spreadsheet application is published to the user, and if so, install that application.","In general, the managed software installer mechanism  b provides a standard installation mechanism for applications and components, i.e., it is an execution engine for the setup scripts generated by the application deployment editor  or other various authoring tools. In general, the package is what a developer uses an authoring tool to create, i.e., essentially when a developer \u201cwrites a setup,\u201d the result is a Windows installer package. From that package, advertise scripts are created, and subsequently executed. However, it is also possible to install the package itself by generating and then running an install script. Generation and execution of install scripts are both handled on the end user's machine, in contrast to the advertising script model. For example, this happens in response to a standalone install, or as the result of install on demand.","As described in more detail below, the managed software installer mechanism also exposes an application programming interface (API) which an application program  may use () to determine what installation choices users made, or even to install missing components. For example, if a component is missing, the application  itself may in effect run setup for the user, using installer APIs as set forth below to install the missing component. Moreover, because the managed software installer mechanism is a basic system service that tracks information about what is installed, it may provide administrators in managed environments with a powerful set of tools for determining the software installed, and remotely pushing software installation down to user machines.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 12","b":["84","100","102","104","96","106","74","35","108","104","110","110","100","104"],"i":"b "},"Although not necessary to the present invention, to improve installation, the installer is arranged to divide applications into a three-level hierarchy, such as in the sample feature hierarchy shown in . At the top of the hierarchy is a product , which is an implementation that an administrator or end-user may install, e.g., a specific word processing application package such as Microsoft\u00ae Word. As further shown in , a product may be composed of multiple features such as the features \u2013, wherein a feature is the smallest installable unit of functionality. Examples of features of a word processor are a reader , Editor , Spellchecker , and Printer . A feature is something an administrator\/user may choose to install or not, and thus somewhat corresponds to a checkbox in the \u201cCustom\u201d or \u201cAdvanced\u201d installation dialog of a conventional installation mechanism.","Features in turn comprise one or more components such as \u2013, wherein a component is the smallest unit of sharing among products and features. For example, a component such as component may be shared by both the Reader feature and the Editor feature . Only one copy of the corresponding file (e.g., a DLL) is actually installed, but that copy is installed if either Feature or Feature is installed. Note that while  shows components composed of files \u2013, components are the actual contents of a product, and may be composed of files, registry entries, COM registration information, Visual Basic type libraries, shortcuts, (e.g. for the Windows Start menu), and so on.","While features are specific to a product and identified by a name unique only within the product (e.g. \u201cReader\u201d), components are global across all products installed on a machine and are identified by a GUID. Note that although COM components are also uniquely identified by a GUID and may be encapsulated as an installer component, an installer component is not related to COM. An installer component  is monolithic, i.e. it is either entirely installed on a machine or not installed at all. Because installer component identifiers are global, they are shared across products.","By way of example, a number of products ship the Microsoft Visual Basic for Applications (VBA) runtime. Defining VBA as an installer component  provides advantages, including that the installation logic for VBA can be encapsulated within the component , so all products which install VBA will install and uninstall it in exactly the same way. Also, once VBA is installed on a machine, the managed software installer mechanism  knows that VBA is there, and installation of subsequent products which use this component simply increase an installation reference count of the component, i.e., the products share the same copies of the files. Moreover, since the managed software installer mechanism  manages the installed components, it operates properly when a product is uninstalled, i.e., the reference count ensures that the mechanism does not remove components shared by products remaining on the machine.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 14","b":["1400","1402","1404","1406","1408","1410"]},"Turning to an explanation of how an application may interface with the managed software installer mechanism ,  generally represent the steps taken by the application  and installer  () to provide on-demand installation of features and components. First, at step  of , the application  determines that it needs a feature or component, (or at least state information regarding same). At step , using the QueryFeatureState API, (described below), the application  requests the state of the feature or component from the installer. The state may be Absent, i.e., intentionally turned off by the user or administrator, and thus should not be installed by the application. Otherwise, the state may be Local (locally installed), Source (residing on a source media such as a network drive), or Advertised, (not installed but may be installed from the source when first needed). Based on the state, step  determines whether the feature or component needs to be installed, i.e., it is not locally installed, but now it is needed and is proper for local installation. Step  represents the installation on demand.","Step  () is next executed, wherein the application  requests the installer  to verify that the needed files are present. To this end, the MsiUseFeature API is called. In general, the MsiUseFeature API does two things, i.e., verifies that the feature is intact, and increments the usage count (the usage count is the number of times that the user or application has used the feature). Note also that, if the feature is installed as run-from-source, (e.g., from the network or CD-ROM), part of the verification that the feature is intact involves finding a valid source. At step , a verify status of valid or invalid is returned, whereby step  branches to step  to install needed files if the status is invalid. Note that until valid, step  may keep returning to step  to request verification, some number of times before failing (not shown). However, if the verification returns valid status, at steps \u2013, the application  requests and receives the path from the installer  and loads\/executes it as appropriate.","In this manner, applications may repair themselves such as by installing missing or damaged components or files. Applications may avoid errors by checking with the installer  before making assumptions about what is installed on a machine at a given time. Missing features and components will be automatically installed by the installer mechanism whenever possible (and if allowed).","The Windows Installer (MSI) APIs","The following describes some of the MSI APIs utilized for on-demand installation of software implementations, wherein the \u201c%\u201d symbol represents ANSI (A) and Unicode (W) versions. MsiGetProductCode returns the product code for a registered component, i.e., this API returns information on the product that installed an application:",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT WINAPI MsiGetProductCode%("]},{"entry":[{},"LPCSTR% szComponent, \/\/ component ID registered for this product"]},{"entry":[{},"LPSTR% IpBuf39); \/\/returned string GUID, sized for 39 characters"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"INSTALLSTATE WINAPI MsiQueryFeatureState%("]},{"entry":[{},"LPCSTR% szProduct,"]},{"entry":[{},"LPCSTR% szFeature)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"A management tool, for example, may enumerate the published features for a given product by calling MsiEnumFeatures:",{"@attributes":{"id":"p-0107","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT WINAPI MsiEnumFeatures %("]},{"entry":[{},"LPCSTR% szProduct,"]},{"entry":[{},"DWORD iFeatureIndex, \/\/ zero based index into published features"]},{"entry":[{},"LPSTR% IpFeatureBuf, \/\/feature name buffer, size ="]},{"entry":[{},"MAX_FEATURE CHARS+1"]},{"entry":[{},"LPSTR% IpParentBuf); \/\/parent feature buffer, size ="]},{"entry":[{},"MAX_FEATURE_CHARS+1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"To request and install a feature, the following procedure may be used:","Call MsiUseFeature, passing in the ProductCode and FeatureId","If the return code is INSTALLSTATE_LOCAL or INSTALLSTATE_SOURCE, proceed down the hierarchical \u201cpyramid\u201d of code.","If the return code is INSTALLSTATE_UNKNOWN or INSTALLSTATE_ABSENT, an error occurred, since MsiQueryFeatureState should first be called to ensure that only features known to be available are requested.","If the return code is INSTALLSTATE_ADVERTISED, call MsiConfigureFeature, passing in the ProductCode, FeatureId and INSTALLSTATE_DEFAULT.","The following are return states from MsiUseFeature:","INSTALLSTATE_UNKNOWN: the product\/feature is not known","INSTALLSTATE_ABSENT. the feature is in the absent state","INSTALLSTATE_ADVERTISED: the feature is in the advertise state","INSTALLSTATE_SOURCE: the feature is install run-from-source and a valid source is available","INSTALLSTATE_SOURCEABSENT: the feature is install run-from-source and a valid source is not available","INSTALLSTATE_LOCAL: the feature is installed locally and the components that comprise the feature (and its parents) are all intact","INSTALLSTATE_BROKEN the feature is installed locally and the components that comprise the feature (and its parents) are not all intact (one or more keyfiles are missing)","Note that the above algorithm is one possible way to treat the return values from MsiUseFeature, but not the only way. For example, (although not preferable) an application could choose not to use MsiQueryFeatureState, but could simply use the return value from MsiUseFeature to determine whether a feature was usable or not.","MsiUseFeature indicates an intent to use a product feature and increments the usage count therefor:",{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"INSTALLSTATE WINAPI MsiUseFeature%("]},{"entry":[{},"LPCSTR% szProduct,"]},{"entry":[{},"LPCSTR% szFeature)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"MsiConfigureFeature forces the installed state for a product feature:",{"@attributes":{"id":"p-0125","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT WINAPI MsiConfigureFeature %("]},{"entry":[{},"LPCSTR% szProduct,"]},{"entry":[{},"LPCSTR% szFeature,"]},{"entry":[{},"INSTALLSTATE eInstallState),"]},{"entry":[{},"\/\/local \/ source \/ default \/ absent \/ lock \/ uncache"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"An alternative to MsiConfigureFeature is MsiConfigureFeatureFromDescriptor, useful for making templates, add-ins and Access wizards more resilient. MsiConfigureFeatureFromDescriptor is essentially the same as MsiConfigureFeature, but takes a descriptor (token) rather than separate product and feature parameters:",{"@attributes":{"id":"p-0127","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT WINAPI MsiConfigureFeatureFromDescriptor %("]},{"entry":[{},"LPCSTR% szDescriptor,"]},{"entry":[{},"INSTALLSTATE eInstallState), \/\/local \/ source \/ default \/ absent"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Once an application has requested a feature, it may perform its usual operations such as loading DLLs, opening data files and so on. However, as long as the application first asks where the file is located, dynamically loading DLLs should not fail for DLLs that are the key file of a component. The general information for accessing a file is set forth below:","Call MsiGetComponetPath, passing in the component ID and other appropriate parameters.","If the return code is INSTALLSTATE_ABSENT, then MsiUseFeature\/MsiConfigureFeature was not properly called.","If the return code is INSTALLSTATE_UNKNOWN, then the component is not installed\/known.","If the return code is INSTALLSTATE_DEFAULT, then the call was successful. (see the return values for MsiGetComponentPath. We never return INSTALLSTATE_DEFAULT. INSTALLSTATE_LOCAL and INSTALLSTATE_SOURCE imply success).","If the return code is INSTALLSTATE_SOURCE_ABSENT (see above), then, for example, the network has gone down, or a CD-ROM is not loaded in the appropriate drive, whereby resiliency procedures should be invoked.","A fully qualified key file should be returned, and parsing may be needed such as if a file that is not the key file is desired.","In certain situations, i.e., when accessing a folder, a path is returned without a key file. Also, if the \u201ckey file\u201d is a registry key or value then the registry key or value will be returned instead of a path to a file.","The following sets forth the return values for MsiGetComponentPath:\n\n","MsiGetComponentPath is a registry lookup that returns the full path to an installed component:",{"@attributes":{"id":"p-0138","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"INSTALLSTATE WINAPI MsiGetComponentPath %("]},{"entry":[{},"LPCSTR% szProduct, \/\/ product code for client product"]},{"entry":[{},"LPCSTR% szComponent, \/\/ component ID, string GUID"]},{"entry":[{},"LPSTR lpPathBuf, \/\/ returned path"]},{"entry":[{},"DWORD *pcchBuf) in \/ out buffer character count"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A typical method is to call MsiGetComponentPath after performing the feature request steps set forth above. An alternative is to call MsiProvideComponent, which bundles three APIs (MsiUseFeature, MsiConfigureFeature, MsiGetComponentPath) into one. MsiProvideComponent returns the full component path, performing any necessary installation. As described with reference to , MsiProvideComponent and MsiProvideComponentFromDescriptor call MsiUseFeature to detect that components are installed, calls MsiConfigureFeature if any of its components are uninstalled, and then calls MsiGetComponentPath to obtain the path to its key file:",{"@attributes":{"id":"p-0140","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT WINAPI MsiProvideComponent %("]},{"entry":[{},"LPCSTR% szProduct, \/\/ product code in case install required"]},{"entry":[{},"LPCSTR% szFeature, \/\/ feature ID in case install required"]},{"entry":[{},"LPCSTR% szComponent, \/\/ component ID"]},{"entry":[{},"DWORD dwReserved \/\/reserved, must be zero"]},{"entry":[{},"LPSTR% lpPathBuf, \/\/ returned path, NULL if not desired"]},{"entry":[{},"DWORD *pcchBuf) in \/ out buffer character count"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"MsiProvideComponentFromDescriptor is essentially the same as MsiProvideComponent, but uses a descriptor instead of the product\/feature\/component identifiers:",{"@attributes":{"id":"p-0142","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT WINAPI MsiProvideComponentFromDescriptor %("]},{"entry":[{},"LPCSTR% szDescriptor \/\/ product, feature, component information"]},{"entry":[{},"LPSTR% lpPathBuf, \/\/ returned path, NULL if not desired"]},{"entry":[{},"DWORD *pcchBuf) in \/ out buffer character count"]},{"entry":[{},"DWORD *pcchArgsOffset) returned offset of args in descriptor"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This API, and MsiInstallMissingFile, below, are final, alternative attempts to fault in a feature, given a component or filename. It is expected that an application developer will attempt to use the other APIs to fault in features, but this may not always be possible. As a result, it is anticipated that such developers may benefit via these APIs.","To recover from a missing component error (following a call to MsiLocateComponent), a missing component may be reinstalled by MsiInstallMissingComponent, checking for a return code of ERROR_SUCCESS and then calling MsiLocateComponent again:",{"@attributes":{"id":"p-0145","num":"0152"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"UINT WINAPI MsiInstallMissingComponet %("},{"entry":"LPCSTR% szProduct, \/\/ product code"},{"entry":"LPCSTR% szComponent, \/\/ component ID, string GUID"},{"entry":"INSTALLSTATE eInstallState), \/\/local \/ source \/ default \/ absent invalid"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"To recover from a missing file error (i.e., an application has failed in an attempt to open a file) the general procedure of calling MsiInstallMissingFile, checking for a return code of ERROR_SUCCESS and then re-trying the file I\/O operation:",{"@attributes":{"id":"p-0147","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT WINAP1 MsiInstallMissingFile %("]},{"entry":[{},"LPCSTR% szProduct, \/\/ product code"]},{"entry":[{},"LPCSTR% szFile); \/\/ filename without path"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The present invention is generally directed to the on-demand patching of application programs, since in general, updating application programs is the primary usage of patching technology. Thus, for purposes of simplicity, the following example and accompanying drawings () will refer to patching an application. Notwithstanding, as will be understood, virtually any software implementation that may be installed may also be patched in accordance with the present invention, and there is no intention to limit the present invention to application programs.","As shown in , once an application (e.g., APP) is advertised and\/or installed, the initial install state  of the application is maintained on the local machine (e.g., in the registry ) and is thus available to the managed software installer mechanism as described above. Note that although referred to as \u201cinstall\u201d state information, the information may indicate that the application is not yet installed. As shown in , the initial install state information  includes information such as a list of files (e.g., in a table ) that should be installed for the application, and registry keys and the values therefor (e.g., in a table ). Also maintained by the installer is information  that is specific to this particular installation, such as which options the user has selected for installing, e.g., which of several available templates, if any, the user wants to have available with the application. Further, although primarily maintained locally for performance reasons, a copy  of the application package  is maintained as a file on the local machine , e.g., in a folder that is private to the installer mechanism . The information maintained by the installer mechanism includes a local path to the application package , and possibly includes one or more paths to other copies thereof (e.g., the network share).","When the user (or administrator) wishes to install a patch, the user downloads and\/or otherwise runs an executable patch installation program  (). In keeping with the present invention, patch information, maintained in a managed software patch , (i.e., the patch), is maintained by the installer as install state information \u2032 for the application APP\u2032, (wherein the prime \u201c\u2032\u201d designation is used herein to indicate a change as a result of a patch). Thereafter, whenever the installer is called to perform an installation operation for the application, e.g., install the application on demand, verify and as necessary fix the application files, and so forth, the installer mechanism uses the patched install state information \u2032 as the basis for determining what files, registry settings and so on the application should have installed therefor. Note that a patch may be created that neither touches files nor registry key, i.e., a patch that has no additions, modifications or deletions involving files or registry keys, shortcuts, and so forth. For example, such a patch might only change some of the installation logic, such as the user interface that gets displayed, e.g., a simple patch of this type might change the text in the License Agreement that appears on the first screen when a user clicks on setup.","As represented in , the patch  includes summary information  such as properties, including a list of one or more applications (i.e., as identified by product code) to which the patch  can be applied. For example, a patch may be prepared for a suite of applications, whereby the patch may be able to patch any of the applications in the suite even if the user has less than the full amount of applications advertised or installed. Moreover, a patch may be arranged to patch two or more earlier versions of applications, for example, a patch release . that can patch application X or application X\u2032 (patched with release .). In any event, the summary information  informs the installer as to which applications the patch  applies.","The patch  also includes one or more transforms , which essentially modify the results of running the initial advertise script  in the initial install package , so as to inform the installer as to what changes are to be implemented by the patch . For example, transforms may instruct the installer to install new files for this application, delete certain others, and change selected others. The patch  also typically includes \u201cpatch bits\u201d , comprising the various new files and\/or change information (file bits comprising the deltas) needed by the transforms . These patch bits  may be compressed into cabinet files or the like as desired.","By way of example,  shows how an application, APP, is to be changed by a patch  into a patched application, APP\u2032. In , the application APP initially has the file \u201cFile, version 1.0\u201d associated therewith, (along with possible many other files, not listed). Also, the application APP has an entry for writing in the registry  with a value of one, (RegKey's value equals one). After patching, the application APP\u2032 should have \u201cFile, version 2.0\u201d and \u201cFile , version 2.0\u201d for its associated files, and a new value for RegKey equal to two, as shown in the patch-adjusted APP\u2032 information. To accomplish the change, the patch  includes transforms  that essentially instruct the installer to change the files (e.g., when installed) such that File version 1.0 will be changed to File version 2.0, and such that File version 2.0 will be installed. Similarly, the RegKey value will be changed to two. The patch  also includes the various file bits  necessary to change File from version 1.0 to version 2.0, and also includes the file named File  (version 2.0).","In keeping with the present invention, the files are not necessarily changed (or installed) until needed, i.e., the patching may take place on demand. For example, an application that is advertised, but not installed, may be patched, but the patching need not take place until installation. To this end, as described below with reference to , changes are made to only files that are already installed. Those that are not yet installed will be changed when they are installed.","Turning to an explanation of the operation of the present invention, when a patch installation program  is first run, at step , the installer opens the managed software patch  within (or associated with) the program  to locate the product codes in the summary information . Then, as represented by step , the installer searches the local machine for products that are identified therein. Note that both assigned and published applications may be patched, even if not installed, as well as any other applications that are installed on the machine. If none are found, step  branches to step  to inform the user that the patch is not appropriate for this machine.","At step , if at least one patchable application is found, the installer , via step , opens the local copy  of the package , and at step  applies the transforms  to the package. In essence, the installer is modifying the tables \u2032, \u2032in view of the patch , and continues to step  of .","The transforms  may instruct the installer to update certain files. However, because of the ability of the installer to perform on-demand installation, those files need not be installed on the local machine at this time. Thus, beginning at step , the installer walks through the list of files \u2032 to determine at step  whether each file identified for changing is presently installed. If installed, the installer causes the file to be updated, for example the installer calls a change engine or the like, passing the old file and the change information, whereby the change is made. Such change engines are well known in patching, and thus are not described in detail herein. If not installed (step ), the listed file is marked at step , e.g., a certain bit is set therefor, to indicate that the file is patchable and should be updated whenever the installer installs it. Step  repeats the process until the listed files are either updated or marked for updating.","Step  is then executed to install any new files and\/or delete any existing files as set forth in the transforms . Note that installation of the new files may also be deferred by marking them for install rather than installing, such as if the key files of the application are not yet installed. This may be made dependent on other factors, e.g., the size of the file, whether another, installed application may benefit from the new file and so on. Also, note that if the transforms designate a file for deletion, but that file is still needed by another application, a reference count or the like associated with that file may instead be adjusted. Step  writes any registry key changes to the registry, such as to advertise the application as available, e.g., write any new file extensions to the registry so that the application will be activated when such an extension is clicked on. Lastly, step  updates the installer information  that is specific to this install as modified by the patch (although some or all of the actual installation may not have taken place).","In accordance with an aspect of the invention, once patched, the patching occurs on-demand for applications and the like that are not yet installed. To this end, whenever an application is installed on demand, (as described above with reference to ), if it has been patched, the installer also automatically patches the application on demand.  shows how this is accomplished, i.e., in a manner similar to  except that since the application is installed at this time, there is no marking of files for later installation. Thus, after the regular installation, step  selects the files to be updated, including those marked as patchable, and step  updates the files, e.g., sends the necessary information to a change engine. Step  repeats the process until the files-to-be changed are updated. Steps \u2013 are analogous to steps \u2013, described above, and ensure that the registry settings and installer information \u2032 are correct and current.","Note that a user may change the installed state of files on the machine (e.g., move, rename and delete), and\/or cause the same files to be installed or patched via other applications. Thus, a file that is marked as patchable may have already been installed and\/or patched. For example, a spreadsheet application may be patched, causing xyz.dll to be installed and patched (to xyz\u2032.dll), whereby an advertised, patched but uninstalled word processing application that shares xyz.dll will not need to be patched when it is installed. However, since the installer is in charge of both the on demand installation and on demand patching, for efficiency, the installer knows not install a file that is already installed, or update a file that has been updated, and similarly knows not to install a file that is to be deleted by the patch. The installer also verifies the correct installation state of a patched application, such as by executing steps analogous to steps \u2013 of  after each on demand install and\/or patching operation. Also, to allow for the removal of a patch from an application, if the entire application is uninstalled, the patch will not be applied at the next install. Note that the patch is reapplied if parts of the application (e.g., features) are uninstalled and reinstalled.","As can be seen from the foregoing detailed description, there is provided a method and system for automatically patching applications on demand. Via a managed patch, the initial install state information is modified and supplemented, whereby the patch will properly be applied at each install, including an on-demand installation.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIGS. 15A\u201315B"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
