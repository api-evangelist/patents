---
title: Modular shader architecture and method for computerized image rendering
abstract: One embodiment of the present invention sets forth a technique rendering an image pixel within a graphics image with multiple shaders in a single rendering phase using a modular shader architecture. A user specifies how geometric objects, light sources, and various types of rendering operations in a graphics scene are associated. A rendering application provides computational infrastructure for rendering operations that includes finding an intersected object for each pixel of a target graphics image. The modular shader architecture includes a means for efficiently developing and incorporating custom shader modules for use by the rendering application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08416238&OS=08416238&RS=08416238
owner: AUTODESK, Inc.
number: 08416238
owner_city: San Rafael
owner_country: US
publication_date: 20090218
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","Embodiments of the present invention relate generally to rendering graphics images and more specifically to a modular shader architecture and method for computerized image rendering.","2. Description of the Related Art","High-quality graphics rendering applications are commonly used to generate highly refined images, such as photorealistic graphics images, from mathematical models of three-dimensional (3D) graphics scenes. A graphics scene typically comprises scene objects with material properties, light sources with associated properties, camera positions, and other relevant data configured within a scene database of a modeling application. The modeling application conventionally generates a render database from the scene database. The high-quality rendering application traverses the render database to render a highly refined image from the graphics scene represented within the render database.","The high-quality graphics rendering application typically calls a plurality of shaders configured to impart various physically and visually significant effects on objects within the graphics scene. A shaded pixel may comprise contributions, organized as contribution types, from the plurality of shaders. Each type of shader, such as a material shader, may generate shading results from results computed by a plurality of other shaders, such as lighting shaders. For example, a material shader may generate shading results for a pixel based on specular lighting and diffuse lighting for a point on a scene object, whereby each source of lighting is computed from a corresponding lighting shader. A given shader may be a standard shader and provided as part of the rendering application, or the shader may be a custom shader, created by a shader developer. Each shader, whether standard or custom, may generate a contribution type that may be well known or custom.","Because the goal of high-quality rendering applications is to render images to the highest technically feasible standards, custom shaders are commonly employed to beneficially render certain visual effects and enhance overall image quality. These custom shaders may be separately invoked in a process known in the art as a render pass to generate images corresponding to standard contribution types or custom contribution types.","In order to simultaneously accommodate multiple standard and custom shaders and potential interdependencies between each, high-quality rendering applications conventionally perform a set of separate render passes to drive one shader to compute a complete rendering pass. However, each render pass typically requires significant computation independent of specific shader computations. Therefore, superfluous computations are required in order to perform each additional render pass, leading to inefficiency in the high-quality rendering application. Because the computational load related to a high-quality rendering application typically accounts for a majority of an overall computational effort for a given rendered end product, this inefficiency can be very costly to users.","Furthermore, each custom shader is typically required to implement significant rendering infrastructure related to generic rendering in a specific application context, but not related to the custom shading technique provided by the shader. This rendering infrastructure needs to be replicated for each custom shader, leading to workflow inefficiencies for software developers creating custom shaders.","As the foregoing illustrates, what is needed in the art is a technique for improving efficiency in developing and executing high-quality rendering applications.","One embodiment of the present invention sets forth a graphics library embedded in a computer-readable medium including instructions that, when executed by a processor, cause the processor to render a graphics image based on one or more shading modules included in the graphics library. The graphics library includes a source code list of shading modules, where each of the listed shading modules corresponds to a different material property for shading, for each listed shading module, a source code shading module that includes source code instructions that define a default shading function associated with the source code shading module and is configured to allow modification of the source code instructions to produce a customized shading function associated with the source code shading module, and a shader template that is configured to incorporate each source code shading module, including, for a particular source code shading module, either the source code instructions for the default shading function associated with the source code shading module or the modified source code instructions for the customized shading function associated with the source code shading module. The shader template is further configured to allow each source code shading module to be compiled into a shading program for rendering the graphics image.","One advantage of the disclosed graphics library is that it provides end-users with a framework for developing customized shading programs to generate customized shading effects. By providing a modular shading template to the end-user and exposing the source code of the different default shading modules to the end-user, the end-user can quite easily modify the default settings to generate customized results.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the present invention. However, it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the present invention.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","100","130","110","134","120","132","136","140","142","144","146","148"]},"The CPU  communicates with the system memory  via the memory bridge , which may be, e.g., a Northbridge device or subsystem. System memory  is configured to store application programs, as well as data used by or generated by the CPU . System memory  is coupled to the memory bridge  via a system memory bus . The memory bridge  is coupled to the GPU  via a GPU system bus . The GPU system bus  may comprise any technically feasible data interconnect, such as the well known personal computer interconnect (PCI) express bus. The memory bridge  is also coupled to the device bridge  using an interconnect system such as PCI. The GPU  conventionally incorporates real time image rendering means for rendering both three-dimensional (3D) and two-dimensional (2D) images. The GPU  delivers pixel data to display device , which may comprise a conventional CRT or LCD display. The GPU  is coupled to the GPU memory  using a GPU memory bus . The GPU memory  may be configured to store data used by or generated by the GPU . Data stored within the GPU memory  passes through the GPU  and the memory bridge  when accessed by the CPU . In some embodiments, the integrated circuit implementing the CPU  may incorporate additional functional blocks, such as the memory bridge  and the device bridge . In alternative embodiments, the integrated circuit implementing the GPU  may incorporate additional functional blocks, such as the memory bridge  and the device bridge .","The device bridge  is coupled to a hard drive , a network interface , a mouse , and a keyboard . The hard drive  provides mass storage of programs and data. The network interface  provides network connectivity to other computers using a local area network (LAN) interface using any suitable technology, such as Ethernet. The mouse  and keyboard  provide user input. Other components (not explicitly shown), including USB or other port connections, CD drives, DVD drives, film recording devices, and the like, may also be connected to I\/O bridge . Communication paths interconnecting the various components in  may be implemented using any suitable protocols, such as PCI (Peripheral Component Interconnect), PCI Express (PCI-E), AGP (Accelerated Graphics Port), HyperTransport, Quick Path Interconnect, or any other bus or point-to-point communication protocol(s), and connections between different devices may use different protocols as is known in the art.","In one embodiment, system memory  is configured to store a graphics modeling application , a graphics rendering application , a compositing application , an editor -, and a compiler -. The graphics rendering application  should include at least one shader module. The shader module may communicate with the rendering engine using any technically feasible means, such as a rendering application programming interface (API). System memory  is also configured to store a plurality of frame buffers , which may be configured to store scene segments rendered by the rendering engine, and an image generated by the compositing application . The compositing application  combines segments according to a contribution value for each segment to generate a composite image. For example, the rendering application  may render segments stored in frame buffers - through -, and the compositing application  may combine the segments to generate a composite image, such as a final image, stored in frame buffer -. The rendering application  uses shader functions within a customized shader program - to compute color samples, such as color, transparency, and other aspects of pixels or fragments in a graphics scene.","The editor - is used to generate and modify source code files stored in persistent memory, such as on the hard disk . The compiler - is configured to read in and parse certain source code files to generate, or \u201ccompile\u201d executable code. For example, the editor - may be used to modify source code file  and the compiler - may compile source code file  to generate the customized shading program -. The customized shading program - should be compiled to include housekeeping functionality for shading operations embodied in a shader application -, and specific shading functions included in a shader template -. The source code file  may include a source code representation of the shader template - and related shader modules. The rendering application  may be coupled to the customized shading program - to incorporate modifications made by the editor -. In one embodiment the customized shading program - is incorporated into the rendering application .","In an alternative embodiment, a first computer system includes a modeling application, and may include a compositing application. Additionally, a set of one or more computer systems may include at least one instance of the rendering application. In this scenario, the set of one or more computer systems is configured to communicate via a computer network. In this embodiment, the first computer system includes software configured to cause each computer system in the set of one or more computer systems to independently render and store scene segments.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2","b":["200","200","220","222","1","210","2","212","3","214","200","224"]},"Object   may be rendered in isolation for the purpose of rendering scene segments into independent frame buffers  that may be used for fine-tuning the rendered image in a subsequent compositing phase. To maximize realism, object   should be rendered with other objects and lights, in context in the scene, wherein each rendering pass or group of rendering passes may be written to a separate frame buffer.","A camera  and an associated position for the camera  establish a viewport  into graphics scene . The viewport  comprises a two-dimensional array of pixels, each serving as a sample point of the graphics scene . Each pixel may comprise one or more sub-pixel samples. Persons skilled in the art will recognize that rendering the graphics scene  may be accomplished using different well known techniques, such as ray tracing or scan line rendering. For example, to compute the color of a pixel in the viewport  using ray tracing, at least one eye ray  is projected from the camera , through the pixel sample in the viewport , and into the graphics scene  until the eye ray  intersects with an object within the graphics scene . In this scenario, the eye ray  intersects object   at eye ray intersection  on the surface of object  . Depending on material properties of the object  , the eye ray  may be projected further into graphics scene , for example, along a light ray . In this scenario, the light ray  intersects light source -, potentially imparting various forms of illumination from light source - on object   at the eye ray intersection . Each pixel of the viewport  is similarly sampled by projecting a corresponding eye ray from the camera  through the viewport .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3","b":["210","352","350","356","354"]},"As shown, rendering passes associated with object   include, without limitation, diffuse lighting , ambient lighting , specular lighting , ambient occlusion , matte surface mapping , opacity , and reflection . Each rendering pass imparts a specific effect on object  . The effects of multiple rendering passes may be grouped into pass contribution maps . For example, diffuse lighting , ambient lighting , specular lighting , and ambient occlusion  produce an illumination contribution ; matte surface mapping  may produce a matte pass contribution ; rendering opacity  produces an opacity contribution ; and, a reflection rendering pass  produces a reflection contribution .","For each object in the graphics scene , the pass contribution maps  define associations between lights , objects , and rendering passes . These associations may be defined using any technically feasible means. In one embodiment, an application user may define associations between objects, lights, and rendering passes using a graphical user interface (GUI) associated with the rendering application  of . One exemplary layout of a GUI used to define associations between objects and rendering passes is illustrated in . Persons skilled in the art will recognize that a drag-and-drop scheme for defining associations may provide an intuitive and efficient entry means for users. Association data should be stored in modeling application  and transferred to rendering application  and compositing application  using any technically feasible means. By defining, rendering, and storing results of each rendering pass in a separate frame buffer, the user is able to subsequently fine-tune the contribution of each rendering pass (e.g., in a compositing application) without performing additional time consuming rendering operations.","In one embodiment, object, light, rendering pass, and frame buffer association information needed to generate the pass contribution maps  are transmitted to the rendering application  to render each separate segment associated with each object (or set of objects) into a separate frame buffer.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4","b":["410","412","414","115","2"]},"The default component library  may include default shader modules for most types of conventional shading effects. For example, the default component library  may include default shader modules for default ambient material color , default ambient light , default diffuse material color , default diffuse light , default specular lighting , default reflection , default refraction , default scatter , default global illumination , and default incandescence .","The default shader modules within the default component library  should be used by the rendering application  if no user shader module is specified. When no user shader module is specified the default shaders are gathered within the shader template , which is then compiled with other related modules, such as shader application -, into the customized shader application -. The customized shader application - includes an interface, such as a first API, for calling functions within the compiled shader template , and a second interface, such as a second API, for receiving calls from the rendering application . If a user shader module is specified to replace a corresponding default shader module, then the user shader module replaces a respective default shader module within the shader template . When the shader template  is compiled into the customized shader application -, the rendering application  invokes the user shader module instead of the default shader module when invoking a corresponding shading operation. For example, a brushed metal shader may replace the default specular shader module , the default reflection shader module , and the default scatter shader module  with a custom specular shader module , a custom reflection shader module , and a custom scatter shader module , respectively. The custom shader modules , , , specified as user shader modules , are available to the rendering application  to render one or more scene objects requiring specialized shading for these specific types. In this scenario, the custom shader modules replace their corresponding default shader modules in the shader template  for use by the rendering application .","The rendering application  accesses the customized shader application -, which is generated using shader modules from either the default component library  or from the set of user shader modules . The shader template  is configured to include slots for well known rendering components, as well as slots for custom rendering components. In one embodiment, the well known component slots include an ambient material color component slot , an ambient component slot , a diffuse material color component slot , a diffuse component slot , a specular component slot , a reflection component slot , a refraction component slot , a scatter component slot , a global illumination component slot , an incandescence component slot , and one or more custom component slots . Persons skilled in the art will recognize these shader module types and readily understand how to implement the associated shading functions.","In one embodiment, a C++ template mechanism is used to instantiate and incorporate the custom shader modules , ,  into the shader template  to form a useable shader. Persons skilled in the art will recognize that a C++ function template is an abstract function definition configured to operate on generic data types, and that a function template may include one or more type-specific implementations, each configured to operate on a specific data type or class. The C++ template mechanism resolves data type to implementation type bindings at compile time, enabling a compiler to advantageously generate high-performance, in-line executable code. Furthermore, certain portions of a shader application may be distributed to a user as object code to keep proprietary implementation information secure, while user-configurable portions may be distributed as source code, which includes default shading modules that may be modified by a user. Each default shading module may be customized by defining a corresponding custom implementation for the shading module. A list of defined slots for the default shading modules is provided in source code. When a user customizes a shading module within the source code and compiles the source code, in conjunction with other application object files, the customized shader application - is generated. At this point, the customized shader application - includes user customizations to the shading modules.","Table 1 includes exemplary C++ code fragments for computing specular effects within a Phong shader component for incorporation into an implementation of the modular shader architecture based on C++ function templates. Persons skilled in the art will recognize that each of the each important aspect of computing specular effects for Phong shading with respect to an individual sample may be easily modified in the code fragments. Specifically, the user may modify Equations 1 through 4 in the code fragments given in Table 1 to modify Phong shading specular behavior of a shader application compiled to include the code fragments. Importantly, for any given shader proprietary details of the shader application may be hidden from the user, whereas shading computation details for a given image sample may be fully revealed to the user in the form of source code. The source code also serves to provide structure for any customization needed by the user.\n\nmaterialSpecularColor=*mi_eval_color(&paras\u2192specularColor)\u2003\u2003(Eq. 1)\n\nspecularExponent=*mi_eval_scalar(&paras\u2192cosPower)\u2003\u2003(Eq. 2)\n\nreflectionSpecularity=*mi_eval_scalar(&paras\u2192reflectionSpec)\u2003\u2003(Eq. 3)\n\nresSpecular=phongSpecular*materialSpecularColor\u2003\u2003(Eq. 4)\n",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"template <typename ParameterType, typename ShaderHelper>"},{"entry":"\u2003\u2003class AppPhongSpecularComponent"},{"entry":"{"},{"entry":"public:"},{"entry":"\u2003\u2003AppPhongSpecularComponent(miState *state,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ParameterType *paras);"},{"entry":"\u2003\u2003~AppPhongSpecularComponent( ) { };"},{"entry":"\u2003\u2003\/\/ Called from the light loop in to determine specular"},{"entry":"\u2003\u2003\/\/ component for the current sample."},{"entry":"\u2003\u2003miColor operator( )(miState *state,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ParameterType *paras,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ShaderHelper &helper,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003miVector &pLightDirection,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003miVector &pReflectionDirection,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003miScalar pDotNL,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003miVector &pBumpNormal);"},{"entry":"public:"},{"entry":"\u2003\u2003miColor materialSpecularColor;"},{"entry":"\u2003\u2003miScalar specularExponent;"},{"entry":"\u2003\u2003miScalar reflectionSpecularity;"},{"entry":"};"},{"entry":"template<typename ParameterType, typename ShaderHelper>"},{"entry":"\u2003\u2003AppPhongSpecularComponent<ParameterType, ShaderHelper>::"},{"entry":"\u2003\u2003AppPhongSpecularComponent(miState *state, ParameterType *paras)"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ pre-compute stuff that doesn't change inside light loop"},{"entry":"\u2003\u2003materialSpecularColor = *mi_eval_color(&paras->specularColor);"},{"entry":"\u2003\u2003specularExponent = *mi_eval_scalar(&paras->cosPower);"},{"entry":"\u2003\u2003reflectionSpecularity = *mi_eval_scalar(&paras->reflectionSpec);"},{"entry":"}"},{"entry":"template<typename ParameterType, typename ShaderHelper>"},{"entry":"\u2003\u2003miColor AppPhongSpecularComponent<ParameterType,"},{"entry":"\u2003\u2003ShaderHelper>::operator( )(miState *state,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ParameterType *paras,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ShaderHelper &helper,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003miVector &pLightDirection,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003miVector &pReflectionDirection,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003miScalar pDotNL,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003miVector &pBumpNormal)"},{"entry":"{"},{"entry":"\u2003\u2003miColor resSpecular = APP_BLACK;"},{"entry":"\u2003\u2003if (pDotNL >0.0f) {"},{"entry":"\u2003\u2003\u2003\u2003miScalar phongSpecular = compute_phong_specular("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&pLightDirection,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003specularExponent,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003reflectionSpecularity,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&pReflectionDirection,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003state);"},{"entry":"\u2003\u2003\u2003\u2003if (phongSpecular > 0.0f) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003resSpecular = phongSpecular * materialSpecularColor;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return resSpecular;"},{"entry":"}"},{"entry":"\/\/ Use the SpecularShaderHelper to correctly compute reflections and"},{"entry":"\/\/ attenuation for specular materials"},{"entry":"typedef SpecularShaderHelper<AppPhongParameters>"},{"entry":"\u2003\u2003SpecularShaderHelperType;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Only specular effects were changed in the Phong shader code fragments in Table 1, however additional effects or parts are typically associated with Phong shading. In Table 2, below, default implementations for other, non-specular parts are incorporated in a customized Phong shader using default behaviors. In the last line of Table 2, an \u201cApplication Phong Class,\u201d or \u201cAppPhongClass\u201d is instantiated, causing a compiler to generate executable code according to the code fragments in Table 1 and link the executable code with other application objects to generate a shader application that incorporates any custom user functionality added to the code fragments of Table 1.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Definition AppPhongClass as a specialization of the Surface template."},{"entry":"\/\/ Except for the above specular component we use the default"},{"entry":"\/\/ implementations of all other components."},{"entry":"typedef Surface"},{"entry":"<"},{"entry":"\u2003\u2003AppPhongParameters,"},{"entry":"\u2003\u2003SurfaceShaderReturnType,"},{"entry":"\u2003\u2003SpecularShaderHelperType,"},{"entry":"\u2003\u2003DefaultAmbientMaterialColorComponent"},{"entry":"\u2003\u2003\u2003\u2003<AppPhongParameters, SpecularShaderHelperType>,"},{"entry":"\u2003\u2003DefaultAmbientComponent<AppPhongParameters,"},{"entry":"\u2003\u2003\u2003\u2003SpecularShaderHelperType>,"},{"entry":"\u2003\u2003DefaultDiffuseMaterialColorComponent"},{"entry":"\u2003\u2003\u2003\u2003<AppPhongParameters, SpecularShaderHelperType>,"},{"entry":"\u2003\u2003DefaultDiffuseComponent<AppPhongParameters,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SpecularShaderHelperType>,"},{"entry":"\u2003\u2003AppPhongSpecularComponent<AppPhongParameters,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SpecularShaderHelperType>,"},{"entry":"\u2003\u2003DefaultSpecularReflectionComponent<AppPhongParameters,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SpecularShaderHelperType>"},{"entry":"> AppPhongClass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Other technically feasible techniques may also be used to implement the modular shader architecture without departing from the scope of the invention; for example, the invention could also be implemented using a polymorphic object oriented approach.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 5","FIG. 4"],"b":["510","512","414","520"]},"For example, render pass type - is associated with frame buffer -, render pass type - is associated with frame buffer -, and render pass type - may be associated with frame buffers - and -. In one embodiment, a user specifies the render pass to frame buffer association map  as part of a modeling and data entry process that may be facilitated using an associated GUI.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 6","FIG. 5"],"b":["605","605","610","512","512","510"]},"The frame buffer association map  includes one bit entries , , and  used to indicate whether a given scene object should be associated with a respective frame buffer , and therefore the render pass types associated with the frame buffer. For example, entry - specifies whether scene object - should contribute to frame buffer -, which is generated from render pass type -. Furthermore, a horizontal set of bit entries -, -, and -, for a given value of n, specifies contributions of scene object -to the respective frame buffers. In one embodiment, this horizontal set of bit entries is encoded as a hexadecimal string, providing a compact means of completely specifying scene object  to frame buffer  associations.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 7","FIGS. 1"],"b":["700","3","4","5","6"]},"The method begins in step , where the rendering application  receives a render database and launches a rendering process. The render database includes detailed specifications of scene objects, light sources, and cameras within a graphic scene.","In step , the rendering application determines a fragment to render, based on a camera position, as specification within the render database. In step , the rendering application determines which scene object is associated with the fragment being rendered. In one embodiment, the rendering application projects an eye ray from the camera, through a viewport, into the graphics scene to find an intersected object within the graphics scene.","In step , the rendering application determines which scene objects contribute to the current render pass by examining an associated scene object to frame buffer association map and a render pass to frame buffer association map. In one embodiment, both the scene object to frame buffer association map and the render pass to frame buffer association map are stored within one or more pass contribution maps.","In step , for each required render pass type, the rendering application calls an associated shader module to compute a respective render pass contribution. In step , the computed render pass contribution is saved into an associated frame buffer, as indicated by the scene object to frame buffer association map. If, in step , each pixel within the viewport is not yet rendered and the rendering process is not done, the method proceeds to step .","Returning to step , if each pixel within the viewport is rendered and the rendering process is done, then the method terminates in step .","The method steps  may be repeated for each unique camera specified within the render database.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 8","FIGS. 1"],"b":["800","3","4","5","6"]},"The method begins in step , where a user (a developer) derives a mathematical model for a new material for use in a graphics rendering application. A new material may be characterized as having certain properties with respect to absorbing, emitting, reflecting, diverting, or otherwise modifying or generating light in a graphics scene. The mathematical model for the new material may include aspect of existing or default material models, as well as aspects that are new. In step , the developer factors the mathematical model into a plurality of parts, functionally corresponding to slots in a shader template, such as shader template  of . Each slot of the shader template requires an associated shader module.","If, in step , desired shader modules are available in a default library, such as the default component library , then the method proceeds to step , where the user invokes a source code editor to identify default shader modules from the default library for inclusion in corresponding template slots within the shader template. The user may identify one or more default shader modules as desired shader modules based on whether a given default shader module satisfies a corresponding desired behavior of the mathematical model. The method then proceeds to step .","Returning to step , if no desired shader modules are available, then the method proceeds to step . If, in step , one or more desired shader modules from a set of previously generated shader modules is available, then the method proceeds to step , where the user invokes the source code editor to select previously generated customized shader modules for corresponding template slots within the shader template. The user may identify one or more previously generated customized shader modules as desired shader modules based on whether a given previously generated customized shader module satisfies a corresponding desired behavior of the mathematical model and whether a corresponding slot was previously satisfied by a default shader module. The method then proceeds to step .","Returning to step , if no desired shader module from the set of previously generated shader modules is available, then the method proceeds to step . In step , the user invokes the source code editor to generate desired customized shader modules for corresponding shader template slots. The user may generate a desired customized shader module for each slot remaining unsatisfied by either a default shader module or a previously generated customized shader module. The user may generate a customized shader module using source code from a corresponding default shader module as an example or starting point. As illustrated in , each custom shader module may replace a corresponding default shader module.","In step , the user invokes a compiler to compile the shader template into a shader object, which is linked to a shader application object to generate a customized shading program, such as customized shading program -. The compiler may optionally save each object. In one embodiment, the compiler is a C++ compiler.","In step , a host system avails the customized shading program, such as customized shading program -, to a rendering application, such as rendering application  of . The method terminates in step , where the user invokes the rendering application to render a graphics scene object using the customized shading program. The user may follow method steps  more than once to render each of one or more graphics objects within a graphics scene.","In sum, a technique is disclosed for the rapid development of custom shaders within a customized shading program using a modular shader architecture. The modular shader architecture includes a default component library comprising default shader modules and a facility to incorporate custom user shader modules into a shader template that is used for rendering a graphics image. During a rendering phase, the rendering application computes each sample needed to generate a graphics image. The rendering application invokes shading operations from the customized shading program. The customized shading program is generated from a shader template. The rendering application may save shader results to one or more corresponding frame buffers.","While the forgoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example, aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored. Such computer-readable storage media, when carrying computer-readable instructions that direct the functions of the present invention, are embodiments of the present invention.","In view of the foregoing, the scope of the present invention is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
