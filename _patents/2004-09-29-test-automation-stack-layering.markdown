---
title: Test automation stack layering
abstract: Separation of aspects of automated testing into architectural layers enables automated testing to occur sooner and faster and to provide more comprehensive testing. A physical layer provides an object model over the user interface of an application. A logical layer provides an object model around the functions of an application. A test case executor may execute a test case. A data manager may ensure variability in test data. A behavior manager may determine execution details appropriate for a particular test case. A verification manager may perform the verification processing after the test case has executed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07398514&OS=07398514&RS=07398514
owner: Microsoft Corporation
number: 07398514
owner_city: Redmond
owner_country: US
publication_date: 20040929
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["This application is related to U.S. patent application Ser. No. 10\/953,238, entitled \u201cSystem for Selecting Test Case Execution Behaviors for Reproducible Test Automation,\u201d filed herewith on Sep. 29, 2004 and U.S. patent application Ser. No. 10\/953,437, entitled \u201cAutomated Test Case Verification That Is Loosely Coupled With Respect To Automated Test Case Execution,\u201d filed herewith on Sep. 29, 2004.","The invention relates to software testing and in particular to automated software testing using a layered architecture.","The major stages in the life cycle of software development are the design phase, the coding phase, the code complete phase, the alpha phase, the beta phase, and finally, release to market. During the design phase, the customer problems the software product will address and the functionality of the software product is defined. Typically, the completion of the functional specification marks the end of the design phase. The coding phase may already have begun. The code complete phase is reached when the code has been written but is not necessarily debugged. The alpha phase marks the point in time when the product is stable; that is, most of the major bugs have been found. In the beta phase, the product is ideally free of all major bugs; the only bugs remaining should be essentially harmless. When the product passes a final quality assurance checklist, it is ready for release to market.","As no one wants software that does not work, testing is an important part of the life cycle and can span several phases. Software testing involves devising a test case (or, more likely, a set of test cases), running the software with the test case as input, and checking that the performance of the software with the test case as input yields the expected results. Software testing can be conducted manually by humans or programmatically, referred to as automated software testing. Ideally, testing of the software should begin as soon as possible in the life cycle of the software. Generally, however, the software cannot be tested at all until the design phase has been completed, because until the design phase is complete, expected results cannot be determined. Typically, during the coding phase, the developer manually tests his code as he writes it. Automated software testing usually cannot begin until far later in the development process.","Sometimes, the only testing that is conducted is done by the developer who manually tests as he codes. A developer who tests his own work, however, is likely to overlook bugs that someone not so emotionally invested in the code will find. Furthermore, the scope of the developer's testing is typically limited to the functionality of his code and integration of his code with a limited number of other software applications.","To address these shortcomings, many software development houses have a separate software testing group that also tests the software, often using at least partially-automated testing techniques. Typically, the testing group tests complex interactions across features and across applications by writing and running test cases. It is generally agreed that involving the testing group early in the product life cycle, even as early as the design phase, reaps many benefits, including identification of inconsistencies in the functional specification, identification of hard-to-test areas and others. In general, however, the effort required to keep each test case current in the face of continued changes in feature definition, implementation and user interface (UI) tuning renders this approach impractical. Hence, writing and running test cases is typically a hurried matter that occurs at the tail end of product development. Testing and in particular, automated testing, thus tends to be perpetually behind the curve. It would be helpful if there were a way to write test cases and employ automated testing as soon as possible in the life cycle of a software product, ideally during the design phase.","Development of a suite of test cases is a challenge whenever it occurs. To test a specific feature of an application, numerous sets of tests must be written. For example, an application may permit many modes of interaction with a feature: via a mouse, keyboard, digitizer, accessibility software, programmatically, and so on. Therefore, to provide a comprehensive test for the feature, a suite of tests should include a set of tests interacting with the feature via the mouse (typing text just like a user might); one set interacting with the feature via keyboard, one set interacting with the feature via digitizer, one set interacting with the feature via accessibility software to invoke default actions and otherwise mimic an accessibility application, one set interacting with the feature via the application's coding model, and so on. It would be helpful if there were a way to make sure that the suite of test cases produced provided a comprehensive test of the feature or application and further, to decrease the total number of test cases that must be written to provide that comprehensive test.","Furthermore, much or all of the logic in each of these sets of test is identical to the logic in the other sets of tests and typically, much or all of the verification of results processing is identical as well. Hence, many tests are identical or very nearly so, merely varying execution options. For example, for all the multiple forms of input described above, the expected results are likely identical. Hence, writing a test case for each of these input sources typically requires writing a separate method for executing the test for each of the input sources, and duplicating most of the rest of the test script. Writing the same test over and over again with minor variations is tedious and time-consuming. It would be helpful if there were a way to eliminate or significantly reduce this duplicative coding and to reduce the total number of test cases that must be written.","Code written to determine if the actual results of running the test case coincide with the expected results (called verification of results, or verification) is often included within the test case. Changing the details of a particular result verification or adding new result verification typically requires the modification of each test case. It would be helpful if verification code were separate from the test case, making the test case easier to understand, and the verification code easier to reuse and to maintain.","Execution details are often hard-coded into the test case, requiring the design phase to be complete before the test case is written. It would be helpful if there were a way to define test cases in terms of user actions rather than in terms of specific execution details so that test cases could be written earlier in the software development life cycle.","Changes made to execution details and verification after the test cases are written typically requires a massive maintenance effort in which many test cases must be found and modified. It would be helpful if maintenance efforts could be localized so that modifications could be made in one place instead of in each test case.","An automated test system utilizing an automation stack may enable test cases to be written and compiled as early as the design phase of software development. The test cases may be executed as soon as the code implementing the feature to be tested is written.","An automated test system may include one or more of: a test case executor, a data manager, a behavior manager and a databank of behaviors, a verification manager, and an automation stack. A test case executor may execute a test case. A data manager may ensure variability in testing data. A behavior manager may determine execution details appropriate for a particular test case. A verification manager may perform the verification processing after the test case has executed. An automation stack may provide an architecture that enables the separation of details of test case execution into layers or sets of objects. An automation stack may include a logical layer and a physical layer, while a test case layer may be built on top of the logical layer. A test case may be defined in terms of features or user actions rather than in terms of specific execution details\/user interface details thus enabling test cases to be written earlier in the software development life cycle and enabling changes to execution details and user interface details to be decoupled and isolated from test case details.","Test case execution and test case verification may be decoupled via separation into execution behavior and verification layers. Verification of results processing may be separate from the test case, thereby enabling the test case to be more understandable and to facilitate re-use of the verification code. Maintenance may be simplified by localization to a single point of change within the automation stack or within the verification or behavior layers, thus enabling the test case to be essentially maintenance-free.","Separating each of the details of how the various steps in a test case is executed into its own layer or set of objects allows each of these factors to vary independently. Each layer may introduce variability over the layer or layers below it, thus reducing the number of tests that must be written. For example, one test written to a higher layer that is run five times may have the same efficacy as five, ten or even fifty tests written to a lower layer. The organization into layers enables the tests themselves to be simpler and easier to understand, and may reduce the amount of time it takes to write a test case in addition to reducing the number of test cases that must be written to cover a set of execution paths.","A logical layer may provide a view of the application based on the actions that can be taken (for example, the action of \u201copen a document\u201d) rather than the specific details of the user interface (for example, specific details such as \u201copen the File menu and click Open, wait for the File Open dialog box to open, enter the name of the file to open, press OK, wait for the File Open dialog box to disappear, wait for the application to open the document and be ready for further input\u201d). The logical layer may also abstract away as much knowledge as practical of the user interface, so that tests written to this layer do not need to be edited when the user interface changes. The logical layer may also introduce variability over the various physical methods of execution, so that a single test case written to this layer can be executed via the mouse or the keyboard, etc. without any changes to the test case.","A physical layer insulates tests from the highly specific details of communicating with a particular control, including details such as the identification code of a particular control, and the way the control is accessed (via mouse, keyboard, accessibility, tablet, etc). The physical layer may provide an object model around the application's user interface so that the test has strongly typed access to the user interface. The physical layer may also enable the execution method to be defined independently of the control so that just a single object model is required regardless of the number of execution methods.","A verification layer may be independent of and isolated from direct contact to the test cases, so that changes to verification details do not require any changes to the tests.","An execution behavior layer may be independent of and isolated from direct contact to the test cases so that changes to which execution behaviors are available or changes to the implementation of any specific behavior can be made with minimal or no changes to the test cases.","A data management layer may be used by test cases when the test cases require test data. The data management layer may provide a centralized store of all test data and allow changes to be made to the test data or the manner in which the test data is generated requiring minimal or no changes to the test cases.","Each layer may provide (direct) access to the layer below it but a test case can make calls to any layer as necessary. A test case that explicitly verifies menu behavior, for example, may use the logical layer to create a drawing that contains various shapes, and then use the physical layer to directly manipulate the menus. The test case may go below to the physical layer to the operating system services for verification of results. Thus a test case may utilize the full power of the higher layers while also utilizing the full control provided by the lower layers.","Overview","One challenge in the development of test cases is to prepare a set of test cases that provides a comprehensive test. A large percentage of test cases exercises a small percentage of the user actions under test. To understand why this may happen, consider that an individual operation can usually be executed via several different user actions. For example, creating a new document in Microsoft Word can be done by:","Clicking the File menu, clicking the New submenu, then clicking the New Document menu item.","Typing Alt+F to invoke the File menu, typing N to invoke the New submenu, then typing N to invoke the New Document menu item.","Typing Alt to invoke the main menu repeatedly pressing the left arrow key until the File menu is selected, repeatedly pressing the down arrow key until the New submenu item is selected, pressing the left arrow key a single time to expand the New submenu, repeatedly pressing the down arrow key until the New Document menu item is selected, then pressing Enter to invoke the New Document menu item.\n\n","Each of these different ways to open a document, each one potentially invoking a different code path, should be tested. In accordance with some embodiments of the invention, all possible execution paths and data values are exercised.","Because multiple paths of execution are commonplace, verification processing is often duplicated in many of the test cases in a set. Often, the verification code will be copy-and-pasted into each test case. In addition to being tedious and time-consuming, a maintenance problem is thereby created. For example, if a change is subsequently made in the execution or verification processing, the entire set of affected test cases must be found and revised. In accordance with some embodiments of the invention, maintenance of a test case is localized to a single place in an automation stack, enabling test cases to be nearly maintenance-free.","In a typical test case, code directed to execution of the test case and code directed to determining the results of the execution (verification code) is hard-coded into the test case itself. Often the execution code is mixed in with the verification code. In accordance with some embodiments of the invention, verification processing and details of execution processing are separated from each other and from the test case.","Often test cases do not distinguish between the operations a test is testing and the steps it takes to invoke those actions. An explicit test is often written for each method of execution. For example, each test may include code for each series of mouse moves, button clicks and keystrokes that must be replicated to invoke the operation being tested. With respect to UI testing, each test may have to keep track of the type of control used by each UI component, identify the specific control used and specify where in the UI hierarchy the control can be found. In accordance with some embodiments of the invention, a test case is written in terms of user actions instead of in terms of execution details. User interface details are thus partitioned from user action details.","Automated test cases are typically very tightly bound to the particular piece of software being tested, that is, a typical test case is coded directly against the object it is testing. For example, automated testing of an application via test cases often directly manipulates the state of the application. Test cases for the automated testing of a user interface (UI) often are written directly to one or more controls of the UI, and identify the control(s) by explicit coding of the name or unique identifier of the control(s) in the test cases. If the control changes (e.g., from a button to a list box, or even from one button (e.g., button ) to another button (e.g., button )), all of the test cases for the UI must be changed.","To address these and other problems, a multi-layered library may be created which is usable from scripted test cases, model-based tests and unit tests. The library may comprise one or more of a physical layer, a logical layer, a verification layer, an execution behavior management layer and a data management layer. The physical layer, logical layer and test cases may comprise an automation stack while the verification, execution behavior and data management layers may be separate but at the same level as the logical layer.","A logical layer may provide a view of the application based on the actions that can be taken (e.g., the action \u201copen a document\u201d) rather than the specific details of the user interface (e.g., \u201copen the File menu and click Open, wait for the File Open dialog box to open, enter the name of the file to open, press OK, wait for the File Open dialog box to disappear, wait for the application to open the document and be ready for further input\u201d). The logical layer also abstracts away as much knowledge as practical of the UI, so that tests written to the logical layer do not need to be edited if the UI changes. The logical layer also may introduce variability over the various physical methods of execution, so that a single test written to the logical layer can be executed via the mouse, keyboard, etc. without requiring any changes to be made to the test case.","A physical layer may insulate test cases from the highly specific details of communicating with a particular control, including such details as what a particular control's identification code is, and how that control is accessed (via mouse, keyboard, etc.). The physical layer may provide an object model around the application's UI so that the test has strongly typed access to that UI. The physical layer may also enable the execution method to be defined independently of the control so that just a single object model is required regardless of the number of execution methods.","A verification layer may be independent of and isolated from direct contact to the test case, so that changes to verification processing do not require any changes to be made to the test cases. The verification layer may compare an actual state with an expected state to determine if the test case results were as expected.","An execution behavior management layer may be independent of and isolated from direct contact to the test cases so that changes to availability of execution behaviors or changes to the implementation of any specific behavior can be made with minimal or no changes to the test cases. An execution behavior layer may select one or more appropriate behaviors applicable to the test case. The execution behavior layer may ensure that all possible execution paths are exercised","A data management layer may be used by test cases when the test cases require test data. The data management system may provide a centralized store of all test data and allow changes to be made to the test data or the manner in which that data is generated requiring minimal or no changes to the test cases. The data management layer may ensure that all possible data values are exercised.","Each layer may provide (direct) access to the layer below it but a test case can make calls to any layer as necessary. A test case that explicitly verifies menu behavior, for example, may use the logical layer to create a drawing that contains various shapes, and use the physical layer to directly manipulate the menus, and go to the operating system services for result verification. Execution method details may be hidden. A test written to the logical layer may require no changes when switching between execution methods. If test cases are completely isolated from the execution method, a mechanism external to and separate from the test case may be used at compile time or at runtime to specify which execution method should be used for a specific run of the tests.","Exemplary Computing Environment",{"@attributes":{"id":"p-0044","num":"0048"},"figref":"FIG. 1"},"Although not required, the invention can be implemented via an application programming interface (API), for use by a developer, and\/or included within the network browsing software which will be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers, or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0046","num":"0050"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB).","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . A graphics interface , such as Northbridge, may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU, or host processing unit , and assumes responsibility for accelerated graphics port (AGP) communications. One or more graphics processing units (GPUs)  may communicate with graphics interface . In this regard, GPUs  generally include on-chip memory storage, such as register storage and GPUs  communicate with a video memory . GPUs , however, are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","One of ordinary skill in the art can appreciate that a computer  or other client device can be deployed as part of a computer network. In this regard, the present invention pertains to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. The present invention may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.","Automation Stack Layering","In some embodiments of the invention, an application is defined via a logical functional model that takes a user-centric view of the application, in contrast to an object model view or other type of view. Code that is used over and over again may be componentized in a user-centric fashion. For example, actions may be grouped by target: in the logical layer, SceneElements may contain methods that affect the set of elements on the active scene such as Create, Select, Deselect, Cut, Copy, Paste, Delete elements. The Transforms group of methods may have methods to rotate, scale and otherwise apply transforms to scene elements. Path may contain methods to manipulate scene elements that are paths, and so on. In most applications, most of the user actions may be executed in multiple different ways. The infrastructure required for the different execution paths are typically identical. Hence, in some embodiments of the invention, an execution behavior manager is shared across test cases and selects an appropriate behavior (a logical functional model method) for the test case. In some embodiments of the invention, before a test case or logical functional model method executes an operation, a verification manager is notified. The verification manager may save a copy of the complete current state of the application. This copy forms the basis of the expected state when the operation is complete. In some embodiments of the invention, the test case executes a sequence of actions with no knowledge of how the actions are executed or verified.",{"@attributes":{"id":"p-0057","num":"0061"},"figref":["FIG. 2","FIG. 2"]},"The automated test system  may reside on one or more computers, such as exemplary computer  described with respect to . Automated test system  may include one or more of: a test executor , a data manager , a behavior manager  and associated databank of behaviors (not shown), a verification manager , and an automation stack . A test executor  may execute a test case  against an application . A data manager  in some embodiments of the invention, may provide test data required by the test case . The data manager may provide access to a centralized store of all test data and allow changes to be made to the test data or the manner in which the test data is generated requiring minimal or no changes to the test cases.","A behavior manager  may select an appropriate behavior for a test case  from a databank of behaviors. A verification manager  may provide verification of results of executing the test case .",{"@attributes":{"id":"p-0060","num":"0064"},"figref":["FIG. 3","FIG. 3","FIG. 2","FIG. 3"],"b":["200","200","200","202","204","206","208","210","213","210","212","214","204"]},"The automation library  may include one or more of the physical layer , the logical layer , and one or more test cases in test case layer , while the execution behavior layer , the comprehensive verification layer  and the data manager layer  may exist external to the automation architectural stack . In some embodiments of the invention the execution behavior layer , the comprehensive verification layer  and the data manager layer  although separate from the logical layer , are integrated into the logical layer . Because the execution behavior layer , the comprehensive verification layer  and the data manager level  are separate from the logical layer , the execution behavior layer , the comprehensive verification layer  and the data manager level  can be accessed from outside the architectural stack.","Automation library  may represent a layer over a system library comprising one or more components including, for example, one or more of: an operating system, external tools, a graphics animation subsystem, etc. In , an exemplary system library  includes an internal test automation module , an accessibility module , a UI automation module , a graphics animation subsystem  (comprising a graphics animation object model  and a graphics animation application ), and system level applications.","The automation library  may include the layout and controls of a graphics animation subsystem . The layout portion of automation library  may include classes for each instance of visual element of the graphics animation subsystem . That is, the layout portion may include all the classes which represent the \u201ctop-level\u201d visual elements of the graphics subsystem , such as but not limited to: a new project dialog, one or more toolbox panes and a main menu. The controls portion may include classes for each type of visual element. That is, the controls portion may include classes for all system and custom controls used with the graphics animation subsystem, such as, but not limited to: a button class, a combo box class, a text box class and a color picker class. These controls may be accessible only through top-level elements (e.g., through the main menu, a toolbox pane or the new project dialog). Each control in the controls portion of the automation library  may include all the methods and properties required to access and manipulate the control, including implementations for all input methods (e.g., via keyboard, mouse, accessibility, etc.).","The automation library  may be used to conduct any type of tests including model-based, integration, performance, load, stress, acceptance, unit, build verification, basic functionality, exit criteria, comprehensive\/extended functionality, localization, globalization, accessibility and other tests. The automation library  may be accessed by or include test cases which are scripted. Alternatively, test cases accessing or included in automation library  may be represented in XML, in a compiled language, in byte code, in a database, in text, in a table, or so on.","Each layer of the automation library  has direct access to (can make calls to) the layer below. That is, the test case layer  has direct access to the logical layer . The logical layer  has direct access to the physical layer  and so on. In some embodiments of the invention, means are provided for a layer to access or make calls to a deeper layer, that is, for example, it may be possible for a test case to directly access the internal test automation layer , the physical layer  and so on, in the event that it desirable to do so.","Test cases layer  may include one or more test cases to be applied to an application or module, feature or function to be tested. A test case may be scripted. An exemplary test case written to the logical layer  may be, for example:","Start Graphics Animation Subsystem","Add a new Project","Draw a rectangle from 0,0 to 4,4","Set the color of the rectangle to red","Save the project","Shut down the Graphics Animation Subsystem","It will be appreciated that missing from the above exemplary test case is code directed to verification of results, code directed to execution options, code directed to identifying particular UI elements such as controls and so on. A test case of test case layer  written to the logical layer  should thus rarely need to change because of changes in the automation library  due to the encapsulation of the logical operations of the application.","In some embodiments of the invention, the logical layer  is directed to the functions the application is supposed to perform rather than on how the operations of each function are implemented. The logical layer  may encapsulate or wrap the logical operations of the graphics animation subsystem , abstracting the implementation specifics of the logical operations. In some embodiments of the invention, the logical layer  abstracts away all knowledge of the UI and provides the interface between the test case of the test case layer  and the verification layer , the behavior layer  and the data manager layer . The logical layer  may also provide an interface between the graphics animation object model  (the internal state of the graphics animation application ) and the test case. The logical layer may provide variability over the sequence of actions used to execute a single user action.","The physical layer  abstracts the execution methods so that test cases written to the physical layer do not have to address execution details such as whether a control is invoked by using a mouse, or keyboard, accessibility software, etc. The physical layer may provide variability over the method used to interact with a particular control. The physical layer  also may provide an object model around the UI, that is, the physical layer  may provide an interface to the UI. Hence, when elements in the application or UI change, changes can be made in the physical layer rather than in all the test cases.","Another exemplary test case written to the physical layer may be, for example:","Start Graphics Animation Subsystem","Invoke the File menu","Invoke the New submenu","Invoke the New Project menu item","Type the name to give the new project","Close the New Project dialog box","Wait for the Graphics Animation Subsystem to finish creating the new project","Activate the rectangle shape tool","Drag the mouse from 0,0 to 4,4","Select \u201cRed\u201d from the list of possible stroke colors in the color-properties pane","Invoke the File menu","Invoke the Save menu item","Wait for the Graphics Animation Subsystem to finish saving the project","Invoke the File menu","Invoke the Exit menu item","Wait for the Graphics Animation Subsystem to shut down","It will be appreciated that the above exemplary test case does not specify how the actions (e.g., \u201cInvoke the File menu\u201d) are carried out (i.e., does not specify the execution path). Because the execution manager selects from a universe of possible execution paths, running the test case a number of times will execute all the available execution paths multiple times. Because all verification code resides outside of the test case, verification processing can be made more complete without needing to change the test case. Similarly, the test case will not need to change if the expected results of any of the actions it includes changes. It will be appreciated that the test case contains no references to any UI. Hence, the test case will not need to change if the UI changes. It will be appreciated that the test case is focused on actions a user might take.","Corresponding code in the physical layer to which the test code is written may be as follows:",{"@attributes":{"id":"p-0095","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003class UIPane"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003UIButton Minimize {"},{"entry":"\u2003\u2003\u2003\u2003return new UIButton(\u201cidOfTheMinimizeButton\u201d); }"},{"entry":"\u2003\u2003\u2003\u2003UIButton Restore {"},{"entry":"\u2003\u2003\u2003\u2003return new UIButton(\u201cidOfTheRestoreButton\u201d); }"},{"entry":"\u2003\u2003\u2003\u2003UIButton Close {"},{"entry":"\u2003\u2003\u2003\u2003return new UIButton(\u201cidOfTheCloseButton\u201d); }"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003class UIColorPane derives from class UIPane"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003UIComboBox AvailableColorsForFill { return new"},{"entry":"UIComboBox(\u201cidOfTheAvailableFillColorsComboBox\u201d); }"},{"entry":"\u2003\u2003\u2003\u2003UIColorPicker CustomColorsForFill { return new"},{"entry":"UIColorPicker(\u201cidOfTheCustomFillColorColorPicker\u201d); }"},{"entry":"\u2003\u2003\u2003\u2003UIComboBox AvailableColorsForStroke { return new"},{"entry":"UIComboBox(\u201cidOfTheAvailableStrokeColorsComboBox\u201d); }"},{"entry":"\u2003\u2003\u2003\u2003UIColorPicker CustomColorsForStroke { return new"},{"entry":"UIColorPicker(\u201cidOfTheCustomStrokeColorColorPicker\u201d); }"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003class UIButton"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Area boundingBox;"},{"entry":"\u2003\u2003\u2003\u2003UIButton(identifier)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003GraphicsSubsystem.Control control ="},{"entry":"GraphicsSubsystem.FindControl(identifier);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003boundingBox = control.BoundingBox;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003Invoke( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003ScreenCoordinate clickPoint;"},{"entry":"\u2003\u2003\u2003\u2003clickPoint.x = boundingBox.Left + (boundingBox.Width \/ 2);"},{"entry":"\u2003\u2003\u2003\u2003clickPoint.y = boundingBox.Top + (boundingBox.Height \/2);"},{"entry":"\u2003\u2003\u2003\u2003Mouse.Move(clickPoint);"},{"entry":"\u2003\u2003\u2003\u2003Mouse.Click( );"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Because the logical layer  is concerned only with functionality and not with implementation details, and because most test cases are written to the logical layer , test cases may be written far earlier in the software life cycle. As soon as the code is complete, the test cases may be run, thus more testing can be done sooner and faster.","A comprehensive verification layer  in some embodiments of the invention encapsulates verification processing. The logical layer  in some embodiments of the invention notifies the verification layer  before the logical layer  executes the test case to enable the verification layer  to take a snapshot of the pre-test state. After the test case is executed, the logical layer  notifies the verification layer  that the test case has been executed. The verification layer  may then determine if the actual results coincide with the expected results. Further information concerning the verification layer may be found in the related application, U.S. patent application Ser. No. 10\/953,437, entitled \u201cAutomated Test Case Verification That Is Loosely Coupled With Respect To Automated Test Case Execution.\u201d","The logical layer  in some embodiments implements a specific behavior (of execution behaviors ) for each method of implementing a logical operation. For example, in some embodiments of the invention, for a CreateNewProject behavior, this will include implementing the application's object model, sending a sequence of keystrokes, invoking a menu item via an accessibility module, invoking the menu item using the mouse, invoking the menu item using the arrow keys to navigate around the menu and invoking the menu item using the mnemonic characters to navigate around the menus. The execution behavior layer may determine which behaviors are relevant to the logical operation.","In some embodiments of the invention, a separate behavior (stored in execution behaviors databank , in the logical layer  or elsewhere) may be implemented for each method implementing a logical operation. The use of behaviors makes it possible to write far fewer test cases while still providing the same degree of comprehensive testing. The execution behavior manager  of the execution behavior layer  in some embodiments of the invention determines which behaviors stored in execution behavior databank  are relevant to the logical operation under consideration. In some embodiments of the invention, weighting factors and other settings may be used to select a particular behavior. Further information concerning the behavior layer  may be found in related application U.S. patent application Ser. No. 10\/953,238, entitled \u201cSystem for Selecting Test Case Execution Behaviors for Reproducible Test Automation.\u201d","The logical layer  may then execute the operation using the selected behavior. The selection mechanism in some embodiments of the invention is configurable at run-time. This feature enables test behavior to be modified without modifying the test cases themselves. For example, if the menuing mechanism has recently been re-written, it may be desirable to perform actions using the menuing mechanism in order to give the new code a good test. Alternatively, if there is a known bug in the shortcut key processing, it may be desirable to refrain from using a method that uses shortcut keys until the bug is fixed. This change may be made via the behavior layer rather than in the test case itself.",{"@attributes":{"id":"p-0101","num":"0105"},"figref":"FIG. 4","b":["402","404","406","408","410","406","410","412"]},"The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the creation and\/or implementation of domain-specific programming models aspects of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of illustrative embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 4","FIG. 2"]}]},"DETDESC":[{},{}]}
