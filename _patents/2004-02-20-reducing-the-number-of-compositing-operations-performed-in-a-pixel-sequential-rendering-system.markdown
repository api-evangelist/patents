---
title: Reducing the number of compositing operations performed in a pixel sequential rendering system
abstract: Apparatus is disclosed for rendering an object-based image one pixel at a time in scanline order. The apparatus comprises an optimisation module for generating a set of compositing messages during a first pixel in a run of pixels between adjacent edges of one or two objects, and for generating a reduced set of compositing messages from the set during subsequent pixels in the run of pixels. The apparatus further comprises a pixel compositing module which in addition to compositing the first pixel in the run of pixels also stores a result or partial result of the compositing of the first pixel. The pixel compositing module utilises the reduced set of compositing messages and the stored result or partial result to composite pixels in the run subsequent to the first pixel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06961067&OS=06961067&RS=06961067
owner: Canon Kabushiki Kaisha
number: 06961067
owner_city: Tokyo
owner_country: JP
publication_date: 20040220
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION INCLUDING BEST MODE","1.0 OVERVIEW OF PIXEL SEQUENTIAL RENDERING SYSTEM","2.0 Overview of Software Driver","3.0 OVERVIEW OF PIXEL SEQUENTIAL RENDERING APPARATUS","3.1 OVERVIEW OF INSTRUCTION EXECUTOR","3.2 OVERVIEW OF EDGE TRACKING MODULE","3.3 OVERVIEW OF PRIORITY DETERMINATION MODULE","3.4 OVERVIEW OF OPTIMISATION MODULE","3.5 OVERVIEW OF FILL COLOR DETERMINATION MODULE","3.6 OVERVIEW OF PIXEL COMPOSITING MODULE","3.7 OVERVIEW OF PIXEL OUTPUT MODULE","4.0 OPTIMISATION MODULE","4.1 A FIRST ARRANGEMENT OF THE OPTIMISATION MODULE","4.2 A SECOND ARRANGEMENT OF THE OPTIMISATION MODULE","4.3 A THIRD ARRANGEMENT OF THE OPTIMISATION MODULE","4.4 A FOURTH ARRANGEMENT OF THE OPTIMISATION MODULE","4.5 A FIFTH ARRANGEMENT OF THE OPTIMISATION MODULE","5.0 COMPOSITING MODULE","INDUSTRIAL APPLICABILITY"],"p":["The present invention relates generally to rendering graphic object based images. In particular, the present invention relates to reducing the number of compositing operations performed in a pixel sequential rendering system.","When a computer application provides data to a device for printing and\/or display, an intermediate description of the page is often given to the device driver software in a page description language, such as PostScript or PCL, which provide descriptions of the objects to be rendered onto the page, rather than a raster image to be printed. Equivalently, a set of descriptions of graphics objects may be provided in function calls to a graphics interface, such as the Microsoft Windows GDI, or Unix's X-11. The page is typically rendered for printing and\/or display by an object-based graphics system (or Raster Image Processor).","Most of these object based graphics systems utilize a large area of memory, known to the art as a frame store or a page buffer, to hold a pixel-based image of the page or screen for subsequent printing and\/or display. Typically, the outlines of the graphic objects are calculated, filled and written into the frame store. For two-dimensional graphics, objects that appear in front of other objects are simply written into the frame store after the background objects, thereby replacing the background on a pixel by pixel basis. This is commonly known to the art as \u201cPainter's algorithm\u201d. Objects are considered in priority order, from the rearmost object to the foremost object, and typically, each object is rasterized in scanline order and pixels are written to the framestore in sequential runs along each scanline. Some graphics interfaces allow a logical or arithmetic operation to be specified, to be performed between one or more graphics objects and the already rendered pixels in the frame buffer. In these cases the principle remains the same: objects (or groups of objects) are rasterized in scanline order, and the result of the specified operation is calculated and written to the framestore in sequential runs along each scanline.","There are essentially two problems with this technique. The first is that it requires fast random access to all of the pixels in the framestore. This is because each new object could affect any pixel in the frame store. For this reason, the frame store is normally kept in semiconductor random access memory (RAM). For high-resolution color printers the amount of RAM required is very large, typically in excess of 100 Mbytes, which is costly and difficult to run at high speed. The second problem is that many pixels, which are painted (rendered), are over-painted (re-rendered) by later objects. Painting these pixels with the earlier objects is a waste of time.","One method for overcoming the large frame-store problem is the use of \u201cbanding\u201d. When banding is used, only part of the framestore exists in memory at any one time. All of the objects to be drawn are retained in a \u201cdisplay list\u201d, which is an internal representation of the information required to draw the objects on the page. The display list is considered in object order as above, and only those pixel operations which fall within the fraction of the page which is held in the band are actually performed. After all objects in the display list have been drawn, the band is sent to the printer (or to intermediate storage) and the process is repeated for the next band of the page. There are some penalties with this technique, however. For example, the objects being drawn must be reconsidered many times, once for each band. As the number of bands increases, so does the repetitious examination of the objects requiring rendering. Also, the technique of banding does not solve the problem of the cost of over-painting.","Some other graphic systems consider the image in scan line order. Again, all of the objects on the page are retained in a display list. On each scanline the objects which intersect that scanline are then considered in priority order and for each object, spans of pixels between the intersection points of the object edges with the scanline are filled in a line store. This technique overcomes the large framestore problem, however it still suffers from the over-painting problem.","Other graphic systems utilise pixel-sequential rendering to overcome both the large framestore problem and the over-painting problem. In these systems, each pixel is generated in raster order. Again, all objects to be drawn are retained in a display list. On each scan line, the edges of objects, which intersect that scanline, are held in increasing order of their intersection with the scan line. These points of intersection, or edge crossings, are considered in turn, and used to toggle an array of fields that indicate the activity of the objects in the display list. There is one activity field for each object painting operation that is of interest on the scan line. There is also a field to indicate operations that do not require previously generated data. Between each pair of edges considered, the color data for each pixel, which lies between the first edge and the second edge, is generated by using a priority encoder on the activity flags to determine which operations are required to generate the color, and performing only those operations for the span of pixels between the two edges. In preparation for the next scanline, the coordinate of intersection of each edge is updated in accordance with the nature of each edge, and the edges are sorted into increasing order of intersection with that scanline. Any new edges are also merged into the list of edges.","Graphic systems which use pixel-sequential rendering have significant advantages in that there is no frame store or line store, no unnecessary over-painting, and the object priorities are dealt with in constant order time by the priority encoder, rather than in order N time, where N is the number of priorities.","However, it is still often necessary to perform several compositing operations to combine color from several different objects into a rendered pixel, and this can form a significant bottleneck in the overall rendering process.","It is an object of the present invention to substantially overcome, or at least ameliorate, one or more disadvantages of existing arrangements.","According to one aspect of the invention, there is provided an apparatus for rendering an object-based image one pixel at a time in scanline order, the apparatus comprising: an optimisation module for minimising a number of compositing messages for compositing the object-based image, the optimisation module comprising: a first unit for setting, for a first pixel in a run of pixels between adjacent edges of one or two objects, first data in one or more compositing messages of a set of compositing messages to indicate a compositing result of these one or more compositing messages is to be stored for use in compositing of each pixel subsequent to the first pixel in the run of pixels; and a second unit for generating, for each pixel subsequent to the first pixel in the run of pixels, a reduced set of compositing messages from the set of compositing messages, the second unit comprising: a sub-unit for generating, for each pixel subsequent to the first pixel in the run of pixels, the reduced set of compositing messages; and a sub-unit for setting, for each pixel subsequent to the first pixel in the run of pixels, second data in one or more compositing messages of the reduced set to indicate the stored compositing result is to be retrieved for use in compositing of each pixel subsequent to the first pixel in the run of pixels; and a compositing module for generating a resultant color and opacity for a currently scanned pixel in accordance with the compositing messages, wherein the compositing module generates the color and opacity of the first pixel in the run of pixels in accordance with the set of compositing operations, and the compositing module generates the color and opacity of each pixel in the run subsequent to the first pixel in accordance with the reduced set and the retrieved result.","According to another aspect of the invention, there is provided a method for rendering an object-based image one pixel at a time in scanline order, the method comprising the steps of: an optimisation step for minimising a number of compositing messages for compositing the object-based image, the optimisation step comprising the sub-steps: a setting step for setting, for a first pixel in a run of pixels between adjacent edges of one or two objects, first data in one or more compositing messages of a set of compositing messages to indicate a compositing result of these one or more compositing messages is to be stored for use in compositing of each pixel subsequent to the first pixel in the run of pixels; and a generating step for generating, for each pixel subsequent to the first pixel in the run of pixels, a reduced set of compositing messages from the set of compositing messages, the generating step comprising: a generating sub-step for generating, for each pixel subsequent to the first pixel in the run of pixels, the reduced set of compositing messages; and a setting sub-step for setting, for each pixel subsequent to the first pixel in the run of pixels, second data in one or more compositing messages of the reduced set to indicate the stored compositing result is to be retrieved for use in compositing of each pixel subsequent to the first pixel in the run of pixels; and a compositing step for generating a resultant color and opacity for a currently scanned pixel in accordance with the compositing messages, wherein the compositing module generates the color and opacity of the first pixel in the run of pixels in accordance with the set of compositing operations, and the compositing module generates the color and opacity of each pixel in the run subsequent to the first pixel in accordance with the reduced set and the retrieved result.","Other aspects of the invention are also disclosed.","Where reference is made in any one or more of the accompanying drawings to steps and\/or features, which have the same reference numerals, those steps and\/or features have for the purposes of this description the same function(s) or operation(s), unless the contrary intention appears.","For a better understanding of the pixel sequential rendering system , a brief overview of the system is first undertaken in Section 1.0. Then follows a brief discussion in Section 2.0 of the driver software for interfacing between a third party software application and the pixel sequential rendering apparatus  of the system. A brief overview of the pixel sequential rendering apparatus  is then discussed in Section 3.0. As will become apparent, the pixel sequential rendering apparatus  comprises an instruction execution module ; an edge tracking module ; a priority determination module ; an optimisation module , a fill color determination module ; a pixel compositing module ; and a pixel output module . A brief overview of these modules is described in Sections 3.1 to 3.7. A more detailed description of the optimisation module  and pixel compositing module  then follows in sections 4.0 to 4.5, and 5.0.","The general principles of the invention have application in reducing the number of compositing operations being performed in a pixel sequential rendering system. This is realised in the preferred system in the optimisation module  and pixel compositing module , which are described in more detail in Sections 4.0, 4.1, 4.2, 4.3, 4.4, 4.5 and 5.0.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 1","b":["1","2","3","5","4","1","6","7","8","1","10"]},"The above-described components of the system  are interconnected via a bus system  and are operable in a normal operating mode of computer systems well known in the art, such as IBM PC\/AT type personal computers and arrangements evolved therefrom, Sun Sparcstations and the like.","Also seen in , a pixel sequential rendering apparatus  connects to the bus , and in the preferred arrangement is configured for the sequential rendering of pixel-based images derived from graphic object-based descriptions supplied with instructions and data from the system  via the bus . The apparatus  may utilise the system RAM  for the rendering of object descriptions although preferably the rendering apparatus  may have associated therewith a dedicated rendering store arrangement , typically formed of semiconductor RAM.","The pixel sequential renderer operates generally speaking in the following manner. A render job to be rendered is given to the driver software by third party software for supply to the pixel sequential renderer. The render job is typically in a page description language or in a sequence of function calls to a standard graphics API, which defines an image comprising objects placed on a page from a rearmost object to a foremost object to be composited in a manner defined by the render job. The driver software converts the render job to an intermediate render job, which is then fed to the pixel sequential renderer. The pixel sequential renderer generates the color and opacity for the pixels one at a time in raster scan order. At any pixel currently being scanned and processed, the pixel sequential renderer composites only those exposed objects that are active at the currently scanned pixel. The pixel sequential render determines that an object is active at a currently scanned pixel if that pixel lies within the boundary of the object. The pixel sequential renderer achieves this by reference to a fill counter associated with that object. The fill counter keeps a running fill count that indicates whether the pixel lies within the boundary of the object. When the pixel sequential renderer encounters an edge associated with the object it increments or decrements the fill count depending upon the direction of the edge. The renderer is then able to determine whether the current pixel is within the boundary of the object depending upon the fill count and a predetermined winding count rule. The pixel sequential renderer determines whether an active object is exposed with reference to a flag associated with that object. This flag associated with an object indicates whether or not the object obscures lower order objects. That is, this flag indicates whether the object is partially transparent, and in which case the lower order active objects will thus make a contribution to the color and opacity of the current pixel. Otherwise, this flag indicates that the object is opaque in which case active lower order objects will not make any contribution to the color and opacity of the currently scanned pixel. The pixel sequential renderer determines that an object is exposed if it is the uppermost active object, or if all the active objects above the object have their corresponding flags set to transparent. The pixel sequential renderer then composites these exposed active objects to determine and output the color and opacity for the currently scanned pixel.","The driver software, in response to the page, also extracts edge information defining the edges of the objects for feeding to the edge tracking module. The driver software also generates a linearised table (herein after called the priority properties and status table) of the expression tree of the objects and their compositing operations which is fed to the priority determination module. The priority properties and status table contains one record for each object on the page. In addition, each record contains a field for storing a pointer to an address for the fill of the corresponding object in a fill table. This fill table is also generated by the driver software and contains the fill for the corresponding objects, and is fed to tile fill determination module. The priority properties and status table together with the fill table are devoid of any edge information and effectively represent the objects, where the objects are infinitively extending. The edge information is fed to the edge tracking module, which determines, for each pixel in raster scan order, the edges of any objects that intersect a currently scanned pixel. The edge tracking module passes this information onto the priority determination module. Each record of the priority properties and status table contains a counter, which maintains a fill count associated with the corresponding object of the record. The priority determination module processes each pixel in a raster scan order. Initially, the fill counts associated with all the objects are zero, and so all objects are inactive. The priority determination module continues processing each pixel until it encounters an edge intersecting that pixel. The priority determination module updates the fill count associated with the object of that edge, and so that object becomes active. The priority determination continues in this fashion updating the fill count of the objects and so activating and de-activating the objects. The priority determination module also determines whether these active objects are exposed or not, and consequently whether they make a contribution to the currently scanned pixel. In the event that they do, the pixel determination module generates a series of messages which ultimately instructs the pixel compositing module to composite the color and opacity for these exposed active objects in accordance with the compositing operations specified for these objects in the priority properties and status table so as to generate the resultant color and opacity for the currently scanned pixel. These series of messages do not at that time actually contain the color and opacity for that object but rather an address to the fill table, which the fill determination module uses to determine the color and opacity of the object.","For ease of explanation the location (viz level) of the object in the order of the objects from the rearmost object to the foremost is herein referred to as the object's priority. Preferably, a number of non-overlapping objects that have the same fill and compositing operation, and that form a contiguous sequence in the order of the objects, may be designated as having the same priority. Most often, only one priority (viz level) is required per object, however some objects may require several instructions, and thus the object may require several priorities (viz levels). For example, a character with a color fill may be represented by, a bounding box (B) on a first level having the color fill, a one-bit bitmap (S) which provides the shape of the character on a second level, and the same bounding box (B) on a third level having the color fill, where the levels are composited together ((B xor Page) and S) xor B to produce the color character.","The pixel sequential renderer also utilises clip objects to modify the shape of another object. The pixel sequential renderer maintains an associated clip count for the clip in a somewhat similar fashion to the fill count to determine whether the current pixel is within the clip region.","As will become apparent, there exist runs of pixels having constant color and opacity between adjacent edges. The pixel sequential renderer can composite the color and opacity for the first pixel in the run and in subsequent pixels in the run reproduce the previous composited color and opacity without any further compositions, thus reducing the overall number of compositing operations. In the circumstances where a run of pixels comprises varying color and opacity at one or more priority levels, this technique cannot be used. However, in the latter case the preferred arrangements are still able to minimise the number of compositing operations, as will be described below in more detail.","A software program (hereafter referred to as the driver), is loaded and executed on the host processor  for generating instructions and data for the pixel-sequential graphics rendering apparatus , from data provided to it by a third-party application. Said third-party application may provide data in the form of a standard language description of the objects to be drawn on the page, such as PostScript and PCL, or in the form of function calls to the driver through a standard software interface, such as the Windows GDI or X-11.","The driver software separates the data associated with an object (supplied by the third-party application) into data about the edges of the object, any operation or operations associated with painting the object onto the page, and the color and opacity with which to fill pixels which fall inside the edges of the object.","The driver software partitions the edges of each object into edges which are monotonic increasing in the Y-direction, and then divides each partitioned edge of the object into segments of a form suitable for the edge module described below. Partitioned edges are sorted by the X-value of their starting positions and then by Y. Groups of edges starting at the same Y-value remain sorted by X-value, and may be concatenated together to form a new edge list, suitable for reading in by the edge module when rendering reaches that Y-value.","The driver software sorts the operations, associated with painting objects, into priority order, and generates instructions to load the data structure associated with the priority determination module (described below). This structure includes a field for the fill rule, which describes the topology of how each object is activated by edges, a field for the type of fill which is associated with the object, being painted, and a field, to identify whether data on levels below the current object is required by the operation. There is also a field, herein called clip count, that identifies an object as a clipping object, that is, as an object which is not, itself, filled, but which enables or disables filling of other objects on the page.","The driver software also prepares a data structure (the fill table) describing how to fill objects, said fill table is indexed by the data structure in the priority determination module. This allows several levels in the priority determination module to refer to the same fill data structure.","The driver software assembles the aforementioned data into a job containing instructions for loading the data and rendering pixels, in a form that can be read by the rendering system, and transfers the assembled job to the rendering system. This may be performed using one of several methods known to the art, depending on the configuration of the rendering system and its memory.","Referring now to , a functional data flow diagram of the preferred arrangement is shown. The functional flow diagram of  commences with an object graphic description  which is used to describe those parameters of graphic objects in a fashion appropriate to be generated by the host processor  and\/or, where appropriate, stored within the system RAM  or derived from the system ROM , and which may be interpreted by the pixel sequential rendering apparatus  to render therefrom pixel-based images. For example, the object graphic description  may incorporate objects with edges in a number of formats including straight edges (simple vectors) that traverse from one point on the display to another, or an orthogonal edge format where a two-dimensional object is defined by a plurality of edges including orthogonal lines. Further formats, where objects are defined by continuous curves are also appropriate and these can include quadratic polynomial fragments where a single curve may be described by a number of parameters which enable a quadratic based curve to be rendered in a single output space without the need to perform multiplications. Further data formats such as cubic splines and the like may also be used. An object may contain a mixture of many different edge types. Typically, common to all formats are identifiers for the start and end of each line (whether straight or curved) and typically, these are identified by a scan line number thus defining a specific output space in which the curve may be rendered.","For example,  shows a prior art edge description of an edge  that is required to be divided into two segments  and  in order for the segments to be adequately described and rendered. This arises because the prior art edge description, whilst being simply calculated through a quadratic expression, could not accommodate an inflexion point . Thus the edge  was dealt with as two separate edges having end points  and , and  and  respectively.  shows a cubic spline  that is described by endpoints  and , and control points  and . This format requires calculation of a cubic polynomial for render purposes and thus is expensive of computational time.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIGS. 16C and 16D"},"In , a single edge  is illustrated spanning between scanlines A and M. An edge is described by a number of parameters including start_x, start_y, one or more segment descriptions that include an address that points to the next segment in the edge, and a finish segment used to terminate the edge. According to the preferred arrangement, the edge  may be described as having three step segments, a vector segment, and a quadratic segment. A step segment is simply defined as having a x-step value and a y-step value. For the three step segments illustrated, the segment descriptions are [0,2], [+2,2], and [+2,0]. Note that the x-step value is signed thereby indicating the direction of the step, whilst the y-step value is unsigned as such is always in a raster scan direction of increasing scalene value. The next segment is a vector segment which typically requires parameters start_x (X), start_y (Y), num_of_scanlines (NY) and slope (DX). In this example, because the vector segment is an intermediate segment of the edge , the start_x and start_y may be omitted because such arise from the preceding segment(s). The parameter num_of_scanlines (NY) indicates the number of scanlines the vector segment lasts. The slope value (DX) is signed and is added to the x-value of a preceding scanline to give the x-value of the current scanline, and in the illustrated case, DX=+1. The next segment is a quadratic segment which has a structure corresponding to that of the vector segment, but also a second order value (DDX) which is also signed and is added to DX to alter the slope of the segment.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 16D"},"It will be apparent from the above that the ability to handle plural data formats describing edge segments allows for simplification of edge descriptions and evaluation, without reliance on complex and computationally expensive mathematical operations. In contrast, in the prior art system of , all edges, whether, orthogonal, vector or quadratic were required to be described by the quadratic form.","The operation of the preferred arrangement will be described with reference to the simple example of rendering an image  shown in  which is seen to include two graphical objects, in particular, a partly transparent blue-colored triangle  rendered on top of and thereby partly obscuring an opaque red colored rectangle . As seen, the rectangle  includes side edges , ,  and  defined between various pixel positions (X) and scan line positions (Y). Because the edges  and  are formed upon the scan lines (and thus parallel therewith), the actual object description of the rectangle  can be based solely upon the side edges  and , such as seen in FIG. A. In this connection, edge  commences at pixel location (,) and extends in a raster direction down the screen to terminate at pixel position (,). Similarly, the edge  extends from pixel position (,) to position (,). The horizontal portions of the rectangular graphic object  may be obtained merely by scanning from the edge  to the edge  in a rasterised fashion.","The blue triangular object  however is defined by three object edges ,  and , each seen as vectors that define the vertices of the triangle. Edges  and  are seen to commence at pixel location (,) and extend respectively to pixel locations (,) and (,). Edge  extends between those two pixel locations in a traditional rasterised direction of left to right. In this specific example because the edge  is horizontal like the edges  and  mentioned above, it is not essential that the edge  be defined. In addition to the starting and ending pixel locations used to describe the edges  and , each of these edges will have associated therewith the slope value in this case +1 and \u22121 respectively.","Returning to , having identified the data necessary to describe the graphic objects to the rendered, the graphic systems  then performs a display list generation step .","The display list generation  is preferably implemented as a software driver executing on the host processor  with attached ROM  and RAM . The display list generation  converts an object graphics description, expressed in any one or more of the well known graphic description languages, graphic library calls, or any other application specific format, into a display list. The display list is typically written into a display list store , generally formed within the RAM  but which may alternatively be formed within the rendering stores . As seen in , the display list store  can include a number of components, one being an instruction stream , another being edge information  and where appropriate, raster image pixel data .","The instruction stream  includes code interpretable as instructions to be read by the pixel sequential rendering apparatus  to render the specific graphic objects desired in any specific image. For the example of the image shown in , the instruction stream  could be of the form of:\n\n","Similarly, the edge information  for the example of  may include the following:\n\n","It will be appreciated from the above example of the instruction stream  and edge information  and the manner in which each are expressed, that in the image  of , the pixel position (X) and the scanline value (Y) define a single output space in which the image  is rendered. Other output space configurations however can be realised using the principles of the present disclosure.",{"@attributes":{"id":"p-0086","num":"0096"},"figref":"FIG. 8","b":["16","13"]},"The display list store  is read by a pixel sequential rendering apparatus , which is typically implemented as an integrated circuit. The pixel sequential rendering apparatus  converts the display list into a stream of raster pixels which can be forwarded to another device, for example, a printer, a display, or a memory store.","Although the preferred arrangement describes the pixel sequential rendering apparatus  as an integrated circuit, it may be implemented as an equivalent software module executing on a general purpose processing unit, such as the host processor .",{"@attributes":{"id":"p-0089","num":"0099"},"figref":"FIG. 3","b":["20","13","30","22","20","300","400","500","550","600","700","800","30","13","400","32","500","34","600","36","700","38"]},"The display list store  and the other stores - detailed above may be implemented in RAM or any other data storage technology.","The processing steps shown in the arrangement of  take the form of a processing pipeline . In this case, the modules of the pipeline may execute simultaneously on different portions of image data in parallel, with messages passed between them as described below. In another arrangement, each message described below may take the form of a synchronous transfer of control to a downstream module, with upstream processing suspended until the downstream module completes the processing of the message.","The instruction executor  reads and processes instructions from the instruction stream  and formats the instructions into messages that transferred via an output  to the other modules , , ,  and  within the pipeline . In the preferred arrangement, the instruction stream  may include the instructions:","LOAD_PRIORITY_PROPERTIES: This instruction is associated with data to be loaded into the priority properties and status table , and an address in that table to which the data is to be loaded. When this instruction is encountered by the instruction executor , the instruction executor  issues a message for the storage of the data in the specified location of the priority properties and status table . This may be accomplished by formatting a message containing this data and passing it down the processing pipeline  to the priority determination module  which performs the store operation.","LOAD_FILL_DATA: This instruction is associated with fill data associated with an object to be loaded into the fill data table , and an address in that table to which the data is to be loaded. When this instruction is encountered by the instruction executor , the instruction executor  issues a message for the storage of the data at the specified address of the fill data table . This may be accomplished by formatting a message containing this data and passing it down the processing pipeline  to the fill color determination module which performs the store operation.","LOAD_NEW_EDGES_AND_RENDER: This instruction is associated with an address in the display list store  of new edges  which are to be introduced into the rendering process when a next scanline is rendered. When this instruction is encountered by the instruction executor, the instruction executor  formats a message containing this data and passes it to the edge processing module . The edge processing module  store the address of the new edges in the edge record store . The edges at the specified address are sorted on their initial scanline intersection coordinate before the next scanline is rendered. In one arrangement, they are sorted by the display list generation process . In another arrangement, they are sorted by the pixel-sequential rendering apparatus .","SET_SCANLINE_LENGTH: This instruction is associated with a number of pixels which are to be produced in each rendered scanline. When this instruction is encountered by the instruction executor , the instruction executor  passes the value to the edge processing module  and the pixel compositing module .","SET_OPACITY_MODE: This instruction is associated with a flag, which indicates whether pixel compositing operations will use an opacity channel (also known in the art as an alpha channel). When this instruction is encountered by the instruction executor , the instruction executor  passes the flag value in the pixel compositing module .","SET_BUF: This instruction sets the address of external memory buffers used by the pixel sequential rendering apparatus . Preferably, at least the input, output and spill buffers of the edge processing module  are stored in external memory.","The instruction executor  is typically formed by a microcode state machine that maps instructions and decodes them into pipeline operations for passing to the various modules. A corresponding software process may alternatively be used.","The operation of the edge processing module  during a scanline render operation will now be described with reference to FIG. . The initial conditions for the rendering of a scanline is the availability of three lists of edge records. Any or all of these lists may be empty. These lists are a new edge list , obtained from the edge information  and which contains new edges as set by the LOAD_NEW_EDGES_AND_RENDER instruction, a main edge list  which contains edge records carried forward from the previous scanline, and a spill edge list  which also contains edge records carried forward from the previous scanline.","Turning now to , there is shown the format of such an edge record, which may include:\n\n","Such a format may accommodate vectors, and orthogonally arranged edges. The format may also include a further parameter herein called DDX, which is a value to be added to the DX of this edge record after each scanline. The latter enables the rendering of edges comprising quadratic curves. The addition of further parameters, DDDX for example, may allow such an arrangement to accommodate cubic curves. In some applications, such as cubic Bezier spline, a 6-order polynomial (ie: up to DDDDDDX) may be required. The flag (u) indicates whether a winding count is to be incremented or decremented by an edge. The winding count is stored in a fill counter and is used to determine whether a currently scanned pixel is inside or outside the object in question. In the example of the edges  and  of , the corresponding edge records at scanline  could read as shown in the Table of FIG. B.","In this description, coordinates which step from pixel to pixel along a scanline being generated by the rendering process will be referred to as X coordinates, and coordinates which step from scanline to scanline will be referred to as Y coordinates. Preferably, each edge list contains zero or more records placed contiguously in memory. Other storage arrangements, including the use of pointer chains, are also possible. The records in each of the three lists ,  and  are arranged in order of scanline intersection (X) coordinate. This is typically obtained by a sorting process, initially managed by an edge input module  which receives messages, including edge information, from the instruction executor . It is possible to relax the sort to only regard the integral portion of each scanline intersection coordinate as significant. It is also possible to relax the sort further by only regarding each scanline intersection coordinate, clamped to the minimum and maximum X coordinates which are being produced by the current rendering process. Where appropriate, the edge input module  relay messages to modules ,  and  downstream in the pipeline  via an output .","The edge input module  maintains references into and receives edge data from each of the three lists , , and . Each of these references is initialised to refer to the first edge in each list at the start of processing of a scanline. Thereafter, the edge input module  selects an edge record from one of the three referenced edge records such that the record selected is the one with the least X coordinate out of the three referenced records. If two or more of the X-records are equal, each is processed in any order and the corresponding edge crossings output in the following fashion. The reference, which was used to select that record, is then advanced to the next record in that list. The edge just selected is formatted into a message and sent to an edge update module . Also, certain fields of the edge, in particular the current X, the priority numbers, and the direction flag, are formatted into a message which is forwarded to the priority determination module  as an output  of the edge processing module . Arrangements that use more or fewer lists than those described here are also possible.","Upon receipt of an edge, the edge update module  decrements the count of how many scanlines for which a current segment will last. If that count has reached zero, a new segment is read from the address indicated by the next segment address. A segment preferably specifies:\n\n","If there is no next segment available at the indicated address, no further processing is performed on that edge. Otherwise, the edge update module  calculates the X coordinate for the next scanline for the edge. This typically would involve taking the current X coordinate and adding to it the DX value. The DX may have the DDX value added to it, as appropriate for the type of edge being handled. The edge is then written into any available free slot in an edge pool , which is an array of two or more edge records. If there is no free slot, the edge update module  waits for a slot to become available. Once the edge record is written into the edge pool , the edge update module  signals via a line  to an edge output module  that a new edge has been added to the edge pool .","As an initial condition for the rendering of a scanline, the edge output module  has references to each of a next main edge list \u2032 and a next spill edge list \u2032. Each of these references is initialised to the location where the, initially empty, lists \u2032 and \u2032 may be built up. Upon receipt of the signal  indicating that an edge has been added to the edge pool , the edge output module  determines whether or not the edge just added has a lesser X coordinate than the edge last written to the next main edge list \u2032 (if any). If this is true, a \u201cspill\u201d is said to have occurred because the edge cannot be appended to the main edge list  without violating its ordering criteria. When a spill occurs, the edge is inserted into the next spill edge list \u2032, preferably in a manner that maintains a sorted next spill edge list \u2032. For example this may be achieve using a insertion sorting routine. In some arrangements the spills may be triggered by other conditions, such as excessively large X coordinates.","If the edge added to the edge pool  has an X coordinate greater than or equal to the edge last written to the next main edge list \u2032 (if any), and there are no free slots available in the edge pool , the edge output module  selects the edge from the edge pool  which has the least X coordinate, and appends that edge to the next main edge list \u2032, extending it in the process. The slot in the edge pool  that was occupied by that edge is then marked as free.","Once the edge input module  has read and forwarded all edges from all three of its input lists ,  and , it formats a message which indicates that the end of scanline has been reached and sends the message to both the priority determination module  and the edge update module . Upon receipt of that message, the edge update module  waits for any processing it is currently performing to complete, then forwards the message to the edge output module . Upon receipt of the message, the edge output module  writes all remaining edge records from the edge pool  to the next main edge list \u2032 in X order. Then, the reference to the next main edge list \u2032 and the main edge list  are exchanged between the edge input module  and the edge output module , and a similar exchange is performed for the next spill edge list \u2032 and the spill edge list . In this way the initial conditions for the following scanline are established.","Rather than sorting the next spill edge list \u2032 upon insertion of edge records thereto, such edge records may be merely appended to the list \u2032, and the list \u2032 sorted at the end of the scanline and before the exchange to the current spill list  becomes active in edge rasterisation of the next scanline.","It can be deduced from the above that edge crossing messages are sent to the priority determination module  in scanline and pixel order (that is, they are ordered firstly on Y and then on X) and that each edge crossing message is labelled with the priority to which it applies.",{"@attributes":{"id":"p-0112","num":"0132"},"figref":["FIG. 12A","FIG. 12A"],"b":["418","400","418","13","418","418"]},"It will be appreciated from  that other data structures are also possible, and necessary for example where polynomial implementations are used. In one alternative data structure, the \u2018segment addr\u2019 field is either the address of the next segment in the segment list or copied from the segments DDX value, if the segment is quadratic. In the latter case, the data structure has a q-flag which is set if the segment-is a quadratic segment, and cleared otherwise. In a further variation, the segment address and the DDX field may be separated into different fields, and additional flags provided to meet alternate implementations.",{"@attributes":{"id":"p-0114","num":"0134"},"figref":["FIG. 12B","FIG. 12B"],"b":["400","428","430","432","412","402","404","406","404","406","402","402","404","406","404","406"]},"Although the preferred arrangements utilizes arrays and associated pointers for the handling of edge records, other implementations, such as linked lists for example may be used. These other implementations may be hardware or software-based, or combinations thereof.","The specific rendering of the image  shown in  will now be described with reference to scanlines ,  and  shown in FIG. . In this example, the calculation of the new X coordinate for the next scanline is omitted for the purposes of clarity, with  to  illustrating the output edge crossing being derived from one of the registers ,  and  of the edge poll .",{"@attributes":{"id":"p-0117","num":"0137"},"figref":"FIG. 12C","b":["34","80","34","402","404","404","82","84","434","436","440","34","450"]},"As noted above, at the commencement of each scanline, the next main edge list \u2032 and the main edge list  are swapped and new edges are received into the new edge list . The remaining lists are cleared and each of the pointers set to the first member of each list. For the commencement of scanline , the arrangement then appears as seen in FIG. D. As is apparent from , the records include four active edges which, from , are seen to correspond to the edges , ,  and .","Referring now to , when rendering starts, the first segment of the new edge record  is loaded into an active edge record  and the first active edge records of the main edge list  and spill edge list  are copied to records  and  respectively. In this example, the spill edge list  is empty and hence no loading takes place. The X-positions of the edges within the records ,  and  are then compared and an edge crossing is emitted for the edge with the smallest X-position. In this case, the emitted edge is that corresponding to the edge  which is output together with its priority value. The pointers ,  and  are then updated to point to the next record in the list.","The edge for which the edge crossing was emitted is then updated (in this case by adding DX=0 to its position), and buffered to the edge pool  which, in this example, is sized to retain three edge records. The next entry in the list from which the emitted edge arose (in this case list ) is loaded into the corresponding record (in this case record ). This is seen in FIG. F.","Further, as is apparent from , a comparison between the registers ,  and  again selects the edge with the least X-value which is output as the appropriate next edge crossing (X=85, P=2). Again, the selected output edge is updated and added to the edge pool  and all the appropriate pointers incremented. In this case, the updated value is given by X\u2190X+DX, which is evaluated as 84=85\u22121. Also, as seen, the new edge pointer  is moved, in this case, to the end of the new edge list .","In , the next edge identified with the lowest current X-value is again that obtained from the register  which is output as an edge crossing (X=115, P=2). Updating of the edge again occurs with the value be added to the edge pool  as shown. At this time, it is seen that the edge pool  is now full and from which the edge with the smallest X-value is selected and emitted to the output list \u2032, and the corresponding limited pointer moved accordingly.","As seen in , the next lowest edge crossing is that from the register  which is output (X=160 P=1). The edge pool  is again updated and the next small X-value emitted to the output list \u2032.","At the end of scanline , and as seen in , the contents of the edge pool  are flushed to the output list \u2032 in order of smallest X-value. As seen in , the next main edge list \u2032 and the main edge list  are swapped by exchanging their pointers in anticipation of rendering the next scanline . After the swapping, it is seen from  that the contents of the main edge list  include all edge current on scanline  arranged in order of X-position thereby permitting their convenient access which facilitates fast rendering.","Ordinarily, new edges are received by the edge processing module  in order of increasing X-position. When a new edge arrives, its position is updated (calculated for the next scanline to be rendered) and this determines further action as follows:","(a) if the updated position is less than the last X-position output on the line , the new edge is insertion sorted into the main spill list  and the corresponding limit register updated;","(b) otherwise, if there is space, it is retained in the edge pool .","As is apparent from the foregoing, the edge pool  aids in the updating of the lists in an ordered manner in anticipation of rendering the next scanline in the rasterised image. Further, the size of the edge pool  may be varied to accommodate larger numbers of non-ordered edges. However, it will be appreciated that in practice the edge pool  will have a practical limit, generally dependent upon processing speed and available memory with the graphic processing system. In a limiting sense, the edge pool  may be omitted which would ordinarily require the updated edges to be insertion sorted into the next output edge list \u2032. However, in the preferred arrangement this situation is avoided, as a normal occurrence through the use of the spill lists mentioned above. The provision of the spill lists allows the preferred arrangement to be implemented with an edge pool of practical size and yet handle relatively complex edge intersections without having to resort to software intensive sorting procedures. In those small number of cases where the edge pool and spill list are together insufficient to accommodate the edge intersection complexity, sorting methods may be used.","An example of where the spill list procedure is utilised is seen in  where three arbitrary edges ,  and  intersect an arbitrary edge  at a relative position between scanlines A and B. Further, the actual displayed pixel locations  for each of scanlines A, B, are shown which span pixel locations C to J. In the above described example where the edge pool  is size to retain three edge records, it will be apparent that such an arrangement alone will not be sufficient to accommodate three edge intersections occurring between adjacent scanlines as illustrated in FIG. A.",{"@attributes":{"id":"p-0130","num":"0150"},"figref":"FIG. 14B","b":["60","61","63","412","60","61","63","62","430","412","60","404"]},"In , the next edge crossing is emitted (X=J for edge ) and the) corresponding updated value determined, in this case X=C for scanline B. Because the new updated value X=C is less than the most recent value X=E copied to the output list \u2032, the current edge record and its corresponding new updated value is transferred directly to the output spill list \u2032.",{"@attributes":{"id":"p-0132","num":"0152"},"figref":"FIG. 14D","b":["60","430","62","432","62","412"]},"Edge emission and updating continues for the remaining edges in the main edge list  and at the end of the scanline, the edge pool  is flushed to reveal the situation shown in , where it is seen that each of the edges  to  are appropriately ordered for rendering on the next scanline, having been correctly emitted and rendered on scanline B.","As will be apparent from the foregoing, the spill lists provide for maintaining edge rasterisation order in the presence of complex edge crossing situations. Further, by virtue of the lists being dynamically variable in size, large changes in edge intersection numbers and complexity may be handled without the need to resort to sorting procedures in all but exceptionally complex edge intersections.","In the preferred arrangement the edge pool  is sized to retain eight edge records and the lists , \u2032 together with their associated spill lists , \u2032 have a base (minimum) size of 512 bytes which is dynamically variable thereby providing sufficient scope for handling large images with complex edge crossing requirements.","The operation of the priority determination module  will now be described with reference to FIG. . The primary function of the priority determination module  is to determine those objects that make a contribution to a pixel currently being scanned, order those contributing objects in accordance with their priority levels, and generate color composite messages for instructing the pixel compositing module  to composite the ordered objects to generate the required color and opacity for the current pixel.","The priority determination module  receives incoming messages  from the edge processing module . These incoming messages may include load priority data messages, load fill data messages, edge crossing messages, and end of scanline messages. These messages first pass through a first-in first-out (FIFO) buffer  before being read by a priority update module . The FIFO  acts to de-couple the operation of the edge processing module  and the priority determination module . Preferably the FIFO  is sized to enable the receipt from the edge processing module  and transfer a full scanline of edge-crossings in a single action. Such permits the priority determination module  to correctly handle multiple edge-crossings at the same pixel (X) location.","The priority determination module  is also adapted to access a priority state table , and a priority data table . These tables are used to hold information about each priority. Preferably, the priority state and priority data tables ,  are combined into one table  as shown in FIG. . Alternatively these tables ,  can be kept separate.","Preferably, the priority properties and status table  includes at least the following fields as shown in  for each priority level:\n\n","Clipping objects are known in the art and act not to display a particular new object, but rather to modify the shape of an another object in the image. Clipping objects can also be turned-on and turned-off to achieve a variety of visual effects. For example, the object  of  could be configured as a clipping object acting upon the object  to remove that portion of the object  that lies beneath the clipping object . This may have the effect of revealing any object or image beneath the object  and within the clipping boundaries that would otherwise be obscured by the opacity of the object . The CLIPPER flag is used to identify whether the priority is a clipping object. Also, the CLIP flag is used to determine whether the priority is a clip in or a clip out, and the CLIP COUNT is used in a similar fashion to FILL COUNT to determine whether the current pixel is within the clip region.",{"@attributes":{"id":"p-0141","num":"0174"},"figref":"FIGS. 13A and 13B"},"For the purposes of the non-zero winding rule,  illustrates how the edges  and  of an object  are allocated a notional direction, according to whether the edges are downwards-heading or upwards-heading respectively. In order to form a closed boundary, edges link nose-to-tail around the boundary. The direction given to an edge for the purposes of the fill-rule (applied and described later) is independent of the order in which the segments are defined. Edge segments are defined in the order in which they are tracked, corresponding to the rendering direction.",{"@attributes":{"id":"p-0143","num":"0176"},"figref":["FIG. 13B","FIG. 13B"],"b":["73","76","74","75","77","73","76","74","77"]},"The NEED_BELOW flag for a priority is established by the driver software and is used to inform the pixel generating system that any active priorities beneath the priority in question do not contribute to the pixel value being rendered, unless the flag is set. The flag is cleared where appropriate to prevent extra compositing operations that would otherwise contribute nothing to the final pixel value.","The raster operation code (COLOR_OP), alpha channel operation (ALPHA_OP) and stack operation (STACK_OP) together form the pixel operation (PIXEL_OP), that is to be performed by the pixel compositing module  on each pixel where the priority is active and exposed.","Preferably, most of the information contained in the combined table  is directly loaded by instructions from the driver software. In particular, the fill-rule flag, the clipper flag, the clip type flag, and the need-below flag, fill table address, fill type, raster operation, code, alpha channel operation code, stack operation code, x_independent flag, and other attributes may be handled in this manner. On the other hand, the fill counter, and clip counter are initially zero and are changed by the priority determination module  in response to edge crossing messages.","The priority determination module  determines that a priority is active at a pixel if the pixel is inside the boundary edges which apply to the priority, according to the fill-rule for that priority, and the clip count for the priority. A priority is exposed if it is the uppermost active priority, or if all the active priorities above it have their corresponding need-below flags set. In this fashion, pixel values may be generated using only the fill data of the exposed priorities. It is important to note that an object's priority designates the location (viz level) of the object in the order of the objects from the rearmost object to the foremost object. Preferably, a number of non-overlapping objects that have the same fill and compositing operation, and that form a contiguous sequence, may be designated as having the same priority. This effectively saves memory space in the fill table. Furthermore, the corresponding edge records of objects need only reference the corresponding priority in order to reference the corresponding fill and compositing operation.","Returning now to , the priority update module  maintains a counter  which records the scanline intersection coordinate up to which it has completed processing. This will be referred to as the current X of the priority update module . The initial value at the start of a scanline is zero.","Upon examining an edge crossing message received at the head of the FIFO , the priority update module  compares the X intersection value in the edge crossing message with its current X. If the X intersection value in the edge crossing message is less than or equal to the current X of the priority update module  processes the edge crossing message. Edge crossing message processing comes in two forms, \u201cnormal edge processing\u201d (described below) is used when the record in the priority state table  of the combined table  indicated by the priority in the edge crossing message has a clipper flag which indicates that this is not a clip priority, otherwise \u201cclip edge processing\u201d (described below) is performed.","\u201cNormal edge processing\u201d includes, for each priority in the edge crossing message and with reference to fields of the record of combined table  indicated by that priority, the steps of:","(i) noting the current fill count of the current priority;","(ii) either:\n\n","iii) comparing the new fill count with the noted fill count and if one is zero and the other is non-zero performing an \u201cactive flag update\u201d (described below) operation on the current priority.","Some arrangements may use a separate edge crossing message for each priority rather than placing a plurality of priorities in each edge crossing message.","An active flag update operation includes first establishing a new active flag for the current priority. The active flag is non-zero if the fill count for the priority in the priority state table  is non-zero and the clip count for the priority is zero, else the active flag is zero. The second step in the active flag update operation is to store the determined active flag in an active flags array  at the position indicated by the current priority, then if the need-below flag in the priority state table for the current priority is zero, also storing the active flag in an opaque active flags array  at the position indicated by the current priority.","\u201cClip edge processing\u201d includes, with reference to fields of the priority state table record indicated by the first priority in the edge crossing message, the steps of:","(i) noting the current fill count of the current priority;","(ii) either:\n\n","(iii) comparing the new fill count with the noted fill count and determining a clip delta value of:\n\n","(iv) for every subsequent priority after the first in the edge crossing message, add the determined clip delta value to the clip count in the record in the priority state stable indicated by that subsequent priority, and if the clip count either moved from non-zero to zero, or from zero to non-zero in that process, performing an active flag update operation as described above on that subsequent priority. It should be noted that the initial value of each clip count is set by the LOAD_PRIORITY_PROPERTIES instruction described previously. The clip count is typically initialised to the number of clip-in priorities, which affect each priority.","Some arrangements do not associate a priority with a clip, but instead directly increment and decrement the clip count of all priorities given in the edge crossing message. This technique can be used, for example, when clip shapes are simple and do not require the application of a complex fill rule. In this specific application, the clip count of the level controlled by an edge is incremented for an upwards heading edge or decremented for a downwards heading edge. A simple closed curve, described anticlockwise, acts a clip-in, whereas a simple closed curve, described clockwise, acts as a clip-out.","When the X intersection value in the edge crossing message is greater than the current X of the priority update module , the priority update module  forms a count of how many pixels to generate, being the difference between the X intersection value in the edge crossing message and the current X, this count is formatted into a priority generation message, which is sent via a connection  to a priority generation module . The priority update module  then waits for a signal  from the priority generation module  indicating that processing for the given number of pixels has completed. Upon receipt of the signal , the priority update module  sets its current X to the X intersection value in the edge crossing message and continues processing as described above.","Upon receipt of a priority generation message , the priority generation module  performs a \u201cpixel priority generation operation\u201d (described below) a number of times indicated by the count it has been supplied, thereupon it signals  the priority update module  that it has completed the operation.","Each pixel priority generation operation includes firstly using a priority encoder  (eg. a 4096 to 12 bit priority encoder) on the opaque active flags array  to determine the priority number of the highest opaque active flag. This priority (if any) is used to index the priority data table  and the contents of the record so referenced is formed into a fill priority message output  from the priority generation module  and sent to the fill color determination module  via the optimisation module . Further, if a priority was determined by the previous step (ie. there was at least one opaque active flag set), the determined priority is held, and is referred to as the \u201ccurrent priority\u201d. If no priority was determined the current priority is set to zero. The priority generation module  then repeatedly uses a modified priority encoder  on the active flag array  to determine the lowest active flag which is greater than the current priority. The priority so determined (if any) is used to index the priority determination table  and the contents of the record so referenced is formed into a fill priority message. This fill priority message is then sent  to the fill color determination module  via the optimisation module , then the determined priority is used to update the current priority. This step is used repeatedly until there is no priority determined (that is, there is no priority flagged in the active flags, which is greater than the current priority). Then the priority generation module  forms an end of pixel message and sends it to the fill color determination module . The priority determination module  then proceeds to the next pixel to generate another series of fill priority messages in similar fashion.","Turning now to , there is shown an example of such a series of fill priority messages  generated by the priority determination module  for a single current pixel. As described above, these fill priority messages  are first preceded by a START_OF_PIXEL command. The fill priority messages  are then sent in priority order commencing with the lowest exposed active priority level. When there are no more fill priority messages  for the current pixel, the priority determination module  then sends an END_OF_PIXEL message .","Each of one these fill priority messages  preferably includes at least the following fields:","(i) An identifier code FILL_PRTY  for identifying the message as a fill priority message. This code also includes an index LEVEL_INDX to the corresponding record in the combined table , and also a code FIRST_PIXEL indicating whether or not this fill priority message belongs to a first pixel in a run of pixels having the same fill priority messages. The priority determination module  asserts the FIRST_PIXEL code for all those fill priority messages of a currently scanned pixel that is intersected by an edge as indicated by the edge crossing messages. The FIRST_PIXEL code is de-asserted for all fill priority messages of a currently scanned pixel if there is no edges intersecting that pixel as indicated by the edge crossing messages.","(ii) A fill table address FILL_INDEX,","(iii) A fill type FILL_TYPE,","(iv) A raster operation code COLOR_OP,","(v) An alpha channel operation code Alpha_OP,","(vi) A stack operation code STACK_OP, and","(vii) A flag X_IND which records whether the color of this priority is constant for a given Y, referred to here as the \u201cx-independent\u201d flag. This flag is asserted when the color for this priority is constant.","The values of fields (ii) to (vii) for the fill priority message are retrieved from the corresponding record in the combined table .","Preferably, the priority generation module  notes the value of the x-independent flag of each fill priority message that it forwards to the fill color determination module  while it processes the first pixel of a sequence. If all the forwarded messages have the x-independent flag specified, all subsequent messages in the span of pixels between adjacent edge intersections can be replaced by a single repeat specification of count minus one. This is done by producing a repeat message and sending it to the fill color determination module  in place of all further processing in this sequence. As will be recognised that if all the fill priority messages of a first pixel in a span of pixels between adjacent edges have their x-independent flag asserted, then the color and opacity of the pixels in the span of pixels will be constant. Thus in these cases, the pixel compositing module  need only composite the first pixel in the span of pixels to generate the required constant color and opacity and pass this onto the pixel output module . The generated repeat command then is passed to the pixel output module  which reproduces the constant color and opacity for the subsequent pixels in the span of pixels from the color and opacity of the first pixel. In this fashion, the number of compositing operations performed by the pixel compositing module  is reduced.","As another preferred feature to the basic operation described above, the priority generation module  sends the highest opaque priority via the connection  to the priority update module  after each edge crossing message. The priority update module  holds this in a store . The priority determination module  then, instead of a simple test that the X intersection in the message is greater than the current X, performs a test that the X intersection in the message is greater than the current X and that at least one of the levels in the message is greater than or equal to the highest opaque priority, before producing a fill priority message. By doing this, fewer pixel priority determination operations may be done and longer repeat sequences may be generated.","Using the example of the graphic objects shown in , A and B, the priority update process described above can be illustrated, for scanline  using the edge crossings seen from  to J, as seen in  to E.",{"@attributes":{"id":"p-0178","num":"0218"},"figref":"FIGS. 15A","b":["15","502","504","34","18","34","508","510","512","514"]},"As seen in , edge crossing messages are received in order for a scanline from the edge processing module  and are loaded into the table , which is arranged in priority order. The edge crossing messages include, in this example, an incrementing direction according to the non-zero winding rule of the edge traversal. It is possible for no entries in the priority table  to be set.","The priority determination table as illustrated  includes column entries for fill count, which are determined from the edge according to the non-zero winding rule or, where appropriate, the odd-even rule. The need-below flag is a property of a priority and is set as part of the LOAD_PRIORITIES_PROPERTIES instruction. The need-below is set for all priority levels when the table  is loaded. Other columns such as \u201cclip count\u201d and \u201cfill index table\u201d may be used, but for this example are omitted for simplicity of explanation. Where no level is active the corresponding entries are set to zero. Further, the values of the arrays  and  are updated from the table  after receiving a subsequent edge crossing.","From , it will be apparent that, for convenience, a number of records have been omitted for clarity. As described previously, the contents of the table , where not used in the priority determination module  are passed as messages to each of the fill color determination module  for pixel generation, and to the pixel compositing module  for compositing operations.","The first edge crossing for scanline  () is seen in  where for P=1, the fill count is updated to the value of the edge according to the non-zero winding rule. The \u201cneed-below\u201d flag for this level has been set to zero by the driver software as the object in question is opaque.","Because a previous state of the table  was not set, the arrays  and  remain not set and the priority encoder  is disabled from outputting a priority. This is interpreted by priority generation module  which outputs a count n=40 (pixels) for a \u201cno object\u201d priority (eg: P=0), being the first, blank, portion of the scanline .",{"@attributes":{"id":"p-0184","num":"0224"},"figref":["FIG. 15B","FIG. 12F"],"b":["510","508","34","516","96","90","80"]},{"@attributes":{"id":"p-0185","num":"0225"},"figref":["FIG. 15C","FIG. 12G"],"b":"512"},{"@attributes":{"id":"p-0186","num":"0226"},"figref":["FIG. 15D","FIG. 12H"],"b":"508"},{"@attributes":{"id":"p-0187","num":"0227"},"figref":["FIG. 15E","FIG. 121"]},"As such, the priority module  outputs counts of pixels and corresponding priority display values for all pixels of a scanline.","The next module in the pipeline is the optimisation module . This module  looks for groups of instructions (viz fill priority messages) that can be combined into a single color and instruction, which can be calculated once and stored into a register at the pixel compositing module  on the first pixel in a run of pixels. On subsequent pixels, the color and instruction can be restored from the register, rather than being calculated each time. For example, in the situation where a resultant color for a pixel is x-independent over a run of pixels, the optimisation circuit can send a REPEAT PIXEL message to the compositing module  which can restore the resultant color for subsequent pixels. In this way, the optimisation module reduces the number of compositing operations being performed by the compositing module. In the circumstances where the first pixel in a run comprises an x-dependent pixel value at a particular level, the REPEAT PIXEL message cannot be used. However, the optimisation module is still able to minimise the number of compositing operations, as will be described below in sections 4.0 to 4.5 and 5.0 in more detail.","The operation of the fill color determination module  will now be described with reference to FIG. . Incoming messages  from the priority determination module , which include set fill data messages, repeat messages, fill priority messages, end of pixel messages, and end of scanline messages, first pass to a fill lookup and control module . The fill lookup and control module  maintains a current X position counter  and a current Y position counter  for use by various components of the fill color determination module .","Upon receipt of an end of scanline message, the fill lookup and control module  resets the current X counter  to zero and increments the current Y counter . The end of scanline message is then passed to the pixel compositing module .","Upon receipt of a set fill data message, the fill lookup and control module  stores the data in the specified location  of the fill data table .","Upon receipt of a repeat message, the fill lookup and control module  increments the current X counter  by the count from the repeat message. The repeat message is then passed to the pixel compositing module .","Upon receipt of an end of pixel message , the fill lookup and control module  again increments the current X counter , and the end of pixel message is then passed to the pixel compositing module .","Upon receipt of a fill priority message, the fill lookup and control module  performs operations which include:","(i) the fill type from the fill priority message is used to select a record size in the table ;","(ii) the fill table address from the fill priority message, and the record size as determined above, is used to select a record from the fill data table ;","(iii) the fill type from the fill priority message is used to determine and select a sub-module to perform generation of the fill color. The sub-modules may include a raster image module , a flat color module , a linearly ramped color module , and an opacity tile module ;","(iv) the determined record is supplied to the selected sub-module -;","(v) the selected sub-module - uses the supplied data to determine a color and opacity value;","(vi) the determined color and opacity is combined with remaining information from the fill color message, namely the raster operation code, the alpha channel operation code, the stack operation code, to form a color composite message , which is sent to the pixel compositing module  via the connection .","Thus, as shown in , a message sequence  starting with a start of pixel message  message, then fill priority messages  followed by an end of pixel message  is transformed into a message sequence  comprising a start of pixel message , color composite messages  followed by an end of pixel message . These color composite messages  preferably includes the same fields as the fill priority messages , with the following exceptions:","(i) code CLR_CMP  for identifying the message as a color composite message. This CLR_CMP code also includes the index to the corresponding record in the combined table ;","(ii) a color and opacity field for containing the color and opacity value of the priority. The latter replaces the Fill index and fill type fields of the fill priority messages; and\n\n","In the preferred arrangement the determined color and opacity is a red, green, blue and opacity quadruple with 8-bit precision in the usual manner giving 32 bits per pixel. However, a cyan, magenta, yellow and black quadruple with an implied opacity, or one of many other known color representations may alternatively be used. The red, green, blue and opacity case is used in the description below, but the description may also be applied to other cases.","The operation of the raster image module , the flat color module , the linearly ramped color module , and the opacity tile module  will now be described. The flat color module  interprets the supplied record as a fixed format record containing three 8-bit color components (typically interpreted as red, green and blue components) and an 8-bit opacity value (typically interpreted as a measure of the fraction of a pixel which is covered by the specified color, where 0 means no coverage, that is complete transparency, and 255 means complete coverage, that is, completely opaque). This color and opacity value is output directly via the connection  and forms the determined color and opacity without further processing.","The linearly ramped color module  interprets the supplied record as a fixed formal record containing four sets of three constants, cx, cy, and d, being associated with the three color and one opacity components. For each of these four sets, a result value r is computed by combining the three constants with the current X count, x, and the current Y count, y, using the formula:\n\n=clamp ()\n","Where the function clamp is defined as: \n\n","The four results so produced are formed into a color and opacity value. This color and opacity value is output directly via the connection  and forms the determined color and opacity without further processing.","The opacity tile module  interprets the supplied record as a fixed format record containing three 8-bit color components, an 8-bit opacity value, an integer X phase, (px), a Y phase, (py), an X scale, (sx), a Y scale, (sy), and a 64 bit mask. These values originate in the display list generation and contained typically in the original page description. A bit address, a, in the bit mask, is determined by the formula:\n\n=((\/2)mod 8)+((\/2)mod 8)\u00d78\n","The bit at the address \u201ca\u201d in the bit mask is examined. If the examined bit is one, the color and opacity from the record is copied directly to the output of the module  and forms the determined color and opacity. If the examined bit is zero, a color having three zero component values and a zero opacity value is formed and output as the determined color and opacity.","The raster image module  interprets the supplied record as a fixed format record containing six constants, a, b, c, d, tx, and ty; an integer count of the number of bits (bpl) in each raster line of the raster image pixel data  to be sampled; and a pixel type. The pixel type indicates whether the pixel data  in the raster image pixel data is to be interpreted as one of:","(i) one bit per pixel black and white opaque pixels;","(ii) one bit per pixel opaque black or transparent pixels;","(iii) 8 bits per pixel grey scale opaque pixels;","(iv) 8 bits per pixel black opacity scale pixels;","(v) 24 bits per pixel opaque three color component pixels;, or","(vi) 32 bits per pixel three color component plus opacity pixels.","Many other formats are possible.","The raster image module  uses the pixel type indicator to determine a pixel size (bpp) in bits. Then a bit address, a, in the raster image pixel data  is calculated having the formula:\n\n\n","A pixel interpreted according to the pixel type from the record  is fetched from the calculated address \u201ca\u201d in the raster image pixel data . The pixel is expanded as necessary to have three eight bit color components and an eight bit opacity component. By \u201cexpanded\u201d, it is meant for example, that a pixel from an eight bit per pixel grey scale opaque raster image would have the sampled eight bit value applied to each of the red, green and blue component, and the opacity component set to fully opaque. This then forms the determined color and opacity output  to the pixel compositing module .","As a consequence, the raster pixel data valid within a displayable object is obtained through the determination of a mapping to the pixel image data within the memory . This effectively implements an affine transform of the raster pixel data into the object-based image and is more efficient than prior art methods which transfer pixel data from an image source to a frame store where compositing with graphic object may occur.","As a preferred feature to the above, interpolation between pixels in the raster image pixel data  may optionally be performed by first calculating intermediate results p, and q according to the formulae:\n\n\n\n\n","Next the bit addresses, a, a, a, and a, of four pixels in the raster image pixel data  are determined according to the formulae:\n\n=\n\n\u2003=+\n\n=+\n\n=+\n","Next, a result pixel component value, r, is determined for each color and opacity component according to the formula:\n\n=interp(interp(get(), get(), ), interp(get(),get(), ), )\n\nwhere the function interp is defined as:\n\ninterp()=+()*()\n","In the above equations, the representation \u2514value\u2518=floor (value), where a floor operation involves discarding the fractional part of the value.","The get function returns the value of the current pixel component sampled from the raster image pixel data  at the given bit address. Note that for some components of some image types this can be an implied value.","As a preferred feature to the above, image tiling may optionally be performed by using x and y values in the above equations which are derived from the current X and Y counters , by a modulus operation with a tile size read from the supplied record.","Many more such fill color generation sub-modules are possible.","The operation of the pixel compositing module  will now be described. The primary function of the pixel compositing module is to composite the color and opacity of all those exposed object priorities that make an active contribution to the pixel currently being scanned.","Preferably, the pixel compositing module  implements a modified form of the compositing approach as described in \u201cCompositing Digital Images\u201d, Porter, T: Duff, T; Computer Graphics, Vol 18 No 3 (1984) pp253-259. Examples of Porter and Duff compositing operations are shown in FIG. . However, such an approach is deficient in that it only permits handling a source and destination color in the intersection region formed by the composite, and as a consequence is unable to accommodate the influence of transparency outside the intersecting region. The preferred arrangement overcomes this by effectively padding the objects with completely transparent pixels. Thus the entire area becomes in effect the intersecting region, and reliable Porter and Duff compositing operations can be performed. This padding is achieved at the driver software level where additional transparent object priorities are added to the combined table. These Porter and Duff compositing operations are implemented utilising appropriate color operations as will be described below in more detail with reference to , B, and .","Preferably, the images to be composited are based on expression trees. Expression trees are often used to describe the compositing operations required to form an image, and typically comprise a plurality of nodes including leaf nodes, unary nodes and binary nodes. A leaf node is the outermost node of an expression tree, has no descendent nodes and represents a primitive constituent of an image. Unary nodes represent an operation which modifies the pixel data coming out of the part of the tree below the unary operator. A binary node typically branches to left and right subtrees; wherein each subtree is itself is an expression tree comprising at least one leaf node. An example of an expression tree is shown in FIG. C. The expression tree shown in  comprises four leaf nodes representing three objects A, B, and C, and the page. The expression tree of  also comprises binary nodes representing the Porter and Duff OVER operation. Thus the expression tree represents an image where the object A is composited OVER the object B, the result of which is then composited OVER object C, and the result of which is then composited OVER the page.","Turning now to , there is shown a typical binary compositing operation in an expression tree. This binary operator operates on a source object (src) and a destination object (dest), where the source object src resides on the left branch and the destination object (dest) resides on the right branch of the expression tree. The binary operation is typically a Porter and Duff compositing operation. The area src \u2229 dest represents the area on the page where the objects src and dest objects intersect (ie both active), the area src\u2229{overscore (dest)} where only the src object is active, and the area {overscore (src)}\u2229dest where only the dest object is active.","The compositing operations of the expression tree are implemented by means of the pixel compositing stack , wherein the structure of the expression tree is implemented by means of appropriate stack operations on the pixel compositing stack .","Turning now to , there is shown the pixel compositing module  in accordance with one arrangement in more detail. The pixel compositing module  receives incoming messages from the fill color determination module . These incoming messages include repeat messages, series of color composite messages (see FIG. B), end of pixel messages, and end of scanline messages, and are processed in sequence.","The pixel compositing module  comprises a decoder  for decoding these incoming messages, a compositor  for compositing the colors and opacities contained in the incoming color composite messages. The pixel compositing module  also comprises a stack controller  for placing the resultant colors and opacities on a stack , and output FIFO  for storing the resultant color and opacity.","During the operation of the pixel compositing module , the decoder , upon the receipt of a color composite message, extracts the raster operation COLOR_OP and alpha channel operation codes ALPHA_OP and passes them to the compositor . The decoder  also extracts the stack operation STACK_OP and color and opacity values COLOR, ALPHA of the color composite message and passes them to the stack controller . Typically, the pixel composing module  combines the color and opacity from the color composite message with a color and opacity popped from the pixel compositing stack  according to the raster operation and alpha channel operation from the color composite message. It then pushes the result back onto the pixel compositing stack . More generally, the stack controller  forms a source (src) and destination (dest) color and opacity, according to the stack operation specified. If at this time, or during any pop of the pixel compositing stack, the pixel compositing stack  is found to be empty, an opaque white color value is used without any error indication. These source and destination colors and opacity are then made available to the compositor  which then performs the compositing operation in accordance with the COLOR_OP and ALPHA_OP codes. The resultant (result) color and opacity is then made available to the stack controller , which stores the result on the stack  in accordance with the STACK_OP code. These stack operations are described below in more detail below.","During the operation of the pixel compositing module , if the decoder  receives an end of pixel message, it then instructs the stack controller  to pop a color and opacity from the pixel compositing stack . If the stack  is empty an opaque white value is used. The resultant color and opacity is then formed into an pixel output message which is forwarded to the pixel output FIFO . If the decoder  receives a repeat message or an end of scanline message, the decoder  by-passes (not shown) the compositor  and stack controller  and forwards the messages to the pixel output FIFO  without further processing.","As seen in , an intermediate-value register  is accessible to the decoder  and the stack controller . Values from the stack  may be stored in register  and later restored to the stack , as described in more detail below. Another arrangement is seen in , in which the register  is replaced by an accumulator and accumulated value register . The function of the accumulator unit  is described in more detail in section 4.5.",{"@attributes":{"id":"p-0240","num":"0281"},"figref":"FIGS. 24A","b":"38"},{"@attributes":{"id":"p-0241","num":"0282"},"figref":"FIG. 24A","b":["2350","38","38","38","2304","38"]},{"@attributes":{"id":"p-0242","num":"0283"},"figref":"FIG. 24B","b":["2370","38","38","2304","38"]},{"@attributes":{"id":"p-0243","num":"0284"},"figref":"FIG. 24C","b":"2304"},{"@attributes":{"id":"p-0244","num":"0285"},"figref":"FIG. 24D","b":"2304"},"Other stack operations can be used, without departing from the spirit of the invention.","The manner in which the compositor  combines the source (src) color and opacity with the destination (dest) color and opacity will now be described with reference to  to C. For the purposes of this description, color and opacity values are considered to range from 0 to 1, (ie: normalised) although they are typically stored as 8-bit values in the range 0 to 255. For the purposes of compositing together two pixels, each pixel is regarded as being divided into two regions, one region being fully opaque and the other fully transparent, with the opacity value being an indication of the proportion of these two regions.  shows a source pixel  which has some three component color value not shown in the Figure and an opacity value, (so). The shaded region of the source pixel  represents the fully opaque portion  of the pixel . Similarly, the non-shaded region in  represents that proportion  of the source pixel  considered to be fully transparent.  shows a destination pixel  with some opacity value, (do). The shaded region of the destination pixel  represents the fully opaque portion  of the pixel . Similarly, the pixel  has a fully transparent portion . The opaque regions of the source pixel  and destination pixel  are, for the purposes of the combination, considered to be orthogonal to each other. The overlay  of these two pixels is shown in FIG. C. Three regions of interest exist, which include a source outside destination  which has an area of so*(1\u2212do), a source intersect destination  which has an area of so*do, and a destination outside source  which has an area of (1\u2212so)*do. The color value of each of these three regions is calculated conceptually independently. The source outside destination region  takes its color directly from the source color. The destination outside source region  takes its color directly from the destination color. The source intersect destination region  takes its color from a combination of the source and destination color.","The process of combining the source and destination color, as distinct from the other operations discussed above is termed a raster operation and is one of a set of functions as specified by the raster operation code from the pixel composite message. Some of the raster operations included in the preferred arrangement are shown in FIG. . Each function is applied to each pair of color components of the source and destination colors to obtain a like component in the resultant color. Many other functions are possible.","The alpha channel operation from the composite pixel message is also considered during the combination of the source and destination color. The alpha channel operation is performed using three flags LAO_USE_D_OUT_S, LAO_USE_S_OUT_D, LAO_USE_S_ROP_D, which respectively identify the regions of interest (1\u2212so)*do, so*(1\u2212do), and so*do in the overlay  of the source pixel  and the destination pixel . For each of the regions, a region opacity value is formed which is zero if the corresponding flag in the alpha channel operation is not set, else it is the area of the region.","The resultant opacity is formed from the sum of the region opacities. Each component of the result color is then formed by the sum of the products of each pair of region color and region opacity, divided by the resultant opacity.","As shown in , the Porter and Duff operations may be formed by suitable ALPHA_OP flag combinations and raster operators COLOR_OP, provided that both operands can be guaranteed to be active together. Because of the way the table is read, if only one of the operands is not active, then the operator will either not be performed, or will be performed with the wrong operand. Thus objects that are to be combined using Porter and Duff operations must be padded out with transparent pixels to an area that covers both objects in the operation. Other transparency operations may be formed in the same way as the Porter and Duff operations, using different binary operators as the COLOR_OP operation.","The resultant color and opacity is passed to the stack controller circuit and pushed onto the pixel compositing stack . However, if the stack operation is STACK_KEEP_SRC, the source value is pushed onto the stack before the result of the color composite message is pushed.","When an end of pixel message is encountered, the color and opacity value on top of the stack is formed into a pixel output message, and sent to the Pixel Output module. Repeat pixel messages are passed through the Pixel Compositing module to the Pixel Output module.","The operation of the pixel output module  will now be described. Incoming messages are read from the pixel output FIFO, which include pixel output messages, repeat messages, and end of scanline messages are processed in sequence.","Upon receipt of a pixel output message the pixel output module  stores the pixel and also forwards the pixel to its output. Upon receipt of a repeat message the last stored pixel is forwarded to the output  as many times as specified by the count from the repeat message. Upon receipt of an end of scanline message the pixel output module  passes the message to its output.","The output  may connect as required to any device that utilizes pixel image data. Such devices include output devices such as video display units or printers, or memory storage devices such as hard disk, semiconductor RAM including line, band or frame stores, or a computer network. However, as will be apparent from the foregoing, a method and apparatus are described that provide for the rendering of graphic objects with full functionality demanded by sophisticated graphic description languages without a need for intermediate storage of pixel image data during the rendering process.","The next module in the pipeline after the priority determination module  is the optimisation module . The optimisation module  seeks to minimise the number of fill priority messages and color composite messages that are sent to the fill determination and pixel compositing modules  and  respectively, and thus resulting in the reduction of compositing operations performed by the pixel compositing module .","The optimisation module  achieves this by looking for groups of fill priority messages that can be combined into a single color and opacity, which can be calculated once and stored into a register in the pixel compositing module  during the first pixel in a run. On subsequent pixels, the color and opacity can be restored from the register, rather than being calculated each time.","As mentioned previously, there are cases where all of the forwarded fill priority messages of the first pixel in a run of pixels between adjacent edge intersections have the x-independent flag asserted. In these cases all subsequent fill priority messages in the run of pixels can be replaced by a single repeat specification of count minus one. The pixel compositing module  then only needs to composite the first pixel in the run of pixels to generate the required constant color and opacity and pass this onto the pixel output module . The generated repeat command then is passed to the pixel output module  which reproduces the constant color and opacity for the subsequent pixels in the span of pixels from the color and opacity of the first pixel. In this fashion, compositing operations are not required for the subsequent pixels in the run of pixels and thus the number of compositing operations performed by the pixel compositing module  may be reduced.","There are many other cases, where one or more x-independent flags of the forwarded fill priority messages in a first pixel in run of pixels between adjacent edges are not asserted. For example, one of the objects associated with a fill priority message may be a bitmap, thus the color and opacity varies over the run of pixels. In these cases the optimisation module  identifies groups of fill priority messages in the first pixel of the run of pixels that have the x-independent flags asserted and passes this information to the pixel compositing module, which then calculates their combined color and opacity and stores it a register. On subsequent pixels, the color and opacity can be restored from the register rather than being calculated each time, thus leading to a reduction of compositing operations.","The optimisation module  can be implemented in a number of different ways, a few of which will now be described. The schematic block diagrams of  describe hardware implementations of five arrangements.","In this regard it should be noted that, each one of the following first, second, third and fifth arrangements of the optimisation module is intended to be used in conjunction with the pixel compositing module as shown in FIG. A. On the other hand, the fourth arrangement of the optimisation module is intended to be used in conjunction with the pixel compositing module as shown in FIG. B.","Turning now to , there is shown a block diagram of the optimisation module  in accordance with the first arrangement. The optimisation module  takes as input the messages sent by the priority determination module  in sequence and stores them one at a time in an input shift register . These messages may include start pixel, fill priority, end of pixel, and repeat messages etc.  shows, as an example, a fill priority message stored in the input shift register . The optimisation module  also passes these messages to an output shift register , in such a manner that the input and output registers  and  contain the same message at subsequent clock cycles. The output register  outputs all of the messages that are not fill priority messages and only some of the fill priority messages to the fill determination module  as will be explained later. Those fill priority messages that are output from the output shift register  are modified by the addition of two bits called STORE and RESTORE.  shows an example of such a modified fill priority message stored in the output shift register . These STORE and RESTORE bits are initially de-asserted.","As mentioned previously, the fill priority messages are converted to color composite messages in the fill determination module  by the replacement of the fill index and fill type by the corresponding color and opacity values. These color composite messages including the STORE and RESTORE bits are then sent to the pixel compositing module  (FIG. A).","Turning now to , the purpose of the STORE bit, when asserted, is to instruct the pixel compositing module  to store a copy of the top of the stack  in an intermediate-value register  after completion of the compositing operation associated with the fill priority message having the STORE bit. The pixel compositing module  does not store a copy of the stack when the STORE bit is de-asserted. The purpose of the RESTORE bit, when asserted, is to instruct the pixel compositing module  to copy the contents of the intermediate-value register  () to the top of the stack  (FIG. A). The pixel compositing module  does not copy the contents of the intermediate-value register  to the stack when the RESTORE bit is de-asserted.","Returning now to , the optimisation module  comprises a decoder  for decoding the type of stack operation contained in a fill priority message in the input register . Specifically, the decoder  determines whether the stack operation contained in the fill priority message is a NO_POP_DEST or a POP_SRC stack operation. The decoder  is coupled to a counter , and informs the counter when the stack operation is either a NO_POP_DEST or POP_SRC stack operation. The counter  is initialised to one in response to a start of pixel message (not shown) and is incremented for each NO_POP_DEST stack operation, and decremented for each POP_SRC stack operation in the subsequent fill priority messages stored in the input register . The current value of the counter  determines the stack depth of the stack  in the pixel compositing module  that will be produced as a result of executing the determined stack operation of the current fill priority message. It is important to note that the counter  predicts the depth of the stack  that results from the stack operation associated with a current fill priority message before the stack operation of the current fill priority message is actually performed. The counter  does this by keeping a running count of the stack depth produced by the stack operations in the fill priority messages.","The counter  is coupled to a comparator  which detects when the counter  increments\/decrements to one, namely when the predicted stack depth is one. When the comparator  detects that the count is one it asserts a first input to the AND gate .","The optimisation module  also comprises a decoder  for determining whether the message currently being stored in the input register  is a fill priority message, a start of pixel message, or an end of pixel message, etc. Via latch , the decoder  also determines whether the fill priority message currently being stored in the input register  is associated with a first pixel in a run of pixels, and the index to the corresponding record in the combined table  associated with that fill priority message. The decoder  determines this information from the identifier code contained in the messages. For example, each fill priority message contains an identifier code FILL_PRTY for identifying the message as a fill priority message. This code also includes an index LEVEL_INDX to the corresponding record in the combined table , and also a code FIRST_PIXEL indicating whether or not this fill priority message belongs to a first pixel in a run of pixels.","The optimisation module  also comprises a RS latch , which is reset when the decoder  determines that the message stored in the input register  is an end of pixel message. The latch  is set when a x-dependent fill priority message is first encountered in the input register . The latch  when in the reset state asserts the second input to the aforementioned AND gate  and when in the set state de-asserts the second input to the AND gate .","The optimisation module  also comprises a further AND gate  having a first and second input. The first input of the AND gate  is coupled to the output of the AND gate , and the second input is coupled the decoder . The decoder  asserts the second input of the AND gate  when it determines that the fill priority message currently being stored in the input register  is associated with the first pixel in a run of pixels.","The output of the AND gate  is used to set the STORE bit instruction in the fill priority message currently being stored in the output register . In this fashion, the optimisation module  asserts this STORE bit instruction if:","(1) The message in the input and output registers  and  is a fill priority message associated with a first pixel in a run of pixels;","(2) The counter  currently has a count of one and thus the predicted depth of the stack  is one; and","(3) All of the fill priority messages which have been processed so far, including the currently stored fill priority message, since the last end of pixel message have been X-independent.","The optimisation module  also comprises a register  that stores an index of the lowest fill priority message that contributes to the subsequent pixels in the run. It is important to note that the fill priority messages are forwarded to the optimisation module  in bottom to top order. An object's priority designates the location (viz level) of the object in the order of the objects from the rearmost object to the foremost object. The fill priority messages corresponding to each object contributing to a pixel are forwarded to the optimisation module  in rearmost (lowest) to foremost (top) order. The optimisation module  passes to the fill determination module  all fill priority messages associated with a first pixel of a run of pixels, but passes only some of the fill priority messages during the subsequent pixels during that run. Specifically, the same subgroup of fill priority messages, of the group of fill priority messages passed during the first pixel of the run of pixels, is passed during each subsequent pixel of the run. The register  stores the index to the record in the combined table  that corresponds to the lowest fill priority message of this subgroup sent during subsequent pixels in the run.","The storage of this index in the register  is achieved in the following manner. The decoder  decodes the identifier message stored in the input register  and if it is a fill priority message obtains from this identifier the level index LEVEL_INDX of the record in the combined table  associated with the fill priority message. This level index LEVEL_INDX is sent to an input of the register . If the output of the AND gate  asserts the STORE bit instruction for this fill priority message it also sets the register  to store the level index LEVEL_INDX currently on the register's  input. Thus the register  will have stored therein the level index of the fill priority message currently stored in the input registers  and  that has had its STORE bit instruction asserted. It should be noted that if a further fill priority message is stored in the input and output registers  for a current pixel and that fill priority message has had its STORE bit instruction asserted, then the level index currently stored in the register will be overwritten by the level index associated with the further fill priority message.","On the other hand, if the decoder  identifies that the message in the input register is a start of pixel message and the next message is a fill priority message associated with a first pixel in a run of pixels, then the decoder asserts both inputs of the AND gate , which in turn resets the register .","The circuitry of the optimisation module  described so far is primarily concerned with the setting of the STORE instruction bit associated with a group of one or more fill priority messages associated with the first pixel in the run of pixels. The following description of the optimisation module  is primarily concerned with the setting of the RESTORE instruction bit associated with a subgroup of one or more fill priority messages associated with the subsequent pixels in the run of pixels.","The optimisation module further comprises a comparator  which compares the level index currently stored in the register  with the level index of the fill priority message currently being stored in the input register . In the event the level indices are the same the comparator  asserts a first input to an AND gate . Additionally, if the decoder  determines the fill priority message currently stored in the input register  is associated with a first pixel of a run of pixels, then the decoder  asserts an inverted second input of the AND gate  and thus de-asserts the AND gate . Otherwise, it de-asserts the inverted second input of the AND gate . The AND gate  when asserted will assert the RESTORE bit instruction of the fill priority message currently stored in the output register .","In this fashion, the AND gate  will assert the RESTORE bit instruction if:","(1) The message in the input and output registers  and  is a fill priority message associated with a pixel subsequent to a first pixel in a run of pixels; and","(2) The level index of the fill priority message currently being stored in the input and output registers  and  is equal to the level index of that fill priority message of the first pixel in the run of pixels having the uppermost (foremost) level index that has a STORE bit instruction asserted.","The optimisation module further comprises a further comparator  which compares the level index currently stored in the register  with the level index of the fill priority message currently being stored in the input register . In the event the level index of the fill message currently being stored in the input register  is the same as or greater than the index currently stored in the register , the comparator asserts a first input of an OR gate .","The purpose of the OR gate  is to enable the output of the messages contained in the output register . In this fashion, all fill priority messages that are associated with a pixel subsequent to a first pixel in a run of pixels and whose index is the same as or greater than the index currently stored in the register  will be enabled for output. The enabled fill priority messages are passed to the fill determination module . Any remaining fill priority messages that are not enabled for output are not passed to the fill determination module . Also any non fill priority messages are also enabled for output to the fill determination module .","Returning to the decoder , the decoder  reads the identifier in the message currently being stored in the input register  and determines whether this message is a fill priority message. In the event the message is NOT a fill priority message, the decoder  de-asserts an inverted input of the OR gate , which in turn asserts the OR gate  which in turn enables the output of the message contained in the output register . In this fashion all messages that are not fill priority messages are enabled for output and passed to the fill determination module .","Similarly, in the event the decoder  determines that the message currently being stored in the input register  is a fill priority message associated with a first pixel of a run of pixels, the decoder asserts another input of the OR gate . The OR gate  is asserted and in turn enables the output of the message contained in the output register . In this fashion all fill priority messages that are associated with a first pixel in a run of pixels are enabled for output and passed to the fill determination module .","The operation of the optimisation module  is now described with reference to FIG. .","At the start of a pixel run, the counter  is set to 1, the latch  is reset, and the register  is reset to zero.","As each fill priority message for the pixel run passes through the optimisation module , the stack operation is decoded by the decoder . If the stack operation is NO_POP_DEST, the counter  is incremented because the operation will increase the depth of the stack  by one when performed by the pixel compositing module . If the stack operation is POP_SRC, the counter  is decremented because such an operation decreases the stack depth by one. Otherwise, no action is taken by the counter . Also the X-independent flag is checked, and if de-asserted, the latch  is asserted. The latch  remains asserted until the end of pixel message is encountered.","On the first pixel of a run, as each fill priority message passes out of the optimisation module , the STORE bit is asserted for operations where the stack depth counter is equal to 1, and the X-dependent latch  is de-asserted. When the STORE bit is asserted, the register  containing the index of the last stored level, is overwritten with the current level's index.","When the STORE bit is asserted in a fill priority message and the message is passed via the fill determination module  to the pixel compositing module  as a color composite message, it causes the pixel compositing module  to store, into the intermediate-value register , the value on top of the compositing stack after the operation has been performed. Thus, the last stored value will be the last value on a 1-deep stack in the pixel compositing module  prior to the first operation with X-dependent data. Also, if the STORE bit has been asserted for an operation, the level index of the next contributing operation is saved in the register .","When all of the fill priority messages have been passed to the downstream modules (indicated by an end of pixel message), the latch  is reset.","On pixels subsequent to a first pixel in a run of pixels, if the fill priority message associated with a subsequent pixel has an index greater than or equal to the index stored in the register , then the fill priority message is passed to the fill determination module . However, if the index of the fill priority message is less than the index currently stored in the register , then the fill priority message is not passed to the fill determination module . In addition, if the fill priority message is equal to the index stored in the register  then the optimisation module  asserts a RESTORE bit in the fill priority message prior to passing this message to the fill determination module . This RESTORE bit instructs the pixel compositing module  to copy the contents of the intermediate-value register  () to the top of the stack  (FIG. A).","The hardware arrangement of  manipulates the STORE and RESTORE bits of the fill priority messages. The components that act on the STORE bit may be regarded as a first functional unit, and the components that act on the RESTORE bit may be regarded as a second functional unit.","Turning now to  there is shown a comparison between an exemplary original sequence of fill priority messages for a first pixel in a run of pixels and the optimised sequence of fill priority messages for subsequent pixels optimised by the optimisation module  in accordance with the first arrangement.",{"@attributes":{"id":"p-0295","num":"0336"},"figref":"FIG. 30A","b":["3001","3008","550","500","550"]},"The optimisation module  passes all of the fill priority messages for the first pixel in the run to the fill determination module . In addition, it adds two extra bits STORE and RESTORE. During the first pixel in the run, the optimisation module asserts the STORE bit if the counter  currently has a count of one and thus the predicted depth of the stack  is one; and all of the fill priority messages which have been processed so far for the current pixel, including the current fill priority message, are X-independent.","Turning now to , the fill priority messages - of the first pixel in the run are sent to and passed by the optimisation module  in order from the rearmost to the topmost priority order. Namely, the fill priority messages - are sent to and passed by the optimisation module  in the following order , , , , , , , . It can thus been seen that the counter  has a count of 1, 2, 2, 1, 2, 2, 1, 1 for fill priority messages - respectively. Also, the fill priority messages - meet the criteria that all of the fill priority messages processed so far including the current fill message are X-independent. Thus the STORE bit will be asserted for fill messages  and . The RESTORE bit is de-asserted for all fill messages - associated with the first pixel in the run.","These fill priority messages - associated with the first pixel in the run are passed to the fill determination module  and converted to color composite messages and then sent to the pixel compositing module . The pixel compositing module  upon receipt of a color composite message having a STORE bit asserted will copy the top of the stack  to an intermediate-value register  after the compositing operation of the pixel compositing message has been completed. In the event a sequence of color composite messages are received each having their STORE bit asserted, the pixel compositing module  will overwrite a previous value stored in the intermediate-value register with the copy of the stack  associated with a subsequent color composite message. In this particular example, the intermediate-value register  will contain a copy of the top of the stack  that results after the completion of the compositing operation associated with the fill priority message .","Turning now to , there is shown the fill priority messages that are passed by the optimisation module  during each pixel that is subsequent to the first pixel in the run. Firstly, it should be noted that the register  () after the sending of the fill priority messages of the first pixel in the run contains the level index of the fill priority message . Consequently, the output of the shift register  is enabled for sending fill priority messages for subsequent pixels in the run only when the index of these fill priority messages have an index greater than or equal to the index stored in the register . Thus the optimisation module  in this particular example will pass only fill priority messages - for subsequent pixels in the run. The optimisation module  also asserts the RESTORE bit instruction of the fill priority message  as the level index of this instruction is equal to the level index stored in the register  (FIG. ). The STORE bit instruction is de-asserted for all fill priority messages associated with pixels subsequent to the first pixel in the run.","It should be noted that the optimisation module  manipulates only the STORE and RESTORE bits of the fill priority messages, it leaves the other fields of the fill priority messages unchanged.","These fill priority messages - are passed by the optimisation module  for each pixel subsequent to the first pixel in the run to the fill determination module . The fill determination converts these fill priority messages to corresponding color composite messages and then sent to the pixel compositing module . The pixel compositing module  upon receipt of a color composite message (eg. ) having a RESTORE bit asserted will copy the color and opacity value stored in the intermediate-value register  to the top of the stack. The pixel compositing module  then proceeds in the usual fashion according to the instructions contained in the color composite messages corresponding to the fill priority messages -.","It can thus be seen the resultant color and opacity of a group of X-independent compositing operations may been completed and stored during a first pixel in the run and retrieved for use during subsequent pixels in the run.","Turning now to , there is shown a block diagram of the optimisation module  in accordance with the second arrangement, which implements another approach to that of the first arrangement.","The optimisation module  in accordance with the second arrangement passes the fill priority messages and sets the RESTORE bit instruction in the fill priority messages in substantially similar manner as the first arrangement and that part of the module will not be described in any detail. In this regard, those parts of the second arrangement having the same reference numerals as the first arrangement operate in the same manner as the first arrangement. Moreover, the pixel compositing module  used in conjunction with both these first and second arrangements has the same functionality and operates in the same manner.","The optimisation module  in accordance with the second arrangement asserts the STORE bit instruction in the fill priority messages in a different manner to that of the first arrangement. In this case, the decoder  determines whether the stack operation in the fill priority message currently stored in the input register  is a NO_POP_DEST and if this is the case asserts a first input of an OR gate . The optimisation module  also feeds the state of the x-independent flag of the fill priority message to an inverted input of the OR-gate . The output of the OR-gate  is fed to an S input of an RS latch . In addition, an END_OF_PIXEL message from decoder  is fed to an R input of the RS latch . The {overscore (Q)} output of the latch  is fed to one input of an AND gate , and the decoder  also feeds an FIRST_PIXEL message to the other input of the AND gate .","Thus in this arrangement, the latch  is initially de-asserted at the start of the pixel, and the first time a NO_POP_DEST stack operation, or a X-dependent operand is encountered in a fill priority message during the pixel, then the latch  is asserted. If the latch  is not asserted and the pixel is a first pixel in the run then the STORE bit is asserted and the register  is set. When the latch  is asserted for the first pixel in the run it remains asserted for that pixel and no longer sets the STORE bit, and the register  for that first pixel in the run.","In this second arrangement, the determination of the STORE and RESTORE bit instructions differ from the determination of the STORE and RESTORE bit instruction in the first arrangement. Consequently, the fill priority messages that are passed by the optimisation module  in accordance with the second arrangement during subsequent pixels can differ from the first arrangement.","Turning now to  there is shown a comparison between an exemplary original sequence of fill priority messages for a first pixel in a run of pixels and the optimised sequence of fill priority messages for subsequent pixels optimised by the optimisation module  in accordance with the second arrangement.","Turning now to , the fill priority messages - of the first pixel in the run are sent to and passed by the optimisation module  in order from the rearmost to the topmost priority order. Namely, the fill priority messages - are sent to and passed by the optimisation module  in the following order , , , , , , , and . It can thus been seen that the STORE bit instruction will be asserted for those fill priority messages first in the priority order that are X-independent and that do not contain a NO_POP_DEST stack operation. Once a NO_POP_DEST stack operation or an X-dependent operand of a fill priority message is encountered the associated STORE bit is de-asserted and the STORE bits are de-asserted for the remaining fill priority messages in the priority order. Thus the STORE bit will be asserted for fill messages  and . The RESTORE bit is de-asserted for all fill messages - associated with the first pixel in the run.","Turning now to , there is shown the fill priority messages that are passed by the optimisation module  during each pixel that is subsequent to the first pixel in the run. Firstly, it should be noted that the register  () after the sending of the fill priority messages of the first pixel in the run contains the level index of the fill priority message . Consequently, the output of the shift register  is enabled for sending fill priority messages for subsequent pixels in the run only when the index of these fill priority messages have an index greater than or equal to the index stored in the register . Thus the optimisation module  in this particular example will pass only fill priority messages - for subsequent pixels in the run. The optimisation module  also asserts the RESTORE bit instruction of the fill priority message  as the level index of this instruction is equal to the level index stored in the register  (FIG. ). The STORE bit instruction is de-asserted for all fill priority messages associated with pixels subsequent to the first pixel in the run.","In this fashion, the resultant color and opacity of a group of X-independent compositing operations can been completed and stored in a register in the pixel compositing module during a first pixel in the run and retrieved for use during subsequent pixels in the run.","Another alternative is to store the state of the whole stack when the X-independent operation is encountered, and restore the stack from this store on subsequent pixels in the run. This is less restrictive, although in a hardware implementation it requires a lot of fast on-chip memory or registers.","If enough registers or memory cells are available in the pixel compositing module , then the state of the stack can be saved prior to the first occurrence of an X-dependent operation. This allows a relaxation of the requirement that the stack depth must be one when storage of the state is performed. In this case, the counter in the optimization stage is not required, however the complexity of the pixel compositing module is greatly increased.","Turning now to , there is shown a block diagram of the optimisation module  in accordance with the third arrangement, which implements another approach to that of the first and second arrangements.","The optimisation module  in accordance with the third arrangement passes the fill priority messages and sets the RESTORE bit instruction in the fill priority messages in a substantially similar manner to the first and second arrangements and that part of the module will not be described in any detail. In this regard, those parts of the third arrangement having the same reference numerals as the first arrangement operate in the same manner as the first arrangement.","The optimisation module  in accordance with the third arrangement asserts the STORE bit instruction in the fill priority messages in a different manner to that of the first and second arrangements. In this case, the optimisation module  outputs the x-independent flag of the fill priority messages to an inverted S input of a RS latch  and to a first input of a NOR gate . The Q output of the latch  is fed to a second input of the NOR gate . The decoder  resets the latch  via its R input when an end of pixel message is encountered. In this fashion, the latch  is asserted after it encounters the first x-dependent fill priority message of a pixel and stays asserted until it is reset when the end of pixel is encountered. Thus the STORE bit instruction is asserted when an x-dependent fill priority message associated with a first pixel in a run of pixels is encountered. The latch  is used to ensure that the STORE bit instruction is only asserted once for any pixel run.","In this third arrangement, the determination of the STORE and RESTORE bit instructions differ from the determination of the STORE and RESTORE bit instruction in the first and second arrangement. Consequently, the fill priority messages that are passed by the optimisation module  in accordance with the second arrangement during subsequent pixels can differ from the first and second arrangement.","The pixel compositing module  to be used in conjunction with this arrangement of the optimisation module  is modified to enable the storage of the stack in response to a STORE bit instruction. Specifically the intermediate-value register  is replaced with a set of registers to enable a copy of the stack to be stored in these registers.","When the pixel compositing module  receives a color_composite message (derived from a fill priority message) with the STORE bit instruction asserted, it stores the state of the compositing stack in the set of registers. For each subsequent pixel until the end of the pixel run, the stack is initialised to the saved state, before any compositing operations are performed. Thus, the operations prior to the instruction on which the stack was saved do not need to be performed for subsequent pixels.","If the latch  is asserted and the register  is equal to lowest active level, then such an optimization is not possible. In this case, all of the contributing operations for the pixel run are sent to the downstream modules for each pixel in the run.","Turning now to  there is shown a comparison between an exemplary original sequence of fill priority messages for a first pixel in a run of pixels and the optimised sequence of fill priority messages for subsequent pixels optimised by the optimisation module  in accordance with the third arrangement. In this particular example, it should be noted the fill priority messages for the first pixel in the run () are the same as those shown for in , with the exception of the STORE bit instruction.","Turning now to , the fill priority messages - of the first pixel in the run are sent to and passed by the optimisation module  in order from the rearmost to the topmost priority order. Namely, the fill priority messages - are sent to and passed by the optimisation module  in the following order , , , , , , , . It can thus been seen that the STORE bit instruction will be asserted for the first fill priority message that is encountered that is x-dependent, and no others. Thus the STORE bit will be asserted for fill messages . The RESTORE bit is de-asserted for all fill messages - associated with the first pixel in the run.","Turning now to , there is shown the fill priority messages that are passed by the optimisation module  during each pixel that is subsequent to the first pixel in the run. Firstly, it should be noted that the register  () after the sending of the fill priority messages of the first pixel in the run contains the level index of the fill priority message . Consequently, the output of the shift register  is enabled for sending fill priority messages for subsequent pixels in the run only when the index of these fill priority messages have an index greater than or equal to the index stored in the register . Thus the optimisation module  in this particular example will pass only fill priority messages - for subsequent pixels in the run. The optimisation module  also asserts the RESTORE bit instruction of the fill priority message  as the level index of this instruction is equal to the level index stored in the register  (FIG. ). The STORE bit instruction is de-asserted for all fill priority messages associated with pixels subsequent to the first pixel in the run.","It should be noted that the implementation of the pixel compositing module  used in conjunction with the present arrangement differs from the pixel compositing module  used in conjunction with the first and second arrangements. In the latter, an color composite message (derived from a fill priority message) containing a RESTORE bit instruction will retrieve the contents of the intermediate-value register  of the pixel compositing module  to the stack  and then proceed to implement the compositing operations of the next color composite message. On the other hand, the pixel compositing module  used in conjunction with the third arrangement of the optimisation module  will retrieve the state of the stack in the set of registers to the stack  and then perform the compositing operations associated with the current color compositing message.","It this fashion, the resultant color and opacity of a group of X-independent compositing operations can be completed and stored in a set of registers in the pixel compositing module during a first pixel in the run and retrieved for use during subsequent pixels in the run.","The fourth arrangement of the optimisation module  determines associative compositing operations in the fill priority messages, so that the sequences of associative operations with x-independent color can be optimised into a single operation. Several registers are available to store intermediate data in the pixel compositing module, so that several runs of X-independent operations in a single operation stream may be optimised. In this arrangement, the presence of x-dependent operations does not prevent optimisation of subsequent operations, although the set of optimisable operations is reduced as not all operations are associative, and all operations in a sequence must be identical in order to be optimisable. Nevertheless, the Porter and Duff OVER operation is associative, and in systems where transparency operations are supported, OVER is the most common operation.","If an operation is associative, such that (AopB)opC=Aop(BopC), then the order in which a sequence of such an operations is performed can be altered, so that x-independent operations are performed first: The result of one or more sequences of x-independent operations can then be saved in registers to be used in subsequent pixels. The operator has to be the same for any such run, as while there are many associative operators, they cannot be mixed in general. In order to be optimisable, a run of associative operations must be a full sub-expression, and so it must finish with the same stack depth as it starts.","A comparison is used to identify a particular associative operator, herein denoted ASS_OP, and chosen from the list of possible combinations of alpha and color operators. The ASS_OP operation may be hard-wired, or stored in a register, which allows the software driver to determine which operator is to be used.","Turning now to , there is shown a block diagram of the optimisation module  in accordance with a fourth arrangement. The optimisation module  takes as input the messages sent by the priority determination module  in sequence and stores them one at a time in an input shift register . These messages may include start pixel, fill priority, end of pixel, and repeat messages etc.  shows, as an example, a fill priority message stored in the input shift register . The optimisation module  also passes these messages to an output shift register , in such a manner that the input and output registers  and  contain the same message in sequential clock cycles. The output register  outputs all of the messages that are not fill priority messages and only some of the fill priority messages to the fill determination module  as will be explained latter. Those fill priority messages that are output from the output shift register  are modified by the addition of three bits called STORE, RESTORE, and ACC_EN.  shows an example of such a modified fill priority message stored in the output shift register . The STORE RESTORE, and ACC_EN bits are initially de-asserted.","As mentioned previously, the fill priority messages are converted to color composite messages in the fill determination module  by the replacement of the fill index and fill type by the corresponding color and opacity values. These color composite messages including the STORE, RESTORE and ACC_EN bits are then sent to the pixel compositing module  shown in FIG. B.","Returning now to , the optimisation module  also comprises a decoder , which determines whether the message stored in the input register  is a start_of_pixel, end_of_pixel, or a fill priority message. The decoder  outputs respective binary signals START_OF_PIXEL, END_OF_PIXEL, and FILL_PRTY in response thereto. In the event the message is a fill priority message, the decoder  also determines whether the fill priority message is associated with a first pixel in a run of pixels and outputs a binary signal FIRST_PIXEL. The decoder  also determines the priority level index contained in the fill priority message and outputs data LEVEL_INDX representative of that index.","The optimisation module  further comprises a decoder  coupled to the input register  for decoding the type of stack operation contained in a fill priority message in the input register . Specifically, the decoder  determines whether the stack operation contained in the fill priority message is a NO_POP_DEST or a POP_SRC stack operation.","The decoder  is coupled to a counter , and informs the counter  when the stack operation is either a NO_POP_DEST or POP_SRC stack operation. The counter  is initialised to one in response to a START_OF_PIXEL signal received from the decoder  (not shown). The counter  is then incremented for each NO_POP_DEST stack operation, and decremented for each POP_SRC stack operation in the subsequent fill priority messages stored in the input register . The current value of the counter  determines the stack depth of the stack  in the pixel compositing module  that will be produced as a result of executing the determined stack operation of the current fill priority message. It is important to note that the counter  predicts the depth of the stack  that results from the stack operation associated with a current fill priority message before the stack operation of the current fill priority message is actually performed. The counter  does this by keeping a running count of the stack depth produced by the stack operations in the fill priority messages.","The output of the counter  is coupled to a first input of a comparator . The other input of the comparator  is coupled to a register  which stores a value R of a predetermined stack depth. The counter  increments\/decrements the predicted stack depth in response to a sequence of fill priority messages inputted through the shift register  and the comparator  determines when the predicted stack depth is equal to R. When the predicted stack depth is equal to R the comparator  asserts a first input of an AND gate  and a first input of an AND gate .","The optimisation module also comprises a comparator  having one input coupled to the shift register  and another to the register  for comparing the current color_op and alpha_op operations of the fill priority message currently stored in the shift register  with the color_op and alpha_op operations ASS_OP stored in the register . In the event they are the same, the comparator  asserts a first input of an AND gate .","The AND gate  has two inputs, a first input coupled to the output of the comparator , a second input coupled to the shift register . The shift register  outputs to this second input a binary signal that indicates whether or not the fill priority message currently stored in the register  is x_independent. Consequently, the AND gate  is asserted when the color_op, and alpha_op operations of the fill priority message currently stored in the shift register  are the same as ASS_OP, and the fill priority message is x-independent. The output of the AND gate  is coupled to a first input of an AND gate  and a second input of the AND gate .","The AND gate  has two inputs. As mentioned previously, the first is coupled to the output of the comparator  and the second input is coupled to the output of the AND gate . Thus, the AND gate  is asserted when the color_op, and alpha_op operations of the fill priority message currently stored in the shift register  are the same as ASS_OP, the fill priority message is x-independent, and the predicted stack depth equals R. The output of the AND gate  is coupled to the S input of an RS latch  and a first input of an OR gate .","The R input of the RS latch  is coupled to that output of the decoder  that outputs the end of pixel message END_OF_PIXEL. Thus the latch  is reset at the end of each pixel and set when the optimisation module  first encounters for the next pixel an x-independent fill priority message having color op, and alpha op operations the same as ASS_OP, and where the predicted stack depth equals R. The Q output of the latch  is coupled to a first input of an AND gate , and the {overscore (Q)} output of the latch  is coupled to a first input of the OR gate .","The optimisation module  comprises a further comparator  coupled to the shift register  for determining whether the compositing operation is a true push operation. Specifically, the comparator  determines whether\n\n","The OR gate  has two inputs, the first input of which is coupled to the output of the AND gate  and the second input of which is coupled to the comparator . The optimisation module  further comprises an OR gate  having two inputs, one input coupled to the {overscore (Q)} output of the latch , and the other input coupled to the output of the OR gate . The output of the OR gate  is coupled to an inverted S input of a further latch . The R input of the RS latch  is coupled to that output of the decoder  that outputs the end of pixel message END_OF_PIXEL.","Thus the {overscore (Q)} output of the latch  is forcibly asserted until a sequence of associative, x-independent fill priority messages having a stack depth of R is first encountered and then is de-asserted when the first non-associative, x-dependent fill priority message having an associated predicted stack depth of R is encountered.","The {overscore (Q)} output of the latch  is coupled to a second input of the AND gate , the output of which in turn is coupled to a second input of the AND gate .","Thus in this fashion the STORE bit instruction is asserted if:","(1) The message in the input and output registers  and  is a fill priority message associated with a first pixel in a run of pixels;","(2) The message has a predicted stack depth of R; and","(3) The message is one of a sequence of fill priority messages that are x-independent, have a color_op, and alpha_op operation the same as that of ASS_OP. However, in one special exception, the sequence may include a fill priority message, subsequent to the first fill priority message in the sequence, where the message has operators STACK_OP=NO_POP_DEST && COLOR_OP=LCO_COPYPEN && LAO_USE_SOUTD=SET && LAO_USE_SROPD=SET. This special fill priority message comprises a combination of operators that produce a pure stack push of a source value and may be included in the sequence of fill priority messages, which have their STORE bits asserted. The sequence ends when a fill priority message is encountered that has an x-dependent value or non-associative operator, irrespective of the stack depth.","Returning now to , the Q output of the RS latch  is coupled to the AND gate . The AND gate  has two inputs, the other one of which is coupled to that output of the decoder  outputting the binary signal FIRST_PIXEL. Thus the AND gate  and the ACC_EN instruction bit are asserted when the fill priority message is the first x-independent fill priority message associated with a first pixel in a run of pixels that has an associative operator ASS_OP and a predicted stack depth of R. When the run of subsequent fill priority messages ends, either because the x-dependent fill priority messages are encountered or because a non-associative operation is encountered, the latch  is disabled and consequently the ACC_EN instruction bit is de-asserted.","The optimisation module  further comprises a register  having a data line coupled to the LEVEL_INDX output of the decoder , a write enable line coupled to the output of the AND gate , and a reset line coupled to the AND gate . The AND gate  has two inputs coupled respectively to the outputs of the decoder  outputting the START_OF_PIXEL and FIRST_PIXEL messages. When the decoder  encounters a START_OF_PIXEL message and subsequent FIRST_PIXEL message, the AND gate  is asserted and the register  is set to Null. When the AND gate  is asserted the level index of the fill priority message currently stored in the shift register  is stored in the register . In this fashion, the register  contains the level index of the first x-independent fill priority message associated with a first pixel in a run of pixels that has an associative operator ASS_OP and a predicted stack depth of R. Namely, the register  contains the level index of the first fill priority message in the sequence having its STORE instruction bit asserted.","The optimisation module  further comprises a register  having a data line coupled to the LEVEL_INDX output of the decoder , a write enable line coupled to the output of the AND gate , and a reset line coupled to the AND gate . When the decoder  encounters a START_OF_PIXEL message and subsequent FIRST_PIXEL message, the AND gate  is asserted and the register  is set to Null. When the AND gate  is asserted the level index of the fill priority message currently stored in the shift register  is stored in the register . In this fashion, the register  contains the level index of the last fill priority message in the sequence having its STORE instruction bit asserted. The AND gate  has two inputs, the FIRST_PIXEL output of decoder  and the output of AND gate .","The optimisation module  further comprises a comparator . The comparator  comprises one input coupled to the level register  and another input coupled to that output of the decoder  that outputs the LEVEL_INDX signal. The comparator compares the level index LEVEL_INDX of the fill priority message currently stored in the shift register  and the level index currently stored in the register . In the event that these level indices are the same, the comparator  asserts a first input of the AND gate . The second (inverted) input of the AND gate  is the FIRST_PIXEL output of the decoder . The output of AND gate  asserts the RESTORE bit of register . Thus the RESTORE bit is asserted when the current bit is not the first pixel of a run and the output of comparator  is asserted.","The optimisation module  also comprises a comparator . The comparator  comprises one input coupled to the output decoder  that outputs the LEVEL_INDX of the fill priority message currently stored in the shift register . The comparator  also comprises another input coupled to the register . The comparator  compares the level index LEVEL_INDX of the fill priority message currently stored in the shift register  and the level index currently stored in the register . In the event that the level index of the fill priority message currently stored in the shift register  is less than or equal to the level index stored in the register , the comparator  asserts an OR gate .","The optimisation module  comprises a still further comparator . The comparator  comprises one input coupled to the output decoder  that outputs the LEVEL_INDX of the fill priority message currently stored in the shift register . The comparator  also comprises another input coupled to the register . The comparator  compares the level index LEVEL_INDX of the fill priority message currently stored in the shift register  and the level index currently stored in the register . In the event that the level index of the fill priority message currently stored in the shift register  is greater than or equal to the level index stored in the register , the comparator  asserts the OR gate .","The OR gate  comprises four inputs, a first inverted input to the output of decoder  that outputs the FILL_PRTY binary signal, and second, third and fourth inputs coupled to the comparators , , and  respectively. The purpose of the OR gate  is to enable the output of the messages contained in the output shift register . In this fashion, all fill priority messages of pixels subsequent to the first pixel in the run that have an level index greater than or equal to the level index stored in the register  or have a level index less than or equal to the level index stored in the register  will be enabled for output. The enabled fill priority messages are passed to the fill determination module . Any remaining fill priority messages that are not enabled for output are not passed to the fill determination module . Also, any non-fill priority messages are also enabled for passing to the fill determination module .","A description of the operation of the optimisation module  in accordance with the fourth arrangement now follows. When the first fill priority message, for the first pixel in the run having an x-independent associative operation is encountered, an accumulator  in the pixel compositing module  () is enabled, and loaded with the color value. If the subsequent levels contain x-independent, associative operations, then the operation is performed on the accumulated value, as well as on the main stack . The accumulator value is stored to a temporary register in the accumulator unit  of the pixel compositing module  () if the stack depth is identical to the original stack depth of the first associative operation.","When the run ends, either because x-dependent fill data is encountered, or because a non-associative operation is encountered, the accumulator mechanism  of the pixel compositing module  () is disabled. The last stored accumulator value may, on subsequent pixels, be used to replace the operations between the last stored level and the start of the pixel. Thus, when generating fill priority messages for the fill color determination module  on subsequent pixels, an instruction to restore this value from the accumulator unit  is used in place of the sequence of instructions, which has been optimized away. This restore instruction is included in the color composite message, and passed through to the pixel compositing module  (FIG. B), where the restored value is composited into the pixel using the associative operation that was identified by the decoder.","An associative operator may be identified from its code, or by adding a flag to each level in the priority determination module , indicating the presence of an associative operator on that level. The second option allows a software program more flexibility in identifying runs of associative operators when constructing the priority determination table, allowing different operations to be optimized, provided software can identify that the groups of objects being optimized are disjoint.","At some cost in complexity, it is possible to store several runs of associative operations on each pixel: it is simply a matter of providing enough registers to store the intermediate values for each run, and providing a counter, incremented when each run is identified, so that the register into which accumulated data is stored can be determined. In a real-world environment, however, this is unlikely to be required often enough to be worth the extra hardware cost.","Turning now to  there is shown a comparison between an exemplary original sequence of fill priority messages for a first pixel in a run of pixels and the optimised sequence of fill priority messages for subsequent pixels optimised by the optimisation module  in accordance with the fourth arrangement.",{"@attributes":{"id":"p-0359","num":"0404"},"figref":"FIG. 33A","b":["3301","3308","550","500","550"]},"The optimisation module  passes all of the fill priority messages for the first pixel in the run to the fill determination module . In addition, it adds three extra bits STORE, ACC_EN and RESTORE. During the first pixel in the run, the optimisation module  asserts the STORE bit if the message is one of a sequence of messages that are x-independent fill priority messages having associative ASS_OP operators, and is associated with a stack depth of R (which in this particular example is set to 1). The sequence ends when a fill priority message is encountered that has a x-dependent value or non-associative value. However, in one special exception, the sequence may include a fill priority message, subsequent to the first fill priority message in the sequence, where the message has operators STACK_OP=NO_POP_DEST && COLOR_OP=LCO_COPYPEN && LAO_USE_SOUTD=SET && LAO_USE_SROPD=SET. This special fill priority message comprises a combination of operators that produce a pure stack push of a source value and may be included in the sequence of fill priority messages which have their STORE bits asserted.","Turning now to , the fill priority messages - of the first pixel in the run are sent to and passed by the optimisation module  in order from the rearmost to the topmost priority order. Namely, the fill priority messages - are sent to and passed by the optimisation module  in the following order , , , , , , , . It can thus been seen that the counter  has a count of 1, 1, 1, 1, 2, 2, 1, 1 for fill priority messages - respectively. Also, the fill priority messages - are X-independent, and the fill priority messages -, ,  are associative ASS_OP. Thus the sequence of fill priority messages having their STORE bit asserted is -, . It should be noted that even though the fill priority message  is a special exception fill priority message, and the fill priority message  is associative ASS_OP, the fill priority messages ,  have associated therewith a stack depth of two and thus will not have their STORE instruction bit asserted. Furthermore, the sequence of fill priority messages having their STORE bit asserted finishes at the x-dependent fill priority message . It can also be seen that the ACC_EN bit instruction is asserted for the first fill priority message in the sequence having its STORE bit instruction asserted (viz ) and continues for the rest of the fill priority messages associated with the first pixel in the run. The RESTORE bit is de-asserted for all fill messages - associated with the first pixel in the run.","Turning now to , there is shown the fill priority messages that are passed by the optimisation module  during each pixel that is subsequent to the first pixel in the run. Firstly, it should be noted that the register  (FIG. ), after the sending of the fill priority messages of the first pixel in the run, contains the level index of the fill priority message . Also, it should be noted that the register  (FIG. ), after the sending of the fill priority messages of the first pixel in the run, contains the level index of the fill priority message . Consequently, the output of the shift register  is enabled for sending fill priority messages for subsequent pixels in the run only when the index of these fill priority messages have an index greater than or equal to the index stored in the register , or have an index less than or equal to the index stored in the register . Thus the optimisation module  in this particular example will pass only fill priority messages , , and  for subsequent pixels in the run. The optimisation module  also asserts the RESTORE bit instruction of the fill priority message  as the level index of this instruction is equal to the level index stored in the register  (FIG. ). The STORE bit instruction is de-asserted for all fill priority messages associated with pixels subsequent to the first pixel in the run.","It should be noted that the optimisation module  manipulates only the STORE, ACC_EN and RESTORE bits of the fill priority messages, it leaves the other fields of the Fill priority messages unchanged.","These fill priority messages ,  and  are passed by the optimisation module  for each pixel subsequent to the first pixel in the run to the fill determination module . The fill determination converts these fill priority messages to corresponding color composite messages and then sent to the pixel compositing module .","It can thus be seen the resultant color and opacity of a group of X-independent compositing operations may be completed and stored during a first pixel in the run and retrieved for use during subsequent pixels in the run.","The optimisation module  in accordance with a fifth arrangement is concerned with operations that can be written as an expression tree (that is, where the destination is not duplicated into a branch of the tree). In this situation, the pixel compositing module () is adapted to store, into a register, the result of a branch of the tree, which is X-independent, and on subsequent pixels, restore the branch from the register. The presence of X-dependent data in one branch of a node in the tree triggers optimisation of the other branch. Note that if both branches of a node are X-independent, a better optimisation is available further up the tree, while if both branches of a node are X-dependent no optimisation is possible for that node.","If the graphic description of a run of pixels can be written in expression-tree form, then where a branch of the tree is X-independent, that branch can be calculated once, and the result of this calculation used in place of the branch on subsequent pixels in the run. More generally, if all of the operations between a PUSH operation, and the corresponding POP_SRC operation which combines the result of these operations with the pushed value, are\n\n","Turning now to , there is shown a block diagram of the optimisation module  in accordance with the fifth arrangement. The optimisation module  shown is for a stack depth N. The hardware requires duplication for each possible stack depth, because operations involving pushed values on one level do not affect the pushed values further down the stack. Such an operation on a higher level of the stack, therefore, does not preclude the optimisation of X-independent data at a lower stack depth.","The optimisation module  takes as input the messages sent by the priority determination module  and stores them in the input and output shift registers  and  in similar fashion to the input and output registers described in relation to the previous arrangements. The fill priority messages that are output from the output shift register  are modified by the addition of a series of bits STORE_, STORE_, . . . , STORE_N and a series of bits RESTORE_, RESTORE_, . . . , RESTORE_N.",{"@attributes":{"id":"p-0370","num":"0417"},"figref":["FIG. 29","FIG. 29","FIG. 29"],"b":["2948","550"]},"The purpose of the STORE_x and RESTORE_x instruction bits is similar to that described previously with respect to the first and second arrangements. However, the difference is that an x-independent branch of the expression tree may be calculated once and stored in the intermediate register  () by means of the STORE_x instruction bit and retrieved for use in compositing operations during subsequent pixels by means of the RESTORE_x instruction bit.","Returning now to , the optimisation module  also comprises a decoder , which determines whether the message stored in the input register  is a start_of_pixel, end_of_pixel, or an fill priority message, and outputs respective binary signals START_OF_PIXEL, END_OF_PIXEL, and FILL_PRTY in response thereto. In the event the message is a fill priority message, the decoder  also determines whether the fill priority message is associated with a first pixel in a run of pixels and outputs a binary signal FIRST_PIXEL, and determines the priority level index contained in the fill priority message and outputs data LEVEL_INDX representative of that index.","The optimisation module  further comprises a decoder  coupled to the input register  for decoding the type of stack operation contained in a fill priority message in the input register . Specifically, the decoder  determines whether the stack operation contained in the fill priority message is a NO_POP_DEST or a POP_SRC stack operation.","The decoder  is coupled to a counter , and informs the counter when the stack operation is either a NO_POP_DEST or POP_SRC stack operation. The counter  is initialised to one in response to a START_OF_PIXEL signal received from the decoder  (not shown). The counter  is then incremented for each NO_POP_DEST stack operation, and decremented for each POP_SRC stack operation in the subsequent fill priority messages stored in the input register . The current value of the counter  determines the stack depth of the stack  in the pixel compositing module  that will be produced as a result of executing the determined stack operation of the current fill priority message. It is important to note that the counter  predicts the depth of the stack  that results from the stack operation associated with a current fill priority message before the stack operation of the current fill priority message is actually performed. The counter  does this by keeping a running count of the stack operations of the fill priority messages.","The counter  is coupled to a comparator  which detects when the counter  increments\/decrements to a predetermined stack depth N, namely when the predicted stack depth is N. The output of the comparator  is coupled to a first input of an AND gate , which will be discussed below. The counter  is also coupled to a comparator  which detects when the predicted stack depth is greater than N.","When the comparator  detects that the count is equal to N it asserts a first input of an AND gate . In addition, when the decoder  detects that the stack operation is a POP_SRC operation it asserts a second input of the AND gate . Thus the AND gate  will be asserted when the count=N and the current stack operation is POP_SRC.","The optimisation module further comprises a RS latch , which is reset via the R input by the END_OF_PIXEL signal (obtained from the decoder ) and is set via the S input by the AND gate . Thus the Q output of the RS latch  will always be de-asserted until N first decrements to stack depth N. The Q output of the RS latch  is coupled to an inverted second input of an AND gate .","The optimisation module  also comprises a decoder  that determines whether the compositing operation of the fill priority message in the input register  belongs to a branch that is a valid branch in an expression tree. It does this by generating a binary signal\n\n","INVOLVES_PUSHED=FALSE (zero) for","(STACK_OP=NO_POP_DEST) && (COLOR_OP=LCO_COPYPEN)\n\n","(STACK_OP=STD_OP)\n\n","(STACK_OP=POP_SRC)","In the case where the binary signal INVOLVES_PUSHED is false (zero) then the branch is a valid branch and thus may be suitable for optimisation, otherwise the branch is invalid and not suitable for optimisation.","The decoder  is coupled to and supplies the INVOLVES_PUSHED signal to a first input of an AND gate . In addition, the comparator  is coupled to an inverted second input of the AND gate . Thus the AND gate  is asserted when INVOLVED_PUSHED=TRUE and the count <=N. The output of the AND gate  is coupled to an inverted first input of an AND gate . In addition, the AND gate  has a second input coupled to the shift register . The AND gate  is asserted when the fill priority message stored in the input register is x_independent and the following condition is not true: INVOLVED_PUSHED=TRUE and the count <=N. The output of the AND gate is coupled to a third input of the AND gate .","The optimisation circuit  also comprises a RS latch  having a reset input R and an inverted set S input. The RS latch  is reset via the R input by an OR gate  and is set via the inverted S input by the AND gate . A first input of the OR gate  is coupled to the output of the comparator  and a second input of the OR gate  is coupled to the decoder . The OR gate  is asserted when either the message stored in the input register  is an end_of_pixel message or the count=N. Thus the latch  is set when the fill priority message is x-dependent and INVOLVED_PUSHED=TRUE and the count <=N. The {overscore (Q)} output of the latch  is coupled to a fourth input of the AND gate . In addition, the AND gate  also has a fifth input coupled (not shown) to the decoder , wherein the binary signal FIRST_PIXEL is fed to the fifth input.","In this fashion, the optimisation module  asserts this STORE_N bit instruction if:","(1) The message in the input and output registers  and  is a fill priority message associated with a first pixel in a run of pixels;","(2) The counter  currently has a count of N and thus the predicted depth of the stack  is N;","(3) (a) The fill priority message in registers  and  is the first fill priority message encountered so far since the last end of pixel message that is X-independent, or if not,\n\n","(4) The stored fill priority message is part of a valid branch viz (ie. INVOLVES_PUSHED=FALSE).","The optimisation module  also comprises an AND gate  having a first input coupled to the AND gate  and a second input coupled to an output of the decoder  outputting the FIRST_PIXEL signal. The AND gate  is asserted when the message contained in the shift registers  and  is a fill priority message of a first pixel in a run of pixels and the STORE_N bit instruction for that fill priority message is asserted.","The optimisation module  further comprises a register  having a data input line coupled to that output of the decoder  that outputs the LEVEL_INDX data, a write enable line coupled to the output of the AND gate , and a reset line coupled to the AND gate . The AND gate  has two inputs coupled respectively to the outputs of the decoder  outputting the START_OF_PIXEL and FIRST_PIXEL messages. When the decoder  encounters a START_OF_PIXEL and a subsequent FIRST_PIXEL message, the AND gate  is asserted and the register  is set to Null. Furthermore, the register  stores the LEVEL_INDX data of the fill priority message stored in the shift registers  and  when the AND gate  is asserted. Thus the register  at any one time stores the LEVEL_INDX of the last fill priority message that had its STORE_N bit instruction asserted.","The optimisation module  also comprises an AND gate  having a first input coupled to the AND gate  and a second input coupled to the comparator . The AND gate  is asserted when the STORE_N bit instruction bit is asserted.","The optimisation module  further comprises a register  having a data input coupled to that output of the decoder  that outputs the LEVEL_INDX data. The register  is also coupled to that output of the AND gate  which resets the register  to Null when a START_OF_PIXEL signal and a subsequent FIRST_PIXEL signal is encountered. The register  stores the LEVEL_INDX data currently output when the AND gate  is asserted. In this fashion, the register  stores the LEVEL_INDX data of that fill priority message of the first pixel in the run that has the first STORE BIT instruction bit asserted. Namely, the register  stores the level index of the last fill priority message that had its STORE_N bit asserted, whereas the register  stores the level index of the first fill priority message that had its STORE_N bit asserted for the first pixel in the run.","The optimisation module  further comprises a comparator . The comparator  comprises one input coupled to the level register  and another input coupled to that output of the decoder  that outputs the LEVEL_INDX signal. The comparator compares the level index LEVEL_INDX of the fill priority message currently stored in the shift register  and the level index currently stored in the register . In the event that these level indices are the same, the comparator  asserts a first input of the AND gate .","The AND gate  also comprises an inverted second input coupled to that output of the decoder  outputting the FIRST_PIXEL signal. Thus the AND gate  asserts the RESTORE_N bit instruction for that fill priority message subsequent to the first pixel in the run of pixels that has a level index the same as the level index currently stored in the register .","The optimisation module  also comprises a comparator . The comparator  comprises one input coupled to the output decoder  that outputs the LEVEL_INDX of the fill priority message currently stored in the shift register . The comparator  also comprises another input coupled to the register . The comparator  compares the level index LEVEL_INDX of the fill priority message currently stored in the shift register  and the level index currently stored in the register . In the event that the level index of the fill priority message currently stored in the shift register  is greater than or equal to the level index stored in the register , the comparator  asserts an OR gate , which in turn asserts an OR gate .","The optimisation module  comprises a still further comparator . The comparator  comprises one input coupled to the output decoder  that outputs the LEVEL_INDX of the fill priority message currently stored in the shift register . The comparator  also comprises another input coupled to the register . The comparator  compares the level index LEVEL_INDX of the fill priority message currently stored in the shift register  and the level index currently stored in the latch . In the event that the level index of the fill priority message currently stored in the shift register  is less than or equal to the level index stored in the register , the comparator  assert the OR gate , which in turn asserts an OR gate .","The OR gate  comprises three inputs a first input coupled to the OR gate , a second input to the output of decoder  that outputs the FIRST_PIXEL signal and a third inverted input coupled to the output of the decoder  that outputs the FILL_PRTY signal. The purpose of the OR gate  is to enable the output of the messages contained in the output register . In this fashion, all fill priority messages of pixels subsequent to the first pixel in the run that have an level index greater than or equal to the level index stored in the register  or have a level index less than or equal to the level index stored in the register  will be enabled for output. The enabled fill priority messages are passed to the fill determination module . Any remaining fill priority messages that are not enabled for output are not passed to the fill determination module . Also, any non-fill priority messages are also enabled for passing to the fill determination module .","The operation of the optimisation module in accordance with the fifth arrangement will now be described. As the fill priority messages for the first pixel are processed, the counter  is used to monitor the stack depth, and the comparator  output is enabled when the stack depth is equal to N. The stack operation and the graphic operation are decoded by the decoder  to determine whether the stack operation involves the pushed value (ie. INVOLVES_PUSHED=FALSE). The resulting STORE_N bit instruction is disabled when the stack depth is greater than N, so that X-independent data at higher stack depths may be optimised away when the stack depth drops back to N.","The STORE_N signal starts being asserted, and continues being asserted when the color values are x-independent, and no operation involving a pushed value at a predicted stack depth<N is encountered. If the predicted stack depth increases above N, the storage is disabled but may be enabled again if neither of the above conditions occurs. Also, the priority level when the STORE_N signal starts being asserted is stored in the register  and the priority level when the STORE_N signal is de-asserted is stored in a register .","The STORE_N signal causes the value on top of the stack  to be stored in the intermediate-value register  (see ) at level N. The intermediate-value register  in accordance with the present arrangement comprises one entry for each stack depth N. As will become apparent, when there is no STORE_X signal for a particular level x, there will be no value stored in the entry of the register  at level x.","The STORE_N signal is latched by REG_N_USED latch  to indicate the presence of a stored value for the level. So that when a fill priority message with POP_SRC is next encountered with stack depth=N, the REG_N_USED latch  disables storage in the register for level N by disabling STORE_N, and the last value prior to the POP_SRC cannot be over-written. The first fill priority message having its STORE_x bit instruction bit asserted is indicated by the presence of level data in the register , the last fill priority message having its STORE_x bit instruction asserted is indicated by the presence of level data in the register . For subsequent pixels, the result of the fill priority messages between these first and the last fill priority message may be replaced with the value stored in intermediate-value register  at level N. Thus, when generating compositing instructions for the compositing module on subsequent pixels, an instruction to restore this value from the intermediate-value register  for level N is used in place of the sequence of fill priority messages, which have been optimised away. The stored value is pushed onto the stack before the color, opacity and stack operations are performed.","Turning now to  there is shown a comparison between an exemplary original sequence of fill priority messages for a first pixel in a run of pixels and the optimised sequence of fill priority messages for subsequent pixels optimised by the optimisation module  in accordance with the fifth arrangement.",{"@attributes":{"id":"p-0405","num":"0456"},"figref":"FIG. 34A","b":["3401","3410","550","500","550"]},"The optimisation module  passes all of the fill priority messages for the first pixel in the run to the fill determination module . In addition, it adds six extra bits STORE_, STORE_, STORE_ and RESTORE_, RESTORE_, RESTORE_ (the latter three not shown in FIG. A and the former three not shown in FIG. B). The STORE_, STORE_, and STORE_ bit instructions correspond to duplicate circuits where the counter  has initialised stack depth of one, two and three respectively. Similarly for the RESTORE_x bit instructions.","During the first pixel in the run, the optimisation module asserts the STORE_N bit () in accordance with the aforementioned test condition.","Turning now to , the fill priority messages - of the first pixel in the run are sent to and passed by the optimisation module  in order from the rearmost to the topmost priority order. Namely, the fill priority messages - are sent to and passed by the optimisation module  in the following order , , , , , , , , , .","Considering first an initialised stack depth of 1 and the STORE_ instruction. It can thus been seen that the counter  has a count of 1, 1, 1, 2, 2, 2, 3, 2, 1, 1 for fill priority messages - respectively. Also, the fill priority messages , , meet the criteria that the fill priority messages are a first continuous run of X-independent fill priority messages. It should be noted that fill priority messages - do not meet the aforementioned test condition because of the existence of x-dependent fill priority message at that stack depth. It can also be seen that fill messages - and - meet the criteria that INVOLVED_PUSHED=FALSE. Thus the STORE_ bit instruction (viz stack depth of one) will be asserted for fill messages  and  for a stack depth . In a similar fashion it can be seen that the STORE_ bit instruction (stack depth of two) will be asserted for fill messages - and . Again it can been seen that no STORE_ (viz stack depth of three) will be asserted. The RESTORE_x bit is de-asserted for all fill messages - associated with the first pixel in the run and is not shown in FIG. A.","These fill priority messages - associated with the first pixel in the run are passed to the fill determination module  and converted to color composite messages and then sent to the pixel compositing module . The pixel compositing module  upon receipt of a color composite message having a STORE_x bit asserted will copy the top of the stack  to level x of the intermediate-value register  after the compositing operation of the pixel compositing message has been completed. In the event a sequence of color composite messages are received each having their STORE_x bit asserted of the same level, the pixel compositing module  will overwrite a previous value stored in the intermediate-value register with the copy of the stack  associated with a subsequent color composite message. In this particular example, the intermediate-value register  will contain in level one (corresponding to a stack depth of one) a copy of the top of the stack  that results after the completion of the compositing operation associated with the fill priority message . The intermediate-value register  will also contain in level two (corresponding to a stack depth of two) a copy of the top of stack  that results after the completion of the compositing operation associated with the fill priority message .","Turning now to , there is shown the fill priority messages that are passed by the optimisation module  during each pixel that is subsequent to the first pixel in the run. Firstly, it should be noted that the register  () during subsequent pixels contains the level index of the last fill priority message  in the run that had its store bit asserted. Also, it should be noted that the register  () during subsequent pixels contains the level index of the first fill priority message  in the run that had its store bit asserted. Consequently, the output of the shift register  is enabled for sending fill priority messages for subsequent pixels in the run only when the index of these fill priority messages have an index level between or equal to the level index stored in the registers , and . Thus the optimisation module  in this particular example will pass only fill priority messages , , - for subsequent pixels in the run. The optimisation module  also asserts the RESTORE_ bit instruction of the fill priority message  as the level index of this fill priority message is equal to the level index stored in the register  (FIG. ). In a similar fashion the optimisation module  also asserts the RESTORE_ bit instruction of the fill priority message .","The STORE_x bit instructions are de-asserted for all fill priority messages associated with pixels subsequent to the first pixel in the run. It should be noted that the optimisation module  manipulates only the STORE_x and RESTORE_x bits of the fill priority messages, it leaves the other fields of the fill priority messages unchanged.","These fill priority messages , , , ,  are passed by the optimisation module  for each pixel subsequent to the first pixel in the run to the fill determination module . The fill determination converts these fill priority messages to corresponding color composite messages and then sent to the pixel compositing module . The pixel compositing module  upon receipt of a color composite message (eg. ) having a RESTORE_x bit asserted will copy the color and opacity value stored in the intermediate-value register  at that level x to the top of the stack. The pixel compositing module  then proceeds in usual fashion according to the instructions contained in the color composite messages corresponding to the fill priority messages (eg. , , , ).","In further variations of the aforementioned arrangements, the arrangements are arranged as modules and sub-modules for performing the functions of the arrangements.","In still further variations, combinations of two or more of the aforementioned arrangements are possible.","In a still further arrangement, the optimisation module  is incorporated into the priority determination module  with the view to directly generating the reduced set of fill priority messages from the combined table . In this fashion, throughput of fill priority messages is reduced.","The compositing module  accepts color composite messages passed to it from the priority determination module , via the fill color determination module , and performs the color and opacity operation specified in the color_op and alpha fields of the message, and the stack operation specified in the stack operation field of the messages.","Preferably, the compositing module  includes the registers used for storing the intermediate results of optimised sequences, and accepts messages stored into, and restored from these registers, according to messages issued by the optimisation circuit .","The optimisation module  in accordance with the first arrangement is used in conjunction with the pixel compositing module  as shown in FIG. A. In this case, a color composite message with the STORE bit set will cause the compositing module  () to store the value on top of the stack  into the register , prior to performing the color, opacity and stack operations specified in color composite message. Conversely, when a color composite message with the RESTORE bit set is encountered, the value in this register  is copied from the register  onto the top of the stack , prior to performing the color, opacity and stack operations specified in the color composite message. The optimisation module  in accordance with the second arrangement can also be used in conjunction with the pixel compositing module  as shown in , and operates in the same manner.","The optimisation module  in accordance with the third arrangement is used in conjunction with the pixel compositing module  as shown in , with one modification. In this modification, the pixel compositing module  comprises a set of registers instead of one register . In this case, a color composite message with the STORE instruction bit asserted will cause the compositing module  to store the state of the stack  into the set of registers, prior to performing the color, opacity and stack operations specified in the color composite message. Conversely, when a color composite message with the RESTORE instruction bit asserted is encountered, the stack  is restored to the state which was stored in these set of registers, prior to performing the color, opacity and stack operations specified in the color composite message.","The optimisation module  in accordance with the fourth arrangement is used in conjunction with the pixel compositing module  as shown in FIG. B. In this case, the presence of an associative operation will trigger the performance of this operation on the accumulator , in addition to performing the color, opacity and stack operations specified in the color composite message on the stack itself. If a color composite message is encountered with the STORE bit asserted, then the accumulator value is stored into a temporary register in the accumulator unit . Conversely, if a color composite message is encountered with the RESTORE bit asserted, then the value in the temporary register of unit  is composited with the current destination value, and the color, opacity and stack operations specified in the color composite message are then performed. In the case where multiple temporary registers are used, the index of the register to be stored\/restored from can be included in the color composite message.","The optimisation module  in accordance with the fifth arrangement is used in conjunction with the pixel compositing module  as shown in  with some modification. The register  is adapted to store a list of color and opacity values at different priority levels. In this case, the color composite messages generated from the priority determination module  include STORE_x bits corresponding to a x level of the register  to be used. A color composite message with the STORE_x bit asserted will cause the value on top of the stack  to be stored in the register  at the level x specified in the color composite message, after the color, opacity and stack operations specified in the color composite message have been performed. A color composite message with the RESTORE_x bit asserted will cause the saved value to be pushed onto the top of the stack after the color, opacity and stack operations specified in the color composite message have been performed.","Each of these optimisations replaces (on average) several color composite messages that must be performed on a per-pixel basis with a single color composite message to restore a value or the state of the stack. Thus, where runs of pixels that require the same compositing operations to be performed on each pixel are encountered, these optimisations reduce the amount of per-pixel processing which must be performed, allowing pixels to be composited using fewer operations, on average. The choice of optimisation method will depend largely on the amount of complexity which is tolerable within a particular system design.","It should be apparent to the person skilled in the art that any of these optimisations may be used in a software implementation of a pixel-sequential renderer, without departing from the principles of this invention.","The aforementioned preferred processes implemented by the computer system  comprise a particular control flow. There are many other variants of the preferred processes, which use different control flows without departing from the spirit or scope of the invention. Furthermore one or more of the steps of the preferred method(s) may be performed in parallel rather than sequentially.","It is apparent from the above that the arrangements described are applicable to computer graphics and printing industries.","The foregoing describes only some arrangements of the present invention, and modifications and\/or changes can be made thereto without departing from the scope and spirit of the invention, the arrangements being illustrative and not restrictive."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["One or more arrangements of the present invention will now be described with reference to the drawings, in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 7A","b":"7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 8B","FIG. 8A"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIGS. 9A and 9B","FIG. 8A"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 10","FIG. 8A"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 11","FIG. 8A"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 12A","FIG. 4"],"b":"400"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 12B","FIG. 4"],"b":"400"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIGS. 12C","FIG. 4","FIG. 8A"],"b":"12"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 13A and 13B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 14A","b":"14"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIGS. 15A","FIG. 5"],"b":"15"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIGS. 16A","b":"16"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 17A and 17B"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 17C"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 18","FIG. 3"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIGS. 20A and 20B"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 22A","b":"500"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 22B","b":"600"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 23A","FIG. 3"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 23B","FIG. 3"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIGS. 24A","FIG. 3"],"b":"700"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 25","b":"550"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 26","b":"550"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 27","b":"550"},"FIGS. () and () shows a block diagram of the optimisation module  in accordance with a fourth arrangement.","FIGS. () and () shows a block diagram of the optimisation module  in accordance with a fifth arrangement.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIGS. 30A and 30B","b":"550"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIGS. 31A and 31B","b":"550"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIGS. 32A and 32B","b":"550"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIGS. 33A and 33B","b":"550"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIGS. 34A and 34B","b":"550"}]},"DETDESC":[{},{}]}
