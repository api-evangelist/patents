---
title: Debugger and debugging methods using breakpoints conditioned on the static identity of data
abstract: A method of debugging a program includes setting a breakpoint in the program identifying a location within the program, a reference-typed expression that is valid within the scope of the location, and a set of statically-specified data entities to which the expression refers, upon encountering the location during a current run of the program, determining whether the associated expression evaluates to a reference corresponding to one of the statically-specified data entities, pausing the program at the location if a value of the expression refers to one of the statically-specified data entities, and continuing the program without pausing if the value does not refer to one of the statically-specified data entities.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08522213&OS=08522213&RS=08522213
owner: International Business Machines Corporation
number: 08522213
owner_city: Armonk
owner_country: US
publication_date: 20110512
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["1. Technical Field","The present disclosure generally relates to software debuggers and methods of debugging software, and more particularly to a debugger and a debugging method that uses conditional breakpoints.","2. Discussion of Related Art","A debugger or a debugging tool is a computer program that is used to test and debug a target program. A \u201ccrash\u201d may happen when the target program cannot normally continue because of a programming bug. For example, the program may have attempted to use an unavailable instruction or to access unavailable or protected memory. When the program \u201ccrashes\u201d or reaches a preset condition, the debugger may show the position in the original code if it is a source-level debugger or symbolic debugger.","Debuggers may also offer more sophisticated functions such as running a program step by step (single-stepping), or by stopping or pausing (breaking) the program to examine the current state at some event or specified instruction by means of a breakpoint. A breakpoint can be absolute or conditional. An absolute breakpoint may identify a line number within a target program where a break in the execution of the program will occur when that line has been reached. A conditional breakpoint additionally includes a condition that needs to be satisfied before the break occurs. For example, the breakpoint could be conditioned on a variable of the program having a certain value.","When debugging object-oriented and imperative software, one is often interested in focusing on the behavior of a piece of code with respect to some specific data entity with which the code interacts. For example, it may be important to focus on behavior with respect to data entities that belong to some other piece of code, by virtue of being allocated at some particular program point. However, this focus cannot be achieved with ordinary conditional breakpoints, because the point at which an object was allocated cannot be identified by examining the object. Further, achieving this focus can be particularly challenging when debugging software that makes use of a complex software framework.","A software framework is an abstraction in which common code providing generic functionality can be selectively overridden or specialized by user code, thus providing specific functionality. Frameworks are a special case of software libraries in that they are reusable abstractions of code wrapped in a well-defined Application Programming Interface (API), yet they contain some distinguishing features that separate them from normal libraries. For example, a framework may have a default behavior, be non-modifiable, have inversion of control, or extensibility. Inversion of control allows the overall program's flow of control to be dictated by the framework instead of the caller. Extensibility allows a framework to be extended due to selective overriding by a user or specialized by user code providing a specific functionality.","Developers debugging software that uses a given framework may resort to tracing through the framework to understand the framework's behavior, and how it relates to their code. Unfortunately, setting a breakpoint at a particular line of source code within a framework often results in the debugger stopping many times at that line, on behalf of entities created or owned by framework clients other than the one of interest. As a result, it can become difficult to focus on the interactions between client code and framework code.","According to an exemplary embodiment of the disclosure, a method of debugging a program includes setting a breakpoint in the program identifying a location within the program, an expression within the scope of the location, and a set of statically-specified data entities to which the expression refers, upon encountering the location during a current run of the program, determining whether the associated expression evaluates to a reference corresponding to one of the statically-specified data entities, pausing the program at the location if a value of the expression refers to one of the statically-specified data entities, and continuing the program without pausing if the value does not refer to one of the statically-specified data entities. The method may be performed by a data processing system, a processor, etc. The expression may be a reference-typed expression whose value refers to a data entity that is dynamically allocated by the program. The expression may be valid when the expression refers only to literal values and variables.","According to an exemplary embodiment of the disclosure, upon encountering a current line of a program identified by a breakpoint, determining whether an expression of the current line evaluates to a reference corresponding to a statically-specified data entity identified by the breakpoint, pausing the program at the location if a value of an expression of the breakpoint refers to the statically-specified data entity, and continuing the program without pausing if the value does not refer to the statically-specified data entity. The method may be performed by a data processing system, a processor, etc. The expression may be a reference-typed expression whose value refers to a data entity that is dynamically allocated by the program.","According to an exemplary embodiment of the invention, an apparatus for debugging a program includes a memory and a processor. The memory stores at least one target program, a debugging program, and a user interface program. The processor is configured to execute the selected target program and the debugging program. The user interface program enables a user to select one of the target programs for debugging, and set a breakpoint in the program identifying a location within the program, a reference-typed expression that is valid within a scope of the location, and a set of statically-specified data entities to which the expression refers. The debugging program determines whether the associated expression evaluates to a reference corresponding to one of the statically-specified data entities, pauses the target program at the location if a value of the expression refers to one of the statically-specified data entities, and continues the target program without pausing if the value does not refer to one of the statically-specified data entities.","Exemplary embodiments of the disclosure relate to an instance-identity-constrained breakpoint for use in methods of debugging software programs and software debuggers. For example, the breakpoint may include i) a source location (e.g., a source line, or an entry point of a program entity such as a method or subroutine), and optionally, (ii) a set of reference-typed expressions that refer to entities within the scope of the location, and (iii) for each specified expression in (ii), a corresponding set of statically-specified data instances. An example of an breakpoint in an object-oriented context with reference to the program of  includes (i) the entry point of a method of an object class (e.g., Foo.execute( ), (ii) a singleton set (e.g., \u201cthe receiver \u2018this\u2019 of Foo.execute( )\u201d, and (iii) a singleton allocation site set (e.g., \u201cline  of Client\u201d).","Herein, the types of the data references whose identities are being constrained are referred to as \u201cconstrained types\u201d. In the object-oriented context, the type containing the source location (i) is referred to as the \u201cowning type\u201d. Further, if the location in question is within an instance method, the object instance on behalf of which a given method executes is referred to as the \u201creceiver\u201d.","The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises\u201d and\/or \u201ccomprising,\u201d when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.","The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present disclosure has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the disclosure. The embodiment was chosen and described in order to best explain the principles of the disclosure and the practical application, and to enable others of ordinary skill in the art to understand the disclosure for various embodiments with various modifications as are suited to the particular use contemplated.","A debugger that supports the breakpoint according to an exemplary embodiment of the disclosure may execute the method of . Referring to , the method includes determining whether a set of reference-typed expressions of a breakpoint are empty (S), pausing the program each time a source location of the breakpoint is encountered if the set is empty (S), and if the set is not empty, at an execution of the given source location, determining if a data item referred to by one of the expressions is contained in a set of statically-specified data instances of the breakpoint (S), pausing the program at the given source location if the expression is determined to be contained in the set of statically-specified data instances (S), and continuing to execute the program without pausing if the expression is determined not be contained within the set of statically-specified data instances (S). The set of reference-typed expressions may be one or more expressions. The set of statically-specified data instances may be one or more data instances.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["206","204","205","201","202","203","205","206","202","202","203","201","206","202"]},"The set of statically-specified data instances can be specified in various ways. For example, the set of data instances can be specified as a set of allocation site locations in the program. For example, the data instances can be specified as the locations in the source\/object code of the program where the data of interest are allocated. In another embodiment, a condition is specified on the state of the program at the time allocation occurs, which can refer to any data in scope at the allocation site.","As an example of an allocation-site based specification for object oriented programs, each source location (and therefore a given breakpoint) may be associated with a single type (e.g., an object class). Thus, relevant allocation sites for a breakpoint that constrain the identity of \u2018this\u2019 are those that allocate the type of object associated with that breakpoint (e.g., the \u201cowning type\u201d of that source location\u201d). Due to type inheritance, there may be multiple concrete types (e.g., those that can be instantiated) that correspond to the \u201cowning\u201d type at any given execution of the line associated with the breakpoint. For example, if the owning type is a base class, which is extended by several derived types, any allocation of any class that extends the owning type is potentially relevant.","For breakpoints that constrain the identity of some other object reference at the breakpoint location, useful allocation sites are those that allocate objects of the type of the object reference. Again, due to type inheritance, there may be multiple concrete types that could correspond to the type of the object reference. For example, if the object reference is of an interface type, any allocation of any class that implements the given interface is potentially relevant.","In languages that are not object-oriented, but do support dynamic memory allocation (e.g., procedural languages such as Pascal), the set of allocation sites may be specified as a set of source locations where the given type of data is allocated.","At least one exemplary embodiment of the disclosure relates to a debugger or a debugging method that uses a static specification of a breakpoint's identity conditions to instrument one or more potentially relevant allocations (e.g., instantiations) of a data entity (e.g., object) to record information about events where the data entity was allocated. For example, upon encountering a line of code with an associated identity breakpoint, the debugger uses the specification to determine whether the data entity referred to by a data reference (e.g., a variable) was allocated at \u201csites of interest\u201d associated with the breakpoint.","The sites of interest can be specified in various ways, including as a set of one or more of any of the following: i) single source locations (e.g., a line number of source code at which instances of the relevant type (e.g., class) are allocated), ii) the set of sites of interest contained within a given type, iii) the set of sites of interest contained within a given compilation unit, iv) the set of sites of interest contained within a given package or module, v) the set of sites of interest contained within a given library or other software bundle, or vi) a condition that constrains the circumstances under which a given object constructor or allocation site is executed. For example, the condition could place constraints on the contents of a call stack, such as \u201cany call to constructor Foo(int) in which the Bar( ) method of class (e.g., type) Bar  appears as a caller in the call stack\u201d).","A debugger supporting such a condition breakpoint keeps track of where the relevant data entities (e.g., object instances) were allocated. For example, the debugger could maintain an allocation table. However, for languages that are strictly statically type safe (e.g., Java and Pascal), the debugger need not track the allocation of all types of data. Rather, the debugger need only track allocations of the \u201cconstrained types\u201d associated with one or more existing breakpoints. Moreover the debugger can perform this bookkeeping by means of an additional set of breakpoints and a small amount of housekeeping data.","For strictly-statically type-safe languages, the debugger instruments the allocations sites of interest (e.g., those associated with such a conditional breakpoint) by adding instructions that maintain the set of data instances of interest (\u201cthe instance set\u201d). For example, as each such allocation site, the debugger adds instructions to add the newly created object instance to the \u201cinstance set\u201d associated with a given breakpoint. When the program then reaches the source location associated with that breakpoint, the debugger compares the identity of the referred data to the identities of the data in the associated instance set. Since object-oriented runtimes may have a very concise way of identifying objects (e.g., as either an index into an object table or as a starting address of a memory block occupied by the object instance), this comparison can be made more efficient by use of hashing. Accordingly, it may be possible to avoid a linear search through the instance set (e.g., N objects, where N is a natural number).","However, in languages that are not statically type-safe (e.g., various procedural languages like \u201cC\u201d), it may not be possible to statically limit the set of allocation sites that can result in data that could be referred to by a given data reference. In the \u201cC\u201d language, for example, the ability to unsafely down-cast pointers permits one to treat a pointer to any type of data as any other type. As a result, it may be necessary to instrument all allocation sites so that the site at which each data item was allocated is known.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 3","FIG. 3"],"b":["301","302","303","304"]},"As an example, the location may be a line of code within the program or an entry point of a program entity. The statically-specified data entities could be instances of corresponding object classes. For example, the breakpoint could identify the statically-specified data entities by including names of the object classes that allocate the instances or names of object methods that allocate the instances. As another example, the breakpoint could identify the statically-specified data entities by including names of files that allocate the data entities. As a further example, the breakpoint could identify the statically-specified data entities by including names of libraries or modules that allocate the data entities.","According to an exemplary embodiment of the disclosure, prior to determining whether the value refers to a corresponding one of the statically specified data entities, for each allocation of the expression, an object identifier and a stack backtrace of the allocation may be recorded as an entry in a table. The determining of whether the value refers to a corresponding one of the statically specified data entities may include steps of determining an object identifier of an object to which the value refers, determining the entry in the table that includes the object identifier, and determining that the value refers to one of the statically-specified data entities if the stack backtrace of the entry refers to any allocation location associated with the statically-specified data entities. The value does not refer to one of the statically-specified data entities if the stack backtrace does not refer to any allocation location associated with the statically-specified data entities.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 4","FIG. 5","FIG. 4","FIG. 6","FIG. 4"]},"Referring to , the classes include a Foo class , a Framework class , a Client class , a Client class , and a Main class . In this example, the main( ) method of the Main class  calls the Client.setup( ) method and the Client.setup( ) method. The Client.setup( ) method allocates a first instance of the Foo class  and registers it with the Framework class . The Client.setup( ) method executes a small loop, repeatedly allocating second through sixth instances of the Foo class , and registers each with the Framework class . As a result, the Framework class  manages instances of the Foo class  on behalf of both Client and Client.","If an ordinary breakpoint is set within the execute( ) method within the Foo class , the breakpoint would be triggered for Foo instances allocated by both Client and Client, which makes it difficult to focus on only a single client's (e.g., only Client  or only Client) interactions with the Framework Class .","Accordingly, at least one embodiment of the disclosure provides a means of focusing attention on client\/framework interactions by making a breakpoint conditional on the identity of a given data item. For example, in at least one embodiment of the disclosure, the breakpoint is made conditional on the identity of one or more data items in a routine or a method call, so that the debugger will stop (or pause) at such a breakpoint only when the data items belong to a given set of object instances.","Referring to , a location within a target program for a break is selected (S). For example, as shown in , it is assumed that a user has selected a breakpoint  at a source line location within the execute( ) method of the Foo class .","Next, an object class within the scope of that location is selected (S). For example, the user selects the Foo class  since it is within the scope of the execute( ) method.","Next, a method (e.g., of another object class) that allocates an object instance of the selected object class is selected (S). As shown in , the Client.setup( ) method of the Client class  and the Client.setup( ) method of the Client  class  both allocate an object instance of the Foo class  (e.g., see new Foo( ) method in classes  and ). For the purpose of this example, it is assumed that the user is only concerned with allocations of the Foo class  by Client.setup( ) method. Thus, here, the user would select the Client.setup( ) method as the selected method.","Next, the breakpoint  is generated based on the selected data (S). For example, the breakpoint  may include the source line location, an item referring to or an expression identifying the selected object class (e.g., \u201cFoo\u201d), and an item referring to or an expression identifying the selected method (e.g., \u201cClient.setup( )\u201d).","The breakpoint  may be structured as a boolean condition (e.g., \u201cstop if \u2018this\u2019 refers to an instance of the class Foo allocated by a call from the method Client.setup( )\u201d). The Boolean condition could be thought of has a Boolean function, that takes a stack backtrace and returns true if the breakpoint should be \u201ctaken\u201d. So, in this example, if a given allocation backtrace contains any frame that refers to Client.setup( ) the function would return true.","Next, based on the selected object class (e.g., Foo) of the breakpoint , an entry for each allocation of the object class (e.g., Foo) is recorded that includes the object ID and the stack backtrace of the corresponding object instance (S). For example, allocations of Foo are recorded because the breakpoint  refers to Foo. These recordings occur while the program is run.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 5","FIG. 6"],"b":["505","600","1","1","503","2","2","504","505","1","600","1","2","600","2"]},"A debugger running the above method can place a breakpoint in the constructor of the Foo class  to assist in the recording of these entries. For example, when the breakpoint within the constructor is hit, the debugger can query for the object ID (e.g., examine the \u2018this\u2019 variable), retrieve its corresponding stack backtrace, and add the queried items (e.g., the object ID and corresponding stack backtrace) as an entry of the allocation table.","Next, while the program is currently run or after the program is re-run, and upon encountering a line corresponding to the previously selected location, a determination of an object ID of an object instance with which the encountered line refers is made (S). For example, the debugger may examine the value of the \u2018this\u2019 variable to determine the object ID.","Next, a break occurs within the program at the encountered line only if the stack backtrace associated with the determined object ID refers to the method in the breakpoint. (S). Here, the breakpoint specified that the method was Client.setup( ). Thus, if the determined object ID happened to be , a break would occur at the encountered line since the backtrace in table  associated with an object ID of  refers to Client.setup( ). Alternately, if the determined object ID happened to be , a break would not have occurred at the encountered line, since the backtrace in table  associated with object ID  did not refer to the Client.setup( ) method, and instead referred to the Client.setup( ) method. The breakpoint may be referred to as an instance-identity-constrained breakpoint since its occurrence was dependent on the identity of the object instance (e.g., object ID).",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 7","FIGS. 1"],"b":["3","4","1008"]},"The computer system referred to generally as system  may include, for example, a central processing unit (CPU) , random access memory (RAM) , a printer interface , a display unit , a local area network (LAN) data transmission controller , a LAN interface , a network controller , an internal bus , and one or more input devices , for example, a keyboard, mouse etc. The display unit  may display results of the debugging. As shown, the system  may be connected to a data storage device, for example, a hard disk , via a link . CPU  may be the computer processor that performs the above described methods (e.g., those of ,  and ).","In at least one embodiment of the invention, the memory  may store a target program, a debugging program, and a user interface program. The CPU  (e.g., a processor) may execute the selected target program and the debugging program. The CPU  may also execute the user interface program or a processor remote to the system may execute the user interface program. The user interface program enables a user to select one of the target programs for debugging. The user interface program enables the user to set a breakpoint in the program identifying a location within the target program, a reference-typed expression that is valid within a scope of the location, and a set of statically-specified data entities to which the expression refers. The debugging program determines whether the associated expression evaluates to a reference corresponding to one of the statically-specified data entities, pauses the target program at the location if a value of the expression refers to one of the statically-specified data entities, and continues the target program without pausing if the value does not refer to one of the statically-specified data entities. The user interface program may enable the user to examine (view) the content of at least one memory location of the memory  when the program is paused (e.g., program variables, memory locations outside the program, etc.). The user interface program may enable the user to view code of the line of the program at the paused location and code of one or more surrounding lines. Further, the user interface may enable the user to view the code of other lines of the program or external programs that are invoked by the viewed lines. Moreover, the user interface may enable the user to view the content of program variables associated with each viewed line.","As will be appreciated by one skilled in the art, aspects of the present disclosure may be embodied as a system, method or computer program product. Accordingly, aspects of the present disclosure may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device. Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present disclosure may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present disclosure are described above with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present disclosure. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["Exemplary embodiments of the disclosure can be understood in more detail from the following descriptions taken in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
