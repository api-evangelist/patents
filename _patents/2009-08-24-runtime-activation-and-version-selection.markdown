---
title: Runtime activation and version selection
abstract: A runtime activation system uses a set of policies designed to provide a balance between backwards compatibility and ease of migrating existing (non side-by-side aware) applications to new runtime versions. The system chooses the runtime version to activate when an application runs or when a runtime application programming interface is invoked based on the set of policies. The system implements these policies by consulting compatibility data associated with the application indicating the intent of the author and level of side-by-side support provided by the application and/or global configuration data. Based on the compatibility data, the system chooses policies that are right in the most common cases, and easy to modify in less common cases. Thus, the runtime activation system allows applications to be flexibly configured to handle new runtime versions in a manner determined by the application author, a system administrator, or others.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08522227&OS=08522227&RS=08522227
owner: Microsoft Corporation
number: 08522227
owner_city: Redmond
owner_country: US
publication_date: 20090824
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Software developers often build software applications on top of a \u201cruntime\u201d library such as Microsoft's Common Language Runtime (CLR), or runtime libraries like Microsoft's C-Language Runtime (CRT). Runtimes may provide common functions such as application startup logic, as well as class libraries for handling common programming challenges. For example, the CLR contains class libraries that implement common data structures (e.g., linked lists, hash tables, and so forth), as well as common functionality, such as garbage collection. By using a runtime, an application relieves the application's author from implementing well-understood programming logic so that the author can focus on logic specific to the problem the author is trying to solve.","Applications have grown complex, often allowing extendibility through third-party software plug-ins. For example, a word processing application may invoke third-party software modules that add new items to toolbars and menus, or provide other extended functionality to the word processing application. As the application evolves and the application author updates the application, it is common for the application to be built to run with one runtime version while the application's author would like to continue supporting older plug-ins built using an earlier runtime version. Similarly, the plug-ins may evolve faster than the hosting application, and the plug-ins may rely on a newer version of a runtime while the application relies on an older version of the runtime. A newer runtime version may introduce intentional and unintentional changes in behavior that can negatively affect components that operated correctly on the previous version. Further complicating such applications is that managed execution environments, such as Microsoft's CLR, may allow a mix of managed and native (non-managed) application code to run in the same process, each having its own runtime considerations and expectations.","Managed code is computer program code that executes under the management of a virtual machine or runtime, unlike unmanaged code, which is executed directly by the computer's central processing unit (CPU). Programs in any programming language can, in principle, be compiled into either managed or unmanaged code. In practice, however, each programming language is typically compiled into one type. For example, the Java programming language is almost always compiled into managed code, although there are Java compilers that can generate unmanaged code (such as the GNU Compiler for Java). By contrast, Microsoft's Visual C++ development environment can produce both managed code (running under the .NET CLR) or unmanaged code.","Designers of runtimes may initially design the runtime so that a particular process can only load a single version of that runtime, and application authors often build applications with the same assumption. When the runtime author updates and distributes a newer version of the runtime, older applications are sometimes forced to execute using the new runtime potentially leading to backwards compatibility problems. For example, if a user deploys an application compiled against runtime version 1 to a computer that has runtime version 2 installed, the application may run using the installed version, which can be subtly incompatible with the application and result in a variety of problems during execution. Solving this problem by maintaining total backwards compatibility is not feasible for any complex and evolving runtime, so such runtimes may evolve to support multiple versions loaded simultaneously into the same process at once so that application code can use the runtime version for which it was designed.","Another problem is that when evolving a runtime to support multiple versions \u201cside-by-side\u201d in the same process, it is often desirable to continue running applications correctly that were designed for a previous version of the runtime that did not support multiple runtime versions in a single application process. The runtime may include functions that query information about the application execution environment from which it is desirable to hide new versions of the runtime. At the same time, the runtime author wants to make it easy to update an application to run against a new version of the runtime (e.g., for compatibility testing or just updating). These two goals are contradictory. These considerations can be translated into the following question: how can an application designed to have only one runtime in its process execute in a multiple runtime process with no impact, while also making it easy to move applications forward to a new version of the runtime?","A previous simple solution to this problem is to keep applications tightly coupled to the version of the runtime they were designed for, so that all requests to a runtime are implicitly targeted at a specific version with no sharing across versions. This is the solution taken by the Microsoft CRT. The biggest downsides are that application authors cannot move applications between versions without recompiling and applications designed for different runtime versions are limited in how they can share information.","A runtime activation system is described herein that uses a set of policies designed to provide a balance between backwards compatibility and ease of migrating existing (non side-by-side aware) applications to new runtime versions. The system includes an activation shim component that chooses the runtime version to activate when an application runs or when a runtime application programming interface is invoked. The activation shim carries out a set of policies to determine which runtime to activate for a particular application or module within a process. The system implements these policies by consulting compatibility data associated with the application indicating the intent of the author and level of side-by-side support provided by the application and\/or global configuration data. Based on the compatibility data, the system chooses policies that are right in the most common cases, and easy to modify in less common cases. Thus, the runtime activation system allows applications to be flexibly configured to handle new runtime versions and side-by-side runtime versions in a manner determined by the application author, a system administrator, or others.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","A runtime activation system is described herein that uses a set of policies designed to provide a balance between backwards compatibility and ease of migrating existing (non side-by-side aware) applications to new runtime versions. Backwards compatibility in the case of a runtime may include preferring to run applications or plug-ins on the runtime for which they were built, so that the results are the same as experienced when the application was built and tested by its author. The system includes an activation shim component that chooses the runtime version to activate when an application runs or when a runtime application programming interface (API) is invoked. The activation shim carries out a set of policies to determine which runtime to activate for a particular application or module within a process. Under one set of policies: 1) applications designed for a previous version of the runtime are unaffected when a new version of the runtime is installed on the machine, 2) applications designed without consideration of side-by-side runtimes can be migrated (with or without recompiling) to new versions of the runtime without any special consideration of side-by-side runtimes, 3) applications designed without consideration of side-by-side runtimes can be easily updated to be side-by-side aware, and 4) plug-ins designed for new versions of the runtime can be injected into processes not explicitly designed or configured for side-by-side runtimes. The system implements these policies by consulting compatibility data associated with the application indicating the intent of the author and level of side-by-side support provided by the application and\/or global configuration data. The compatibility data may specify, for example policies that produce correct program behavior in the most common cases and are easy to modify in less common cases. Thus, the runtime activation system allows applications to be flexibly configured to handle new runtime versions and side-by-side runtime versions in a manner determined by the application author, a system administrator, or others.","The policy used by the runtime activation system is a set of dynamic rules that describes how applications activate one or many runtimes in processes associated with the applications. Having the latest runtime installed should not affect applications and plug-ins built using previous versions of the runtime. The policy provides rules in order to avoid unpredictable behavior in old applications and plug-ins. For legacy applications, the policy may provide a rule that applications bind to one of the runtimes against which the applications were tested. If no such runtime is installed or available, the policy may specify that the system display a dialog message inviting the user to install a compatible runtime or the system may install the compatible runtime on the user's behalf. As referred to herein, legacy applications and runtimes refer to those that are not side-by-side aware, while current\/non-legacy runtimes and applications are those built to run correctly with side-by-side aware runtimes in a process. However, those of ordinary skill in the art will recognize that the techniques described herein may also be applied successfully to other incompatibilities that occur when a runtime is updated from one version to the next. The system may be configured to prefer to preserve the behavior of legacy applications, keeping the existing behavior, and preferring execution against the runtime for which the legacy applications were built.","In some embodiments, the runtime activation system determines the activation policy based upon the host application type (native vs. managed) and the level of information available in the application. For native applications, the system may cause plug-ins to bind to the runtime against which the plug-ins were compiled and to apply legacy execution rules only for execution against legacy (non side-by-side) runtimes. Plug-ins may include Component Object Model (COM) objects or other pluggable software building blocks. For managed applications, the system may determine whether the application was compiled against a runtime that is side-by-side aware, and if so cause any legacy plug-ins to bind to that runtime by default. However, the system provides a configuration setting that can be used by the application author to indicate that the application has been migrated from the legacy API such that the system can enable support for side-by-side activation with older runtimes. If the application was compiled against any legacy runtime, then new plug-ins bind against the side-by-side aware runtime for which they were designed. Alternately, the system may choose to provide increased compatibility for legacy plug-ins, and run them in the runtime for which they were built by default (even for managed plug-ins compiled against a runtime that is side-by-side aware). In such cases, the system provides a configuration setting that can be used by the application or plug-in author to indicate that the software relies on the legacy API.","In some embodiments, the runtime activation system provides results from legacy APIs based on the host application type. The legacy API may include a one-per-process resource that constrains the activation itself. For APIs with results affected by activating multiple side-by-side runtimes in a process, the system may determine the results to return from the APIs based on the policies described herein. For example, legacy APIs may expect only one runtime in a process, and if the API, for example, is asked to report the current runtime version, the API determines which loaded runtime's version to report. It is desirable for legacy APIs to preserve their original returned results. Thus, the system may determine that for native hosts any legacy APIs will return results related to legacy runtimes by default. For example, if a legacy API returns new runtime results, then any multiple runtime capabilities may be turned-off. For managed applications, by default any legacy API will return results related to the runtime already loaded in the process. The previous example describes a policy that prefers ease of migration. A policy that prefers backwards compatibility might instead bind the legacy APIs to the highest legacy version. This balance can be modified through configuration settings described herein.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","110","120","130","140","150","160","170","100","100","130"]},"The detect activation component  detects an activity that invokes a runtime. For example, the activity may be a function call or loading of a software module or assembly for execution. The detect activation component  may take the form of an activation shim that a software module invokes to select and activate a runtime. The detect activation component  allows the runtime activation system  to insert the logic described herein into the activation process. For example, upon detection of a request for runtime activation by the component , the system may consult one or more activation policies, select an appropriate runtime version to activate, and activate the selected runtime version to handle the request that caused the activation.","The policy store  stores one or more policies that determine a runtime version among a plurality of runtime versions to invoke in response to a particular runtime activation request. The policy store may include a configuration file associated with a computer system and individual configuration files associated with software modules. In some embodiments, the author of a software module can express the author's confidence in the compatibility of the software module with one or more runtime versions as well as the author's preference for rolling forward to new runtime versions. The author may place this information in a manifest or other configuration information associated with the software module (e.g., flags in a Portable Executable (PE) file). The information may be added manually by the author or automatically, such as by a compiler or other development tools.","The policy configuration component  allows an administrator or other user to modify policies stored in the policy store . For example, an administrator may determine that a particular runtime version contains vulnerabilities such that the administrator does not want to allow the particular runtime version to run on a computer system. In response, the administrator may use the policy configuration component  to set a policy that excludes the errant runtime version from running, even when a particular software module requests that version of the runtime.","The configuration loading component  accesses policy information associated with the runtime on a computer system. For example, Microsoft NET uses a configuration file that may be extended with the process element in the following XML code to define the permitted runtimes for assemblies running on the computer system.",{"@attributes":{"id":"p-0025","num":"0024"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<configuration>"]},{"entry":[{},"\u2003\u2003<startup>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<process>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<permittedRuntimes mode=\u201cinclusive\u201d|\u201cexclusive\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<runtime version=\u201cX.Y.Z}\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<\/permittedRuntimes>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<rollForward enabled=\u201ctrue\u201d|\u201cfalse\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/process>"]},{"entry":[{},"\u2003\u2003<\/startup>"]},{"entry":[{},"<\/configuration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The permittedRuntimes element describes the set of runtimes that can be loaded into a process. The element may have a mode property that specifies whether the list is inclusive or exclusive. The rollForward element specifies whether the system will use the compatibility policy when the system cannot find an exact match within the set of runtimes supported by the application. By default the value is false, but when set to true and the desired runtime is not found, the system rolls forward to the closest available match among the permitted and installed runtimes.","The runtime selection component  selects a runtime to activate in response to a runtime activation request based on policy and other information. For example, when component  receives a request to activate a runtime (e.g., via the detect activation component ), the runtime selection component  may select a runtime based on factors such as policy stored in the policy store  and accessed through the configuration loading component , configuration information associated with an executable hosting the software module initiating the request, the host type of the executable (e.g., managed or native), whether the request specifies a particular runtime version (e.g., an API that receives a runtime version string), and so forth. The runtime selection component  may also determine whether a particular host executable was built to be aware of and compatible with side-by-side execution of multiple runtime versions in a process.","The legacy API binding component  is a subcomponent of the runtime selection component  that determines a runtime to activate when a legacy API is invoked that is dependent on a particular runtime version. Based on configuration policy, the component  determines whether to activate a side-by-side aware runtime or a legacy runtime version. The decision of which runtime to activate may balance backwards compatibility with ease of migration to a new runtime version based on configured policy or other factors described herein.","The request handling component  activates the runtime selected by the runtime selection component  and forwards the runtime activation request to the selected runtime for handling. For example, the runtime activation request may have resulted from invoking a legacy hosting API that dynamically binds to a runtime. The runtime activation system  detects the activation request through the detect activation component  selects an appropriate runtime to handle the request (e.g., based on policy and\/or other factors described herein) using the runtime selection component , activates the selected runtime, and forwards the API call to the activated runtime to respond to the request. The caller that invoked the legacy hosting API receives the results of the API call from the selected runtime.","The computing device on which the runtime activation system is implemented may include a central processing unit, memory, input devices (e.g., keyboard and pointing devices), output devices (e.g., display devices), and storage devices (e.g., disk drives or other non-volatile storage media). The memory and storage devices are computer-readable storage media that may be encoded with computer-executable instructions (e.g., software) that implement or enable the system. In addition, the data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communication link. Various communication links may be used, such as the Internet, a local area network, a wide area network, a point-to-point dial-up connection, a cell phone network, and so on.","Embodiments of the system may be implemented in various operating environments that include personal computers, server computers, handheld or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, digital cameras, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and so on. The computer systems may be cell phones, personal digital assistants, smart phones, personal computers, programmable consumer electronics, digital cameras, and so on.","The runtime activation system may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, and so on that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":"210"},"Continuing in block , the component accesses a runtime configuration policy that includes one or more criteria for selecting a runtime version among the plurality of runtime versions to activate. For example, the runtime configuration policy may specify that information associated with a software module from which the activation request originated governs which runtime version to select. Alternatively or additionally, the runtime configuration policy may specify criteria to select a runtime version for a plug-in software module based on information about a host software module hosting the plug-in software module. For example, if the host is bound to a side-by-side aware runtime version, then the policy may limit plug-ins to the same runtime version. As another example, if the host is bound to a legacy runtime version, then the policy may allow plug-ins to use either a side-by-side aware or legacy runtime version.","Continuing in block , the component selects a runtime version to activate in response to the runtime activation request based on the runtime configuration policy. The component may include information about runtime versions installed on a computer system running the component. For example, if the policy specifies that a particular activation should use version two or higher of a runtime, and the computer system has versions one and two installed, then the component may select version two. Alternatively or additionally, under some circumstances the component may request that the user install a particular version of the runtime (e.g., version four in the previous example). Continuing in block , the component activates the selected version of the runtime. Activation may include loading one or more software modules associated with the runtime (e.g., mscoree.dll for Microsoft .NET or msvcrt.dll for the Microsoft CRT) and invoking one or more initialization functions of the runtime. In situations where the component dynamically loads the runtime in response to an API call, the component may also forward an original API request that caused the activation to the loaded runtime for response to the caller of the API. After block , these steps conclude.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3","b":"310"},"Continuing in block , the component receives a runtime configuration policy that specifies one or more criteria for selecting a runtime version to which to bind the API request. For example, the policy may specify that the API request be bound to a version of the runtime for which a software executable that invokes the API is built. As another example, the policy may specify a runtime version to which to bind legacy APIs. Continuing in block , the component selects a runtime version to which to bind an API based on the API version information and runtime configuration policy. For example, if the API version information specifies an available runtime version, then the component may select that runtime version. Alternatively or additionally, if the runtime configuration policy specifies a configuration override that specifies a particular runtime version, then the component may select that runtime version. The component may also determine which runtime versions are installed on the computer system executing the component to select an appropriate runtime version.","Continuing in block , the component binds the API to the selected runtime version and invokes the API to respond to the API request. The component may bind the API by loading a software module associated with the runtime and having a host proxy calls to the appropriate runtime (e.g., call into the runtime on the plug-ins behalf and return the results) or mimic the runtime's behavior. As another example, the component may maintain a function table and set one or more function pointers associated with legacy APIs to point to API implementations within the loaded runtime. In some embodiments, the APIs may return results based on the API version information and runtime configuration policy information. For example, if a particular software executable designed for an older runtime is incapable of handling results based on newer runtime information, then the API may only return results containing older runtime information, so that the software executable will continue to operate as designed even after the newer runtime version is installed. After block , these steps conclude.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 4","FIG. 2"],"b":["230","410","420","450"]},"Continuing in decision block , if a version of the runtime requested by the hosting executable process is not installed, then the component continues at block , else the component continues at block . In block , the component displays a prompt or other user interface to inform a user to install the requested runtime version. For example, the prompt may include download instructions for obtaining the requested runtime version. After displaying the prompt, the component completes. The user can re-run the hosting executable process after downloading the requested runtime version. Continuing in decision block , if the hosting executable process requests a legacy runtime version, then the component continues at block , else the component jumps to block . Typically, a software module includes information identifying a runtime version for which the software module is designed. For example, a Portable Executable (PE) file may include information about the runtime used to build the file in the PE header. As another example, a manifest may include configuration information that specifies a runtime version for which the software module is designed.","Continuing in block , the component executes the process, which requested the legacy runtime version, with legacy API implementations. The component may activate the current runtime version but may inform the runtime that APIs should return results similar to a legacy version of the runtime. During the execution of the hosting executable process, the process may load and invoke one or more plug-in modules, such as third party extensions that add functionality to the hosting executable process. Continuing in decision block , if a plug-in requests a legacy runtime, then the component continues in block , else the component continues in block . In block , the component selects a legacy runtime version to bind to the plug-in. In block , the component selects a current runtime version to bind to the plug-in. Note that in this particular embodiment, if the hosting executable is running using a current (e.g., side-by-side aware) version of the runtime, then legacy plug-ins also run against that version of the runtime, regardless of the version requested by the plug-ins. Non-legacy plug-ins will run using the side-by-side aware version of the runtime against which they were built or designed. Other outcomes can be configured using the configuration policy described herein. After block , these steps conclude.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5","FIGS. 5 and 6"],"b":["510","520","550","520","540","530","530","540"]},"Continuing in decision block , if the executable is a managed executable, then the component continues at block , else the component continues at block . In block , the component binds the legacy API to the runtime version associated with the executable. Continuing in decision block , if the legacy APIs are passed a version number, then the component continues at block , else the component jumps to block . Continuing in block , the component binds the legacy APIs to the version passed to the APIs. Thus, as illustrated by these steps the runtime activation system can be configured to alter the binding of legacy APIs based on a variety of criteria. After block , these steps conclude.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 6","b":["610","620","650","620","630","640","630","640"]},"Continuing in decision block , if the legacy APIs are passed a version number, then the component continues at block , else the component continues at block . In block , the component binds the legacy API to the runtime version passed to the APIs. Continuing in decision block , if the executable is a managed executable, then the component continues at block , else the component jumps to block . Continuing in decision block , if the executable was built for a legacy runtime version, then the component continues at block , else the component continues at block . In block , the component binds the legacy APIs to the version associated with the executable. In block , the component leaves the legacy APIs unbound. After block , these steps conclude.","In some embodiments, the runtime activation system provides a high compatibility policy so that an application, component, or plug-in executes using the runtime for which it was built. The system may provide an interface (e.g., ICLRMetaHostPolicy) through which an application can obtain information about the policy and can select the high compatibility policy. In addition, the system may allow this policy to be modified via a configuration setting.","In some embodiments, the runtime activation system treats communication between modules in a process using different runtime versions similar to cross-process communication. For example, for cross-process communication the runtime may perform marshaling of calls and data that is not typically performed between components in the same process. Although treating the communication in this manner may hurt performance, the added isolation boundary helps to ensure compatibility between the components.","From the foregoing, it will be appreciated that specific embodiments of the runtime activation system have been described herein for purposes of illustration, but that various modifications may be made without deviating from the spirit and scope of the invention. For example, although legacy versions of the runtime are described herein as those that do not support side-by-side runtimes, those of ordinary skill in the art will appreciate that other variations between runtime versions can cause runtime incompatibilities for which the system described herein provides a configurable solution. Accordingly, the invention is not limited except as by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
