---
title: Systems and methods for managing data in complex containers
abstract: Systems and methods for managing data in complex containers permit atomic addition of a plurality of data items to the containers. Each data item can occupy contiguous memory locations, although the plurality of data items may be mutually discontiguous. The method comprises creating a package object, which comprises an externally accessible array of pointer and associated integers. Each pointer points to the start of a memory location holding a distinct data item and the associated integer represents the size of the data item referenced by the pointer. A function associated with an external interface of the container determines a quantity of memory to hold the plurality of data items and invokes an externally accessible write function in the package object to add the plurality of individual data items to the container at specified locations if there is adequate memory available to hold the plurality of data items.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782094&OS=08782094&RS=08782094
owner: Konica Minolta Laboratory U.S.A., Inc.
number: 08782094
owner_city: San Mateo
owner_country: US
publication_date: 20090930
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Technical Field","The present disclosure pertains to the field of memory management and in particular, to systems and methods for managing data in complex memory containers.","2. Description of Related Art","Document processing software, database management systems, computer graphics, document printing, and other software applications often use complex memory containers to hold data for processing. These complex containers, which can include code and data, permit representation of multiple relationships between various objects (or portions of these objects) that are held in the containers.","For example, during document processing Page Description Language (\u201cPDL\u201d) descriptions, which provide a high-level portrayal of each page in a document, may be parsed and converted to an intermediate form\u2014termed a display list\u2014prior to rasterization. The display list (\u201cDL\u201d), which can hold objects, including commands called display list primitives, is a type of complex container with an elaborate data structure. In some instances, the DL may be comprised of a linked list of linked lists, with the nodes of the latter referencing memory blocks, which, in turn, may contain data from multiple graphical objects. Partly on account of this complexity, the internal structure of complex containers (such as the display list) is typically hidden from its clients and the complex container (hereinafter \u201ccontainer\u201d) may provide an external functional interface to clients to add entire objects, or object data to the container. The functional interface often specifies that the object or object portions to be added to the container be placed in a contiguous memory block prior to invocation of the functional interface.","In some instances, however, such as during print data processing, specific portions of graphical objects, which are not contiguous in memory, may be selected for addition to the display list. In other words, each portion of the graphical object selected for addition to the DL may reside in a memory location that is not contiguous with any other selected portion of the same graphical object i.e. the object portions are mutually discontiguous.","In traditional schemes, when non-contiguous portions of graphical objects are selected for addition to a DL, the DL functional interface may be called multiple times to add each distinct portion. In such situations, it becomes difficult for the program code associated with the DL functional interface to guarantee the atomicity of the transaction as a whole. For example, memory may be unavailable after one portion of the graphical object has been written to the DL.","Another approach calls the functional interface associated with the DL to add the entire graphical object to the DL. However, adding the entire graphical object to the DL can be an extremely inefficient use of memory resources because the portions of the graphical object selected for addition to the DL may be small in size relative to the size of the entire object. A third approach copies the selected portions of the graphical object in sequence into a contiguous memory block and prior to invoking the functional interface to add the memory block to the DL. The additional copy step contributes to processing delays.","In general, conventional schemes for the addition of mutually discontiguous data items to complex containers in a given order use memory inefficiently, may be slow, and\/or incapable of guaranteeing the atomicity of the entire transaction. Thus, there is a need for systems and methods to efficiently allow the addition of non-contiguous data items to containers while guaranteeing the atomicity of the entire transaction.","Consistent with disclosed embodiments, systems and methods for atomically adding a plurality of data items to complex containers are disclosed. Each individual data item can occupy physically contiguous memory locations, while the individual data items that comprise the plurality of data items may be mutually discontiguous. In some embodiments, a method for atomically adding a plurality of individual data items to a complex container can comprise: creating a package object, which comprises: an externally accessible array comprising of pointer-integer pairs, wherein each pointer points to the start of a memory location for a distinct individual data item and each pointer is associated with an externally accessible integer that represents the size of the data item referenced by the pointer. The package can also comprise an externally accessible size function that provides the cumulative size of the plurality of individual data items, and an externally accessible write function that writes the individual data items in sequence to a destination address, the sequence being determined by the order in which pointers that reference the data item appear in the array. The method further comprises invoking a function associated with an external interface of the complex container, wherein the function: determines a quantity of memory to hold the plurality of data items, and invokes the externally accessible write function to add the plurality of individual data items to the container at locations supplied by the external interface, if the memory available to hold the plurality of data items is not less than the determined quantity of memory.","Embodiments disclosed also relate to methods created, stored, accessed, or modified by processors using computer-readable media or computer-readable memory. These and other embodiments are further explained below with respect to the following figures.","In accordance with embodiments reflecting various features of disclosed embodiments, systems and methods for managing data in complex container are presented.  shows a block diagram illustrating components in an exemplary computer system capable of running applications capable of using and managing data in complex containers. A computer software application consistent with disclosed embodiments may be deployed on a network of computers, as shown in , that are connected through communication links that allow information to be exchanged using conventional communication protocols and\/or data port interfaces.","As shown in , exemplary system  includes computers including a computing device  and a server . Further, computing device  and server  may communicate over a connection , which may pass through network , which in one case could be the Internet. Computing device  may be a computer workstation, desktop computer, laptop computer, or any other computing device capable of being used in a networked environment. Server  may be a platform capable of connecting to computing device , database , and other devices (not shown).","Computing device  and server  may be capable of executing software (not shown), such as database management systems (\u201cDBMS\u201d), graphics and image processing software, and document processing and printing software. For example, documents may be pre-processed by computer  and\/or server  prior to being sent to printer . Database  may be coupled to server  and may also be coupled to and accessible over network . For example, computer  may be able to access database  over network .","Exemplary printer  includes devices that produce physical documents from electronic data including, but not limited to, laser printers, ink-jet printers, LED printers. Exemplary printer  may take the form of a plotter, facsimile machine, multi-function device, and\/or a digital copier. In some embodiments, printer  may also be capable of directly printing documents received from computing device  or server  over connection . In some embodiments such an arrangement may allow for the direct printing of documents, with (or without) prior pre-processing by computing device  or server . In some embodiments, documents may contain one or more of text, graphics, and images.","Printer  may include one or more of a CPU, firmware, memory, input-output ports, print engine, and secondary storage device. Printer  may also contain other Application Specific Integrated Circuits (ASICs), and\/or Field Programmable Gate Arrays (FPGAs). In some embodiments, printer  may also be capable of executing software including a printer operating system and other appropriate application software. Printer memory and\/or firmware may hold instructions and data including but not limited to a boot-up sequence, pre-defined routines including routines for managing data in containers, memory management routines, and other code. Routines may include code to translate page descriptions received from computing device  to DLs. In some embodiments, printer  may receive PDL descriptions of documents for printing. Note, too, that document print processing can be distributed. Thus, computing device , server , and\/or the printer may perform portions of document print processing such as half-toning, color matching, and\/or other manipulation processes before a document is physically printed by printer .","Computing device  and printer  may also contain removable media drives such as removable media drive . Removable media drive  may include, for example, solid state drives, portable hard disks, CD-ROM drives, DVD ROM drives, CD\u00b1RW or DVD\u00b1RW drives, USB\u2122 flash drives, memory card readers, and\/or any other removable media drives consistent with disclosed embodiments. In some embodiments, portions of the software application may reside on removable media and be read and executed by computing device  or printer .","Connection  couples computing device , server , and printer  and may be implemented as a wired or wireless connection using conventional communication protocols and\/or data port interfaces. In general, connections  can be any communication channel that allows transmission of data between the devices. In one embodiment, for example, the devices may be provided with conventional data ports, such as parallel ports, serial ports, Ethernet, USB\u2122, SCSI, FIREWIRE\u2122, and\/or coaxial cable ports for transmission of data through the appropriate connection. The communication links could be wireless links or wired links or any combination consistent with disclosed embodiments that allows communication between the various devices.","Network  could include a Local Area Network (LAN), a Wide Area Network (WAN), or the Internet. Printer  may be connected to network  through connection . In some embodiments, printer  may also be connected directly to computing device  and\/or server . System  may also include other peripheral devices (not shown), according to some embodiments. A computer software application consistent with the disclosed embodiments may be deployed on any of the exemplary computers and\/or printers, as shown in . For example, computing device  could execute software that may be downloaded directly from server . Portions of the application may also be executed by printer  in accordance with disclosed embodiments. Note that components of system  may be physically distributed or integrated into a single apparatus.","In one embodiment, computing device  may transform document data into a first printable data, which can take the form of a PDL description of a document. Then, the first printable data can be sent to printer  for transformation into intermediate printable data, which can take the form of a container such as a DL. Printer  may transform intermediate printable data into a final form of printable data and print according to this final form, which may take the form of a pixmap. In some embodiments, the display list may reside in memory on one or more of printer , computing device , and server . In another embodiment, computer  may hold various data items in a record, and selected data items from the record may be added to a container, prior to being written to database  by routines associated with the DBMS. In some embodiments, memory allocated to store objects in containers such as display lists may be dynamically allocated and released.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 2","FIG. 2"],"b":["200","283","200"]},"On one hand, in accordance with disclosed embodiments, architecture  permits memory in memory pool  to be allocated and released using memory manager . For example, memory manager  can allocate memory in blocks to prevent memory fragmentation and can abstract away implementation details pertaining to memory management through memory management Application Programming Interface (\u201cAPI\u201d) . In some embodiments, memory manager  may permit the sharing of memory pool across several sub-applications of application . For example, if application  takes the form of a print processing application, then memory manager may permit memory in memory pool  to be shared between display list code and framebuffer management code.","In one embodiment, routines in memory manager  may manage some subset of available memory as memory pool  and allocate memory from memory pool  to requesting processes through memory management API . When memory is no longer needed by the requesting processes, the memory may be de-allocated and returned to memory pool , where it can be made available to other processes. Thus, exemplary memory manager  may also provide various other memory management functions, including routines to free memory, routines to recover memory, and swapping routines that can swap memory to secondary storage.","On the other hand, application , which can comprise application specific code  and application library , may allow application data to be viewed logically as an integral unit while permitting application data to occupy discontiguous memory blocks allocated from memory pool  by leveraging the functionality provided by memory manager  through memory management API . Application  may take various forms, including, but not limited to, a database management application, a graphics processing application, an image processing application and\/or a print processing application. In situations where application  takes the form of a print processing application, then the print processing application may allow pixmaps in framebuffers to be physically distributed while permitting the pixmap to be viewed logically as an integral unit. The term pixmap (or pixel map), which is related to bitmap, is used to denote a raster image that can exist at a number of bit depths. A bitmap is a type of memory organization used to store digital images, in which each pixel is assigned a single bit (i.e. the pixel is either \u201con\u201d or \u201coff\u201d).","Additionally, application specific code  and application specific libraries  may use package API  associated with package  to add discrete objects to complex container  through container external interface . For example, as shown in , exemplary \u201cpackage.AddData( )\u201d function associated with package  may be used to specify data for addition to container . Package  may also comprise private package internal code and structure . Package API  may also include externally accessible functions such as \u201cpackage.GetSize( )\u201d and \u201cpackage.Write( )\u201d, which may be used by functions associated with container external interface  to permit the addition of data items, which may occupy mutually discontiguous memory locations, to container  in a manner that guarantees both atomicity and serialization. These functions are described further in conjunction with the description of  below.","In some embodiments, container external interface , may include functions that specify or use a minimum granularity in terms of data size for data to be added to the container. In addition, these functions may also specify that any data to be added to container , should appear serially in physically contiguous memory to guarantee serialization and to ensure atomicity of the transaction, respectively. Atomicity refers to the indivisibility of the transaction i.e. the entire operation on the data will either succeed or fail. Serialization refers to the property by which transaction data will appear, at least logically, in the order in which they were presented to the container.","In some embodiments, container external interface may be enhanced by the addition of additional functionality that facilitates the addition of portions of objects or multiple objects\u2014which may occupy mutually discontiguous memory locations\u2014to container  in a manner that guarantees both atomicity and serialization. For example, in some implementations, the additional functionality provided by container external interface  may be made available through an additional externally accessible function\u2014such as \u201ccontainer_addPackage( )\u201d described below.","Note that container  may have a complicated internal structure, comprising private container code  and private container structure , which may depend, in part, on the functions supported by complex container . Therefore, external or public interface  may be used to permit access to objects within complex container  and to permit the addition, deletion, and manipulation of data within complex container  without revealing internal or private details of the structure and code associated with container . Further, complex container  may comprise private container internal code  that operates on data in private container internal structure  based on parameters received by container external interface  from package API .","In some embodiments, after data has been successfully added to container , container external interface  may return a \u201csuccess\u201d code to package API . If the transaction fails, a \u201cfailure\u201d code may be returned and package API  may take appropriate corrective action based on the nature of the failure. Architecture  allows container  to manage internal structural and organizational complexities and request and release memory as needed from memory manager  through memory management API . Finally, memory manager  can focus on managing memory resources in memory pool  and preventing fragmentation by allocating and releasing memory in blocks or multiples of block units.","In some embodiments, package API  may also include routines to permit access to enhanced functionality provided by container external interface . The enhanced functionality may permit the addition of portions of objects or multiple objects\u2014which may occupy mutually discontiguous memory locations\u2014to container  in a manner that guarantees both atomicity and serialization.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3","b":["300","260","283"]},"In some embodiments, package , may comprise an array of pointers and integers, such as bundle . In some embodiments, a pointer (shown as data type void*) in bundle  can point to a contiguous portion of data, which can be added to container ; and an integer (shown as data type unsigned int) in bundle , which is associated with the pointer, can hold the size of the portion of data pointed to by its associated pointer. For example,  shows exemplary bundle  as comprising pointers \u201cdata_p\u201d with associated integers \u201cdata_size\u201d words. The prefix \u201c+\u201d indicates that the fields\/functions are public i.e. visible outside package , while the prefix \u201c\u2212\u201d indicates that the fields\/function are private and may form part of private package internal code and structure .","In addition, as shown in , package  can specify a maximum number of bundles , indicated by MAX_BUNDLES, that is supported by package . Package  can also include private section, comprising private internal code and structure , which are internal details not visible externally. Further, as shown in , package  can comprise Package API , which includes public such as AddData( ), GetSize( ), and Write( ), which may receive parameters and output results in accordance with the received parameters. For example, the function Package.GetSize( ) may be invoked to obtain the cumulative size of the data referenced by pointers in the pointer array. As another example, Package.Write( ) may be invoked with appropriate parameters to traverse the array of pointer-integer pairs in sequence and copy the specified number of bytes (indicated by data_size) from a specified memory location (indicated by data_p) to the destination memory location.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["400","283","260","400","245","400"]},"After invocation, algorithm  may perform initialization where package  is instantiated. In step , a pointer-integer pair is assigned to the first data item. The data item may be contiguous piece of data from an object, or the first contiguous object that is to be added container . Note that while data item is contiguous, the plurality of data items need not be physically contiguous (i.e. they can be mutually discontiguous) with other data items. The pointer points to the start of the first data item, while the integer associated with the pointer indicates the size of the data item. In some embodiments, the pointer-integer pairs may correspond to the pointers and associated integers in bundle  of package .","In step , the algorithm checks whether there are additional data items that are to be added container . If there are additional data items (\u201cY\u201d in step ), the algorithm proceeds to step , where a pointer-integer pair is assigned to the next contiguous data item that is to be added container . The algorithm then iterates through step  and  until all data items (\u201cN\u201d in step ) have been added to package . Then, in step , container external interface routine  may be invoked to add data items in package  to container .","In some embodiments, code associated with container external interface routine  may process package  by querying the total size of the data to be written from the package (for example by using Package\u2192GetSize( )), requesting any additional memory from memory manager  through memory management API  as appropriate; allocating that memory (if any was requested and received); obtaining a pointer to the memory being used; and then having package write its contents to that memory location by invoking a publicly accessible external function such package\u2192Write(mem_p), which can be part of public package API  of package . When a function such as package\u2192Write(mem_p) is invoked, the array of pointer-integer pairs can be traversed in sequence and the specified number of bytes may be copied from the specified memory location to the destination memory location, which, in some instances, may be provided by private container internal code . Note that serialization can be guaranteed when the array of pointer-integer pairs is traversed in sequence.","Thus, container  is oblivious to the distribution of data being written to the container, application specific code  need not be concerned with details of the structure and organization of container . Further, the entire transaction in step  can occur through a single functional call, such as to exemplary container_AddPackage( ) above, which can guarantee the atomicity of the transaction because any memory requested from memory manager  is requested with knowledge of the total size of the data to be written from package , thereby ensuring that adequate memory is available prior to commencing the transaction.","Note that the embodiments described may be applicable to a variety of applications. For example, in a database management application, where serialization and atomicity are important, the methods described may used to write data to a complex containers associated with the DBMS in a manner that guarantees both atomicity and serialization. The disclosed methods and other embodiments, as would be apparent to one of ordinary skill in the art, may also be incorporated on computer readable media and\/\/or computer readable memory. In some embodiments, the methods may be implemented in computer system  using one or more of computer , server , and\/or printer .","Other implementations will be apparent to those skilled in the art from consideration of the specification and practice of disclosed embodiments. It is intended that the specification and examples be considered as exemplary only, with its true scope and spirit being indicated by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
