---
title: Query-driven partial materialization of relational-to-hierarchical mappings
abstract: Techniques are provided for automatically rewriting a relational-to-hierarchical mapping into one or more modified mappings. In this way, clients that prefer or require different portions of the mapping-defined data are supported. For example, in one aspect of the invention, a technique for modifying a relational-to-hierarchical mapping in accordance with at least one user query includes the following steps/operations. At least one query associated with a query language that supports a hierarchical data structure is obtained. Further, at least one relational-to-hierarchical mapping for use in translating data associated with a relational data structure into data associated with the hierarchical data structure is obtained. Then, the at least one relational-to-hierarchical mapping is modified based on the at least one query such that data specifically relevant to the at least one query may be generated in accordance with the modified relational-to-hierarchical mapping.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07469249&OS=07469249&RS=07469249
owner: International Business Machines Corporation
number: 07469249
owner_city: Armonk
owner_country: US
publication_date: 20040308
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["This invention relates to database query techniques and more specifically to producing hierarchical structures containing data obtained from relational databases.","Data sets are frequently communicated or delivered in hierarchical data structures. Such hierarchical data structures can be stored in structured documents, such as eXtensible Markup Language (XML) documents. XML documents, for example, are widely accepted by various processing programs and data exchange systems, wherein the data in the XML document is used directly or transformed into a data structure used by the receiving program or system.","In contrast to the communications and delivery of data, database systems are generally used to store and manipulate data. Relational database systems are a popular type of database system due to the many widely known benefits to storing and manipulating data stored in relational databases. Relational databases are generally maintained by software systems that are referred to as Relational Database Management Systems (RDBMS). RDBMSs are generally able to be distributed among two or more computer nodes that are able to be physically and even geographically separated. An enterprise is also able to distribute data among multiple RDBMSs that are hosted on different computers. Retrieval of a complete set of data for a particular request in such enterprises then requires access to the multiple RDBMSs.","A common data manipulation process is the publishing of data out of a database in an XML format. This is currently done by specifying a mapping from a relational database to a hierarchical structure.","Typically, the generated hierarchical structure is exported to multiple clients. Each client subsequently queries this structure via an XML query language such as XML Query, eXtensible Stylesheet Language (XSL) or XML Path Language (XPath). The queries executed by a client will typically explore only a limited portion of the generated XML data, and each client will explore different portions of the data. Therefore, an XML document, which can be quite large and which is not going to be used in its entirety, is generated and transmitted.","Accordingly, there is a need for improved techniques for generating and transmitting documents such that each client may receive only the data that is relevant for its queries.","Techniques for use in, for example, generating and transmitting documents are provided in accordance with principles of the present invention. More particularly, techniques are provided for automatically rewriting a relational-to-hierarchical mapping into one or more modified mappings. In this way, clients that prefer or require different portions of the mapping-defined data are supported. Such modified mappings may thus be considered \u201cquery-driven partial materializations\u201d of the original mappings.","In one aspect of the invention, a technique for modifying a relational-to-hierarchical mapping in accordance with at least one user query includes the following steps\/operations. At least one query associated with a query language that supports a hierarchical data structure is obtained. Further, at least one relational-to-hierarchical mapping for use in translating data associated with a relational data structure into data associated with the hierarchical data structure is obtained. Then, the at least one relational-to-hierarchical mapping is modified based on the at least one query such that data specifically relevant to the at least one query may be generated in accordance with the modified relational-to-hierarchical mapping.","Further, the step\/operation of obtaining at least one query associated with a query language that supports a hierarchical data structure further includes obtaining at least one query associated with an extensible Markup Language (XML) based query language such as, for example, XML Query, eXtensible Stylesheet Language (XSL) or XML Path Language (XPath).","Still further, the technique further includes the step\/operation of analyzing the at least one query to identify one or more expressions associated with the at least one query. The one or more expressions may include one or more XPath expressions. The one or more XPath expressions may be normalized.","The step\/operation of modifying the at least one relational-to-hierarchical mapping based on the at least one query may further include the steps\/operations of: (i) applying each of the one or more expressions respectively to one or more tagging trees defining the relational-to-hierarchical mapping, each tagging tree including one or more nodes, and attaching one or more formulas to appropriate nodes in each tagging tree; (ii) marking the tagging tree nodes traversed during the expression application step as visited; (iii) marking the node corresponding to an output node of the expression as an end node; (iv) superimposing the modified tagging trees respectively resulting from the application of each expression to form a resulting tagging tree; and (v) removing the nodes not marked as visited from the resulting tagging tree, the resulting tagging tree representing the modified relational-to-hierarchical mapping.","At least a portion of the one or more formulas may be pushed up from a child node of a tagging tree to a parent node of the tagging tree so as to further limit the amount of data being generated. At least a portion of the one or more formulas may be pushed down from a parent node of a tagging tree to a child node of the tagging tree so as to prune one or more irrelevant subtrees of the tagging tree.","The step\/operation of applying an expression to a tagging tree may include the steps\/operations of: (i) parsing the expression into constituent main steps and zero or more predicate expressions; (ii) recursively traversing the tagging tree according to the current step in the expression; and (iii) using the predicate expressions to generate one or more formulas reflecting one or more conditions to be imposed on generated data and attaching the one or more formulas to the nodes that generate the data involved in the expression.","In another aspect of the invention, a technique for generating a hierarchically structured document in response to at least one user query includes the following steps\/operations. At least one query associated with a query language that supports a hierarchical data structure is obtained. At least one relational-to-hierarchical mapping for use in translating data associated with a relational data structure into data associated with the hierarchical data structure is obtained. The at least one relational-to-hierarchical mapping is modified based on the at least one query. Then, a hierarchically structured document including data specifically relevant to the at least one query is generated in accordance with the modified relational-to-hierarchical mapping.","Furthermore, it is to be appreciated that a tagging tree may include a plurality of nodes and each of the plurality of nodes may have a node type. Node types may include element nodes and attribute nodes. Each tagging tree node may be annotated with a formula that specifies the data to be inserted at that location in the data generation process. The techniques of the invention may further include the step\/operation of traversing at least one node of the tagging tree and retrieving, in response to traversing an execution node, a data object from the at least one relational database as specified in the execution node. The techniques may further include inserting, in response to a data node and based upon the mapping, the data object into an output conforming to the hierarchical structure.","Each modified mapping may reflect a query workload of a client and results in the generation of data that are relevant for that workload. The techniques of the invention may include transforming XPath expressions into normalized XPath expressions that contain only self and child axes navigational steps, applying these normalized path expressions to the tagging tree defining the relational-to-hierarchical mapping, and propagating conditions from the predicates present in the path expression to the appropriate nodes of the tagging tree.","In yet another aspect of the invention, a mapping rewriting processor includes query workload analyzer and a tagging tree transformation processor that modifies a tagging tree in accordance with the query workload. The query workload analyzer may examine the queries in a given workload and produce normalized XPath expressions corresponding to this workload. The tagging tree transformation processor may further have a runtime environment that traverses at least one node of the tagging tree and modifies the formula annotating this node in accordance with a normalized path expression from the workload.","These and other objects, features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof, which is to be read in connection with the accompanying drawings.","It is to be understood that while the present invention will be described below in the context of XML documents and relational databases, the invention is not so limited. Rather, the invention is more generally applicable to any document type and database type in which it would be desirable to provide techniques for generating and transmitting documents such that each client may receive only the data that is relevant for its queries.","As will be described in detail below, exemplary embodiments of the present invention provide for rewriting a relational-to-hierarchical mapping into several modified mappings, in accordance with client query workloads. The relational-to-hierarchical mapping is specified at the schema level, rather than at the instance level, and is represented as a tagging tree. One or more XML DTDs (Document Type Definitions) or XML Schema define the structure of XML data objects. Database schemas define the structure of the relational data.","Exemplary embodiments of the present invention are capable of being advantageously applied to tasks in a variety of applications such as, by way of example only, data management, business-to-business message exchange, and content management. An especially advantageous application is the custom transformation of relational data to specific XML dialects such as HTML (Hypertext Markup Language), VXML (Voice XML) and WML (Wireless Markup Language), in order to support various display devices and specific client workloads.","The principles of mapping rewriting according to the invention address many challenging issues such as: (1) analyzing the query workload and producing a set of normalized XPath expressions; (2) using a normalized XPath expression to determine which parts of the tagging tree are relevant; (3) using a normalized XPath expression to determine which formulas to attach at different nodes in the tagging tree in order to restrict the generation of data to relevant data for this expression; and (4) combining the effects of rewritings from a plurality of normalized XPath expressions on the same tagging tree.","The illustrative methodology described herein completes the mapping rewriting in two steps. The first part is a query analysis and normalization step. The queries in the workload are processed one at a time and rewritten into normalized XPath expressions. The second part is a tagging tree rewriting step. Each normalized path expression is processed in turn and results in various formulas being attached to specific nodes of the tagging tree. The resulting modified tagging trees are then superimposed by disjoining the formulas attached to the same node.","Referring initially to , an exemplary data transformation diagram according to an exemplary embodiment of the present invention is illustrated. More particularly, the data transformation diagram illustrates an exemplary RDBMS set of tables and a resulting published XML document generated in accordance with an exemplary embodiment of the present invention.","The RDBMS  in this example contains a number of tables. Illustrated in the RDBMS  in this example are three tables that contain a description of one purchase order. These three trivially simple tables are illustrated here for ease of understanding of the publishing process. The exemplary embodiment operates with one or more RDBMSs that maintain complex database tables. These three tables could also be visualized as results sets that would be produced by conventional processing, which would execute the two exemplary queries in series to produce these result sets from a more populated set of database tables. The operation of the exemplary embodiment would not, however, explicitly produce these results sets but rather produce the outer-union result set described below.","The \u201cORDERS\u201d table  in this illustration is shown to contain one row that contains a description of a purchase order (PO) that is stored in the RDBMS . This purchase order has an ID element containing \u201c,\u201d which is an identification number used only by the RDBMS  to identify this purchase order and related elements in the same or other tables maintained by this RDMBS . This purchase order also has a customer element containing \u201cJohn Doe\u201d and a status element containing \u201cpending.\u201d An \u201cADDRESS\u201d table  contains one row that corresponds to the \u201cbill_id\u201d of \u201c5,\u201d as was identified in the \u201cPO\u201d result set . The item and quantity for the items on this purchase order is similarly contained in a third table  called \u201cORDERLINE\u201d.","The data in the RDBMS  is published to a generated XML document  as illustrated. A first tag  identifies the XML version in use by this document. A root tag  specifies the root name for this structured document. Within the \u201cpolist\u201d section of this document is a subsection with a \u201cpo\u201d tag . The \u201ccustomer\u201d element  and \u201cstatus\u201d element  correspond to data contained in the \u201cPO\u201d table . The \u201cbillto\u201d section  of this document has a subsection \u201caddress\u201d whose data corresponds to the data contained in the \u201cADDRESS\u201d table. The \u201cID\u201d element, which identifies the purchase order for the RDBMS , is not included in this structured XML document since the data relationships are denoted by the structure of the document and not by record identifiers. Further, the exemplary XML document contains one \u201corderline\u201d section that begins with an \u201corderline\u201d tag. All tags in this XML document have corresponding closing tags as is well known.","Referring now to , an exemplary multiple client scenario according to an exemplary embodiment of the present invention is illustrated. In this exemplary scenario, a data provider uses a relational database  to store facts in tables (such as \u201cORDERS\u201d, \u201cADDRESS\u201d, \u201cORDERLINE\u201d). In order to export this data, the data provider defines a DB-to-XML mapping . This mapping could be applied as-is to generate an XML document  composed of a hierarchical representation of the entire collection of facts present in the tables of the relational database. However, shipping this document to clients would be inefficient, especially if the clients are interested only in a relatively small portion of the data. This is why we refer to the XML document  as \u201chypothetical XML data\u201d.","Instead, the system of the present invention generates a custom XML document for each client, containing relevant data for that client. For example, consider a client C() that plans to run the set of queries QS={q, . . . , q}, referred to as a \u201cquery workload\u201d. The system of the present invention analyzes the set of queries QSand generates a custom XML document  to be shipped to client C. Similarly, the system generates a custom XML document for each client according to its query workload.","Referring now to , an exemplary tagging tree  according to an exemplary embodiment of the present invention is illustrated. Tagging trees as are used by exemplary embodiments of the present invention have nodes that can be one of two node types and can be annotated with formulas that have been defined for a tagging tree by the particular embodiment. The two node types and their formulas define the features of the transformation from a relational database to the hierarchical data structure of the XML output document.","The two tagging tree nodes types are: element and attribute. Element nodes contain an element name and have as children zero or more attribute nodes and zero or more element nodes. Element nodes generate XML elements composed of a start tag (e.g., \u201c<po>\u201d), variable length contents, and an end tag (e.g., \u201c<\/po>\u201d). Attribute nodes contain an attribute name. Attribute nodes generate XML attribute expressions of the form \u201cattribute name=attribute value\u201d that are inserted inside the start tag of the element generated by the parent element node.","The nodes in the exemplary tagging tree  are annotated with formulas, as shown in . The element node \u201cpo\u201d  is annotated with an SQL (Structured Query Language) query that retrieves all the rows from table \u201cOrders\u201d and binds them to a variable x. The element node \u201cbillto\u201d  is annotated with an SQL query that retrieves the address row from the table \u201cAddress\u201d such that the identifier of this address (the ID column) matches the BILL_ID column of the current row extracted from the Orders table. This results in the extraction of the billing address for the current purchase order and its binding to a variable z. Similarly, the SQL query annotating the element node \u201corderline\u201d  extracts all the rows from the Orderline table that have in the PO_ID column a value that matches the ID of the current Orders row.","The leaf nodes in the exemplary tagging tree  are annotated with formulas that specify the value to be inserted in the generated data tree. Thus, for example, the \u201ccustomer\u201d element node  is annotated with the expression \u201cx.customer\u201d indicating that its value should be extracted from the CUSTOMER column of the current row that is bound to the variable x.","Referring now to , a typical query workload and the result of a normalization algorithm according to an exemplary embodiment of the present invention is illustrated. The exemplary query workload  as shown in  includes four XPath queries. For example, the query  requests the \u201citem\u201d information for all the purchase orders whose status is \u201cprocessing\u201d. The query  is not in normal form because it contains the \u201cdescendant-or-self\u201d axis navigation step \u201c\/\/item\u201d that indicates that the \u201citem\u201d element is to be found as a descendant node at any depth from the previous node in the expression \u201cpo\u201d. The normalized query workload is denoted as .","The normalization algorithm in an exemplary embodiment of the present invention identifies all the possible matches between the path expression  and the tagging tree  by simulating the execution of the path expression  on the tagging tree . The result of this simulated execution is the normalized path expression . The expression conforms to the non-abbreviated XPath syntax in accordance with the XPath standard defined by the World Wide Web Consortium Recommendation \u201cXML Path Language (XPath)\u201d available at http:\/\/www.w3.org\/TR\/xpath. Although in this simple example there was a single normalized expression produced, in general, the algorithm produces a plurality of normalized expressions, one for each possible match between the original path expression and the tagging tree.","Another result of the normalizing algorithm is a plurality of \u201cmatching maps\u201d. A matching map associates each step of a normalized path expression with a node in the tagging tree such that the first step is mapped to the root node, the element names match and the parent-child relationship is preserved. Thus, for example, the \u201croot\u201d step of expression  is mapped to the root of the tagging tree, the \u201cchild::polist\u201d is mapped to the \u201cpolist\u201d node, the \u201cchild::po\u201d step is mapped to the \u201cpo\u201d node, the \u201cchild::status=\u201cprocessing\u201d\u201d step inside the predicate expression is mapped to the \u201cstatus\u201d node, the \u201cchild::orderline\u201d is mapped to the \u201corderline\u201d node, and the \u201cchild::item\u201d node is mapped to the \u201citem\u201d node.","Referring now to , a modified tagging tree corresponding to the workload in  according to an exemplary embodiment of the present invention is illustrated. More particularly,  depicts modified tagging tree . As shown, the formula attached to node \u201cpo\u201d has been modified by adding a disjunction of conditions about the status of the order that result from the application of the rewriting algorithm on the queries in the query workload . Similarly, the formulas attached to the \u201cbillto\u201d and \u201corderline\u201d nodes have been modified as a result of the \u201cformula push-down\u201d (as will be explained below in step  of ).","Referring now to , mapping rewriting stages according to an exemplary embodiment of the present invention are illustrated. The mapping rewriting stages are as follows: each query Q in the query workload QS is examined and the tagging tree is modified according to the current query (step ). Each query Q may have a plurality of matching maps m that associate the steps of Q to nodes in the tagging tree T. Each such matching map m is considered in turn (step ) and the following steps are performed for each matching map: (a) the formulas attached to nodes of T are modified according to the algorithm AssocF (given in  and described below); (b) all the nodes to which the matching map m maps the steps of Q are marked as \u201cvisited\u201d and the node to which the matching map m maps the last major step of Q is marked as \u201cend\u201d node; (c) optionally, some formulas are \u201cpushed up\u201d to ancestor nodes (\u201cpush up\u201d step described below).","After all of the above steps have been performed for all the queries and the matching maps associated to them, the tree is pruned by eliminating all the nodes not marked as \u201cvisited\u201d together with all the edges leading to them (step ). Step  is an optional step consisting in \u201cpushing down\u201d some of the formulas attached to nodes in the tagging tree to further limit the number of sub-trees being generated. Finally, in step , the data tree is generated by traversing the modified tagging tree in a top-down fashion and retrieving the data from the relational database according to the modified formulas attached to the nodes (as described above in accordance with ).","Referring now to , an algorithm is illustrated for attaching formulas to nodes of the tagging tree for a given query and matching of this query to the tagging tree according to an exemplary embodiment of the present invention.","More particularly, the algorithm depicted in  is a recursive procedure, named AssocF, which associates formulas to nodes in the tagging tree. A goal of the algorithm is to restrict the corresponding image data to data that is relevant to the normalized expressions in the query workload.","Consider a normalized expression e in the query workload and a matching map denoted m that maps each step in e to a node in tagging tree T. We now describe how the procedure AssocF modifies the formulas attached to the nodes on T based on map m.","The algorithm AssocF examines the parsed normalized expression e and the tree T in the context of the matching map m. Inductively, once the algorithm is called with a node v in T and a parsed sub-expression, it returns a formula F which represents conditions that must hold at that node v for the recursive call to succeed in a data tree generated from Tat the corresponding image node.","Some of the formulas returned by AssocF, the ones corresponding to Predicate* sequences on the major steps of e, are attached to tree nodes (at lines  and ), the others are simply returned to the caller with no side effect. The information about whether the algorithm AssocF is currently processing a major step is encoded in the Boolean parameter is Major.","Let v.formula be the original formula labeling the node v in the tagging tree T; in case of a data annotation, the formula is v.annotation !=NULL; in case of no annotation at all, v.formula is True.","Initially, the algorithm is invoked as follows: AssocF(root, e, True).","At this point, let us review the effect of AssocF. Consider a matching map m for normalized expression e. Let Step_\/ . . . \/Step_N be the major steps in the major path of e, that is, those steps not embedded within any brackets [ . . . ]. Let v_, . . . , v_N be the respective nodes of T to which m maps Step_, . . . , Step_N. Algorithm AssocF attaches formulas G_, . . . , G_N that will specify the generation of image data for node v_i only if all predicates applied at Step_i are guaranteed to hold. In other words, image data generation for nodes along the major path of e is filtered.","Note that this filtering holds only for the current matching m. In order to reflect the changes mandated by all the matching maps for all the path expressions in the query workload, the rewritings triggered by each matching map are superimposed.","Algorithm AssocF handles one matching map m of an expression e. Let m\u2032 be another matching map. Intuitively, each such matching map should be supported independently of the other.","A straightforward approach is to rewrite a formula at a node v that is in the range of some matching maps, say m_, . . . , m_k to v.formula and (F_ or . . . or F_k), where F_i is the formula attached to node v by AssocF based on matching map m_i.","The approach above may lead to unnecessary image data generation because the nodes that are descendants of v will be produced for all the rows retrieved by the query at v even if they are only needed only when a particular F_i is true (for example, in , the \u201cbillto\u201d node is needed only when the \u201cformula x.status=\u2018pending\u2019\u201d is true).","The solution is to perform an optional \u201cformula push-down\u201d step (step  in ). This step includes pushing each formula F_i to the descendants of node v that were visited during the invocation of AssocF in the context of matching map m_i. For example, in , the formula \u201cx.status=\u2018pending\u2019\u201d is pushed to the \u201cbillto\u201d node and the formula \u201cx.status=\u2018processing\u2019\u201d is pushed to the \u201corderline\u201d node.","Another optional optimization step is the formula \u201cpush-up\u201d step in . This step proceeds as follows: let v be a node in T that is not an end node or an ancestor of an end node or the image of a last step in a predicate expression. Let F be the formula attached to this node. Let vl, . . . , v_k be visited children, associated respectively with formulas \u0192_l, . . . , \u0192_k. Let x_i be the variable bound at node v_i or some other, previously unused, variable otherwise. Modify F to F\u2032=F and (Exists x_l (\u0192_l) or . . . or Exists x_k (\u0192_k)).","The intuition of this push up step is that the data generated as the image of node v is filtered by its formula as well as the requirement that this data will embed generated data for at least one child. There is no point in generating a data element e for v data does not pass this filtering. Such a data element cannot possibly be useful for data tree matching by the expression mapping implied by m.","Push-up steps may be performed in various parts of the three. The benefit of pushing lies in the further filtering of image data node generation. The cost of extensive filtering is that:","(a) resulting formulas are complex; and","(b) some computations are repeated (that is, a condition is ensured, perhaps as part of a disjunction, and then rechecked for a filtering effect further down the tree).","Therefore, there is a tradeoff for formula push-up: less \u201cuseless\u201d image data is generated, but the computation is more extensive.","Referring now to , a grammar of normalized XPath expressions is illustrated. Thus, line  states that an XPath expression is either a Root step by itself or a Root step followed by a \u2018\/\u2019 step delimiter, followed by a relative path expression RLP. Line  specifies that a relative path expression RLP is composed of either a single Step or by a Step followed by a delimiter followed by a relative path expression (note that this is a recursive definition, allowing any number of steps to be specified). Line  specifies that a Step is composed of an axis name Axis Name followed by a node test NodeTest followed by a sequence of zero or more predicates Predicate. Line  states that a Predicate is a predicate expression PredExp enclosed in angular brackets.","Line  states that a predicate expression PredExp can be one of: 1) a relative path expression RLP by itself; or 2) a relative path expression RLP followed by an expression of the form \u2018\/self::node( )\u2019 followed by a comparison operator Op followed by a constant value Value; or 3) an expression of the form \u2018\/self::node( )\u2019 followed by a comparison operator Op followed by a constant value Value.","Line  states that a comparison operator Op is one of: \u201cequal\u201d, \u201cless than\u201d, \u201cless or equal\u201d, \u201cgreater than\u201d, \u201cgreater or equal\u201d, and \u201cnot equal\u201d. Line  states that a node test NodeTest can be either a node name (an XML element name) which matches nodes with that name or the expression \u2018node( )\u2019 which matches any node. Finally, line  states that the axis name can only be one of \u2018child::\u2019 (which indicates a traversal to a child node) or \u2018self::\u2019 (which indicates that the current node is the same as in the previous step).","Referring now to , a system architecture illustrates the components of the mapping rewriter processor and the interactions between them. As shown, a Mapping Rewriter Processor  is composed of two components: a Query Workload Analyzer  and a Tagging Tree Transformation Processor , whose functions are described below.","The Query Workload Analyzer  accepts as input a query workload  composed of a plurality of XPath queries and has access to the original tagging tree defining the mapping. Based on the structure of the original tagging tree, the Query Workload Analyzer  simulates the execution of each query from the workload by traversing the tagging tree according to the steps specified in the query as described in the query normalization algorithm (presented above in the description of ). The output of the Query Workload Analyzer component is a set of normalized XPath queries  which is sent to the Tagging Tree Transformation Processor .","The Tagging Tree Transformation Processor  accepts as input an original tagging tree  and a set of normalized XPath queries  and computes a modified tagging tree . This modified tagging tree is obtained by modifying the formulas attached to the nodes of the original tree according to the algorithm AssocF (presented above in the description of ) followed by the elimination of all the nodes that were not marked as visited during the execution of the algorithm.","Many advantages flow from the use of exemplary embodiments of the present invention. By way of example, some of the advantages include:","(a) amount of data shipped to the clients is considerably reduced which results in smaller communication costs as well as query processing costs at the client site; and","(b) schema of the shipped data is the same as the original schema of the mapped hierarchical data which means that the client queries do not have to be modified in order to process this data.","It is to be appreciated that embodiments of the invention can be implemented as a program product for use with a computer system such as, for example, the computer system shown in  and described herein below. The program(s) of the program product defines functions of the embodiments (including the methods described herein) and can be contained on a variety of signal-bearing medium. Illustrative signal-bearing medium include, but are not limited to: (i) information permanently stored on non-writable storage medium (e.g., read-only memory devices within a computer such as CD-ROM disk readable by a CD-ROM drive); (ii) alterable information stored on writable storage medium (e.g., floppy disks within a diskette drive or hard-disk drive); or (iii) information conveyed to a computer by a communications medium, such as through a computer or telephone network, including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks. Such signal-bearing media, when carrying computer-readable instructions that direct the functions of the present invention, represent embodiments of the present invention.","In general, the routines executed to implement the embodiments of the present invention, whether implemented as part of an operating system or a specific application, component, program, module, object or sequence of instructions may be referred to herein as a \u201cprogram.\u201d The computer program typically is composed of a multitude of instructions that will be translated by the native computer into a machine-readable format and hence executable instructions. Also, programs are composed of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition, various programs described herein may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However, it should be appreciated that any particular program nomenclature is used merely for convenience, and thus the invention should not be limited to use solely in any specific application identified and\/or implied by such nomenclature.","It is also to be appreciated that computer programs may be organized into a variety of routines, procedures, methods, modules, objects, and the like. Also, program functionality may be allocated among various software layers that are resident within a typical computer (e.g., operating systems, libraries, application programming interfaces (APIs), applications, applets, etc.) It should be appreciated that the invention is not limited to the specific organization and allocation or program functionality described herein.","The present invention can be realized in hardware, software, or a combination of hardware and software. A system according to an illustrative embodiment of the present invention can be realized in a centralized fashion in one computer system, or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system (or other apparatus adapted for carrying out the methods described herein) is suitable. A typical combination of hardware and software could be a general purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein.","Each computer system may include, inter alia, one or more computers and at least a signal bearing medium allowing a computer to read data, instructions, messages or message packets, and other signal bearing information from the signal bearing medium. The signal bearing medium may include non-volatile memory, such as ROM, flash memory, disk drive memory, CD-ROM, and other permanent storage. Additionally, a computer medium may include, for example, volatile storage such as RAM, buffers, cache memory, and network circuits. Furthermore, the signal bearing medium may include signal bearing information in a transitory state medium such as a network link and\/or a network interface, including a wired network or a wireless network, that allow a computer to read such signal bearing information.","Referring now to , a computer system suitable for implementing mapping rewriting stages according to an exemplary embodiment of the present invention is illustrated. For example, the illustrative architecture of  may be used in implementing any and all of the components and\/or steps described in the context of .","As shown, the computer system  may be implemented in accordance with a processor , a memory , I\/O devices , and a network interface , coupled via a computer bus  or alternate connection arrangement.","It is to be appreciated that the term \u201cprocessor\u201d as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit) and\/or other processing circuitry. It is also to be understood that the term \u201cprocessor\u201d may refer to more than one processing device and that various elements associated with a processing device may be shared by other processing devices.","The term \u201cmemory\u201d as used herein is intended to include memory associated with a processor or CPU, such as, for example, RAM, ROM, a fixed memory device (e.g., hard drive), a removable memory device (e.g., diskette), flash memory, etc.","In addition, the phrase \u201cinput\/output devices\u201d or \u201cI\/O devices\u201d as used herein is intended to include, for example, one or more input devices (e.g., keyboard, mouse, etc.) for entering data to the processing unit, and\/or one or more output devices (e.g., speaker, display, etc.) for presenting results associated with the processing unit.","Still further, the phrase \u201cnetwork interface\u201d as used herein is intended to include, for example, one or more transceivers to permit the computer system to communicate with another computer system via an appropriate communications protocol.","Accordingly, software components including instructions or code for performing the methodologies described herein may be stored in one or more of the associated memory devices (e.g., ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (e.g., into RAM) and executed by a CPU.","It is to be further appreciated that the present invention also includes techniques for providing data query services. By way of example, a service provider agrees (e.g., via a service level agreement or some informal agreement or arrangement) with a service customer or client to provide data query services. That is, by way of one example only, the service provider may host the customer's web site and associated applications. Then, in accordance with terms of the contract between the service provider and the service customer, the service provider provides data query services which may include one or more of the methodologies of the invention described herein. By way of example, this may include generating a hierarchically structured document in response to at least one user query.","Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
