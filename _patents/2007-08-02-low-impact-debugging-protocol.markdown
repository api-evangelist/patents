---
title: Low impact debugging protocol
abstract: Methods and apparatus, including computer program products, are provided for debugging using dynamic compilers. The method may include receiving a first indication to grant access to a set of variables and to allow access to be inhibited to a set of remaining variables. The dynamic compiler may be allowed to optimize the set of remaining variables, while the set of granted variables is preserved. A second indication may be provided to acknowledge access to the set of granted variables and allow access to be inhibited to the set of remaining variables. In some variations, the set of granted variables is implemented as a set of live variables and the set of remaining variables is implemented as a set of dead variables. Related apparatus, systems, methods, and articles are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08312438&OS=08312438&RS=08312438
owner: SAP AG
number: 08312438
owner_city: Walldorf
owner_country: DE
publication_date: 20070802
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present disclosure generally relates to compilers and, and more particularly, debugging protocols for use with dynamic compilers.","A \u201cJava Virtual Machine\u201d (JVM) (also referred to as a \u201cJava Runtime\u201d) is a program that can execute other programs (\u201capplication programs\u201d) provided as Java bytecode. Java bytecode usually, but not exclusively, is generated from programs written in the Java programming language. Java program code may be executed in an interpreted mode, in compiled mode, or using a mixture of the two modes. In addition to governing the execution of an application's bytecodes, the JVM handles related tasks such as managing memory, providing security, and managing multiple threads of program execution. The JVM is a so-called \u201clayer\u201d on top of the operating system of the host (i.e., the physical machine). The JVM thus provides portability of applications across various operating systems and corresponding physical machines (i.e., hardware).","A \u201cdynamic compiler\u201d refers to a compiler built into a virtual machine, such as a JVM. For example, a dynamic compiler may compile procedures of the target program immediately before their first invocation or concurrently with execution. Dynamic compilers may provide accelerated execution of Java bytecode in JVMs. Moreover, a virtual machine with a dynamic compiler may execute a program code in an interpreted mode, in a dynamically compiled mode, or a combination of the two modes. A dynamic compiler may generate optimized code sequences (corresponding to the code sequences of an application) as the application is being executed by an interpreter. The generated code sequence may be stored in cache, and subsequent invocations of the same code sequence prompt an interpreter to query cache for the existence of a compiled version of the same code. If such a compiled version exists, then it is executed, else the incoming code sequence is interpreted by the interpreter. Concurrent with the execution of a procedure, the compiler may compile or recompile a procedure several times to further optimize it. The dynamic compiler is considered \u201cdynamic\u201d since it generates optimized code for applications while these applications are running, and the dynamic compiler may generate new, more optimized code, while the original code is being executed, interpreted, or compiled. In contrast, a \u201cstatic compiler\u201d completely compiles the program (e.g., into machine specific binary code or into portable bytecode) before it is executed, and compilation and optimization are not performed dynamically as the application is being executed.","To \u201cdebug\u201d a program refers to inspection and manipulation of the operations of the program while the program is being executed (e.g., by a virtual machine). This may include setting breakpoints, single stepping, observing the program's variables, changing the program state (e.g., the state of the virtual machine), and registering for events that might occur during execution.","Any compiler, static, or dynamic, needs to know in advance whether it must produce code that can be debugged (\u201cis debuggable\u201d) or not. Producing debuggable code restricts the compiler in the amount of optimization that may be applied to the original program. A larger degree of debuggability means a lesser degree of possible optimization, and vice versa. While it may be the case that the performance of a debuggable program need not be optimized (e.g. since debuggability might play a role only during development), enhanced supportability of running server application programs may be needed to balance the achievable performance of the application programs with the desired degree of debuggability.","A \u201clive variable\u201d refers to a local variable that is being used in the current execution path of a program. Specifically, a local variable X is called \u201clive\u201d (or \u201clive out\u201d) at some point P in a program, if there is a path in the program from that point P to another point Q, such that the value of the variable X is read at point Q but X does not get written to (i.e., overwritten) on this path; otherwise, the variable X is considered to be a \u201cdead variable\u201d at point P in the program. A dead variable cannot have any impact on the future behavior of the program. The only reason dead variables may have to be maintained in a compiled program (e.g. by saving their values from processor registers to memory) is for extended debugging purposes.","The Java Virtual Machine Tools Interface (JVMTI) is an application programming interface (API) that allows a program, called the \u201cJVMTI client,\u201d to inspect the state and to control the execution of application programs running in a JVM, in this context referred to as a \u201cJVMTI server.\u201d As such, JVMTI is used to implement debuggers, profilers, and other tools accessing the state of the JVM and the application programs running within the JVM. Since the JVMTI is a native interface of the JVM, a JVMTI client is implemented as a library that is loaded during JVM initialization. When loaded, the JVMTI client may gain access to and manipulate the JVMTI server (i.e., the JVM) via procedure calls (also referred to as \u201cin-process messages\u201d). These procedure calls may be directed from the JVMTI client to the JVMTI server, but may also occur in the other direction.","The Java Debug Wire Protocol (JDWP) is a communication protocol between a JDWP client and a JDWP server that is associated with a JVM. A \u201cprotocol\u201d generally refers to allowed exchanges of messages between two communicating parties. The part that initiates the communication is called the \u201cclient,\u201d while the so-called \u201cserver\u201d operates on behalf of the client. In particular, a \u201cdebugging protocol\u201d specifies the way a debugger client may communicate with a debug server, such as a JVM. A JDWP client typically includes an interactively used debugger that allows the user to debug a running Java program in the remote JVM associated with the JDWP server. The message exchange between the JDWP client and the JDWP server typically takes place across a network, as opposed to the in-process message exchange in JVMTI. The JDWP server typically is implemented as a JVMTI client hosted by a JVMTI-capable JVM.","The subject matter disclosed herein provides methods and apparatus, including computer program products, for a debugging protocol for use with a dynamic compiler.","In one aspect, there is provided a computer-implemented method for dynamic compilers. The method may include receiving an indication at the virtual machine, which lets the virtual machine grant access to a set of live variables in subsequent requests of the client (e.g., for debugging purposes). This grant does not imply that the virtual machine also allows access to a set of dead variables. The live variables and dead variables referred to are associated with a program that may undergo compilation by a dynamic compiler. The virtual machine may inhibit access to the set of dead variables based on the received indication to enable the dynamic compiler to compile the program without having to preserve the set of dead variables. The virtual machine may provide an indication acknowledging that the virtual machine grants access to the set of live variables. Otherwise, the virtual machine may provide an error indication that the virtual machine does not provide the grant of access to the set of live variables. For example, if a client receives an acknowledgement, then the client may assume that subsequent accesses to live variables will be successful, but the client may not assume that accesses to dead variables will be successful as well. If the client receives the error indication, then the client must not assume that any access to live variables will be successful.","The subject matter described herein may be implemented to realize the advantage of improved compilation (e.g. dynamic compilation) of programs (e.g. in a virtual machine such as a JVM) by enabling compilation to optimize on dead variables but not on live variables. Compiling to optimize on dead variables but not live variables may maintain a higher degree of debuggability of the generated code when compared to optimizing on all variables. Moreover, compiling to optimize on dead variables but not live variables may maintain a higher degree of possible optimizations than if all variables are required to be preserved by the compiler.","It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive. Further features and\/or variations may be provided in addition to those set forth herein. For example, the implementations described herein may be directed to various combinations and subcombinations of the disclosed features and\/or combinations and subcombinations of several further features disclosed below in the detailed description.","Like labels are used to refer to same or similar items in the drawings.","When a program is to be debugged, a compiler is restricted when optimizing the program. For example, a debugger may attempt to access local variables of the program being debugged. As such, the compiler must preserve all variables of the original uncompiled program at any point in the compiled program to enable the debugger to access those variables. The preservation of all variables at any point in the compiled program restricts optimization of the performance of the program. In some instances, preserving all local variables may be unnecessary since many debugging operations may be performed using only the live variables. To that end, the subject matter described herein provides a protocol for debugging that allows a debugging client to control (or inspect) the degree of accessibility of variables, i.e. to control whether access to any variables needs to be granted at all, whether the access may be restricted to live variables, or whether all variables must be kept accessible. In some implementations, the debugging protocol described herein may be implemented as a client-server debugging protocol, such as a protocol incorporated into (e.g., as a modification to, or an extension of the Java Virtual Machine Tool Interface (JVMTI) and the Java Debugger Wire Protocol (JDWP). For example, JVMTI and JDWP may be modified to include the features described herein to enable a debugging client to indicate that debugging needs access to live variables and not dead variables. Therefore, the dynamic compiler (e.g., the compiler of the JVM) has the freedom to optimize without regard to dead variables.","Java is a dynamically compiled language. The subject matter described herein may achieve the greatest benefit in terms of optimization if the program code is dynamically compiled and the compiler supports \u201cdeoptimization.\u201d Deoptimization refers to dynamic compilers of JVMs capable of deoptimization by interrupting the execution of a running procedure at certain deoptimization points and continuing to run the procedure in interpreted (e.g., unoptimized) mode. Deoptimization enables adaptation of the compiled procedures by deoptimizing and then possibly recompiling in order to adapt to changed conditions during the execution of the program. Supporting deoptimization requires that the JVM reconstruct the unoptimized interpreter state at the deoptimization points. In particular, the values of live variables of the unoptimized program must be known even in the optimized code. As a consequence, granting live variables access to a debugging client does not additionally restrict the achievable optimization. Although a JVM is described, other types of virtual machines may be used as well.","The following refers to implementations incorporated into a JVM and debugging protocols JVMTI and JDWP, although other compilers and debugging protocols may include the features described herein.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","110","120","121","130","131","150","110","120","121","130","150"],"i":["a ","b. "]},"JDWP client  provides an interface for debugging of program code (e.g., running within a JVM  at JVMTI server ). The JDWP client  defines the communication protocol (e.g., format) between the debugger (i.e., client debugger ) and the program being debugged (e.g., executed by JVM ). Moreover, in some implementations, the JDWP client  may also provide information regarding the state of the JVM  to debuggers and other systems. For example, JDWP client  may provide access to a running JVM's  state, class, array, interface, primitive types, and instances of those types. The JDWP client  may also provide explicit control over execution of the JVM  including suspension and resumption of threads, setting breakpoints, setting watchpoints, setting notification of exceptions, class loading, thread creation, inspection of suspended thread state, inspection of local variables, inspection of stack backtrace, and the like.","JDWP client  may send and\/or receive one or more messages  to\/from JDWP server  as part of the debugging of the JVM . Messages  may include command and reply messages. For example, JDWP client  may send a command message and receive a reply message from JDWP server . A command message (also referred to as a command packet) may be sent by JDWP client , JDWP server , and JVMTI client  to request information from the JVM  or to control program execution of the JVM . In some cases, command packets are sent by JDWP server  to notify JDWP client  of some event in the JVM  (e.g., a breakpoint or an exception). A reply message may be sent only in response to a command packet and provides information regarding the success or failure of a command. Reply packets may also carry any data requested by a command (e.g., the value of a field or variable).","The JDWP server  receives messages (e.g., commands) from JDWP client  and includes a JVMTI client . The JDWP server  including JVMTI client  exchanges on one or more procedure call(s)  with JVMTI server , which is hosted by the JVM . The JVM  runs the program (which may be compiled) that is being debugged. The procedure calls  enable JDWP server  to interact with JVMTI server  to process the commands and replies associated with JDWP client  during debugging of the JVM.","The Java Virtual Machine Tool Interface (JVMTI) is a protocol for in-process communication between a JVMTI client (e.g., JVMTI client ) and a JVMTI server (e.g., JVMTI server ). The JVMTI client  includes a dynamic library for loading into a JVMTI-capable JVM (e.g., JVM ). The JVMTI client  provides the client-side JVMTI procedures. The JVMTI is a programming interface used by development and monitoring tools to provide both a way to inspect the state and to control the execution of applications running in the JVM . Specifically, JVMTI provides a virtual machine interface to access the state of JVM  including one or more of the following: profiling, debugging, monitoring, thread analysis, and coverage analysis tools. JVMTI is a so-called \u201ctwo-way interface\u201d including a client of JVMTI, such as JVMTI client , which may be notified of events at JVM . JVMTI enables query and control of JVM  either in response to events or independent of them. The JVMTI client  runs in the same process with and communicate directly with the virtual machine executing the application being examined (e.g., the application in JVM ). Moreover, the JVMTI client  may be the backend that supports remote debugging via JDWP messages , while the JVMTI server  is a JVM implementation that provides the JVMTI server-side procedures and provides functionality for loading the JVMTI client library .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 2","i":["a","c "],"b":["2","160","121","130","131","160","121","130"]},{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"float diagonal(float a, float b) {"]},{"entry":[{},"\u2003float x = a*a + b*b;"]},{"entry":[{},"\u2003\/\/ {grave over (\u2009)}a\u2019, {grave over (\u2009)}b\u2019 are dead"]},{"entry":[{},"\u2003float c = sqrt(x);"]},{"entry":[{},"\u2003\/\/ {grave over (\u2009)}a\u2019, \u2018b\u2019, {grave over (\u2009)}x\u2019 are dead"]},{"entry":[{},"\u2003return c;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Table 2 depicts a machine code fragment showing how full debuggability of the procedure \u201cdiagonal\u201d of Table 1 has to preserve dead variables.",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"STFD F2,120+0,SP \u2002\/\/ save b for debugging"]},{"entry":[{},"STFD F1,112+0,SP \u2002\/\/ save a for debugging"]},{"entry":[{},"FMUL F13,F1,F1 \u2002\/\/ t <- a*a"]},{"entry":[{},"FMUL F12,F2,F2 \u2002\/\/ u <- b*b"]},{"entry":[{},"FADD F13,F13,F12 \/\/ t <- t+u"]},{"entry":[{},"STFD F13,136+0,SP \/\/ save t (equals x) for debugging"]},{"entry":[{},"FMR F1,F13 \u2003\/\/ x <- t (pass x)"]},{"entry":[{},"CALL,static 0x0000040002235860 \/\/ sqrt(x)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Table 3 depicts a machine code fragment showing how optimization of the procedure \u201cdiagonal\u201d of Table 1 may remove dead variables.",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FMUL F13,F1,F1 \/\/ t <- a*a"]},{"entry":[{},"FMUL F12,F2,F2 \/\/ u <- b*b"]},{"entry":[{},"FADD F1,F13,F12 \/\/ x <- t+u (pass x)"]},{"entry":[{},"CALL,static 0x0000040002235860 \/\/ sqrt(x)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The subject matter described herein thus provides a protocol, which may be used to obtain access to live variables, but not necessarily to dead variables. In some implementations, JVMTI client  may use a can_access_live_variables request message to demand access to live variables, but not to dead variables, and JVMTI server  will respond with a can_access_live_variables reply message (e.g., a confirmation), as described further below.","In some implementations, negotiating the desired debugging capabilities takes place in the early \u201con-load\u201d phase since the compiler might need to know the desired features in advance, as depicted for example in . When JVMTI server  does not grant access to local variables and does not grant access to live variables (e.g., in , the can_access_live_variables request  has been denied by message  and a can_access_local_variables request has not been granted by JVMTI server  or JVM ), then JVMTI client  may nevertheless attempt to access a local variable (including dead variables or live variables) by a message . In this case, JVMTI server  may reply an error message , such as \u201cJVMTI_ERROR_MUST_POSSESS_CAPABILITY.\u201d",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 2","FIG. 2"],"i":["b ","b"],"b":["121","208","207","131","121","121","206","205","121","131","209","211","131","121","209","121","131","210","121","211","212","131","130","131","131","131"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","i":"c ","b":["121","214","121","215","121","130","216","130","214","121","217","219","218","220","130","130","131","131","121","213","214","214","131","121"]},"Compared to the can_access_local_variables state, being in the can_access_live_variables state allows the dynamic compiler of JVM  to enhance optimizations in generated code. The dynamic compiler may eliminate some or all of the dead variables and hence enjoy less register pressure, less spilling code, and more opportunities for dead code removal, all of which contribute to better optimization of the application program executed by JVM .","In some implementations, a dynamic compiler of JVM  may support deoptimization of dynamically compiled program code. With deoptimization support, the dynamic compiler of the JVM  must preserve all of the live variables, so the JVMTI client  may request the can_access_live_variables state (e.g., message ) at any time (e.g., in the on-load and in the live phase of JVM execution) and may be subsequently confirmed (e.g., by message ).","In some implementations where the compiler of JVM  does not support deoptimization, JVM  may still offer the can_access_live_variables state during the on-load phase. For example, the JVMTI client  may request the can_access_live_variables state at startup (i.e., on-load) of JVM . If this is granted by confirmation message , the compiler optimization is thus restricted to require the compiler to preserve the live variables, while possibly not preserving the dead variables. Without having confirmed the can_access_live_variables state, the JVM's dynamic compiler can perform a full optimization that does not preserve live or dead variables.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 2","FIG. 2"],"i":["d ","d"],"b":["121","130","120","110","221","120","131","222","110","223","120","224","131","120","130","120","110","225","120","131","226"]},"Although -depict specific messages, the messages (e.g., commands, replies, error messages, and the like) associated with JVMTI and JDWP include a variety of other messages as well.","The JVMTI client  includes an \u201cAgent_OnLoad\u201d procedure. The Agent_OnLoad procedure must be called by JVM  and\/or JVMTI server  on startup (i.e., on-load) when loading the JVMTI client library. The Agent_OnLoad procedure enables JVMTI client  to configure the desired features of the JVMTI server . At startup, the JDWP server  (if implemented as a JVMTI client ) may request can_access_live_variables but not can_access_local_variables from the JVMTI server . When this is the case, the JVMTI server  does not have to restrict the dynamic compiler of JVM  with regard to the dead variables. When the JDWP server  (and\/or JVMTI client ) requests both, can_access_live_variables state and can_access_local_variables state, but only obtains can_access_live_variables confirmation, then JDWP server  may still startup properly. This is because JDWP server  is allowed to merely grant access to live variables at the JVM  to the JDWP client . When JDWP server  (as well as JVMTI client ) does not obtain at least the can_access_live_variables confirmation  at startup, then JDWP server  (and with it JVMTI server  and JVM ) may choose to terminate with an error since JDWP server  (and JVMTI server ) cannot satisfy JDWP client  requests for the minimum useful subset of variables, namely live variables.","Table 4 below includes a sample implementation of the Agent_OnLoad procedure (in the form of pseudo-code in Scheme syntax) of a JDWP server making use of JVMTI services described above.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":";;The terms \u201cJDWP2\u201d and \u201cJVMTI2\u201d refer to modifications (consistent"},{"entry":";; with the features of the subject matter described herein) over prior"},{"entry":";; JDWP protocols and prior JVMTI protocols."},{"entry":"(define (Agent_OnLoad JDWP2-RQMTS)"},{"entry":"\u2003;; REQUIRES: \u2018JDWP2-RQMTS\u2019 holds the user's requirements on the"},{"entry":"\u2003;; JDWP2 debugging features."},{"entry":"\u2003;; CHANGES: Possibly changes the state of the JVM such as to be"},{"entry":"\u2003;; \u2003able to support the requirements from \u2018JDWP2-RQMTS\u2019."},{"entry":"\u2003;; RETURNS: A valid JVMTI2 state or an error."},{"entry":"(cond"},{"entry":"\u2003((user-requires-standard-jdwp? JDWP2-RQMTS)"},{"entry":"\u2003;; E.g. the user may have supplied a standard JDWP option"},{"entry":"\u2003;; \u2018-agentlib:jdwp=...\u2019 or some non-standard JDWP2 option"},{"entry":"\u2003;; \u2018-agentlib:jdwp=locals=all...\u2019 indicating that standard"},{"entry":"\u2003;; JDWP behavior is desired."},{"entry":"\u2003(let ( (jvmti2-state"},{"entry":"\u2003\u2002(make-jvmti2-state"},{"entry":"\u2003\u2002;; request standard JVMTI capabilities from the"},{"entry":"\u2003\u2002;; JVMTI2 server."},{"entry":"\u2003\u2003can-access-local-variables"},{"entry":"\u2003\u2003can-pop-frame"},{"entry":"\u2003\u2003;; ... more needed standard JVMTI capabilities"},{"entry":"\u2003\u2002)) )"},{"entry":"\u2003(if (null? jvmti2-state)"},{"entry":"\u2003\u2002;; ... then the JVMTI2 server did not grant the"},{"entry":"\u2003\u2002;; needed capabilities. For instance because the JVM"},{"entry":"\u2003\u2002;; only implements a subset of these. User's"},{"entry":"\u2003\u2002;; requirements can not be satisfied."},{"entry":"\u2003\u2003(make-jdwp2-error"},{"entry":"\u2003\u2003\u2003JDWP2-RQMTS \u201cStandard JDWP is not supported\u201d)"},{"entry":"\u2003\u2002;; ... else the JVMTI2 server granted the needed"},{"entry":"\u2003\u2002;; capabilities. The JVM's dynamic compiler will"},{"entry":"\u2003\u2002;; generate machine code that supports all the"},{"entry":"\u2003\u2002;; debugging functionality. Return JVMTI2 state."},{"entry":"\u2003\u2002jvmti2-state)))"},{"entry":"(;; ... else"},{"entry":"\u2003(user-requires-low-impact-jdwp? JDWP2-RQMTS)"},{"entry":"\u2003;; E.g. the user may have supplied a non-standard"},{"entry":"\u2003;; \u2018-agentlib:jdwp=locals=live...\u2019 option. This will not"},{"entry":"\u2003;; be accepted by standard JDWP implementations."},{"entry":"\u2003(let ( (jvmti2-state"},{"entry":"\u2003\u2002(make-jvmti2-state"},{"entry":"\u2003\u2002;; request JVMTI capabilities from the JVMTI server."},{"entry":"\u2003\u2002can-access-live-variables"},{"entry":"\u2003\u2002;; ... more needed standard JVMTI capabilities but"},{"entry":"\u2003\u2002;; possibly not \u2018can-pop-frame\u2019, which would require"},{"entry":"\u2003\u2002;; keeping arguments live."},{"entry":"\u2003\u2002)) )"},{"entry":"\u2003(if (null? jvmti2-state)"},{"entry":"\u2003;; ... then the JVMTI2 server did not grant the"},{"entry":"\u2003;; needed capabilities. For instance because the JVM"},{"entry":"\u2003;; does not implement access even to live variables."},{"entry":"\u2003;; User's requirements can not be satisfied."},{"entry":"\u2003(make-jdwp2-error"},{"entry":"\u2003\u2002JDWP2-RQMTS \u201cLow impact JDWP is not supported\u201d)"},{"entry":"\u2003;; ... else the JVMTI2 server granted the needed"},{"entry":"\u2003;; capabilities. The JVM's dynamic compiler will"},{"entry":"\u2003;; generate machine code that needs only support the"},{"entry":"\u2003;; low impact debugging functionality of JDWP2."},{"entry":"\u2003;; Return JVMTI2 state."},{"entry":"\u2003jvmti2-state)))"},{"entry":"(;; ... else"},{"entry":"\u2003#t"},{"entry":"\u2003;; No debugging is required by the client."},{"entry":"\u2003;; Return indication of success."},{"entry":"\u2003#t)))"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The JDWP server  may refuse to deliver or manipulate values of dead variables when it has only obtained (as a JVMTI client ) the can_access_live_variables confirmation , without having obtained the can_access_local_variables confirmation . In this state, JDWP server  may still choose to deliver or manipulate dead variables if the dead variables reside within frames of interpreted rather than compiled methods.","Table 5 lists pseudo-code demonstrating how JDWP server  may interact with JDWP client . For simplicity, it is assumed that the incoming requests only access a single variable, although access to a set of variables may be implemented as well.",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":";; The terms \u201cJDWP2\u201d and \u201cJVMTI2\u201d refer to modifications (consistent"},{"entry":";;with the features of the subject matter described herein) over prior"},{"entry":";;JDWP protocols and prior JVMTI protocols."},{"entry":"(define (serve-jdwp2-request JDWP2-REQ JVMTI2-STATE)"},{"entry":"\u2003;; REQUIRES: \u2018JDWP2-REQ\u2019 is a JDWP2 request sent by a JDWP2"},{"entry":"\u2003;; \u2003client. \u2018JVMTI2-STATE\u2019 is the state of the underlying"},{"entry":"\u2003;; \u2003JVMTI2 server as prepared by the procedure"},{"entry":"\u2003;; \u2003\u2018Agent_OnLoad\u2019."},{"entry":"\u2003;; CHANGES: Possibly changes the state of a thread via the"},{"entry":"\u2003;; \u2003JDWP2 command contained in \u2018JDWP2-REQ\u2019."},{"entry":"\u2003;; RETURNS: A valid JDWP2 reply or an error."},{"entry":"\u2003(cond"},{"entry":"\u2003\u2003((is-get-local-variable? JDWP2-REQ)"},{"entry":"\u2003\u2003\u2003;; Standard JDWP request."},{"entry":"\u2003\u2003\u2003\u2003(cond"},{"entry":"\u2003\u2003\u2003\u2003\u2003((can-access-local-variables? JVMTI2-STATE)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(send-variable-value JDWP2-REQ))"},{"entry":"\u2003\u2003\u2003\u2003\u2003(;; ... else"},{"entry":"\u2003\u2003\u2003\u2003\u2003(can-access-live-variables? JVMTI2-STATE)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003;; Non-standard JDWP condition. This can not happen in"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003;; prior JDWP implementations."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(if (reads-live-variable? JDWP2-REQ)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; ... then provide its value"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003(send-variable-value JDWP2-REQ)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; ... else provide an error"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003(send-jdwp2-error JDWP2-REQ invalid-slot)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003(;; ... else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003#t"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003;; May succeed on a per-request basis,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003;; but here we choose to send an error."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(send-jdwp2-error JDWP2-REQ not-implemented))))"},{"entry":"\u2003(;; ... else"},{"entry":"\u2003(is-set-local-variable? JDWP2-REQ)"},{"entry":"\u2003\u2003\u2003;; Standard JDWP request."},{"entry":"\u2003\u2003\u2003\u2003(cond"},{"entry":"\u2003\u2003\u2003\u2003\u2003((can-access-local-variables? JVMTI2-STATE)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(set-variable-value JDWP2-REQ))"},{"entry":"\u2003\u2003\u2003\u2003\u2003(;; ... else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(can-access-live-variables? JVMTI2-STATE)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003;; Non-standard JDWP condition. This can not happen in"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003;; prior JDWP implementations."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003(if (writes-live-variable? JDWP2-REQ)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; ... then set its value"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(set-variable-value JDWP2-REQ)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; ... else provide an error"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003(send-jdwp-error JDWP2-REQ invalid-slot)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(#t"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; May succeed on a per-request basis,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; but here we choose to send an error."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003(send-jdwp2-error JDWP2-REQ not-implemented))))"},{"entry":"\u2003\u2003\u2003\u2003\u2003(;; ... else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(is-pop-frame? JDWP2-REQ)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003;; Standard JDWP request."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(cond"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003((can-pop-frame? JVMTI2-STATE)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(pop-frame JDWP2-REQ))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003(;; ... else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003#t"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; Non-standard JDWP condition. This can not happen"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; in prior JDWP implementations. This may succeed"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; on a per-request basis but here we choose to send"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003;; an error."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(send-jdwp2-error JDWP2-REQ not-implemented))))"},{"entry":"\u2003\u2003\u2003\u2003\u2003(;; ... else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003#t"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003;; Other standard JDWP requests."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(serve-other-requests JDWP2-REQ JVMTI2-STATE))))"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In some implementations, system  may be interoperable with a command line debugger known as \u201cjdb\u201d (commercially available from Sun Microsystems, Inc.). The jdb debugger is a prior JDWP client. Table 6 depicts a sample session protocol of how jdb handles the behavior of the JDWP of  when a dead variable is accessed. The debugged program rests at a breakpoint in the jdb_break_here procedure and the calling procedure check_live_among_dead_locals is compiled.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"main[2] up"]},{"entry":[{},"main[2] list"]},{"entry":[{},"27 static int check live among dead locals(int i0)"]},{"entry":[{},"28 int i1dead = 1+i0;"]},{"entry":[{},"29 int i2live = 2+i0;"]},{"entry":[{},"30 int i3dead = 3+i0;"]},{"entry":[{},"31 => boolean blive = jdb break here( );"]},{"entry":[{},"32 \/\/ all locals are dead here except \u2018i2live\u2019 and \u2018blive\u2019."]},{"entry":[{},"33 return blive ? i2live-2\/*success*\/"]},{"entry":[{},": i2live-1\/*failure*\/;"]},{"entry":[{},"34"]},{"entry":[{},"35"]},{"entry":[{},"36 public static void main(String[ ] args)"]},{"entry":[{},"main[2] print i1dead"]},{"entry":[{},"com.sun.jdi.InternalException: Unexpected JDWP Error: 35"]},{"entry":[{},"i1dead = null"]},{"entry":[{},"main[2] print i2live"]},{"entry":[{},"i2live = 3"]},{"entry":[{},"main[2] locals"]},{"entry":[{},"Internal exception:"]},{"entry":[{},"com.sun.jdi.InternalException: Unexpected JDWP Error: 35"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Referring to Table 6, the value of the live variable ilive may be read properly. Attempting to read the value of the dead variable idead yields the error code , which corresponds to INVALID_SLOT. The \u201clocals\u201d command of jdb tries to access all the variables of the frame at once via a single JDWP command GetValues. Since among the variables there are dead ones, this will lead to an error  and no variable will be obtained at all. An improved jdb client might avoid this error condition by using \u201cGetLiveValues\u201d instead of \u201cGetValues.\u201d",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 3","FIG. 3"],"b":["300","131","310","131","320","310","131","131","330","121","120","330","121","120","208","130"]},"The systems and methods disclosed herein may be embodied in various forms including, for example, a data processor, such as a computer that also includes a database, digital electronic circuitry, firmware, software, or in combinations of them. Moreover, the above-noted features and other aspects and principles of the present disclosed embodiments may be implemented in various environments. Such environments and related applications may be specially constructed for performing the various processes and operations according to the disclosed embodiments or they may include a general-purpose computer or computing platform selectively activated or reconfigured by code to provide the necessary functionality. The processes disclosed herein are not inherently related to any particular computer, network, architecture, environment, or other apparatus, and may be implemented by a suitable combination of hardware, software, and\/or firmware. For example, various general-purpose machines may be used with programs written in accordance with teachings of the disclosed embodiments, or it may be more convenient to construct a specialized apparatus or system to perform the required methods and techniques.","The systems and methods disclosed herein may be implemented as a computer program product, i.e., a computer program tangibly embodied in an information carrier, e.g., in a machine readable storage device or in a propagated signal, for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","The foregoing description is intended to illustrate but not to limit the scope of the invention, which is defined by the scope of the appended claims. Other embodiments are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings,",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 2","i":["a","b","c "],"b":["2","2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2","i":"d "},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
