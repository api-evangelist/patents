---
title: Recovering added precision from L-bit samples by dithering the samples prior to an averaging computation
abstract: A dithering system comprising a dithering unit, a storage medium, and an averaging unit. The dithering unit is configured to receive a set of data values, to add dither values to the data values, and to truncate the resultant addition values to L-bit truncated values. The storage medium is configured to store the L-bit truncated values. The averaging unit is configured to read the L-bit truncated values from the storage medium, and to compute an average value using at least a subset of the L-bit truncated values. The dither values may have an average value of approximately one-half. The dither values may approximate a uniform distribution of numbers between −A+½ and A+½, wherein A is greater than or equal to one. Alternatively, the dithering unit may receive a temporal stream of data values, and the average unit may perform a temporal average (e.g. an FIR filter). The dithering system may be incorporated in a graphics system. In this case, data values may represent rendered sample values (e.g. color or alpha).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06894698&OS=06894698&RS=06894698
owner: Sun Microsystems, Inc.
number: 06894698
owner_city: Santa Clara
owner_country: US
publication_date: 20010111
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF SEVERAL EMBODIMENTS"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/214,597, filed on Jun. 27, 2000, and titled \u201cRecovering Added Precision from L-Bit Samples by Dithering the Samples Prior to an Averaging Computation\u201d.","This application claims the benefit of U.S. Provisional Application No. 60\/175,384, filed on Jan. 11, 2000, and titled \u201cPhotorealistic Hardware Antialiasing\u201d.","1. Field of the Invention","This invention relates generally to the field of digital signal processing and, more particularly, to a system and method for operating on data values so that their average (with respect to time and\/or space) survives truncation.","2. Description of the Related Art","Modern computer systems typically rely on a graphics system to generate output video signals for the display devices. Early graphics systems were only responsible for receiving data produced by the host processor and displaying it on a monitor device. In essence, they acted as simple translators or interfaces. Modern graphics systems, however, incorporate graphics processors with a great deal of processing power. They now act more like coprocessors rather than simple translators. This change has resulted in an increase in both the complexity and amount of data being sent to the display devices. For example, modern display devices have many more pixels, greater color depth, and are able to display more complex images with higher refresh rates than earlier models. Similarly, the images displayed are now more complex and may involve advanced techniques such as anti-aliasing and texture mapping.","As a result, without considerable processing power in the graphics system, the host processor would spend a great deal of time performing graphics calculations. This could rob the host processor of the processing power needed for performing other tasks associated with program execution, and thereby dramatically reduce the overall performance of the computer system. With a powerful graphics system, however, when the host processor is instructed to draw a box on the screen, the host processor may send a request to the graphics system stating \u201cdraw a box at these coordinates.\u201d The graphics system may then compute the position and color of each pixel comprising the box. The host processor is thus liberated from the time consuming draw or render process.","Generally, a graphics system is a type of video adapter that contains its own processor to boost performance levels. These processors are specialized for computing graphical transformations, and thus, they tend to achieve better results than the general-purpose CPU used by the computer system. In addition, they free up the computer's CPU to execute other commands while the graphics system is handling graphics computations. The popularity of graphical applications, and especially multimedia applications, has made high performance graphics systems a common feature of computer systems. Most computer manufacturers now bundle a high performance graphics system with their computer systems.","Since graphics systems typically perform only a limited set of functions, they may be customized and therefore are far more efficient at graphics operations than the computer's general-purpose CPU. While early graphics systems were limited to performing two-dimensional (2D) graphics, their functionality has increased to support three-dimensional (3D) wire-frame graphics, 3D solids, and now includes support for three-dimensional (3D) graphics with textures and special effects such as advanced shading, fogging, alpha-blending, and specular highlighting.","Prior art graphics systems use a conventional frame buffer for refreshing pixel\/video data on a display device (e.g. a monitor device or projection device). The frame buffer stores rows and columns of pixels that exactly correspond to respective row and column locations on the display device. Prior art graphics systems render 2D and\/or 3D images or objects into the frame buffer in pixel form, and then read the pixels from the frame buffer during a screen refresh to refresh the display device. Thus, the frame buffer stores the output pixels that are provided to the display device. To reduce visual artifacts that may be created by refreshing the screen at the same time the frame buffer is being updated, frame buffers in most graphics systems are double-buffered.","To obtain more realistic images, some prior art graphics systems have gone further by generating more than one sample per pixel. As used herein, the term \u201csample\u201d refers to information calculated at a particular point on an object or image, i.e. information such as one or more of color, depth (z), transparency, etc. For example a sample may comprise the following component values: a red value, a green value, a blue value, a z-depth value, and an alpha value (e.g., representing the transparency of the sample). A sample may also comprise other information, e.g, a blur value, an intensity value, brighter-than-bright information, and an indicator that the sample partially or completely comprises control information rather than color information (i.e., \u201csample control information\u201d). By calculating more samples than pixels (i.e., super-sampling), a more detailed image is calculated than can be displayed on the display device. For example, a graphics system may calculate four samples for each pixel to be output to the display device. After the samples are calculated, they are then combined or filtered to form the pixels that are stored in the frame buffer and then conveyed to the display device. Using pixels formed in this manner may create a more realistic final image because overly abrupt changes in the image may be smoothed by the filtering process.","These prior art super-sampling systems typically generate a number of samples that are far greater than the number of pixel locations on the display. These prior art systems typically have rendering processors that calculate the samples and store them into a render buffer. Filtering hardware then reads the samples from the render buffer, filters the samples to create pixels, and then stores the pixels in a conventional frame buffer. The conventional frame buffer is typically double-buffered, with one side being used for refreshing the display device while the other side is updated by the filtering hardware. These systems, however, have generally suffered from limitations imposed by the conventional frame buffer, and by the added latency caused by the render buffer and filtering hardware. Therefore, an improved graphics system is desired which includes the benefits of pixel super-sampling while avoiding the drawbacks of the conventional frame buffer.","One of the factors determining the quality of the video output generated by a display device as perceived by humans is the number Nof bits of precision delivered to the display device per pixel per color value by the graphics system. A number of adverse perceptual effects may be observed when the value Nis not sufficiently large. For example, with 24-bit color, i.e. eight bits each for red, green and blue, a smoothly varying color field may appear stair-stepped. (Experimental evidence indicates that the limit of human perceptual sensitivity is approximately 12 bits of linear quantization for the lighting conditions likely to prevail in typical display applications. It is noted that under some very special conditions human perceptual sensitivity has been demonstrated up to approximately 13 bits.) Thus, increasing the value Nis generally desirable. However, a larger value for Nimplies a larger and more costly pixel frame buffer. It may be difficult for a graphics system to realize a value for Nwhich is large enough to eliminate (or sufficiently reduce) the adverse perceptual effects since the associated memory costs may be high. In certain situations, the video output generated by a graphics system may be targeted for a non-human sensing system. For example, the video output may used to train another computer system such as a machine vision system. Thus, there may be a demand for the graphics system to generate bit precisions (for pixel color or intensity) higher than the limit of human perceptual sensitivity. Therefore, there exists a need for a system and method capable of delivering increased pixel color (or intensity) precision from lower precision sample color values.","More broadly, in the field of signal processing, there exists a problem that may be stated as follows. Suppose that there exists a collection of data values each having a precision of K bits. Suppose that each of the data values are rounded to L bits, where L is smaller than K. Suppose that a processing unit computes a weighted average AVGof the rounded data values. If the same weighted average computation were performed on the original collection of K-bit data values, resulting in an average value AVG, it would be readily observed that the two averages, AVGand AVG, differ significantly. In other words, the average of a set of data values is not generally preserved through a rounding operation. Thus, there exists a need for a system and method which could modify the data values so that the average of the rounded data values after modification would more closely approximate the true average AVGof the original K-bit data values.","It has been observed that biological systems are capable of providing increased signal sensitivity by an appropriate use of noise. This phenomenon, known as \u201cstochastic resonance\u201d, is described in the following references:\n\n","A graphics system may, in one embodiment, comprise one or more rendering units, a dithering unit, a sample buffer, and one or more sample-to-pixel calculation units. The rendering units may compute a plurality of sample values corresponding to positions in a two-dimensional virtual screen space. The dithering unit is configured to receive a spatially co-located group of sample values from a rendering unit. The sample values may represent color values (e.g. red, green, or blue values), alpha values, etc. The dithering unit adds dither values to the sample values, truncates the resultant addition values to L-bit truncated values (where L is an integer), and stores the L-bit truncated values into the sample buffer. The truncation length L may take any of a variety of values. For example, in one embodiment L equals ten.","One of the sample-to-pixel calculation units reads the L-bit truncated values from the sample buffer, and generates an M-bit pixel value by filtering the L-bit truncated values, where M is an integer larger than L. As a result of the dithering performed by the dithering unit, the M-bit pixel value may more closely approximate the ideal pixel value which would be obtained from filtering the originally rendered (high precision) sample values. In one alternative embodiment, the dithering unit may be comprised within the rendering unit(s).","In one embodiment, the sample-to-pixel calculation unit may filter the L-bit truncated values by computing a weighted average of at least a subset of the L-bit truncated values. The weighted average may involve several groups (i.e. bins) of L-bit truncated values.","In one set of embodiments, the dither values may have an average value of one-half (or approximately one-half). In particular, the dither values may approximate a uniform distribution of numbers between \u2212A+\u00bd and A+\u00bd, where A is a rational number greater than or equal to one. In one embodiment, A equals one. The dithering unit may be configured to add the dither values and the sample values so that the \u00bd bit position of the dither values is aligned with the most significant bit position which is to be removed in truncating each of the resultant values.","In another set of embodiments, the dither values may have an average value of zero (or approximately zero). In particular, the dither values may approximate a uniform distribution of numbers between \u2212A and A, where A is a rational number greater than or equal to one. In these embodiments, the dither unit adds the dither values to the sample values and adds \u00bd to the resultant addition values prior to truncation. The addition of \u00bd and truncation achieve a rounding of resultant addition values down to L bits.","In some embodiments, the sample-to-pixel calculation unit may use the M-bit pixel value to perform gamma correction. In other words, the sample-to-pixel calculation unit may determine a gamma corrected pixel value (e.g. by table lookup) in response to the M-bit pixel value. In order to maximize the precision of the gamma corrected pixel value, the system may maximize the precision length M for any given value of storage length L. Advantageously, dithering may facilitate this maximization. In one embodiment, precision length M is at least 12 and the gamma corrected pixel value has at least 10 bits of precision.","In another embodiment, a dithering system may be implemented comprising a dithering unit, a storage medium, and an averaging unit. The dithering unit is configured to receive a set of data values, to add dither values to the data values, and to truncate the resultant addition values to L-bit truncated values. The storage medium is configured to store the L-bit truncated values. The averaging unit is configured to read the L-bit truncated values from the storage medium and compute an average value using at least a subset of the L-bit truncated values.","In yet another embodiment, a temporal dithering system may be implemented comprising a dithering unit and a temporal averaging unit. The dithering unit is configured to receive a first stream of data values, to add dither values to the data values, and to truncate the resultant addition values in order to generate a second stream of L-bit truncated values. The temporal averaging unit is configured to receive the second stream of L-bit truncated values and compute a time-average on the second stream of L-bit truncated values.","In one embodiment of the temporal averaging system, a storage medium is interposed between the dithering unit and the averaging unit. In a second embodiment, a transmission medium is interposed between the dithering unit and the averaging unit.","FIG. \u2014Computer System",{"@attributes":{"id":"p-0056","num":"0057"},"figref":"FIG. 1","b":["80","80","82","84","84","84","84","84","84","84","84"],"sub":["1 ","G","1 ","G ","1 ","G "]},"Various input devices may be connected to system unit , including a keyboard , a mouse , a video camera, a trackball, a digitizing tablet, a six-degree of freedom input device, a head tracker, an eye tracker, a data glove, body sensors, etc. Application software may be executed by computer system  to display 3-D graphical objects on projection screen SCR and\/or monitor devices A and B. It is noted that projection devices PDthrough PDmay project their respective component images onto a surface other than a conventional projection screen, and onto surfaces that are curved.","FIG. A\u2014Computer System Block Diagram",{"@attributes":{"id":"p-0058","num":"0059"},"figref":"FIG. 2A","b":["80","80","102","112","104","106","104","104"]},"Host CPU  may be realized by any of a variety of processor technologies. For example, host CPU  may comprise one or more general purpose microprocessors, parallel processors, vector processors, digital signal processors, etc., or any combination thereof. System memory  may include one or more memory subsystems representing different types of memory technology. For example, system memory  may include read-only memory (ROM) and\/or random access memory (RAM)\u2014such as static random access memory (SRAM), synchronous dynamic random access memory (SDRAM) and\/or Rambus dynamic access memory (RDRAM).","System bus  may comprise one or more communication buses or host computer buses (for communication between host processors and memory subsystems). In addition, various peripheral devices and peripheral buses may be connected to system bus .","Graphics system  may comprise one or more graphics boards GB as shown in , C and D. The graphics boards may couple to system bus  by any of a variety of connectivity technologies (e.g. crossbar switches). The graphics boards may generate video signals for display devices DDthrough DDin response to graphics commands and data received from one or more graphics applications executing on host CPU . The graphics boards comprising graphics system  are collectively denoted GB. The Igraphics board in graphics system  is denoted GB(I).","In one embodiment, graphics system  comprises graphics boards GB() through GB(Q) which couple to display devices DD-DDin a one-to-one fashion as shown in FIG. B. In other words, graphics board GB(I) couples to and generates the video signal for display device DD.","In a second embodiment, graphics system  comprises graphics boards GB() through GB(Q\/2) which couple to display devices DD-DDin a one-to-two fashion as shown in FIG. C. In other words, graphics board GB(I) couples to and generates video signals for two display devices DDand DDwhere I ranges from 1 to Q\/2.","In a third embodiment, graphics system  comprises graphics boards GB() through GB(Q) which couple to projection devices DD-DDin a two-to-one fashion as shown in FIG. D. In other words, graphics boards GB(I-) and GB(I) may be daisy chained together to generate a video signal for display device DD.","A wide distribution of \u201cmappings\u201d between graphics boards and display devices are possible. At one end of the distribution, a single graphics board may drive all Q display devices, where the size of Q is limited by the computational bandwidth of the graphics board. At the other end of the distribution, X graphics boards may drive a single projection device. The size of integer X is determined by the input video bandwidth of the projection device. The X graphics boards may be daisy-chained together, and partition the effort of generating the video signal for the single projection device.","In addition, X graphics boards may map to Q projection devices where neither X nor Q are equal to one. For example, three graphics boards may drive two projection devices. A first graphics board and half of the resources\/bandwidth of a second graphics board may be used to generate a first video signal for a first projection device DD, and a third graphics board together with the remaining half of the resources\/bandwidth of the second graphics board may be used to generate a second video signal for a second projection device DD.","Depending on the embodiment, a user may configure graphics system  with any of a variety of board-to-projector mappings. For example, the user may have five projectors: one with large input bandwidth, two with moderate input bandwidth, and two with small input bandwidth. Thus, the user may choose to assign two or more graphics boards to the large bandwidth projector, one graphics board each to the moderate bandwidth projectors, and one graphics board to the two small bandwidth projectors.","It is noted that the graphics boards GB comprising 3-D graphics system  may couple to one or more busses of various types in addition to system bus . Furthermore, some or all of the graphics boards GB may couple to a communication port, and thereby, directly receive graphics data from an external source such as the Internet or a local area network.","Host CPU  may transfer information to\/from the graphics boards GB according to a programmed input\/output (I\/O) protocol over system bus . Alternately, graphics board GB may access system memory  according to a direct memory access (DMA) protocol or through intelligent bus-mastering.","A graphics application program conforming to an application programming interface (API) such as OpenGL\u00ae or Java 3D\u2122 may execute on host CPU  and generate commands and data that define geometric primitives such as a polygons for output on display devices DD, through DD. Host CPU  may transfer this graphics data to system memory . Thereafter, the host CPU  may transfer the graphics data to graphics system  over system bus . In another embodiment, graphics boards GB may read geometry data arrays from system memory  using DMA access cycles. In yet another embodiment, graphics boards GB may be coupled to system memory  through a direct port, such as an Advanced Graphics Port (AGP) promulgated by Intel Corporation.","Graphics boards GB may receive graphics data from any of various sources including host CPU , system memory  or any other memory, external sources such as a network (e.g., the Internet) or a broadcast medium (e.g. television). While graphics system  is depicted as part of computer system , graphics system  may also be configured as a stand-alone device.","Graphics system  may be comprised in any of various systems, including a network PC, an Internet appliance, a gaming playstation, a television (including an HDTV system or an interactive television system), or other devices which display 2D and\/or 3D graphics.","FIG. \u2014Graphics Board GB(I)",{"@attributes":{"id":"p-0073","num":"0074"},"figref":"FIG. 3","b":["90","162","170","1","170","178","178"]},"Graphics processing unit  may comprise any combination of processing technologies. For example, graphics processing unit  may comprise specialized graphics processors or calculation units, multimedia processors, DSPs, general-purpose processors, programmable logic, reconfigurable logic, or discrete logic.","In one embodiment, graphics processing unit  may comprise one or more rendering units A-D. Graphics processing unit  may also comprise one or more control units , one or more data memories A-D, and one or more schedule units . Sample buffer  may comprise one or more sample memories A-P.","A. Control Unit ","Control unit  operates as the interface between graphics board GB(I) and computer system  by controlling the transfer of data between graphics board GB(I) and computer system . In embodiments of graphics board GB(I) that comprise two or more rendering units A-D, control unit  may also divide the stream of data received from computer system  into a corresponding number of parallel streams that are routed to the individual rendering units A-D. The graphics data may be received from computer system  in a compressed form. Graphics data compression may advantageously reduce the required transfer bandwidth between computer system  and graphics board GB(I). In one embodiment, control unit  may be configured to split and route the received data stream to rendering units A-D in compressed form.","The graphics data may comprise one or more graphics primitives. As used herein, the term graphics primitive includes polygons, parametric surfaces, splines, NURBS (non-uniform rational B-splines), sub-division surfaces, fractals, volume primitives, and particle systems. These graphics primitives are described in detail in the text book entitled \u201cComputer Graphics: Principles and Practice\u201d by James D. Foley, et al., published by Addison-Wesley Publishing Co., Inc., 1996.","It is noted that the embodiments and examples presented herein are described in terms of polygons for the sake of simplicity. However, any type of graphics primitive may be used instead of or in addition to polygons in these embodiments and examples.","B. Rendering Units A-D","Rendering units A-D (also referred to herein as draw units) are configured to receive graphics instructions and data from control unit  and then perform a number of functions which depend on the exact implementation. For example, rendering units A-D may be configured to perform decompression (if the received graphics data is presented in compressed form), transformation, clipping, lighting, texturing, depth cueing, transparency processing, set-up, visible object determination, and virtual screen rendering of various graphics primitives occurring within the graphics data.","Depending upon the type of compressed graphics data received, rendering units A-D may be configured to perform arithmetic decoding, run-length decoding, Huffman decoding, and dictionary decoding (e.g., LZ77, LZSS, LZ78, and LZW). Rendering units A-D may also be configured to decode graphics data that has been compressed using geometric compression. Geometric compression of 3D graphics data may achieve significant reductions in data size while retaining most of the image quality. A number of methods for compressing and decompressing 3D geometry are described in:\n\n","Transformation refers to applying a geometric operation to a primitive or an object comprising a set of primitives. For example, an object represented by a set of vertices in a local coordinate system may be embedded with arbitrary position, orientation, and size in world space using an appropriate sequence of translation, rotation, and scaling transformations. Transformation may also comprise reflection, skewing, or any other affine transformation. More generally, transformations may comprise non-linear operations.","Lighting refers to calculating the illumination of the objects. Lighting computations result in an assignment of color and\/or brightness to objects or to selected points (e.g. vertices) on objects. Depending upon the shading algorithm being used (e.g., constant, Gourand, or Phong shading), lighting may be evaluated at a number of different locations. For example, if constant shading is used (i.e., the lighted surface of a polygon is assigned a constant illumination value), then the lighting need only be calculated once per polygon. If Gourand shading is used, then the lighting is calculated once per vertex. Phong shading calculates the lighting on a per-sample basis.","Clipping refers to the elimination of graphics primitives or portions of graphics primitives which lie outside of a 3-D view volume in world space. The 3-D view volume may represent that portion of world space which is visible to a virtual observer situated in world space. For example, the view volume may be a solid cone generated by a 2-D view window and a view point located in world space. The solid cone may be imagined as the union of all rays emanating from the view point and passing through the view window. The view point may represent the world space location of the virtual observer. Primitives or portions of primitives which lie outside the 3-D view volume are not currently visible and may be eliminated from further processing. Primitives or portions of primitives which lie inside the 3-D view volume are candidates for projection onto the 2-D view window.","In order to simplify the clipping and projection computations, primitives may be transformed into a second, more convenient, coordinate system referred to herein as the viewport coordinate system. In viewport coordinates, the view volume maps to a canonical 3-D viewport which may be more convenient for clipping against.","Graphics primitives or portions of primitives which survive the clipping computation may be projected onto a 2-D viewport depending on the results of a visibility determination. Instead of clipping in 3-D, graphics primitives may be projected onto a 2-D view plane (which includes the 2-D viewport) and then clipped with respect to the 2-D viewport.","Virtual screen rendering refers to calculations that are performed to generate samples for projected graphics primitives. For example, the vertices of a triangle in 3-D may be projected onto the 2-D viewport. The projected triangle may be populated with samples, and values (e.g. red, green, blue and z values) may be assigned to the samples based on the corresponding values already determined for the projected vertices. (For example, the red value for each sample in the projected triangle may be interpolated from the known red values of the vertices.) These sample values for the projected triangle may be stored in sample buffer . A virtual image accumulates in sample buffer  as successive primitives are rendered. Thus, the 2-D viewport is said to be a virtual screen on which the virtual image is rendered. The sample values comprising the virtual image are stored into sample buffer . Points in the 2-D viewport are described in terms of virtual screen coordinates X and Y, and are said to reside in virtual screen space.","When the virtual image is complete, e.g., when all graphics primitives have been rendered, sample-to-pixel calculation units  may access the samples comprising the virtual image, and may filter the samples to generate pixel values. In other words, the sample-to-pixel calculation units  may perform a spatial convolution of the virtual image with respect to a convolution kernel C(X,Y) to generate pixel values. For example, a red value Rfor a pixel P may be computed at any location (X,Y) in virtual screen space based on the relation: \n\n\nwhere the summation is evaluated at samples (X,Y) in the neighborhood of location (X,Y). Since convolution kernel C(X,Y) is non-zero only in a neighborhood of the origin, the displaced kernel C(X\u2212X,Y\u2212Y) may take non-zero values only in a neighborhood of location (X,Y). Similar summations to compute green and blue pixel values in terms of the green and blue sample values respectively may be performed in parallel with the red pixel value summation.\n","The value E is a normalization value that may be computed according to the relation:\n\n(),\n\nwhere the summation is evaluated for the same samples (X,Y) as in the red pixel value summation above. The summation for the normalization value E may be performed in parallel with the red, green and\/or blue pixel value summations. The location (X,Y) may be referred to as a pixel center, or a pixel origin. In the case where the convolution kernel C(X,Y) is symmetric with respect to the origin (0,0), the term pixel center is favored. The pixel values may be presented to one or more of display devices DDthrough DD.\n","In the embodiment of graphics board GB(I) shown in , rendering units A-D calculate sample values instead of pixel values. This allows rendering units A-D to perform super-sampling, i.e. to calculate more than one sample per pixel. Super-sampling is discussed more thoroughly below. More details on super-sampling are discussed in the following books:\n\n","Sample buffer  may be double-buffered so that rendering units A-D may write samples for a first virtual image into a first portion of sample buffer , while a second virtual image is simultaneously read from a second portion of sample buffer  by sample-to-pixel calculation units .","It is noted that the 2-D viewport and the virtual image which is rendered with samples into sample buffer  may correspond to an area larger than that area which is physically displayed via display devices DDthrough DD. For example, the 2-D viewport may include a viewable subwindow. The viewable subwindow represents displayable graphics information, while the marginal area of the 2-D viewport (outside the viewable subwindow) may allow for various effects such as panning and zooming. In other words, only that portion of the virtual image which lies within the viewable subwindow gets physically displayed. In one embodiment, the viewable subwindow equals the whole of the 2-D viewport. In this case, all of the virtual image gets physically displayed.","C. Data Memories","Each of rendering units A-D may be coupled to a corresponding one of instruction and data memories A-D. In one embodiment, each of memories A-D may be configured to store both data and instructions for a corresponding one of rendering units A-D. While implementations may vary, in one embodiment, each data memory A-D may comprise two 8 MByte SDRAMs, providing a total of 16 MBytes of storage for each rendering unit A-D. In another embodiment, RDRAMs (Rambus DRAMs) may be used to support the decompression and set-up operations of each rendering unit, while SDRAMs may be used to support the draw functions of each rendering unit. Data memories A-D may also be referred to as texture and render memories A-D.","D. Schedule Unit","Schedule unit  may be coupled between rendering units A-D and sample memories A-P. Schedule unit  is configured to sequence the completed samples and store them in sample memories A-P. Note in larger configurations, multiple schedule units  may be used in parallel. In one embodiment, schedule unit  may be implemented as a crossbar switch.","E. Sample Memories","Super-sampled sample buffer  comprises sample memories A-P, which are configured to store the plurality of samples generated by rendering units A-D. As used herein, the term \u201csample buffer\u201d refers to one or more memories which store samples. As previously noted, samples may be filtered to form each output pixel value. Output pixel values may be provided to one or more of display devices DDthrough DD. Sample buffer  may be configured to support super-sampling, critical sampling, or sub-sampling with respect to pixel resolution. In other words, the average distance between adjacent samples in the virtual image (stored in sample buffer ) may be smaller than, equal to, or larger than the average distance between adjacent pixel centers in virtual screen space. Furthermore, because the convolution kernel C(X,Y) may take non-zero functional values over a neighborhood which spans several pixel centers, a single sample may contribute to several output pixel values.","Sample memories A-P may comprise any of various types of memories (e.g., SDRAMs, SRAMs, RDRAMs, 3DRAMs, or next-generation 3DRAMs) in varying sizes. In one embodiment, each schedule unit  is coupled to four banks of sample memories, where each bank comprises four 3DRAM-64 memories. Together, the 3DRAM-64 memories may form a 116-bit deep super-sampled sample buffer that stores multiple samples per pixel. For example, in one embodiment, each of sample memories A-P may store up to sixteen samples per pixel.","3DRAM-64 memories are specialized memories configured to support full internal double buffering with single buffered Z in one chip. The double buffered portion comprises two RGBX buffers, where X is a fourth channel that can be used to store other information (e.g., alpha). 3DRAM-64 memories also have a lookup table that takes in window ID information and controls an internal 2-1 or 3-1 multiplexer that selects which buffer's contents will be output. 3DRAM-64 memories are next-generation 3DRAM memories that may soon be available from Mitsubishi Electric Corporation's Semiconductor Group. In one embodiment, 32 chips used in combination are sufficient to create a double-buffered 1280\u00d71024 super-sampled sample buffer with eight samples per pixel.","Since the 3DRAM-64 memories are internally double-buffered, the input pins for each of the two frame buffers in the double-buffered system are time multiplexed (using multiplexers within the memories). The output pins may be similarly time multiplexed. This allows reduced pin count while still providing the benefits of double buffering. 3DRAM-64 memories further reduce pin count by not having z output pins. Since z comparison and memory buffer selection are dealt with internally, use of the 3DRAM-64 memories may simplify the configuration of sample buffer . For example, sample buffer  may require little or no selection logic on the output side of the 3DRAM-64 memories. The 3DRAM-64 memories also reduce memory bandwidth since information may be written into a 3DRAM-64 memory without the traditional process of reading data out, performing a z comparison, and then writing data back in. Instead, the data may be simply written into the 3DRAM-64 memory, with the memory performing the steps described above internally.","However, in other embodiments of graphics board GB(I), other memories (e.g., SDRAMs, SRAMs, RDRAMs, or current generation 3DRAMs) may be used to form sample buffer .","Graphics processing unit  may be configured to generate a plurality of sample positions according to a particular sample positioning scheme (e.g., a regular grid, a perturbed regular grid, etc.). Alternatively, the sample positions (or offsets that are added to regular grid positions to form the sample positions) may be read from a sample position memory (e.g., a RAM\/ROM table). Upon receiving a polygon that is to be rendered, graphics processing unit  determines which samples fall within the polygon based upon the sample positions. Graphics processing unit  renders the samples that fall within the polygon and stores rendered samples in sample memories A-P. Note as used herein the terms render and draw are used interchangeably and refer to calculating color values for samples. Depth values, alpha values, and other per-sample values may also be calculated in the rendering or drawing process.","F. Sample-to-Pixel Calculation Units","Sample-to-pixel calculation units - through -V (collectively referred to as sample-to-pixel calculation units ) may be coupled between sample memories A-P and DACs A and B. Sample-to-pixel calculation units  are configured to read selected samples from sample memories A-P and then perform a filtering operation (e.g. a convolution) on the samples to generate the output pixel values which are provided to DACs A and\/or B. The sample-to-pixel calculation units  may be programmable to perform different filter functions at different times depending upon the type of output desired.","In one embodiment, the sample-to-pixel calculation units  may implement a super-sample reconstruction band-pass filter to convert the super-sampled sample buffer data (stored in sample memories A-P) to pixel values. The support of the band-pass filter may cover a rectangular area in virtual screen space which is Hpixels high and Wpixels wide. Thus, the number of samples covered by the band-pass filter is approximately equal to HWS, where S is the number of samples per pixel. A variety of values for H, Wand S are contemplated. For example, in one embodiment of the band-pass filter H=W=5. It is noted that with certain sample positioning schemes (see the discussion attending FIGS.  & ), the number of samples that fall within the filter support may vary as the filter center (i.e. pixel center) is moved in the virtual screen space.","In other embodiments, sample-to-pixel calculation units  may filter a selected number of samples to calculate an output pixel. The selected samples may be multiplied by a spatial weighting function that gives weights to samples based on their position with respect to the center of the pixel being calculated.","The filtering operations performed by sample-to-pixel calculation units  may use any of a variety of filters, either alone or in combination. For example, the filtering operations may comprise convolution with a box filter, a tent filter, a cylindrical filter, a cone filter, a Gaussian filter, a Catmull-Rom filter, a Mitchell-Netravali filter, a windowed sinc filter, etc. Furthermore, the support of the filters used by sample-to-pixel calculation units  may be circular, elliptical, rectangular (e.g. square), triangular, hexagonal, etc.","Sample-to-pixel calculation units  may also be configured with one or more of the following features: color look-up using pseudo color tables, direct color, inverse gamma correction, filtering of samples to pixels, and conversion of pixels to non-linear light space. Other features of sample-to-pixel calculation units  may include programmable video timing generators, programmable pixel clock synthesizers, cursor generators, and crossbar functions. Once the sample-to-pixel calculation units  have manipulated the timing and color of each pixel, the pixels are output to DACs A and B.","G. Digital-to-Analog Converters","Digital-to-Analog Converters (DACs) A and B\u2014collectively referred to as DACs \u2014operate as the final output stage of graphics board GB(I). DACs  translate digital pixel data received from calculation units  into analog video signals. DAC A couples to output video channel A, and DAC B couples to output video channel B. DAC A may receive a first stream of digital pixel data from one or more of calculation units , and converts the first stream into a first video signal which is asserted onto output video channel A. Similarly, DAC B may receive a second stream of digital pixel data from one or more of calculation units , and converts the second stream into a second video signal which is asserted onto output video channel B. Rather than fixing the allocation of calculation units  to output video channels, the preferred embodiment of graphics board GB(I) has a hardware architecture which allows particular calculation units  to be assigned to either output video channel on a per session basis. For example, all of calculation units  may be assigned to video channel A where graphics board GB(I) is to be used in the one board per projector scenario depicted in FIG. B. In situations where graphics board GB(I) is to be used in the \u201ctwo projector per board\u201d scenario of , a first subset of the calculation units  may be assigned to video channel A, and the remaining calculation units assigned to video channel B.","In the preferred embodiment, sample-to-pixel calculation units  provide pixel values to DACs  without an intervening frame buffer. However, in one alternate embodiment, sample-to-pixel calculation units  output the pixel values to a frame buffer prior to display.","In one embodiment DACs  may be bypassed or omitted completely in order to output digital pixel data in lieu of analog video signals. This may be useful where display devices DDthrough DDare based on a digital technology (e.g., an LCD-type display, an LCOS display, or a digital micro-mirror display).","As alluded to above, multiple graphics boards may be chained together so that they share the effort of generating video data for a display device. Thus, in the preferred embodiment, graphics board GB(I) includes a first interface for receiving one or more digital video streams from any previous graphics board in the chain, and a second interface for transmitting digital video streams to any subsequent graphics board in the chain.","It is noted that various embodiments of graphics board GB(I) are contemplated with varying numbers of render units , varying numbers of calculation units , and more or less than two video output channels, etc.","FIGS. -\u2014Super-sampling",{"@attributes":{"id":"p-0117","num":"0123"},"figref":"FIG. 4","b":["74","70","150","170"]},"Turning now to , an example of one embodiment of super-sampling is illustrated. In this embodiment, two samples are computed per pixel. The samples are distributed according to a regular grid. Even though there are more samples than pixels in the figure, output pixel values could be computed using one sample per pixel, e.g. by throwing out all but the sample nearest to the center of each pixel. However, a number of advantages arise from computing pixel values based on multiple samples.","A support region  is superimposed over pixel , and illustrates the support of a filter which is localized at pixel . The support of a filter is the set of locations over which the filter (i.e. the filter kernel) takes non-zero values. In this example, the support region  is a circular disc. The output pixel values (e.g. red, green, blue and z values) for pixel  are determined only by samples A and B, because these are the only samples which fall within support region . This filtering operation may advantageously improve the realism of a displayed image by smoothing abrupt edges in the displayed image (i.e., by performing anti-aliasing). The filtering operation may simply average the values of samples A-B to form the corresponding output values of pixel . More generally, the filtering operation may generate a weighted sum of the values of samples A-B, where the contribution of each sample is weighted according to some function of the sample's position (or distance) with respect to the center of pixel . The filter, and thus support region , may be repositioned for each output pixel being calculated. In other words, the filter center may visit the center of each output pixel for which pixel values are to be computed. Other filters and filter positioning schemes are also possible and contemplated.","In the example of , there are two samples per pixel. In general, however, there is no requirement that the number of samples be related to the number of pixels. The number of samples may be completely independent of the number of pixels. For example, the number of samples may be smaller than the number of pixels. (This is the condition that defines sub-sampling).","Turning now to , another embodiment of super-sampling is illustrated. In this embodiment, the samples are positioned randomly. Thus, the number of samples used to calculate output pixel values may vary from pixel to pixel. Render units A-D calculate color information at each sample position.","FIGS. -\u2014Super-sampled Sample Buffer with Real-time Convolution",{"@attributes":{"id":"p-0122","num":"0128"},"figref":"FIG. 6","b":["350","352","352","140","150","152","154","350"]},"In addition to the vertex data, draw process  (which may be performed by rendering units A-D) also receives sample position information from a sample position memory . The sample position information defines the location of samples in virtual screen space, i.e. in the 2-D viewport. Draw process  selects the samples that fall within the polygon currently being rendered, calculates a set of values (e.g. red, green, blue, z, alpha, and\/or depth of field information) for each of these samples based on their respective positions within the polygon. For example, the z value of a sample that falls within a triangle may be interpolated from the known z values of the three vertices. Each set of computed sample values are stored into sample buffer .","In one embodiment, sample position memory  is embodied within rendering units A-D. In another embodiment, sample position memory  may be realized as part of memories A-D, or as a separate memory.","Sample position memory  may store sample positions in terms of their virtual screen coordinates (X,Y). Alternatively, sample position memory  may be configured to store only offsets dX and dY for the samples with respect to positions on a regular grid. Storing only the offsets may use less storage space than storing the entire coordinates (X,Y) for each sample. The sample position information stored in sample position memory  may be read by a dedicated sample position calculation unit (not shown) and processed to calculate sample positions for graphics processing unit . More detailed information on the computation of sample positions is included below (see description of FIGS.  and ).","In another embodiment, sample position memory  may be configured to store a table of random numbers. Sample position memory  may also comprise dedicated hardware to generate one or more different types of regular grids. This hardware may be programmable. The stored random numbers may be added as offsets to the regular grid positions generated by the hardware. In one embodiment, sample position memory  may be programmable to access or \u201cunfold\u201d the random number table in a number of different ways, and thus, may deliver more apparent randomness for a given length of the random number table. Thus, a smaller table may be used without generating the visual artifacts caused by simple repetition of sample position offsets.","Sample-to-pixel calculation process  uses the same sample positions as draw process . Thus, in one embodiment, sample position memory  may generate a sequence of random offsets to compute sample positions for draw process , and may subsequently regenerate the same sequence of random offsets to compute the same sample positions for sample-to-pixel calculation process . In other words, the unfolding of the random number table may be repeatable. Thus, it may not be necessary to store sample positions at the time of their generation for draw process .","As shown in , sample position memory  may be configured to store sample offsets generated according to a number of different schemes such as a regular square grid, a regular hexagonal grid, a perturbed regular grid, or a random (stochastic) distribution. Graphics board GB(I) may receive an indication from the operating system, device driver, or the geometry data  that indicates which type of sample positioning scheme is to be used. Thus, sample position memory  is configurable or programmable to generate position information according to one or more different schemes. More detailed information on several sample positioning schemes are described further below (see description of FIG. ).","In one embodiment, sample position memory  may comprise a RAM\/ROM that contains stochastically determined sample points or sample offsets. Thus, the density of samples in virtual screen space may not be uniform when observed at small scale. Two bins with equal area centered at different locations in virtual screen space may contain different numbers of samples. As used herein, the term \u201cbin\u201d refers to a region or area in virtual screen space.","An array of bins may be superimposed over virtual screen space, i.e. the 2-D viewport, and the storage of samples in sample buffer  may be organized in terms of bins. Sample buffer  may comprise an array of memory blocks which correspond to the bins. Each memory block may store the sample values (e.g. red, green, blue, z, alpha, etc.) for the samples that fall within the corresponding bin. The approximate location of a sample is given by the bin in which it resides. The memory blocks may have addresses which are easily computable from the corresponding bin locations in virtual screen space, and vice versa. Thus, the use of bins may simplify the storage and access of sample values in sample buffer .","Suppose (for the sake of discussion) that the 2-D viewport ranges from (0000,0000) to (FFFF,FFFF) in hexadecimal virtual screen coordinates. This 2-D viewport may be overlaid with a rectangular array of bins whose lower-left corners reside at the locations (XX00,YY00) where XX and YY independently run from 0x00 to 0xFF. Thus, there are 256 bins in each of the vertical and horizontal directions with each bin spanning a square in virtual screen space with side length of 256. Suppose that each memory block is configured to store sample values for up to 16 samples, and that the set of sample values for each sample comprises 4 bytes. In this case, the address of the memory block corresponding to the bin located at (XX00,YY00) may be simply computed by the relation BinAddr=(XX+YY*256)*16*4. For example, the sample S=(1C3B,23A7) resides in the bin located at (1C00,2300). The sample value set for sample S is then stored in the memory block residing at address 0x8C700=(0x231C)(0x40) in sample buffer .","The bins may tile the 2-D viewport in a regular array, e.g. in a square array, rectangular array, triangular array, hexagonal array, etc., or in an irregular array. Bins may occur in a variety of sizes and shapes. The sizes and shapes may be programmable. The maximum number of samples that may populate a bin is determined by the storage space allocated to the corresponding memory block. This maximum number of samples is referred to herein as the bin sample capacity, or simply, the bin capacity. The bin capacity may take any of a variety of values. The bin capacity value may be programmable. Henceforth, the memory blocks in sample buffer  which correspond to the bins in virtual screen space will be referred to as memory bins.","The specific position of each sample within a bin may be determined by looking up the sample's offset in the RAM\/ROM table, i.e., the sample's offset with respect to the bin position (e.g. the lower-left corner or center of the bin, etc.). However, depending upon the implementation, not all choices for the bin capacity may have a unique set of offsets stored in the RAM\/ROM table. Offsets for a first bin capacity value may be determined by accessing a subset of the offsets stored for a second larger bin capacity value. In one embodiment, each bin capacity value supports at least four different sample positioning schemes. The use of different sample positioning schemes may reduce final image artifacts that would arise in a scheme of naively repeating sample positions.","In one embodiment, sample position memory  may store pairs of 8-bit numbers, each pair comprising an x-offset and a y-offset. (Other offsets are also possible, e.g., a time offset, a z-offset, etc.) When added to a bin position, each pair defines a particular position in virtual screen space, i.e. the 2-D viewport. To improve read access times, sample position memory  may be constructed in a wide\/parallel manner so as to allow the memory to output more than one sample location per read cycle.","Once the sample positions have been read from sample position memory , draw process  selects the samples that fall within the polygon currently being rendered. Draw process  then calculates the z and color information (which may include alpha or other depth of field information values) for each of these samples and stores the data into sample buffer . In one embodiment, sample buffer  may only single-buffer z values (and perhaps alpha values) while double-buffering other sample components such as color. Unlike prior art systems, graphics system  may use double-buffering for all samples (although not all components of samples may be double-buffered, i.e., the samples may have some components that are not double-buffered). In one embodiment, the samples are stored into sample buffer  in bins. In some embodiments, the bin capacity may vary from frame to frame. In addition, the bin capacity may vary spatially for bins within a single frame rendered into sample buffer . For example, bins on the edge of the 2-D viewport may have a smaller bin capacity than bins corresponding to the center of the 2-D viewport. Since viewers are likely to focus their attention mostly on the center of the screen SCR, more processing bandwidth may be dedicated to providing enhanced image quality in the center of 2-D viewport. Note that the size and shape of bins may also vary from region to region, or from frame to frame. The use of bins will be described in greater detail below in connection with FIG. .","In parallel and independently of draw process , filter process  is configured to: (a) read sample positions from sample position memory , (b) read corresponding sample values from sample buffer , (c) filter the sample values, and (d) output the resulting output pixel values onto video channels A and\/or B. Sample-to-pixel calculation units  implement filter process . Filter process  is operable to generate the red, green, and blue values for an output pixel based on a spatial filtering of the corresponding data for a selected plurality of samples, e.g. samples falling in a neighborhood of the pixel center. Other values such as alpha may also be generated. In one embodiment, filter process  is configured to: (i) determine the distance of each sample from the pixel center; (ii) multiply each sample's attribute values (e.g., red, green, blue, alpha) by a filter weight that is a specific (programmable) function of the sample's distance; (iii) generate sums of the weighted attribute values, one sum per attribute (e.g. a sum for red, a sum for green, . . . ), and (iv) normalize the sums to generate the corresponding pixel attribute values. Filter process  is described in greater detail below (see description accompanying , A, and ).","In the embodiment just described, the filter kernel is a function of distance from the pixel center. However, in alternative embodiments, the filter kernel may be a more general function of X and Y displacements from the pixel center. Also, the support of the filter, i.e. the 2-D neighborhood over which the filter kernel takes non-zero values, may not be a circular disk. Any sample falling within the support of the filter kernel may affect the output pixel value being computed.",{"@attributes":{"id":"p-0138","num":"0144"},"figref":"FIG. 7","b":["354","354","354","354","354","354","354","354","352","354","360","354","354","354","352","354","360","354","354","352","360"]},"Yet another alternative embodiment may store tags to offsets with the sample values in super-sampled sample buffer . These tags may be used to look-up the offset (i.e. perturbations) dX and dY associated with each particular sample.","FIGS. -: Sample Positioning Schemes",{"@attributes":{"id":"p-0140","num":"0146"},"figref":"FIG. 8","b":"190"},"In the perturbed regular positioning scheme , sample positions are defined in terms of perturbations from a set of fixed positions on a regular grid or tiling. In one embodiment, the samples may be displaced from their corresponding fixed grid positions by random x and y offsets, or by random angles (ranging from 0 to 360 degrees) and random radii (ranging from zero to a maximum radius). The offsets may be generated in a number of ways, e.g. by hardware based upon a small number of seeds, by reading a table of stored offsets, or by using a pseudo-random function. Once again, perturbed regular grid scheme  may be based on any type of regular grid or tiling. Samples generated by perturbation with respect to a grid or hexagonal tiling may particularly desirable due to the geometric properties of these configurations.","Stochastic sample positioning scheme  represents a third potential type of scheme for positioning samples. Stochastic sample positioning involves randomly distributing the samples across the 2-D viewport. Random positioning of samples may be accomplished through a number of different methods, e.g., using a random number generator such as an internal clock to generate pseudo-random numbers. Random numbers or positions may also be pre-calculated and stored in memory.","Turning now to , details of one embodiment of perturbed regular positioning scheme  are shown. In this embodiment, samples are randomly offset from a regular square grid by x- and y-offsets. As the enlarged area shows, sample  has an x-offset  that specifies its horizontal displacement from its corresponding grid intersection point . Similarly, sample  also has a y-offset  that specifies its vertical displacement from grid intersection point . The random x-offset  and y-offset  may be limited to a particular range of values. For example, the x-offset may be limited to the range from zero to X, where Xis the width of the a grid rectangle. Similarly, the y-offset may be limited to the range from zero to Y, where Yis the height of a grid rectangle. The random offset may also be specified by an angle and radius with respect to the grid intersection point .",{"@attributes":{"id":"p-0144","num":"0150"},"figref":"FIG. 10","b":["192","138","198","124","126","132","138","354"]},"FIG. \u2014Computing Pixels from Samples","As discussed earlier, the 2-D viewport may be covered with an array of spatial bins. Each spatial bin may be populated with samples whose positions are determined by sample position memory . Each spatial bin corresponds to a memory bin in sample buffer . A memory bin stores the sample values (e.g. red, green, blue, z, alpha, etc.) for the samples that reside in the corresponding spatial bin. Sample-to-pixel calculation units  (also referred to as convolve units ) are configured to read memory bins from sample buffer  and to convert sample values contained within the memory bins into pixel values.",{"@attributes":{"id":"p-0146","num":"0152"},"figref":"FIG. 11","b":["162","170","1","170","4","170","1","162","170"]},{"@attributes":{"id":"p-0147","num":"0153"},"figref":"FIG. 11","b":["170","170"]},"The amount of the overlap between columns may depend upon the horizontal diameter of the filter support for the filter kernel being used. The example shown in  illustrates an overlap of two bins. Each square (such as square ) represents a single bin comprising one or more samples. Advantageously, this configuration may allow sample-to-pixel calculation units  to work independently and in parallel, with each of the sample-to-pixel calculation units  receiving and convolving samples residing in the memory bins of the corresponding column. Overlapping the columns will prevent visual bands or other artifacts from appearing at the column boundaries for any operators larger than a pixel in extent.","Furthermore, the embodiment of  may include a plurality of bin caches  which couple to sample buffer . In addition, each of bin caches  couples to a corresponding one of sample-to-pixel calculation units . Bin cache -I (where I takes any value from one to four) stores a collection of memory bins from Column I, and serves as a cache for sample-to-pixel calculation unit -I. Bin cache -I may have an optimized coupling to sample buffer  which facilitates access to the memory bins for Column I. Since the convolution calculation for two adjacent convolution centers may involve many of the same memory bins, bin caches  may increase the overall access bandwidth to sample buffer .",{"@attributes":{"id":"p-0150","num":"0156"},"figref":"FIG. 12A","b":["162","400","406","170","400","176","402","404","176","400","400"],"sub":["L ","L ","v ","L ","v "]},"After completing convolution computations at a convolution center, convolution filter kernel  shifts to the next convolution center. Kernel  may be visualized as proceeding horizontally within Column I in the direction indicated by arrow . When kernel  reaches the right boundary  of Column I, it may shift down one or more bin rows, and then, proceed horizontally starting from the left column boundary . Thus the convolution operation proceeds in a scan line fashion, generating successive rows of output pixels for display.","In one embodiment, the cache line-depth parameter Dis set equal to D+1. In the example of , the filter support covers D=5 bins vertically. Thus, the cache line-depth parameter D=6=5+1. The additional bin row in bin cache -I allows the processing of memory bins (accessed from bin cache -I) to be more substantially out of synchronization with the loading of memory bins (into bin cache -I) than if the cache line-depth parameter Dwere set at the theoretical minimum value D.","In one embodiment, sample buffer  and bin cache -I may be configured for row-oriented burst transfers. If a request for a memory bin misses in bin cache -I, the entire bin row containing the requested memory bin may be fetched from sample buffer  in a burst transfer. Thus, the first convolution of a scan line may fill the bin cache -I with all the memory bins necessary for all subsequent convolutions in the scan line. For example, in performing the first convolution in the current scan line at the first convolution center , sample-to-pixel calculation unit -I may assert a series of requests for memory bins, i.e. for the memory bins corresponding to those spatial bins (rendered in shade) which intersect the support of filter kernel . Because the filter support  intersects five bin rows, in a worst case scenario, five of these memory bin requests will miss bin cache -I and induce loading of all five bin rows from sample buffer . Thus, after the first convolution of the current scan line is complete, bin cache -I may contain the memory bins indicated by the heavily outlined rectangle . Memory bin requests asserted by all subsequent convolutions in the current scan line may hit in bin cache -I, and thus, may experience significantly decreased bin access time.","In general, the first convolution in a given scan line may experience fewer than the worst case number of misses to bin cache -I because bin cache -I may already contain some or all of the bin rows necessary for the current scan line. For example, if convolution centers are located at the center of each spatial bin, the vertical distance between successive scan lines (of convolution centers) corresponds to the distance between successive bin rows, and thus, the first convolution of a scan line may induce loading of a single bin row, the remaining four bin rows having already been loaded in bin cache -I in response to convolutions in previous scan lines.","If the successive convolution centers in a scan line are expected to depart from a purely horizontal trajectory across Column I, the cache line-depth parameter Dmay be set to accommodate the maximum expected vertical deviation of the convolution centers. For example, in , the convolution centers follow a curved path across Column I. The curved path deviates from a horizontal path by approximately two bins vertically. Since the support of the filter kernel covers a 3 by 3 array of spatial bins, bin cache -I may advantageously have a cache line-depth Dof at least five (i.e. two plus three).","As mentioned above, Columns 1 through 4 of the 2-D viewport may be configured to overlap horizontally. The size of the overlap between adjacent Columns may be configured to accommodate the maximum expected horizontal deviation of convolution centers from nominal convolution centers on a rectangular grid.",{"@attributes":{"id":"p-0157","num":"0163"},"figref":"FIG. 12C","b":["420","162","170","420","400","170","400","420"],"sub":"0 "},"In one embodiment, sample-to-pixel calculation units  may generate one or more dummy bins to cover the marginal area of the filter support . Sample positions for the dummy bins may be generated by reflecting the sample positions of spatial bins across the 2-D viewport boundary. For example, dummy bins F, G, H, I and J may be assigned sample positions by reflecting the sample positions corresponding to spatial bins A, B, C, D and E respectively across of the boundary line Y=0. The sample positions for dummy bins may also be generated by translating the sample positions corresponding to spatial bins across the viewport boundary, or perhaps, by generating sample positions on-the-fly according to a regular, a perturbed regular or stochastic sample positioning scheme.","Predetermined color values may be associated with these dummy samples in the dummy bins. For example, the value (0,0,0) for the RGB color vector may be assigned to each dummy sample. As pixel center PCmoves downward (i.e. toward the boundary Y=0 and through it), additional dummy bins with dummy samples may be generated to cover filter support  (which moves along with the pixel center PC). Within filter support , the number of dummy samples (having the background color) increases and the number of rendered samples (having arbitrary colors) decreases. When the filter support  has moved entirely outside of the 2-D viewport , filter support  is populated entirely with dummy samples. Thus, as pixel center PCmoves toward the boundary and through it, the color value computed with filter support  smoothly approaches the predetermined background color.","In one alternative embodiment, only samples which reside inside the 2-D viewport  (and inside the filter support ) are allowed to contribute to the pixel's color computations, i.e. convolution sums. In other words, portions of filter support  which fall outside the 2-D viewport  may be ignored. As described later in connection with , the cumulative sums of weighted sample values are normalized by a cumulative sum of filter weights. This normalization compensates for the decreased number of samples which contribute to the cumulative sums at the boundary of the 2-D viewport .",{"@attributes":{"id":"p-0161","num":"0167"},"figref":"FIG. 12D","b":["170","422","420","170","354","420","400","422","420","354","162","402","402","162","402","402","162","402","162","402","402","422","422"],"sub":["1","1","2","2","1 ","1 "]},"In another embodiment, samples outside the viewable subwindow  contribute their rendered color values instead of the background color values to the pixel value computations.","In one alternative embodiment, only samples inside the filter support  and inside the viewable subwindow  are allowed to contribute to a pixel's color computations, i.e. convolution sums. In other words, samples outside the viewable subwindow  are not used in the computation of color values.","FIG. \u2014Rendering Samples into a Super-sampled Sample Buffer",{"@attributes":{"id":"p-0164","num":"0170"},"figref":["FIG. 13","FIG. 13"],"b":["200","102","106","202","150","204","150","150","206","208"]},"If the graphics system implements variable resolution super-sampling, then the triangles are compared with a set of sample-density region boundaries (step B). In variable-resolution super-sampling, different regions of the 2-D viewport may be allocated different sample densities based upon a number of factors (e.g., the center of the attention of an observer on projection screen SCR as determined by eye or head tracking). If the triangle crosses a sample-density region boundary (step ), then the triangle may be divided into two smaller polygons along the region boundary (step ). The polygons may be further subdivided into triangles if necessary (since the generic slicing of a triangle gives a triangle and a quadrilateral). Thus, each newly formed triangle may be assigned a single sample density. In one embodiment, graphics system  may be configured to render the original triangle twice, i.e. once with each sample density, and then, to clip the two versions to fit into the two respective sample density regions.","In step , one of the sample positioning schemes (e.g., regular, perturbed regular, or stochastic) is selected from sample position memory . The sample positioning scheme will generally have been pre-programmed into the sample position memory , but may also be selected \u201con the fly\u201d. In step , rendering units A-D may determine which spatial bins contain samples located within the triangle's boundaries, based upon the selected sample positioning scheme and the size and shape of the spatial bins. In step , the offsets dX and dY for the samples within these spatial bins are then read from sample position memory . In step , each sample's position is then calculated using the offsets dX and dY and the coordinates of the corresponding bin origin, and is compared with the triangle's vertices to determine if the sample is within the triangle. Step  is discussed in greater detail below.","For each sample that is determined to be within the triangle, the rendering unit draws the sample by calculating the sample's color, alpha and other attributes. This may involve a lighting calculation and an interpolation based upon the color and texture map information associated with the vertices of the triangle. Once the sample is rendered, it may be forwarded to schedule unit , which then stores the sample in sample buffer  (as indicated in step ).","Note the embodiment of the rendering method described above is used for explanatory purposes only and is not meant to be limiting. For example, in some embodiments, the steps shown in  as occurring serially may be implemented in parallel. Furthermore, some steps may be reduced or eliminated in certain embodiments of the graphics system (e.g., steps - in embodiments that do not implement geometry compression, or steps - in embodiments that do not implement a variable resolution super-sampled sample buffer).","Determination of Which Samples Reside Within the Polygon being Rendered","The determination of which samples reside within the polygon being rendered may be performed in a number of different ways. In one embodiment, the deltas between the three vertices defining the triangle are first determined. For example, these deltas may be taken in the order of first to second vertex (v2\u2212v1)=d12, second to third vertex (v3\u2212v2)=d23, and third vertex back to the first vertex (v1\u2212v3)=d31. These deltas form vectors, and each vector may be categorized as belonging to one of the four quadrants of the coordinate plane (e.g., by using the two sign bits of its delta X and Y components). A third condition may be added determining whether the vector is an X-major vector or Y-major vector. This may be determined by calculating whether abs(delta_x) is greater than abs(delta_y). Using these three bits of information, the vectors may each be categorized as belonging to one of eight different regions of the coordinate plane. If three bits are used to define these regions, then the X-sign bit (shifted left by two), the Y-sign bit (shifted left by one), and the X-major bit, may be used to create the eight regions as shown in FIG. .","Next, three edge inequalities may be used to define the interior of the triangle. The edges themselves may be described as lines in the either (or both) of the forms y=mx+b or x=ry+c, where rm=1. To reduce the numerical range needed to express the slope, either the X-major and Y-major equation form for an edge equation may be used (so that the absolute value of the slope may be in the range of 0 to 1). Thus, the edge (or half-plane) inequalities may be expressed in either of two corresponding forms:\n\nX-major: 0, when point (x,y) is below the edge;\n\nY-major: 0, when point (x,y) is to the left of the edge.\n","The X-major inequality produces a logical true value (i.e. sign bit equal to one) when the point in question (x,y) is below the line defined by the an edge. The Y-major equation produces a logical true value when the point in question (x,y) is to the left of the line defined by an edge. The side which comprises the interior of the triangle is known for each of the linear inequalities, and may be specified by a Boolean variable referred to herein as the accept bit. Thus, a sample (x,y) is on the interior side of an edge if\n\nX-major: (0)<xor> accept=true;\n\nY-major: (0)<xor> accept=true.\n","The accept bit for a given edge may be calculated according to the following table based on (a) the region (zero through seven) in which the edge delta vector resides, and (b) the sense of edge traversal, where clockwise traversal is indicated by cw=1 and counter-clockwise traversal is indicated by cw=0. The notation \u201c!\u201d denotes the logical complement.\n\n","Tie breaking rules for this representation may also be implemented (e.g., coordinate axes may be defined as belonging to the positive octant). Similarly, X-major may be defined as owning all points that tie on the slopes.","In an alternate embodiment, the accept side of an edge may be determined by applying the edge inequality to the third vertex of the triangle (i.e. the vertex that is not one of the two vertices forming the edge). This method may incur the additional cost of a multiply-add, which may be avoided by the technique described above.","To determine the \u201cfaced-ness\u201d of a triangle (i.e., whether the triangle is clockwise or counter-clockwise), the delta-directions of two edges of the triangle may be checked and the slopes of the two edges may be compared. For example, assuming that edge has a delta-direction of 1 and the second edge (edge) has a delta-direction of 0, 4, or 5, then the triangle is counter-clockwise. If, however, edge has a delta-direction of 3, 2, or 6, then the triangle is clockwise. If edge has a delta-direction of 1 (i.e., the same as edge), then comparing the slopes of the two edges breaks the tie (both are x-major). If edge has a greater slope, then the triangle is clockwise. If edge has a delta-direction of 7 (the exact opposite of edge), then again the slopes are compared, but with opposite results in terms of whether the triangle is clockwise or counter-clockwise.","The same analysis can be exhaustively applied to all combinations of edge and edge delta-directions, in every case determining the proper faced-ness. If the slopes are the same in the tie case, then the triangle is degenerate (i.e., with no interior area). It can be explicitly tested for and culled, or, with proper numerical care, it could be let through as it will cause no samples to render. One special case arises when a triangle splits the view plane. However, this case may be detected earlier in the pipeline (e.g., when front plane and back plane clipping are performed).","Note in most cases only one side of a triangle is rendered. Thus, if the faced-ness of a triangle determined by the analysis above is the one to be rejected, then the triangle can be culled (i.e., subject to no further processing with no samples generated). Further note that this determination of faced-ness only uses one additional comparison (i.e., of the slope of edge to that of edge) beyond factors already computed. Many traditional approaches may utilize more complex computations (though at earlier stages of the set-up computation).","FIG. \u2014Generating Output Pixels Values from Sample Values",{"@attributes":{"id":"p-0178","num":"0192"},"figref":["FIG. 15","FIG. 12A"],"b":["162","250","162","252","176","170","254","400"]},"Each sample in the selected bins (i.e. bins that have been identified in step ) is then individually examined to determine if the sample does indeed contribute (as indicated in steps -). This determination may be based upon the distance from the sample to the center of the output pixel being generated.","In one embodiment, the sample-to-pixel calculation units  may be configured to calculate this sample distance (i.e., the distance of the sample from the filter center) and then use it to index into a table storing filter weight values (as indicated in step ). In another embodiment, however, the potentially expensive calculation for determining the distance from the center of the pixel to the sample (which typically involves a square root function) may be avoided by using distance squared to index into the table of filter weights. In one embodiment, this squared-distance indexing scheme may be facilitated by using a floating point format for the distance (e.g., four or five bits of mantissa and three bits of exponent), thereby allowing much of the accuracy to be maintained while compensating for the increased range in values. In one embodiment, the table of filter weights may be implemented in ROM. However, RAM tables may also be used. Advantageously, RAM tables may, in some embodiments, allow the graphics system to vary the filter coefficients on a per-frame or per-session basis. For example, the filter coefficients may be varied to compensate for known shortcomings of the display\/projection device or for the user's personal preferences. The graphics system can also vary the filter coefficients on a screen area basis within a frame, or on a per-output pixel basis. Another alternative embodiment may calculate the desired filter weights for each sample using specialized hardware (e.g., multipliers and adders). The filter weight for samples outside the limits of the convolution filter may simply be multiplied by a filter weight of zero (step ), or they may be removed from the calculation entirely.","In one alternative embodiment, the filter kernel may not be expressible as a function of distance with respect to the filter center. For example, a pyramidal tent filter is not expressible as a function of distance from the filter center. Thus, filter weights may be tabulated (or computed) in terms of X and Y sample-displacements with respect to the filter center.","Once the filter weight for a sample has been determined, the attribute values (e.g. red, green, blue, alpha, etc.) for the sample may then be multiplied by the filter weight (as indicated in step ). Each of the weighted attribute values may then be added to a corresponding cumulative sum\u2014one cumulative sum for each attribute\u2014as indicated in step . The filter weight itself may be added to a cumulative sum of filter weights (as indicated in step ). After all samples residing in the support of the filter have been processed, the cumulative sums of the weighted attribute values may be divided by the cumulative sum of filter weights (as indicated in step ). It is noted that the number of samples which fall within the filter support may vary as the filter center moves within the 2-D viewport. The normalization step  compensates for the variable gain which is introduced by this nonuniformity in the number of included samples, and thus, prevents the computed pixel values from appearing too bright or too dark due to the sample number variation. Finally, the normalized output pixels may be output for gamma correction, digital-to-analog conversion (if necessary), and eventual display (step ).","FIG. \u2014Example Output Pixel Convolution",{"@attributes":{"id":"p-0183","num":"0197"},"figref":"FIG. 16","b":["288","288","288","296","294","292","290","290"]},"Example attribute values for samples - are illustrated in boxes -. In this example, each sample comprises red, green, blue and alpha values, in addition to the sample's positional data. Block  illustrates the calculation of each pixel attribute value prior to normalization. As previously noted, the filter values may be summed to obtain a normalization value . Normalization value  is used to divide out the unwanted gain arising from the non-constancy of the number of samples captured by the filter support. Block  illustrates the normalization process and the final normalized pixel attribute values.","The filter presented in  has been chosen for descriptive purposes only and is not meant to be limiting. A wide variety of filters may be used for pixel value computations depending upon the desired filtering effect(s), e.g., filters such as the box filter, the tent filter, the cylinder filter, the cone filter, the Gaussian filter, the Catmull-Rom filter, the Mitchell-Netravali filter, the windowed sinc filter, or in general, any form of bandpass filter or any of various windowed approximations to the sinc filter. Furthermore, the support of the filters used for the pixel value convolutions may be circular, elliptical, rectangular (e.g. square), triangular, hexagonal, etc.","It is a well known fact that the sinc filter realizes an ideal band-pass filter. However, the sinc filter takes non-zero values over the whole of the X-Y plane. Thus, various windowed approximations of the sinc filter have been developed. Some of these approximations such as the cone filter or Gaussian filter approximate only the central lobe of the sinc filter, and thus, achieve a smoothing effect on the sampled image. Better approximations such as the Catmull-Rom filter are obtained by approximating some of the negative lobes and positive lobes which surround the central positive lobe of the sinc filter. The negative lobes allow a filter to more effectively retain spatial frequencies up to the cutoff frequency and reject spatial frequencies beyond the cutoff frequency. A negative lobe is a portion of a filter where the filter values are negative. Thus, some of the samples residing in the support of a filter may be assigned negative filter values (i.e. filter weights).","The piecewise constant filter function shown in  with four constant regions is not meant to be limiting. For example, in one embodiment the convolution filter may have a large number of regions each with an assigned filter value (which may be positive, negative and\/or zero). In another embodiment, the convolution filter may be a continuous function that is evaluated for each sample based on the sample's distance (or X and Y displacements) from the pixel center. Also note that floating point values may be used for increased precision.","Full-screen Anti-aliasing","The vast majority of current 3D graphics systems only provide real-time anti-aliasing for lines and dots. While some systems also allow the edge of a polygon to be \u201cfuzzed\u201d, this technique typically works best when all polygons have been pre-sorted in depth. This may defeat the purpose of having general-purpose 3D rendering hardware for most applications (which do not depth pre-sort their polygons). In one embodiment, graphics system  may be configured to implement full-screen anti-aliasing by stochastically distributing up to sixteen samples per output pixel in 2-D viewport , and filtering the samples with a 5\u00d75 convolution filter (i.e. a filter which covers a 5 by 5 area measured in pixel units).","Notation for Data Operands","The notation X(sY.Z) is used herein to denote an X-bit quantity, where the X bits include: one sign bit, Y bits before the binary point, and Z bits after the binary point. Thus X=1+Y+Z. The notation X(s.Z) indicates an X-bit quantity, where the X bits include: one sign bit, and Z bits after the binary point. The notation X(sg.Y) denotes an X-bit quantity, where the X bits include: one sign bit, one guard bit, Y bits after the binary point.","Spatial Dithering of Color Samples","In one embodiment, graphics board GB(I) comprises a dither unit  as shown in FIG. . Dither unit  may be comprised within one or more of rendering units . Dither unit  comprises adder  and multiplexor . Dither unit  receives a sequence of N color values (e.g. red values) corresponding to the samples in a bin prior to their storage into sample buffer . For example, N may equal sixteen. The color values may be 14(s.13) quantities.","Dither unit  also receives a sequence of N dither values. The N dither values may be configured to have an average value of \u00bd (or approximately \u00bd). In some embodiments, the N dither values may approximate a uniform distribution of numbers between \u00bd\u2212A and \u00bd+A, where A is a rational number greater than or equal to one. The dither radius A may be programmable. In one particular embodiment, A equals one. The dither values may be 5(s1.3) quantities. The dither values may be sign extended to fourteen bits in anticipation of adding the dither values to the 14-bit color values. The sign extension may be efficiently implemented by hardwired pathways as suggested by connectivity pattern . Connectivity pattern  includes hardwired electrical pathways which (a) replicate the most significant bit, i.e. the sign bit, of the 5-bit input word to the ten most significant bits of the 14-bit output word, and (b) copy the four low order bits of the input word to the four lower order bits of the output word. The sign-extended dither values may be interpreted as having the form 14(s.13).","Adder  receives each color value Xand the corresponding sign-extended dither value D, and computes the sum D+X. In one embodiment, adder  provides the sum as a resultant value with the form 15(sg.13). If the sum is greater than one, adder  sets the guard bit of the resultant value to one. If the sum is negative, adder  sets the sign bit of the resultant value to one.","Multiplexor  includes data inputs I through I, control inputs C and C, and a single output. In one embodiment, each of the multiplexor inputs comprises 10 bits. Similarly, the multiplexor output may comprise 10 bits. The guard bit G of the resultant value is supplied to the control input C. The sign bit S of the resultant value is supplied to the control input C. The 3 least significant bits of the resultant value are discarded. The ten most significant bits of the resultant value after the binary point are supplied to input I of multiplexor . Input I is driven with the 10-bit value 0x3FF. Input I is driven with the 10-bit value 0x000. Input I is driven with the 10-bit value 0x000. Multiplexor  couples one of the four inputs I through I to the output based on the following control table. Other configurations are also possible and contemplated.",{"@attributes":{"id":"p-0194","num":"0208"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Control Table for Multiplexor 706"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"C = S","C = G","Action","Effect"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"0","0","Couple I0 to Output","Transmit Sum"]},{"entry":[{},"0","1","Couple I1 to Output","Clamp to MAX"]},{"entry":[{},"1","0","Couple I2 to Output","Clamp to Zero"]},{"entry":[{},"1","1","Couple I3 to Output","Clamp to Zero"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"If the sign bit S is set, multiplexor  couples either input  or input  to the output. In other words, if the resultant value is negative, the multiplexor output is clamped to zero. If the guard bit G is set while the sign bit S is clear, multiplexor  couples input I to the output. In other words, if the adder generated a value greater than one, the multiplexor output is clamped to the most positive value (i.e. \u201call ones\u201d=0x3FF). If neither the guard bit nor the sign bit are set, the 10 MSBs (after the binary point) of the resultant value are transmitted to the multiplexor output.","An output value presented at the multiplexor output is referred to herein as a dithered color value. Adder  generates a stream of resultant values in response to the sequence of dither values and sequence of color values. Similarly, multiplexor  generates a stream of dithered color values in response to the stream of resultant values. In one embodiment, the stream of dithered color values may be interpreted as 10(0.10) quantities, i.e. 10 bit unsigned quantities with all 10 bits following the binary point. The sequence of dithered color values generated at the multiplexor output may be stored in sample buffer . In one embodiment, sample buffer  may have 10 bits of storage per color per sample. This motivates the action of discarding the 3 LSBs of the resultant value.","Graphics board GB(I) may include dither units -, - and - similar to dither unit  for dithering respectively red values, green values, and blue values for the samples in a bin. The three dither units may dither the three colors in parallel. Alternatively, dither unit  may perform dithering for all three colors in a time-shared fashion. For example, in a first time period, dither unit  may dither the red values for the samples in a given bin. In a second time period, dither unit  may dither the green values for the same samples in the bin. In a third time period, dither unit  may dither the blue values for the same samples in the bin. After the third time period, dither unit  may advance to a next bin. Thus, the dither unit  may be used as a time-shared (i.e. multiplexed) resource.","The N dither values may be used repeatedly for successive bins. The dither values may be accessed from a dither lookup table.","Spatial Dithering of Alpha Values","Dithering may be applied to the alpha values in a similar way. In one embodiment, a separate dither unit  is used to dither alpha values as shown in FIG. . Dither unit  comprises adder  and multiplexor . Dither unit  receives a sequence of N alpha values corresponding to the samples in a bin prior to their storage into sample buffer . For example, N may equal sixteen. The alpha values may be 12(s.11) quantities. Dither unit  may receive the N alpha values while dither unit  concurrently receives the N color values for the same samples in the same bin.","Dither unit  may be configured to receive the same sequence of N dither values received by dither unit . The dither values, as originally presented to dither unit , may be 5(s1.3) quantities. The dither values may be sign-extended to twelve bits. The sign extension may be efficiently implemented by hardwired pathways as suggested by connectivity pattern . A sign-extended dither value may be interpreted as having the form 12(s.11).","Adder  receives each alpha value Aand the corresponding sign-extended dither value d, and computes the sum d+A. Adder  may provide the sum as a resultant value with the form 13(sg.11). If the sum is greater than one, adder  sets the guard bit of the resultant value to one. If the sum is negative, adder  sets the sign bit of the resultant value to one.","In one embodiment, multiplexor  includes data inputs J through J, control inputs D and D, and a single output. Each of the multiplexor inputs comprises 8 bits. Similarly, the multiplexor output comprises 8 bits. The guard bit G of the resultant value is supplied to the control input D. The sign bit S of the resultant value is supplied to the control input D. The 3 least significant bits of the resultant value are discarded. The eight most significant bits of the resultant value after the binary point are supplied to input J of the multiplexor . Input J is driven with the value 0xFF. Input J is driven with value 0x00. Input J is driven with the value 0x00. Multiplexor  couples one of the four inputs J through J to the output based on the following control table.",{"@attributes":{"id":"p-0203","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Control Table for Multiplexor 714"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D = S","D = G","Action","Effect"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"0","0","Couple J0 to Output","Transmit Sum"]},{"entry":[{},"0","1","Couple J1 to Output","Clamp to MAX"]},{"entry":[{},"1","0","Couple J2 to Output","Clamp to Zero"]},{"entry":[{},"1","1","Couple J3 to Output","Clamp to Zero"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"If the sign bit S is set, multiplexor  couples either input J or input J to the output. In other words, if the resultant value is negative, the multiplexor output is clamped to zero. If the guard bit G is set while the sign bit S is clear, multiplexor  couples input J to the output. In other words, if the adder  generated a value greater than one, the multiplexor output is clamped to the most positive value (i.e. all ones=0xFF). If neither the guard bit nor the sign bit are set, the 8 MSBs (after the binary point) of the resultant value, are transmitted to the multiplexor output. Other configurations are also contemplated.","An output value presented at the output of multiplexor  is referred to herein as a dithered alpha value. Adder  generates a stream of resultant values in response to the sequence of sign-extended dither values di and the sequence of alpha values A. Similarly, multiplexor  generates a stream of dithered alpha values in response to the stream of resultant values. The stream of dithered alpha values may be interpreted as 8(0.8) quantities, i.e. 8 bit unsigned quantities with all 8 bits following the binary point. The sequence of dithered alpha values generated at the multiplexor output may be stored in sample buffer . Sample buffer  may have 8 bits of storage for the alpha component of each sample. This motivates the action of discarding the 3 LSBs of the resultant values.","In an alternative embodiment, the dithering of color values and\/or alpha values may be performed by programmable hardware (e.g. a DSP core) instead of in dedicated hardware as described above.","FIG. \u2014Tabulated Example",{"@attributes":{"id":"p-0207","num":"0221"},"figref":"FIG. 18","b":["700","720","700","16","700"],"sub":["i ","i ","i ","i ","i","i","i ","i"],"sup":"10 "},"Observe that the total of the color values Xis 147.125, and the total of the truncated sums Trn(S) is 147. In contrast, the total of the rounded color values Trn(X+\u00bd) is 144. Thus, dithering may allow the average of the color values to survive truncation where simple rounding may not. It is noted that the advantages of dithering may be more pronounced when the original sample values Xare tightly clustered about their average value.","In some embodiments, dithering may be optional. For example, by loading the dither lookup table with the value zero, dither unit  may implement a truncation of the color values. Alternatively, by loading the dither lookup table with all values \u00bd, dither unit  may implement a rounding of color values.","Dealing with a Non-ideal Set of Dither Values","In the example above, the average of the dither values was {fraction (7\/16)}, i.e. not exactly \u00bd. Given a first set D of dither values Dhaving an average value of \u00bd+epsilon, it is possible to construct a complementary set C of dither values Chaving an average value of \u00bd-epsilon by reflection about \u00bd. In other words, for each dither value Din the first set, construct a complementary dither value according to the relation C=1\u2212D. If the samples in a first bin are dithered with the first set D of dither values, and samples from a second adjacent bin are dithered with the complementary set of dither values, then the two sets of dither values together will have an average value of \u00bd as desired.","Dither unit  (and\/or dither unit ) may operate on bins with the first set D or the second complementary set C in a checkerboard as shown in FIG. . Thus, any two horizontally or vertically adjacent bins in the 2-D viewport  may be dithered so that one bin uses the first set D and the other bin uses the complementary set C.","Pixel Value Computations","As described extensively above, sample-to-pixel calculation units  compute pixel values by filtering the 10-bit samples (e.g. red, green, blue or alpha samples) obtained from sample buffer . In particular, generic sample-to-pixel calculation unit -I generates a pixel value by computing a weighted average of samples localized at a virtual pixel center (X,Y) in the 2-D viewport . (See , and the attending description.) A filter kernel centered on the virtual pixel center (X,Y) is used to generate weighting values for samples. Samples falling within the support of the filter are included in the weighted average.","In one embodiment, intermediate computations in the weighted average are performed with at least M bits precision where M is larger than 10. Thus, the pixel value generated by sample-to-pixel calculation unit -I retains a precision of M bits.","Sample-to-pixel calculation unit -I may use the M-bit pixel value to perform gamma correction. Gamma correction involves the evaluation of a function f(V) on the M-bit pixel value V in order to compensate for the nonlinear response curve of a display device. The correction function f approximates the inverse of the nonlinear response curve. The function evaluation may be implemented as a table lookup. In order to obtain a gamma corrected value f(V) with 10 bits precision, the pre-corrected pixel value V may have at least 12 bits precision. Thus, precision length M may be at least 12. In one embodiment, M is exactly equal to 12.","Because of the dithering performed by dither unit , the M-bit pixel value, which is a weighted average of 10-bit samples (i.e. the samples after having added the dither values and truncated), more closely approximates the value which would be obtained if the weighted average were performed on the originally-rendered 14-bit samples. In situations where the originally rendered 14-bit samples represent a smoothly varying color field, this approximation property contributes to the elimination of false contouring, especially when M is greater than or equal to 12.","Furthermore, since the support of the filter kernel covers several bins, any bias to the weighted average induced by the dither set used for one bin may be compensated by the dither sets used for the remaining bins which intersect the support of the filter kernel. See FIG.  and attending discussion above.","Generalization of Operand Sizes","In the embodiment described above, it was assumed that the sample values as originally rendered by render units  were 14 bits, and that the truncated sample values stored into sample buffer  were 10 bits. This embodiment naturally generalizes. Let <K,L,M> denote an embodiment where (a) the sample values as originally rendered by render units  are K-bit quantities, (b) the truncated sample values stored into sample buffer  are L bit quantities, and (c) the precision length of the weighted average generated by sample-to-pixel calculation unit -I is equal to M. The present invention contemplates any embodiment <K,L,M> where K and M are larger than L.",{"@attributes":{"id":"p-0218","num":"0232"},"figref":"FIG. 20","b":["802","804","806","802","700","802","804","802","804","806","804","806","170"]},"Dithering unit  is configured to receive a set X of K-bit data values Xand a corresponding set of dither values D. In one embodiment, the set of data values represent a spatially co-located group of rendered sample values such as color or alpha. The dithering unit  is further configured (a) to add each data value Xand the corresponding dither value D, and (b) to truncate the resultant sums Sto L-bits. The set Y of L-bit truncated sums may be written to storage medium . In one alternative embodiment, dither values Dmay be stored within dithering unit .","The dither values Dmay have an average value of \u00bd (or approximately \u00bd). When adding the dither values to the data values X, the \u00bd bit position (i.e. the bit position whose weight equals \u00bd) of the dither values is aligned with the most significant bit of the resultant sum which is to be truncated. More generally, the dither values may have an average value of 2(or approximately 2) where u is an integer.","The dither values Dmay approximate a uniform distribution of numbers between \u00bd\u2212A and \u00bd+A, where A is a positive real number greater than or equal to one. In one embodiment, A equals one. For example, assuming that length N of the data set equals 2, the dither values may be chosen as: \n\n","Averaging unit  is configured to read the set Y of L-bit truncated sums from the storage medium, and to compute an average of the L-bit truncated sums. The average may be a weighted average, a straight average (i.e. total\/population-size), a nonlinear average, etc. The averaging computations are performed with M-bit precision, where M is larger than L. Thus, the average value resulting from the average computation is an M-bit quantity. Because of the dithering performed by dithering unit , the M-bit average value closely approximates the average of the original K-bit data values.","In one embodiment, the average value generated by averaging unit  represents a pixel value (e.g. color or alpha value). The pixel value may be transmitted to a display device for image visualization. Gamma correction may be applied to the pixel value prior to transmission to the display device.","Dithering unit  may receive a succession X(), X(), X(), . . . of input data sets, and may apply the above dithering operation to each input data set X(k). Thus, dithering unit  generates a set Y(k) of L-bit truncated sums for each input data set X(k), and stores the set Y(k) into storage medium . Dithering unit  may repeatedly use the same set of dither values to dither each input data set X(k). Alternatively, different sets of dither values may be used for successive input data sets. Averaging unit  reads each set Y(k) of L-bit truncated sums from the storage medium , and generates a corresponding average value V(k). Thus, averaging unit  produces a succession V(), V(), V(), . . . of average values. The sequence of average values V(), V(), V(), . . . may represent a filtered image.","FIG. \u2014Temporal Dithering",{"@attributes":{"id":"p-0225","num":"0239"},"figref":"FIG. 21","b":["902","904","906","902","700","902","904","902","906","904"]},"Dithering unit  is configured to receive a temporal stream u(), u(), u(), u(), . . . , u(j), . . . of K-bit data values. Dithering unit  is further configured to add a dither value D(j) to each K-bit data value U(j) of the temporal stream. The dither values D(j) may repeat, i.e. may be periodic with period N. Thus D(j)=D(j+kN) for any integer k. Dithering unit  may cyclically read the N dither values from a memory located internal to or external to dither unit . The sum values S(j)=D(j)+U(j) are truncated to L bits, where L is smaller than K, i.e. the (K\u2212L) least significant bits of the sums S(j) are discarded. The truncation may be performed to accommodate the storage capacity of storage medium . The truncated sums Trn[S(j)] are written into storage medium . Alternatively, L-bit truncated sums Trn[S(j)] may be transmitted onto a transmission medium (not shown).","Temporal averaging unit  is configured to read the stream of L-bit truncated sums Trn[S(j)] from storage medium  (or alternatively, to receive the L-bit truncated sums from the transmission medium), and to compute a time average of the L-bit truncated sums. For example, temporal averaging unit  may implement a FIR filter operation on the truncated sums Trn[S(j)]. Temporal average unit  may alternatively implement an IIR filter, a nonlinear filter, a median filter, etc. The length of the filter used by temporal averaging unit  may be a multiple of N.","Because of the dithering performed by dithering unit , the output signal Z(j) from the temporal average unit  closely approximates the signal which would have been obtained from performing the same averaging operation on the original K-bit data values.","The time-average computations may be performed with M-bit precision, where M is larger than L. Thus, the average values Z(j) generated by the temporal averaging unit  may be M-bit quantities.","Dithering with Truncation Versus Dithering with Rounding","Many of the above embodiments have described dithering in terms of adding dither values Dwith average value \u00bd to corresponding input data values Xto obtain sums Y=X+D, and truncating the sums Yto lower-precision values Z. Now, recall that the rounding of any number U may be achieved by adding \u00bd and then truncating: Round(U)=Trn(U+\u00bd). Furthermore, observe that sums Ymay be expressed in following form: Y=X+(D\u2212\u00bd)+\u00bd, and that the set of numbers D\u2212\u00bd has an average value of zero. Thus, the truncation of sum Yis the same as the rounding of X+(D\u2212\u00bd). In other words, all the above embodiments may be modified to operate with dither values Ehaving average value zero provided that the resulting sums X+Eare rounded instead of truncated, i.e. truncation units may be replaced by rounding units.","Dithering of Pixels Prior to Display","In one embodiment, sample-to-pixel calculation units  may spatially dither pixel values prior to display to further address the problem of false contouring. In other words, each sample-to-pixel calculation unit -I may add a zero-average noise function to the pixel values prior to transmission to a display device. The human eye may perform a spatial averaging of the pixel values which eliminates the false contouring.","In one alternative embodiment, the graphics system may be configured to directly render pixels in response to received geometry data, and thus, the graphics system may not include sample-to-pixel calculation units and instead utilize a traditional frame buffer. The graphics system may dither pixel values, i.e. add zero-mean spatial noise to the pixel values, prior to transmitting the pixel values to one or more video output ports. The pixel rendering and dithering may be performed in dedicated hardware, programmable hardware (e.g. a DSP core), or any combination thereof. The one or more display devices may then display images formed by the dithered pixel values. The eye and brain (i.e. visual cortex) of an observer then performs spatial filtering which allows the observer to interpolate perceived color values with higher resolution than the display resolution. Advantageously, this may result in a more visually pleasing and more accurate perceived image.","Although the embodiments above have been described in considerable detail, other versions are possible. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications. Note the headings used herein are for organizational purposes only and are not meant to limit the description provided herein or the claims attached hereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing, as well as other objects, features, and advantages of this invention may be more completely understood by reference to the following detailed description when read together with the accompanying drawings in which:",{"@attributes":{"id":"p-0027","num":"0028"},"figref":"FIG. 1","b":["112","84"],"sub":["1 ","Q"]},{"@attributes":{"id":"p-0028","num":"0029"},"figref":["FIG. 2A","FIG. 1"]},{"@attributes":{"id":"p-0029","num":"0030"},"figref":"FIG. 2B","b":"112"},{"@attributes":{"id":"p-0030","num":"0031"},"figref":"FIG. 2C","b":"112"},{"@attributes":{"id":"p-0031","num":"0032"},"figref":"FIG. 2D","b":"112"},{"@attributes":{"id":"p-0032","num":"0033"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0033","num":"0034"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0034","num":"0035"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0035","num":"0036"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0036","num":"0037"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0037","num":"0038"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0038","num":"0039"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0039","num":"0040"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0040","num":"0041"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0041","num":"0042"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0042","num":"0043"},"figref":["FIG. 12A","FIG. 12"],"b":"400"},{"@attributes":{"id":"p-0043","num":"0044"},"figref":["FIG. 12B","FIG. 11"],"b":"400"},{"@attributes":{"id":"p-0044","num":"0045"},"figref":"FIG. 12C"},{"@attributes":{"id":"p-0045","num":"0046"},"figref":"FIG. 12D"},{"@attributes":{"id":"p-0046","num":"0047"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0047","num":"0048"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0048","num":"0049"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0049","num":"0050"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0050","num":"0051"},"figref":"FIG. 17","b":["700","720"]},{"@attributes":{"id":"p-0051","num":"0052"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0052","num":"0053"},"figref":"FIG. 19","b":"420"},{"@attributes":{"id":"p-0053","num":"0054"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0054","num":"0055"},"figref":"FIG. 21"},"While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Please note that the headings are for organizational purposes only and are not meant to limit the description or claims."]},"DETDESC":[{},{}]}
