---
title: Planar mapping of graphical elements
abstract: Planar rendering is described. In an implementation, a method includes approximating a shape that corresponds to an overlapping portion of at least one graphical element that is translucent with another graphical element. A color is computed for the approximated shape from respective colors of each of the graphical elements and the translucence of the at least one graphical element. The approximated shape having the computed color is formed into a communication for output to a printer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08024648&OS=08024648&RS=08024648
owner: Microsoft Corporation
number: 08024648
owner_city: Redmond
owner_country: US
publication_date: 20090212
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation application of, and claims priority to, copending U.S. nonprovisional patent application Ser. No. 10\/935,025, filed on Sep. 7, 2004, entitled \u201cPlanar Mapping of Graphical Elements\u201d to inventors Foehr, et al. This application also incorporates by reference the entire disclosure of each of the following U.S. Provisional Patent Applications, and claims priority under 35 U.S.C. \u00a7119(e) to the following U.S. Provisional Patent Applications, each of which was filed on May 3, 2004:\n\n","This application also incorporates by reference the entire disclosure of co-pending U.S. nonprovisional patent application Ser. No. 10\/794,669, filed on Apr. 30, 2004, entitled \u201cDocument Mark Up Methods and Systems\u201d to inventors Emerson et al.","The present invention generally relates to computing and rendering devices, and more particularly relates to systems and methods that provide planar mapping of graphical elements.","A variety of rendering devices may be communicatively coupled to a computing device to provide an output for a user. For example, a computing device configured as a desktop personal computer (PC) may include a display device (e.g., a monitor) that provides an output for viewing by the user and a printer for printing images to a printable medium which may then be viewed by the user. Each rendering device, however, may support different rendering functionality, one to another, such that one provides an output that cannot be rendered as intended by utilizing another.","A graphics environment for output on a display device, for instance, may support a concept known as transparency. Transparency is used to provide a visual effect in which a graphical element that is rendered using the effect may appear to be transparent or translucent to varying degrees. For instance, a translucent object, when displayed, enables any underlying object and\/or background to be seen through the translucent object to varying degrees depending on an amount of transparency that is specified for the translucent object.","Traditional printers, however, do not support transparency. For instance, for each graphical element that is to be printed to a page utilizing a traditional printer, there are a variety of different scenarios that can be encountered. In a first scenario, a pixel of the graphical element is to be drawn to a location which does not already contain a pixel. In this scenario, the pixel does not affect any other pixel and therefore can be drawn to the location. In a second scenario, a new pixel is to be drawn to a location having a preexisting pixel. In this scenario, however, traditional printing devices merely overwrite the preexisting pixel using the new pixel. Therefore, when a new graphical element that contains the new pixel is printed using a traditional printer in the second scenario, the new graphical element opaquely covers any preexisting graphical element that was previously provided for output at that location.","In a third scenario, portions of an output file that contain translucent and overlapping graphical elements for output are rasterized to form a rasterized image, such as a bitmap. A raster is a grid of individual coordinates that is used to specify a location of each individual pixel in a display. A raster image identifies each of the coordinates in the raster and a corresponding color value. Rasterizing a portion of the image file, however, introduces resolution dependency. For example, to display the rasterized image as intended, a printer should have a resolution that generally corresponds to the resolution of the rasterized image. Additionally, because each individual pixel is mapped in a rasterized image, the amount of memory used to store a raster image generally consumes more memory resources than a vector image. Vector images are created through a sequence of mathematical statements that may be utilized to place vector shapes in a two-dimensional space. Therefore, instead of using a storage location for each pixel of a line drawing, a vector image describes a series of points to be connected.","Accordingly, there is a continuing need for planar rendering such that transparency functionality may be provided in a memory efficient manner using traditional printers that would not otherwise support transparency.","Planar mapping of graphical elements is described. Content with translucent graphical elements is converted into visually equivalent content that avoids using transparency functionality, thereby enabling graphical environments that do not support transparency functionality to output the content as intended. Additionally, rasterization of the translucent graphical elements may be avoided, thereby conserving memory resources.","In an implementation, a method includes approximating a shape that corresponds to an overlapping portion of at least one graphical element that is translucent with another graphical element. A color is computed for the approximated shape from respective colors of each of the graphical elements and the translucence of the at least one graphical element. The approximated shape having the computed color is formed into a communication for output to a printer.","The same numbers are used throughout the disclosure and figures to reference like components and features.","Overview",{"@attributes":{"id":"p-0026","num":"0031"},"figref":"FIG. 1","b":"100"},"Transparency may be specified a graphical image using a special encoding of color values of elements and their constituting pixels. In addition to the standard color channels, such as Red, Green and Blue (RGB) or Cyan, Magenta, Yellow and Black (CMYK), there is an additional channel called an \u201calpha channel\u201d. The value of this alpha channel (i.e., the alpha value), for instance, can range from 0.0 to 1.0 (or 0 to 255, depending on the range of values used). The alpha value of 0.0 (or 0) is generally utilized to represent a fully transparent pixel, and the alpha value of 1.0 (or 255) is generally utilized to represent a fully opaque pixel.","The environment  of  is illustrated as including a computing device  and a plurality of target entities, one of which is illustrated as a display device  and another one of which is illustrated as a printer . The computing device  includes an application  which is executable thereon to provide and\/or request a translucent graphical element . When the translucent graphical element  is rendered, its corresponding color channels (e.g., RGB or CMYK) are blended with the color channels of any other graphical element it overlaps that has already been rendered. In an implementation, alpha blending operates on pixels already provided for output to the destination surface and does not differentiate between pixels based on the originating graphical element that contains the pixels.","A video adapter , for instance, may be provided for processing the translucent graphical element  for display on a screen  of the display device . The video adapter  includes a frame buffer  that stores graphical elements for output to the display device  and for display on the screen . In this instance, however, the alpha blending operation utilizes read access to the frame buffer  or destination surface (e.g., the screen ) in order to read back each preexisting pixel's value(s), such as color and alpha values. Read and write access is illustrated between the application , the frame buffer , and the display device  through the use of double-ended arrows , .","While read access to the frame buffer  is provided for some target entities (e.g., the video adapter , software rasterizers, and so on), read access is not typically available for printers. For example, the computing device  may include a printer adapter  that is configured to process the translucent graphical element  for output to the printer . Once the commands to process the translucent graphical element  have been sent to the printer  (e.g. by a driver), its internal state changes, the application  or other software executing on the computing device  may not be able to determine a new device state. Thus, the output from the application  may be unidirectional through the printer adapter  to the printer  even though the printer adapter  may also include a frame buffer . The absence of read access is illustrated between the application , printer adapter , and printer  through the use of single-ended arrows , .","Page description languages (PDLs) that do not allow specification of alpha values require special treatment of transparent and translucent objects. A PDL may be thought of as a command set used to transmit graphical elements (along with their positions and attributes) to a printer. One method is rasterization of the transparent content. Rasterization, as previously described, is generally considered undesirable because of the significant memory resources utilized to store rasterized portions of an image.","Planar rendering is described which, in an implementation, limits and\/or avoids rasterization of portions of an image. Instead, planar rendering may be utilized to retain an elemental nature of the content and record each graphical element in a display list that is used track of the area covered by each graphical element and its relative z order position, one to another. When the transparent graphical element  is to be rendered, for instance, a converter module  may be executed to find overlapping areas of the translucent graphical element with any previous graphical elements recorded in a display list . In a second step, the translucent graphical element  is added to the display list  with its color computed as if it was transparently printed on a printable medium, such as a white surface for white paper. In subsequent steps, the effective color of each previously determined overlapping area is computed according to one or more transparency blending (e.g., alpha blending) algorithms. In a last step, a new graphical element is generated for each overlapping area and recorded in the display list  (together with the computed effective color values), according to the z order of the graphical elements. This results in a display list  that provides a planar map of graphical elements, where each graphical element has a deterministic color that is independent from any previously included graphical element. This display list  can then be translated into PDL commands using a printer driver for output to the printer .","The following discussion is arranged into a plurality of sections. A first section provides a glossary of terms as utilized in instances of this document. A second section describes an exemplary system for producing and consuming structured job information that can contain graphical elements that utilize transparency functionality. A third section includes illustrations and flow charts describing exemplary procedures which may be implemented utilizing the exemplary system.","Glossary","The term \u201cjob\u201d used herein refers to a task in which one or more actions are performed to process rendering information. For instance, a print job may entail printing job information that defines one or more documents. More generally, reference to \u201cprocessing\u201d job information can refer to any kind of rendering of such job information, such as printing or displaying such job information. Alternatively, processing can refer to distributing the job information to a target destination (with or without modifying it), archiving the job information, or some other form of processing. The term \u201cjob information\u201d refers to any kind of information used to specify the nature of the job, such as the actual information to be rendered, and\/or information that defines how the job is to be rendered, and so on.","A \u201cpackage\u201d is a logical concept that refers to a collection of job information that comprehensively specifies an entire job. The package can contain multiple \u201cparts.\u201d A \u201cpayload\u201d corresponds to a collection of parts treated as a single unit, and which satisfies certain characteristics. For instance, a package may specify multiple payloads that respectively define different renditions of a single document, and each of these payloads can contain multiple parts (e.g., image resources, font resources, and so forth).","The term \u201cdocument\u201d as used herein refers to any unit of any kind of information. For example, a document may pertain to information created by a text editing application, a spreadsheet processing program, a drawing program, and so on. Each document can have multiple associated parts, each of which can itself be considered a component document in its own right. A job can specify documents that originate from multiple different sources.","The term \u201cspool storage\u201d represents storage for storing job information implemented using any physical storage medium. In one case, a device may implement the spool storage using RAM memory. In another case, the device may implement the spool storage using disk storage, and so on. The spool storage may define a single file, a collection of associated files, or some other storage strategy. A unit of spool storage (such as a single file) that stores an entire package defining a job is also referred to as a \u201ccontainer.\u201d Alternatively, the spool storage can refer to transitory information transmitted via a communication channel and inherently stored on that channel during transport.","Generally, any of the functions described herein can be implemented using software, firmware (e.g., fixed logic circuitry), manual processing, or a combination of these implementations. The terms \u201cmodule,\u201d \u201cfunctionality,\u201d and \u201clogic\u201d as used herein generally represents software, firmware, or a combination of software and firmware. In the case of a software implementation, the module, functionality, or logic represents program code that performs specified tasks when executed on a processing device or devices (e.g., CPU or CPUs). The program code can be stored in one or more computer readable memory devices. The features of the planar rendering strategies described below are platform-independent, meaning that the planar rendering strategies may be implemented on a variety of commercial computing platforms having a variety of processors.","Processors are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example, processors may be comprised of semiconductor(s) and\/or transistors (e.g., electronic integrated circuits (ICs)). In such a context, processor-executable instructions may be electronically-executable instructions. Alternatively, the mechanisms of or for processors, and thus of or for a computing device, may include, but are not limited to, quantum computing, optical computing, mechanical computing (e.g., using nanotechnology), and so forth.","Exemplary Environment",{"@attributes":{"id":"p-0040","num":"0045"},"figref":"FIG. 2","b":["200","202","202","204","202","206"]},"As broadly indicated in , the job information  includes a defined structure . The structure  generally includes a plurality of nodes that are connected together according to a set of established rules. The same general rules apply to the construction of the structure  regardless of the application and application platform used to generate the job information .","In the exemplary case of , the structure  uses a hierarchical scheme to connect the nodes together. A hierarchical scheme couples the nodes together using parent-child relationships. That is, a \u201ctop-most\u201d node defines a so-called root node. Thus, the use of the terms \u201ctop\u201d and \u201cbottom\u201d refer to placement in the hierarchical scheme relative to the root node. The root node includes one or more child nodes, and the child nodes, in turn, can include one or more of their own respective child nodes, and so on. If so configured, child nodes can generally inherit properties associated with their respective parent\/ancestor nodes.","Generally, the structure  is a logical concept that may or may not map to actual parts of a document to be rendered. That is, each node may be considered an object. Certain objects may represent actual parts of a document to be rendered (such as various image resources and font resources). Other objects may not have a one-to-one relationship with parts of the documents to be rendered. These latter types of nodes are therefore analogous to folders in a file hierarchy; that is, the folders may store individual files that contain content that maps to actual parts of the document, but the folders themselves may not have a one-to-one relationship with actual parts of the document.","The production and consumption aspects (, ) of the processing of job information  will be addressed separately below. First, by way of overview, the system  includes an application module  and conversion logic  coupled to a spool storage  via application programming interfaces (APIs) . The spool storage  stores the job information . This chain of components implements the production aspects () of the processing of the job information . The system  also includes a spooling module  that is configured to retrieve the job information  from the spool storage  and then perform some kind of processing on it to provide an output result. This chain of components implements the consumption () aspects of the processing of the job information . As noted above, processing can refer to any kind of action performed on the job information , which may or may not modify the content of the job information . The processing may comprise printing the job information , displaying the job information , routing the job information  to a target location (with or without modifying it), archiving the job information , and so on. In any case, the recipient of the output result generated by the spooling module  can include one or more of the target entities (, , . . . , ) associated with different usage cases . A variety of the usage cases  will be discussed below.","The modules, logic and storage units shown in the system  can be implemented by any variety and grouping of physical mechanisms and devices. In one exemplary case, a computing device (not shown here) executes the application module , the conversion logic , the APIs , the spool storage  and the spooling module . More specifically, the various logic and modules (, , , ) can be implemented by machine readable code that is storable in the memory of the computing device and executed by a processing unit(s) of a computing device. The spool storage  can be implemented by a storage medium (e.g., hard disk) provided by the computing device. The computing device can operate using any kind of platform (e.g., as defined by the operating system and\/or other software configuration of the computing device). In other words, in one implementation, the functionality and associated formats to be described below are specifically configured to operate on different computing platforms, thus defining a standard approach that has wide applicability to different technical environments and which thus serves to facilitate interaction among different technical environments and associated users.","In one case, the target entities (, , . . . , ) can be implemented as devices which are separate from the computing device which implements the other components (-) of the system . The computing device can be communicatively coupled to the target entities (, , . . . , ) via any kind of communication channel, such as a USB coupling, a parallel coupling, a removable media coupling, a network coupling of any kind, and so forth. In a common case, for instance, one or more of the target entities (, , . . . , ) are configured as rendering devices for rendering documents, such as printers for printing documents that are provided by the spooling module . The computing device can be communicatively coupled to the printer(s) via any kind of hardwired and\/or wireless links using any kind of communication protocol. The target entities (, , . . . , ) can alternatively represent display devices, storage devices, other computing devices, and so on.","The above allocation of system  functions to particular devices is only exemplary. In other implementations, different aspects of the system  can be implemented by separate computing devices. For instance, a first computing device can implement the application module  and a separate computing device can implement the spooling module . In other implementations, the spool storage  can also be implemented as a separate unit which couples to the computing device which implements the application module  and\/or the spooling module . In other implementations, the target entities (, , . . . , ) can be integrated into the same computing device which implements the application module  and\/or the spool module . Still other configurations are possible, examples of which are illustrated throughout the present description.","In any event, where one or more computing devices are used to perform aspects of the system , those computing devices can correspond to any type of computing devices, such as general purpose computing devices (e.g., desktop PCs), application-specific computing devices (e.g., game consoles), portable computing devices (e.g., personal digital assistants and mobile phones), and so on.","Further details regarding each of the above-identified components of the system  will follow. Beginning with the production aspect () of the system , the system  can use any kind of application module  to generate any kind of job information , typically associated with any kind of document. Common types of application modules  include text processing programs, spreadsheet processing programs, graphics processing programs, markup language processing programs, database search and retrieval programs, and so on. There is no constraint on the type of application program that can be used to supply job information  to be processed using the system .","Conversion logic , in association with APIs , ensures that the job information sent to the spooler storage  has the required structure . In one case, the application module  can itself supply the conversion logic  as part of its tools. In another case, the system  may employ a separate module to implement the conversion logic . In this case, different commercial providers can supply the application module  and the conversion logic . The specific nature of the transformations performed by the conversion logic  is dictated by the prescribed format of the structure . The forthcoming explanation of the format of the structure  will also provide detail regarding the nature of the transformation performed by the conversion logic  (if, in fact, any transformation is required). Alternatively, or in addition, the spooling module  can play a role in the generation of the job information  having the required structure .","APIs  define one or more interfaces for facilitating interaction among the components shown in the system . For example, the APIs  facilitate the storage of job information  in the spool storage  and the subsequent retrieval of the job information  from the spool storage . More specifically, exemplary and non-limiting functions performed by the APIs  can include: (1) submitting job information  to the spooling module  for scheduling and printing; (2) querying the state of the job while in the spooling module ; (3) monitoring different stages of the job production and hooking up to back end notifications to inform any interested listening entities; (4) monitoring different stages of the job consumption and hooking up to back end notifications to inform any interested listening entities; (5) enabling the spooling module  to send output data to the target entities (, , ), and so on. Job information can be supplied to and retrieved from the spool storage  in a number of different modes, such as, for example, a streaming mode. In a streaming mode, portions of the job information are stored or processed in piecemeal fashion as it is being received.","The APIs  can generally be implemented as a plurality of methods and properties. In the context of an object-oriented programming paradigm, the APIs  can be defined by a collection of classes which specify such methods and properties.","With respect to the consumption () aspect of the system , the system  retrieves the resource information  from the spool storage  and supplies it to the spooling module  for processing. The spooling module  can represent a software program implemented by the same computing device that provides the application module . It includes processing logic  for processing the job information . This processing logic , in turn, can include management logic  for governing various operations performed by the processing logic .","The processing logic  can also include filter logic  for actually performing the required processing on the job information . In an implementation, the processing logic  corresponds to the converter module  of  and the filter logic  corresponds to the filter pipeline  of . As will be described in greater detail below in relation to , the filter logic  (e.g., filter pipeline ) can include one or more filters (, , . . . , ) for performing different processing functions on the job information  to generate an output result. The spooling module  then feeds the final output result to one or more of the target entities (, , . . . , ) via a device port . In the common case of printing, one or more of the target entities (, , . . . , ) include a printer which receives the output result and prints the document(s) specified by the output result. Finally, the spooling module  can also include generically-labeled other logic  for performing other related and unrelated functions.","Further details regarding the filter logic  are provided as follows. In one implementation, the job information  that is processed by one or more of the filters (, , . . . ) has the same format structure  as the job information  stored in the spool storage . Thus, in this exemplary implementation, the filter logic  does not require that the job information  be converted into an intermediary form in order to process it. This, in turn, enables the spooling module  to process job information  in a more efficient manner compared to those techniques that require such conversion. This also yields a more uniform approach compared to some other techniques, which may resort to a complicated assortment of disparate and ad hoc processing techniques to deal with different proprietary formats that can be used to store job information in the spooler storage .","The functions performed by the individual filters (, , . . . , ) can be generalized in the following manner. A first class of filters accepts job information  which conforms to the structure , performs some kind of processing on this information  (which may or may not modify the information ), and then generates an output result which also conforms to the structure . A second class of filters accepts job information  which conforms to the structure , performs some kind of processing on this information , and then generates an output result which does not conform to the structure  (or which only partially conforms to the structure ). A third class of filters accepts job information  which has already been converted into a non-structured format, and provides yet further modification or processing of such non-structured information.","More specifically, for example, one or more initial filters of the first class can be set up to modify the job information  in various ways (e.g., by adding a watermark, and so on), but do not otherwise change its basic format structure . A terminal filter of the second class can be set up to modify the job information  by changing its format, such as by either completely removing its format structure  or at least partially modifying its format structure . More specifically, the terminal filter (e.g., filter n ) can be used to convert job information  having the format structure  into a non-structured form that can be interpreted by an identified target entity (, , . . . , ). In effect, the filters (-), when taken together, thus serve the role of a printer driver. For instance, filter n  may convert the job information  having the structure  into a print description language (PDL) format that can be fed to a printer which accepts such format.","Suppose, as explained above, that the terminal filter n  is a filter of the first class which generates an output result having job information  which still conforms to the structure . A target entity  represents an appropriate device to receive such an output result. This target entity  is referred to as \u201cstructure-aware\u201d because it receives job information  conforming to the structure  and thus includes processing functioning to recognize such information  and process it appropriately.","Suppose, alternatively, that the terminal filter n  is a filter of the second class or third class which generates job information which no longer conforms to the structure . A target entity  represents an appropriate entity to receive such an output result. This target entity  is referred to as \u201cstructure-unaware\u201d because it receives job information  that no longer conforms to the structure , and thus the entity  does not need to devote any specialized functionality for processing information expressed in this structure ; indeed, the target entity  need not, and generally will not, be aware that the job information  its receives (e.g., in an appropriate PDL format) was ever originally expressed using the structure .","There is a third case where the terminal filter n  generates an output result which modifies the structured format  to some extent, but still maintains some vestiges of the structure . Target entity  is an example of a kind of entity that can receive and processing this output result.  identifies this kind of entity  as being \u201cpartially structure-aware\u201d because it should include at least some processing functionality for interpreting whatever remnants of the structure  that still remain in the output result.","Different jobs may require that different filtering operations be performed on the associated job information . The filter logic  (e.g., the converter module  of ) can be used to define what filters (, , . . . , ) are to be invoked in processing a particular job, how the individuals filters (, , . . . , ) are to be configured, and how the filters (, , . . . , ) are to be chained together. In other words, the filter logic  can select and chain the filters (, , . . . , ) together in different ways to produce different net effects. In a series configuration shown in , for example, filter a  feeds its output result into the input of filter b , and filter b  feeds its output result into to the input of another filter, and so on.","More specifically, the type of processing that the filter logic  performs on the job information  can be controlled, in part, by one or more \u201cprint tickets\u201d associated with the job information . The print tickets include attribute information that defines the operations that should be performed on the job information  as it passes through the filter logic . Different print tickets can be associated with different parts of the structure  of the job information . For instance, a print ticket can be associated with the root of the structure , so as to globally apply print instructions to the entire job. A print ticket can be associated with another node farther down in the hierarchy of the structure  to apply more localized print instructions with respect to some part of the job. For example, this feature allows different processing rules to be assigned to two different pages of a single print job, or different parts of a single page, and so on.",{"@attributes":{"id":"p-0063","num":"0068"},"figref":["FIG. 3","FIG. 2"],"b":["300","202","208","300","202","210","210","208","212","216","210","202","208","218","208"]},"The top level of the hierarchy specifies job-related information  that identifies the entire job itself. For instance, the job may pertain to the printing of a book including multiple chapters, and each chapter, in turn, can include multiple pages, and each page, in turn, can include font resources and image resources. In this example, the top level of the hierarchy identifies the logical package which encapsulates the entire job, that is, the entire book. The next level of the hierarchy specifies information  that identifies the documents associated with the job. In the example of the book, the document level might specify individual chapters in the book. Or this level of the hierarchy may specify different kinds of documents to be printed in a single print job, such a first document created using a text editor, and a second document created using a spreadsheet program, and so on, where these two documents together form a report of some kind. The next level of the hierarchy specifies information  that identifies different renditions of the documents identified in the preceding level. For instance, consider the case of a chapter of a book. This chapter can be specified in a first rendition that requires that the chapter be printed in a black and white mode, and a second rendition that requires that the chapter be printed in a color mode. Or different renditions may correspond to different languages used to present information in the document, and so on. Depending on configuration information and other factors, the spooling module  or other processing logic can select an appropriate one of the renditions to process and present to an appropriate target entity (, , . . . , ). The next level of the hierarchy specifies information  that identifies different pages within the renditions of the documents identified in the proceeding level.","Resources can be associated with any level of the hierarchy defined by schema . For instance, exemplary resource  can be associated with the renditions level of the hierarchy. Such resource  can comprise an image resource , a font resource , or some other resource . Resource , on the other hand, is associated with the page level of the hierarchy, rather than rendition level.  is exemplary and non-limiting; for instance, resources can be associated with yet additional levels in the hierarchy, although not shown in .","Further, although not shown in , metadata can be associated with any of the levels of the hierarchy of the schema . Metadata specifies any supplemental information pertaining to the job information , such as an author who created a document contained in the job, a time when the document was created, and so on. There are no restrictions on the type of, and meaning assigned to, metadata that can be appended to different parts of the schema .","In the same manner, print tickets can be associated with any level of the hierarchy of the schema . Print tickets define the types of processing operations that should be performed on associated parts of the hierarchy. For instance, a print ticket associated with the job container level  will apply to the entirety of the package defined by the job information . A print ticket associated with an individual page of the job information  will have a localized effect by only affecting that page.","In general, if so configured, lower levels of the hierarchy defined by the schema  can inherent the properties defined in higher levels. In other words, if so configured, a child object in the hierarchy will inherit the properties defined for its parent and ancestors. This means that, if so configured, a print ticket, resource, or metadata associated with a parent node can also be, through inheritance, available to its associated child nodes.","In summary, the schema  shown in  provides a powerful, uniform and versatile mechanism for representing complex job information, particularly for those jobs that involve multiple documents and\/or multiple renditions of documents. Traditional techniques provide no provisions for representing these kinds of complex scenarios in spool storage; therefore, these traditional techniques suffer from the inefficiencies described above, which can be significant.","To further clarify the exemplary schema ,  shows one exemplary instantiation  of the schema . The entire collection of nodes shown in  defines a package. The package includes a root node  associated with the entire package, e.g., the entire job. An index can be associated with the package, and hence with the root node . This index can be used to locate the package in the spool storage .","The job defined by the root node  includes a number of documents, as identified by document node  and document node . Also, a metadata node  is associated with the root node . If so configured, the metadata associated with this metadata node  defines properties which apply to the job as a whole.","Each of the documents associated with nodes  and  can include multiple renditions associated therewith. For example, the document represented by node  includes at least two renditions identified by nodes  and . As explained in connection with , a document may allocate separate renditions for printing a document in black and white mode, color mode, and so on. No limitation is placed on what a developer may define as a rendition in the context of a particular application environment.","By virtue of the above-identified provisions, the job information  having the structure  serves as a general blueprint from which many renditions can be generated. In general, the specification of such rendition information within the spool storage  itself is a particularly unique and beneficial feature. For instance, this provides an efficient mechanism for printing different versions of the same document without having to store entire separately-tailored copies of the same document in the spool storage . Storing separate copies may overwhelm the storage and processing resources of the printing subsystem.","In addition to rendition nodes (, ), node  also includes nodes  and  associated therewith. Node  specifies metadata associated with node  and node  specifies a resource associated with node . A resource can include an image resource, a font resource, or some other resource that goes into the composition of the document represented by node .","Each rendition includes one or more pages associated therewith. Nodes  and , for example, represent pages associated with rendition node . Metadata node  indicates that metadata can be associated with the rendition level of the hierarchy (as it can for any level). Resource node  indicates that resource information can be associated with the rendition level (as it can for any level). An image may also include a hierarchical structure, further discussion of which may be found in relation to .","Finally, each page can include page data associated therewith as well as metadata. For example, page node  includes page data node  and metadata node  associated therewith, indicating that page data and metadata can be associated with this page. Page node  includes page data node  and metadata node  associated therewith, indicating that page data and metadata can be associated with this page.","The package associated with root node  can also include a collection of resources for shared use by different nodes in the job. Such collection of resources thus defines a shared library of resources that can be applied at different points within a document represented by the package. Particular types of resources include image resources, as represented by general image node . Individual image nodes (, ) are children of the parent image node , and respectively represent individual image resources. A metadata node  depends from the general image node , which represents metadata that, if so configured, applies to all of the image resources. Another metadata node  depends from an individual image node , representing metadata that applies to only this image resource associated with this node .","The same structure applies to font resources. A general font node  represents the inclusion of a plurality of font resources to select from, indicated by font nodes  and . Metadata can be associated with the general font node , as indicated by metadata node , or can be associated with a particular font resource, as indicated by metadata node . If so configured, metadata associated with the general font node  applies to all font resources while metadata associated with a particular font resource (such as found resource ) applies only to that particular font resource.","The resources can also include a number of other types of resources, as generally indicated by resource node . Metadata can be associated with this node , as indicated by metadata node .","Any document-related node in the package can reference any reference node, indicating that a particular part or aspect of the document is referencing a particular resource for use thereat. For instance, in the exemplary case of , page node  references resource extensions node . This association is indicated with a dashed line. This means that the resource represented by node  is used in the page represented by page . Further, page node  is associated with image node  and font node , indicting that an image resource associated with node  and a font resource associated with node  are used in the page associated with node . These associations are indicated by two respective dashed lines.","The hierarchies shown in  can be created in different ways. The hierarchy itself is a logical entity, where the nodes correspond to respective objects. Objects can reference other objects in different ways. In one technique, the individual objects can be modified so that they point to linked objects. Linking can be provided by pointers, Uniform Resource Locators (URLs), or some other referencing mechanism. Alternatively, or in addition, separate relationship information can be defined that specifies how separate objects are linked together. This mechanism eliminates the need for individual objects to be modified to define their interrelationship to other objects. This separate relationship information thus serves a blueprint for linking together separate objects in the job information. Likewise, metadata can be associated with individual nodes in the hierarchical structure in different ways. For instance, individual nodes can provide linking information that points to associated metadata, or the objects themselves can embeds such metadata. The Extensible Markup Language (XML), or other markup language, can be used to create the structured format shown in .","As noted above, the nodes shown in  are logical entities. Mapping rules define how the nodes map to actual physical entities used to constitute a document that is to be rendered. In one case, some of the nodes directly correspond to parts that are to be rendered, such as image resources and font resources. In another case, other of the nodes do not map, in one-to-one fashion, to actual renderable content of the document, but rather serve to communicate the organization of content in the document, or other aspect of the document.",{"@attributes":{"id":"p-0083","num":"0088"},"figref":["FIG. 5","FIG. 1","FIG. 2"],"b":["128","128","504","512","222","128"]},"The plurality of filters - of the converter module  are arranged to form a filter pipeline. Each of the filters -, for instance, may be configured to convert complex elements in a file that cannot be effectively processed by a legacy printer into simpler elements that the printer can efficiently print. For example, outline filter  is configured to process elements with complex outlines. Outline filter  is executable to convert a complex outline of a graphical element into a simple primitive(s) that can be handled by a legacy printer. Simple primitives may include lines, polygons, areas, vector shape elements, and the like.","Gradient filter  is configured to process elements with complex gradients. Gradient filter , for instance, is executable to convert a complex gradient into multiple polygons with fill colors that approximate the gradient.","Transparent vector shape filter  is configured to process vector shape elements with transparency functionality. As previously described, a first graphical element that supports transparency functionality (e.g. alpha value less than one) allows a second graphical element that is overlapped by the first graphical element with transparency to be partially shown. The region of the second graphical element covered by the first graphical element (i.e. overlapping portion) may therefore have a color that is \u201cbetween\u201d the colors of the first and second graphical elements. For example, if the transparency value is high (i.e., an alpha value is set closer to 1.0 such that the graphical element is more opaque), the color of the overlapping portion will be closer to the color of the element with transparency (i.e., the first graphical element). If the transparency value is low (i.e., an alpha value is set closer to 0.0 such that the graphical element is more opaque), the color of the overlapped region will be closer to the color of the overlapped element (i.e., the second graphical element). Transparent vector shape filter , for instance, may be executed to convert the transparency element and the overlapped element into two new elements with solid fill colors but without the overlapped region. Transparent vector shape filter  may also create another new element with for the overlapping portion with a solid fill color that approximates the original overlapping portion.","Transparent image filter  is configured to process image elements with transparency. Transparent image filter  determines the overlapping region of image elements and creates a new image element that approximates the overlapping region using shape elements and other image elements. Transparent image filter  is configured to apply alpha computation and subsequent clipping to polygonal paths. It is to be appreciated that transparent vector shape filter  and transparent image filter  are separately discussed in this document for clarity reasons. In an implementation, both filters may be combined into a single filter.","Converter module  may include other filters for performing other processing steps. For example, converter module  may include a filter to convert file data to information that a legacy printer can understand, such as print description language (PDL) command streams. Converter module  may also include filters that are not configured to modify file data. For example, converter module  may include a filter that sends a copy of the file data to an archive.","It is to be understood that filters - are modularly configured and form a filter pipeline where the output of one filter serves as the input of another filter. The modular configuration enables different filters to be easily added, modified or removed. The filter pipeline enables a file to be converted efficiently to a format understood by a legacy printer. This capability allows converter module  to provide a file to a legacy printer for printing without converting the complex elements in the file to computationally-intensive pixel-based elements, such as rasterized graphical elements (e.g., bitmaps).","Planar Rendering","Planar rendering may be provided as a stage (e.g., the transparent vector shape and image filters ,  of ) in a filter pipeline as previously described. This stage is configured to convert files having transparent\/translucent images into a printable format for rendering devices and graphics models which do not support transparency functionality, such as legacy rendering devices.","A technique, which may be referred to as alpha blending, may be utilized to provide transparent and translucent graphical elements. As previously described, additional information, referred to as alpha information, may be specified for each pixel that is to be rendered on a surface (e.g., the screen  of , a printable medium, and so on). Alpha can be specified in a variety of ways, such as a floating point number that has a range from 0.0 to 1.0. In this instance, if alpha is zero then a corresponding pixel is transparent, and therefore is not rendered. If the alpha for a corresponding pixel is 1.0, then the corresponding pixel is opaque such that it completely covers whatever is \u201cunderneath\u201d it. If the alpha value is between 0.0 and 1.0, in this instance, colors for the corresponding pixels are mixed to provide a translucent appearance. For example, if a white rectangle is to be drawn on top of a black rectangle, and the alpha for the white rectangle is specified as 0.5, then the resulting color for the overlapping portions is an equal mixture of black and white.","Graphical elements that are drawn in the form of a vector object, such as text, curves, polygons, filled regions, and so on, typically have a fixed alpha value associated with the entire area of the graphical element that is to be rendered. Other graphical elements, however, may specify an alpha value for each individual pixel of the graphical element. For example, a photographic image of a pumpkin may include an alpha value for each pixel that does not belong to the pumpkin (e.g., a bounding area) to transparent and set alpha values for each pixel that belong to the apple to opaque. In this way, the image provides a built-in mask that specifies how that image of the pumpkin is to be rendered against a background.","Traditional PDLs, however, supported limited scenarios for each graphical element that was to be drawn on a printable medium. In a first scenario, a new pixel was drawn onto a location where there was no existing output from a previous drawing operation, such as when white and black rectangles are drawn on a page and none of the pixels of that white rectangle intersect the pixels of the black rectangle, i.e. share the same location. In this first scenario, none of the pixels of the white and black rectangle affected each other and therefore the traditional PDLs could provide an output as intended.","In a second scenario, a first pixel of a first graphical element was to be drawn onto a location that already had a second pixel provided by a second graphical element that was drawn before the first graphical element. Thus, a portion the first graphical element \u201coverlaps\u201d a portion the second graphical element, which may be referred to as an \u201coverlapping portion\u201d or \u201coverlapping portions\u201d. Utilizing traditional PDLs, however, the overlapping portion did not support a transparent\/translucent output and therefore would merely override any preexisting pixels. Therefore, pixels in the portion of the first graphical element would opaquely cover pixels in the portion of the second graphical element.","In a third scenario, portions of a output file that contained transparent and overlapping graphical elements for output were rasterized to form a rasterized image, such as a bitmap. Rasterizing a portion of the image file, however, introduces resolution dependency and requires a large amount of memory resources to store rasterized images. Thus, traditional PDL's did not support the concept of alpha, and therefore could not translate a graphical element that is transparent or translucent for output as intended.",{"@attributes":{"id":"p-0096","num":"0101"},"figref":["FIG. 6","FIG. 6"],"b":["600","602","604","606","604","606","608","602","604","604","606","608","604","606","606","604"]},"The converter module  is implemented to convert the file  having translucent and\/or transparent portions to a file  having a printable format for target entities and other graphical environments which do not support transparency functionality, such as legacy rendering devices. The converting module  first converts each portion of the file  having a uniform color into a logical shape, such as a polygon. A first shape \u2032, for instance, includes a solid white portion of the white rectangle . A second shape \u2032 includes a solid black portion of the block rectangle . A third shape \u2032 is taken from the overlapping portions  of the white and black rectangles , . Because each of these shapes \u2032, \u2032, \u2032 do not overlap, each can be drawn with a independent color such that it is not dependent on another color that is already provided for inclusion on the page. For instance, the third shape \u2032 may be rendered as a mixture of 50% black and 50% white. Therefore, the alpha value for each of the first, second, and third shapes \u2032, \u2032, and \u2032 may be set to opaque (e.g., 1.0).","The converter module  may employ an algorithm that processes a page description for a whole page and determines where graphical element intersections occur, i.e. overlapping portions. The algorithm may then convert the graphical element intersections into objects and derive a single color for each graphical element intersection object. The result (e.g., file ) can therefore be rendered by rendering devices that do not support transparency functionality.","In this way, planar rendering provides for accurate rendering of the transparent and translucent graphical elements by rendering devices which do not support transparency. The term \u201cplanar\u201d is used in reference to layers provided by graphical elements having specified alpha values.  is an illustration of an exemplary implementation showing the files ,  of  as layered for output from a side view. Alpha values are utilized to layer graphical elements, one on top of another. Therefore, file  provides a layered image when viewed from the side as shown in . The file  has a base layer which represents paper , on which, the image is to be printed, which is followed by individual layers formed on top of the paper  to form the image of the file . Alpha values are used to determine how these layers for the graphical elements (e.g., the white and black rectangles , ) are composed respective to each other. The converter module  utilizes planar rendering to essentially flatten these layers of file  to a single layer in file . For instance, the overlapping portion  of file  includes multiple layers formed by portions of the white and black rectangles , . The overlapping portion \u2032 of file , however, includes a single layer which is the result of the overlapping portions that has an alpha value set to opaque such that a rendering device which receives the file  can provide an output which gives the appearance of transparency\/translucence, even if the rendering device does not support transparency functionality.","Exemplary Procedures","The following discussion describes planar rendering that may be implemented utilizing the previously described systems and environments. Aspects of each of the procedures may be implemented in hardware, firmware, or software, or a combination thereof. The procedures are shown as a set of blocks that specify operations performed by one or more devices and are not necessarily limited to the orders shown for performing the operations by the respective blocks.",{"@attributes":{"id":"p-0101","num":"0106"},"figref":"FIG. 8","b":["800","802","804","800","804","806","808","806","806","808","810","808","810","806","808","806","808","804","800"]},{"@attributes":{"id":"p-0102","num":"0107"},"figref":["FIG. 9","FIG. 8","FIG. 8","FIG. 3","FIG. 8"],"b":["800","900","900","800","900","312","304","900","902","804","800","904","806","808"]},"The plurality of nodes - may specify a variety of properties. For example, each node of the tree  may specify a corresponding alpha value. A leaf node, for instance, references a particular graphical element (e.g., nodes , ). An alpha value specified for the leaf node defines an alpha value for a graphical element referenced by the leaf node. In another example grouping nodes (e.g., nodes , ), which reference a plurality of other nodes, may also specify an alpha value for each child of that node. For example, an alpha value  that is specified for the second child node  defines an alpha value for each node (e.g., nodes , ) that is a child of the second child node . Each of these nodes may also have a property which is a bounding rectangle  of the object as it appears, when rendered, and a property that specifies a color  for an area described by the node.",{"@attributes":{"id":"p-0104","num":"0109"},"figref":["FIG. 10","FIG. 1","FIG. 9","FIG. 10","FIG. 9","FIG. 11"],"b":["1000","900","1000","1100"]},"At block , the converter module walks the tree  of  (i.e., traverses a data structure) to find a node of the tree having a bounding rectangle that contains a graphical element. For example, the converter module starts at node  which references the segment  of the background of the image .","At block , the converter module determines if the bounding rectangle of the current node intersects another bounding rectangle of another node that is \u201cbelow\u201d the current bounding rectangle. For example, the tree  may provide a z order for display of graphical elements which is utilized to specify which graphical element is to be displayed on top of another graphical element. The z order is represented in the tree  of  such that the left-most nodes are to be displayed below the right-most nodes that are included in the same hierarchical levels of the tree, as will become more apparent in the description of this example.","In this instance, there are no other graphical elements that are to be displayed below or beneath the segment , and therefore the bounding rectangle does not intersect another bounding rectangle (block ). Therefore, at block , a color is computed for graphical elements in the bounding rectangle as if it was printed on a printable medium. For instance, if the segment  has an alpha value which specifies that the segment  is translucent, a color of the segment  is computed based on the color specified, the alpha value, and a color value of white for the underlying surface utilizing alpha blending techniques as previously described. In this way, the segment  is converted for accurate rendering. At block , the segment is added to the display list for output. For example, tree  depicts a display list for output. The segment  is added to the tree  as node . The procedure  then returns to block  to find a new current bounding rectangle and determines whether the new bounding rectangle intersects another bounding rectangle (block ).","The converter module in this instance walks the tree  to find a grouping node (i.e., child node ) which represents the intersection of the triangle  and the circle . As previously described, the tree  provides a z order for display of graphical elements. Therefore, the converter module marks a next bounding rectangle in the z order for analysis, which in this instance is node .","At block , the converter module determines whether the bounding rectangle for the triangle  intersects any \u201clower\u201d (i.e., z order) bounding rectangles. At block , the converter module inspects the other graphical element in the other bounding rectangle and determines if the other graphical element intersects the current graphical element (block ). For instance, the converter module may inspect geometric and location descriptions of the respective graphical elements to determine which portions, if any, of the graphical elements overlap. In this instance, the triangle  is to be displayed over the segment  and therefore there is an intersection.","At block , the converter module determines if the current graphical element is opaque. If so, the current graphical element will cover the other graphical element and therefore the current graphical element may be included in the display list (block ) without further computations. If the current graphical element is not opaque (block ), then the converter module determines whether the current graphical element is translucent (block ). For example, the converter module may inspect the current graphical element to determine its alpha value. If the current graphical element is transparent, then the other graphical element will be displayed \u201cthrough\u201d the current graphical element without modification. If the current graphical element is translucent, however, transparency functionality employed by the current graphical element is converted for use by graphical environments which do not support transparency as follows.","At block , the converter module determines an overlapping portion of the current graphical element with the other graphical element. For example, the triangle  in this instance completely overlaps the segment  and therefore the overlapping portion is the triangle  itself. The converter module then computes a color for the overlapping portion (block ). In this instance, the color is computed based on the colors of the segment  and the triangle  utilizing alpha blending techniques. The overlapping portion (e.g. the triangle ) having the computed color of block  is included in the display list (block ). The triangle  having the computed color is stored, for example, as triangle  at node  of the result tree  of .","The converter module may also optimize the display list. At block , for example, the converter module determines if any other graphical elements in the display list (e.g., tree  of ) are obscured by the overlapping graphical element. If so, the obscured graphical element is removed (block ), thereby conserving memory resources. The procedure then returns back to block  for a next graphical element.","In this instance, the circle  is found at node  of tree  of . The procedure  continues through blocks - as previously described to compute a new circle  having a color computed from the overlap of the circle  and the segment  to form a new circle . The new circle  has a color computed from the overlap of the circle  with the segment  of node  and is stored at node  in tree  of .","The procedure is again repeated for the circle , but in this instance the overlap of the circle  with the triangle  is addressed. For example, the procedure  may proceed through blocks - as previously described. At block , the overlapping portion  of the circle  and the triangle  is determined. The converter module, for instance, may compute a portion having a generally uniform color that is provided through the overlap of the translucent circle  with the triangle . The converter module then arrives at a shape (i.e., a polygon) that approximates the overlapping portion, which in this instance is a \u201cpie\u201d shape  illustrated in . At block , a color is computed for the pie shape  based on the color of the triangle  of node  and the circle  of node . The pie shape  and its computed color are then included in the display list, i.e. node  of tree  of FIG. .","Thus, the procedure  of  may be utilized to flatten a hierarchical structure of the tree  of  to the result tree  of . The tree of  does not specify translucent alpha values (e.g., each alpha, if specified, is 0.0 or 1.0) and therefore may be utilized in graphical environments which do not support transparency functionality, such as legacy printers. The source tree (e.g., tree  of ) contains graphical elements at different levels, \u201cgrouping\u201d nodes that do not contain imagable data (e.g., node  of ), and so on. The result tree (e.g., tree  of ), however, has one root and graphical elements which are directions from the root. Thus, the result tree is the result of planar mapping of the source tree. In this way, planar mapping may address an arbitrarily deep nested tree and convert it into a flat tree having one level of imagable data having correct color computations.","It should be noted that in an implementation, overlapping portions do not need to be removed from the respective parent object. For instance, the illustrated \u201cpie shape\u201d portion is not removed from the circle or the triangle. Rather, the alpha for the pie shape is set to opaque such that it overwrites the other shapes. For example, each object in the tree may be set as opaque with the corresponding order (i.e., z order) defining which object will be displayed \u201con top\u201d. Thus, a \u201cflat\u201d tree is formed having images with alpha values each set as \u201c1.0\u201d (i.e. opaque) so that it does not matter whether the overlapping portions are removed from the parent graphical elements. In another embodiment, it may be efficient to remove the overlapping portions from the other shapes.",{"@attributes":{"id":"p-0117","num":"0122"},"figref":"FIG. 12","b":["1200","1202"]},"At block , each graphical element in the display list is added to a tree in a z order which describes the order, in which, each of the graphical elements is to be displayed with respect to other graphical elements.","At block , the \u201clowest\u201d graphical element is selected based on the z order of the tree. At decision block , a determination is made as to whether the selected graphical element has a corresponding alpha value. If not, the selected graphical element is added to a result tree (block ).","If the selected graphical element does contain alpha information (block ), an overlapping portion is computed of the selected graphical element with any previously encountered graphical elements (block ). At block , a color for the overlapping portion is computed based on colors and alpha values for any underlying graphical elements. At block , a new graphical element is created which represents the overlapping area and the computed color. At block , the new graphical element is added to the result tree and a next graphical element is selected (block ).",{"@attributes":{"id":"p-0121","num":"0126"},"figref":"FIG. 13","b":["1300","1302","1304"]},"At block , shapes that approximate the non-overlapping portions of the elements are determined. At block , a shape that approximates the overlapping section of the elements is determined. At block , fill colors for the shapes that approximate the transparent and the overlapping elements and the overlapping region are determined. At block , the elements are replaced with the filled shapes.","Although the invention has been described in language specific to structural features and\/or methodological acts, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claimed invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0019"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0020"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0016","num":"0021"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0023"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0019","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0025"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0021","num":"0026"},"figref":["FIG. 10","FIG. 1","FIG. 9"]},{"@attributes":{"id":"p-0022","num":"0027"},"figref":["FIG. 11","FIG. 9","FIG. 10"]},{"@attributes":{"id":"p-0023","num":"0028"},"figref":["FIG. 12","FIG. 1"]},{"@attributes":{"id":"p-0024","num":"0029"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
