---
title: Method and system for anticipating demand for a computational resource by containers running above guest operating systems within a distributed, virtualized computer system
abstract: The current document is directed to methods and systems for efficiently executing OSL-virtualization containers within the execution environments provided by virtual machines that execute above traditional virtualization layers within large, virtualized, distributed computing systems. The currently disclosed methods and systems anticipate the need for additional virtual machines in order to meet anticipated demands for one or more computational resources by the containers. In addition, the methods and systems provision and launch virtual machines with computational-resource allocations that minimize overhead and computational-resource wastage. In one implementation, computational-resource utilization of ATMs and containers within the virtualized, distributed computer system are periodically monitored in order to estimate future demand for the computational resource and, when necessary, to launch additional virtual machines to meet the estimated future demand for the computational resource.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619261&OS=09619261&RS=09619261
owner: VMware, Inc.
number: 09619261
owner_city: Palo Alto
owner_country: US
publication_date: 20151009
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS","Computer Hardware, Complex Computational Systems, and Virtualization","Containers and Containers Supported by Virtualization Layers","Methods and Systems to which the Current Document is Directed"],"p":["Benefit is claimed under 35 U.S.C. 119(a)-(d) to Foreign application Serial No. 3318\/CHE\/2015 filed in India entitled \u201cMETHOD AND SYSTEM FOR ANTICIPATING DEMAND FOR A COMPUTATIONAL RESOURCE BY CONTAINERS RUNNING ABOVE GUEST OPERATING SYSTEMS WITHIN A DISTRIBUTED, VIRTUALIZED COMPUTER SYSTEM\u201d, filed on Jun. 29, 2015, by VMware, Inc., which is herein incorporated in its entirety by reference for all purposes.","The current document is directed to virtualized, distributed computer systems, such as virtualized, distributed computer systems that operate as cloud-computing facilities, and, in particular, to methods and systems for elastic scheduling of virtual machines to host containers that, in turn, provide execution environments for applications within the cloud-computing facility.","During the past 60 years, computer systems have evolved from primitive, single-processor computer systems that lacked operating systems and compilers for modern, structured programming languages to enormous, geographically distributed computer systems comprising hundreds, thousands, or more individual multi-processor computer systems, linked together with network communications and shared mass-storage facilities, concurrently running many different sophisticated applications. These large, distributed computer systems are often virtualized to provide virtual data centers and virtual-data-center aggregations that, in turn, provide for flexible and efficient system administration. Many cloud-computing facilities provide interfaces to large, virtualized, distributed computing systems that allow clients of the cloud-computing facilities to rapidly and dynamically configure virtual host systems for running client applications that can, in turn, provide computing services to thousands, millions, or more remote users. Many of the virtualization technologies employed within cloud-computing facilities involve virtualization layers that execute above the hardware layer of host computers to provide execution environments for virtual machines. The virtual machines, in turn, provide execution environments for guest operating systems, which, in turn, provide execution environments for applications. This type of virtualization technology provides enormous advantages to owners and administrators of cloud-computing facilities as well as to cloud-computing-facility clients. These virtualization technologies, as one example, can simulate any of many different types of underlying hardware and can therefore provide a virtual hardware platform on which many different types of operating systems can execute. However, the enormous flexibility provided by this type of virtualization technology is associated with certain computational overheads and costs. Another approach to virtualization is referred to as operating system-level virtualization (\u201cOSL virtualization\u201d). While not as flexible and powerful as the traditional virtualization technologies that provide virtualization layers to support virtual-machine execution, OSL virtualization has significantly lower computational overheads and costs, and is, for that reason, an increasingly popular choice for virtual hosting environments, such as those used to run client applications in cloud-computing facilities. Designers and developers of distributed computing systems, designers and developers of cloud-computing facilities, owners and administrators of cloud-computing facilities and other distributed computing systems, and, ultimately, users of distributed computing systems continue to seek efficient and cost-effective technologies that provide a foundation for cloud computing and other virtualized, distributed computing-systems applications.","The current document is directed to methods and systems for efficiently executing OSL-virtualization containers within the execution environments provided by virtual machines that execute above traditional virtualization layers within large, virtualized, distributed computing systems. The currently disclosed methods and systems anticipate the need for additional virtual machines in order to meet anticipated demands for one or more computational resources by the containers. In addition, the methods and systems provision and launch virtual machines with computational-resource allocations that minimize overhead and computational-resource wastage. In one implementation, computational-resource utilization of VMs and containers within the virtualized, distributed computer system are periodically monitored in order to estimate future demand for the computational resource and, when necessary, to launch additional virtual machines to meet the estimated future demand for the computational resource.","The current document is directed to methods and systems for elastic scheduling of virtual machines within a virtualized, distributed computer system in order to provide execution environments for OSL-virtualization containers that, in turn, provide execution environments for client applications. In a first subsection, below, traditional virtualization technologies are described with reference to . In a following subsection, contains and containers supported by virtualization layers are discussed. In a third subsection, the methods and systems for elastic scheduling of VMs in order to anticipate resource needs of containers is discussed, in detail, with reference to flow diagrams and C++ implementation.","The term \u201cabstraction\u201d is not, in any way, intended to mean or suggest an abstract idea or concept. Computational abstractions are tangible, physical interfaces that are implemented, ultimately, using physical computer hardware, data-storage devices, and communications systems. Instead, the term \u201cabstraction\u201d refers, in the current discussion, to a logical level of functionality encapsulated within one or more concrete, tangible, physically-implemented computer systems with defined interfaces through which electronically-encoded data is exchanged, process execution launched, and electronic services are provided. Interfaces may include graphical and textual data displayed on physical display devices as well as computer programs and routines that control physical computer processors to carry out various tasks and operations and that are invoked through electronically implemented application programming interfaces (\u201cAPIs\u201d) and other electronically implemented interfaces. There is a tendency among those unfamiliar with modem technology and science to misinterpret the terms \u201cabstract\u201d and \u201cabstraction,\u201d when used to describe certain aspects of modem computing. For example, one frequently encounters assertions that, because a computational system is described in terms of abstractions, functional layers, and interfaces, the computational system is somehow different from a physical machine or device. Such allegations are unfounded. One only needs to disconnect a computer system or group of computer systems from their respective power supplies to appreciate the physical, machine nature of complex computer technologies. One also frequently encounters statements that characterize a computational technology as being \u201conly software,\u201d and thus not a machine or device. Software is essentially a sequence of encoded symbols, such as a printout of a computer program or digitally encoded computer instructions sequentially stored in a file on an optical disk or within an electromechanical mass-storage device. Software alone can do nothing. It is only when encoded computer instructions are loaded into an electronic memory within a computer system and executed on a physical processor that so-called \u201csoftware implemented\u201d functionality is provided. The digitally encoded computer instructions are an essential and physical control component of processor-controlled machines and devices, no less essential and physical than a cam-shaft control system in an internal-combustion engine. Multi-cloud aggregations, cloud-computing services, virtual-machine containers and virtual machines, communications interfaces, and many of the other topics discussed below are tangible, physical components of physical, electro-optical-mechanical computer systems.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["102","105","108","110","112","110","114","116","118","120","122","127","127","128"]},"Of course, there are many different types of computer-system architectures that differ from one another in the number of different memories, including different types of hierarchical cache memories, the number of processors and the connectivity of the processors with other system components, the number of internal communications busses and serial links, and in many other ways. However, computer systems generally execute stored programs by fetching instructions from memory and executing the instructions in one or more processors. Computer systems include general-purpose computer systems, such as personal computers (\u201cPCs\u201d), various types of servers and workstations, and higher-end mainframe computers, but may also include a plethora of various types of special-purpose computing devices, including data-storage systems, communications routers, network nodes, tablet computers, and mobile telephones.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2","FIG. 2"],"b":["202","205","210","212","214","216"]},"Until recently, computational services were generally provided by computer systems and data centers purchased, configured, managed, and maintained by service-provider organizations. For example, an e-commerce retailer generally purchased, configured, managed, and maintained a data center including numerous web servers, back-end computer systems, and data-storage systems for serving web pages to remote customers, receiving orders through the web-page interface, processing the orders, tracking completed orders, and other myriad different tasks associated with an e-commerce enterprise.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 3","FIG. 3"],"b":["302","304","306","308","310","312","314","304","312","316"]},"Cloud-computing facilities are intended to provide computational bandwidth and data-storage services much as utility companies provide electrical power and water to consumers. Cloud computing provides enormous advantages to small organizations without the resources to purchase, manage, and maintain in-house data centers. Such organizations can dynamically add and delete virtual computer systems from their virtual data centers within public clouds in order to track computational-bandwidth and data-storage needs, rather than purchasing sufficient computer systems within a physical data center to handle peak computational-bandwidth and data-storage demands. Moreover, small organizations can completely avoid the overhead of maintaining and managing physical computer systems, including hiring and periodically retraining information-technology specialists and continuously paying for operating-system and database-management-system upgrades. Furthermore, cloud-computing interfaces allow for easy and straightforward configuration of virtual computing facilities, flexibility in the types of applications and operating systems that can be configured, and other functionalities that are useful even for owners and administrators of private cloud-computing facilities used by a single organization.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 4","FIG. 1"],"b":["400","402","404","406","402","408","410","410","412","414","404","402","416","418","420","422","424","426","428","430","432","436","442","444","446","448","436"]},"While the execution environments provided by operating systems have proved to be an enormously successful level of abstraction within computer systems, the operating-system-provided level of abstraction is nonetheless associated with difficulties and challenges for developers and users of application programs and other higher-level computational entities. One difficulty arises from the fact that there are many different operating systems that run within various different types of computer hardware. In many cases, popular application programs and computational systems are developed to run on only a subset of the available operating systems, and can therefore be executed within only a subset of the various different types of computer systems on which the operating systems are designed to run. Often, even when an application program or other computational system is ported to additional operating systems, the application program or other computational system can nonetheless run more efficiently on the operating systems for which the application program or other computational system was originally targeted. Another difficulty arises from the increasingly distributed nature of computer systems. Although distributed operating systems are the subject of considerable research and development efforts, many of the popular operating systems are designed primarily for execution on a single computer system. In many cases, it is difficult to move application programs, in real time, between the different computer systems of a distributed computer system for high-availability, fault-tolerance, and load-balancing purposes. The problems are even greater in heterogeneous distributed computer systems which include different types of hardware and devices running different types of operating systems. Operating systems continue to evolve, as a result of which certain older application programs and other computational entities may be incompatible with more recent versions of operating systems for which they are targeted, creating compatibility issues that are particularly difficult to manage in large distributed systems.","For all of these reasons, a higher level of abstraction, referred to as the \u201cvirtual machine,\u201d has been developed and evolved to further abstract computer hardware in order to address many difficulties and challenges associated with traditional computing systems, including the compatibility issues discussed above.  illustrate two types of virtual machine and virtual-machine execution environments.  use the same illustration conventions as used in .  shows a first type of virtualization. The computer system  in  includes the same hardware layer  as the hardware layer  shown in . However, rather than providing an operating system layer directly above the hardware layer, as in , the virtualized computing environment illustrated in  features a virtualization layer  that interfaces through a virtualization-layer\/hardware-layer interface , equivalent to interface  in , to the hardware. The virtualization layer provides a hardware-like interface  to a number of virtual machines, such as virtual machine , executing above the virtualization layer in a virtual-machine layer . Each virtual machine includes one or more application programs or other higher-level computational entities packaged together with an operating system, referred to as a \u201cguest operating system,\u201d such as application  and guest operating system  packaged together within virtual machine . Each virtual machine is thus equivalent to the operating-system layer  and application-program layer  in the general-purpose computer system shown in . Each guest operating system within a virtual machine interfaces to the virtualization-layer interface  rather than to the actual hardware interface . The virtualization layer partitions hardware resources into abstract virtual-hardware layers to which each guest operating system within a virtual machine interfaces. The guest operating systems within the virtual machines, in general, are unaware of the virtualization layer and operate as if they were directly accessing a true hardware interface. The virtualization layer ensures that each of the virtual machines currently executing within the virtual environment receive a fair allocation of underlying hardware resources and that all virtual machines receive sufficient resources to progress in execution. The virtualization-layer interface  may differ for different guest operating systems. For example, the virtualization layer is generally able to provide virtual hardware interfaces for a variety of different types of computer hardware. This allows, as one example, a virtual machine that includes a guest operating system designed for a particular computer architecture to run on hardware of a different architecture. The number of virtual machines need not be equal to the number of physical processors or even a multiple of the number of processors.","The virtualization layer includes a virtual-machine-monitor module  (\u201cVMM\u201d) that virtualizes physical processors in the hardware layer to create virtual processors on which each of the virtual machines executes. For execution efficiency, the virtualization layer attempts to allow virtual machines to directly execute non-privileged instructions and to directly access non-privileged registers and memory. However, when the guest operating system within a virtual machine accesses virtual privileged instructions, virtual privileged registers, and virtual privileged memory through the virtualization-layer interface , the accesses result in execution of virtualization-layer code to simulate or emulate the privileged resources. The virtualization layer additionally includes a kernel module  that manages memory, communications, and data-storage machine resources on behalf of executing virtual machines (\u201cVM kernel\u201d). The VM kernel, for example, maintains shadow page tables on each virtual machine so that hardware-level virtual-memory facilities can be used to process memory accesses. The VM kernel additionally includes routines that implement virtual communications and data-storage devices as well as device drivers that directly control the operation of underlying hardware communications and data-storage devices. Similarly, the VM kernel virtualizes various other types of I\/O devices, including keyboards, optical-disk drives, and other such devices. The virtualization layer essentially schedules execution of virtual machines much like an operating system schedules execution of application programs, so that the virtual machines each execute within a complete and fully functional virtual hardware layer.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 5B","FIG. 5B","FIG. 4","FIG. 5A","FIG. 5A","FIG. 4"],"b":["540","542","544","402","546","548","550","540","504","550","544","550","552","508","552","416","556","558"]},"In , the layers are somewhat simplified for clarity of illustration. For example, portions of the virtualization layer  may reside within the host-operating-system kernel, such as a specialized driver incorporated into the host operating system to facilitate hardware access by the virtualization layer.","It should be noted that virtual hardware layers, virtualization layers, and guest operating systems are all physical entities that are implemented by computer instructions stored in physical data-storage devices, including electronic memories, mass-storage devices, optical disks, magnetic disks, and other such devices. The term \u201cvirtual\u201d does not, in any way, imply that virtual hardware layers, virtualization layers, and guest operating systems are abstract or intangible. Virtual hardware layers, virtualization layers, and guest operating systems execute on physical processors of physical computer systems and control operation of the physical computer systems, including operations that alter the physical states of physical devices, including electronic memories and mass-storage devices. They are as physical and tangible as any other component of a computer since, such as power supplies, controllers, processors, busses, and data-storage devices.","A virtual machine or virtual application, described below, is encapsulated within a data package for transmission, distribution, and loading into a virtual-execution environment. One public standard for virtual-machine encapsulation is referred to as the \u201copen virtualization format\u201d (\u201cOVF\u201d). The OVF standard specifies a format for digitally encoding a virtual machine within one or more data files.  illustrates an OVF package. An OVF package  includes an OVF descriptor , an OVF manifest , an OVF certificate , one or more disk-image files -, and one or more resource files -. The OVF package can be encoded and stored as a single file or as a set of files. The OVF descriptor  is an XML document  that includes a hierarchical set of elements, each demarcated by a beginning tag and an ending tag. The outermost, or highest-level, element is the envelope element, demarcated by tags  and . The next-level element includes a reference element  that includes references to all files that are part of the OVF package, a disk section  that contains meta information about all of the virtual disks included in the OVF package, a networks section  that includes meta information about all of the logical networks included in the OVF package, and a collection of virtual-machine configurations  which further includes hardware descriptions of each virtual machine . There are many additional hierarchical levels and elements within a typical OVF descriptor. The OVF descriptor is thus a self-describing, XML file that describes the contents of an OVF package. The OVF manifest  is a list of cryptographic-hash-function-generated digests  of the entire OVF package and of the various components of the OVF package. The OVF certificate  is an authentication certificate  that includes a digest of the manifest and that is cryptographically signed. Disk image files, such as disk image file , are digital encodings of the contents of virtual disks and resource files  are digitally encoded content, such as operating-system images. A virtual machine or a collection of virtual machines encapsulated together within a virtual application can thus be digitally encoded as one or more files within an OVF package that can be transmitted, distributed, and loaded using well-known tools for transmitting, distributing, and loading files. A virtual appliance is a software service that is delivered as a complete software stack installed within one or more virtual machines that is encoded within an OVF package.","The advent of virtual machines and virtual environments has alleviated many of the difficulties and challenges associated with traditional general-purpose computing. Machine and operating-system dependencies can be significantly reduced or entirely eliminated by packaging applications and operating systems together as virtual machines and virtual appliances that execute within virtual environments provided by virtualization layers running on many different types of computer hardware. A next level of abstraction, referred to as virtual data centers which are one example of a broader virtual-infrastructure category, provide a data-center interface to virtual data centers computationally constructed within physical data centers.  illustrates virtual data centers provided as an abstraction of underlying physical-data-center hardware components. In , a physical data center  is shown below a virtual-interface plane . The physical data center consists of a virtual-infrastructure management server (\u201cVI-management-server\u201d)  and any of various different computers, such as PCs , on which a virtual-data-center management interface may be displayed to system administrators and other users. The physical data center additionally includes generally large numbers of server computers, such as server computer , that are coupled together by local area networks, such as local area network  that directly interconnects server computer  and - and a mass-storage array . The physical data center shown in  includes three local area networks , , and  that each directly interconnects a bank of eight servers and a mass-storage array. The individual server computers, such as server computer , each includes a virtualization layer and runs multiple virtual machines. Different physical data centers may include many different types of computers, networks, data-storage systems and devices connected according to many different types of connection topologies. The virtual-data-center abstraction layer , a logical abstraction layer shown by a plane in , abstracts the physical data center to a virtual data center comprising one or more resource pools, such as resource pools -, one or more virtual data stores, such as virtual data stores -, and one or more virtual networks. In certain implementations, the resource pools abstract banks of physical servers directly interconnected by a local area network.","The virtual-data-center management interface allows provisioning and launching of virtual machines with respect to resource pools, virtual data stores, and virtual networks, so that virtual-data-center administrators need not be concerned with the identities of physical-data-center components used to execute particular virtual machines. Furthermore, the VI-management-server includes functionality to migrate running virtual machines from one physical server to another in order to optimally or near optimally manage resource allocation, provide fault tolerance, and high availability by migrating virtual machines to most effectively utilize underlying physical hardware resources, to replace virtual machines disabled by physical hardware problems and failures, and to ensure that multiple virtual machines supporting a high-availability virtual appliance are executing on multiple physical computer systems so that the services provided by the virtual appliance are continuously accessible, even when one of the multiple virtual appliances becomes compute bound, data-access bound, suspends execution, or fails. Thus, the virtual data center layer of abstraction provides a virtual-data-center abstraction of physical data centers to simplify provisioning, launching, and maintenance of virtual machines and virtual appliances as well as to provide high-level, distributed functionalities that involve pooling the resources of individual physical servers and migrating virtual machines among physical servers to achieve load balancing, fault tolerance, and high availability.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 8","FIG. 8","FIG. 7"],"b":["802","804","802","806","808","810","810","812","814","816","818","708","818","824","825","826"]},"The distributed services  include a distributed-resource scheduler that assigns virtual machines to execute within particular physical servers and that migrates virtual machines in order to most effectively make use of computational bandwidths, data-storage capacities, and network capacities of the physical data center. The distributed services further include a high-availability service that replicates and migrates virtual machines in order to ensure that virtual machines continue to execute despite problems and failures experienced by physical hardware components. The distributed services also include a live-virtual-machine migration service that temporarily halts execution of a virtual machine, encapsulates the virtual machine in an OVF package, transmits the OVF package to a different physical server, and restarts the virtual machine on the different physical server from a virtual-machine state recorded when execution of the virtual machine was halted. The distributed services also include a distributed backup service that provides centralized virtual-machine backup and restore.","The core services provided by the VI management server include host configuration, virtual-machine configuration, virtual-machine provisioning, generation of virtual-data-center alarms and events, ongoing event logging and statistics collection, a task scheduler, and a resource-management module. Each physical server - also includes a host-agent virtual machine - through which the virtualization layer can be accessed via a virtual-infrastructure application programming interface (\u201cAPI\u201d). This interface allows a remote administrator or user to manage an individual server through the infrastructure API. The virtual-data-center agents - access virtualization-layer server information through the host agents. The virtual-data-center agents are primarily responsible for offloading certain of the virtual-data-center management-server functions specific to a particular physical server to that physical server. The virtual-data-center agents relay and enforce resource allocations made by the VI management server, relay virtual-machine provisioning and configuration-change commands to host agents, monitor and collect performance statistics, alarms, and events communicated to the virtual-data-center agents by the local host agents through the interface API, and to carry out other, similar virtual-data-management tasks.","The virtual-data-center abstraction provides a convenient and efficient level of abstraction for exposing the computational resources of a cloud-computing facility to cloud-computing-infrastructure users. A cloud-director management server exposes virtual resources of a cloud-computing facility to cloud-computing-infrastructure users. In addition, the cloud director introduces a multi-tenancy layer of abstraction, which partitions virtual data centers (\u201cVDCs\u201d) into tenant-associated VDCs that can each be allocated to a particular individual tenant or tenant organization, both referred to as a \u201ctenant.\u201d A given tenant can be provided one or more tenant-associated VDCs by a cloud director managing the multi-tenancy layer of abstraction within a cloud-computing facility. The cloud services interface ( in ) exposes a virtual-data-center management interface that abstracts the physical data center.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 9","FIG. 9"],"b":["902","904","906","908","910","912","910","916","919","920","922","924","926","930","932","934","936"]},"Considering , the VI management server and cloud-director layers of abstraction can be seen, as discussed above, to facilitate employment of the virtual-data-center concept within private and public clouds. However, this level of abstraction does not fully facilitate aggregation of single-tenant and multi-tenant virtual data centers into heterogeneous or homogeneous aggregations of cloud-computing facilities.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 10","FIG. 10"],"b":["1002","1008","1002","1010","1012","1003","1008","1003","1006","1004","1007","1008","1005","1014","1002","1016","1010","1014","1018","1023","1026"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 11","b":["1102","1104","1106","1108","1110","1112","1113","1114","1115","1118","1120","1122"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 12","b":["1202","1204","1206","1208","1210","1212","1214"]},"As mentioned above, while the traditional virtual-machine-based virtualization layers, described in the previous subsection, have enjoyed widespread adoption and use in a variety of different environments, from personal computers to enormous distributed computing systems, traditional virtualization technologies are associated with computational overheads. While these computational overheads have steadily decreased, over the years, and often represent ten percent or less of the total computational bandwidth consumed by an application running above a guest operating system in a virtualized environment, traditional virtualization technologies nonetheless involve computational costs in return for the power and flexibility that they provide.","Another approach to virtualization, as also mentioned above, is referred to as operating-system-level virtualization \u201cOSL virtualization\u201d).  illustrates OSL-virtualization. In , as in previously discussed , an operating system  runs above the hardware  of a host computer. The operating system provides an interface, for higher-level computational entities, that includes a system-call interface  and the non-privileged instructions, memory addresses, and registers  provided by the hardware layer . However, unlike in , in which applications run directly above the operating system, OSL virtualization involves an OS-level virtualization layer  that provides an operating-system interface - to each of one or more containers -. The containers, in turn, provide an execution environment for one or more applications, such as application  running within the execution environment provided by container . The container can be thought of as a partition of the resources generally available to higher-level computational entities through the operating system interface . While a traditional virtualization layer can simulate the hardware interface expected by any of many different operating systems, OSL virtualization essentially provides a secure partition of the execution environment provided by a particular operating system. As one example, OSL virtualization provides a file system to each container, but the file system provided to the container is essentially a view of a partition of the general file system provided by the underlying operating system. In essence, OSL virtualization uses operating-system features, such as namespace support, to isolate each container from the remaining containers so that the applications executing within the execution environment provided by a container are isolated from applications executing within the execution environments provided by the other containers. As a result, a container can be booted up much faster than a virtual machine, since the container uses operating-system-kernel features that are already available and functioning within the host computer. Furthermore, the containers share computational bandwidth, memory, network bandwidth, and other computational resources provided by the operating system, without the overhead associated with computational resources allocated to virtual machines and virtualization layers. Again, however, OSL virtualization does not provide many desirable features of traditional virtualization. As mentioned above, OSL virtualization does not provide a way to run different types of operating systems for different groups of containers within the same host system and OSL-virtualization does not provide for live migration of containers between host computers, high-availability functionality, distributed resource scheduling, and other computational functionality provided by traditional virtualization technologies.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 14","FIG. 14","FIG. 5A","FIG. 5A","FIG. 14"],"b":["502","504","508","1402","1404","1406","1408"]},"Running containers above a guest operating system within a virtualized host computer provides advantages of traditional virtualization in addition to the advantages of OSL virtualization. Containers can be quickly booted in order to provide additional execution environments and associated resources for additional application instances. The resources available to the guest operating system are efficiently partitioned among the containers provided by the OSL-virtualization layer , since there is almost no additional computational overheads associated with container-based partitioning of computational resources. However, many of the powerful and flexible features of the traditional virtualization technology can be applied to virtual machines in which containers run above guest operating systems, including live migration from one host computer to another, various types of high-availability and distributed resource scheduling, and other such features. Containers provide share-based allocation of computational resources to groups of applications with guaranteed isolation of applications in one container from applications in the remaining containers executing above a guest operating system. Moreover, resource allocation can be modified at run time between containers. The traditional virtualization layer provides for flexible and easy scaling over large numbers of host computers within large distributed computing systems and a simple approach to operating-system upgrades and patches. Thus, the use of OSL virtualization above traditional virtualization in a hybrid virtualized distributed computing system, as illustrated in , provides many of the advantages of both a traditional virtualization layer and the advantages of OSL virtualization.","The current disclosure is particularly directed to an elastic scheduling method and system that anticipates the need for additional resources to support launching additional containers in a hybrid virtualized distributed computing system. Virtual-data-center administration facilities provided by the virtualization layer anticipates the future need for additional physical computational resources, such as additional host computers, memory, mass-storage devices, and other such resources. However, running OSL-virtualization containers above guest operating systems introduces new computational-resource issues not previously addressed within virtualization layers, including the need to anticipate when to provision and launch additional virtual machines in order to provide sufficient computational resources for launching of new containers to run additional client application programs and\/or additional instances of already running application programs. When launching new VMs, the number of VMs to provision and launch and the amount of resources allocated to each of the VMs need to be carefully considered in order to minimize wastage of computational resources. Each VM is associated with a certain amount of overhead, so that, in general, it is best to launch fewer VMs with greater resource allocations, provided that the allocated resources match the anticipated need for additional computational resources to support launching of additional containers.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIGS. 15A-D","FIGS. 15A-D"]},"In , the state of a hybrid virtualized distributed computing system is illustrated. The virtualized, distributed computing system includes four host computers represented by four sets of horizontal bars -. The large horizontal bars - represent the amount of a physical memory resource within each of the host computers -, respectively. A scale  shows the correspondence between gigabytes of memory and the lengths of the horizontal bars representing the memory resource. Shorter horizontal bars representing the virtual machines currently running within the host computer are shown, in , above the horizontal bars - representing the available physical memory within host computers. The shorter horizontal bars representing the virtual machines, such as horizontal bar , indicate the local name for the virtual machine, the guest operating system running within the virtual machine, and the available memory for supporting OSL-virtualization containers. A third level of short horizontal bars, above the shorter horizontal bars representing virtual machines, represent containers running within the guest-operating-system-provided execution environment. For example, short horizontal bars - represent three containers C, C, and C, respectively, running within a Linux execution environment within virtual machine VM  executing on host computer . The local name of the container and the amount of memory utilized by the container are shown within each short horizontal bar representing a container. A clock symbol  is used to indicate a time point at which the state snapshot represented by the sets of horizontal bars was obtained. The min and max arrows - represent the minimum amount of memory and the maximum amount of memory that can be allocated to a virtual machine when the virtual machine is provisioned and launched. Thus, according to , the example hybrid virtualized, distributed computing system includes: (1) a first host computer  on which two virtual machines  and  are currently executing, the first virtual machine  supporting three containers - and the second virtual machine  supporting a single container ; (2) a second host computer  on which two virtual machines  and  are currently executing, the first of which  is currently supporting three containers - and the second of which  currently supports a single container ; (3) a third host computer  on which a single virtual machine  is currently running and supporting two containers  and ; and a fourth host computer  on which two virtual machines  and  are currently running, the first of which  currently supports two containers  and  and the second of which  is currently supporting a single container .",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 15B","FIG. 15B","FIGS. 15A-D"],"b":["1516","1538","1538","1539","1540","1541","1542","1543"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 15C","b":["1545","1546","1547","1548","1549"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 15D","b":["1550","1551","1552","1553","1554","1555","1554","1554"]},"A better approach to launching and provisioning VMs to support containers in a hybrid virtualized distributed computing system would be to attempt to anticipate the need for new virtual machines well before they are actually needed, so that sufficient computational resources are available to launch new containers on demand. Moreover, by anticipating the demand for resources to launch of new containers, new VMs can be launched with appropriate amounts of allocated resources to efficiently satisfy expected demands for computational resources.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIGS. 16A-C","FIGS. 15A-C","FIG. 16A","FIGS. 15B-D","FIGS. 15B-D","FIG. 15B","FIGS. 16B and 16C","FIG. 15C","FIG. 15D"],"b":["1538","1602","1603","1604","1605","1606","1607","1606","3","2","3"]},"There are a variety of different, well-known methods for estimating or extrapolating a subsequent data point from a time series of data points.  illustrate three of the many different data-point-extrapolation methods. In each of , a plot of the values of a discrete function with respect to time is shown. The data points, such as data point  in , represent the function value at a particular point in time, such as time point  on the horizontal axis  corresponding to data point  with value equal to the height of the data point above the horizontal, time axis . One method for estimating a subsequent data point, shown in , is to use linear regression to determine a best-estimated line  that fits the data points in the time series of data points. In one approach, a line is computes that minimizes the squared vertical deviations of the data points from the line. Once a best-fitting line  is obtained, a next data point in the time series  is estimated as the intersection between the best-fitting line and a vertical line passing through the time at which the estimated function value is desired. Another approach, shown in , is to attempt to fit some type of constrained curve to the data points. The curve may have local radius of curvature constraints, for example, so that it is reasonably smooth. Once the curve  is determined, then the value of the next data point in the time series can be estimated  as the intersection of the curve and the vertical line corresponding to the next time point . Yet another approach, as shown in , is to attempt to optimally fit some number of lines or curves to the data points and estimate the subsequent data point  from the intersection of the vertical line  to the next time interval and the final linear or curved segment  estimated from the time series of data points. There are many additional methods that can be used to extrapolate the values of subsequent data points in a data-point time series.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIGS. 18A-D"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 18A","b":["1802","1804","1806","1811"]},"In step , the monitoring routine pushes the amount of the computational resource, data[os].C_utilized, utilized by the containers running within guest operating systems of the currently considered type of operating system that were launched during the most recent monitoring interval onto the end of the data-point window. The push operation may remove the first data point of the window, when necessary, in order to make space to push the most recently determined data point onto the data-point window. When there are as sufficient number of data points in the data-point window to estimate the projected utilization of the computational resource for the next, future time interval, as determined in step , the monitoring routine estimates the next data point d, in step , using a data-point extrapolation method, such as one of those discussed above with reference to . The monitoring routine then uses the estimated data point to carry out eager provision of new VMs, when a future need for more resources is indicated by the estimated data point value d, in step . The routine \u201ceager provision\u201d is discussed below with reference to . When there are more OS types in the set of OS types OSset, as determined in step , control returns to step  to estimate the demand for the computation resource for a next operating-system type. When all the operating-system types have been considered, the data point windows for any operating-system types for which no data point was computed in the current monitoring interval are cleared, in step , since there would otherwise a discontinuity in the time series of data points. A data point is not computed for an operating-system type, for example, when there are no currently executing VMs that run an operating system of that type.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 18B","FIG. 18A"],"b":["1804","1820","1821","1827","1822","1823","1824","1825","1826","1827","1822"]},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 18C","FIG. 18B"],"b":["1826","1830","1834","1831","1832","1835","1833","1834","1833","1835","1831"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 18D","FIG. 18A","FIG. 18A"],"b":["1810","1840","1809","1841","1842","1843","1845","1846","1847","1848"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIGS. 19A-E"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 19A","b":"1902"},"An enumeration OS  includes a listing of the various types of operating systems run by VMs in the distributed computing system. The type definition time  produces a type time used for the start times of containers and for other purposes. As with all the particular implementation details in this C++-like implementation, various alternative types, constants, constant values, and other such details may be used in alternative implementations. In general, time stamps generated by the distributed system may be integer values that express the number of some time unit, such as milliseconds, seconds, or other time units, that have elapsed since some arbitrary initial time. Alternatively, time stamps may be encoded in date\/time formats corresponding to calendar and clock time.","The function wait  causes a routine to wait for an indicated amount of time before resuming execution. No implementation for this routine is provided, since it is highly dependent on platform hardware, choice of virtualization technology, and\/or choice of operating system. The routine extrapolate  extrapolates a next data point in a time series of data points by any of various different methods discussed above or by other extrapolation methods. Data-extrapolation routines may be based on simple linear extrapolation, using linear regression, may be based on various types of curve fitting, or may be based on more sophisticated time-sequence-progression estimation techniques. The type definition for the type Ct  is used to store the memory utilization and start time for a container in an array of elements of type Ct that is sorted as part of the method, implemented below in a monitor routine.","Next, four class declarations are provided. In all cases, only the public function-member portions of the declaration are provided, since there are many different, and generally straightforward, ways of implementing these classes. The class Container  represents a container running within the distributed-computing system. Member functions allow for the memory utilization and start time for the container to be extracted from an instance of the class Container, including the member functions get Utilization and getStart, and an == operator, initialization routine, and constructor are also defined for the class Container.","The class VM  represents a virtual machine executing within the distributed-computing system. The class VM includes an == operator, initialization routine, and constructor, like the Container class. In addition, the member functions get Utilization and getConfigured are used to determine the amount of memory utilized by the VM and the amount of configured memory for the VM, respectively. The member function getOS is used to extract an indication of the type of operating system run by the VM. The member function getNumContainers is used to determine the number of containers currently executing within the execution environment provided by the VM. The pair of member functions getFirstContainer and getNextContainer are used to traverse the containers currently executing within the execution environment provided by the VM.","The type definitions for VMptr and Ctptr are provided as convenient types for pointers to instances of the VM and Container classes, respectively . The class set is a generalized class representing a set of objects of type M . The class set includes member functions for adding an element to the set, the pair of member functions first and next, which allow the elements in the set to be traversed, a member function getNum, which returns the number of elements in the set, and the member function in, which returns a Boolean value to indicate whether the reference to an element, supplied as an argument to the function in, is currently contained in the set.","A final declaration is for the class dSystem . This class represents the distributed computing system. The class provides a pair of functions getFirstVM and getNextVM provides a mechanism for traversing the VMs associated with the distributed computing system. In certain implementations, this may mean those VMs currently executing within the distributed-computing system. In other implementations, this may mean both the currently executing VMs as well as any VMs that were executing during some more recent period of time such as, in one example, during the past n time intervals considered by the subsequently described monitoring method. In other words, in order to estimate future demand for container-associated resources, one may consider only the currently executing VMs or one may consider a historical record of all VMs that were executing over a considered previous time period. In many cases, the number of executing VMs in the distributed computing system may be relatively stable, over the considered periods of time, and may generally increase, in which case a historical perspective is unnecessary. In other cases, the number of executing VMs may fluctuate, with demand, over the considered time period, as a result of which a historical perspective provides a better estimate of future demand for resources. Two member functions provision and launch provide for provisioning and launching VMs within the distributed computing system. The member function getCurrentTime is used to obtain a current time stamp from the distributed computing system. The member functions beginMonitor and endMonitor are used, in the subsequently described monitoring routine, to signal beginning of routine execution and ending of routine execution, in case that the distributed computing system wishes to temporarily suspend certain activities while the monitoring routine executes, in order to ensure that the monitoring routine produces a best possible prediction.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 19C","b":["1913","1914","1915","1916"]},{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIGS. 19D-G","FIG. 19D"],"b":["1917","1918","1919","1920","1921","1922","1923","1924","1925","1936","1927","1928"]},{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIGS. 19E-G","FIG. 19E"],"b":["1929","1930","1931","1932","1932","1933","1934","1935","1936","1937","1938","1939"]},"Turning to , when no containers are currently being executed by VMs supported the currently considered operating system, then further execution of the current iteration of the main while-loop is terminated  and execution resumes at the beginning of the main loop . Otherwise, Ct data structures representing the containers launched within the considered time period, stored in the array sortedCts are sorted by a quicksort operation . The local variable nextTime is set to the final time in the first time interval within the considered period . In a while-loop , local variable mStart is incremented until the start time of the first container in the array sortedCts falls within the time interval within the considered time period represented by the current value of mStart. Local variable j is set to  . Local variable j represents the next element of the array sortedCts to be considered in the following for-loop . In for-loop , each data point corresponding to considered time intervals within the considered time period are computed. The data points are stored in the array MbyInterval. During each iteration of the for-loop, the value of the currently considered data point is first initialized to 0 . When the index i for the data point is greater than or equal to the current value of mStart, then all of the Ct data structures that include start times less than the final time for the currently considered interval, stored in the local variable nextTime, are used to compute the currently considered data point as the sum of the memory utilized by all of the containers launched within the currently considered time interval, in the inner while-loop . Following execution of for-loop , a next memory-demand or total-memory-utilized data point is predicted or estimated using the extrapolation routine .",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 19G","FIG. 19F"],"b":["1948","1949","1950","1951","1952","1953","1954","1955"]},"Although the present invention has been described in terms of particular embodiments, it is not intended that the invention be limited to these embodiments. Modifications within the spirit of the invention will be apparent to those skilled in the art. For example, any of many different design and implementation parameters may be varied in order to generate a variety of different implementations of the above-disclosed methods and systems, including choice of native virtualization layers, programming languages, communications protocols, modular organization, data structures, control structures, and other such design and implementation parameters. Any of many different data-point extrapolation routines can be employed. The length of the monitoring period may vary and may, in certain implementations, dynamically vary. Many different types of computational-resource utilization may be monitored concurrently in order to ensure that adequate amounts of the resources are available to allow for launch of containers on demand, without needing to first provision and launch VMs.","It is appreciated that the previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present disclosure. Various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the disclosure. Thus, the present disclosure is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 5A-B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 9","FIG. 9"],"b":["902","904","906","908"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 15A-D"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIGS. 16A-C","FIGS. 15A-C"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 17A-C"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 18A-D"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 19A-G"}]},"DETDESC":[{},{}]}
