---
title: Mechanism for providing data driven command line output
abstract: The present mechanism provides a data driven command line output within an environment that supports a pipeline of object-based commands. Each object-based command inputs a parseable object for processing and outputs another parseable object for subsequent command processing. The mechanism is operative to direct formatting and subsequent processing of the commands based on a type of the incoming parseable object. Format information is obtained for the type, such as shape, properties to display, and the like. The format information may be specified within an XML-based document. The mechanism utilizes one or more output processing commands, such as format commands, markup commands, convert commands, transform commands, and out commands. These output processing commands may be arranged within the pipeline in various ways to achieve the desired output results.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07594170&OS=07594170&RS=07594170
owner: Microsoft Corporation
number: 07594170
owner_city: Redmond
owner_country: US
publication_date: 20031024
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Exemplary Computing Environment","Exemplary Administrative Tool Framework","Exemplary Operation"],"p":["Subject matter disclosed herein relates to command line environments, and in particular to the output of commands entered via a command line environment.","Many operating systems provide a mechanism for \u201cstitching\u201d (i.e., pipelining) multiple applications (e.g., utilities) together to create a custom, ad hoc command that can be entered on a command line of the operating system. Typically, the commands are used in system administration tools, such as for managing system properties. Each of the \u201cpipelined\u201d utilities in the command communicate with each other by transferring text. Thus, each utility in the pipeline is responsible for parsing text that is received and for formatting text that is output.","The formatting of the text that is output is performed by code within the command and is, typically, based on interpreting switches provided on the command line for the command. Thus, each command is responsible for formatting and displaying the output, as desired.","Therefore, there is a need for a mechanism that provides enhanced formatting options and does not require extensive code within the command in order to provide the enhanced formatting options.","The present mechanism provides a data driven command line output within an environment that supports a pipeline of object-based commands. Each object-based command inputs a parseable object for processing and outputs another parseable object for subsequent command processing. The mechanism is operative to direct formatting and subsequent processing of the commands based on a type of the incoming parseable object. Format information is obtained for the type, such as shape, properties to display, and the like. The format information may be specified within an XML-based document. The mechanism utilizes one or more output processing commands, such as format commands, markup commands, convert commands, transform commands, and out commands. These output processing commands may be arranged within the pipeline in various ways to achieve the desired output results.","Briefly stated, the present mechanism provides a data driven command line output. A plurality of output processing cmdlets may be pipelined in various sequences to provide a desired output result. The output processing cmdlets include format cmdlets, markup cmdlets, convert cmdlets, transform cmdlets, and out cmdlets. Display information is populated with formatting options for a type of object. The mechanism is operative to direct formatting and subsequent cmdlet processing based on the type of incoming structured data (e.g., object).","The following description sets forth a specific exemplary administrative tool environment in which the mechanism operates. Other exemplary environments may include features of this specific embodiment and\/or other features, which aim to facilitate outputting of formatted command line data.","The following detailed description is divided into several sections. A first section describes an illustrative computing environment in which the administrative tool environment may operate. A second section describes an exemplary framework for the administrative tool environment. Subsequent sections describe individual components of the exemplary framework and the operation of these components. For example, the section on \u201cExemplary Process for Displaying Command Line Data\u201d, in conjunction with , describes an exemplary mechanism for providing data driven command line output.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 1","FIG. 1"],"b":["100","102","104","104","104","105","106","107","106","120","105","200","120","108"]},"Computing device  may have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable  storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. These devices are well know in the art and need not be discussed at length here.","Computing device  may also contain communication connections  that allow the device to communicate with other computing devices , such as over a network. Communication connections  are one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["200","200","202","204","206","208","206","202","204","208"]},"Host Components","The host components  include one or more host programs (e.g., host programs -) that expose automation features for an associated application to users or to other programs. Each host program - may expose these automation features in its own particular style, such as via a command line, a graphical user interface (GUI), a voice recognition interface, application programming interface (API), a scripting language, a web service, and the like. However, each of the host programs - expose the one or more automation features through a mechanism provided by the administrative tool framework.","In this example, the mechanism uses cmdlets to surface the administrative tool capabilities to a user of the associated host program -. In addition, the mechanism uses a set of interfaces made available by the host to embed the administrative tool environment within the application associated with the corresponding host program -. Throughout the following discussion, the term \u201ccmdlet\u201d is used to refer to commands that are used within the exemplary administrative tool environment described with reference to .","Cmdlets correspond to commands in traditional administrative environments. However, cmdlets are quite different than these traditional commands. For example, cmdlets are typically smaller in size than their counterpart commands because the cmdlets can utilize common functions provided by the administrative tool framework, such as parsing, data validation, error reporting, and the like. Because such common functions can be implemented once and tested once, the use of cmdlets throughout the administrative tool framework allows the incremental development and test costs associated with application-specific functions to be quite low compared to traditional environments.","In addition, in contrast to traditional environments, cmdlets do not need to be stand-alone executable programs. Rather, cmdlets may run in the same processes within the administrative tool framework. This allows cmdlets to exchange \u201clive\u201d objects between each other. This ability to exchange \u201clive\u201d objects allows the cmdlets to directly invoke methods on these objects. The details for creating and using cmdlets are described in further detail below.","In overview, each host program - manages the interactions between the user and the other components within the administrative tool framework. These interactions may include prompts for parameters, reports of errors, and the like. Typically, each host program - may provide its own set of specific host cmdlets (e.g., host cmdlets ). For example, if the host program is an email program, the host program may provide host cmdlets that interact with mailboxes and messages. Even though  illustrates host programs -, one skilled in the art will appreciate that host components  may include other host programs associated with existing or newly created applications. These other host programs will also embed the functionality provided by the administrative tool environment within their associated application. The processing provided by a host program is described in detail below in conjunction with .","In the examples illustrated in , a host program may be a management console (i.e., host program ) that provides a simple, consistent, administration user interface for users to create, save, and open administrative tools that manage the hardware, software, and network components of the computing device. To accomplish these functions, host program  provides a set of services for building management GUIs on top of the administrative tool framework. The GUI interactions may also be exposed as user-visible scripts that help teach the users the scripting capabilities provided by the administrative tool environment.","In another example, the host program may be a command line interactive shell (i.e., host program ). The command line interactive shell may allow shell metadata  to be input on the command line to affect processing of the command line.","In still another example, the host program may be a web service (i.e., host program ) that uses industry standard specifications for distributed computing and interoperability across platforms, programming languages, and applications.","In addition to these examples, third parties may add their own host components by creating \u201cthird party\u201d or \u201cprovider\u201d interfaces and provider cmdlets that are used with their host program or other host programs. The provider interface exposes an application or infrastructure so that the application or infrastructure can be manipulated by the administrative tool framework. The provider cmdlets provide automation for navigation, diagnostics, configuration, lifecycle, operations, and the like. The provider cmdlets exhibit polymorphic cmdlet behavior on a completely heterogeneous set of data stores. The administrative tool environment operates on the provider cmdlets with the same priority as other cmdlet classes. The provider cmdlet is created using the same mechanisms as the other cmdlets. The provider cmdlets expose specific functionality of an application or an infrastructure to the administrative tool framework. Thus, through the use of cmdlets, product developers need only create one host component that will then allow their product to operate with many administrative tools. For example, with the exemplary administrative tool environment, system level graphical user interface help menus may be integrated and ported to existing applications.","Host-Specific Components","The host-specific components  include a collection of services that computing systems (e.g., computing device  in ) use to isolate the administrative tool framework from the specifics of the platform on which the framework is running. Thus, there is a set of host-specific components for each type of platform. The host-specific components allow the users to use the same administrative tools on different operating systems.","Turning briefly to , the host-specific components  may include an intellisense\/metadata access component , a help cmdlet component , a configuration\/registration component , a cmdlet setup component , and an output interface component  Components - communicate with a database store manager  associated with a database store . The parser  and script engine  communicate with the intellisense\/metadata access component . The core engine  communicates with the help cmdlet component , the configuration\/registration component , the cmdlet setup component , and the output interface component . The output interface component  includes interfaces provided by the host to out cmdlets. These out cmdlets can then call the host's output object to perform the rendering. Host-specific components  may also include a logging\/auditing component , which the core engine  uses to communicate with host specific (i.e., platform specific) services that provide logging and auditing capabilities.","In one exemplary administrative tool framework, the intellisense\/metadata access component  provides auto-completion of commands, parameters, and parameter values. The help cmdlet component  provides a customized help system based on a host user interface.","Handler Components","Referring back to , the handler components  includes legacy utilities , management cmdlets , non-management cmdlets , remoting cmdlets , and a web service interface . The management cmdlets  (also referred to as platform cmdlets) include cmdlets that query or manipulate the configuration information associated with the computing device. Because management cmdlets  manipulate system type information, they are dependant upon a particular platform. However, each platform typically has management cmdlets  that provide similar actions as management cmdlets  on other platforms. For example, each platform supports management cmdlets  that get and set system administrative attributes (e.g., get\/process, set\/IP Address). The host-independent components  communicate with the management cmdlets via cmdlet objects generated within the host-independent components . Exemplary data structures for cmdlets objects will be described in detail below in conjunction with .","The non-management cmdlets  (sometimes referred to as base cmdlets) include cmdlets that group, sort, filter, and perform other processing on objects provided by the management cmdlets . The non-management cmdlets  may also include cmdlets for formatting and outputting data associated with the pipelined objects. An exemplary mechanism for providing a data driven command line output is described below in conjunction with . The non-management cmdlets  may be the same on each platform and provide a set of utilities that interact with host-independent components  via cmdlet objects. The interactions between the non-management cmdlets  and the host-independent components  allow reflection on objects and allow processing on the reflected objects independent of their (object) type. Thus, these utilities allow developers to write non-management cmdlets once and then apply these non-management cmdlets across all classes of objects supported on a computing system. In the past, developers had to first comprehend the format of the data that was to be processed and then write the application to process only that data. As a consequence, traditional applications could only process data of a very limited scope. One exemplary mechanism for processing objects independent of their object type is described below in conjunction with .","The legacy utilities  include existing executables, such as win32 executables that run under cmd.exe. Each legacy utility  communicates with the administrative tool framework using text streams (i.e., stdin and stdout), which are a type of object within the object framework. Because the legacy utilities  utilize text streams, reflection-based operations provided by the administrative tool framework are not available. The legacy utilities  execute in a different process than the administrative tool framework. Although not shown, other cmdlets may also operate out of process.","The remoting cmdlets , in combination with the web service interface , provide remoting mechanisms to access interactive and programmatic administrative tool environments on other computing devices over a communication media, such as internet or intranet (e.g., internet\/intranet  shown in ). In one exemplary administrative tool framework, the remoting mechanisms support federated services that depend on infrastructure that spans multiple independent control domains. The remoting mechanism allows scripts to execute on remote computing devices. The scripts may be run on a single or on multiple remote systems. The results of the scripts may be processed as each individual script completes or the results may be aggregated and processed en-masse after all the scripts on the various computing devices have completed.","For example, web service  shown as one of the host components  may be a remote agent. The remote agent handles the submission of remote command requests to the parser and administrative tool framework on the target system. The remoting cmdlets serve as the remote client to provide access to the remote agent. The remote agent and the remoting cmdlets communicate via a parsed stream. This parsed stream may be protected at the protocol layer, or additional cmdlets may be used to encrypt and then decrypt the parsed stream.","Host-Independent Components","The host-independent components  include a parser , a script engine  and a core engine . The host-independent components  provide mechanisms and services to group multiple cmdlets, coordinate the operation of the cmdlets, and coordinate the interaction of other resources, sessions, and jobs with the cmdlets.","Exemplary Parser","The parser  provides mechanisms for receiving input requests from various host programs and mapping the input requests to uniform cmdlet objects that are used throughout the administrative tool framework, such as within the core engine . In addition, the parser  may perform data processing based on the input received. One exemplary method for performing data processing based on the input is described below in conjunction with . The parser  of the present administrative tool framework provides the capability to easily expose different languages or syntax to users for the same capabilities. For example, because the parser  is responsible for interpreting the input requests, a change to the code within the parser  that affects the expected input syntax will essentially affect each user of the administrative tool framework. Therefore, system administrators may provide different parsers on different computing devices that support different syntax. However, each user operating with the same parser will experience a consistent syntax for each cmdlet. In contrast, in traditional environments, each command implemented its own syntax. Thus, with thousands of commands, each environment supported several different syntax, usually many of which were inconsistent with each other.","Exemplary Script Engine","The script engine  provides mechanisms and services to tie multiple cmdlets together using a script. A script is an aggregation of command lines that share session state under strict rules of inheritance. The multiple command lines within the script may be executed either synchronously or asynchronously, based on the syntax provided in the input request. The script engine  has the ability to process control structures, such as loops and conditional clauses and to process variables within the script. The script engine also manages session state and gives cmdlets access to session data based on a policy (not shown).","Exemplary Core Engine","The core engine  is responsible for processing cmdlets identified by the parser . Turning briefly to , an exemplary core engine  within the administrative tool framework  is illustrated. The exemplary core engine  includes a pipeline processor , a loader , a metadata processor , an error & event handler , a session manager , and an extended type manager .","Exemplary Metadata Processor","The metadata processor  is configured to access and store metadata within a metadata store, such as database store  shown in . The metadata may be supplied via the command line, within a cmdlet class definition, and the like. Different components within the administrative tool framework  may request the metadata when performing their processing. For example, parser  may request metadata to validate parameters supplied on the command line.","Exemplary Error & Event Processor","The error & event processor  provides an error object to store information about each occurrence of an error during processing of a command line. For additional information about one particular error and event processor which is particularly suited for the present administrative tool framework, refer to U.S. patent application Ser. No. 10\/413,054 U.S. Pat. No. 7,254,751, entitled \u201cSystem and Method for Persisting Error Information in a Command Line Environment\u201d, which is owned by the same assignee as the present invention, and is incorporated here by reference.","Exemplary Session Manager","The session manager  supplies session and state information to other components within the administrative tool framework . The state information managed by the session manager may be accessed by any cmdlet, host, or core engine via programming interfaces. These programming interfaces allow for the creation, modification, and deletion of state information.","Exemplary Pipeline Processor and Loader","The loader  is configured to load each cmdlet in memory in order for the pipeline processor  to execute the cmdlet. The pipeline processor  includes a cmdlet processor  and a cmdlet manager . The cmdlet processor  dispatches individual cmdlets. If the cmdlet requires execution on a remote, or a set of remote machines, the cmdlet processor  coordinates the execution with the remoting cmdlet  shown in . The cmdlet manager  handles the execution of aggregations of cmdlets. The cmdlet manager , the cmdlet processor , and the script engine  () communicate with each other in order to perform the processing on the input received from the host program -. The communication may be recursive in nature. For example, if the host program provides a script, the script may invoke the cmdlet manager  to execute a cmdlet, which itself may be a script. The script may then be executed by the script engine . One exemplary process flow for the core engine is described in detail below in conjunction with .","Exemplary Extended Type Manager","As mentioned above, the administrative tool framework provides a set of utilities that allows reflection on objects and allows processing on the reflected objects independent of their (object) type. The administrative tool framework  interacts with the component framework on the computing system (component framework  in ) to perform this reflection. As one skilled in the art will appreciate, reflection provides the ability to query an object and to obtain a type for the object, and then reflect on various objects and properties associated with that type of object to obtain other objects and\/or a desired value.","Even though reflection provides the administrative tool framework  a considerable amount of information on objects, the inventors appreciated that reflection focuses on the type of object. For example, when a database datatable is reflected upon, the information that is returned is that the datatable has two properties: a column property and a row property. These two properties do not provide sufficient detail regarding the \u201cobjects\u201d within the datatable. Similar problems arise when reflection is used on extensible markup language (XML) and other objects.","Thus, the inventors conceived of an extended type manager  that focuses on the usage of the type. For this extended type manager, the type of object is not important. Instead, the extended type manager is interested in whether the object can be used to obtain required information. Continuing with the above datatable example, the inventors appreciated that knowing that the datatable has a column property and a row property is not particularly interesting, but appreciated that one column contained information of interest. Focusing on the usage, one could associate each row with an \u201cobject\u201d and associate each column with a \u201cproperty\u201d of that \u201cobject\u201d. Thus, the extended type manager  provides a mechanism to create \u201cobjects\u201d from any type of precisely parse-able input. In so doing, the extended type manager  supplements the reflection capabilities provided by the component-based framework  and extends \u201creflection\u201d to any type of precisely parse-able input.","In overview, the extended type manager is configured to access precisely parse-able input (not shown) and to correlate the precisely parse-able input with a requested data type. The extended type manager  then provides the requested information to the requesting component, such as the pipeline processor  or parser . In the following discussion, precisely parse-able input is defined as input in which properties and values may be discerned. Some exemplary precisely parse-able input include Windows Management Instrumentation (WMI) input, ActiveX Data Objects (ADO) input, eXtensible Markup Language (XML) input, and object input, such as .NET objects. Other precisely parse-able input may include third party data formats.","Turning briefly to , a functional block diagram of an exemplary extended type manager for use within the administrative tool framework is shown. For explanation purposes, the functionality (denoted by the number \u201c3\u201d within a circle) provided by the extended type manager is contrasted with the functionality provided by a traditional tightly bound system (denoted by the number \u201c1\u201d within a circle) and the functionality provided by a reflection system (denoted by the number \u201c2\u201d within a circle). In the traditional tightly bound system, a caller  within an application directly accesses the information (e.g., properties P and P, methods M and M) within object A. As mentioned above, the caller  must know, a priori, the properties (e.g., properties P and P) and methods (e.g., methods M and M) provided by object A at compile time. In the reflection system, generic code  (not dependent on any data type) queries a system  that performs reflection  on the requested object and returns the information (e.g., properties P and P, methods M and M) about the object (e.g., object A) to the generic code . Although not shown in object A, the returned information may include additional information, such as vendor, file, date, and the like. Thus, through reflection, the generic code  obtains at least the same information that the tightly bound system provides. The reflection system also allows the caller  to query the system and get additional information without any a priori knowledge of the parameters.","In both the tightly bound systems and the reflection systems, new data types can not be easily incorporated within the operating environment. For example, in a tightly bound system, once the operating environment is delivered, the operating environment can not incorporate new data types because it would have to be rebuilt in order to support them. Likewise, in reflection systems, the metadata for each object class is fixed. Thus, incorporating new data types is not usually done.","However, with the present extended type manager new data types can be incorporated into the operating system. With the extended type manager , generic code  may reflect on a requested object to obtain extended data types (e.g., object A\u2032) provided by various external sources, such as a third party objects (e.g., object A\u2032 and B), a semantic web , an ontology service , and the like. As shown, the third party object may extend an existing object (e.g., object A\u2032) or may create an entirely new object (e.g., object B).","Each of these external sources may register their unique structure within a type metadata  and may provide code . When an object is queried, the extended type manager reviews the type metadata  to determine whether the object has been registered. If the object is not registered within the type metadata , reflection is performed. Otherwise, extended reflection is performed. The code  returns the additional properties and methods associated with the type being reflected upon. For example, if the input type is XML, the code  may include a description file that describes the manner in which the XML is used to create the objects from the XML document. Thus, the type metadata  describes how the extended type manager  should query various types of precisely parse-able input (e.g., third party objects A\u2032 and B, semantic web ) to obtain the desired properties for creating an object for that specific input type and the code  provides the instructions to obtain these desired properties. As a result, the extended type manager  provides a layer of indirection that allows \u201creflection\u201d on all types of objects.","In addition to providing extended types, the extend type manager  provides additional query mechanisms, such as a property path mechanism, a key mechanism, a compare mechanism, a conversion mechanism, a globber mechanism, a property set mechanism, a relationship mechanism, and the like. Each of these query mechanisms, described below in the section \u201cExemplary Extended Type Manager Processing\u201d, provides flexibility to system administrators when entering command strings. Various techniques may be used to implement the semantics for the extended type manager. Three techniques are described below. However, those skilled in the art will appreciate that variations of these techniques may be used without departing from the scope of the claimed invention.","In one technique, a series of classes having static methods (e.g., getproperty( )) may be provided. An object is input into the static method (e.g., getproperty(object)), and the static method returns a set of results. In another technique, the operating environment envelopes the object with an adapter. Thus, no input is supplied. Each instance of the adapter has a getproperty method that acts upon the enveloped object and returns the properties for the enveloped object. The following is pseudo code illustrating this technique:",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class Adaptor"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003Object X;"]},{"entry":[{},"\u2003\u2003getProperties( );"]},{"entry":[{},"}."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In still another technique, an adaptor class subclasses the object. Traditionally, subclassing occurred before compilation. However, with certain operating environments, subclassing may occur dynamically. For these types of environments, the following is pseudo code illustrating this technique:",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class Adaptor : A"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003getProperties( )"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003return data;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Thus, as illustrated in , the extended type manager allows developers to create a new data type, register the data type, and allow other applications and cmdlets to use the new data type. In contrast, in prior administrative environments, each data type had to be known at compile time so that a property or method associated with an object instantiated from that data type could be directly accessed. Therefore, adding new data types that were supported by the administrative environment was seldom done in the past.","Referring back to , in overview, the administrative tool framework  does not rely on the shell for coordinating the execution of commands input by users, but rather, splits the functionality into processing portions (e.g., host-independent components ) and user interaction portions (e.g., via host cmdlets). In addition, the present administrative tool environment greatly simplifies the programming of administrative tools because the code required for parsing and data validation is no longer included within each command, but is rather provided by components (e.g., parser ) within the administrative tool framework. The exemplary processing performed within the administrative tool framework is described below.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIGS. 5-7","FIGS. 8-17"]},"Exemplary Data Structures for Cmdlet Objects",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 5","FIG. 2"]},"The provider cmdlet  (hereinafter, referred to as cmdlet ) is a public class having a cmdlet class name (e.g., StopProcess ). Cmdlet  derives from a cmdlet class . An exemplary data structure for a cmdlet class  is described below in conjunction with . Each cmdlet  is associated with a command attribute  that associates a name (e.g., Stop\/Process) with the cmdlet . The name is registered within the administrative tool environment. As will be described below, the parser looks in the cmdlet registry to identify the cmdlet  when a command string having the name (e.g., Stop\/Process) is supplied as input on a command line or in a script.","The cmdlet  is associated with a grammar mechanism that defines a grammar for expected input parameters to the cmdlet. The grammar mechanism may be directly or indirectly associated with the cmdlet. For example, the cmdlet  illustrates a direct grammar association. In this cmdlet , one or more public parameters (e.g., ProcessName  and PID ) are declared. The declaration of the public parameters drives the parsing of the input objects to the cmdlet . Alternatively, the description of the parameters may appear in an external source, such as an XML document. The description of the parameters in this external source would then drive the parsing of the input objects to the cmdlet.","Each public parameter ,  may have one or more attributes (i.e., directives) associated with it. The directives may be from any of the following categories: parsing directive , data validation directive , data generation directive , processing directive , encoding directive , and documentation directive . The directives may be surrounded by square brackets. Each directive describes an operation to be performed on the following expected input parameter. Some of the directives may also be applied at a class level, such as user-interaction type directives. The directives are stored in the metadata associated with the cmdlet. The application of these attributes is described below in conjunction with .","These attributes may also affect the population of the parameters declared within the cmdlet. One exemplary process for populating these parameters is described below in conjunction with . The core engine may apply these directives to ensure compliance. The cmdlet  includes a first method  (hereinafter, interchangeably referred to as StartProcessing method ) and a second method  (hereinafter, interchangeably referred to as processRecord method ). The core engine uses the first and second methods ,  to direct the processing of the cmdlet . For example, the first method  is executed once and performs set-up functions. The code  within the second method  is executed for each object (e.g., record) that needs to be processed by the cmdlet . The cmdlet  may also include a third method (not shown) that cleans up after the cmdlet .","Thus, as shown in , code  within the second method  is typically quite brief and does not contain functionality required in traditional administrative tool environments, such as parsing code, data validation code, and the like. Thus, system administrators can develop complex administrative tasks without learning a complex programming language.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 6","FIG. 5"],"b":["600","602","602"]},"The exemplary data structure  includes parameters, such as Boolean parameter verbose , whatif , and confirm . As will be explained below, these parameters correspond to strings that may be entered on the command input. The exemplary data structure  may also include a security method  that determines whether the task being requested for execution is allowed.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 7","b":["700","700","500","700","704","702","700","500","700","730","732","520","526","500"]},"However, in this exemplary data structure , each of the expected input parameters  and  is associated with an input attribute  and , respectively. The input attributes  and  specifying that the data for its respective parameter  and  should be obtained from the command line. Thus, in this exemplary data structure , there are not any expected input parameters that are populated from a pipelined object that has been emitted by another cmdlet. Thus, data structure  does not override the first method (e.g., StartProcessing) or the second method (e.g., ProcessRecord) which are provided by the cmdlet base class.","The data structure  may also include a private member  that is not recognized as an input parameter. The private member  may be used for storing data that is generated based on one of the directives.","Thus, as illustrated in data structure , through the use of declaring public properties and directives within a specific cmdlet class, cmdlet developers can easily specify a grammar for the expected input parameters to their cmdlets and specify processing that should be performed on the expected input parameters without requiring the cmdlet developers to generate any of the underlying logic. Data structure  illustrates a direct association between the cmdlet and the grammar mechanism. As mentioned above, this associated may also be indirect, such as by specifying the expected parameter definitions within an external source, such as an XML document.","The exemplary process flows within the administrative tool environment are now described.","Exemplary Host Processing Flow",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 8","FIG. 2"],"b":["800","801","802"]},"At block , the specific application (e.g., host program) on the \u201ctarget\u201d computing device sets up its environment. This includes determining which subsets of cmdlets (e.g., management cmdlets , non-management cmdlets , and host cmdlets ) are made available to the user. Typically, the host program will make all the non-management cmdlets  available and its own host cmdlets  available. In addition, the host program will make a subset of the management cmdlets  available, such as cmdlets dealing with processes, disk, and the like. Thus, once the host program makes the subsets of cmdlets available, the administrative tool framework is effectively embedded within the corresponding application. Processing continues to block .","At block , input is obtained through the specific application. As mentioned above, input may take several forms, such as command lines, scripts, voice, GUI, and the like. For example, when input is obtained via a command line, the input is retrieve from the keystrokes entered on a keyboard. For a GUI host, a string is composed based on the GUI. Processing continues at block .","At block , the input is provided to other components within the administrative tool framework for processing. The host program may forward the input directly to the other components, such as the parser. Alternatively, the host program may forward the input via one of its host cmdlets. The host cmdlet may convert its specific type of input (e.g., voice) into a type of input (e.g., text string, script) that is recognized by the administrative tool framework. For example, voice input may be converted to a script or command line string depending on the content of the voice input. Because each host program is responsible for converting their type of input to an input recognized by the administrative tool framework, the administrative tool framework can accept input from any number of various host components. In addition, the administrative tool framework provides a rich set of utilities that perform conversions between data types when the input is forwarded via one of its cmdlets. Processing performed on the input by the other components is described below in conjunction with several other figures. Host processing continues at decision block .","At decision block , a determination is made whether a request was received for additional input. This may occur if one of the other components responsible for processing the input needs additional information from the user in order to complete its processing. For example, a password may be required to access certain data, confirmation of specific actions may be needed, and the like. For certain types of host programs (e.g., voice mail), a request such as this may not be appropriate. Thus, instead of querying the user for additional information, the host program may serialize the state, suspend the state, and send a notification so that at a later time the state may be resumed and the execution of the input be continued. In another variation, the host program may provide a default value after a predetermined time period. If a request for additional input is received, processing loops back to block , where the additional input is obtained. Processing then continues through blocks  and  as described above. If no request for additional input is received and the input has been processed, processing continues to block .","At block , results are received from other components within the administrative tool framework. The results may include error messages, status, and the like. The results are in an object form, which is recognized and processed by the host cmdlet within the administrative tool framework. As will be described below, the code written for each host cmdlet is very minimal. Thus, a rich set of output may be displayed without requiring a huge investment in development costs. Processing continues at block .","At block , the results may be viewed. The host cmdlet converts the results to the display style supported by the host program. For example, a returned object may be displayed by a GUI host program using a graphical depiction, such as an icon, barking dog, and the like. The host cmdlet provides a default format and output for the data. The default format and output may utilize the exemplary output processing cmdlets described below in conjunction with . After the results are optionally displayed, the host processing is complete.","Exemplary Process Flows for Handling Input",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 9","FIG. 2"],"b":["901","902"]},"At block , the input is received from the host program. In one exemplary administrative tool framework, the input is received by the parser, which deciphers the input and directs the input for further processing. Processing continues at decision block .","At decision block , a determination is made whether the input is a script. The input may take the form of a script or a string representing a command line (hereinafter, referred to as a \u201ccommand string\u201d). The command string may represent one or more cmdlets pipelined together. Even though the administrative tool framework supports several different hosts, each host provides the input as either a script or a command string for processing. As will be shown below, the interaction between scripts and command strings is recursive in nature. For example, a script may have a line that invokes a cmdlet. The cmdlet itself may be a script.","Thus, at decision block , if the input is in a form of a script, processing continues at block , where processing of the script is performed. Otherwise, processing continues at block , where processing of the command string is performed. Once the processing performed within either block  or  is completed, processing of the input is complete.","Exemplary Processing of Scripts",{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIG. 10","FIG. 9"],"b":["1001","1002"]},"At block , pre-processing is performed on the script. Briefly, turning to , a logical flow diagram is shown that illustrates a script pre-processing process  suitable for use within the script processing process . Script pre-processing begins at block  and continues to decision block .","At decision block , a determination is made whether the script is being run for the first time. This determination may be based on information obtained from a registry or other storage mechanism. The script is identified from within the storage mechanism and the associated data is reviewed. If the script has not run previously, processing continues at block .","At block , the script is registered in the registry. This allows information about the script to be stored for later access by components within the administrative tool framework. Processing continues at block .","At block , help and documentation are extracted from the script and stored in the registry. Again, this information may be later accessed by components within the administrative tool framework. The script is now ready for processing and returns to block  in .","Returning to decision block , if the process concludes that the script has run previously, processing continues to decision block . At decision block , a determination is made whether the script failed during processing. This information may be obtained from the registry. If the script has not failed, the script is ready for processing and returns to block  in .","However, if the script has failed, processing continues at block . At block , the script engine may notify the user through the host program that the script has previously failed. This notification will allow a user to decide whether to proceed with the script or to exit the script. As mentioned above in conjunction with , the host program may handle this request in various ways depending on the style of input (e.g., voice, command line). Once additional input is received from the user, the script either returns to block  in  for processing or the script is aborted.","Returning to block  in , a line from the script is retrieved. Processing continues at decision block . At decision block , a determination is made whether the line includes any constraints. A constraint is detected by a predefined begin character (e.g., a bracket \u201c[\u201d) and a corresponding end character (e.g., a close bracket \u201c]\u201d). If the line includes constraints, processing continues to block .","At block , the constraints included in the line are applied. In general, the constraints provide a mechanism within the administrative tool framework to specify a type for a parameter entered in the script and to specify validation logic which should be performed on the parameter. The constraints are not only applicable to parameters, but are also applicable to any type of construct entered in the script, such as variables. Thus, the constraints provide a mechanism within an interpretive environment to specify a data type and to validate parameters. In traditional environments, system administrators are unable to formally test parameters entered within a script. An exemplary process for applying constraints is illustrated in .","At decision block , a determination is made whether the line from the script includes built-in capabilities. Built-in capabilities are capabilities that are not performed by the core engine. Built-in capabilities may be processed using cmdlets or may be processed using other mechanisms, such as in-line functions. If the line does not have built-in capabilities, processing continues at decision block . Otherwise, processing continues at block .","At block , the built-in capabilities provided on the line of the script are processed. Example built-in capabilities may include execution of control structures, such as \u201cif\u201d statements, \u201cfor\u201d loops, switches, and the like. Built-in capabilities may also include assignment type statements (e.g., a=3). Once the built-in capabilities have been processed, processing continues to decision block .","At decision block , a determination is made whether the line of the script includes a command string. The determination is based on whether the data on the line is associated with a command string that has been registered and with a syntax of the potential cmdlet invocation. As mentioned above, the processing of command strings and scripts may be recursive in nature because scripts may include command strings and command strings may execute a cmdlet that is a script itself. If the line does not include a command string, processing continues at decision block . Otherwise, processing continues at block .","At block , the command string is processed. In overview, the processing of the command string includes identifying a cmdlet class by the parser and passing the corresponding cmdlet object to the core engine for execution. The command string may also include a pipelined command string that is parsed into several individual cmdlet objects and individually processed by the core engine. One exemplary process for processing command strings is described below in conjunction with . Once the command string is processed, processing continues at decision block .","At decision block , a determination is made whether there is another line in the script. If there is another line in the script, processing loops back to block  and proceeds as described above in blocks -. Otherwise, processing is complete.","An exemplary process for applying constraints in block  is illustrated in . The process begins at block  where a constraint is detected in the script or in the command string on the command line. When the constraint is within a script, the constraints and the associated construct may occur on the same line or on separate lines. When the constraint is within a command string, the constraint and the associated construct occur before the end of line indicator (e.g., enter key). Processing continues to block .","At block , constraints are obtained from the interpretive environment. In one exemplary administrative tool environment, the parser deciphers the input and determines the occurrence of constraints. Constraints may be from one of the following categories: predicate directive, parsing directive, data validation directive, data generation directive, processing directive, encoding directive, and documentation directive. In one exemplary parsing syntax, the directives are surrounded by square brackets and describe the construct that follows them. The construct may be a function, a variable, a script, or the like.","As will be described below, through the use of directives, script authors are allowed to easily type and perform processing on the parameters within the script or command line (i.e., an interpretive environment) without requiring the script authors to generate any of the underlying logic. Processing continues to block .","At block , the constraints that are obtained are stored in the metadata for the associated construct. The associated construct is identified as being the first non-attribution token after one or more attribution tokens (tokens that denote constraints) have been encountered. Processing continues to block .","At block , whenever the construct is encountered within the script or in the command string, the constraints defined within the metadata are applied to the construct. The constraints may include data type, predicate directives , documentation directives , parsing directives , data generation directives , data validation directives , and object processing and encoding directives . Constraints specifying data types may specify any data type supported by the system on which the administrative tool framework is running. Predicate directives  are directives that indicate whether processing should occur. Thus, predicate directives  ensure that the environment is correct for execution. For example, a script may include the following predicate directive:","[PredicateScript(\u201cis Installed\u201d, \u201cApplicationZ\u201d)].","The predicate directive ensures that the correct application is installed on the computing device before running the script. Typically, system environment variables may be specified as predicate directives. Exemplary directives from directive types - are illustrated in Tables 1-5. Processing of the script is then complete.","Thus, the present process for applying types and constraints within an interpretive environment, allows system administrators to easily specify a type, specify validation requirements, and the like without having to write the underlying logic for performing this processing. The following is an example of the constraint processing performed on a command string specified as follows:","[Integer] [ValidationRange(3,5)] $a=4.","There are two constraints specified via attribution tokens denoted by \u201c[ ]\u201d. The first attribution token indicates that the variable is a type integer and a second attribution token indicates that the value of the variable $a must be between 3 and inclusive. The example command string ensures that if the variable $a is assigned in a subsequent command string or line, the variable $a will be checked against the two constraints. Thus, the following command strings would each result in an error:","$a=231","$a=\u201capple\u201d","$a=$(get\/location).","The constraints are applied at various stages within the administrative tool framework. For example, applicability directives, documentation directives, and parsing guideline directives are processed at a very early stage within the parser. Data generation directives and validation directives are processed in the engine once the parser has finished parsing all the input parameters.","The following tables illustrate representative directives for the various categories, along with an explanation of the processing performed by the administrative tool environment in response to the directive.",{"@attributes":{"id":"p-0131","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Applicability Directives"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["PrerequisiteMachineRoleAttribute","Informs shell whether element"]},{"entry":[{},"is to be used only in certain machine"]},{"entry":[{},"roles (e.g., File Server, Mail Server)."]},{"entry":["PrerequisiteUserRoleAttribute","Informs shell whether element"]},{"entry":[{},"is to be used only in certain user roles"]},{"entry":[{},"(e.g., Domain Administrator, Backup"]},{"entry":[{},"Operator)."]},{"entry":["PrerequisiteScriptAttribute","Informs the shell this script will"]},{"entry":[{},"be run before excuting the actual"]},{"entry":[{},"command or parameter. Can be used"]},{"entry":[{},"for parameter validation"]},{"entry":["PrerequisiteUITypeAttribute","This is used to check the User"]},{"entry":[{},"interface available before excuting"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0132","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Parsing Guideline Directives"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ParsingParameterPositionAttribute","Maps unqualified"]},{"entry":[{},"parameters based on"]},{"entry":[{},"position."]},{"entry":["ParsingVariableLengthParameterListAttribute","Maps parameters"]},{"entry":[{},"not having a Parsing"]},{"entry":[{},"ParameterPosition"]},{"entry":[{},"attribute."]},{"entry":["ParsingDisallowInteractionAttribute","Specifies action"]},{"entry":[{},"when number of"]},{"entry":[{},"parameters is less than"]},{"entry":[{},"required number."]},{"entry":["ParsingRequireInteractionAttribute","Specifies that"]},{"entry":[{},"parameters are obtained"]},{"entry":[{},"through interaction."]},{"entry":["ParsingHiddenElementAttribute","Makes parameter"]},{"entry":[{},"invisible to end user."]},{"entry":["ParsingMandatoryParameterAttribute","Specifies that the"]},{"entry":[{},"parameter is required."]},{"entry":["ParsingPasswordParameterAttribute","Requires special"]},{"entry":[{},"handling of parameter."]},{"entry":["ParsingPromptStringAttribute","Specifies a prompt"]},{"entry":[{},"for the parameter."]},{"entry":["ParsingDefaultAnswerAttribute","Specifies default"]},{"entry":[{},"answer for parameter."]},{"entry":["ParsingDefaultAnswerScriptAttribute","Specifies action to"]},{"entry":[{},"get default answer for"]},{"entry":[{},"parameter."]},{"entry":["ParsingDefaultValueAttribute","Specifies default"]},{"entry":[{},"value for parameter."]},{"entry":["ParsingDefaultValueScriptAttribute","Specifies action to"]},{"entry":[{},"get default value for"]},{"entry":[{},"parameter."]},{"entry":["ParsingParameterMappingAttribute","Specifies a way to"]},{"entry":[{},"group parameters"]},{"entry":["ParsingParameterDeclarationAttribute","This defines that the"]},{"entry":[{},"filed is a parameter"]},{"entry":["ParsingAllowPipelineInputAttribute","Defines the"]},{"entry":[{},"parameter can be"]},{"entry":[{},"populated"]},{"entry":[{},"from the pipeline"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0133","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Documentation Directives"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["DocumentNameAttribute","Provides a Name to refer to"]},{"entry":[{},"elements for interaction or help."]},{"entry":["DocumentShortDescriptionAttribute","Provides brief description of"]},{"entry":[{},"element."]},{"entry":["DocumentLongDescriptionAttribute","Provides detailed description"]},{"entry":[{},"of element."]},{"entry":["DocumentExampleAttribute","Provides example of element."]},{"entry":["DocumentSeeAlsoAttribute","Provides a list of related"]},{"entry":[{},"elements."]},{"entry":["DocumentSynopsisAttribute","Provides documentation"]},{"entry":[{},"information for element."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0134","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Validation Directives"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ValidationRangeAttribute","Specifies that parameter must be"]},{"entry":[{},"within certain range."]},{"entry":["ValidationSetAttribute","Specifies that parameter must be"]},{"entry":[{},"within certain collection."]},{"entry":["ValidationPatternAttribute","Specifies that parameter must fit"]},{"entry":[{},"a certain pattern."]},{"entry":["ValidationLengthAttribute","Specifies the strings must be"]},{"entry":[{},"within size range."]},{"entry":["ValidationTypeAttribute","Specifies that parameter must be"]},{"entry":[{},"of certain type."]},{"entry":["ValidationCountAttributue","Specifies that input items must"]},{"entry":[{},"be of a certain number."]},{"entry":["ValidationFileAttribute","Specifies certain properties for a"]},{"entry":[{},"file."]},{"entry":["ValidationFileAttributesAttribute","Specifies certain properties for a"]},{"entry":[{},"file."]},{"entry":["ValidationFileSizeAttribute","Specifies that files must be"]},{"entry":[{},"within specified range."]},{"entry":["ValidationNetworkAttribute","Specifies that given Network"]},{"entry":[{},"Entity supports certain properties."]},{"entry":["ValidationScriptAttribute","Specifies conditions to evaluate"]},{"entry":[{},"before using element."]},{"entry":["ValidationMethodAttribute","Specifies conditions to evaluate"]},{"entry":[{},"before using element."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0135","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Processing and Encoding Directives"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ProcessingTrimStringAttribute","Specifies size limit for strings."]},{"entry":["ProcessingTrimCollectionAttribute","Specifies size limit for"]},{"entry":[{},"collection."]},{"entry":["EncodingTypeCoercionAttribute","Specifies Type that objects are"]},{"entry":[{},"to be encoded."]},{"entry":["ExpansionWildcardsAttribute","Provides a mechanism to allow"]},{"entry":[{},"globbing"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"When the exemplary administrative tool framework is operating within the .NET\u2122 Framework, each category has a base class that is derived from a basic category class (e.g., CmdAttribute). The basic category class derives from a System.Attribute class. Each category has a pre-defined function (e.g., attrib.func( )) that is called by the parser during category processing. The script author may create a custom category that is derived from a custom category class (e.g., CmdCustomAttribute). The script author may also extend an existing category class by deriving a directive class from the base category class for that category and override the pre-defined function with their implementation. The script author may also override directives and add new directives to the pre-defined set of directives.","The order of processing of these directives may be stored in an external data store accessible by the parser. The administrative tool framework looks for registered categories and calls a function (e.g., ProcessCustomDirective) for each of the directives in that category. Thus, the order of category processing may be dynamic by storing the category execution information in a persistent store. At different processing stages, the parser checks in the persistent store to determine if any metadata category needs to be executed at that time. This allows categories to be easily deprecated by removing the category entry from the persistent store.","Exemplary Processing of Command Strings","One exemplary process for processing command strings is now described.  is a functional flow diagram graphically illustrating the processing of a command string  through a parser  and a core engine  within the administrative tool framework shown in . The exemplary command string  pipelines several commands (i.e., process command , where command , sort command , and table command ). The command line  may pass input parameters to any of the commands (e.g., \u201chandlecount>400\u201d is passed to the where command ). One will note that the process command  does not have any associated input parameters.","In the past, each command was responsible for parsing the input parameters associated with the command, determining whether the input parameters were valid, and issuing error messages if the input parameters were not valid. Because the commands were typically written by various programmers, the syntax for the input parameters on the command line was not very consistent. In addition, if an error occurred, the error message, even for the same error, was not very consistent between the commands.","For example, in a UNIX environment, an \u201cls\u201d command and a \u201cps\u201d command have many inconsistencies between them. While both accept an option \u201c-w\u201d, the \u201c-w\u201d option is used by the \u201cls\u201d command to denote the width of the page, while the \u201c-w\u201d option is used by the \u201cps\u201d command to denote print wide output (in essence, ignoring page width). The help pages associated with the \u201cls\u201d and the \u201cps\u201d command have several inconsistencies too, such as having options bolded in one and not the other, sorting options alphabetically in one and not the other, requiring some options to have dashes and some not.","The present administrative tool framework provides a more consistent approach and minimizes the amount of duplicative code that each developer must write. The administrative tool framework  provides a syntax (e.g., grammar), a corresponding semantics (e.g., a dictionary), and a reference model to enable developers to easily take advantage of common functionality provided by the administrative tool framework .","Before describing the present invention any further, definitions for additional terms appearing through-out this specification are provided. Input parameter refers to input-fields for a cmdlet. Argument refers to an input parameter passed to a cmdlet that is the equivalent of a single string in the argv array or passed as a single element in a cmdlet object. As will be described below, a cmdlet provides a mechanism for specifying a grammar. The mechanism may be provided directly or indirectly. An argument is one of an option, an option-argument, or an operand following the command-name. Examples of arguments are given based on the following command line:","findstr\/i\/d:\\winnt;\\winnt\\system32 aa*b*.ini.","In the above command line, \u201cfindstr\u201d is argument 0, \u201c\/i\u201d is argument 1, \u201c\/d:\\winnt;\\winnt\\system32\u201d is argument 2, \u201caa*b\u201d is argument 3, and \u201c*.ini\u201d is argument 4. An \u201coption\u201d is an argument to a cmdlet that is generally used to specify changes to the program's default behavior. Continuing with the example command line above, \u201c\/i\u201d and \u201c\/d\u201d are options. An \u201coption-argument\u201d is an input parameter that follows certain options. In some cases, an option-argument is included within the same argument string as the option. In other cases, the option-argument is included as the next argument. Referring again to the above command line, \u201cwinnt;\\winnt\\system32\u201d is an option-argument. An \u201coperand\u201d is an argument to a cmdlet that is generally used as an object supplying information to a program necessary to complete program processing. Operands generally follow the options in a command line. Referring to the example command line above again, \u201caa*b\u201d and \u201c*.ini\u201d are operands. A \u201cparsable stream\u201d includes the arguments.","Referring to , parser  parses a parsable stream (e.g., command string ) into constituent parts - (e.g., where portion ). Each portion - is associated with one of the cmdlets -. Parser  and engine  perform various processing, such as parsing, parameter validation, data generation, parameter processing, parameter encoding, and parameter documentation. Because parser  and engine  perform common functionality on the input parameters on the command line, the administrative tool framework  is able to issue consistent error messages to users.","As one will recognize, the executable cmdlets - written in accordance with the present administrative tool framework require less code than commands in prior administrative environments. Each executable cmdlet - is identified using its respective constituent part -. In addition, each executable cmdlet - outputs objects (represented by arrows , , , and ) which are input as input objects (represented by arrows , , and ) to the next pipelined cmdlet. These objects may be input by passing a reference (e.g., handle) to the object. The executable cmdlets - may then perform additional processing on the objects that were passed in.",{"@attributes":{"id":"p-0147","num":"0146"},"figref":["FIG. 14","FIG. 9"],"b":["1401","1404"]},"At block , a cmdlet is identified. The identification of the cmdlet may be thru registration. The core engine determines whether the cmdlet is local or remote. The cmdlet may execute in the following locations: 1) within the application domain of the administrative tool framework; 2) within another application domain of the same process as the administrative tool framework; 3) within another process on the same computing device; or 4) within a remote computing device. The communication between cmdlets operating within the same process is through objects. The communication between cmdlets operating within different processes is through a serialized structured data format. One exemplary serialized structured data format is based on the extensible markup language (XML). Processing continues at block .","At block , an instance of the cmdlet object is created. An exemplary process for creating an instance of the cmdlet is described below in conjunction with . Once the cmdlet object is created, processing continues at block .","At block , the properties associated with the cmdlet object are populated. As described above, the developer declares properties within a cmdlet class or within an external source. Briefly, the administrative tool framework will decipher the incoming object(s) to the cmdlet instantiated from the cmdlet class based on the name and type that is declared for the property. If the types are different, the type may be coerced via the extended data type manager. As mentioned earlier, in pipelined command strings, the output of each cmdlet may be a list of handles to objects. The next cmdlet may inputs this list of object handles, performs processing, and passes another list of object handles to the next cmdlet. In addition, as illustrated in , input parameters may be specified as coming from the command line. One exemplary method for populating properties associated with a cmdlet is described below in conjunction with . Once the cmdlet is populated, processing continues at block .","At block , the cmdlet is executed. In overview, the processing provided by the cmdlet is performed at least once, which includes processing for each input object to the cmdlet. Thus, if the cmdlet is the first cmdlet within a pipelined command string, the processing is executed once. For subsequent cmdlets, the processing is executed for each object that is passed to the cmdlet. One exemplary method for executing cmdlets is described below in conjunction with . When the input parameters are only coming from the command line, execution of the cmdlet uses the default methods provided by the base cmdlet case. Once the cmdlet is finished executing, processing proceeds to block .","At block , the cmdlet is cleaned-up. This includes calling the destructor for the associated cmdlet object which is responsible for de-allocating memory and the like. The processing of the command string is then complete.","Exemplary Process for Creating a Cmdlet Object",{"@attributes":{"id":"p-0153","num":"0152"},"figref":["FIG. 15","FIG. 14"],"b":["1500","1501","1504"]},"At block , metadata associated with the cmdlet object class is read. The metadata includes any of the directives associated with the cmdlet. The directives may apply to the cmdlet itself or to one or more of the parameters. During cmdlet registration, the registration code registers the metadata into a persistent store. The metadata may be stored in an XML file in a serialized format, an external database, and the like. Similar to the processing of directives during script processing, each category of directives is processed at a different stage. Each metadata directive handles its own error handling. Processing continues at block .","At block , a cmdlet object is instantiated based on the identified cmdlet class. Processing continues at block .","At block , information is obtained about the cmdlet. This may occur through reflection or other means. The information is about the expected input parameters. As mentioned above, the parameters that are declared public (e.g., public string Name ) correspond to expected input parameters that can be specified in a command string on a command line or provided in an input stream. The administrative tool framework through the extended type manager, described  in , provides a common interface for returning the information (on a need basis) to the caller. Processing continues at block .","At block , applicability directives (e.g., Table 1) are applied. The applicability directives insure that the class is used in certain machine roles and\/or user roles. For example, certain cmdlets may only be used by Domain Administrators. If the constraint specified in one of the applicability directives is not met, an error occurs. Processing continues at block .","At block , metadata is used to provide intellisense. At this point in processing, the entire command string has not yet been entered. The administrative tool framework, however, knows the available cmdlets. Once a cmdlet has been determined, the administrative tool framework knows the input parameters that are allowed by reflecting on the cmdlet object. Thus, the administrative tool framework may auto-complete the cmdlet once a disambiguating portion of the cmdlet name is provided, and then auto-complete the input parameter once a disambiguating portion of the input parameter has been typed on the command line. Auto-completion may occur as soon as the portion of the input parameter can identify one of the input parameters unambiguously. In addition, auto-completion may occur on cmdlet names and operands too. Processing continues at block .","At block , the process waits until the input parameters for the cmdlet have been entered. This may occur once the user has indicated the end of the command string, such as by hitting a return key. In a script, a new line indicates the end of the command string. This wait may include obtaining additional information from the user regarding the parameters and applying other directives. When the cmdlet is one of the pipelined parameters, processing may begin immediately. Once, the necessary command string and input parameters have been provided, processing is complete.","Exemplary Process for Populating the Cmdlet","An exemplary process for populating a cmdlet is illustrated in  and is now described, in conjunction with . In one exemplary administrative tool framework, the core engine performs the processing to populate the parameters for the cmdlet. Processing begins at block  after an instance of a cmdlet has been created. Processing continues to block .","At block , a parameter (e.g., ProcessName) declared within the cmdlet is retrieved. Based on the declaration with the cmdlet, the core engine recognizes that the incoming input objects will provide a property named \u201cProcessName\u201d. If the type of the incoming property is different than the type specified in the parameter declaration, the type will be coerced via the extended type manager. The process of coercing data types is explained below in the subsection entitled \u201cExemplary Extended Type Manager Processing.\u201d Processing continues to block .","At block , an attribute associated with the parameter is obtained. The attribute identifies whether the input source for the parameter is the command line or whether it is from the pipeline. Processing continues to decision block .","At decision block , a determination is made whether the attribute specifies the input source as the command line. If the input source is the command line, processing continues at block . Otherwise, processing continues at decision block .","At decision block , a determination is made whether the property name specified in the declaration should be used or whether a mapping for the property name should be used. This determination is based on whether the command input specified a mapping for the parameter. The following line illustrates an exemplary mapping of the parameter \u201cProcessName\u201d to the \u201cfoo\u201d member of the incoming object:","$ get\/process|where han*-gt 500|stop\/process-ProcessName\u2190foo. Processing continues at block .","At block , the mapping is applied. The mapping replaces the name of the expected parameter from \u201cProcessName\u201d to \u201cfoo\u201d, which is then used by the core engine to parse the incoming objects and to identify the correct expected parameter. Processing continues at block .","At block , the extended type manager is queried to locate a value for the parameter within the incoming object. As explain in conjunction with the extended type manager, the extended type manager takes the parameter name and uses reflection to identify a parameter within the incoming object with parameter name. The extended type manager may also perform other processing for the parameter, if necessary. For example, the extended type manager may coerce the type of data to the expected type of data through a conversion mechanism described above. Processing continues to decision block .","Referring back to block , if the attribute specifies that the input source is the command line, data from the command line is obtained. Obtaining the data from the command line may be performed via the extended type manager. Processing then continues to decision block .","At decision block , a determination is made whether there is another expected parameter. If there is another expected parameter, processing loops back to block  and proceeds as described above. Otherwise, processing is complete and returns.","Thus, as shown, cmdlets act as a template for shredding incoming data to obtain the expected parameters. In addition, the expected parameters are obtained without knowing the type of incoming object providing the value for the expected parameter. This is quite different than traditional administrative environments. Traditional administrative environments are tightly bound and require that the type of object be known at compile time. In addition, in traditional environments, the expected parameter would have been passed into the function by value or by reference. Thus, the present parsing (e.g., \u201cshredding\u201d) mechanism allows programmers to specify the type of parameter without requiring them to specifically know how the values for these parameters are obtained.","For example, given the following declaration for the cmdlet Foo:",{"@attributes":{"id":"p-0172","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Foo : Cmdlet"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003string Name;"]},{"entry":[{},"\u2003\u2003Bool Recurse;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The command line syntax may be any of the following:","$ Foo-Name: (string)-Recurse: True","$ Foo-Name<string>-Recurse True","$Foo-Name (string).","The set of rules may be modified by system administrators in order to yield a desired syntax. In addition, the parser may support multiple sets of rules, so that more than one syntax can be used by users. In essence, the grammar associated with the cmdlet structure (e.g., string Name and Bool Recurse) drives the parser.","In general, the parsing directives describe how the parameters entered as the command string should map to the expected parameters identified in the cmdlet object. The input parameter types are checked to determine whether correct. If the input parameter types are not correct, the input parameters may be coerced to become correct. If the input parameter types are not correct and can not be coerced, a usage error is printed. The usage error allows the user to become aware of the correct syntax that is expected. The usage error may obtain information describing the syntax from the Documentation Directives. Once the input parameter types have either been mapped or have been verified, the corresponding members in the cmdlet object instance are populated. As the members are populated, the extended type manager provides processing of the input parameter types. Briefly, the processing may include a property path mechanism, a key mechanism, a compare mechanism, a conversion mechanism, a globber mechanism, a relationship mechanism, and a property set mechanism. Each of these mechanisms is described in detail below in the section entitled \u201cExtended Type Manager Processing\u201d, which also includes illustrative examples.","Exemplary Process for Executing the Cmdlet","An exemplary process for executing a cmdlet is illustrated in  and is now described. In one exemplary administrative tool environment, the core engine executes the cmdlet. As mentioned above, the code  within the second method  is executed for each input object. Processing begins at block  where the cmdlet has already been populated. Processing continues at block .","At block , a statement from the code  is retrieved for execution. Processing continues at decision block .","At decision block , a determination is made whether a hook is included within the statement. Turning briefly to , the hook may include calling an API provided by the core engine. For example, statement  within the code  of cmdlet  in  calls the confirmprocessing API specifying the necessary parameters, a first string (e.g., \u201cPID=\u201d), and a parameter (e.g., PID). Turning back to , if the statement includes the hook, processing continues to block . Thus, if the instruction calling the confirmprocessing API is specified, the cmdlet operates in an alternate executing mode that is provided by the operating environment. Otherwise, processing continues at block  and execution continues in the \u201cnormal\u201d mode.","At block , the statement is processed. Processing then proceeds to decision block . At block , a determination is made whether the code includes another statement. If there is another statement, processing loops back to block  to get the next statement and proceeds as described above. Otherwise, processing continues to decision block .","At decision block , a determination is made whether there is another input object to process. If there is another input object, processing continues to block  where the cmdlet is populated with data from the next object. The population process described in  is performed with the next object. Processing then loops back to block  and proceeds as described above. Once us all the objects have been processed, the process for executing the cmdlet is complete and returns.","Returning back to decision block , if the statement includes the hook, processing continues to block . At block , the additional features provided by the administrative tool environment are processed. Processing continues at decision block  and continues as described above.","The additional processing performed within block  is now described in conjunction with the exemplary data structure  illustrated in . As explained above, within the command base class  there may be parameters declared that correspond to additional expected input parameters (e.g., a switch).","The switch includes a predetermined string, and when recognized, directs the core engine to provide additional functionality to the cmdlet. If the parameter verbose  is specified in the command input, verbose statements  are executed. The following is an example of a command line that includes the verbose switch:","$ get\/process|where \u201chan*-gt 500\u201d|stop\/process-verbose.","In general, when \u201c-verbose\u201d is specified within the command input, the core engine executes the command for each input object and forwards the actual command that was executed for each input object to the host program for display. The following is an example of output generated when the above command line is executed in the exemplary administrative tool environment:","$ stop\/process PID=15","$ stop\/process PID=33.","If the parameter whatif  is specified in the command input, whatif statements  are executed. The following is an example of a command line that includes the whatif switch:","$ get\/process|where \u201chan*-gt 500\u201d|stop\/process-whatif.","In general, when \u201c-whatif\u201d is specified, the core engine does not actually execute the code , but rather sends the commands that would have been executed to the host program for display. The following is an example of output generated when the above command line is executed in the administrative tool environment of the present invention:","#$ stop\/process PID=15","#$ stop\/process PID=33.","If the parameter confirm  is specified in the command input, confirm statements  are executed. The following is an example of a command line that includes the confirm switch:","$ get\/process|where \u201chan*-gt 500\u201d|stop\/process-confirm.","In general, when \u201c-confirm\u201d is specified, the core engine requests additional user input on whether to proceed with the command or not. The following is an example of output generated when the above command line is executed in the administrative tool environment of the present invention.","$ stop\/process PID 15","Y\/N Y","$ stop\/process PID 33","Y\/N N.","As described above, the exemplary data structure  may also include a security method  that determines whether the task being requested for execution should be allowed. In traditional administrative environments, each command is responsible for checking whether the person executing the command has sufficient privileges to perform the command. In order to perform this check, extensive code is needed to access information from several sources. Because of these complexities, many commands did not perform a security check. The inventors of the present administrative tool environment recognized that when the task is specified in the command input, the necessary information for performing the security check is available within the administrative tool environment. Therefore, the administrative tool framework performs the security check without requiring complex code from the tool developers. The security check may be performed for any cmdlet that defines the hook within its cmdlet. Alternatively, the hook may be an optional input parameter that can be specified in the command input, similar to the verbose parameter described above.","The security check is implemented to support roles based authentication, which is generally defined as a system of controlling which users have access to resources based on the role of the user. Thus, each role is assigned certain access rights to different resources. A user is then assigned to one or more roles. In general, roles based authentication focus on three items: principle, resource, and action. The principle identifies who requested the action to be performed on the resource.","The inventors of the present invention recognized that the cmdlet being requested corresponded to the action that was to be performed. In addition, the inventors appreciated that the owner of the process in which the administrative tool framework was executing corresponded to the principle. Further, the inventors appreciated that the resource is specified within the cmdlet. Therefore, because the administrative tool framework has access to these items, the inventors recognized that the security check could be performed from within the administrative tool framework without requiring tool developers to implement the security check.","The operation of the security check may be performed any time additional functionality is requested within the cmdlet by using the hook, such as the confirmprocessing API. Alternatively, security check may be performed by checking whether a security switch was entered on the command line, similar to verbose, whatif, and confirm. For either implementation, the checkSecurity method calls an API provided by a security process (not shown) that provides a set of APIs for determining who is allowed. The security process takes the information provided by the administrative tool framework and provides a result indicating whether the task may be completed. The administrative tool framework may then provide an error or just stop the execution of the task.","Thus, by providing the hook within the cmdlet, the developers may use additional processing provided by the administrative tool framework.","Exemplary Extended Type Manager Processing","As briefly mentioned above in conjunction with , the extended type manager may perform additional processing on objects that are supplied. The additional processing may be performed at the request of the parser , the script engine , or the pipeline processor . The additional processing includes a property path mechanism, a key mechanism, a compare mechanism, a conversion mechanism, a globber mechanism, a relationship mechanism, and a property set mechanism. Those skilled in the art will appreciate that the extended type manager may also be extended with other processing without departing from the scope of the claimed invention. Each of the additional processing mechanisms is now described.","First, the property path mechanism allows a string to navigate properties of objects. In current reflection systems, queries may query properties of an object. However, in the present extended type manager, a string may be specified that will provide a navigation path to successive properties of objects. The following is an illustrative syntax for the property path: P.P.P.P.","Each component (e.g., P, P, P, and P) comprises a string that may represent a property, a method with parameters, a method without parameters, a field, an XPATH, or the like. An XPATH specifies a query string to search for an element (e.g., \u201c\/FOO@=13\u201d). Within the string, a special character may be included to specifically indicate the type of component. If the string does not contain the special character, the extended type manager may perform a lookup to determine the type of component. For example, if component P is an object, the extended type manager may query whether P is a property of the object, a method on the object, a field of the object, or a property set. Once the extended type manager identifies the type for P, processing according to that type is performed. If the component is not one of the above types, the extended type manager may further query the extended sources to determine whether there is a conversion function to convert the type of P into the type of P. These and other lookups will now be described using illustrative command strings and showing the respective output.","The following is an illustrative string that includes a property path:","$ get\/process|\/where hand*-gt>500|format\/table name.toupper, ws.kb, exe*.ver*.description.tolower.trunc(30).","In the above illustrative string, there are three property paths: (1) \u201cname.toupper\u201d; (2) \u201cws.kb\u201d; and (3) \u201cexe*.ver*.description.tolower.trunc(30). Before describing these property paths, one should note that \u201cname\u201d, \u201cws\u201d, and \u201cexe\u201d specify the properties for the table. In addition, one should note that each of these properties is a direct property of the incoming object, originally generated by \u201cget\/process\u201d and then pipelined through the various cmdlets. Processing involved for each of the three property paths will now be described.","In the first property path (i.e., \u201cname.toupper\u201d), name is a direct property of the incoming object and is also an object itself. The extended type manager queries the system using the priority lookup described above to determine the type for toupper. The extended type manager discovers that toupper is not a property. However, toupper may be a method inherited by a string type to convert lower case letters to upper case letters within the string. Alternatively, the extended type manager may have queried the extended metadata to determine whether there is any third party code that can convert a name object to upper case. Upon finding the component type, processing is performed in accordance with that component type.","In the second property path (i.e., \u201cws.kb\u201d), \u201cws\u201d is a direct property of the incoming object and is also an object itself. The extended type manager determines that \u201cws\u201d is an integer. Then, the extended type manager queries whether kb is a property of an integer, whether kb is a method of an integer, and finally queries whether any code knows how to take an integer and convert the integer to a kb type. Third party code is registered to perform this conversion and the conversion is performed.","In the third property path (i.e., \u201cexe*.ver*.description.tolower.trunc(30)\u201d), there are several components. The first component (\u201cexe*\u201d) is a direct property of the incoming object and is also an object. Again, the extended type manager proceeds down the lookup query in order to process the second component (\u201cver*). The \u201cexe* object does not have a \u201cver*\u201d property or method, so the extend type manager queries the extended metadata to determine whether there is any code that is registered to convert an executable name into a version. For this example, such code exists. The code may take the executable name string and use it to open a file, then accesses the version block object, and return the description property (the third component (\u201cdescription\u201d) of the version block object. The extended type manager then performs this same lookup mechanism for the fourth component (\u201ctolower\u201d) and the fifth component (\u201ctrunc(40)\u201d). Thus, as illustrated, the extended type manager may perform quite elaborate processing on a command string without the administrator needing to write any specific code. Table 1 illustrates output generated for the illustrative string.",{"@attributes":{"id":"p-0217","num":"0216"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name.toupper","ws.kb","exe*.ver*.description.tolower.trunc(30)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ETCLIENT","29,964","etclient"]},{"entry":["CSRSS","\u20026,944"]},{"entry":["SVCHOST","28,944","generic host process for win32"]},{"entry":["OUTLOOK","18,556","office outlook"]},{"entry":["MSMSGS","13,248","messenger"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Another query mechanism  includes a key. The key identifies one or more properties that make an instance of the data type unique. For example, in a database, one column may be identified as the key which can uniquely identify each row (e.g., social security number). The key is stored within the type metadata  associated with the data type. This key may then be used by the extended type manager when processing objects of that data type. The data type may be an extended data type or an existing data type.","Another query mechanism  includes a compare mechanism. The compare mechanism compares two objects. If the two objects directly support the compare function, the directly supported compare function is executed. However, if neither object supports a compare function, the extended type manager may look in the type metadata for code that has been registered to support the compare between the two objects. An illustrative series of command line strings invoking the compare mechanism is shown below, along with corresponding output in Table 2.",{"@attributes":{"id":"p-0220","num":"0219"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"$ $a = $( get\/date )"},{"entry":"$ start\/sleep 5"},{"entry":"$ $b = $( get\/date"},{"entry":"compare\/time $a $b"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Ticks:","51196579"]},{"entry":[{},"Days:","0"]},{"entry":[{},"Hours:","0"]},{"entry":[{},"Milliseconds:","119"]},{"entry":[{},"Minutes:","0"]},{"entry":[{},"Seconds:","5"]},{"entry":[{},"TotalDays:","5.92552997685185E\u221205"]},{"entry":[{},"TotalHours:","0.00142212719444444"]},{"entry":[{},"TotalMilliseconds:","5119.6579"]},{"entry":[{},"TotalMinutes:","0.0853276316666667"]},{"entry":[{},"TotalSeconds:","5.1196579"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Compare\/time cmdlet is written to compare two datetime objects. In this case, the DateTime object supports the IComparable interface.","Another query mechanism  includes a conversion mechanism. The extended type manager allows code to be registered stating its ability to perform a specific conversion. Then, when an object of type A is input and a cmdlet specifies an object of type B, the extended type manager may perform the conversion using one of the registered conversions. The extended type manager may perform a series of conversions in order to coerce type A into type B. The property path described above (\u201cws.kb\u201d) illustrates a conversion mechanism.","Another query mechanism  includes a globber mechanism. A globber refers to a wild card character within a string. The globber mechanism inputs the string with the wild card character and produces a set of objects. The extended type manager allows code to be registered that specifies wildcard processing. The property path described above (\u201cexe*.ver*.description.tolower.trunc(30) ) illustrates the globber mechanism. A registered process may provide globbing for file names, file objects, incoming properties, and the like.","Another query mechanism  includes a property set mechanism. The property set mechanism allows a name to be defined for a set of properties. An administrator may then specify the name within the command string to obtain the set of properties. The property set may be defined in various ways. In one way, a predefined parameter, such as \u201c?\u201d, may be entered as an input parameter for a cmdlet. The operating environment upon recognizing the predefined parameter lists all the properties of the incoming object. The list may be a GUI that allows an administrator to easily check (e.g., \u201cclick on\u201d) the properties desired and name the property set. The property set information is then stored in the extended metadata. An illustrative string invoking the property set mechanism is shown below, along with corresponding output in Table 3:","$ get\/process|where han*-gt>500|format\/table config.","In this illustrative string, a property set named \u201cconfig\u201d has been defined to include a name property, a process id property (Pid), and a priority property. The output for the table is shown below.",{"@attributes":{"id":"p-0227","num":"0226"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","Pid Priority"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ETClient","\u20093528 Normal"]},{"entry":[{},"csrss","\u2002\u2009528 Normal"]},{"entry":[{},"svchost","\u2002\u2009848 Normal"]},{"entry":[{},"OUTLOOK","2,772 Normal"]},{"entry":[{},"msmsgs","2,584 Normal"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Another query mechanism  includes a relationship mechanism. In contrast to traditional type systems that support one relationship (i.e., inheritance), the relationship mechanism supports expressing more than one relationship between types. Again, these relationships are registered. The relationship may include finding items that the object consumes or finding the items that consume the object. The extended type manager may access ontologies that describe various relationships. Using the extended metadata and the code, a specification for accessing any ontology service, such as OWL, DAWL, and the like, may be described. The following is a portion of an illustrative string which utilizes the relationship mechanism: .OWL: \u201cstring\u201d.","The \u201cOWL\u201d identifier identifies the ontology service and the \u201cstring\u201d specifies the specific string within the ontology service. Thus, the extended type manager may access types supplied by ontology services.","Exemplary Process for Displaying Command Line Data","The present mechanism provides a data driven command line output. The formatting and outputting of the data is provided by one or more cmdlets in the pipeline of cmdlets. Typically, these cmdlets are included within the non-management cmdlets described in conjunction with  above. The cmdlets may include a format cmdlet, a markup cmdlet, a convert cmdlet, a transform cmdlet, and an out cmdlet.",{"@attributes":{"id":"p-0231","num":"0230"},"figref":"FIG. 19","b":["1901","1907","1901","1910","1910","1910","1910","1910","1910","1910","1910","1910"]},"Each host is responsible for supporting certain out cmdlets, such as out\/console. The host also supports any destination specific host cmdlet (e.g., out\/chart that directs output to a chart provided by a spreadsheet application). In addition, the host is responsible for providing default handling of results. The out cmdlet in this sequence may decide to implement its behavior by calling other output processing cmdlets (such as format\/markup\/convert\/transform). Thus, the out cmdlet may implicitly modify sequence  to any of the other sequences or may add its own additional format\/output cmdlets.","The second sequence  illustrates a format cmdlet  before the out cmdlet . For this sequence, the format cmdlet  accepts a stream of pipeline objects generated and processed by other cmdlets within the pipeline. In overview, the format cmdlet  provides a way to select display properties and a way to specify a page layout, such as shape, column widths, headers, footers, and the like. The shape may include a table, a wide list, a columnar list, and the like. In addition, the format cmdlet  may include computations of totals or sums. Exemplary processing performed by a format cmdlet  is described below in conjunction with . Briefly, the format cmdlet emits format objects, in addition to emitting pipeline objects. The format objects can be recognized downstream by an out cmdlet (e.g., out cmdlet  in sequence ) via the extended type manager or other mechanism. The out cmdlet  may choose to either use the emitted format objects or may choose to ignore them. The out cmdlet determines the page layout based on the page layout data specified in the display information. In certain instances, modifications to the page layout may be specified by the out cmdlet. In one exemplary process the out cmdlet may determine an unspecified column width by finding a maximum length for each property of a predetermined number of objects (e.g., 50) and setting the column width to the maximum length. The format objects include formatting information, header\/footer information, and the like.","The third sequence  illustrates a format cmdlet  before the out cmdlet . However, in the third sequence , a markup cmdlet  is pipelined between the format cmdlet  and the out cmdlet . The markup cmdlet  provides a mechanism for adding property annotation (e.g., font, color) to selected parameters. Thus, the markup cmdlet  appears before the output cmdlet . The property annotations may be implemented using a \u201cshadow property bag\u201d, or by adding property annotations in a custom namespace in a property bag. The markup cmdlet  may appear before the format cmdlet  as long as the markup annotations may be maintained during processing of the format cmdlet .","The fourth sequence  again illustrates a format cmdlet  before the out cmdlet . However, in the fourth sequence , a convert cmdlet  is pipelined between the format cmdlet  and the out cmdlet . The convert cmdlet  is also configured to process the format objects emitted by the format cmdlet . The convert cmdlet  converts the pipelined objects into a specific encoding based on the format objects. The convert cmdlet  is associated with the specific encoding. For example, the convert cmdlet  that converts the pipelined objects into Active Directory Objects (ADO) may be declared as \u201cconvert\/ADO\u201d on the command line. Likewise, the convert cmdlet  that converts the pipelined objects into comma separated values (csv) may be declared as \u201cconvert\/csv\u201d on the command line. Some of the convert cmdlets  (e.g., convert\/XML and convert\/html) may be blocking commands, meaning that all the pipelined objects are received before executing the conversion. Typically, the out cmdlet  may determine whether to use the formatting information provided by the format objects. However, when a convert cmdlet  appears before the out cmdlet , the actual data conversion has already occurred before the out cmdlet receives the objects. Therefore, in this situation, the out cmdlet can not ignore the conversion.","The fifth sequence  illustrates a format cmdlet , a markup cmdlet , a convert cmdlet , and an out cmdlet  in that order. Thus, this illustrates that the markup cmdlet  may occur before the convert cmdlet .","The sixth sequence  illustrates a format cmdlet , a specific convert cmdlet (e.g., convert\/xml cmdlet \u2032), a specific transform cmdlet (e.g., transform\/xslt cmdlet ), and an out cmdlet . The convert\/xml cmdlet \u2032 converts the pipelined objects into an extended markup language (XML) document. The transform\/xslt cmdlet  transforms the XML document into another XML document using an Extensible Style Language (XSL) style sheet. The transform process is commonly referred to as extensible style language transformation (XSLT), in which an XSL processor reads the XML document and follows the instructions within the XSL style sheet to create the new XML document.","The seventh sequence  illustrates a format cmdlet , a markup cmdlet , a specific convert cmdlet (e.g., convert\/xml cmdlet \u2032), a specific transform cmdlet (e.g., transform\/xslt cmdlet ), and an out cmdlet . Thus, the seventh sequence  illustrates having the markup cmdlet  upstream from the convert cmdlet and transform cmdlet.",{"@attributes":{"id":"p-0239","num":"0238"},"figref":"FIG. 20","b":["2000","2001","2002"]},"At block , a pipeline object is received as input to the format cmdlet. Processing continues at block .","At block , a query is initiated to identify a type for the pipelined object. This query is performed by the extended type manager as described above in conjunction with . Once the extended type manager has identified the type for the object, processing continues at block .","At block , the identified type is looked up in display information. An exemplary format for the display information is illustrated in  and will be described below. Processing continues at decision block .","At decision block , a determination is made whether the identified type is specified within the display information. If there is no entry within the display information for the identified type, processing is complete. Otherwise, processing continues at block .","At block , formatting information associated with the identified type is obtained from the display information. Processing continues at block .","At block , information is emitted on the pipeline. Once the information is emitted, the processing is complete.","Exemplary information that may be emitted is now described in further detail. The information may include formatting information, header\/footer information, and a group end\/begin signal object. The formatting information may include a shape, a label, numbering\/bullets, column widths, character encoding type, content font properties, page length, group-by-property name, and the like. Each of these may have additional specifications associated with it. For example, the shape may specify whether the shape is a table, a list, or the like. Labels may specify whether to use column headers, list labels, or the like. Character encoding may specify ASCII, UTF-8, Unicode, and the like. Content font properties may specify the font that is applied to the property values that are display. A default font property (e.g., Courier New, 10 point) may be used if content font properties are not specified.","The header\/footer information may include a header\/footer scope, font properties, title, subtitle, date, time, page numbering, separator, and the like. For example, the scope may specify a document, a page, a group, or the like. Additional properties may be specified for either the header or the footer. For example, for group and document footers, the additional properties may include properties or columns to calculate a sum\/total, object counts, label strings for totals and counts, and the like.","The group end\/begin signal objects are emitted when the format cmdlet detects that a group-by property has changed. When this occurs, the format cmdlet treats the stream of pipeline objects as previously sorted and does not re-sort them. The group end\/begin signal objects may be interspersed with the pipeline objects. Multiple group-by properties may be specified for nested sorting. The format cmdlet may also emit a format end object that includes final sums and totals.","Turning briefly to , an exemplary display information  is in a structured format and contains information (e.g., formatting information, header\/footer information, group-by properties or methods) associated with each object that has been defined. For example, the display information  may be XML-based. Each of the afore-mentioned properties may then be specified within the display information. The information within the display information  may be populated by the owner of the object type that is being entered. The operating environment provides certain APIs and cmdlets that allow the owner to update the display information by creating, deleting, and modifying entries.",{"@attributes":{"id":"p-0250","num":"0249"},"figref":["FIG. 22","FIG. 23"],"b":["2201","2213"]},"As described, the mechanism for providing data driven command line output may be employed in an administrative tool environment. However, those skilled in the art will appreciate that the mechanism may be employed in various environments that need to display results of pipelined commands. By using the output processing cmdlets in various pipeline sequences, command line users may generate robust and versatile displays with minimal code. In contrast, using traditional mechanisms, extensive code in the output command is needed. In addition, the extensive code may not be uniform with other code in other output commands. These and other limitations with the traditional mechanism for displaying results are overcome by the present mechanism for providing data driven command line output.","Although details of specific implementations and embodiments are described above, such details are intended to satisfy statutory disclosure obligations rather than to limit the scope of the following claims. Thus, the invention as defined by the claims is not limited to the specific features described above. Rather, the invention is claimed in any of its forms or modifications that fall within the proper scope of the appended claims, appropriately interpreted in accordance with the doctrine of equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 5","FIG. 2"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 7","FIG. 2"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 8","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 9","FIG. 2"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 12","FIG. 10"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 13","FIG. 2"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 14","FIG. 9"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 15","FIG. 14"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 16","FIG. 14"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 17","FIG. 14"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 18","FIG. 2"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 20","FIG. 19"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 21","FIG. 20"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 23"}]},"DETDESC":[{},{}]}
