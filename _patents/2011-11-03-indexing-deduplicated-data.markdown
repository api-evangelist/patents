---
title: Indexing deduplicated data
abstract: In general, in one aspect, a method for managing data in a data storage system includes receiving identifiers corresponding to different respective entries of a map stored in the data storage system, with a particular identifier corresponding to a particular entry of the map, the particular entry including a computed value corresponding to a particular portion of data stored in the data storage system and metadata indicating a location where the particular portion of data is stored in the data storage system, selecting, according to a first selection criterion, at least some of the identifiers for storage in a first portion of an index, and selecting, according to a second selection criterion, at least some of the identifiers for storage in a second portion of the index.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09069707&OS=09069707&RS=09069707
owner: Permabit Technology Corp.
number: 09069707
owner_city: Cambridge
owner_country: US
publication_date: 20111103
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DESCRIPTION"],"p":["This description relates to managing and indexing deduplicated data.","Some data storage systems are configured to include a deduplication function that is used to reduce the amount of storage capacity that is needed to store received data (e.g., data to be stored in the data storage system). In some implementations, deduplication works by segmenting received data into segments (also called \u201cchunks\u201d of data) that are identified in an index by a value, such as a cryptographic hash value. A form of data compression can be achieved by preventing duplicate segments from being stored when the data is being stored in the data storage system. For example, a given file (made up of one or more segments) that has already been stored (e.g., an email attachment attached to multiple emails in an email storage system) can simply be replaced with a reference to the previously stored file if the previously stored file has the same segments. Alternatively, a given segment within a given file that is the same as another segment in the given file or another file (e.g., a portion of document within a ZIP archive that is also stored in another ZIP archive) can be replaced with a reference to the duplicate segment.","In general, managing data in a data storage system, the method comprising receiving identifiers corresponding to different respective entries of a map, with a particular identifier corresponding to a particular entry of the map, the particular entry including a computed value corresponding to a particular portion of data stored in the data storage system and metadata indicating a location where the particular portion of data is stored in the data storage system; selecting, according to a first selection criterion, at least some of the identifiers for storage in a first portion of an index; and selecting, according to a second selection criterion, at least some of the identifiers for storage in a second portion of the index.","Implementations may include one or more of the following features.","The method includes generating at least some of the identifiers. The method includes storing identifiers in the first portion of the index until the first portion of the index reaches a predetermined size. The method includes determining that a first identifier corresponding to a first entry of the map, received after the first portion of the index reached the predetermined size, was not already stored in the first portion of the index before the first identifier was received, removing at least a second identifier corresponding to a second entry of the map from the first portion of the index, and storing the first identifier in the first portion of the index, such that the first portion of the index does not exceed the predetermined size. The method includes designating the second identifier for storage in the second portion of the index. The method includes accessing at least one of the identifiers stored in the first index and copying the entry of the map corresponding to the accessed identifier to a cache for recently accessed identifiers. Identifying at least one other entry of the map that was stored in the map at approximately the same time as the entry of the map corresponding to the first identifier, and copying the other entry of the map to the cache. The method includes accessing at least one of the identifiers stored in the index, and accessing an entry of the map corresponding to the accessed identifier from a cache for recently accessed identifiers. Accessing at least one other entry of the map in the cache, wherein the other entry of the map has no corresponding identifier stored in the index. Selecting at least some of the identifiers according to a first selection criterion comprises selecting at least some of the identifiers at a first sample rate. Selecting at least some of the identifiers according to a second selection criterion comprises selecting at least some of the identifiers at a second sample rate different from the first sampling rate. Identifiers selected at a first sample rate have been accessed more recently than the identifiers selected at a second sample rate, and the first sample rate is greater than the second sample rate. Selecting at least some of the identifiers according to a first selection criterion comprises selecting at least some of the identifiers from a first set of identifiers. Selecting at least some of the identifiers according to a second selection criterion comprises selecting at least some of the identifiers from the first set of identifiers. Selecting at least some of the identifiers according to a second selection criterion comprises selecting at least some of the identifiers from a second set of identifiers, wherein the second set includes no identifiers in the first set. Selecting at least some of the identifiers according to a second selection criterion comprises selecting at least some of the identifiers from a second set of identifiers, wherein the second set includes some identifiers in the first set. Selecting at least some of the identifiers according to a first selection criterion comprises stochastically selecting at least some of the identifiers based on at least a portion of a value associated with the respective identifier. The value associated with the respective identifier comprises the computed value corresponding to the particular portion of data corresponding to the respective identifier. Selecting at least some of the identifiers according to a first selection criterion comprises selecting a threshold number of most recently used identifiers, wherein the threshold number is a predetermined size of the first portion of the index.","In another aspect, a computer-readable storage medium stores a computer program for managing data in a data storage system. The computer program includes instructions for causing a computing system to: receive identifiers corresponding to different respective entries of a map, with a particular identifier corresponding to a particular entry of the map, the particular entry including a computed value corresponding to a particular portion of data stored in the data storage system and metadata indicating a location where the particular portion of data is stored in the data storage system; select, according to a first selection criterion, at least some of the identifiers for storage in a first portion of an index; and select, according to a second selection criterion, at least some of the identifiers for storage in a second portion of the index.","In another aspect, a system for managing data includes: a data storage system storing the data being managed; and a computing system configured to manage the data based on a map. The managing includes: receiving identifiers corresponding to different respective entries of the map, with a particular identifier corresponding to a particular entry of the map, the particular entry including a computed value corresponding to a particular portion of data stored in the data storage system and metadata indicating a location where the particular portion of data is stored in the data storage system; selecting, according to a first selection criterion, at least some of the identifiers for storage in a first portion of an index; and selecting, according to a second selection criterion, at least some of the identifiers for storage in a second portion of the index.","In another aspect, a method for managing data in a data storage system comprises receiving identifiers corresponding to different respective entries of a map, with a particular identifier corresponding to a particular entry of the map, the particular entry including a computed value corresponding to a particular portion of data stored in the data storage system and metadata indicating a location where the particular portion of data is stored in the data storage system; non-uniformly selecting at least some of the identifiers for storage in an index.","Implementations may also include one or more of the following features.","Non-uniformly selecting at least some of the identifiers for storage in an index comprises stochastically selecting at least some of the identifiers based on at least a portion of a value associated with the respective identifier. The value associated with the respective identifier comprises the computed value corresponding to the particular portion of data corresponding to the identifier. Non-uniformly selecting at least some of the identifiers for storage in an index comprises selecting at least some of the identifiers based on a first sample rate and selecting at least some of the identifiers according to a second sample rate.","Another aspect can include a method for managing data in a data storage system including receiving identifiers corresponding to different respective entries of a map, with a particular identifier corresponding to a particular entry of the map, the particular entry including a computed value corresponding to a particular portion of data stored in the data storage system and metadata indicating a location where the particular portion of data is stored in the data storage system, selecting a first set of the identifiers for storage in a first portion of an index, wherein the first set comprises most recently accessed identifiers, and selecting a second set of the identifiers for storage in a second portion of the index, wherein the second set comprises identifiers selected at a sample rate.","Another aspect can include a method for managing data in a data storage system including non-uniformly selecting a plurality of entries of a map, a particular entry including a computed value corresponding to a particular portion of data stored in the data storage system and metadata indicating a location where the particular portion of data is stored in the data storage system, generating identifiers each corresponding to a particular non-uniformly selected entry of the map, and storing the identifiers in an index.","Aspects can include one or more of the following features. Identifiers can be stored in an index using multiple selection criteria.","Other aspects and advantages will be apparent from the detailed description, drawings, appendices and claims.","There are a great many possible implementations of the invention, too many to describe herein. Some possible implementations that are presently preferred are described below. It cannot be emphasized too strongly, however, that these are descriptions of implementations of the invention, and not descriptions of the invention, which is not limited to the detailed implementations described in this section but is described in broader terms in the claims.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","102","104","104","106","106","104","108","104","110","108"]},"The deduplication engine  can be configured to provide a deduplication function for use by the data storage system . In some examples, the deduplication engine  may provide an application programming interface (API)  that includes various functions that can be called from within the software layer  of the data storage system . The software layer  can store new data in the media , in some examples taking into account advice returned as output of the functions of the API  about whether portions of the data have already been stored in the media , and if so where the portions are stored. In response to the deduplication advice indicating which new segments of data have duplicates that are already stored, the software layer  can determine whether to represent some of the new segments by referring to the previously stored duplicates instead of storing the new segments. In some examples, the deduplication engine  is integrated in a storage system in such a way that an API is optional or not used.","When deduplication advice is desired for new data, the software layer  provides the new data to the deduplication engine  by calling a function of the API . The function can be called at any of a variety of stages including: while the new data is being written to the media , or at any subsequent time as determined by the software layer . Along with the new data, the software layer  can provide other input to the function such as application-specific metadata. For example, location information can be provided that describes where the new data is located (e.g., in a temporary storage location within the media  or other storage media) in the system  or an external location. The software layer  is also able to improve the accuracy of the advice from the deduplication engine  by calling functions of the API  to update the index when data is deleted or modified. In some implementations, the software layer  may also provide a sequence number along with the application specific metadata to the function. The software layer  can use the sequence number to quickly verify whether or not the deduplication advice is valid. If the location information has changed since the last time the software layer  queried the deduplication engine , then the sequence number will indicate that the deduplication advice is outdated.","In some implementations, the deduplication advice can be used by a remote user or client of a data storage system  to determine if a data segment needs to be transmitted over a network. For example, if the data segment is a duplicate of an existing copy of the segment, then the existing copy of the segment can be referenced instead thus saving network capacity and possibly also storage capacity.","The deduplication engine  includes a segmentation and index management module  that performs various actions to handle calls to the functions of the API . The module  segments the new data into fixed- or variable-length segments, optionally taking into account characteristics of the new data to determine appropriate boundaries for the segments. For example, duplicate data may occur in files having different block alignments, such as when a file appears within two ZIP archives at different locations relative to the start of the archive. Content-aware segmentation enables the embedded file to be located and deduplicated even if the file appears at different offsets in the two archives.","The module  computes fingerprints as identifiers corresponding to different respective segments. In some implementations, the module  computes hash values that uniquely identify different respective segments, and includes the entire hash value or a shorter portion of the hash value or a shorter computed value based on the hash value in the fingerprint. In some implementations, the module  uses SHA-256 cryptographic hashing algorithm designed by the National Security Agency to compute the hash values for the respective segments. For example, techniques for using abbreviated values for the fingerprint are described in U.S. Pat. No. 7,457,800, and U.S. Pat. No. 7,457,813, each of which is incorporated herein by reference.","In some implementations, the fingerprint also includes a domain tag representing a domain in which one or more segments are being stored and managed. For example, the domain tag can corresponds to a section of a file system in which the one or more segments are being stored, a portion of a storage medium including, for example, any of the following: a disk or disk volume (e.g., identified by a logical unit number (LUN)), a data protected set of disks, a storage device, or a cluster of storage devices). The inclusion of the domain tag in the fingerprint enables the system  to distinguish between different segments that may have identical content (and therefore identical hash values) but are stored in different media and\/or file systems, where it may be difficult to create references to between data stored in those different media and\/or file systems.","The deduplication engine  stores the fingerprints in an index that includes multiple entries, each entry storing one of the fingerprints. Each entry stores a reference to the segment corresponding to the fingerprint stored in the entry.","In some implementations, different data segments may need to be indexed in the same index without being deduplicated across the segments. By way of example, a service provider may have two customer volumes on the same underlying media, but data cannot be shared between volumes. To address this situation, the index may support the creation of a domain identifier or tag (e.g., a namespace) to be associated with each segment (e.g., Client1 and Client2). The data segment associated with the first domain, e.g., Client1, will not deduplicate with the data segment associated with the second domain, e.g. Client2.","When a duplicate segment is identified, a duplicate data advisory can be sent to the software layer . In some implementations, the advisory can be synchronously sent via a function return. In some implementations, the advisory can be asynchronously sent via a previously registered callback function. The advisory provides metadata necessary for the software layer  to determine the duplicate information. For example, the metadata can include a location of the duplicate data and possibly a sequence number, each corresponding to the new segment and the previously stored segment. In some examples, the software layer  may notify the deduplication engine  that the advice is outdated (e.g., based on sequence numbers described above). In such instances, the deduplication engine  updates its index to remove the outdated information. In some examples, the software layer  can unify data extents within the file system specific to the software layer  based on the advice.","When a duplicate segment is identified, a reference to the segment can also be stored in a data structure that is separate from the index. In some implementations, the data storage system  stores a reference to the location of a duplicate segment using a data structure that is independent of the deduplication engine , such as a data structure in the file system inode structure of the media , where the data structure is able to point directly to the location where the duplicate data is stored on the media  (e.g., a location on a disk). This can provide the advantage of the data storage system  being able to operate independently of the deduplication engine , without the need to rely on the index to access files that include segments that are references to duplicate segments from other files or locations within the same file. In such implementations, the deduplication engine  does not become critical to the reliability and availability of the data storage system  for data retrieval.","In alternative implementations, the data storage system  only stores the fingerprint value for the duplicate segment. In such implementations, the data storage system  would have to query the deduplication engine  as to where the referenced segment was located, and the deduplication engine  would become critical to the operation of the data storage system .","The index can be managed such that the size of the index does not exceed a predetermined maximum size. This enables the deduplication engine  to limit the amount of storage space required for the index. The deduplication engine  provides deduplication advice for data that falls within a deduplication window corresponding to the most recently \u201cseen\u201d segments in order of how recently they have been seen (e.g., accessed or used). In some implementations, the index can include an on-disk volume for recording names corresponding to the data segments. Using this on-disk volume, the deduplication engine  is able to determine the deduplication window for which the engine  provides deduplication advice. In some implementations, a sampling technique is used to choose the entries that appear in the index. Sampling is discussed in greater detail below. In some implementations, the index contains identifiers corresponding to entries of a map, and entries of the map correspond to segments of a storage medium.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 1"],"b":["204","210","210","214","214","202","202","110","210","210","204","214","214","202","210","210","214","214","214","214","202","214","214"],"i":["a","b ","a","b ","a","b ","a","b ","a","b ","a","b ","a","b ","a","b. "]},"An index  stores identifiers , corresponding to entries of the map. An identifier can be used to determine if the corresponding entry is stored in the map . Put another way, each identifier represents a corresponding entry . For example, the identifiers , can contain a computed value corresponding to data stored in a segment of the storage medium . In some examples, the computed value contained in an identifier may be the same as the computed value contained in the corresponding entry of the map . In some examples, the computed value contained in an identifier may be different from the computed value contained in the corresponding entry of the map . For example, the computed value contained in an identifier may have been generated by a hash function that generates values of a first size, and the computed value contained in the corresponding entry of the map  may have been generated by a hash function that generates values of a second size. The identifiers , can also contain metadata identifying the corresponding entry of the map . For example, the identifier can also contain the location of a portion of the map  that contains the corresponding entry of the map  along with other map entries that were recorded or stored at approximately the same time.","In some implementations, the identifiers can be generated when the index  is generated. In some implementations, the identifiers are chosen from an existing set of identifiers. For example, the index  changes as the deduplication system is used, and some identifiers are discarded over time, while others are chosen to remain in the index . When the deduplication system is said to have selected or chosen identifiers for storage in the index , the identifiers can be existing identifiers that remain in the index or are moved to a different section or portion of the index, or the identifiers can be newly-generated identifiers, or any combination of these things.","In some examples, all of the entries , of the map  have a corresponding identifier , in the index . In some examples, some of the entries of the map  have corresponding identifiers , while other entries have no corresponding identifier in the index . For example, the identifiers , chosen for storage in the index  can be chosen based on a sampling criterion. When a sampling criterion is used, a subset (sample) of the entries of the map  are chosen to have corresponding identifiers , and the remaining entries of the map  have no corresponding identifier. A set of identifiers is said to be sampled if the identifiers only represent a subset (sample) of a particular group of entries of the map . By storing in the index  a subset of fewer than all entries of the map  in the index , the index  can be stored in a relatively smaller and\/or faster storage medium (e.g., with some or all of the index  being stored in volatile memory), while the map  can be stored in a relatively larger and\/or slower storage medium (e.g., with some or all of the map  being stored in non-volatile memory).","In some examples, identifiers are chosen for corresponding entries of the map  according to a sample rate. For example, a percentage (e.g., 1% or 10% or 50%) of the entries can be chosen to have a corresponding identifier . Put another way, identifiers are chosen to represent a sample of the entries . In some implementations, the identifiers are chosen uniformly. For example, if identifiers are chosen to represent 10% of the entries of the map, then every tenth entry can be chosen to be represented by an identifier . In some examples, identifiers are chosen non-uniformly. For example, a stochastic process can be used to determine which entries will be represented by identifiers . When a stochastic process is used, the identifiers represent a random or non-deterministically selected sample of the entries . In some implementations, the deduplication system can choose identifiers based on a value associated with the identifier. For example, the deduplication system can examine data contained in the identifier or data contained in an entry associated with the identifier . If 50% of the identifiers , are to be sampled, then the deduplication system can choose identifiers having a \u201c1\u201d as the first bit of a data value contained in the identifier , and discard identifiers having a \u201c0\u201d as the first bit of a data value contained in the identifier . In this way, because the distribution of \u201c1\u201d bits and \u201c0\u201d bits will be non-uniform among the identifiers , , the selected identifiers , will have been selected non-uniformly by the deduplication system.","In some implementations, the deduplication system has a cache  that contains a collection  of entries. The cache  can be accessed more quickly than the map . For example, the cache  may reside in memory that operates faster than memory in which the map  resides. When the deduplication system accesses an entry, the deduplication system can first determine if the entry can be accessed in the cache , and if so, avoid accessing the map . In some implementations, when an entry is accessed in the map , the entry can be copied to the cache  (e.g., replacing a different entry stored in the cache  less recently). The entry can then be accessed again in the cache  (rather than the map ) before it is removed from the cache (e.g., replaced by another entry).","In some implementations, the deduplication system sometimes stores multiple entries , that reference segments , of the storage medium  that are related. For example, the segments , may contain data representing portions of the same data file. In this example, if the segments , are stored at approximately the same time (e.g., relatively close times to each other within a second or within a few seconds or minutes), the deduplication system may also store entries , referencing the segments , at relatively close times to each other (e.g., when the deduplication system becomes aware of the segments , ). Further, the deduplication system may store the entries , in close proximity to each other. For example, the entries , may be stored adjacent to each other in the map  (e.g., at sequential addresses within the map ). When one entry is accessed, an entry related to the first entry is likely to be accessed shortly thereafter, for example, if the entries , reference segments , containing data of a single data file.","Because related entries , may be stored in close proximity to each other in the map , when one entry is stored in the cache , other entries stored in close proximity to the first entry can be stored in the cache  during the same cache loading operation. For example, for every entry that the deduplication system stores in the cache, the deduplication system can store the most proximate other entries (e.g., five other entries or twenty other entries or another number of entries) in the same operation. In this way, if the first entry is accessed, other entries that are likely to be related, and thus also likely to be accessed shortly thereafter, will already be present in the cache .","In some implementations, the index  contains multiple index portions , , . Each index portion can contain identifiers , chosen according to different criteria. In some examples, each index portion , , corresponds to a particular category of entries , of the map . For example, one index portion can contain identifiers corresponding to the most recently accessed entries , of the map . In some examples, each index portion , , contains identifiers chosen according to different selection criteria. For example, one index portion can contain identifiers selected according to a first sample rate (e.g., 10% of the corresponding entries of the map ), and another index portion can contain identifiers selected according to a second sample rate (e.g., 1% of the corresponding entries of the map ). In some examples, one index portion can contain identifiers sampled uniformly, and another index portion can contain identifiers sampled non-uniformly (e.g., by a stochastic process).",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["302","54","72","54","72","302","302"]},"Identifiers corresponding to the entries can be stored in an index. In the example shown in the figure, the index is represented by three index portions , , . Each index portion , ,  can store identifiers selected according to different criteria. In some examples, each of the index portions , ,  can store identifiers corresponding to entries of the map stored or accessed at different times or stored in different portions of the map. In some examples, each of the index portions , ,  can store identifiers selected according to different sample rates.","In the example shown, the first index portion  stores identifiers  corresponding to the most recently accessed entries of the map . In this example, the identifiers  represent entries numbered  to . Further, identifiers corresponding to all of the entries within that range are included in the index portion . Put another way, this index portion  has a sampling rate of 100%. In some examples, the index portion  storing the most recently used identifiers can have a predetermined size that corresponds to a threshold number of recently used identifiers.","The other index portions ,  store less recently accessed entries of the map . In this example, one of the index portions  stores identifiers  representing the entries numbered  to . Another of the index portions  stores identifiers  representing the entries numbered greater than or equal to 67. Each of these two index portions ,  can have their own respective sampling rates. For example, one index portion  may have a sampling rate of 50%, so that the identifiers  represent only half of the entries of the map  for which this index portion  stores identifiers. Another index portion  may have a sampling rate of 10%, so that the identifiers  represent only a tenth of the entries of the map  for which this index portion  stores identifiers. Further, the index portions ,  may contain identifiers ,  chosen uniformly or non-uniformly. For example, the identifiers  in one index portion  may be chosen uniformly such that every other entry has a corresponding identifier  in the index portion . For example, the identifiers  in another index portion  may be chosen non-uniformly such that identifiers  in the index portion  are chosen according to a stochastic process.","In this example, there is no overlap between identifiers stored in one of the index portions , ,  and identifiers stored in another of the index portions , , . In some implementations, an identifier corresponding to a particular entry of the map  can be stored in more than one index portion , , .","Because multiple index portions , ,  are used, the deduplication system can store identifiers in a way that maximizes the use of available storage space. For example, the most recently accessed (or most recently stored) identifiers (e.g., corresponding to the most recently accessed entries of the map ) are more likely to be accessed again than identifiers accessed less recently. One of the index portions  can be dedicated to storing the most recently accessed identifiers. For example, the index portion  can store identifiers corresponding to all of the most recently accessed entries of the map , so that all of the most recently accessed entries of the map  can be accessed by way of an identifier. Further, the other index portions ,  can store less recently accessed identifiers according to a sampling technique. For example, one index portion  can store identifiers  sampled at a rate of 50%. If this index portion  is the same size (e.g., stores the same number of identifiers) as the index portion  for most recently accessed identifiers, then this index portion  can store identifiers representing a portion of the map  twice as large as the index portion  for most recently accessed identifiers. Although some entries of the map  do not have a corresponding identifier in the index portion , the entries of the map  that do not have a corresponding identifier are less likely to be accessed than the entries of the map  having an identifier stored in the index portion  for most recently accessed identifiers.","The index portion  storing identifiers  accessed even less recently than the identifiers stored in the other index portions ,  can be sampled at a lower rate than the other index portions , . Because these identifiers  have been least recently accessed, it is less likely that any particular identifier in this index portion  will be accessed. Thus, there will be relatively few times that the deduplication system will attempt to access an identifier for an entry of the map  having no identifier stored in the index.","As the deduplication system stores and accesses identifiers, the identifiers that have been accessed most recently can change. The deduplication system can add and remove identifiers from the index portions , ,  over time. For example, if one identifier stored in the index portion  for recently accessed identifiers has not been accessed recently, the deduplication system can remove the identifier from that index portion . For example, this can be done to free up space in the index portion  for another identifier that has been accessed more recently, so that the index portion  does not exceed a predetermined number of identifiers or another predetermined size. The deduplication system can then move the identifier to another index portion  containing less recently used identifiers. The identifier may also be discarded depending on the sampling rate of the other index portion . For example, if the other index portion  has a sampling rate of 50%, the identifier may be discarded instead of moved if it is among the 50% of identifiers that are not sampled for storage in the index portion .","In some examples, an identifier that was not accessed recently is accessed again. For example, the data deduplication system may access an identifier stored in an index portion  containing less recently accessed identifiers (e.g., to access an entry of the map  corresponding to the identifier). When this occurs, in some implementations the data deduplication system can remove the identifier from the index portion  containing less recently accessed identifiers and store the identifier in the index portion  for recently accessed identifiers.","In use, the deduplication system may access an entry of the map  by first accessing an identifier corresponding to the entry. For example, the deduplication may access entry number  by accessing an identifier  corresponding to entry number . The identifier  corresponding to entry number  includes a pointer to the entry, so that the deduplication system can locate entry number  using the pointer included in the identifier . In some implementations, the deduplication system then copies entry number  to a cache , and also copies other entries  stored in proximity to entry number  to the cache. As described herein, entries stored in proximity to each other are likely to be accessed at about the same time. Thus, if the deduplication system then attempts to access the other entries , the deduplication system can access those entries in the cache  rather than access them in the map .  shows an example map entry . For example, the map entry  can include a key portion  and a value portion , each of a predetermined length (e.g., 32 bytes each for a total of 64 bytes). The key portion  is a computed value corresponding to a particular portion of data. In some implementations, the key portion  can include a key representing a result of a hash function operating on the contents of a data segment. For example, the hash function can be based on the SHA-256 cryptographic hash described above. In some examples, the key can include the hash value in combination with a domain identifier (e.g., a namespace). For example, the hash value and the domain identifier can be combined based on one of the following expressions:\n\nKey=XOR(hash,SHA256(domain identifier))\n\nKey=SHA256(hash,domain identifier)\n","In some implementations, the value portion  can be application-provided metadata describing a data segment. For example, the value portion  can include an address in the storage medium corresponding to a location where the data segment is stored. In some examples, the value portion  can also include other metadata, such as, a sequence number and\/or a transaction identifier, which may be used to validate the deduplication advice.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 5","b":["500","500","502","504","506","500","502","504","506"]},"The techniques described above can be implemented using software for execution on a computer system. For instance, the software defines procedures in one or more computer programs that execute on one or more programmed or programmable computer systems (e.g., desktop, distributed, client\/server computer systems) each including at least one processor, at least one data storage system (e.g., including volatile and non-volatile memory and\/or storage elements), at least one input device (e.g., keyboard and mouse) or port, and at least one output device (e.g., monitor) or port. The software may form one or more modules of a larger program.","The software may be provided on a computer-readable storage medium, such as a CD-ROM, readable by a general or special purpose programmable computer or delivered over a communication medium (e.g., encoded in a propagated signal) such as a network to a computer where it is executed. Each such computer program is preferably stored on or downloaded to a storage medium (e.g., solid state memory or media, or magnetic or optical media) readable by a general or special purpose programmable computer, for configuring and operating the computer system when the storage medium is read by the computer system to perform the procedures of the software.","Many other implementations of the invention other than those described above are within the invention, which is defined by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
