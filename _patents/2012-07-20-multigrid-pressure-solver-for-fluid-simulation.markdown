---
title: Multigrid pressure solver for fluid simulation
abstract: One embodiment of the present invention sets forth multigrid generation technique which enables accurate simulations of large scale three dimensional (3D) fluid volumes. A model of the fluid to be simulated is represented using a cell grid. The generated multigrid provides a hierarchy of increasingly coarser representations of the model that are used by a pressure solver. Eulerian simulation techniques require solving a linear system to determine pressure values for each cell within the cell grid. Different levels of the multigrid are then used to compute the pressure values for different regions of the model, maintaining accuracy near the surface of the fluid while simplifying the computations. The accurate pressure values ensure that the simulation produces detailed features of the water movement. Additionally, the multigrid pressure solver may be optimized for execution by a graphics processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09087411&OS=09087411&RS=09087411
owner: NVIDIA CORPORATION
number: 09087411
owner_city: Santa Clara
owner_country: US
publication_date: 20120720
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","DESCRIPTION OF THE RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","System Overview","Processing Cluster Array Overview","Graphics Pipeline Architecture","Real-Time Eulerian Water Simulation Using a Restricted Tall Cell Grid","Generating a Multigrid and a Pressure Solver for Fluid Simulation"],"p":["This application claims benefit of U.S. provisional patent application Ser. No. 61\/515,286 filed Aug. 4, 2011, and titled \u201cREAL-TIME EULERIAN WATER SIMULATION USING A RESTRICTED TALL CELL GRID.\u201d The subject material of this related application is hereby incorporated herein by reference.","The present invention generally relates to free surface water simulation and more specifically to a multigrid pressure solver for fluid simulation.","Grid-based (Eulerian) and particle-based (Lagrangian) simulation techniques are used to generate special effects involving fluids (liquids and gases) in feature films and commercials. Conventional techniques employed for free surface water simulations are limited to off-line computation due to the complexity of the models and the simulation performance needs. Real-time performance for free surface water simulations is desired for real-time applications such as computer game applications.","Traditionally the free surface water is modeled using three-dimensions to capture details of the water movement. The number of dimensions of the models may be reduced from three to two-and-a half dimensions, representing the water surface as a height field, to reduce the complexity of the models and increase computation speed for real-time simulation. However, interesting features produced from simulation of a full three-dimensional model, such as splashes and overturning waves are lost because the two-and-a-half dimensional representation cannot capture details of the water movement.","In order to satisfy the needs of computer game applications, the details of the water movement must be retained and real-time simulation performance is needed to allow for user interaction.","Accordingly, what is needed in the art is an approach that reduces the complexity of a water model to enable real-time free surface water simulation while also producing detailed water movement.","One embodiment of the present invention sets forth a system and method for generating a multigrid for fluid simulation. The method includes obtaining first level-set field values for a three-dimensional model of a fluid volume represented as a first two-dimensional grid of columns, where each column within the first two-dimensional grid comprises one or more regular cubic cells. The first level-set field values are downsampled to generate second level-set field values for a second two-dimensional grid of columns that represents the three-dimensional model of the fluid volume and is coarser than the first two-dimensional grid of columns, where the downsampling increases the likelihood that air bubbles will persist in the second two-dimensional grid of columns. The second level-set field values are downsampled to generate third level-set field values for a third two-dimensional grid of columns that represents the three-dimensional model of the fluid volume and is coarser than the first two-dimensional grid of columns and the second two-dimensional grid of columns, where the downsampling increases the likelihood that air bubbles will not persist in the third two-dimensional grid of columns.","One advantage of the technique is that free surface water simulations may be performed in real-time and also produce detailed water movement. The multigrid provides a hierarchy of increasingly coarser representations of a model of the water. Different levels of the multigrid are used to compute the pressure values for different regions of the model, maintaining accuracy while simplifying the computations for real-time execution. The accurate pressure values ensure simulation results that retain detailed features of the water movement.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the present invention. However, it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the present invention.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","105","105","106","107","107","108","102","106","105","112","105","113","112","110","114","107","116","107","118","120","121","107"]},"In one embodiment, the parallel processing subsystem  incorporates circuitry optimized for graphics and video processing, including, for example, video output circuitry, and constitutes a graphics processing unit (GPU). In another embodiment, the parallel processing subsystem  incorporates circuitry optimized for general purpose processing, while preserving the underlying computational architecture, described in greater detail herein. In yet another embodiment, the parallel processing subsystem  may be integrated with one or more other system elements, such as the memory bridge , CPU , and I\/O bridge  to form a system on chip (SoC).","It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology, including the number and arrangement of bridges, the number of CPUs , and the number of parallel processing subsystems , may be modified as desired. For instance, in some embodiments, system memory  is connected to CPU  directly rather than through a bridge, and other devices communicate with system memory  via memory bridge  and CPU . In other alternative topologies, parallel processing subsystem  is connected to I\/O bridge  or directly to CPU , rather than to memory bridge . In still other embodiments, I\/O bridge  and memory bridge  might be integrated into a single chip. Large embodiments may include two or more CPUs  and two or more parallel processing systems . The particular components shown herein are optional; for instance, any number of add-in cards or peripheral devices might be supported. In some embodiments, switch  is eliminated, and network adapter  and add-in cards ,  connect directly to I\/O bridge .",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["112","112","202","204","202","204"]},"Referring again to , in some embodiments, some or all of PPUs  in parallel processing subsystem  are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU  and\/or system memory  via memory bridge  and bus , interacting with local parallel processing memory  (which can be used as graphics memory including, e.g., a conventional frame buffer) to store and update pixel data, delivering pixel data to display device , and the like. In some embodiments, parallel processing subsystem  may include one or more PPUs  that operate as graphics processors and one or more other PPUs  that are used for general-purpose computations. The PPUs may be identical or different, and each PPU may have its own dedicated parallel processing memory device(s) or no dedicated parallel processing memory device(s). One or more PPUs  may output data to display device  or each PPU  may output data to one or more display devices .","In operation, CPU  is the master processor of computer system , controlling and coordinating operations of other system components. In particular, CPU  issues commands that control the operation of PPUs . In some embodiments, CPU  writes a stream of commands for each PPU  to a pushbuffer (not explicitly shown in either  or ) that may be located in system memory , parallel processing memory , or another storage location accessible to both CPU  and PPU . PPU  reads the command stream from the pushbuffer and then executes commands asynchronously relative to the operation of CPU .","Referring back now to , each PPU  includes an I\/O (input\/output) unit  that communicates with the rest of computer system  via communication path , which connects to memory bridge  (or, in one alternative embodiment, directly to CPU ). The connection of PPU  to the rest of computer system  may also be varied. In some embodiments, parallel processing subsystem  is implemented as an add-in card that can be inserted into an expansion slot of computer system . In other embodiments, a PPU  can be integrated on a single chip with a bus bridge, such as memory bridge  or I\/O bridge . In still other embodiments, some or all elements of PPU  may be integrated on a single chip with CPU .","In one embodiment, communication path  is a PCI-EXPRESS link, in which dedicated lanes are allocated to each PPU , as is known in the art. Other communication paths may also be used. An I\/O unit  generates packets (or other signals) for transmission on communication path  and also receives all incoming packets (or other signals) from communication path , directing the incoming packets to appropriate components of PPU . For example, commands related to processing tasks may be directed to a host interface , while commands related to memory operations (e.g., reading from or writing to parallel processing memory ) may be directed to a memory crossbar unit . Host interface  reads each pushbuffer and outputs the work specified by the pushbuffer to a front end .","Each PPU  advantageously implements a highly parallel processing architecture. As shown in detail, PPU () includes a processing cluster array  that includes a number C of general processing clusters (GPCs) , where C\u22671. Each GPC  is capable of executing a large number (e.g., hundreds or thousands) of threads concurrently, where each thread is an instance of a program. In various applications, different GPCs  may be allocated for processing different types of programs or for performing different types of computations. For example, in a graphics application, a first set of GPCs  may be allocated to perform patch tessellation operations and to produce primitive topologies for patches, and a second set of GPCs  may be allocated to perform tessellation shading to evaluate patch parameters for the primitive topologies and to determine vertex positions and other per-vertex attributes. The allocation of GPCs  may vary dependent on the workload arising for each type of program or computation.","GPCs  receive processing tasks to be executed via a work distribution unit , which receives commands defining processing tasks from front end unit . Processing tasks include indices of data to be processed, e.g., surface (patch) data, primitive data, vertex data, and\/or pixel data, as well as state parameters and commands defining how the data is to be processed (e.g., what program is to be executed). Work distribution unit  may be configured to fetch the indices corresponding to the tasks, or work distribution unit  may receive the indices from front end . Front end  ensures that GPCs  are configured to a valid state before the processing specified by the pushbuffers is initiated.","When PPU  is used for graphics processing, for example, the processing workload for each patch is divided into approximately equal sized tasks to enable distribution of the tessellation processing to multiple GPCs . A work distribution unit  may be configured to produce tasks at a frequency capable of providing tasks to multiple GPCs  for processing. By contrast, in conventional systems, processing is typically performed by a single processing engine, while the other processing engines remain idle, waiting for the single processing engine to complete its tasks before beginning their processing tasks. In some embodiments of the present invention, portions of GPCs  are configured to perform different types of processing. For example a first portion may be configured to perform vertex shading and topology generation, a second portion may be configured to perform tessellation and geometry shading, and a third portion may be configured to perform pixel shading in pixel space to produce a rendered image. Intermediate data produced by GPCs  may be stored in buffers to allow the intermediate data to be transmitted between GPCs  for further processing.","Memory interface  includes a number D of partition units  that are each directly coupled to a portion of parallel processing memory , where D\u22671. As shown, the number of partition units  generally equals the number of DRAM . In other embodiments, the number of partition units  may not equal the number of memory devices. Persons skilled in the art will appreciate that DRAM  may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets, such as frame buffers or texture maps may be stored across DRAMs , allowing partition units  to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .","Any one of GPCs  may process data to be written to any of the DRAMs  within parallel processing memory . Crossbar unit  is configured to route the output of each GPC  to the input of any partition unit  or to another GPC  for further processing. GPCs  communicate with memory interface  through crossbar unit  to read from or write to various external memory devices. In one embodiment, crossbar unit  has a connection to memory interface  to communicate with I\/O unit , as well as a connection to local parallel processing memory , thereby enabling the processing cores within the different GPCs  to communicate with system memory  or other memory that is not local to PPU . In the embodiment shown in , crossbar unit  is directly connected with I\/O unit . Crossbar unit  may use virtual channels to separate traffic streams between the GPCs  and partition units .","Again, GPCs  can be programmed to execute processing tasks relating to a wide variety of applications, including but not limited to, linear and nonlinear data transforms, filtering of video and\/or audio data, modeling operations (e.g., applying laws of physics to determine position, velocity and other attributes of objects), image rendering operations (e.g., tessellation shader, vertex shader, geometry shader, and\/or pixel shader programs), and so on. PPUs  may transfer data from system memory  and\/or local parallel processing memories  into internal (on-chip) memory, process the data, and write result data back to system memory  and\/or local parallel processing memories , where such data can be accessed by other system components, including CPU  or another parallel processing subsystem .","A PPU  may be provided with any amount of local parallel processing memory , including no local memory, and may use local memory and system memory in any combination. For instance, a PPU  can be a graphics processor in a unified memory architecture (UMA) embodiment. In such embodiments, little or no dedicated graphics (parallel processing) memory would be provided, and PPU  would use system memory exclusively or almost exclusively. In UMA embodiments, a PPU  may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high-speed link (e.g., PCI-EXPRESS) connecting the PPU  to system memory via a bridge chip or other communication means.","As noted above, any number of PPUs  can be included in a parallel processing subsystem . For instance, multiple PPUs  can be provided on a single add-in card, or multiple add-in cards can be connected to communication path , or one or more of PPUs  can be integrated into a bridge chip. PPUs  in a multi-PPU system may be identical to or different from one another. For instance, different PPUs  might have different numbers of processing cores, different amounts of local parallel processing memory, and so on. Where multiple PPUs  are present, those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs  may be implemented in a variety of configurations and form factors, including desktop, laptop, or handheld personal computers, servers, workstations, game consoles, embedded systems, and the like.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 3A","FIG. 2B"],"b":["208","202","208","208"]},"Operation of GPC  is advantageously controlled via a pipeline manager  that distributes processing tasks to streaming multiprocessors (SPMs) . Pipeline manager  may also be configured to control a work distribution crossbar  by specifying destinations for processed data output by SPMs .","In one embodiment, each GPC  includes a number M of SPMs , where M\u22671, each SPM  configured to process one or more thread groups. Also, each SPM  advantageously includes an identical set of functional execution units (e.g., execution units and load-store units\u2014shown as Exec units  and LSUs  in ) that may be pipelined, allowing a new instruction to be issued before a previous instruction has finished, as is known in the art. Any combination of functional execution units may be provided. In one embodiment, the functional units support a variety of operations including integer and floating point arithmetic (e.g., addition and multiplication), comparison operations, Boolean operations (AND, OR, XOR), bit-shifting, and computation of various algebraic functions (e.g., planar interpolation, trigonometric, exponential, and logarithmic functions, etc.); and the same functional-unit hardware can be leveraged to perform different operations.","The series of instructions transmitted to a particular GPC  constitutes a thread, as previously defined herein, and the collection of a certain number of concurrently executing threads across the parallel processing engines (not shown) within an SPM  is referred to herein as a \u201cwarp\u201d or \u201cthread group.\u201d As used herein, a \u201cthread group\u201d refers to a group of threads concurrently executing the same program on different input data, with one thread of the group being assigned to a different processing engine within an SPM . A thread group may include fewer threads than the number of processing engines within the SPM , in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SPM , in which case processing will take place over consecutive clock cycles. Since each SPM  can support up to G thread groups concurrently, it follows that up to G*M thread groups can be executing in GPC  at any given time.","Additionally, a plurality of related thread groups may be active (in different phases of execution) at the same time within an SPM . This collection of thread groups is referred to herein as a \u201ccooperative thread array\u201d (\u201cCTA\u201d) or \u201cthread array.\u201d The size of a particular CTA is equal to m*k, where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SPM , and m is the number of thread groups simultaneously active within the SPM . The size of a CTA is generally determined by the programmer and the amount of hardware resources, such as memory or registers, available to the CTA.","Each SPM  contains an L1 cache (not shown) or uses space in a corresponding L1 cache outside of the SPM  that is used to perform load and store operations. Each SPM  also has access to L2 caches within the partition units  that are shared among all GPCs  and may be used to transfer data between threads. Finally, SPMs  also have access to off-chip \u201cglobal\u201d memory, which can include, e.g., parallel processing memory  and\/or system memory . It is to be understood that any memory external to PPU  may be used as global memory. Additionally, an L1.5 cache  may be included within the GPC , configured to receive and hold data fetched from memory via memory interface  requested by SPM , including instructions, uniform data, and constant data, and provide the requested data to SPM . Embodiments having multiple SPMs  in GPC  beneficially share common instructions and data cached in L1.5 cache .","Each GPC  may include a memory management unit (MMU)  that is configured to map virtual addresses into physical addresses. In other embodiments, MMU(s)  may reside within the memory interface . The MMU  includes a set of page table entries (PTEs) used to map a virtual address to a physical address of a tile and optionally a cache line index. The MMU  may include address translation lookaside buffers (TLB) or caches which may reside within multiprocessor SPM  or the L1 cache or GPC . The physical address is processed to distribute surface data access locality to allow efficient request interleaving among partition units. The cache line index may be used to determine whether of not a request for a cache line is a hit or miss.","In graphics and computing applications, a GPC  may be configured such that each SPM  is coupled to a texture unit  for performing texture mapping operations, e.g., determining texture sample positions, reading texture data, and filtering the texture data. Texture data is read from an internal texture L1 cache (not shown) or in some embodiments from the L1 cache within SPM  and is fetched from an L2 cache, parallel processing memory , or system memory , as needed. Each SPM  outputs processed tasks to work distribution crossbar  in order to provide the processed task to another GPC  for further processing or to store the processed task in an L2 cache, parallel processing memory , or system memory  via crossbar unit . A preROP (pre-raster operations)  is configured to receive data from SPM , direct data to ROP units within partition units , and perform optimizations for color blending, organize pixel color data, and perform address translations.","It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units, e.g., SPMs  or texture units , preROPs  may be included within a GPC . Further, while only one GPC  is shown, a PPU  may include any number of GPCs  that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC  receives a particular processing task. Further, each GPC  advantageously operates independently of other GPCs  using separate and distinct processing units, L1 caches, and so on.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 3B","FIG. 2"],"b":["215","202","215","350","355","360","350","210","360","350","355","355","355","220","220"]},"In graphics applications, ROP  is a processing unit that performs raster operations, such as stencil, z test, blending, and the like, and outputs pixel data as processed graphics data for storage in graphics memory. In some embodiments of the present invention, ROP  is included within each GPC  instead of partition unit , and pixel read and write requests are transmitted over crossbar unit  instead of pixel fragment data.","The processed graphics data may be displayed on display device  or routed for further processing by CPU  or by one of the processing entities within parallel processing subsystem . Each partition unit  includes a ROP  in order to distribute processing of the raster operations. In some embodiments, ROP  may be configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.","Persons skilled in the art will understand that the architecture described in , , A, and B in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit, including, without limitation, one or more CPUs, one or more multi-core CPUs, one or more PPUs , one or more GPCs , one or more graphics or special purpose processing units, or the like, without departing the scope of the present invention.","In embodiments of the present invention, it is desirable to use PPU  or other processor(s) of a computing system to execute general-purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier (\u201cthread ID\u201d) that is accessible to the thread during its execution. The thread ID, which can be defined as a one-dimensional or multi-dimensional numerical value controls various aspects of the thread's processing behavior. For instance, a thread ID may be used to determine which portion of the input data set a thread is to process and\/or to determine which portion of an output data set a thread is to produce or write.","A sequence of per-thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example, the sequence of per-thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point, an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access, an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs, or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read, with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques, data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently, any desired pattern of data sharing among threads can be supported, and any thread in a CTA can share data with any other thread in the same CTA. The extent, if any, of data sharing among threads of a CTA is determined by the CTA program; thus, it is to be understood that in a particular application that uses CTAs, the threads of a CTA might or might not actually share data with each other, depending on the CTA program, and the terms \u201cCTA\u201d and \u201cthread array\u201d are used synonymously herein.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 3C","FIG. 3A"],"b":["310","310","370","335","312","370","304","310","310","302","303"]},"SPM  provides on-chip (internal) data storage with different levels of accessibility. Special registers (not shown) are readable but not writeable by LSU  and are used to store parameters defining each CTA thread's \u201cposition.\u201d In one embodiment, special registers include one register per CTA thread (or per exec unit  within SPM ) that stores a thread ID; each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers, readable by all CTA threads (or by all LSUs ) that store a CTA identifier, the CTA dimensions, the dimensions of a grid to which the CTA belongs, and an identifier of a grid to which the CTA belongs. Special registers are written during initialization in response to commands received via front end  from device driver  and do not change during CTA execution.","A parameter memory (not shown) stores runtime parameters (constants) that can be read but not written by any CTA thread (or any LSU ). In one embodiment, device driver  provides parameters to the parameter memory before directing SPM  to begin execution of a CTA that uses these parameters. Any CTA thread within any CTA (or any exec unit  within SPM ) can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .","Local register file  is used by each CTA thread as scratch space; each register is allocated for the exclusive use of one thread, and data in any of local register file  is accessible only to the CTA thread to which it is allocated. Local register file  can be implemented as a register file that is physically or logically divided into P lanes, each having some number of entries (where each entry might store, e.g., a 32-bit word). One lane is assigned to each of the N exec units  and P load-store units LSU , and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups, so that a given entry in the local register file  is accessible only to a particular thread. In one embodiment, certain entries within the local register file  are reserved for storing thread identifiers, implementing one of the special registers.","Shared memory  is accessible to all CTA threads (within a single CTA); any location in shared memory  is accessible to any CTA thread within the same CTA (or to any processing engine within SPM ). Shared memory  can be implemented as a shared register file or shared on-chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments, shared state space might map onto a per-CIA region of off-chip memory, and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory , or as a separate shared register file or on-chip cache memory to which the LSUs  have read-only access. In one embodiment, the area that implements the parameter memory is also used to store the CTA ID and grid ID, as well as CTA and grid dimensions, implementing portions of the special registers. Each LSU  in SPM  is coupled to a unified address mapping unit  that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently, an instruction may be used to access any of the local, shared, or global memory spaces by specifying an address in the unified memory space.","The L1 Cache  in each SPM  can be used to cache private per-thread local data and also per-application global data. In some embodiments, the per-CTA shared data may be cached in the L1 cache . The LSUs  are coupled to a uniform L1 cache , the shared memory , and the L1 cache  via a memory and cache interconnect . The uniform L1 cache  is configured to receive read-only data and constants from memory via the L1.5 Cache .",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 4","FIG. 2"],"b":["400","202","310","415","425","460","410","420","455","465","208","215","400"]},"Data assembler  processing unit collects vertex data for high-order surfaces, primitives, and the like, and outputs the vertex data, including the vertex attributes, to vertex processing unit . Vertex processing unit  is a programmable execution unit that is configured to execute vertex shader programs, lighting and transforming vertex data as specified by the vertex shader programs. For example, vertex processing unit  may be programmed to transform the vertex data from an object-based coordinate representation (object space) to an alternatively based coordinate system such as world space or normalized device coordinates (NDC) space. Vertex processing unit  may read data that is stored in L1 cache , parallel processing memory , or system memory  by data assembler  for use in processing the vertex data.","Primitive assembler  receives vertex attributes from vertex processing unit , reading stored vertex attributes, as needed, and constructs graphics primitives for processing by geometry processing unit . Graphics primitives include triangles, line segments, points, and the like. Geometry processing unit  is a programmable execution unit that is configured to execute geometry shader programs, transforming graphics primitives received from primitive assembler  as specified by the geometry shader programs. For example, geometry processing unit  may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters, such as plane equation coefficients, that are used to rasterize the new graphics primitives.","In some embodiments, geometry processing unit  may also add or delete elements in the geometry stream. Geometry processing unit  outputs the parameters and vertices specifying new graphics primitives to a viewport scale, cull, and clip unit . Geometry processing unit  may read data that is stored in parallel processing memory  or system memory  for use in processing the geometry data. Viewport scale, cull, and clip unit  performs clipping, culling, and viewport scaling and outputs processed graphics primitives to a rasterizer .","Rasterizer  scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Additionally, rasterizer  may be configured to perform z culling and other z-based optimizations.","Fragment processing unit  is a programmable execution unit that is configured to execute fragment shader programs, transforming fragments received from rasterizer , as specified by the fragment shader programs. For example, fragment processing unit  may be programmed to perform operations such as perspective correction, texture mapping, shading, blending, and the like, to produce shaded fragments that are output to raster operations unit . Fragment processing unit  may read data that is stored in parallel processing memory  or system memory  for use in processing the fragment data. Fragments may be shaded at pixel, sample, or other granularity, depending on the programmed sampling rate.","Raster operations unit  is a processing unit that performs raster operations, such as stencil, z test, blending, and the like, and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in graphics memory, e.g., parallel processing memory , and\/or system memory , for display on display device  or for further processing by CPU  or parallel processing subsystem . In some embodiments of the present invention, raster operations unit  is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.","Persons skilled in the art will understand that the architecture described in , , A, B, C, and  in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit, including, without limitation, one or more CPUs, one or more multi-core CPUs, one or more PPUs , one or more GPCs , one or more graphics or special purpose processing units, or the like, without departing the scope of the present invention.","In embodiments of the present invention, it is desirable to use PPU  or other processor(s) of a computing system to execute general-purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier (\u201cthread ID\u201d) that is accessible to the thread during its execution. The thread ID, which can be defined as a one-dimensional or multi-dimensional numerical value controls various aspects of the thread's processing behavior. For instance, a thread ID may be used to determine which portion of the input data set a thread is to process and\/or to determine which portion of an output data set a thread is to produce or write.","A sequence of per-thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example, the sequence of per-thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point, an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access, an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs, or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read, with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques, data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently, any desired pattern of data sharing among threads can be supported, and any thread in a CTA can share data with any other thread in the same CTA. The extent, if any, of data sharing among threads of a CTA is determined by the CTA program; thus, it is to be understood that in a particular application that uses CTAs, the threads of a CTA might or might not actually share data with each other, depending on the CTA program, and the terms \u201cCIA\u201d and \u201cthread array\u201d are used synonymously herein.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 3C","FIG. 3A"],"b":["310","310","370","335","312","370","304","310","310","302","303"]},"SPM  provides on-chip (internal) data storage with different levels of accessibility. Special registers (not shown) are readable but not writeable by LSU  and are used to store parameters defining each CTA thread's \u201cposition.\u201d In one embodiment, special registers include one register per CTA thread (or per exec unit  within SPM ) that stores a thread ID; each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers, readable by all CTA threads (or by all LSUs ) that store a CTA identifier, the CTA dimensions, the dimensions of a grid to which the CTA belongs, and an identifier of a grid to which the CTA belongs. Special registers are written during initialization in response to commands received via front end  from device driver  and do not change during CTA execution.","A parameter memory (not shown) stores runtime parameters (constants) that can be read but not written by any CTA thread (or any LSU ). In one embodiment, device driver  provides parameters to the parameter memory before directing SPM  to begin execution of a CTA that uses these parameters. Any CTA thread within any CTA (or any exec unit  within SPM ) can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .","Local register file  is used by each CTA thread as scratch space; each register is allocated for the exclusive use of one thread, and data in any of local register file  is accessible only to the CTA thread to which it is allocated. Local register file  can be implemented as a register file that is physically or logically divided into P lanes, each having some number of entries (where each entry might store, e.g., a 32-bit word). One lane is assigned to each of the N exec units  and P load-store units LSU , and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups, so that a given entry in the local register file  is accessible only to a particular thread. In one embodiment, certain entries within the local register file  are reserved for storing thread identifiers, implementing one of the special registers.","Shared memory  is accessible to all CTA threads (within a single CTA); any location in shared memory  is accessible to any CTA thread within the same CTA (or to any processing engine within SPM ). Shared memory  can be implemented as a shared register file or shared on-chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments, shared state space might map onto a per-CTA region of off-chip memory, and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory , or as a separate shared register file or on-chip cache memory to which the LSUs  have read-only access. In one embodiment, the area that implements the parameter memory is also used to store the CTA ID and grid ID, as well as CTA and grid dimensions, implementing portions of the special registers. Each LSU  in SPM  is coupled to a unified address mapping unit  that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently, an instruction may be used to access any of the local, shared, or global memory spaces by specifying an address in the unified memory space.","The L1 Cache  in each SPM  can be used to cache private per-thread local data and also per-application global data. In some embodiments, the per-CTA shared data may be cached in the L1 cache . The LSUs  are coupled to a uniform L1 cache , the shared memory , and the L1 cache  via a memory and cache interconnect . The uniform L1 cache  is configured to receive read-only data and constants from memory via the L1.5 Cache .","A hybrid grid representation that provides a three-dimensional representation of water above an arbitrary terrain is composed of regular cubic cells on top of a layer of tall cells. A fluid solver that simultaneously solves the three-dimensional Euler equation for both the tall cells and the regular cubic cells may be efficiently executed by a GPU such as the PPU  or by another SIMD architecture. Parallel execution is performed to simultaneously compute values for the grid cells, e.g., tall cells and the regular cubic cells. Additionally, a specialized multigrid algorithm for solving the Poisson equation may be used to accelerate simulations. The hybrid grid representation and computational optimizations allow for real-time simulation performance while maintaining the complexity of the fluid movement.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIGS. 5A","b":["5","5"]},"Fluids are simulated by solving the inviscid Euler Equations,",{"@attributes":{"id":"p-0080","num":"0079"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","mi":"u"},{"mo":"\u2202","mi":"t"}]},"mo":"=","mrow":{"mrow":{"mrow":{"mo":"-","mrow":{"mo":["(",")"],"mrow":{"mi":"u","mo":["\u00b7","\u2207"]}}},"mo":"\u2062","mi":"u"},"mo":["+","-"],"mfrac":[{"mi":["f","\u03c1"]},{"mrow":{"mo":"\u2207","mi":"p"},"mi":"\u03c1"}]}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"1"}}}]}}}},"br":[{},{},{}],"in-line-formulae":[{},{}],"i":"u=","sup":"T "},{"@attributes":{"id":"p-0081","num":"0080"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","mi":"\u03c6"},{"mo":"\u2202","mi":"t"}]},"mo":"=","mrow":{"mrow":[{"mo":"-","mi":"u"},{"mo":"\u2207","mi":"\u03c6"}],"mo":"\u00b7"}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"3"}}}]}}}}},"As a discretization of the simulation domain a specialized tall cell grid is used to model the fluid volume that includes the water and air above the water.  is a cross section of the hybrid grid model comprised of tall cells  and regular cubic cells , according to one embodiment of the present invention. Each water column is positioned on the terrain  and includes a single tall cell and a constant number of regular cubic cells. For example, a water column  includes a single tall cell representing water, two regular cubic cells representing water, and six regular cubic cells representing air above the water. As shown in , the constant number of regular cubic cells in each water column is eight.","The terrain height and the height of the tall cell are discretized to be a multiple of the grid spacing \u0394x. The height values are stored in two arrays. For regular cubic cells, all the physical quantities such as velocity, level set value and pressure are stored at the center of the regular cubic cell. For tall cells, values of physical quantities are stored at the center of the topmost and the bottommost subcells, where a size of each subcell matches a regular cubic cell. In contrast, conventional techniques require storing a number of parameters equal to the number of regular cubic cells represented by each tall cell. In terms of implementation, a quantity q is stored in a compressed 3D array, q, of size (B, B+2, B) where Band Bare the number of cells along the x and z axis respectively, Bis the constant number of regular cells along the y-axis per column and the \u00b12 comes from the top and the bottom values stored in per tall cell. In addition, the terrain height Hand the tall cell height hare stored in two 2D arrays of size (B, B). The y-coordinate of the uncompressed position of an array element qis given by",{"@attributes":{"id":"p-0084","num":"0083"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":"y","mrow":{"mi":["i","j","k"],"mo":[",",","]}},"mo":"=","mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":"H","mrow":{"mi":["i","k"],"mo":","}},"mo":"+","mn":"1"}},{"mi":"if"},{"mrow":{"mi":"j","mo":"=","mrow":{"mn":"1","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["tall","cell","bottom"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}}}]},{"mtd":[{"mrow":{"msub":[{"mi":"H","mrow":{"mi":["i","k"],"mo":","}},{"mi":"h","mrow":{"mi":["i","k"],"mo":","}}],"mo":"+"}},{"mi":"if"},{"mrow":{"mi":"j","mo":"=","mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["tall","cell","top"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}}}]},{"mtd":[{"mrow":{"msub":[{"mi":"H","mrow":{"mi":["i","k"],"mo":","}},{"mi":"h","mrow":{"mi":["i","k"],"mo":","}}],"mo":["+","+","-"],"mi":"j","mn":"2"}},{"mi":"if"},{"mrow":{"mi":"j","mo":"\u2265","mrow":{"mn":"3","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["regular","cubic","cell"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},"mo":"."}}}}]}]}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"4"}}}]}}}}},"A quantity stored in the compressed array at position i, j, k is denoted as qwithout parentheses, and a quantity at the uncompressed world location (x\u0394x, y\u0394x, z\u0394x) is denoted as qwith parentheses. Depending on the y-coordinate, there are four cases for evaluating qbased on the values stored in the compressed array.\n\n",{"@attributes":{"id":"p-0086","num":"0087"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":"q","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y","z"],"mo":[",",","]}}},"mo":"=","mrow":{"mrow":[{"mfrac":{"mrow":{"mi":"y","mo":"-","msub":{"mi":"H","mrow":{"mi":["x","z"],"mo":","}}},"msub":{"mi":"h","mrow":{"mi":["x","z"],"mo":","}}},"mo":"\u2062","msub":{"mi":"q","mrow":{"mi":["x","z"],"mo":[",",","],"mn":"2"}}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":{"mi":"y","mo":"-","msub":{"mi":"H","mrow":{"mi":["x","z"],"mo":","}}},"msub":{"mi":"h","mrow":{"mi":["x","z"],"mo":","}}}}},"mo":"\u2062","msub":{"mi":"q","mrow":{"mi":["x","z"],"mo":[",",","],"mn":"2"}}}],"mo":"+"}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"5"}}}]}}}},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["If H+h<y<H+h+Bthe quantity is obtained by looking the value up from the regular cells in the compressed array as\n\n,(\u22122),\u2003\u2003equation (6)\n","Otherwise qis the value above air."]}}}},"The definition of qhides the tall cell structure of the grid. Once implemented, the grid can be accessed as if the grid is a regular grid composed of regular cubical cells only, which significantly simplifies the computations performed during a simulation. A quantity at an arbitrary point in space can be computed by trilinearly interpolating the nearest q's.","There are a few properties that distinguish the tall cell formulation from conventional techniques that also use tall cells.\n\n","The time integration scheme that is used to perform the simulation for each timestep is summarized in TABLE 1. With the exception of the remeshing step, the time integration technique follows standard Eulerian fluid simulation.",{"@attributes":{"id":"p-0090","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Time Integration Scheme"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1:","Velocity extrapolation"]},{"entry":[{},"2:","Level set reinitialization"]},{"entry":[{},"3:","Advection and external force integration"]},{"entry":[{},"4:","Remeshing"]},{"entry":[{},"5:","Incompressibility enforcement"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"First, the velocity field is extrapolated into the air region. Then, after reinitializing the level-set (signed distance) field, the level set and the velocity field are advected and external forces are taken into account. The next step is to perform remeshing by recomputing the height of the tall cells and transferring the physical quantities to update the tall cell grid. Finally, incompressibility is enforced by making the velocity field divergence free.","The x-component of the velocity field u can be extrapolated into the air region, where \u03c6>0, by solving the equation",{"@attributes":{"id":"p-0093","num":"0099"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mfrac":{"msub":[{"mo":"\u2202","mi":"u"},{"mo":"\u2202","mi":"T"}]},"mo":"=","mrow":{"mrow":[{"mo":"-","mfrac":{"mrow":[{"mo":"\u2207","mi":"\u2205"},{"mo":["\uf603","\uf604"],"mrow":{"mo":"\u2207","mi":"\u2205"}}]}},{"mo":["\u2207","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"u"}],"mo":"\u00b7"}},"mo":","}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"7"}}}]}}}},"br":{}},"However, for the time integration scheme shown in TABLE 1 the velocity is relatively large and the time step that is used ( 1\/30 s) is much larger than is typically used in water simulations. Therefore, water can cross several grid cells in a single time step. To make this possible, velocity information far away from the liquid surface is needed.","Fortunately, an accurate velocity field is only needed close to the surface, while far away from the liquid a crude estimate is sufficient. Therefore, a variation of an Eikonal solver algorithm is applied only in a narrow band of two cells at the surface. Outside of the narrow band region, a coarser level of a hierarchical tall cell grid maybe used for extrapolating the velocity field. All velocity components can be simultaneously extrapolated when a collocated grid is used.",{"@attributes":{"id":"p-0096","num":"0102"},"figref":["FIG. 5E","FIG. 5D","FIG. 5F","FIG. 5D"],"b":["530","515","535","515"]},"The multigrid provides a hierarchy of increasingly coarser representations of the model that may be used by a pressure solver. As described further herein, Eulerian simulation techniques require solving a linear system to determine pressure values for each cell within the cell grid. Different levels of the multigrid are used to compute the pressure values for different regions of the model, maintaining accuracy while simplifying the computations. The multigrid ensures that air bubbles are correctly modeled near the surface of the water so that details of the water movement are retained. A multigrid may be generated and used to solve the linear system for a cell grid model that includes tall cells or a multigrid may be generated and used to solve the linear system for a cell grid model that includes only regular cubic cells. In other words, although the multigrid technique may be used in conjunction with the tall cell grid technique, each technique may also be employed independently for fluid simulations.","The number of levels of a hierarchical tall cell grid is determined by L=logmin(B, B, B) where B, B, and Bare the number of regular cubic cells along the x, y, and z axes, respectively. The finest level of the hierarchical tall cell grid corresponds to the simulation tall cell grid with \u0394x=\u0394x, u=u, H=H, and h=h. On coarser levels of the hierarchical tall cell grid l, L>l\u22671, the quantities Hand hare defined via down sampling as",{"@attributes":{"id":"p-0099","num":"0105"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"msubsup":{"mi":["H","l"],"mrow":{"mi":["i","k"],"mo":","}},"mo":"=","mrow":{"mo":["\u230a","\u230b"],"mfrac":{"mrow":{"msubsup":[{"mi":"min","mrow":[{"mrow":[{"msup":{"mi":["i","\u2032"]},"mo":"=","mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"i"}},{"msup":{"mi":["k","\u2032"]},"mo":"=","mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"k"}}],"mo":","},{"mrow":[{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"i"},"mo":"+","mn":"1"},{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"k"},"mo":"+","mn":"1"}],"mo":","}]},{"mi":"H","mrow":[{"msup":[{"mi":["i","\u2032"]},{"mi":["k","\u2032"]}],"mo":","},{"mi":"l","mo":"+","mn":"1"}]}],"mo":"\u2062"},"mn":"2"}}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"8"}}}]},{"mtd":[{"mrow":{"mrow":{"msubsup":{"mi":["h","l"],"mrow":{"mi":["i","k"],"mo":","}},"mo":"=","mrow":{"mrow":{"mo":["\u2308","\u2309"],"mfrac":{"mrow":{"mrow":{"msubsup":[{"mi":"max","mrow":[{"mrow":[{"msup":{"mi":["i","\u2032"]},"mo":"=","mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"i"}},{"msup":{"mi":["k","\u2032"]},"mo":"=","mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"k"}}],"mo":","},{"mrow":[{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"i"},"mo":"+","mn":"1"},{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"k"},"mo":"=","mn":"1"}],"mo":","}]},{"mi":"H","mrow":[{"msup":[{"mi":["i","\u2032"]},{"mi":["k","\u2032"]}],"mo":","},{"mi":"l","mo":"+","mn":"1"}]}],"mo":"\u2062"},"mo":"+","msubsup":{"mi":"h","mrow":[{"msup":[{"mi":["i","\u2032"]},{"mi":["k","\u2032"]}],"mo":","},{"mi":"l","mo":"+","mn":"1"}]}},"mn":"2"}},"mo":"-","msubsup":{"mi":["H","l"],"mrow":{"mi":["i","k"],"mo":","}}}},"mo":","}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"9"}}}]}]}}},"br":{},"figref":["FIGS. 5D","FIGS. 5E and 5F","FIG. 5D"],"b":["5","5","515"]},"The velocities in the hierarchy of grids are evaluated by sweeping down then sweeping up the hierarchy. On the finest level L, the velocity of a cell (tall or regular cubic) is declared to be known if the cell is a liquid cell or if the velocity is already extrapolated. Then the levels are traversed from finest to coarsest and velocities are computed by trilinearly interpolating the velocities of the previous level using only known velocities and renormalizing the interpolation weights accordingly. The velocity of a coarse cell is declared to be known if at least one corresponding finer cell velocity is known. The hierarchy of the tall cell grid is then traversed in the reverse order, from coarsest to finest, and velocities on finer levels are evaluated by trilinearly interpolating values from coarser levels of the hierarchical tall cell grid. After the two traversals are complete, every cell of the finest grid has a known velocity.","Advecting \u03c6 destroys the signed distance field property of the scalar level set field. Therefore, \u03c6 needs to be reinitialized periodically to be accurate at least for two to three cells away from the liquid surface. Conventional techniques may be used to reinitialize \u03c6. Because a higher resolution level of a grid in the tall cell grid hierarchy is used for surface tracking compared with the level of the grid in the tall cell grid hierarchy that is used for the simulation, the reinitialization computation can be quite costly. In one embodiment, the reinitialization process is significantly simplified and satisfactory results are still achieved. A first simplification is to run the reinitialization step only every N frames, where N is a integer value, e.g., 10. A second simplification is to not modify \u03c6 values of grid points next to the surface during reinitialization in order to avoid moving the surface. A third simplification is to clamp the value of \u03c6 next to the liquid surface (boundary between the liquid and air) to not exceed the grid spacing \u0394x for every frame. Without clamping, incorrect values get advected near the liquid surface and cause surface bumpiness. To stabilize the process further, in one embodiment, all \u03c6 values are clamped to have magnitude less than 5\u0394x. These simplifications have not introduced significant problems or artifacts during simulations.","To advect u the modified MacCormack scheme is used and if the new velocity component lies outside the bound of the values used for interpolation simple Semi-Lagrangian advection is used. To update \u03c6 Semi-Lagrangian advection is used because the modified MacCormack scheme produces noisier surfaces, even when care is taken near the interface between the liquid and air. Because the collocated grid is used, the Semi-Lagrangian ray is traced only once for all quantities reusing the same interpolation weights. After tracing to rays, external forces such as gravity are integrated using a forward-Euler technique.","After advection, liquid cells are identified as those where \u03c6\u22660. At this point new values hare defined, i.e. the number of cells above the terrain that should be grouped into one tall cell for each column (i, k) is determined. There are a few desirable constraints that may conflict each other:\n\n","First, iterate through each pair (i, k) and compute the maximum and minimum y-coordinate of the top of the tall cell that satisfy constraints (1) and (2), respectively. Next, initialize the temporary variable yto be the average of the two extrema. To reduce the differences in height of adjacent tall cells several smoothing passes are run on y. During the smoothing yis clamped so that constraints (1) and (2) are satisfied. Preference is given to constraint (2) by enforcing constraint (2) after constraint (1). Finally, iterate through (i, k) again and enforce constraint (3) in a Jacobi-type fashion using",{"@attributes":{"id":"p-0105","num":"0114"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msubsup":{"mi":"y","mrow":{"mi":["i","k"],"mo":","},"msup":{"mi":["tmp","\u2032"]}},"mo":"=","mrow":{"mi":"min","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msubsup":{"mi":["y","tmp"],"mrow":{"mi":["i","k"],"mo":","}},"mo":",","mrow":{"mrow":{"munder":{"mi":"max","mrow":{"mrow":{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"msup":{"mi":["i","\u2032"]},"mo":"-","mi":"i"}},{"mo":["\uf603","\uf604"],"mrow":{"msup":{"mi":["k","\u2032"]},"mo":"-","mi":"k"}}],"mo":"+"},"mo":"=","mn":"1"}},"mo":"\u2062","msubsup":{"mi":["y","tmp"],"mrow":{"msup":{"mi":["i","\u2032"]},"mo":",","mrow":{"mi":["k","\u2032"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}},"mo":"+","mi":"D"}}}}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"10"}}}]}}}}},"In one embodiment, 8\u2266G\u226632, G=8.3\u2266D\u22666 are used new and between one and two Jacobi iterations. Finally we set h=y\u2212H. The algorithm attempts to make compromise among the constraints but may not satisfy all of them. Once the new heights of the tall cells are determined, all of the physical quantities are transferred to update the tall cell grid. For regular cubic cells, values at the corresponding locations are copied from the previous tall cell grid or are linearly interpolated if the location was occupied by a tall cell in the previous time step. For tall cells, a least square fit is performed to obtain the values at the bottom and the top of the tall cell.","Once the values are updated for the tall cell grid, incompressibility is enforced. Suppose the velocity field after the advection and the remeshing step is u*. The pressure field p is computed such that",{"@attributes":{"id":"p-0108","num":"0117"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mo":"\u2207","mrow":{"mo":"\u00b7","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":"u","mo":"*"},"mo":"-","mrow":{"mfrac":{"mrow":{"mi":["\u0394","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mi":"\u03c1"},"mo":"\u2062","mrow":{"mo":["\u2207","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"p"}}}}}},"mo":"=","mn":"0"}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"11"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0109","num":"0118"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msup":{"mo":"\u2207","mn":"2"},"mo":"\u2062","mi":"p"},{"mfrac":{"mi":"\u03c1","mrow":{"mi":["\u0394","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},"mo":"\u2062","mrow":{"mo":"\u2207","mrow":{"mo":"\u00b7","msup":{"mi":"u","mo":"*"}}}}],"mo":"="}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"12"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0110","num":"0119"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":[{"msub":{"mrow":[{"mo":["(",")"],"mrow":{"mo":"\u2207","mrow":{"mo":"\u00b7","mi":"u"}}},{"mi":["i","j","k"],"mo":[",",","]}]},"mo":"=","mrow":{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"u"},{"mo":"\u2202","mi":"x"}]}},"mo":"\u2062","mi":"i"}},{"mi":"k","mo":"+","mrow":{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"v"},{"mo":"\u2202","mi":"y"}]}},"mo":"\u2062","mi":"i"}},{"mi":"k","mo":"+","mrow":{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"w"},{"mo":"\u2202","mi":"z"}]}},"mo":"\u2062","mi":"i"}}],"mo":[",",",",",",",",",",",",","],"mi":["j","j","j","k"]}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"13"}}}]},{"mtd":[{"mrow":{"mrow":[{"mi":["Where","i"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"u"},{"mo":"\u2202","mi":"x"}]}}},{"mi":"k","mo":"=","mrow":{"mfrac":{"mrow":[{"msubsup":[{"mi":"u","mrow":{"mi":["i","j","k"],"mo":[",",","]},"mo":"+"},{"mi":"u","mrow":{"mi":["i","j","k"],"mo":[",",","]},"mo":"-"}],"mo":"-"},{"mi":["\u0394","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"and"}}],"mo":[",",","],"mi":"j"}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},{"mtd":[{"mrow":{"msubsup":{"mi":"u","mrow":{"mi":["i","j","k"],"mo":[",",","]},"mo":"+"},"mo":"=","mrow":{"mo":"{","mrow":{"mtable":{"mtr":[{"mtd":{"mfrac":{"mrow":{"msub":[{"mi":"u","mrow":{"mi":["i","j","k"],"mo":[",",","]}},{"mi":"u","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"i","mo":"+","mn":"1"},"mo":[",",","],"mi":["y","k"]}}}],"mo":"+"},"mn":"2"}}},{"mtd":{"msub":{"mi":["u","solid"]}}}]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mtext":{}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","the","cell","is","not","solid"],"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":"i","mo":"+","mn":"1"},"mo":[",",","],"mi":["y","k"]}},{"mi":"Otherwise","mo":"."}]}}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"14"}}}]}]}}},"br":{},"sub":"i,j,k","sup":"\u2212 "},{"@attributes":{"id":"p-0111","num":"0120"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"v"},{"mo":"\u2202","mi":"y"}]}},"mo":"\u2062","mi":"i"},{"mi":["k","and","i"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"w"},{"mo":"\u2202","mi":"z"}]}}},{"mi":"k","mo":"."}],"mo":[",",",",",",","],"mi":["j","j"]}}},"br":{}},{"@attributes":{"id":"p-0112","num":"0121"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"msub":{"mrow":[{"mo":["(",")"],"mrow":{"msup":{"mo":"\u2207","mn":"2"},"mo":"\u2062","mi":"p"}},{"mi":["i","j","k"],"mo":[",",","]}]},"mo":"=","mrow":{"msub":[{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"msup":{"mo":"\u2202","mn":"2"},"mo":"\u2062","mi":"p"},{"mo":"\u2202","msup":{"mi":"x","mn":"2"}}]}},{"mi":["i","j","k"],"mo":[",",","]}]},{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"msup":{"mo":"\u2202","mn":"2"},"mo":"\u2062","mi":"p"},{"mo":"\u2202","msup":{"mi":"y","mn":"2"}}]}},{"mi":["i","j","k"],"mo":[",",","]}]},{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"msup":{"mo":"\u2202","mn":"2"},"mo":"\u2062","mi":"p"},{"mo":"\u2202","msup":{"mi":"z","mn":"2"}}]}},{"mi":["i","j","k"],"mo":[",",","]}]}],"mo":["+","+"]}},"mo":","}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"15"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0113","num":"0122"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msubsup":{"mi":"p","mrow":[{"mi":["i","j","k"],"mo":[",",","]},{"mi":"x","mo":"+"}]},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":"p","mrow":{"mi":["i","j","k"],"mo":[",",","]}},"mo":"\u2062","mfrac":{"mrow":[{"mi":"\u03c6","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"i","mo":"+","mn":"1"},"mo":[",",","],"mi":["y","k"]}}},{"mrow":{"mi":["\u03c6","i"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":[",",","],"mi":["j","k"]}]}}},{"mrow":{"mi":["if","the","cell","is","air"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"i","mo":"+","mn":"1"},"mo":[",",","],"mi":["y","k"]}}}}]},{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"msub":[{"mi":"s","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"i","mo":"+","mn":"1"},"mo":[",",","],"mi":["y","k"]}}},{"mi":"p","mrow":{"mi":["i","j","k"],"mo":[",",","]}}],"mo":"\u2062"},"mo":"+"}}},{"mtd":{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msub":{"mi":"s","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"i","mo":"+","mn":"1"},"mo":[",",","],"mi":["y","k"]}}}}},"mo":"\u2062","msub":{"mi":"p","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"i","mo":"+","mn":"1"},"mo":[",",","],"mi":["y","k"]}}}}}}]}},{"mrow":{"mi":"otherwise","mo":","}}]}]}}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"16"}}}]}}}},"br":{},"sub":["i,j,k ","i,j,k"],"sup":"x\u2212 "},{"@attributes":{"id":"p-0114","num":"0123"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"msup":{"mo":"\u2202","mn":"2"},"mo":"\u2062","mi":"p"},{"mo":"\u2202","msup":{"mi":"y","mn":"2"}}]}},{"mi":["i","j","k"],"mo":[",",","]}]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","mrow":{"msub":{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"msup":{"mo":"\u2202","mn":"2"},"mo":"\u2062","mi":"p"},{"mo":"\u2202","msup":{"mi":"z","mn":"2"}}]}},{"mi":["i","j","k"],"mo":[",",","]}]},"mo":"."}}}},"br":{}},"Discretizing equation (12) by applying the operators defined above to all the regular cubic cells and the bottom and the top of tall cells yields a linear system for the unknown pressure field p. After solving for p, the gradient of p is computed using",{"@attributes":{"id":"p-0116","num":"0125"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mrow":[{"mo":["(",")"],"mrow":{"mo":"\u2207","mi":"p"}},{"mi":["i","j","k"],"mo":[",",","]}]},"mo":"=","msup":{"mrow":{"mo":["[","]"],"mrow":{"msub":[{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"x"}]}},{"mi":["i","j","k"],"mo":[",",","]}]},{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"y"}]}},{"mi":["i","j","k"],"mo":[",",","]}]},{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"z"}]}},{"mi":["i","j","k"],"mo":[",",","]}]}],"mo":["\u2062","\u2062"]}},"mi":"T"}},{"msub":{"mrow":[{"mi":"where","mo":["\u2062","(",")"],"mstyle":{"mtext":{}},"mfrac":{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"x"}]}},{"mi":["i","j","k"],"mo":[",",","]}]},"mo":"=","mrow":{"mrow":{"mfrac":{"mrow":[{"msubsup":[{"mi":"p","mrow":[{"mi":["i","j","k"],"mo":[",",","]},{"mi":"x","mo":"+"}]},{"mi":"p","mrow":[{"mi":["i","j","k"],"mo":[",",","]},{"mi":"x","mo":"-"}]}],"mo":"-"},{"mi":["\u0394","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},"mo":"\u00b7","msub":{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"y"}]}},{"mi":["i","j","k"],"mo":[",",","]}]}},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","msub":{"mrow":[{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"z"}]}},{"mi":["i","j","k"],"mo":[",",","]}]}}}],"mo":[",","\u2062"],"mstyle":{"mtext":{}}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"17"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0117","num":"0126"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":"u","mrow":{"mi":["i","j","k"],"mo":[",",","]}},"mo":"-=","mrow":{"mfrac":{"mrow":{"mi":["\u0394","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mi":"\u03c1"},"mo":"\u2062","msub":{"mrow":[{"mo":["(",")"],"mrow":{"mo":"\u2207","mi":"p"}},{"mi":["i","j","k"],"mo":[",",","]}]}}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"18"}}}]}}}}},"Solving the linear system for p is usually the most time consuming step in fluid simulations. Without tall cells, the matrix of the system is identical to the conventional matrix appearing in standard Eulerian regular grid liquid simulation and can be solved efficiently using the incomplete Cholesky preconditioned Conjugate Gradients method. In the presence of tall cells though, the resulting linear system is non-symmetric and the Conjugate Gradients method cannot be used. On the other hand, even though non-symmetric, the system is still much simpler than the one emerging from a conventional technique that does not limit the number of velocities stored for each tall cell because a constant number of coefficients is stored per cell. The constant number of data that is stored for the tall cell grid makes the problem well suited for a data parallel architecture such as a GPU and for a hierarchical grid (multigrid) approach. TABLE 2 summarizes the algorithm for a multigrid pressure solver.",{"@attributes":{"id":"p-0119","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Multigrid Pressure Solver"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20021: Compute matrix Afor level L"]},{"entry":[{},"\u20022: for l=L\u22121 down to 1 do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20023:","Down sample \u03c6\u2192 \u03c6and s\u2192 s"]},{"entry":[{},"\u20024:","Compute matrix Afor level l"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20025: end for"]},{"entry":[{},"\u20026: b= \u2212\u0394tl\u03c1(\u2207\u00b7u)"]},{"entry":[{},"\u20027: p= 0"]},{"entry":[{},"\u20028: for i=1 to num_Full_Cycles do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20029:","Full_Cycle( )"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"10: end for"]},{"entry":[{},"11: for i=1 to num_V_Cycles do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"12:","V_Cycle(L)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"13: end for"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As previously explained, at each level of the hierarchical grid, a linear system of the form Ap=bhas to be solved. To down sample sto s, an 8-to-1 average is computed for regular cubic cells and a least square fit of the 8-to-1 averages of the sub cells is performed for the tall cells. For down sampling \u03c6to \u03c6the following two cases are identified:\n\n","The key idea is to ensure that air bubbles persist in the C finest levels. In the C finest levels, bubbles have a significant influence on the resulting pressure values. On the other hand, letting air bubbles disappear in coarser levels is not problematic because only a general pressure profile is needed in the coarser levels in order to get accurate pressure values in the original grid. Tracking bubbles on coarser levels is not only unnecessary but keeping bubbles at the coarser levels yields incorrect profiles because the influence of the bubbles at the coarser levels becomes exaggerated. In one embodiment, C=2 is used for simulations.","The coefficients of the Amatrix are then computed for each level using Equation (16). Unlike conventional solvers, sub-grid features are handled correctly through the ghost fluid and solid fraction methods on all the levels of the hierarchy. So in contrast to conventional solvers, the solver converges even in the presence of irregular free-surface and solid boundaries. Handling sub-grid features correctly is crucial to obtain meaningful pressures fields on coarse levels. For example, in the hydrostatic case free surface boundary conditions are enforced at the correct location up to first order to get a correct linear pressure profile on all levels of the hierarchy. Without using sub-grid resolution, slightly different problems would be solved on the coarse grids.","For smoothing, the Red-Black Gauss-Seidel (RBGS) method may be used and the system may be solved in two parallel passes. The restriction operator tri-linearly interpolates r, where ris specially computed as",{"@attributes":{"id":"p-0124","num":"0135"},"maths":{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":"r","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y","z"],"mo":[",",","]}}},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"msub":{"mi":"r","mrow":{"mi":["x","z"],"mo":[",",","],"mn":"1"}}},{"mrow":{"mrow":[{"mi":["if","y"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"msub":{"mi":"H","mrow":{"mi":["x","z"],"mo":","}},"mo":"+","mn":"1"}],"mo":"="}}]},{"mtd":[{"msub":{"mi":"r","mrow":{"mi":["x","z"],"mo":[",",","],"mn":"2"}}},{"mrow":{"mrow":[{"mi":["if","y"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"msub":[{"mi":"H","mrow":{"mi":["x","z"],"mo":","}},{"mi":"h","mrow":{"mi":["x","z"],"mo":","}}],"mo":"+"}],"mo":"="}}]},{"mtd":[{"mrow":{"mrow":{"msub":[{"mi":"r","mrow":{"mi":["x","y"],"mo":","}},{"mi":"H","mrow":{"mi":["x","z"],"mo":","}},{"mi":"h","mrow":{"mi":["x","z"],"mo":","}}],"mo":["-","-","-"],"mn":"2"},"mo":",","mi":"z"}},{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":"H","mrow":{"mi":["x","z"],"mo":","}}},"mo":"+","msub":{"mi":"h","mrow":{"mi":["x","z"],"mo":","}}},"mo":["\u2264","<"],"mi":"y"}}},{"mtd":{"mrow":{"msub":[{"mi":"H","mrow":{"mi":["x","z"],"mo":","}},{"mi":"h","mrow":{"mi":["x","z"],"mo":","}},{"mi":["B","y"]}],"mo":["+","+"]}}}]}}]},{"mtd":[{"mn":"0"},{"mrow":{"mi":"otherwise","mo":"."}}]}]}}}},{"mrow":{"mi":"equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"19"}}}]}}}},"br":{}},"There are three critical steps to making the multigrid algorithm converge:\n\n","TABLE 3 summarizes the algorithm for the V_Cycle function shown in line 12 of TABLE 2.",{"@attributes":{"id":"p-0127","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"V_Cycle function"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20021: if l ==1 then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20022:","Solve the linear system, Ap= b"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20023: else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20024:","for i=1 to num_Pre_Sweep do"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20025:","Smooth(p)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20026:","end for"]},{"entry":[{},"\u20027:","r= b Ap"]},{"entry":[{},"\u20028:","b= Restrict(r)"]},{"entry":[{},"\u20029:","p= 0"]},{"entry":[{},"10:","V_Cycle(l\u22121)"]},{"entry":[{},"11:","p= p+ Prolong(p)"]},{"entry":[{},"12:","for i=1 to num_Post_Sweep do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"13:","Smooth(p)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"14:","end for"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"15: end if"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"TABLE 4 summarizes the algorithm for the Full_Cycle function shown in line 9 of TABLE 2.",{"@attributes":{"id":"p-0129","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Full_Cycle function"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20021: p= p"]},{"entry":[{},"\u20022: r= b\u2212 Ap"]},{"entry":[{},"\u20023: for l=L \u2212 1 down to 1 do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20024:","r= Restrict(r)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20025: end for"]},{"entry":[{},"\u20026: b= r"]},{"entry":[{},"\u20027: Solve the linear system, Ap= b"]},{"entry":[{},"\u20028: for l=2 to L do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20029:","p= Prolong(p)"]},{"entry":[{},"10:","b= r"]},{"entry":[{},"11:","V_Cycle(l)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"12: end for"]},{"entry":[{},"13: p= p+ p"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Several optimizations may be employed to increase performance during simulation.\n\n",{"@attributes":{"id":"p-0131","num":"0149"},"figref":["FIG. 6A","FIGS. 1"],"b":["2","3","3","3","4"]},"The steps shown in  are performed by a processor, e.g., CPU or GPU, for one or more timesteps to complete a simulation of a 3D model of a fluid volume. At step  a 3D model of the fluid volume is represented using a tall cell grid. In one embodiment, a 3D model of water is represented as a two-dimensional grid of a plurality of columns that each comprise a single tall cell and a constant number of regular cubic cells. At step  velocities of a fluid velocity field u are extrapolated into the air region of the 3D model of the fluid volume using equation 7. At step  the level-set field \u03c6 is reinitialized. At step  the level-set field \u03c6 and the velocity field u are advected, taking external forces into account. At step  the heights of the tall cells in the 3D model are updated based on the velocity field, i.e., remeshing is performed using equation 10. At step  incompressibility is enforced by making the velocity field divergence free using equations 16, 17, and 18. Steps  through  are repeated for each timestep of the simulation.",{"@attributes":{"id":"p-0133","num":"0151"},"figref":["FIG. 6B","FIG. 6A","FIGS. 1"],"b":["625","2","3","3","3","4"]},"At step  single tall cells and regular cubic cells residing within a surface of the water are identified as liquid cells. At step  maximum and minimum heights of the tall cells are computed for each column in the tall cell grid to satisfy constraints (1) maintaining a minimum number of regular cubic cells below a surface of the water. and (2) maintaining a minimum number of regular cubic cells above the surface of the water. At step  differences between directly adjacent neighboring tall cell heights computed at step  are reduced to satisfy constraint (3) the heights of adjacent tall cells must not differ by more than D units. At step  values are copied from the previous timestep for regular cubic cells that have not been absorbed into the single tall cells. At step  values are interpolated using the values of tall cells for new regular cubic cells. At step  values are computed for tall cells having heights that have changed compared with the previous timestep.",{"@attributes":{"id":"p-0135","num":"0153"},"figref":["FIG. 7","FIGS. 1"],"b":["2","3","3","3","4"]},"At step  a first level-set field values (\u03c6) and first solid fraction values (s) for a three-dimensional model of a fluid volume represented as a first two-dimensional grid of columns is obtained. Each column within the first two-dimensional grid includes one or more regular cubic cells. When a tall cell grid is used, each column within the first two-dimensional grid includes a single tall cell and may include one or more regular cubic cells. The first two-dimensional grid is the highest resolution of the multigrid, level L.","At step , coefficients of the matrix Aare computed using equation (16). At step  the first solid fraction values are downsampled to generate second solid fraction values for the second two-dimensional grid of columns. At step , the first level-set field values are downsampled to generate second level-set field values for a second two-dimensional grid of columns that represents the three-dimensional model of the fluid volume and is coarser than the first two-dimensional grid of columns.","When C\u22671, the downsampling increases the likelihood that air bubbles will persist in the second two-dimensional grid of columns. As previously described, different downsampling computations are used based on C and whether the level-set field values to be downsampled to produce a single value for a coarser level of the multigrid have the same sign. When all of the level-set field values to be downsampled have the same sign, a level-set field value for the second two-dimensional grid of columns is computed as an average of a sub-set of the first level-set field values for the first two-dimensional grid of columns. When the level of the multigrid to be generated, l is less than L\u2212C, a level-set field value for the second two-dimensional grid of columns is also computed as an average of a sub-set of the first level-set field values for the first two-dimensional grid of columns. When\/is not less than L\u2212C or all of the level-set field values to be downsampled do not have the same sign, the second two-dimensional grid of columns is computed as an average of portion of a sub-set of the second level-set field values having positive signs.","At step , coefficients of the matrix Aare computed using equation (16), where l is the next coarser level of the multigrid, e.g., l=L\u22121, l=L\u22122 . . . to l=0. At step , the multigrid generator determines if another level of the multigrid can be generated, i.e., if l>0. If another level can be generated, then the multigrid generator returns to step . Otherwise, at step , the multigrid generator has completed generating the multigrid and the multigrid pressure solver computes b. At step  the multigrid pressure solver sets the pressure pto zero. At step  the multigrid pressure solver solves a linear system in the form Ap=b, where A is a matrix and p is pressure for the different levels of the multigrid. The multigrid pressure solver assigns negative pressure to regular cubic cells that represent air such that p=0 on a surface between air and liquid represented by the first two-dimensional grid of columns, the second two-dimensional grid of columns, and coarser levels of the multigrid. The multigrid pressure solver algorithm is described in TABLEs 3 and 4.","In sum, a three-dimensional model of water is represented as a two-dimensional grid of water columns. A multigrid is generated by downsampling a highest resolution of the grid of water columns to produce successively coarser versions of the water model. A multigrid pressure solver is used to efficiently solve the Poisson equation computing accurate pressure values during simulations. The computational density is focused near the surface of the water to ensure accurate simulation results where the motion of the water is most interesting. The downsampling technique ensures that air bubbles persist in the higher resolution grids of the multigrid. Finally, a correct linear pressure profile is maintained for the multigrid and a pressure solver that using the multigrid converges even in the presence of irregular free-surface and solid boundaries.","One advantage of the technique is that free surface water simulations may be performed in real-time and also produce detailed water movement. A model of the water to be simulated is represented using a cell grid. The multigrid provides a hierarchy of increasingly coarser representations of the model that are used by a pressure solver. Eulerian simulation techniques require solving a linear system to determine pressure values for each cell within the cell grid. Different levels of the multigrid are used to compute the pressure values for different regions of the model, maintaining accuracy while simplifying the computations. The multigrid ensures that air bubbles are correctly modeled near the surface of the water. The accurate pressure values ensure that the water movement is comparable in terms of visual detail to that provided by full three-dimensional model simulation performed off-line. Therefore, visually interesting water simulations may be performed in real-time enabling user interaction for game applications.","One embodiment of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored.","The invention has been described above with reference to specific embodiments. Persons skilled in the art, however, will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.","Therefore, the scope of embodiments of the present invention is set forth in the claims that follow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 3A","FIG. 2"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 3B","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3C","FIG. 3A"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 5A","b":["5","5"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5D"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIGS. 5E and 5F","FIG. 5D"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 6B","FIG. 6A"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
