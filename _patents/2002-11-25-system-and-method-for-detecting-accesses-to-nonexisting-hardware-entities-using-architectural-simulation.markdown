---
title: System and method for detecting accesses to non-existing hardware entities using architectural simulation
abstract: A system and method for detecting accesses to non-existing hardware entities using a simulator environment. When an application running on a simulated target platform issues a transaction that involves accessing a hardware address, wherein the address is within a range of addresses allocated to a simulated hardware block, a set of instructions provided with the simulator are operable to determine if there exists a backing that corresponds to the transaction's address. If there is no backing (i.e., a control status register) associated with the address, an appropriate notification or warning is provided as a response.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07130785&OS=07130785&RS=07130785
owner: Hewlett-Packard Development Company, L.P.
number: 07130785
owner_city: Houston
owner_country: US
publication_date: 20021125
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE DRAWINGS"],"p":["Architecting reliable software for high performance computing platforms has become a daunting task. In today's multiprocessor (MP) systems having a large number of processors in various architectural arrangements, the task is even more challenging. Because the teachings of the present invention will be exemplified in particular reference to MP platforms, a brief introduction thereto is set forth below.","In the most general sense, multiprocessing may be defined as the use of multiple processors to perform computing tasks. The term could apply to a set of networked computers in different locations, or to a single system containing several processors. As is well known, however, the term is most often used to describe an architecture where two or more linked processors are contained in a single or partitioned enclosure. Further, multiprocessing does not occur just because multiple processors are present. For example, having a stack of personal computers in a rack is not multiprocessing. Similarly, a server with one or more \u201cstandby\u201d processors is not multiprocessing, either. The term \u201cmultiprocessing\u201d is typically applied, therefore, only to architectures where two or more processors are designed to work in a cooperative fashion on a task or set of tasks.","There exist numerous variations on the basic theme of multiprocessing. In general, these variations relate to how independently the processors operate and how the workload among these processors is distributed. In loosely-coupled multiprocessing architectures, the processors perform related tasks but they do so as if they were standalone processors. Each processor is typically provided with its own private memory and may have its own mass storage and input\/output (I\/O). Further, each loosely-coupled processor runs its own copy of an operating system (OS), and communicates with the other processor or processors through a message-passing scheme, much like devices communicating over a local area network. Loosely-coupled multiprocessing has been widely used in mainframes and minicomputers, but the software to do so is closely tied to the hardware design. For this reason, among others, it has not gained the support of software vendors and is not widely used in today's high performance server systems.","In tightly-coupled multiprocessing, on the other hand, operation of the processors is more closely integrated. They typically share main memory, and may even have a shared cache. The processors need not be identical to one another, and may or may not perform similar tasks. However, they typically share other system resources such as mass storage and I\/O. Additionally, instead of a separate copy of the OS for each processor, they run a single copy, with the OS handling the coordination of tasks between the processors. The sharing of system resources makes tightly-coupled multiprocessing platforms somewhat less expensive, and it is the dominant multiprocessor architecture in the business-class servers currently deployed.","Hardware architectures for tightly-coupled MP platforms can be further divided into two broad categories. In symmetrical MP (SMP) systems, system resources such as memory, disk storage and I\/O are shared by all the microprocessors in the system. The workload is distributed evenly to available processors so that one does not sit idle while another is heavily loaded with a specific task. Further, the SMP architecture is highly scalable, i.e., the performance of SMP systems increases, at least theoretically, as more processor units are added.","In asymmetrical MP systems, tasks and resources are managed by different processor units. For example, one processor unit may handle I\/O and another may handle network OS (NOS)-related tasks. Thus, it should be apparent that an asymmetrical MP system may not balance the workload and, accordingly, it is possible that a processor unit handling one task can be overworked while another unit sits idle.","SMP systems are further subdivided into two types, depending on the way cache memory is implemented. \u201cShared-cache\u201d platforms, where off-chip (i.e., Level 2, or L2) cache is shared among the processors, offer lower performance in general. In \u201cdedicated-cache\u201d systems, every processor unit is provided with a dedicated L2 cache, in addition to its on-chip (Level 1, or L1) cache memory. The dedicated L2 cache arrangement accelerates processor-memory interactions in the multiprocessing environment and, moreover, facilitates higher scalability.","As alluded to at the beginning, designing software intended for reliable cross-platform execution on numerous MP systems available nowadays has become an arduous undertaking. Further, with ever-shrinking design\/debug cycle times, software developers are continuously looking for ways to streamline the debug operations necessary to architect well-tested code, be it application software, OS software, or firmware (collectively, \u201capplications\u201d).","A particular difficulty arises when a software application is afflicted with latent errors that may go largely unnoticed when it is actually executed on a machine. For instance, a software application may involve transactions that require access to hardware and, at times, a transaction may be directed to a non-existent hardware address. Typically, that is not a problem because the system hardware (each hardware block having a range of addresses supported by control status registers with appropriate initialization information) simply ignores the access transaction when there is no backing and continues to stay in operational mode without raising any alarm. Instead, some undefined value may be returned to the application. This is usually the case since the operational paradigm of high availability MP systems requires that the hardware not go off-line unless it is somehow critically impacted. However, the application code (and the user) does not have the opportunity to realize that an improper access operation to non-existent hardware registers has been issued during the execution. Since the hardware is not designed to catch such accesses and the software application may continue to execute based on some undefined values returned from the hardware, the dynamic behavior and reliability of the application is somewhat compromised. In addition, the problem can be compounded by the fact that oftentimes the hardware development of a particular platform may not have advanced far enough to allow complete testing of the software code targeted for that platform.","A system and method for detecting accesses to non-existing hardware entities using a simulator environment is disclosed. In one embodiment, when an application running on a simulated target platform issues a transaction that involves accessing a hardware address, wherein the address is within a range of addresses allocated to a simulated hardware block, a set of instructions provided with the simulator are operable to determine if there exists a backing that corresponds to the transaction's address. If there is no backing (i.e., a control status register) associated with the address, an appropriate notification or warning is provided as a response.","In the drawings, like or similar elements are designated with identical reference numerals throughout the several views thereof, and the various elements depicted are not necessarily drawn to scale. Referring now to , depicted therein is a functional block diagram of a conventional computer system  wherein accesses to a non-existing entity caused by a user application program  are typically ignored. The computer system  includes a platform hardware environment  that can be organized in any known or heretofore unknown fashion, and may be comprised of uniprocessor or multiprocessor architectures. An OS kernel  supports an Application Programming Interface (API) layer  for facilitating communication between the software code of the user application  and the underlying hardware platform environment .","As is well known, the computer hardware forming the platform environment  is assigned a range of addresses that are used for effectuating access thereto pursuant to a transaction initiated by the user application . Further, the platform environment  may be partitioned into a plurality of hardware functionality blocks - through -N, each hardware functionality block having a corresponding range of address space. Each hardware functionality block is operable to support a range of hardware entities, such as processors, memory, mass storage devices and other peripherals, and the like, by further refining its address space. By way of illustration, an address range  of $FFF\u2013$FFFF is assigned to the hardware functionality block -N that is associated with hardware units - to -. An address refining mechanism, which will be described in further detail hereinbelow, is provided with the hardware functionality blocks for facilitating access to the various hardware units supported. In addition, a hardware functionality block includes one or more control status registers (CSRs) that are populated with appropriate initialization information, wherein each CSR manages access to a particular hardware unit depending on the address captured and refined by the hardware functionality block. Accordingly, when a transaction generated by the user application initiates a hardware access operation using an address that does not correspond to a properly initialized CSR (i.e., \u201cbacking\u201d) in a hardware functionality block, that access is essentially undefined (hence, illegal) and may be ignored by the hardware functionality block. However, the conventional hardware systems, as alluded to hereinabove in the Background section of the present patent application, do not issue any error reports or provide a suitable alarm or warning to the user indicating that access to a non-existent entity has been attempted. Also, in general, the hardware functionality block that captures the transaction and refines the address does not pause its operation or otherwise go \u201coff-line\u201d, either, on account of the attempted access to a non-existent entity.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2","b":["202","204","206","208","210","212","214"]},"Referring now to , depicted therein is a functional block diagram of an embodiment of a system  operable to support a simulator environment  wherein accesses to non-existent hardware entities by an application are advantageously detected. System  comprises a host machine  organized in any known computer architecture wherein a host OS  executing thereon is operable to provide a software platform. Simulator environment  is provided as a software rendition capable of running on the host OS, and may be embodied as an architectural simulator that can simulate a target computer platform .","Depending on design objectives, the target platform  may comprise a single processor, dual processor, or multiprocessor system. Application code  intended for execution, optimization, and maintenance on the target platform  is provided as a software code portion running in the simulator environment . Various hardware functionality blocks of the target platform are also simulated as part of the software rendition of the target system. Accordingly, a plurality of simulated hardware (SHW) blocks - through -M are provided as part of the simulator environment . Each SHW block is allocated an address range, wherein a particular SHW block may include one or more simulated CSRs for controlling access to appropriate partitions of the allocated hardware address space.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4","b":["312","1","300","401","312","1","401","402","404","406","1","406","408","1","408","312","1"]},"Referring now to , shown therein is a flow chart of the various steps of an embodiment of methodology for handling an application's access to a non-existent entity in the simulator environment depicted in . When a hardware access transaction is initiated by a user application executed on a simulator (block ), the transaction is extracted from the bus by an SHW whose address space contains the address associated with the transaction (block ). The captured address is further filtered and refined in the SHW block. The transaction type may also be determined therein (block ). A determination is made to verify whether there exists a populated CSR that corresponds to the refined hardware address location to which access is being attempted (decision block ). If there is a corresponding CSR, the access transaction is directed to a simulated hardware object based on the CSR's contents (block ) and the user application may continue to execute (block ). Otherwise, the simulator recognizes that an error condition has taken place. Further, a variety of error response mechanisms may be implemented such as, e.g., (i) reporting the error to the user; (ii) terminating the application that initiated access to a non-existent hardware entity; (iii) terminating the simulator; and (iv) providing an alert and continuing to execute the application. These response mechanisms are consolidated in block . It should be apparent that any combination of the responses may be implemented in a particular system.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6","b":["600","602","1","602","604","602","2","606","608","610","612","614","600"]},"Each processor complex may be provided with its own data structures, including run queues, counters, time-of-day information, notion of current process(es) and priority. Global data structures available for the entire MP system  are protected by means such as semaphores and spinlocks. Furthermore, in other implementations of the MP system, the processors may be arranged as \u201ccells\u201d wherein each cell is comprised of a select number of processors (e.g., four, six, or eight processors), interrupts, registers and other resources.","The architectural simulator program operable to simulate a hardware platform such as the MP system  is preferably provided with appropriate instructions to carry out the access detection system and method described in greater detail hereinabove. Any software application intended for execution on the MP system may, accordingly, be debugged, tested, and optimized on the architectural simulator even before the target hardware platform is completely assembled and verified.","Based on the foregoing, those skilled in the art should appreciate that method and apparatus have been described that may use an architectural simulator system to detect accesses to non-existent entities, whereby appropriate responses may be generated for the benefit of users and software developers. Based on the responses generated, accordingly, bugs in an application that cause such access transactions can be fixed early in the code development cycle before a target platform and associated application software are committed to production, where the ability to discover such bugs is substantially reduced while the potential for unknown software behavior remains high.","Although the invention has been particularly described with reference to certain illustrations, it is to be understood that the forms of the invention shown and described are to be treated as exemplary embodiments only. Various changes, substitutions and modifications can be realized without departing from the spirit and scope of the invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
