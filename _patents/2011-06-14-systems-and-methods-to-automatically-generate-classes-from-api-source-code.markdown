---
title: Systems and methods to automatically generate classes from API source code
abstract: According to some embodiments, Application Programming Interface (API) source code, including command design patterns, is determined to be executed as a runtime scenario. Class may then be automatically generated as linkable building blocks in accordance with the API source code and command design patterns. For example, API command classes and associated methods may be dynamically read using reflection, and a building block class associated with each API command class may be generated. Runtime readable embedded metadata may be planted in the building block classes, at least some of the metadata being provided by the reflection. According to some embodiments, a logical sequence of the building blocks classes may be linked in accordance with the runtime scenario.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08881127&OS=08881127&RS=08881127
owner: SAP AG
number: 08881127
owner_city: Walldorf
owner_country: DE
publication_date: 20110614
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["Some embodiments relate to systems and methods to automatically generate classes from Application Programming Interface (API) source code. More specifically, some embodiments are associated with the automatic generation of classes as linkable building blocks from API source code to be executed as, for example, a runtime scenario.","In some cases, a user might want to execute a runtime scenario to, for example, test Application Programming Interface (API) source code. The API source code might, for example, access and\/or modify thousands of records in an enterprise database. Similarly, the API source code might be associated with a logical business flow. Creating such runtime scenarios, however, can be difficult, time consuming, and error prone process. This may be especially true when the user is not familiar with the API layer and\/or the inner workings of various Operating System (OS) implementations.","Accordingly, a method and mechanism to efficiently, accurately, and automatically generate runtime scenarios to be executed may be provided in accordance with some embodiments described herein.","In some cases, a user might want to execute a runtime scenario to, for example, test API source code. The API source code might, for example, access and\/or modify thousands of records in an enterprise database. Similarly, the API source code might be associated with a logical business flow. Creating such runtime scenarios, however, can be difficult, time consuming, and error prone process. This may be especially true when the user is not familiar with the API layer and\/or the inner workings of various OS implementations.","Accordingly, a method and mechanism to efficiently, accurately, and automatically generate runtime scenarios to be executed may be provided in accordance with some embodiments described herein. For example,  is a block diagram of a system  that might be associated with an enterprise. The system  includes at least one data source  storing API source code to be executed as a runtime scenario. According to some embodiments, multiple data sources may be provided. Different data sources  may, for example, be associated with different business applications. According to some embodiments, one or more data sources  might be associated with table of an Enterprise Resource Planning (\u201cERP\u201d) system. Note that the records might be stored within physical tables of a database. The database may comprise a relational database such as SAP MaxDB, Oracle, Microsoft SQL Server, IBM DB2, Teradata and the like. As another example, the data sources  might be associated with a multi-dimensional database, an eXtendable Markup Language (\u201cXML\u201d) document, or any other structured data storage system. The physical tables of a database may be distributed among several relational databases, dimensional databases, and\/or other data sources.","A software server engine  may receive the API source code from the data source . The software server engine  may then perform operations in accordance with any of the embodiments described here. For example, the software server engine  may dynamically read API source command classes using reflection to help create a building block class  for each API command class. The software server engine  may also plant runtime readable embedded metadata (e.g., Java annotations) in the building block classes  to help a subsequent linking of blocks in a logical sequence in accordance with the runtime scenario. The linked building block classes  may be stored in a reusable runtime pool  to be accessed by multiple users and\/or devices . The devices  might be associated with, for example, Personal Computers (PC), servers, smart phones and\/or other mobile devices.","Note that  represents a logical architecture according to some embodiments, and actual implementations may include more or different components arranged in other manners. Moreover, each system described herein may be implemented by any number of devices in communication via any number of other public and\/or private networks. Two or more of devices may be located remote from one another and may communicate with one another via any known manner of network(s) and\/or a dedicated connection. Further, each device may comprise any number of hardware and\/or software elements suitable to provide the functions described herein as well as any other functions. Other topologies may be used in conjunction with other embodiments.","All systems and processes discussed herein may be embodied in program code stored on one or more computer-readable media. Such media may include, for example, a floppy disk, a CD-ROM, a DVD-ROM, magnetic tape, OR solid state Random Access Memory (RAM) or Read Only Memory (ROM) storage units. Embodiments are therefore not limited to any specific combination of hardware and software.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 1"],"b":["200","120"]},"At S, API source code to be executed as a runtime scenario may be determined by the software server engine . Moreover, the API source code may include \u201ccommand design patterns.\u201d As used herein, the phrase \u201ccommand design pattern\u201d may refer to object-oriented programming wherein an object is used to represent and\/or encapsulate the information needed to call a method at a later time. This information might include, for example, a method name, an object that owns the method, and\/or values for the method parameters.","According to some embodiments, the API source code may be associated with a database (e.g., an ERP database) storing records. For example, the API source code might be associated with record retrieval, record creation, record modification, and\/or record deletion. Note, however, that the API source code may be associated with operations other than those involving databases.","At S, classes may be automatically generated as linkable building blocks in accordance with the API source code and command design patterns. According to some embodiments, this automatic generation of classes may be associated with a software server or software server engine. Moreover, the linked logical sequence of building blocks classes might be accessed by a user via a device communicating with the software server. For example, a user might access components in a reusable code block to create a test scenario via a PC, a smart phone, and\/or a web interface.","Note that the automatic generation of classes may be performed in a number of different ways. For example,  is a flow diagram of a process  that might be associated with the software server engine  of  according to some embodiments. At S, the software server engine  might dynamically read API command classes and associated methods using \u201creflection.\u201d As used herein, the term \u201creflection\u201d may refer to, for example, an operation used for observing and\/or modifying program execution at runtime. In some cases, a reflection-oriented program component may monitor execution of an enclosure of code and modify itself according to a desired goal related to the enclosure. In Java, for example, reflection may allow for the inspection of classes, interfaces, fields and methods at runtime and\/or allow instantiation of new objects and invocation of methods.","At S, a building block class associated with each API command class may be generated. The automatically generated building block classes may be associated with, for example, input classes, output classes, and\/or command classes. According to some embodiments, a method associated with a building block class may correspond to an input class if the method name starts with \u201cset\u201d or \u201cadd.\u201d Similarly, a method associated with a building block class might correspond to an output class if the method name starts with \u201cget.\u201d Further note that each building block class might be associated a primitive input associated with user input and\/or non-primitive input associated with a dynamic input of data from another building block. According to some embodiments, primitive inputs may be defined by a user via a Graphical User Interface (\u201cGUI\u201d).","At S, runtime readable embedded metadata may be planted in the building block classes, at least some of the metadata being provided by the reflection. By way of example, Java annotations may be used to plant metadata in the building block classes. At S, a logical sequence of the building blocks classes may be linked in accordance with the runtime scenario. For example, an output of one building block class is assigned as in input to another building block class. According to some embodiments, the logically linked sequence of building blocks classes is reusable for other runtime scenarios. For example, the logically linked sequence of building block classes might be stored in a reusable code pool accessed by API consumers, a development team, a quality assurance team, and\/or a software customer.","Thus, embodiments described herein may be applicable for API's that are based on command design patterns. Dynamically reading API source command classes using reflection may help generate a building block class from each API command class. Moreover, planting runtime readable embedded metadata (e.g., Java annotations) in the block classes may help a user link a logical sequence of blocks to a scenario.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4","b":["400","400"]},"Each operation which may be done on a software server may be represented by a \u201ccommand class.\u201d In some cases, before the operation execution via the command class, the command class instance may consume objects which define the operation nature. These classes may be referred to as \u201cInput Classes.\u201d In some cases, after an operation has been executed data objects may be retrieved from the command class. These classes may be referred to as \u201cOutput Classes.\u201d Note that a class might be an Input Class to one Command and an Output Class to another command. Thus, the API may contain: (1) Command Classes (where a command is always command), (2) Input\/Output Classes (which may change roles according to the command operation).","Referring again to , the example  is associated with a retrieve records operation (commonly used in information systems). Note that if the software maintains an API in command design pattern, there will be a Command Class to represent the operation. In particular, the example  illustrates the content of a RetrieveLimitedRecordsCommand class. Each method in the command class starting with the characters \u201cset\u201d or \u201cadd\u201d may define one or more Input Classes for the command (and each parameter of the method may be an input class). Similarly, each method in the command class starting with the characters \u201cget\u201d may define an Output Class for the command (the method return type).","The process may initially create an object from the command class, and the set the Input Classes using the \u201cset\u201d or \u201cadd\u201d methods. The process may execute the command using an execute method and then get output classes (if needed) using the \u201cget\u201d methods. With respect to the example  of , the RecordResultSet  may be an output class to the command. Further, the setPageSize (int pageSize)  may represent how many records to retrieve and may be a primitive input class as described with respect to . Moreover, the setSearch (Search search)  may be an input class to the command.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 5","FIG. 5"],"b":"500"},"In this example, the process may create a RetrieveRecordsCommand instance. The process may then set input classes using \u201cset\u201d and\/or \u201cadd\u201d methods. Next, the process may execute the command using execute method, and use a getRecords( )method in order to get the Output Class. RecordResultDefinition may be associated with an array of the retrieved records, and Record[ ] may be extracted from this object. The process may then create a DeleteRecordsCommand instance, and set input classes using \u201cset\u201d and\/or \u201cadd\u201d methods. Among these, the process may set the Record[ ] in add Records( ) to specify which records to delete as illustrated by the arrow in . Finally, the command may be executed in order to delete the appropriate records. As a result, a logical sequence of two commands may provide a simple automatic scenario.","According to some embodiments, each API command may be associated with a corresponding building block class. In this way, a user can look at the building block class as a management unit for the represented command. The API code (command classes and input\/output classes) may already exist and facilitate an extension of the command class functionality in order to simplify scenario assembling (e.g., connections between operations). The building block class may set the Input Classes into the command, execute, and extract the Output Classes as appropriate. Note that building block class may be reusable class once it is created. For example, other users may access it to perform a test case and\/or command functionality (assuming the API source has not changed).","The building block class may contain the command class, and a scenario may be constructed as a logical sequence of building block classes. Note that the building block class may, according to some embodiments, represent each Input Class and Output Class of the Command in Keys in order to ease Input and Output between building clock classes. Further, the output of a first building block class may be an input to a second building block class. Moreover, each building block class may pass output to any other building block class in a scenario.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 6","b":["600","610","610","610"],"sub":["\u2014","\u2014"]},"Next, a code portion  may create a command instance and the building block class example  will contain the command, namely RetrieveLimitedRecordsCommand cmd=new RetriveLimitedRecordsCommand (new UserSessionContext( )). A code portion  may then dynamically set the input classes, followed by execution of the command, namely cmd.execute( ). Finally a code portion  may get command output outputs via code generated automatically.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 7","FIG. 7"],"b":["700","700","700","710","720","720","700","740","750"]},"The processor  communicates with a storage device . The storage device  may comprise any appropriate information storage device, including combinations of magnetic storage devices (e.g., a hard disk drive), optical storage devices, and\/or semiconductor memory devices. The storage device  stores a program  and\/or software server engine application  for controlling the processor . The processor  performs instructions of the programs , , and thereby operates in accordance with any of the embodiments described herein. For example, the processor  may get command pattern software API source code, locate command classes, create building block classes, and\/or generate a scenario by linking a series of building block classes.","The programs ,  may be stored in a compressed, uncompiled and\/or encrypted format. The programs ,  may furthermore include other program elements, such as an operating system, a database management system, and\/or device drivers used by the processor  to interface with peripheral devices.","As used herein, information may be \u201creceived\u201d by or \u201ctransmitted\u201d to, for example: (i) the software server engine  from another device; or (ii) a software application or module within the software server engine  from another software application, module, or any other source.","According to some embodiments, the storage device  may further store API source code  including command design patterns. Note that the API source code might instead be received from a remote data store via communication device . The storage device  may further store a reusable code pool  storing building block classes and\/or scenarios (e.g., linked sequences of building block classes).","Users may then access the reusable code pool  to create and\/or modify building block classes and\/or scenarios. For example,  illustrates a GUI  according to some embodiments. In particular, the GUI  may include a screen area (upper left in ) to display and\/or allow for the selection of available Java API commands. Similarly, the GUI  may include a screen area (lower left in ) to display a command description associated with a selected Java API commands. Further, the GUI  may include a screen area (upper right in ) to display and\/or allow for the selection of building block class inputs, associated including methods, method attributes, and\/or parameter attributes. Finally, the GUI  may include a screen area (lower right in ) to display and\/or allow for the selection of building block class outputs, including associated methods, return type attributes, and\/or building block class output attributes.","Thus, some embodiments may be applicable for APIs that are based on command design patterns. Building block classes may be generated using dynamically read API source command classes via reflection, and runtime readable embedded metadata (e.g., Java Annotations) may be planted into the building block classes to facilitate linking the building block classes into a logical sequence scenario. The linkable building block classes may therefore provide an ability to compose test scenarios simulating automatic logical business flows on various OS. Moreover, enhanced efficiency may be provided for an API consumer enabling him or her to allocate more time focused on business logic (and thus, reduce coding time). In addition, a common convention and reusable code pool may be provide for use by API consumers, including development teams, quality teams, and\/or software customers.","Moreover, some embodiments may provide robust readiness tests that customers may perform before upgrading their systems and allow accelerated API infrastructure layer construction for development groups. Still further, some embodiments may ease automatic test scenario composition for quality assurance teams and allow for the implementation of system business scenarios utilizing APIs.","The following illustrates various additional embodiments and do not constitute a definition of all possible embodiments, and those skilled in the art will understand that the present invention is applicable to many other embodiments. Further, although the following embodiments are briefly described for clarity, those skilled in the art will understand how to make any changes, if necessary, to the above-described apparatus and methods to accommodate these and other embodiments and applications.","Although embodiments have been described with respect to particular types of data, note that embodiments may be associated with other types of information. For example, sales orders, financial information, and health data may be processed in accordance with any of the embodiments described herein.","As described herein a building block class may represent each Input Class and Output Class of the Command in Keys in order to ease Input and Output between building clock classes. Further, the output of a first building block class may be an input to a second building block class. Note that each building block class may pass output to any other building block class in a scenario. As described with respect to , a retrieve records command may, for example, be associated with a code portion  that defines a key for each input and output. Consider now , which illustrates an example  associated with a simple use case scenario  in accordance with some embodiments. Note that one reason to give Keys to each input\/output may be the ability to refer the key which is given in the readable metadata comments (e.g., annotations) as an \u201cInner Key.\u201d","While a user of an application may define a scenario from a building block pool, he or she may need to define an \u201cOuter Key\u201d for each output and map the output to inputs according to the Outer key. For example, the scenario  of  includes test cases TC (associated with a write to a virtual map  that exists in run time), TC, and TC (associated with a read from the virtual map). If all examples were as simple as the scenario  of , the implementation of a separate Outer Key might not be required.","Consider, however,  which illustrates an example  associated with a more complex use case scenario in accordance with some embodiments. In this case, two connection test cases of the same class may be created (having Outer Key: Connection1 and Outer Key: Connection2) along with test case X and test case Y, which each require a connection as an input. That is, the test case responsible for connection creation may be generic such that it omits as an output a connection object from different variation according to inputs. For example, two databases might need to be connected with during a scenario, and yet there may be only a single test case that creates connections. As a result, if the Inner Key is utilized by the metadata of a test case (e.g., as was done in the \u201cVirtual Map\u201d  illustrated in ) it may only be possible to contain a single connection at a given time (e.g., because a second connection would override the first connection since they have the same key). To avoid such a result, an Outer Key may provide the flexibility to maintain multiple objects of the same type in a virtual map even when they are created by the same test case.","Moreover, while embodiments have been illustrated using particular programming languages, embodiments may be implemented in any other of a number of different ways. For example, some embodiments might be associated with C++ or any other programming language.","Embodiments have been described herein solely for the purpose of illustration. Persons skilled in the art will recognize from this description that embodiments are not limited to those described, but may be practiced with modifications and alterations limited only by the spirit and scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
