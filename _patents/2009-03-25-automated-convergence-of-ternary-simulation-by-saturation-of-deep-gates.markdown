---
title: Automated convergence of ternary simulation by saturation of deep gates
abstract: A method, system and computer program product for X-Saturated ternary simulation based reduction. An X-Saturated ternary simulation (XSTS) utility, which executes on a computer system, receives design information, where the design information includes a netlist. The XSTS utility initializes one or more data structures and/or variables and simulates, in a ternary fashion, the netlist at a time value by applying logical X values to all RANDOM gates of the netlist and to registers marked X_SATURATED. For each register of the netlist XSTS utility: determines whether or not the register departs from its expected prefix behavior, and if the register departs from its expected prefix behavior, the register is marked as X_SATURATED and the current state is updated with an X value upon the register. XSTS utility can store the current state in a data structure and can use the information from the data structure to simplify the design.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08171437&OS=08171437&RS=08171437
owner: International Business Machines Corporation
number: 08171437
owner_city: Armonk
owner_country: US
publication_date: 20090325
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF ILLUSTRATIVE EMBODIMENTS","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["1. Technical Field","The present invention generally relates to verification of optimized designs. More specifically, the present invention relates to design size reduction using ternary simulation.","2. Description of the Related Art","Many applications can benefit by reducing the size of a design representation while preserving functionality. For example, synthesis often includes an explicit objective to reduce design size and can benefit verification, since verification can often be more efficient on a reduced or smaller design. However, most techniques for design reduction tend to be rather computationally expensive, particularly those that require sequential analysis.","Ternary simulation is a technique that analyzes behavior of a design under \u201c0\u201d, \u201c1\u201d, \u201cX\u201d valuations to the gates of the design (where \u201cX\u201d is a \u201cdo not care\u201d or undetermined value representing either \u201c0\u201d or \u201c1\u201d). By assigning values of \u201cX\u201d to the valuations of primary inputs and by simulating the design until a state vector is repeated, identification of gates that are constant or pairs of gates that are equivalent can be determined. Simplification of the design can be accomplished by simplifying the gates of the resulting ternary sequence accordingly. However, there is at least one fundamental weakness of ternary simulation-based reduction: it may not converge with reasonable resources on temporally \u201cdeep\u201d designs. For instance, a design with a 64-bit counter can require 2^64 (i.e., 2 to the power of 64) time frames or iterations of a simulation before convergence is possible. This can be too computationally expensive to perform. Accordingly, there is a need for a method, a system and\/or a computer program product for convergence (repetition) of ternary simulation by saturating \u201cdeep\u201d gates to a ternary \u201cX\u201d and an optimization of resulting reductions under a fixed number of ternary simulation steps.","Disclosed are a method, a system and a computer program product for X-Saturated ternary simulation based reduction. A X-Saturated ternary simulation (XSTS) utility, which executes on a computer system, receives design information, where the design information includes a netlist and where the XSTS utility receives the design information from one or more of a user, a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and\/or a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.). After receiving the design information, the XSTS utility initializes a hash table, sets a converged value to zero, sets a time value to an initial value (e.g., a value of zero). XSTS utility sets a current state and simulates, in a ternary fashion, the netlist at the time value by applying logical X values to all RANDOM gates (e.g., primary inputs) of the netlist and to registers marked X_SATURATED of all registers of the netlist.","For each register (or latch) of the netlist, XSTS utility determines whether or not the register is not already marked as X_SATURATED and the register is found to depart from its expected prefix behavior. If the register is not already marked as X_SATURATED and the register is found to depart from its expected prefix behavior, XSTS utility marks the register as X_SATURATED and updates the current state with an X value upon the register. XSTS utility searches the hash table for the current state and determines whether or not the current state was found in the hash table. If the current state was found in the hash table, XSTS utility sets the converged value to one. If the current state was not found in the hash table, XSTS utility inserts the current state into the hash table. XSTS utility determines whether or not one or more resources are exceeded. If the one or more resources are not exceeded, XSTS utility increments the time value by one and repeats from setting the current state. If the one or more resources are exceeded, XSTS utility determines whether or not the converged value is not zero. If the converged value is zero, XSTS utility indicates that the design could not be simplified. XSTS utility can indicate that the design could not be simplified by outputting a message to a user, storing a message in a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and\/or sending a message to a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.). If the converged value is not zero, XSTS utility simplifies the design using information from the hash table and outputs the simplified design. XSTS utility can output the simplified design by outputting the simplified design to a display, storing the simplified design in a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and\/or sending the simplified design to a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.).","The above as well as additional objectives, features, and advantages of the present invention will become apparent in the following detailed written description.","The illustrative embodiments provide a method, system and computer program product for X-Saturated ternary simulation based reduction, where the X-Saturated ternary simulation based reduction simplifies at least a portion of an integrated circuit embodied by a netlist. An X-Saturated ternary simulation (XSTS) utility, which executes on a computer system, receives design information, where the design information includes a netlist and where the XSTS utility receives the design information from one or more of a user, a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and\/or a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.).","After receiving the design information, the XSTS utility initializes a hash table, sets a converged value to zero, sets a time value to an initial value (e.g., a value of zero). XSTS utility sets a current state and simulates, in a ternary fashion, the netlist at the time value by applying logical X values to all RANDOM gates (e.g., primary inputs) of the netlist and to registers marked X_SATURATED of all registers of the netlist. For each register (or latch) of the netlist, XSTS utility determines whether or not the register is not already marked as X_SATURATED and the register is found to depart from its expected prefix behavior. If the register is not already marked as X_SATURATED and the register is found to depart from its expected prefix behavior, XSTS utility marks the register as X_SATURATED and updates the current state with an X value upon the register.","XSTS utility searches the hash table for the current state and determines whether or not the current state was found in the hash table. If the current state was found in the hash table, XSTS utility sets the converged value to one. If the current state was not found in the hash table, XSTS utility inserts the current state into the hash table. XSTS utility determines whether or not one or more resources are exceeded. If the one or more resources are not exceeded, XSTS utility increments the time value by one and repeats from setting the current state. If the one or more resources are exceeded, XSTS utility determines whether or not the converged value is not zero. If the converged value is zero, XSTS utility indicates that the design could not be simplified. For example, XSTS utility can indicate that the design could not be simplified by outputting a message to a user, storing a message in a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and\/or sending a message to a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.). If the converged value is not zero, XSTS utility simplifies the design using information from the hash table and outputting the simplified design. For example, XSTS utility can output the simplified design by outputting the simplified design to a display, storing the simplified design in a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and\/or sending the simplified design to a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.).","In the following detailed description of exemplary embodiments of the invention, specific exemplary embodiments in which the invention may be practiced are described in sufficient detail to enable those skilled in the art to practice the invention, and it is to be understood that other embodiments may be utilized and that logical, architectural, programmatic, mechanical, electrical and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims and equivalents thereof.","Within the descriptions of the figures, similar elements are provided similar names and reference numerals as those of the previous figure(s). Where a later figure utilizes the element in a different context or with different functionality, the element is provided a different leading numeral representative of the figure number. The specific numerals assigned to the elements are provided solely to aid in the description and not meant to imply any limitations (structural or functional or otherwise) on the described embodiment.","It is understood that the use of specific component, device and\/or parameter names (such as those of the executing utility\/logic described herein) are for example only and not meant to imply any limitations on the invention. The invention may thus be implemented with different nomenclature\/terminology utilized to describe the components\/devices\/parameters herein, without limitation. Each term utilized herein is to be given its broadest interpretation given the context in which that terms is utilized. Specifically, as utilized herein, the following terms are defined as follows: a \u201cRANDOM gate\u201d or \u201cRANDOM\u201d is a primary input (e.g., an input of the netlist that does not originate from a gate or register of the netlist); and a value of \u201cX\u201d is logical value representing a \u201cdon't care\u201d value or a \u201cnot determined\u201d value, where, X could be either a logical \u201c0\u201d or a logical \u201c1\u201d but not known or determined to be either. In one or more embodiments, a primary input is an input to the netlist.","With reference now to the figures, and beginning with , there is depicted a block diagram representation of an example data processing system (DPS)  as utilized within one embodiment. DPS  can be a computer, a portable device, such as a personal digital assistant (PDA), a smart phone, and\/or other types of electronic devices that can generally be considered processing devices. As illustrated, DPS  includes at least one processor or central processing unit (CPU)  connected to system memory  via system interconnect\/bus . Also connected to system bus  is input\/output (I\/O) controller , which provides connectivity and control for input devices, of which pointing device (or mouse)  and keyboard  are illustrated. I\/O controller  also provides connectivity and control for output devices, of which display  is illustrated. Additionally, multimedia drive  (e.g., compact disk read\/write (CDRW), digital video disk (DVD) drive, etc.) and USB (universal serial bus) port  are illustrated, coupled to I\/O controller . Multimedia drive  and an USB port  enable insertion of a removable storage device (e.g., optical disk, \u201cthumb\u201d drive, etc.) on which data\/instructions\/code may be stored and\/or from which data\/instructions\/code may be retrieved. DPS  also includes storage , within\/from which data\/instructions\/code may also be stored\/retrieved.","DPS  is also illustrated with network interface device (NID) , by which DPS  may connect to one or more networks, such as network . In one or more embodiments, network  may include and\/or be coupled to another network, such as a wide area network (e.g., a wide area corporate network, the Internet, etc.), a local area network (LAN), a public switched telephone network (PSTN), or a virtual private network (VPN), among others. In one embodiment, the Internet represents\/is a worldwide collection of networks and gateways that may utilize one or more protocols (e.g., Internet Protocol (IP), Transmission Control Protocol (TCP), User Datagram Protocol (UDP), Internet Control Message Protocol (ICMP), etc.). NID  may be configured to operate via wired and\/or wireless connection to an access point of one or more networks. Connection to network  may be utilized to establish with one or more servers, such as server . In one embodiment, server  provides one or more of data, instructions, and code for execution on DPS .","In one or more embodiments, server  includes a software deploying server, and DPS  communicates with the software deploying server  via network  using network interface device . In one example, XSTS utility  (which may include various functionalities associated with XSTS utility ) of server  may be deployed from\/on network , via software deploying server . With this configuration, software-deploying server  performs all or almost all of the functions associated with the execution of XSTS utility . Accordingly, DPS  is not required to utilize internal computing resources of DPS  to execute XSTS utility . For example, XSTS utility  is executed on server , while user interactions (e.g., via keyboard, mouse, display, etc.) are conducted through DPS  and are communicated between server  and DPS  via network .","In one or more embodiments, XSTS utility  may be accessed through network  using network file system (NFS) , where CPU  executes instructions of XSTS utility  as they are received from software deploying server .","In addition to the above described hardware components of DPS , various features of the invention are completed\/supported via software, firmware, code, and\/or logic stored within memory  and\/or other storage (e.g., storage ) and executed by CPU . Thus, for example, illustrated within memory  are a number of software\/firmware\/logic components, including an operating system (OS)  (e.g., Microsoft Windows\u00ae, a trademark of Microsoft Corp, or GNU\u00ae\/Linux\u00ae, registered trademarks of the Free Software Foundation and The Linux Mark Institute), one or more applications , and XSTS utility  which executes on CPU  to provide one or more reports of minterms of two or more timing points (positive and inverted) using logic from an existing optimized netlist by tracing the optimized netlist from timing point to timing point. In actual implementation, XSTS utility  may be combined with or incorporated within application(s)  to provide a single executable component, collectively providing the various functions of each individual software component when the corresponding combined code is executed by the CPU . For simplicity, XSTS utility  is illustrated and described as a stand alone or separate software\/firmware component, which provides specific functions, as described below.","CPU  executes XSTS utility  as well as OS , which supports the user interface features of XSTS utility . In one embodiment, XSTS utility  generates\/provides at least one graphical user interface (GUI) to enable user interaction with, or manipulation of, the functional features of XSTS utility . Certain functions supported and\/or implemented by XSTS utility  generate processing logic executed by processor and\/or device hardware to complete the implementation of that function. For simplicity of the description, the collective body of code that enables these various features is referred to herein as XSTS utility . The software code\/instructions\/logic provided by XSTS utility  include: (a) code\/logic for receiving design information, where the design information includes the netlist; (b) code\/logic for initializing a hash table; (c) code\/logic for setting a converged value to zero; (d) code\/logic for setting a time value to an initial value; (e) code\/logic for setting a current state; (f) code\/logic for simulating, in a ternary fashion, the netlist at the time value by applying logical X values to all RANDOM gates of the netlist and to registers marked X_SATURATED of all registers of the netlist; (g) code\/logic for performing an iterative loop where for each register of the netlist, performing: determining whether or not the register is not already marked as X_SATURATED and the register is found to depart from its expected prefix behavior; and if the register is not already marked as X_SATURATED and the register is found to depart from its expected prefix behavior: marking the register as X_SATURATED; and updating the current state with an X value upon the register; (h) code\/logic for searching for the current state in the hash table; (i) code\/logic for determining whether or not the current state was found in the hash table; (j) code\/logic for if the current state was found in the hash table, setting the converged value to one; and (k) code\/logic for if the current state was not found in the hash table, inserting the current state into the hash table.","The software code\/instruction\/logic provide by XSTS utility  further include: (l) code\/logic for determining whether or not one or more resources are exceeded; (m) code\/logic for if the one or more resources are not exceeded: incrementing the time value by one; and performing the code\/logic from (e); and (n) code\/logic for if the one or more resources are exceeded: determining whether or not the converged value is not zero; if the converged value is zero, indicating that the design could not be simplified; and if the converged value is not zero: simplifying the design using information from the hash table; and outputting the simplified design. According to one or more embodiments, when CPU  executes XSTS utility , DPS  initiates a series of functional processes that enable the above functional features as well as additional features\/functionality. These features\/functionality are described in greater detail below within the description of .","Those of ordinary skill in the art will appreciate that the hardware components and basic configuration depicted in  can vary. The illustrative components within DPS  are not intended to be exhaustive, but rather are representative to highlight essential components that are utilized to implement the present invention. For example, other devices\/components may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural or other limitations with respect to the presently described embodiments and\/or the general invention. The data processing system depicted in  may be, for example, an IBM eServer pSeries system, a product of International Business Machines Corporation in Armonk, N.Y., running the Advanced interactive Executive (AIX) operating system or LINUX operating system.","With reference now to , a block diagram of an exemplary netlist is illustrated. In one or more embodiments, the netlist is represented by a directed graph with vertices representing gates (e.g., gates A-R and registers A and B) and edges representing interconnections among the gates. The gates include associated functions. These associated functions can include constants, primary inputs (referred to as RANDOM gates), combinational logic (e.g., AND, OR, XOR, NAND, NOR, etc.), and sequential elements (referred to as registers or latches). The netlist receives information from inputs A-L, and inputs A-L are primary inputs, since they are inputs of the netlist that do not originate from a gate or register of the netlist.","As shown, gate A includes inputs A-C, is coupled to a gate F, and is coupled gate I via register (or latch) A. Gate B includes inputs D-F and is coupled to gate F. Gate C includes inputs G and H and is coupled to gates F and G. Gate D includes inputs I and J and is coupled to gates F and G. Gate E includes inputs K and L, is coupled to gate G, and is coupled to gate L via register A. Gate F is coupled to gate H via register A, and gate G is coupled to gates H and J-L via register A. Gate H is coupled to gates I-K. Gate I is coupled to gate M. Gate J is coupled to gates M and N. Gate K is coupled to gates N and O. Gate L is coupled to gate O and is coupled to gate R via register (or latch) B. Gate M is coupled to gate P via register B. Gate N is coupled to gates P and Q via register B. Gate O is coupled to gates Q and R via register B. Gates P-R have respective outputs A-C, as shown. In one or more embodiments, register A and\/or register B can include one or more registers or latches. For example, register A can include four registers or latches to perform its functionality.","In one or more embodiments, each register includes two associated functions: its initial-value function and its next-state function. In one example, for each register: the value appearing at the register's initial-value at time \u201c0\u201d (e.g., \u201cinitialization\u201d, \u201creset time\u201d, \u201cinitial time\u201d, etc.) is applied as the value of the register; and the value appearing at the register's next-state function at time \u201ci\u201d is applied to the register at time \u201ci+1\u201d. Often gates are analyzed using binary analysis where every gate will take a \u201c0\u201d or a \u201c1\u201d value over time.","In one or more embodiments, XSTS utility  utilizes ternary analysis where every gate will take a \u201c0\u201d, a \u201c1\u201d, or an \u201cX\u201d values over time. For example in a two-input AND gate, if either input of the AND gate evaluates to \u201c0\u201d, the output of the AND gate must be \u201c0\u201d regardless of a value of the other input due to the logical properties of the gate. However, if none of the inputs of the gate evaluate to \u201c0\u201d and at least one of the inputs evaluates to \u201cX\u201d, the output of the gate evaluates to \u201cX\u201d.","Turning now to , a method for reducing the size of a design is illustrated, in accordance with one or more embodiments. Although the method illustrated in  may be described with reference to components shown in , it should be understood that this is merely for convenience and alternative components and\/or configurations thereof can be employed with implementing one or more methods. Key portions of the method illustrated in  can be completed by XSTS utility  executing on CPU  within DPS  and controlling specific operations of\/on DPS . The method is, thus, described from the perspective of either\/both XSTS utility  and DPS .","The method of  begins at block  and proceeds to block  where XSTS utility  receives design information. The design information includes a netlist and\/or information that indicate the netlist or a location of the netlist, and the design information can be received from one or more of a user, an application, a data file, database, a memory, a disk, a network, etc. At block  XSTS utility  initializes a hash table. For example, initializing the hash table can include allocating memory (e.g., RAM, disk space, etc.) and\/or setting one or more values in the hash table to a default value. At block , XSTS utility  a converged value is set to zero (e.g., a logical false value), and at block , XSTS utility  sets a time value to zero (e.g., an initial time). At block , XSTS utility  sets and\/or initializes a current state (e.g., a current state of the method or process being performed). In one or more embodiments, the current state can be stored in one or more values (e.g., one or more values of a data structure stored in a memory and\/or a disk). At block , XSTS utility  performs ternary-simulates a design at the time value applying \u201cX\u201d values to all RANDOM gates of a netlist of the design. At block , XSTS utility  determines whether or not the current state is in the hash table.","If the current state is in the hash table, XSTS utility  proceeds to block  and sets the converged value to one (e.g., a logical true value). At block , XSTS utility  determined whether or not the converged value does not equal zero (e.g., a logical not false value). If the converged value does not equal zero, XSTS utility  simplifies the design using the hash table information at block  and proceeds to block  where XSTS utility  outputs the simplified design. For example, XSTS utility  can output the simplified design to one or more of a display, a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.), among others. XSTS utility  proceeds to block  where XSTS utility  ends the method. If the converged value equals zero, XSTS utility  proceeds to block  where XSTS utility  outputs that the design is not simplified. For example, XSTS utility  can output that the design is not simplified to one or more of a display, a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.), among others. XSTS utility  proceeds to block  where XSTS utility  ends the method.","If the current state is not in the hash table (with reference to block ), XSTS utility  proceeds to block , where XSTS utility  inserts the current state into the hash table. At block , XSTS utility  determines whether or not resources are exceeded. For example, the resources may include memory, disk space, time (e.g., wall clock time), and\/or a time value upper bound (e.g., an upper bound for a number of iterations), among others. If the resources are not exceeded, XSTS utility  proceeds to block , where XSTS utility  increases the time value by one and proceeds to block . If the resources are exceeded, XSTS utility  proceeds to block .","With reference to the method illustrated in , XSTS utility  injects \u201cX\u201d values for all RANDOM gates until the current state of the design repeats an earlier state or until resources are exceeded. If resources are exceeded, then this indicates that XSTS utility  was unable determine a convergence, and, hence, no reductions based upon the partial data were possible. Otherwise, a state has been repeated. For example, at some time \u201ci\u201d the state occurred, and at some later time \u201ci+j\u201d the state occurred again. In one or more embodiments, this state repetition can indicate that the behavior from time \u201ci\u201d to \u201ci+j\u201d may be repeated infinitely. Since the \u201cX\u201d values for RANDOMs represent any possible sequence of Boolean valuations to these gates, the corresponding sequence of values determined by XSTS utility  during this repetition represents an exhaustive behavior of the design. Thus, XSTS utility  at block  can use information of the states stored in the hash table to determine a simplification potential. In one or more embodiments, one or more input parameters can require that simplified gates can never evaluate to \u201cX\u201d while XSTS utility  performs the method illustrated in  from time \u201c0\u201d (e.g., initial state) to \u201ci+j\u201d. For example, if a gate always evaluates to a constant \u201c0\u201d or a constant \u201c1\u201d in states stored in the hash table, the gate can be merged to its constant value. Similarly, if XSTS utility  determines that two gates always evaluate to the same non-\u201cX\u201d value in states stored in the hash table, the two gates can be merged together. In one or more embodiments, XSTS utility  cannot merge a gate that evaluates to an \u201cX\u201d, since the gate's behavior has not been determined as being equal to a constant or to another gate.","A possible drawback of ternary simulation-based reduction is that convergence may not occur within a reasonable execution time for certain design styles. In one example, a design may include a (large) counter, e.g., a 64-bit counter. A ternary simulation of such a design may not converge until 2^64 (i.e., 2 to the power of 64) time frames or iterations. In another example, a design can include a Linear Feedback Shift Register (LFSR) where a ternary simulation will not converge until a number of time steps or iterations exceeds a period of the LFSR.","Thus, in one or more embodiments, XSTS utility  uses \u201cX-saturation\u201d to accelerate convergence of a ternary simulation (i.e., reducing a number of ternary simulation time frames or iterations until a repetition is detected). In some instances, convergence does not occur because some gates depart from their \u201cregular prefix behavior\u201d up until a specific number of time frames or iterations. In one example with reference to the 64-bit counter discussed above, a limit of at most 2^10 or 1024 time frames or iterations in a simulation for this counter is possible. For instance, a property of counters includes the nth least significant bit toggles every 2^(n\u22121), i.e., 2 to the power of n\u22121, time frames or iterations. Thus, at the 1023rd time step or iteration, XSTS utility  can determine that the lower 10 bits of the counter behave periodically and the upper 54 bits of the counter have constant values of \u201c0\u201d. At and\/or after the 1024th tine-frame, the 11th least significant bit toggles. Accordingly, in one or more embodiments, XSTS utility  replaces such gates that depart from their regular prefix behavior by the value \u201cX\u201d. This aids in convergence without exhausting available resources. In the 64-bit counter example, by \u201cX-saturating\u201d bit  after 2^10 time frames or iterations of the ternary simulation, bit  can toggle after another 2^10 time frames or iterations of the ternary simulation. If XSTS utility  turns \u201cX-saturate\u201d bit  at that point, bit  can toggle after another 2^10 time frame or iterations instead of 2^11 time frames or iterations. Accordingly, XSTS utility  can saturate earlier.","In one or more embodiments, XSTS utility  may limit the analysis to gates that depart from their expected behavior to only registers alone. For instance, registers can be a root cause of behavior departures since RANDOMs always evaluate to \u201cX\u201d and every other gate is a combinational function of registers and RANDOMs. By replacing such registers by \u201cX\u201d, XSTS utility  breaks the dependence of subsequent regular prefix behavior departure of other registers on the signals being \u201cX-saturated\u201d. For example, a netlist may include M registers which would depart from their regular prefix behavior. After XSTS utility  begins \u201cX-saturation\u201d at time N, XSTS utility  will converge a simulation within N*M (i.e., N multiplied by M) time frames or iterations, whereas without \u201cX-saturation\u201d convergence may not happen until N*2^M (i.e., N multiplied by 2 to the power of M) timeframes or iterations. An exemplary modified version of the ternary simulation framework, that integrates X-saturation, is provided as a method illustrated in , according to one or more embodiments. One difference is that upon some configurable X_SATURATIONTIME value (e.g., configurable by a user, an application, from a data file and\/or database, etc.), XSTS utility  will check to see if an unsaturated register departs from its prefix behavior. For example, if the register has been constant \u201c0\u201d until the X_SATURATION_TIME and if XSTS utility  determines a change of value from \u201c0\u201d to \u201c1\u201d at a current time frame or iteration, the register has departed from its prefix behavior. When XSTS utility  determines such a departure, XSTS utility  marks the register as \u201cX-saturated\u201d, and thereafter XSTS utility  will evaluate the register to \u201cX\u201d. In one or more embodiments, reductions based upon \u201cX-saturated\u201d values are still valid, since \u201cX-saturation\u201d may only reduce the amount of merging that will occur (i.e., XSTS utility  cannot merge a gate that evaluates to \u201cX\u201d), and convergence through state repetition over-approximated for all possible design behavior.","Turning now to , a method for reducing the size of a design is illustrated, in accordance with one or more embodiments. Although the method illustrated in  can be described with reference to components shown in , it should be understood that this is merely for convenience and alternative components and\/or configurations thereof can be employed with implementing one or more methods. Key portions of the method illustrated in  can be completed by XSTS utility  executing on CPU  within DPS  and controlling specific operations of\/on DPS . The method is, thus, described from the perspective of either\/both XSTS utility  and DPS .","The method of  begins at block  and proceeds to block  where XSTS utility  receives design information. The design information includes a netlist and\/or information that indicate the netlist or a location of the netlist, and the design information can be received from one or more of a user, an application, a data file, database, a memory, a disk, a network, etc. At block  XSTS utility  initializes a hash table. For example, initializing the hash table can include allocating memory (e.g., RAM, disk space, etc.) and\/or setting one or more values in the hash table to a default value. At block , XSTS utility  sets a converged value to zero (e.g., a logical false value), and at block , XSTS utility  sets a time value to zero (e.g., an initial time). At block , XSTS utility  sets a current state (e.g., a current state of the method or process being performed). In one or more embodiments, the current state can be stored in one or more values (e.g., one or more values of a data structure stored in a memory and\/or a disk). At block , XSTS utility  ternary-simulates a design at the time value applying \u201cX\u201d values to all RANDOM gates of a netlist of the design and to registers marked as X_SATURATED of all registers of the netlist of the design.","For each register of the netlist of the design, XSTS utility  performs one or more of blocks -, as shown. At block , XSTS utility  determines whether or not the register is not already marked as X_SATURATED and the register is found to depart from its expected prefix behavior. If so, XSTS utility  proceeds to block , and XSTS utility  marks the register as X_SATURATED. At block , XSTS utility  updates the current state with an \u201cX\u201d value upon the register.","At block , XSTS utility  searches for the current state in the hash table. At block , XSTS utility  determines whether or not the current state is found in the hash table. If the current state is found in the hash table, XSTS utility  proceeds to block , where XSTS utility  sets the converged value to a non-zero value, and XSTS utility  proceeds to block . If the current state is not found in the hash table, XSTS utility  proceeds to block , where XSTS utility  inserts the current state into the hash table, and XSTS utility  proceeds to block . At block , XSTS utility  determines whether or not the resources have been exceeded. For example, the resources may include memory, disk space, time (e.g., wall clock time), and\/or a time value upper bound (e.g., an upper bound for a number of time frames or iterations), among others. If resources have not been exceeded, XSTS utility  proceeds to block , where XSTS utility  increments the time value by one, and XSTS utility  proceeds to block . If the resources have been exceeded, XSTS utility  proceeds to block , where XSTS utility  determines whether or not the converged value is not equal to zero (e.g., a logical false value). If the converged value is equal to zero, XSTS utility  proceeds to block  where XSTS utility  outputs that the design is not simplified. For example, XSTS utility  can output that the design is not simplified to one or more of a display, a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.), among others. At block , XSTS utility  ends the method. If the converged value is not equal to zero (e.g., a logical value that is not false), XSTS utility  simplifies the design using the hash table information at block . At block , XSTS utility  outputs the simplified design. For example, XSTS utility  can output the simplified design to one or more of a display, a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.), among others. XSTS utility  proceeds to block , where the method ends.",{"@attributes":{"id":"p-0046","num":"0045"},"b":["100431","145","145","145","145","145","425","425","145","430","145","425","145","145","145"],"figref":"FIG. 4B"},"In one or more embodiments, XSTS utility  can relax the periodic check to be a delayed periodic check (i.e., after some initial number of time frames or iterations during which a gate may behave erratically), and XSTS utility  can, thereafter, check for periodic behavior. In an example, XSTS utility  performs the delayed periodic check in two ways: (1) the time frame or iteration after which XSTS utility  checks gate behavior may be controlled using a MIN_CONSISTENT_TIMEFRAME parameter (e.g., a configurable number of time frames or iterations); and (2) as discussed further below, a netlist could have an initial set of time frames or iterations where the netlist monotonically acquires more or less \u201cX\u201d values. In one or more embodiments, XSTS utility  uses the termination of the initial set of time frames or iterations to represent a time frame or iteration where XSTS utility  begins checking for regular behavior of gates.","As discussed above regarding the 64-bit counter, even with \u201cX-saturation\u201d, XSTS utility  may require a large number of time frames or iteration to achieve a convergence. Thus, in one or more embodiments, XSTS utility  may employ a secondary \u201cX-saturation\u201d mechanism to ensure that a ternary simulation converges within a specified bound. For example, while a particular dependency of other registers on another register being \u201cX-saturated\u201d may be broken, there may still be a dependency on other gates (e.g., lower-order counter bits, which have periodic behavior with adequately small periodicity). XSTS utility  can overcome this issue by propagating \u201cX\u201d values upon saturation to a set of registers in a fan-out of those gates being saturated. In other words, rather than merely saturating register \u201cr\u201d at a point in time, XSTS utility  can identify those registers in the fan-out of \u201cr\u201d and saturate those as well. In one or more embodiments, XSTS utility  uses this \u201cX-propagation\u201d mechanism or process at a later time frame or iteration than the X_SATURATION_TIME, e.g., as the simulation nears a final time frame or iteration to simulate with reasonable overall computational resources and\/or to enable optimal ternary simulation based reductions with fixed and\/or bounded resources. The later time frame or iteration is referred to as X_SATURATION_PROPAGATE_TIME with reference to the method illustrated in  described below.","In one or more embodiments, XSTS utility  determines that a later state can safely be treated as a match in the hash table versus an earlier state if every \u201c0\u201d and \u201c1\u201d register valuation from an earlier state is matched by the later state, and this can occur without requiring the \u201cX\u201d register valuations from the earlier state to match the later state. Accordingly, a determination whether or not the current state is in the hash table (in blocks  (see ) and\/or  (see )) may be relaxed to only look for matches against non-\u201cX\u201d values in earlier states. For example, if the later register valuation is an \u201cX\u201d, XSTS utility  has determined an exact match, and the determination whether or not the current state is in the hash table can be relaxed. In another example, if XSTS utility  does not determine an exact match and the later register valuation is \u201c0\u201d or \u201c1\u201d (where an earlier \u201cX\u201d valuation was modeled either case), XSTS utility  determines a repetition of all other behaviors over \u201creducible\u201d signals (which never evaluated to an \u201cX\u201d). In one or more embodiments, XSTS utility  performing the relaxation can allow convergence to be determined earlier and can be efficiently determined by using a \u201cmasked compare\u201d between earlier and later states (e.g., ANDing away register valuations for registers where the earlier state was determined to be an \u201cX\u201d value).","In one or more embodiments, XSTS utility  determines that a ternary simulation monotonically increases a number of registers evaluating to \u201cX\u201d for a first several time frames or iterations (provided that initial states are primarily \u201c0\u201d and \u201c1\u201d values, as the \u201cX\u201d values from RANDOMS propagate through the design), or XSTS utility  determines that the ternary simulation monotonically decreases a number of registers evaluating to \u201cX\u201d for a first several time frames or iterations (provided that initial states are primarily \u201cX\u201d and some dedicated logic \u201cdeterministically resets\u201d these registers). This can allow XSTS utility  to utilize a smaller hash table and, thus, enable faster processing as a result of less or fewer I\/O operations (e.g., memory operations, disk operations, etc.). For example, XSTS utility  begins the ternary simulation process by neglecting a hashing of vectors until a monotonic increase or decrease has terminated, and XSTS utility  treats a register as \u201cX\u201d where the register evaluates to \u201cX\u201d as XSTS utility  begins hashing. Accordingly, XSTS utility  can avoid representing registers with \u201cX\u201d valuations in the hash signatures of the hash table.","During an initial time-frame or iteration, a chance of matching an earlier state is very small or non-existent. In the case where \u201cX\u201d valuations are monotonically increasing, the chance is also very small or non-existent, since increasing numbers of later \u201cX\u201d valuations cannot (or should not) match against a lesser number of earlier \u201cX\u201d valuations. In the case where \u201cX\u201d valuations are monotonically decreasing, some non-\u201cX\u201d state machine driving behavior can exist which acts as a \u201creset device\u201d to clear the initial \u201cX\u201d valuations. In one or more instances, the early time frames or iterations can provide states of this reset device that cannot be determined at later time frames or iterations. Accordingly, XSTS utility  not recording these early time-frames will not delay convergence.","In accordance with one or more embodiments, a modified version of the method illustrated in  is provided in  which incorporates the extensions described above. The value \u201crecord_state\u201d initializes to 0, and stays 0 until the initial \u201cprefix trend\u201d (detected by a function \u201cstate_at_end_of_prefix\u201d) has terminated. For example, XSTS utility  performs the state_at_end_of_prefix function, and the state_at_end_of_prefix function can be configured to return a logical \u201ctrue\u201d value when a prefix trend of monotonically increasing or monotonically decreasing \u201cX\u201d values is determined to end or conclude. While record state remains 0, the method refrains from processing and\/or performing subsequent state recording(s) and determining behavior(s).","Turning now to , a method for reducing the size of a design which avoids redundant prefix checks is illustrated, in accordance with one or more embodiments. Although the method illustrated in  can be described with reference to components shown in , it should be understood that this is merely for convenience and alternative components and\/or configurations thereof can be employed with implementing one or more methods. Key portions of the method illustrated in  can be completed by XSTS utility  executing on CPU  within DPS  and controlling specific operations of\/on DPS . The method is, thus, described from the perspective of either\/both XSTS utility  and DPS .","The method of  begins at block  and proceeds to block  where XSTS utility  receives design information. The design information includes a netlist and\/or information that indicates the netlist or a location of the netlist. At block , XSTS utility  receives an X_SATURATION_TIME value. The design information and\/or the X_SATURATION_TIME value can be received from one or more of a user, an application, a data file, database, a memory, a disk, a network, etc. At block , XSTS utility  initializes a hash table. For example, initializing the hash table may include allocating memory (e.g., RAM, disk space, etc.) and\/or setting values in the hash table to a default value. At block , XSTS utility  sets a converged value to zero (e.g., a logical false value), and at block , XSTS utility  sets a time value to zero (e.g., an initial time). At block , XSTS utility  sets a current state. In one or more embodiments, the current state includes a data structure that includes one or more values and\/or variables of a time frame or iteration of the method being performed by XSTS utility . At block , XSTS utility  performs a ternary-simulation on a design at the time value applying \u201cX\u201d values to all RANDOM gates of the netlist of the design and to registers marked as X_SATURATED of all registers of the netlist of the design. At block , XSTS utility  determines if record_state equals zero. If record_state equals zero, XSTS utility  proceeds to block , where XSTS utility  performs the state_at_end_of_prefix function (described above) using the current state. At block , XSTS utility  sets record_state to one and proceeds to block .","If record_state does not equal zero, XSTS utility  proceeds to block , where XSTS utility  determines whether or not the time value is greater than or equal to X_SATURATION_TIME. If the time value is not greater than or equal to X_SATURATION_TIME, then XSTS utility  proceeds to block . If the time value is greater than or equal to X_SATURATION_TIME, then XSTS utility  proceeds to block .","In one or more embodiments, XSTS utility  performs one or more of blocks - for each register of the netlist, as shown. At block , XSTS utility  determines whether or not the register is not marked as \u201cX\u201d and that the register is determined to depart from its expected prefix behavior. If the register is not marked as \u201cX\u201d and the register is determined to depart from its expected prefix behavior, XSTS utility  proceeds to block , where XSTS utility  determines whether or not the time value is greater than or equal to X_SATURATION_PROPAGATE_TIME. If the time value is greater than or equal to X_SATURATION_PROPAGATE_TIME, XSTS utility  proceeds to block , where XSTS utility  marks the register and its fan-out registers as \u201cX-saturated\u201d. At block , XSTS utility  updates current state with an \u201cX\u201d value on the register and its fan-out registers. If the time value is not greater than or equal to X_SATURATION_PROPAGATE_TIME, XSTS utility  proceeds to block , where XSTS utility  marks the register as \u201cX-saturated\u201d. At block , XSTS utility  updates current state with an \u201cX\u201d value on the register.","XSTS utility  proceeds to block . At block , XSTS utility  determines whether or not the current state is in the hash table. If the current state is in the hash table, XSTS utility  proceeds to block , where XSTS utility  sets the converged value to one. If the current state is not in the hash table, XSTS utility  proceeds to block , where XSTS utility  inserts the current state into the hash table. XSTS utility  proceeds to block . At block , XSTS utility  determines whether or not resources are exceeded. For example, the resources can include memory, disk space, time (e.g., wall clock time), and\/or a time value upper bound (e.g., an upper bound for a number of iterations), among others. If resources are not exceeded, XSTS utility  proceeds to block , where XSTS utility  increases the time value by one and proceeds to block . If resources are exceeded, XSTS utility  proceeds to block , where XSTS utility  determines whether or not the converged value is not zero. If the converged value is not zero, XSTS utility  proceeds to block , where XSTS utility  simplifies the design using the hash table information. At block , XSTS utility  outputs the simplified design. For example, XSTS utility  can output the simplified design to one or more of a display, a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.), among others. XSTS utility  proceeds to block , where the method ends. If the converged value is zero, XSTS utility  proceeds to block  where XSTS utility  outputs that the design is not simplified. For example, XSTS utility  can output that the design is not simplified to one or more of a display, a memory medium (e.g., random access memory, non-volatile memory, network accessible memory, etc.), and a network (e.g., a local area network, a wide area network, a public network such as an Internet, etc.), among others. At block , XSTS utility  ends the method.","As used herein, a hash table includes a data structure that can be indexed into by a value or key to store or access information associated with the value or key. In one or more embodiments, one or more of the methods described in the flow charts above can use one or more data management methods and\/or mechanisms instead of or in addition to a hash table. For example, the one or more data management methods and\/or mechanisms can include one or more of a database, a database management system (e.g., Oracle, MySQL, PostgreSQL, DB2, etc.), a flat file (ordered or unordered), heap(s), tree(s), XML file(s), etc. In one or more embodiments, the hash table and\/or the one or more data management methods and\/or mechanisms can be accessed using an application programming interface (API). In one or more instances, the API is not bound to a particular processing system. For example, the API can be used on a first processing system (e.g., DPS ) and access the hash table and\/or the one or more data management methods and\/or mechanisms on a second processing system (e.g., server ).","In the flow charts above, one or more of the methods are embodied in a computer readable medium including computer readable code such that a series of steps are performed when the computer readable code is executed (by a processing unit) on a computing device. In some implementations, certain processes of the methods are combined, performed simultaneously, concurrently (e.g., scheduled quick enough in time to appear simultaneous to a person), or in a different order, or perhaps omitted, without deviating from the spirit and scope of the invention. Thus, while the method processes are described and illustrated in a particular sequence, use of a specific sequence of processes is not meant to imply any limitations on the invention. Changes may be made with regards to the sequence of processes without departing from the spirit or scope of the present invention. Use of a particular sequence is therefore, not to be taken in a limiting sense, and the scope of the present invention extends to the appended claims and equivalents thereof.","As will be appreciated by one skilled in the art, the present invention may be embodied as a method, system, and\/or computer program product. Accordingly, the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule,\u201d \u201clogic\u201d, or \u201csystem.\u201d Furthermore, the present invention may take the form of an article of manufacture having a computer program product with a computer-usable storage medium having computer-executable program instructions\/code embodied in or on the medium.","As will be further appreciated, the processes in embodiments of the present invention may be implemented using any combination of software, firmware, microcode, and\/or hardware. As a preparatory step to practicing the invention in software, the programming code (whether software or firmware) will typically be stored in one or more machine readable storage mediums such as fixed (hard) drives, diskettes, magnetic disks, optical disks, magnetic tape, semiconductor memories such as RAMs, ROMs, PROMs, etc., thereby making an article of manufacture in accordance with the invention. The article of manufacture including the programming code is used by either executing the code directly from the storage device, by copying the code from the storage device into another storage device such as a hard disk, RAM, etc., or by transmitting the code for remote execution using transmission type media such as digital and analog communication links. The medium may be electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Further, the medium may be any apparatus that may include, store, communicate, propagate, or transport the program for use by or in connection with the execution system, apparatus, or device. The methods of the invention may be practiced by combining one or more machine-readable storage devices including the code according to the described embodiment(s) with appropriate processing hardware to execute the code included therein. An apparatus for practicing the invention could be one or more processing devices and storage systems including or having network access (via servers) to program(s) coded in accordance with the invention. In general, the term computer, computer system, or data processing system can be broadly defined to encompass any device having a processor (or processing unit) which executes instructions\/code from a memory medium.","Thus, it is important that while an illustrative embodiment of the present invention is described in the context of a fully functional computer (server) system with installed (or executed) software, those skilled in the art will appreciate that the software aspects of an illustrative embodiment of the present invention are capable of being distributed as a program product in a variety of forms, and that an illustrative embodiment of the present invention applies equally regardless of the particular type of media used to actually carry out the distribution. By way of example, a non-exclusive list of types of media, includes recordable type (tangible) media such as floppy disks, thumb drives, hard disk drives, CD ROMs, DVDs, and transmission type media such as digital and analogue communication links.","While the invention has been described with reference to exemplary embodiments, it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted for elements thereof without departing from the scope of the invention. In addition, many modifications may be made to adapt a particular system, device or component thereof to the teachings of the invention without departing from the essential scope thereof. Therefore, it is intended that the invention not be limited to the particular embodiments disclosed for carrying out this invention, but that the invention will include all embodiments falling within the scope of the appended claims. Moreover, the use of the terms first, second, etc. do not denote any order or importance, but rather the terms first, second, etc. are used to distinguish one element from another."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention itself, as well as advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 3A-3C"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 4A-4C"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 5A-5D"}]},"DETDESC":[{},{}]}
