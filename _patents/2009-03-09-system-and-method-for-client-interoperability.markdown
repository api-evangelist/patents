---
title: System and method for client interoperability
abstract: Disclosed herein is a system and method for client interoperability. In one embodiment, a method for client interoperability comprises establishing a network connection between a client and a proxy. The client requests a connection factory from the proxy. The proxy then obtains the connection factory from an application server using a Java Naming and Directory Interface (JNDI). Using the connection factory, a connection to a connection host from the client is created. When the client sends a message, the proxy receives the message and routes the message to a destination server. Similarly, when the client receives a message, the proxy receives the message from a destination server and passes the message to the client. The client can be specifically configured to extend JMS operability to a desired language. In one embodiment the client is a .NET client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08316083&OS=08316083&RS=08316083
owner: Oracle International Corporation
number: 08316083
owner_city: Redwood Shores
owner_country: US
publication_date: 20090309
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","COPYRIGHT NOTICE","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims benefit to and incorporates by reference in its entirety the following U.S. Provisional Patent Application:","U.S. Provisional Patent Application No. 61\/034,932 entitled \u201cSystem and Method for Client Interoperability,\u201d by Dongbo Xiao et al., filed Mar. 7, 2008.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The invention is generally related to application server environments, and in particular to a system and method for client interoperability.","The Java Message Service (JMS) is an enterprise messaging system that enables applications to asynchronously communicate with one another through the exchange of messages. A message is a request, report, and\/or event that contains information needed to coordinate communication between different applications. JMS enables Java applications that share a messaging system to exchange messages and simplifies application development by providing an interface for creating, sending, and receiving messages. JMS accepts messages from producer applications and delivers messages to consumer applications.","A JMS queue defines a point-to-point destination type for a JMS server. A message delivered to a queue is distributed to a single consumer. A JMS topic identifies a publish\/subscribe destination type for a JMS server. Topics are used for asynchronous peer communications. A message delivered to a topic is distributed to all consumers that are subscribed to that topic.","JMS clients are based on the Java Programming Language and Specification. This allows them to make use of Java features such as JDBC, JavaBeans, Java Transaction API (JTA), and other Java enterprise application services. Languages and software components other than Java, such as Ruby and the .NET Framework, have gained in popularity and there is demand for a way to integrate JMS support into applications written in languages other than Java. For example, the .NET framework shares much in common with Java. The .NET framework includes a virtual machine, the Common Language Runtime (CLR), and uses an object oriented language, C#. There are two problems with which an integration solution has to address. First, there is a language interoperability problem; for example, Java and .NET use different byte order formats. Second, the .NET Client applications need access to the JMS messaging system.","Disclosed herein is a system and method for client interoperability. In one embodiment, a method for client interoperability comprises establishing a network connection between a client and a proxy. The client requests a connection factory from the proxy, which obtains the connection factory from an application server using a Java Naming and Directory Interface (JNDI). Using the connection factory, a connection to a connection host from the client is created. When the client sends a message, the proxy receives the message and routes the message to a destination server through the connection host. Similarly, when the client receives a message, the proxy receives the message from a destination server and passes the message to the client. One benefit of this approach is that it provides performance improvements over other integration methods, for example, by requiring fewer additional network calls for similar operations. The client can be specifically configured to extend JMS operability to a desired language. In one embodiment the client is a .NET client.","As shown herein, in several embodiments interoperability can be achieved between .NET applications and the Java Message Service (JMS) using a proxy and a client specifically configured for .NET. As one of ordinary skill in the relevant art would recognize, this .NET client is just one example of a client which can be used to broaden the operability of JMS. In other embodiments, additional clients can be developed which are specifically configured for other languages and software components. Such additional clients can achieve interoperability between applications written in another language, e.g. Ruby, and JMS in much the same way as the .NET client.","There are several components in a JMS architecture. For example, in one embodiment, the WebLogic JMS architecture, by Oracle Corporation of Redwood City, Calif. includes: JMS servers and connection hosts; JMS modules which contain configuration resources such as queue and topic destinations, distributed destinations, and connection factories; a Java Naming and Directory Interface (JNDI) service which provides a lookup facility; and persistent storage for storing persistent message data; and JMS Client environment or simply client JMS applications which can either produce or consume messages using the resources available in the server environment.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 1","FIG. 1"],"b":["102","120","124","124","104","110","126","122","126","114","122","112","100","108","120","122","104","114","106","116","118","104","104","124","114","114","126","112","112","122"]},"In one embodiment, JMS servers act as management containers for JMS queue and topic resources. A JMS server's primary responsibility for its targeted destinations is to maintain information on which persistent store is used for any persistent messages that arrive on the destinations, and to maintain the states of durable subscribers created on the destinations. As a container for targeted destinations, any configuration or run-time changes to a JMS server can affect all of its destinations.","Connection factories are resources that enable JMS clients to create JMS connections. In one embodiment, a connection factory supports concurrent use, enabling multiple threads to access an object simultaneously. A user can configure connection factories to create connections with predefined options to suit the user's application. Connection factories can be used in a cluster and can establish cluster-wide, transparent access to JMS destinations from any application server in the cluster by using connection factories for each server instance or by using one or more connection factories with each connection factory being targeted to one or more server instances in the cluster.","Use of .NET for JMS",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 2","FIG. 2"],"b":["200","210","212","204","214","216","218","204","202","208","206"]},"In one embodiment, the proxy enables the exchange of messages between the plurality of .NET clients and the JMS Destinations on the JMS servers. In accordance with an embodiment, the proxy appears to JMS as a normal JMS client. The proxy uses JMS API to route the operations it receives from the .NET client to the JMS server. Services are assigned numbers and indexed in a service index. When the proxy receives an operation from a .NET client attempting to invoke a service, the proxy invokes the service using the service's assigned number. In doing so, the proxy makes the .NET client appear to the JMS server as a Java client.","In one embodiment, .NET applications run on the same application server as the .NET client. In one embodiment, the application objects are the messages sent by the application.","In one embodiment, when the client transforms the application objects it converts the application objects to a lower level representation and then transforms the lower level representation to be compatible with Java. The communication media connecting a plurality of clients with the proxy are capable of transporting the transformed lower level representation of the application objects. Additionally, the proxy routes the operations contained in the transformed application objects to the plurality of servers using the JMS application programming interface (API) and invokes services on the plurality of servers using a numbered service index. In one embodiment, the messages are transformed as they are sent.","In one embodiment, a method for client interoperability comprises establishing a network connection between a client and a proxy. The client requests a connection factory from the proxy which obtains the connection factory using a Java Naming and Directory Interface (JNDI). Using the connection factory, a connection to a connection host from the client is created. When the client sends a message, the proxy receives the message and routes the message to a destination server through the connection host. Similarly, when the client receives a message, the proxy receives the message from a server destination and passes the message to the client. The client can be specifically configured to extend JMS operability to a desired language. In one embodiment the client is a .NET client.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3","b":["300","301","302","303","304","305","306"]},"In one embodiment, traffic to the JMS server is always routed from the .NET client through the proxy to the connection host to the JMS servers. Similarly, in one embodiment, traffic to the .NET Client is always routed from the JMS servers to the connection host and through the proxy to the .NET client.","In accordance with an embodiment, a programmer can create a plurality of .NET applications. The programmer uses a .NET Client to access JMS services. The .NET client converts the .NET applications' objects to a lower level representation. This lower level representation is transformed before it is communicated to a proxy. The transformation can include endian conversion and byte sign conversion. Before data is communicated to or from the proxy, data is converted as needed. For example, Java uses Big Endian format while .NET uses Little Endian format. Similarly, .NET supports both signed and unsigned byte primitive data types, but Java only supports signed bytes. In one embodiment, for interoperability between .NET and Java, the .NET client allows only the use of the signed byte for reading and writing bytes. For unsigned bytes with a value greater than 127, the .NET client converts the unsigned byte to a signed byte before storing the byte. The transformed low level representation is then communicated to a proxy. The proxy receives requests from the .NET client and then uses the JMS API and a numbered index of services to make calls to services corresponding to the .NET client requests.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4","b":["400","408","402","414","422","414","400","402","412","406","410","404"]},"The .NET Client","In one embodiment, the .NET Client is a fully managed .NET runtime library and API. This enables a programmer to create .NET client applications, written in C#, that can access JMS applications and resources.","In accordance with an embodiment, the .NET client enables programmers to create .NET applications according to .NET standards. The .NET applications are converted to a lower level representation which includes bytes, byte arrays, and some primitive types. This lower level representation is transformed to be compatible with Java. The transformed lower level representation is then pushed on a transport protocol and passed to the proxy. In one embodiment, any transport protocol known to the art can be used. In another embodiment, the T3 transport protocol can be used.","In one embodiment, the .NET client mimics the Java-way of retrieving the connection factory and Queue\/Topic that are deployed on the application server, which is to look up a ConnectionFactory and Queue\/Topic using an InitialContext. In one embodiment, the main properties required for establishing an initial context are a provider URL including at least one host:port pair and security information including a user name and password. The InitialContext includes a lookup method and a close method. In one embodiment, when the provider URL contains a comma separated list of host:port pairs, a round-robin algorithm is used to begin at a random location in the list, and try each entry until one succeeds or all fail.","In one embodiment, the .NET client can support standard JMS message types including: TextMessages, BytesMessages, Map Messages, Object Messages, and Stream Messages. In one embodiment, the producer and consumer of an Object Message must be written in the same language, e.g. if an Object Message is sent by a Java producer and received by a C# consumer, then the user receives a message format error when attempting to access the object.","The .NET client can also support JMS transacted sessions. Transacted sessions provide a standard local transaction capability. Multiple JMS destinations from the same cluster can participate in a transacted session local transaction, but other resources, such as JMS destinations from other clusters, cannot participate.","In one embodiment, the same proxy and client can work with any standard JMS implementations. For example, the .NET client can communicate with multiple JMS vendors using the same API and network configuration.","Use of the Proxy","The proxy can manage multiple clients. In one embodiment, the clients are .NET clients, in another embodiment the clients are specifically configured for another language. In one embodiment, the same proxy can manage multiple clients where each client has been specifically configured to use a different language. In accordance with an embodiment, the proxy appears to JMS as a normal JMS client. The proxy receives the low level representation of the .NET applications from the .NET client. The proxy uses JMS API to route the operations it receives from the .NET client to the JMS server. Services are assigned numbers and indexed in a service index. When the proxy receives an operation from a .NET client attempting to invoke a service, the proxy invokes the service using the service's assigned number. In doing so, the proxy makes the .NET client appear to the JMS server as a Java client.","Exclusive Locking","In one embodiment, the system includes a lock manager. The lock manager is an internal hierarchical structure for handling creation and destruction of related objects robustly, i.e., a way to automatically clean up child objects of parents which need to be destroyed. The lock manager is capable of automatically handling the locking and associated locking\/sleeping behavior that is typical in this paradigm. The lock manager runs on the client.","JMS connections contain sessions and sessions contain producers and consumers. Individual locks are needed for connections and sessions. This presents difficulties when one holds a session lock and needs to reconnect, by establishing a new connection, or to close connections. There is a need to be careful of which locks are held and which locks are being waited for, particularly when stopping connections. When a connection is stopped all sessions within a connection must be stopped. Stopping all sessions requires stopping each consumer in each session. Failure to properly manage locks can result in a deadlock. The only remedy for a deadlock is restarting the client. In one embodiment, this problem is addressed by the lock manager by requiring all locks to coordinate with one another.",".NET Client Supported Features","In one embodiment, the .NET Client is extended to support non-standard JMS features. For example, the .NET Client may support:\n\n","The present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art.","In some embodiments, the present invention includes a computer program product which is a storage medium (media) having instructions stored thereon\/in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and\/or data.","The foregoing description of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. Particularly, it will be evident that while the examples described herein illustrate how the features can be used in a WebLogic environment using the .NET Framework, other application servers, virtual machines, computing environments, software development systems and languages may use and benefit from the invention. The code examples given are presented for purposes of illustration. It will be evident that the techniques described herein can be applied using other code languages, and with different code.","The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
