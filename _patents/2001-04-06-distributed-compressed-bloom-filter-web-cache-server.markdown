---
title: Distributed, compressed Bloom filter Web cache server
abstract: Compressed Bloom filters that act as a message as well as a data structure provide smaller false positive rates, reduced bits broadcast and/or reduced computational overhead in distributed Web proxy servers and other distributed networks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06920477&OS=06920477&RS=06920477
owner: President and Fellows of Harvard College
number: 06920477
owner_city: Cambridge
owner_country: US
publication_date: 20010406
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["STATEMENT OF GOVERNMENT INTEREST","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PRESENTLY PREFERRED EMBODIMENTS","SIMULATION EXAMPLES"],"p":["This invention was made in part with government support under grant number CCR-9983832 from the National Science Foundation. The government may have certain rights in this invention.","This invention is drawn to the field of distributed caching networks, and more particularly, to a novel distributed, compressed-bloom filter Web cache server system and method.","As Web usage increases, so does user perceived fetch latency. Distributed Web caching systems reduce fetch latency by maintaining in the cache memory of each Web server information representative of its Web objects as well as that of other, neighboring Web servers. By allowing for retrieval of desired Web objects from a neighbor's cache closer to the client than the original source, such distributed or cooperative Web caching systems reduce user perceived fetch latency.","For such distributed or cooperative Web caching systems to be effective, Web servers must have reasonably accurate information regarding the contents of other Web server caches. One possibility is for Web servers to periodically broadcast a list of their contents to other neighboring Web servers. The natural form of this list would be as a list of Uniform Resource Locators, or URLS, such as \u201chttp:\/\/www.yahoo.com.\u201d A list written in this textual form might be quite long, as Web servers may cache thousands, tens of thousands, or more Web pages. Moreover, these lists must be broadcast sufficiently often so that they are mostly accurate even as the contents in the Web server caches change over time. Hence this straightforward solution may lead to significant network traffic, undermining the possible advantages of distributed Web caching.","Fan et al. in an article entitled \u201cSummary Cache: a Scalable Wide-area Web Cache Sharing Protocol,\u201d appearing at Proceedings of SIGCOMM '98, (1998: pp 254-265), incorporated herein by reference, disclose a distributed, Bloom filter Web cache server that maintains Bloom filter array data representative of its Web objects, as well as of other, neighboring Web servers, and that periodically broadcasts the Bloom filter array data that represents the contents of its cache to its neighbors whenever sufficiently many changes have occurred since the last broadcast. If a Web server wishes to determine if another neighboring Web server has a page in its cache upon a query miss, it checks the appropriate Bloom filter array data. Message traffic is reduced in Fan et al., since Web servers do not broadcast URL lists corresponding to the exact contents of their memory caches, but rather the succinct Bloom filter array data representative thereof.","The size of the Bloom filter array data is typically determined by the transmission protocol of the communications infrastructure. While the Bloom filter has a zero probability of producing false negatives when queried, it has an optimum non-zero probability of producing false positives for Bloom filter array data of given size. That is, it may incorrectly return that an element is in a set when it in fact is not, which leads to more message traffic and to increased user perceived fetch latency.","There is thus a need to reduce the probability of producing false positives in distributed, summary cache Web servers.","It is accordingly an object of the present invention to disclose a distributed, compressed Bloom filter Web cache server providing reduced optimum probabilities of producing false positives than the heretofore known summary cache Web servers for any given Bloom filter data array size.","In accord therewith, a distributed, compressed Bloom filter Web server providing reduced probabilities of false positives is disclosed that includes a plurality of cache servers each having a cache memory and a cache processor coupled to the memory and operative to (1) represent Web objects stored in its cache memory as a compressed Bloom filter data array having a preselected number of hash functions and a preselected array size which have been chosen to minimize the rate of false positives for a preselected target compression size; and operative (2) to periodically disseminate the compressed Bloom filter data array to neighboring servers when there is a predetermined change in its stored Web objects.","In further accord therewith, a method reducing false positives in a network having distributed Web servers each storing information in cache memory as a Bloom filter data array and broadcasting that data array to other Web servers is disclosed that includes the steps of (1) fixing a compression size for transmission of the Bloom filter data array at each Web server; (2) choosing the number of hash functions and the array size so that the Bloom filter data array minimizes the rate of false positives when it is compressed down to the fixed compression size; and (3) broadcasting the compressed Bloom filter data array to neighboring Web servers whenever there is a predetermined change in the contents of its cache memory.","User perceived fetch latency is improved, due to the reduced probabilities of false positives provided by the compressed Bloom filter data arrays in accord with the present invention, and, among other advantages, computational requirements are generally softened, due to generally reduced processing required for generating the compressed Bloom filter data arrays in accord with the present invention.","The principles of the distributed, compressed Bloom filter Web server system and method in accord with the present invention, that the Bloom filter is both a data structure in memory and an object that is broadcast, that, as having both said attributes, may be optimized for a target compression size, are applicable to distributed networks other than the distributed, compressed Bloom filter Web servers of the solely exemplary, presently preferred embodiments. For example, the inventive principles are applicable in geographic location sharing systems, where each server contains location information about mobile clients that should be distributed elsewhere, or to distributed file-sharing systems (such as, for example, Napster), where the Bloom filter would record file information instead of URL information. In any instance where information is passed in a distributed system according to a Bloom filter the compressed Bloom filter in accord with the present invention may be used to improve performance.","Referring now to , generally designated at  is a functional block diagram illustrating a distributed, compressed Bloom filter Web server arrangement in accord with the present invention. A plurality of cooperative cache servers  are operatively connected to a communications infrastructure, not shown. Any suitable communications infrastructure, such as optical fiber, or the cables of the telephone network, may be employed, and any suitable communications protocol, such as TCP\/IP or UDP, may be employed.","As schematically illustrated by box , the plurality of cooperative cache servers  may, for example, be the cache servers of a LAN or those inside an ISP. As schematically illustrated by box , each of the plurality of cooperative cache servers is operatively connected to the outside world, as, for example, the Internet or the servers outside the ISP.","Each cache server  includes a cache processor  () operatively coupled to cache memory  () in which are stored a compressed Bloom filter data array  () representative of the Web objects located on that server and a plurality of compressed Bloom filter data arrays  () to be described, each representative of the Web objects located on another cooperative Web server . The Web objects stored in cache memory  of each proxy server  will generally be URL's.","Each cache server  responds to a client query to determine if the requested Web object is located in the cache memory of that server, or is located in the cache memory of a cooperative cache server . If it is, it retrieves the requested object either from itself, or, as schematically illustrated by arrow , from that one of the cooperative cache servers that does have the requested Web object. If not, it seeks the requested object in the outside world .","Whenever the contents of the cache memory of any cache server  changes sufficiently, where the amount of change might depend on the application or the parameters of the system (such as the number of cooperating machines), it disseminates a compressed Bloom filter data array to be described representative of the new contents to its neighbors  as schematically illustrated by arrows , which, in turn, decompress it, and update the compressed Bloom filter data array for that node.","The programs, not shown, controlling data structure coding, compression, transmission, and reception are stored in program memory, not shown, of each cache server. Other data structures, objects or programs, not shown, are also stored in cache, program or other memory of each cache server, such as, for example, the program that determines which Web objects and when Web are removed from the cache.","Referring now to , generally designated at  is a block diagram useful in explaining the operation of a prior art Bloom filter. The filter  includes as inputs the Bloom filter data array size m and the number of Web objects n to be represented thereby. The parameters m and n to the left of the Bloom filter  are given as inputs, and the parameter k to the top of the Bloom filter , the number of hash functions, is optimized to minimize the rate \u0192 of false positives. In the typical case, the Bloom filter array size m is determined by the desired message traffic of the communications protocol and infrastructure, which generally is in the range of 4-32 bits per data item, and usually is 8-16 bits, and\/or by the cache memory space available. Reference in this connection may be had to Fan et al, supra, and general reference may be had to an article by Bloom entitled \u201cSpace\/time Trade-offs in Hash Coding with Allowable Errors,\u201d appearing at Communication of the ACM (1970, 13 (7): pp. 422-426), incorporated herein by reference.","As appears more fully below, the number of hash functions k of the prior art Bloom filter  is optimized to provide Bloom filter array data schematically illustrated by arrow  that minimizes the rate \u0192 of false positives given the Bloom filter data array m and the number of Web objects n.","A Bloom filter for representing a set S={s, s, . . . , s} of n elements is described by an array of m bits, initially all set to zero (0). A Bloom filter uses k independent hash functions h, . . . , hwith range {1, . . . , m}. For mathematical convenience, assume these hash functions map each item in the universe to a random number uniform over the range {1, . . . , m}.","For each element s\u2208S, the bits h(s) are set to one (1) for 1\u2266i\u2266k. A location can be set to one (1) multiple times, but only the first change has an effect. To check if an item x is in S. check whether all h(x) are set to one (1). If not, then x is clearly not a member of S. If all h(x) are set to one (1), assume that x is in S, although a Bloom filter may yield a false positive, where it suggests that an element x is in S even though it is not.","The probability of a false positive for an element not in the set, or the false positive rate, can be calculated in a straightforward fashion, given the assumption that hash functions are perfectly random. After all the elements of S are hashed into the Bloom filter, the probability that a specific bit is still zero (0) is: \n\n\nLet p=(e). The probability of a false positive is then: \n\n\nLet f=(1\u2212e)=(1\u2212p). Note the asymptotic assumption is used herein for convenience of representation.\n","Now suppose m and n are given and the number of hash functions k is to be optimized. There are two competing forces; using more hash functions gives more chances to find a zero (0) bit for an element that is not a member of S, while on the other hand, using fewer hash functions increases the fraction of zero (0) bits in the array.","The optimal number of hash functions that minimizes \u0192 as a function of k is found taking the derivative. More conveniently, note that \u0192 equals exp(k ln(1\u2212e)). Let g=k ln(1\u2212e\u2212). \n\n\nMinimizing the false positive rate \u0192 is equivalent to minimizing g with respect to k: The derivative is zero (0) when k=ln 2*(m\/n). This is a global minimum. In this case, the false positive rate \u0192 is (\u00bd)=(0.6185). In practice, of course, k will be an integer, and smaller k might be preferred, insofar as that reduces the amount of computation necessary.\n","Referring now to , generally designated at  is a block diagram useful in explaining the principles of a compressed Bloom filter in accord with the present invention. In accord with the present invention, the Bloom filter is not just an object that resides in cache memory, but an object that is transferred between proxy servers, that, as such, may be optimized to minimize the false positive rate for Bloom filter array data compressed to a transmission compression size z.","The filter  includes as inputs to the left thereof the Bloom filter data array compression size z and the number of Web objects n to be represented thereby. Unlike the prior art filter  (FIG. C), the size of the Bloom filter data array m of the compressed Bloom filter  is not limited by network traffic constraints, but only by cache memory size, since it is to be compressed to the compression size z, which enables compressed Bloom filters in accord with the present invention to obtain better rates of false positive rejection than the prior art Bloom filter  () for any given Bloom filter data array compression size.","As appears more fully below, the two parameters to the top of the compressed Bloom filter  in accord with the present invention, namely, the number of hash functions k and the Bloom filter array size m, are optimized to provide compressed Bloom filter array data schematically illustrated by arrow  that minimizes the false positive rate \u0192 given the Bloom filter data array compression size z and the number of Web objects n. In the typical case, m is set as big as possible, given any cache memory space constraints, and k is optimized to provide compressed Bloom filter data that minimizes the false positive rate \u0192 given the Bloom filter data array compression size z, data array m and the number of Web objects n. In general, fewer hash functions are required than in the prior art filter  (FIG. C), which eases the computational overhead. In the typical case, the Bloom filter array compression size z is determined by the communications protocol and infrastructure, in the range of 4-32 bits per data item, usually 8-16 bits.","Let z\u2267n be the desired compressed size. Each bit in the bit array is zero (0) with probability p if the bits are assumed to be independent. Also, as a mathematically convenient approximation, assume an optimal compressor. That is, assume that the m bit filter can be compressed down to only mH(p) bits, where H(p)=\u2212p logp\u2212(1\u2212p)log(1\u2212p) is the entropy function. The compressor therefore uses the optimal H(p) bits on average for each bit in the original string. Note that near-optimal compressors exist; arithmetic coding, for example, requires on average less than H(p)+\u2208 bits per character for any \u2208>0 given suitably large strings.","Optimization proceeds as follows. Given n and z, choose m and k to minimize \u0192 subject to mH(p)\u2266z. For the prior art optimized Bloom filter where m=z and k=ln 2*(m\/n), p=\u00bd, and \u0192 is \u2266(0.6185). This choice of k is the worst choice possible for the design of compressed Bloom filters in accord with the present invention.","To see this, parametrize so that k=\u03b1m\/n. Then p=e, and m and n are chosen to minimize f=(1\u2212e)subject to m=z\/H (e), where, without loss of generality, m may be chosen as large as possible. Equivalently, we have:\n\n\u0192=(1).\n\nSince z and n are fixed with z>n, we wish to maximize:\n\n\u03b2=\u0192=(1\u2212).\n\nLet \u03b1=\u2212ln x. Then: \n\n\nThe value of \u03b2 is maximized when the exponent is maximized, or equivalently when the term, \n\n\nis minimized.\n\nNote that: \n\n","The value of \u03b2 is clearly zero (0) when x=\u00bd, and using symmetry it is easy to check that d\u03b3\/dx is negative for x<\u00bd and positive for x>\u00bd. Hence the maximum probability of a false positive using a compressed Bloom filter occurs when x=\u00bd, corresponding to \u03b1=ln 2.","This shows that \u03b3 is maximized and hence \u03b2 and \u0192 are minimized in one of the limiting situations as x goes to zero (0) or one (1), corresponding to \u03b1 going to infinity or zero (0). In each case, using for example the expansion ln (1\u2212x)\u2248\u2212x\u2212x\/2\u2212x\/3\u2212 . . . , we find that \u03b3 goes to negative one (\u22121). Hence \u03b2 goes to one-half (\u00bd) in both limiting cases, and a false positive rate arbitrarily close to (0.5)can be achieved by letting the number of hash functions go to zero (0) or infinity.","In practice, these values are constrained as, for example, at least one hash function must be used, and the number of hash functions will be an integer. Note, however, that improved performance may be achieved by taking k<ln 2*(m\/n) for the compressed Bloom filter. This has the additional benefit that a compressed Bloom filter uses fewer hash functions and hence requires less computation for lookup.","Compression therefore improves performance, in terms of reducing the false positive rate for a desired compressed size. An additional benefit of the compressed Bloom filters in accord with the present invention is that they generally use a smaller number of hash functions, so that lookups are more efficient.","It is instructive to compare the prior art Bloom and the compressed Bloom filters in accord with the present invention pictorially in the case shown in , which is a graph plotting the false positive rate \u0192 as the ordinate against the number of hash functions k as the abscissa, where for the standard Bloom filter m\/n=8 and for the compressed Bloom filter z\/n=8, and where k conformably to the foregoing analysis is assumed to behave as a continuous variable. The curve  represents the performance of the prior art Bloom filters. The curve  that of the compressed Bloom filters in accord with the present invention. The point marked  depicts the value of k that gives optimal false positives for the prior art Bloom filter. Note that the optimized uncompressed filter actually yields the largest false positive rate vis-a-vis the compressed Bloom filters of the present invention.","Any suitable hash functions, such as the standard universal families of hash functions described by Carter et al. in an article entitled \u201cUniversal Classes of Hash Functions,\u201d appearing at Journal of Computer and System Sciences, (1979: pp. 143-154), and by Ramakrishna in an article entitled \u201cPractical Performance of Bloom Filters and Parallel Free-text Searching,\u201d appearing at Communications of the ACM (1989, 32 (10): pp. 1237-1239), both incorporated herein by reference, or the MD5 used by Fan et al. in the hereinabove incorporated article, may be employed.","In situations where hashing performance is not sufficiently random, compressed Bloom filters will still generally outperform the uncompressed Bloom filters of the prior art. The point is that if the false positive rate of a compressed Bloom filter is increased because of weak hash functions, the false positive rate of the uncompressed Bloom filter will increase as well. Moreover, since compressed Bloom filters generally use fewer hash functions, the effect will be worse for the uncompressed prior art filters.","Any suitable compression technique, such as arithmetic coding described by Moffat et al. in an article entitled \u201cArithmetic Coding Revisited,\u201d appearing at ACM Transactions on Information Systems, (1998, 16(3): pp. 256-294), and by Witten et al. in a book entitled Managing Gigabytes, (1999: pp. 35-41), both incorporated herein by reference, may be employed. Arithmetic coding provides a flexible compression mechanism for achieving near-optimal performance with low variability. Generally speaking, for a random m bit string of where the bit values are independent and each bit is zero (0) with probability p and one (1) with probability 1\u2212p, arithmetic coding compresses the string to near mH (p) bits with high probability, with the deviation from the average having a Chernoff-like bound.","Referring now to , generally designated at  is a flow chart illustrating the operation of a cache processor of the distributed, compressed Bloom filter cache server in accord with the present invention whenever any cache processor needs to broadcast upon change of the Web objects stored in its cache memory. At such times, the processor is operative to generate a compressed Bloom filter data array as shown by block . The compressed Bloom filter parameters can be optimized to reduce the number of bits broadcast, the false positive rate, and\/or the amount of computation per lookup. As shown by block , the cache server processor then compresses it using a preselected compression algorithm, such as arithmetic coding, and as shown by block , it then broadcasts the compressed Bloom filter data array, together with header information identifying itself, to all its neighbors.","Referring now to , generally designated at  is a flow chart illustrating the operation of a cache processor of the distributed, compressed Bloom filter cache server in accord with the present invention whenever it receives a broadcast from one of its neighbors. At such times, the processor is operative to receive the compressed Bloom filter data array as shown by block , and, as shown by block , it then decompresses the received compressed Bloom filter data array and extracts the decompressed Bloom filter data array and the identifying header. As shown by block , the cache processor then updates its cache memory with the compressed Bloom filter data array corresponding to the appropriate cache server.","It may be instructive to consider some simulation examples. A maximum desired uncompressed size m was chosen and arithmetic coding using the publicly available arithmetic coding compressor described by Carpinelli et al. in an article entitled \u201cSource Code for Arithmetic Coding, Version 1,\u201d available at HTTP:\/\/www.cs.mu.oz.au\/\u02dcalistair\/arith_coder\/, (March, 1995), incorporated herein by reference, and described by Moffat et al., supra, was employed. The parameters of the compressed Bloom filter were chosen using a slightly smaller compressed size than desired to provide room for some variability in compression. The amount of room necessary depends on m. A similar effect may be achieved by slightly overestimating n. If the uncompressed filter is more than half full of zeros, then we can have fewer than expected elements in the set, and the filter will tend to have even more zeros than expected, and hence will compress better. In this manner, the compressed filter should be the desired size with high probability.","The following experiment was repeated 100,000 times. A Bloom filter for n=10,000 elements and m=140,000 bits was created. Each element was hashed into two positions chosen independently and uniformly at random in the bit array. The resulting array was compressed using the Carpinelli et al. arithmetic coding compressor. Using z=mH (p), the compressed size was near 9,904 bytes; to meet the bound of eight bits per element required the compressed size not exceed 10,000 bytes.","Over the 100,000 trials, the average compressed array size was found to be 9,920 bytes, including all overhead. The standard deviation was 11.375 bytes. The maximum compressed array size was only 9,971 bytes, giving several bytes of room to spare. For larger m and n, even greater concentration of the compressed size around its mean is expected; for smaller m and n, the variance would be a larger fraction of the compressed size.","Better performance could have been achieved by using just one hash function, although this would have increased the number of array bits per element, as seen in Table 1, below.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"char"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"char"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Array bits\/element","m\/n","8","14","92"]},{"entry":["Transmission bits\/element","z\/n","8","7.923","7.923"]},{"entry":["Hash functions","k","6","2","1"]},{"entry":["False positive rate","f","0.0216","0.0177","0.0108"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"A Bloom filter where z\/n=m\/n=16 was considered, where 11 hash functions were employed to achieve an optimal false positive rate of 0.000459. As 11 hash functions was seemingly large it was noted that the number of hash functions could be reduced without applying compression, but using only six hash functions more than doubles \u0192 to 0.000935.","Table 2, below, summarizes the improvements available using compressed Bloom filters in accord with the present invention.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"char"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"char"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Array bits\/element","m\/n","16","28","48"]},{"entry":["Transmission bits\/element","z\/n","16","15.846","15.829"]},{"entry":["Hash functions","k","11","4","3"]},{"entry":["False positive rate","f","0.000459","0.000314","0.000222"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"For 28 array bits per element, the false positive rate fell about 30 percent while using only four hash functions. For 48 array bits per element, the false positive rate fell over 50 percent using only three hash functions. The case where n=10,000 elements, m=480,000 bits, and k=3 hash functions was simulated using 100,000 trials. The considerations described above suggested the compressed size was 19,787 bytes. Over the simulation trials, the average compressed array size was 19,805 bytes, including all overhead. The standard deviation was 14,386 bytes, and the maximum compressed array size was only 19,865 bytes, well below the 20,000 bytes available.","Many modifications of the presently disclosed invention will become apparent to those of skill in the art who have benefitted from the present disclosure. For example, multiple filter types may be employed in cases where the array data does not compress adequately. For example, each filter type t is associated with an array of size m, a set of hash functions, and a compression technique. These types are agreed on ahead of time. A few bits of the header can be used to represent the filter type. If one of the filter types is the prior art Bloom filter, then the set can always be sent appropriately using at least one of the types. In most cases two types, compressed and uncompressed, would be sufficient.","Fan et al. in their article entitled \u201cSummary Cache: a Scalable Wide-area Web Cache Sharing Protocol,\u201d appearing at Proceedings of SIGCOMM '98, (1998: pp 254-265), describe two possible approaches that may be improved using compressed Bloom filters in accord with the present invention. First, when update messages are sent among neighboring Web servers, it may be possible to send a bit vector representing the difference between the last update rather than an entirely new Bloom filter. For example, suppose the system is set so that when five (5) % of the bits in the Bloom filter have changed, an update is sent denoting only which bits in the Bloom filter array have been changed. Rather than sending a Bloom filter, the message sent is therefore a Bloom filter delta representing the change in the Bloom filter. Just as the present invention demonstrates that a Bloom filter can be compressed to improve performance, similarly the Bloom filter delta can be compressed to improve performance, in an entirely similar manner. Using compressed Bloom filter delta may therefore allow even larger Bloom filters to be used, further decreasing the probability of a false positive.","Fan et al. also describe a counting Bloom filter, in which each entry in the size m table representing the Bloom filter is not a bit but a counter that can represent for example the numbers 0-15 using four bits. Counting Bloom filters are not passed as messages in the application described in the paper. If it is desirable to pass counting Bloom filters as messages, then improvements could be made by sending a compressed counting Bloom filter in a manner similar to that described above for the standard Bloom filter. That is, the counts represented in the counting Bloom filter would be compressed via arithmetic coding or some other compression method, and the compressed form would be transmitted. Again this allows a decrease in the probability of a false positive while transmitting the same or fewer bits throughout the system.","The principles of the distributed, compressed Bloom filter Web server in accord with the present invention may be implemented in distributed systems or networks other than that of the distributed Web server of the exemplary, presently preferred embodiments. For example, compressed Bloom filters in accord with the present invention may advantageously be employed in geographic location sharing systems. An example of a geographic location sharing system based on Bloom filters is described, for example, in the paper \u201cGeographical Region Summary Service for Geographical Routing\u201d by Pai-Hsiang Hsiao (2000, submitted to Mobicom 2001), incorporated herein by reference. Mobile agents wander through a neighborhood, represented by, for example, a square grid (other shapes are possible; the square grid is described for convenience). This square grid is divided recursively into several subsquares. The IDs of mobile agents in each subsquare can be succinctly represented by a Bloom filter, which is passed among mobile or stationary agents that keep track of location data. In this case finding the approximate location of a mobile agent can be done with high probability by checking the appropriate Bloom filters; this information can be used to route packets toward a mobile agent when data is to be sent. These Bloom filters must be updated regularly in order to cope with mobility. Using compressed Bloom filters will improve the accuracy while allowing the same number of bits to be transmitted.","The principles of the distributed, compressed Bloom filter Web server in accord with the present invention may be implemented in applications for other distributed systems or networks. For example, general file names instead of URLs may be used in a distributed file sharing system with compressed Bloom filters."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other objects, inventive aspects and advantageous features of the present invention will become apparent as the invention becomes better understood by referring to the following, solely exemplary detailed description of the presently preferred embodiments, and to the drawings, wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 1","FIG. 1A","FIG. 1B","FIG. 1C","FIG. 1D","FIG. 1E"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 2","FIGS. 2A"],"b":"2"}]},"DETDESC":[{},{}]}
