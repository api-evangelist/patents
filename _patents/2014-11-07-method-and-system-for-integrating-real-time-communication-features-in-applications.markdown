---
title: Method and system for integrating real time communication features in applications
abstract: A computer has a processor and a memory connected to the processor. The memory stores instructions executed by the processor to receive a real time communication request from a client device and perform an evaluation of the number of client devices associated with the real time communication request. The evaluation results in the coordination of peer-to-peer communications in the event of two client devices and an attempt to host a real time communication session using a first protocol in the event of three or more client devices. A second protocol for the real time communication session is invoked in the event that the attempt to host the real time communication session using the first protocol is unsuccessful.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09083770&OS=09083770&RS=09083770
owner: Snapchat, Inc.
number: 09083770
owner_city: Venice
owner_country: US
publication_date: 20141107
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority to U.S. Provisional Patent Application Ser. No. 61\/909,343, filed Nov. 26, 2013, and U.S. Provisional Patent Application Ser. No. 61\/916,562, filed Dec. 16, 2013, the contents of which are incorporated herein by reference.","This invention relates to real time communications in a computer network. More particularly, this invention relates to techniques for integrating real time communication features into software applications.","Real time communication tools allow users to communicate in real time. The real time communication can include audio, video, images, etc. The real time communication tools are available as stand-alone applications that can be installed on devices or as web browser based applications. However, the current real time communication tools do not provide efficient ways to integrate them into existing software applications. Further, they lack reliability, efficiency and adaptability to network bandwidth features.","A computer has a processor and a memory connected to the processor. The memory stores instructions executed by the processor to receive a real time communication request from a client device and perform an evaluation of the number of client devices associated with the real time communication request. The evaluation results in the coordination of peer-to-peer communications in the event of two client devices and an attempt to host a real time communication session using a first protocol in the event of three or more client devices. A second protocol for the real time communication session is invoked in the event that the attempt to host the real time communication session using the first protocol is unsuccessful.","Technology is disclosed for integrating real time communication (RTC) features into software applications (\u201cthe technology\u201d). Various embodiments of the technology provide an RTC tool that allows users, e.g., application developers to integrate RTC features into software applications. The RTC features support streaming of content including audio, video, and screen sharing. In some embodiments, the RTC tool is generated using Web Real-Time Communication (WebRTC) application programming interfaces (APIs). The WebRTC enables browser-to-browser applications for voice calling, video chat, and P2P file sharing without plugins. The RTC tool can be integrated in various popular platforms. For example, the RTC tool is available as a JavaScript for web applications (this can use native WebRTC for browsers supporting it and a native NPAPI\/ActiveX plug-in otherwise), as native Java\u00ae for Android\u00ae devices, as Objective-C for iOS\u00ae devices, native C for Mac OS X\u00ae and Microsoft Windows\u00ae for desktop applications.","The client software development kit (SDK) of the RTC tool allows the application to establish a connection to the streaming infrastructure of the tool and create a multimedia session with multiple contributing sources (e.g., clients connected to the streaming service), and media types. Additionally it is possible to exchange messages between peers connected to the same session or scope, using the reliable data channel.","RTC Tool Components",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","130","155"]},"Server Side Components","The server-side components include a streaming server device  having a streaming server  that provides the core streaming functionality of the RTC tool . Other components, including the Command and Control (CnC) application  and the streamer agent  provide a support framework for the core streaming functionality. The RTC tool  also includes the database engines such as MySQL\u00ae 160, Redis\u00ae 115 and Cassandra\u00ae 110.","Server Side Components\u2014Streaming Server","The streaming server  (hereinafter referred to as \u201cstreamer\u201d) is the core component of the RTC collaboration infrastructure. The streamer serves a role of an intelligent multipoint control unit (MCU) providing services, including media streams relaying, quality control and signaling.","The streamer  is effectively a smart packet relay. It transmits packets between peers connected to the same virtual video conference room (referred to as \u201cMedia Scope\u201d, \u201cscope\u201d or \u201csession\u201d). There can be two use cases for this functionality: multiparty conferences and Network Address Translation (NAT) traversal. Whenever there are more than two participants in the session, the data is relayed to ensure that the client sends the data only once. This allows the RTC tool to utilize the most efficient media session topology, e.g., the star topology. In case of the one-to-one sessions with at least one user behind a NAT device using an implementation other than the endpoint-independent mapping, as per RFC 4787 [2], relaying makes the data transmission possible.","The streamer  can also be responsible for all the measurements and feedback notifications required to ensure the quality of the session for all the peers participating. This can apply in both directions of media streams\u2014from client to the streamer  and vice versa. When ensuring the stream quality from peers to the streamer , the server-side component measures the loss, one-way packet queuing delay and generates Real-time Transport Control Protocol (RTCP) receiver report (as per RFC 3550) feedback messages sent to the clients. The client SDKs use this information to adapt the quality of the sent stream accordingly. The downstream adaptation is done in a similar way. This time, the client side performs all the measurements and notifies the streamer  using RTCP receiver report (RR) messages. It then controls which peer should receive high video quality feed and which one a lower video quality feed.","The streamer  provides signaling communication required to establish and maintain a media session. It allows each client to know where and how to send the media streams when establishing a media session. The signaling controls also the basic presence by letting all the peers know who is connected to the session and what kind of media streams are published by every participant. Finally, it provides reliable data channel functionality.","The streamer runs as an independent process in the streaming server device . In some embodiments, it does not require any application container (e.g., Tomcat\u00ae) or front end, reverse-proxy server (Ngnix\u00ae, Apache\u00ae). The streamer  can be implemented using various programming languages, e.g., C\/C++ programming languages, etc., and several open source libraries such as boost, Google\u00ae protocol buffers, oRTP\u00ae, OpenSSL\u00ae, Google Breakpad\u00ae, Hiredis\u00ae, JSONCPP\u00ae, etc.","The streamer  interacts with the client SDKs and the streamer agent . In some embodiments, the client SDK-streamer communication is done by the signaling and media streaming protocols. In the latter case the streamer  uses a local instance of the Redis\u00ae database server  to pass asynchronous events with usage and quality statistics.","Server Side Components\u2014Command and Control Application","The CnC application  executing in a CnC server  is a web application that manages clusters of streaming server instances. The CnC application  associates an instance of the streamer  with a multimedia session, ensuring that: (1) all peers requesting a connection to the same media session will use the same streaming server  instance, (2) the load is distributed evenly across all the streamers  available and (3) the geographically closest streamer  is used.","The CnC application  is also responsible for persistence of the diagnostic data, including bug reports, logs, devices etc. The CnC application  provides an API to access the analytics data stored in Cassandra\u00ae database . The API can be consumed by the JavaScript\u00ae components of the Developer Dashboard  of the RTC tool. The CnC web application  can be implemented using various programming languages such as Python\u00ae, and can use open source Python\u00ae libraries such as Flask\u00ae, Simpleapi\u00ae and Jinja2\u00ae. The CnC application  may not interact directly with other server-side components, instead it can use the database engines employed by the RTC tool. As stated above, the Redis\u00ae database  is used to maintain the session streamer mappings. The Cassandra\u00ae database  is queried for the usage and quality statistics when serving the API requests. The MySQL\u00ae database  can be used for persisting automatic error reports.","Server Side Components\u2014Streamer Agent","The streamer agent  is a server side component that helps to maintain a set of streaming servers . The streamer agent  receives events from streamers , process them to generate usage and quality statistics, and persist the statistics using the Cassandra\u00ae database . The streamer agent  can receive events, including (1) session created (triggered by first connection to a session), (2) session joined (triggered after any connection to a session, including the first one), (3) session left (triggered after any disconnection from a session), (4) session disposed (triggered after the last participant leaves a session), and (5) media stream quality statistics (sent periodically for every media stream included in an active session).","The events related to the session lifecycle (created, joined, left, disposed) can be required to collect session information\u2014when it was started and ended, who was participating and when each participant joined or left the session. The media stream quality statistics events are useful for analyzing the system behavior under certain condition, which allows system optimizations. The streaming agent  releases the session-streamer mapping when the session disposed event is received.","In one embodiment, the streamer agent  interacts with two database engines: Redis\u00ae 115 as a source of events and Cassandra\u00ae 110 as a persistent data store. Regarding the implementation details, the streamer agent  can be a daemon process, implemented using various programming languages, including Python\u00ae and open source third party Python libraries such as Redis\u00ae, Pycassa\u00ae, Jsonpickle\u00ae and Supervisor\u00ae.","Data Storage Components","The RTC tool uses various data storage components for storing data associated with RTC features.","Data Storage Components\u2014MySQL\u00ae","The MySQL\u00ae database  is used by the RTC to store information including clients, applications, billing data (monthly minute usage per application), details about the WebRTC streaming server instances, etc. The MySQL\u00ae database  can be used by the components of CnC server  and developer dashboard .","Data Storage Components\u2014Cassandra\u00ae","In one embodiment the RTC tool uses Cassandra\u00ae database  to persist the usage and quality statistics including:\n\n","In some embodiments, the Cassandra\u00ae database  is a \u201cNoSQL\u201d storage engine. A NoSQL database provides a mechanism for storage and retrieval of data that employs less constrained consistency models than traditional relational databases. The Cassandra\u00ae database is used by the CnC application  and streaming agent  modules.","Data Storage Components\u2014Redis\u00ae","The Redis\u00ae database  can be used for exchanging events between the streaming server  and the components of streamer agent , and for providing to the streamer  a way to get an API key when authenticating a connection request. In some embodiments, the Redis\u00ae database  is a No-SQL database. The Redis\u00ae database can be hosted on cloud services such as Amazon EC2\u00ae.","Client Side Components","The client-side components of the RTC tool includes internal components of client SDKs and the API bindings, which are described in further detail in the following paragraphs.","Client Side Components\u2014RTC Client Side Service","The RTC client side service (referred to as \u201cRTC client\u201d), e.g., RTC client , is one of the core client-side components. The RTC client  can be responsible for the RTC features, especially where the native WebRTC implementation is not available, e.g., in mobile SDKs, desktop SDKs and browsers without the native support for the WebRTC via an RTC Plug-in . The RTC client  can contain modules for video conferencing aspects such as video capture devices management, video coding, quality control, networking, business logic and an audio engine built on top of the libWebRTC.","The API published by the RTC client  is composed of a few functions that use primitive values (integers, C-strings, pointers to platform specific structures for rendering, e.g., HWND\u2014a handle to window in Microsoft Windows\u00ae). The service functionality is available via a function\u2014invoke, which takes as the input parameter an invocation request serialized as a string. Internally the request is parsed and delegated to a proper internal function. The requests handling is implemented using known reactor design patterns, where all the requests are put in a queue by the calling thread and processed by a single Service thread. This approach can allow calls from application user interface (UI) thread, and reduce the possibility of synchronization issues within the RTC client  implementation.","The RTC client  can be implemented using various programming languages, including portable C\/C++ with platform specific subcomponents responsible for video capture devices handling, rendering and logging. It can be distributed as a native library, e.g., dll on Microsoft Windows\u00ae, dylib on Apple Mac OS X\u00ae, .framework for iOS\u00ae development, .so for Android\u00ae development, etc. The RTC client  interacts with the API bindings, the RTC Plug-in , the Operating System and the server-side components.","Client Side Components\u2014RTC Plug-in","The RTC Plug-in  uses the RTC client  to provide real-time audio and video streaming functionality to browsers not supporting the WebRTC technology natively. The RTC Plug-in  uses NPAPI standard on browsers supporting it and the ActiveX\u00ae on Microsoft Internet Explorer\u00ae. The browser compatibility layer is implemented with the help of the FireBreath\u00ae open source library. The RTC tool uses a unique approach to keeping the software up to date\u2014the RTC Plug-in  passes the requests to the RTC client  without being aware of the RTC client  functionality. The RTC client  component can be replaced while the RTC Plug-in  is loaded in memory without the need to restart the browser.","Client Side Components\u2014API Bindings","The RTC client  uses several API bindings allowing users, e.g., application developers who integrate RTC tool into their software applications to use the RTC client  with the various platforms available on the market. The APIs offered include\n\n","The RTC tool uses various communication protocols, e.g., between the server side components and the client side components. The RTC tool uses at least three classes of communication protocols: the signaling protocol for media session establishment and maintenance, the media protocols for transmission of media data: audio, video, screen, and for the auxiliary communication for diagnostics and platform maintenance.","The signaling and media streaming protocols can be used in communication between the RTC client  or WebRTC-enabled browser and the streaming server . The auxiliary communication can be performed between the client SDKs and the CnC web application .","Communication Protocols\u2014Signaling","The RTC tool uses various protocols, including a proprietary protocol for the signaling part of the client server communication. The existing protocols that have been considered for this purpose (SIP, H.323), were designed to accomplish a calling scenario, where peer A calls peer B in order to establish media session. The client SDKs, e.g., desktop SDK , to establish a multimedia session between peer A and B (or any other peers involved) make a logical connection to a single virtual room\u2014the media scope or session. This use case requires the flexibility not offered by any of the aforementioned protocols, which led to a proprietary protocol. The protocol designed is built on top of a reliable Transport Layer Security (TLS) over Transmission Control Protocol (TCP) channel and can use Google\u00ae Protocol Buffers library for messages serialization.","The TLS over TCP is selected for various reasons. First of all, the TCP protocol offers a reliability of the data delivery, which can be crucial for the use case. Additionally, since the rate of the signaling messages exchanged is fairly low, the variable latency of the TCP is not an issue. Finally the use of TLS\/TCP and port  on the streamer  side allows the protocol to mimic HTTPS traffic, which improves the ability to traverse firewall and NAT devices. In one embodiment, the signaling protocol (also called the \u201cmanagement link\u201d) is composed of following message types:\n\n","The transmission of the real-time media data places high demands on the networking infrastructure. These requirements include but are not limited to:\n\n","The RTC tool is designed to ensure the best quality possible, even in environments as hostile as the WAN. The RTC tool uses a suit of media protocols to ensure the best quality where possible and fallback to the best effort when required. The core protocol used is the industry standard SRTP and RTCP. Using it as a base, the RTC tool also supports following transport mechanisms for the media streaming: (1) User Datagram Protocol (UDP) in peer-to-peer mode (P2P), (2) UDP relayed through the streaming server , and (3) Transport Layer Security (TLS) over TCP fallback trough the streaming server .","The RTC tool uses the UDP relayed protocol as a primary media streaming transport mechanism. After the client SDK  establishes the management link to the Streamer , the RTC client  will first try to use this protocol. If the UDP communication fails (most likely due to a firewall restriction), the RTC client  will try to reach the Streamer  over the TCP fallback transport type. The P2P mode of the UDP based protocol is used as an optimization in case there are only two peers connected to a scope. The state transitions between different media connection types are shown in the . Initially, UDP probing  is performed. Is successful, a UDP relay  is established with a UDP P2P . UDP probing  fails, TCP connecting  is pursued. If successful, a TCP\/TLS session  transpires. Disconnection occurs upon a disconnect state of a failed TCP connection .","The following sections provide more detailed description of each of the media transport mechanisms employed by the RTC tool.","UDP Relay Connection","The UDP relay connection is the primary connection type for the RTC tool. The RTC client  tries to establish this type of a connection as soon as the authentication response from the streamer  is received. To ensure that the UDP packet flow is functional, the client component sends a series of probing packets to the UDP ports given in the response. After receiving at least a single reply, the UDP channel is considered as functional and the media packets flow begins.","The UDP relay uses multiple UDP ports for streaming purposes. In some embodiments, initially the client SDK  will attempt to connect to the streamer  using ports  for the audio stream and the port  for video. This is to ease the port-based Quality of Service (QoS) polices when using the on-premise deployments. If the RTC client  fails to communicate using the default ports, it will proceed and attempt to establish the connection using the TCP fallback. Upon a success, it will try to establish UDP connectivity again, using multiple possible remote UDP ports, with audio and video multiplexed within a single channel. This is to leverage the existing firewall exception policies that may be configured on the end user network for other media streaming services.","TLS Over TCP Fallback Connection","The TLS over TCP connection is treated as a fallback for clients behind restrictive firewall devices. The RTC client  will try to establish the TCP streaming connection when the UDP probing timeout occurs. The connection is made to the same host and the same port as with the management link\u2014port . Once the TCP and TLS connection is established, the connection is considered as functional and the media packets flow will start. Since the TCP uses data streams instead of datagrams, the RTC tool uses Protocol Buffers messages to serialize and de-multiplex between signaling and media packets.","UDP P2P Connection","An attempt to establish the Peer-to-Peer (P2P) transport is done only when there are two clients in the session and if the UDP relay works for both of them. The notification to enable the P2P mode is always sent by the streamer . This is because, in some embodiments, the streamer  is the only component that has all the data needed to decide whether this mode should be enabled. The data includes the exact number of users connected, type of media protocol used by each participant, and the public UDP endpoints used by participants.","The notification is sent using the user event message over the signaling channel. The body of the message contains only the public UDP endpoint of the remote peer. The RTC client  will use this information and probe the endpoint. Upon a success, the data transmission is smoothly transitioned to use the direct link. The communication between the RTC client  and streamer  is maintained, even when the media streaming uses direct channel. This is to ensure that the port mapping is maintained on the NAT device used by the client.","The P2P connection establishment process employs the core mechanisms from the RFC 5245[4] ICE protocol, such as: UDP hole punching, exchange of UDP endpoints visible from the WAN or heart-beating.","Proxy Support","The signaling and media streaming protocols are functional also when the end-user device is connected to the Internet via a proxy. The RTC tool supports following various proxy server types, including: SOCKS5 TCP and UDP proxies, without the authentication support, HTTPS proxies not requiring authentication, HTTPS proxies requiring basic or digest authentication, HTTPS proxies using Kerberos\/NTLM for authentication.","Auxiliary Communication","The RTC client  communicates also with the CnC application . For this purpose, it can use the HTTPS protocol. A streamer endpoint resolution is a process where an application id and scope id are passed to the CnC component , to resolve which streamer  should be used to conduct the session. The request can be made using HTTPS GET method with parameters encoded in the query string. The CnC application  can reply using a plain text string, e.g., in the form of STREAMER HOST+\u201c:\u201d +STREAMER PORT.","The RTC client  can use several POST requests to facilitate automatic bug reports in case of a platform failure, media devices used during a session upon a successful connection, service logs while the client is connected to any session, etc.","RTC Tool Quality Adaptation","The RTC tool provides an adaptive layer protecting an end user's endpoint from congestion and resources overuse (e.g., CPU overuse). The RTC tool controls the quality of the video streams to ensure the fixed, high quality of audio streaming. The RTC tool can scale the quality of the video feed from, e.g., 64 kbps (QVGA @ 10FPS) up to 1-1.5 Mbps (720p @ 24 FPS). It means that the streams generated by the RTC tool can require as little as 100 kbps of bandwidth for the tool to operate","The RTC tool uses 3 types of quality control adaptation including Uplink adaptation, Downlink adaptation, and Peer to Peer adaptation.","Uplink Adaptation","The Uplink adaptation monitors client network to detect: packet queuing delay to avoid the congestion early (before there is loss), packet loss (in case of networks lossy in general) and increased jitter.","The reduction of the quality is done on various levels: quality of the encoder (target bitrate), size of the video feed and amount of the frames per second.","When publishing the video stream, an application tells the SDK the maximum quality it wants to publish (max width, height and frames per second). The SDK uses this as an upper cap of the quality of the video feed.","Downlink Adaptation","The downlink adaptation uses an approach called simulcast. For the simulcasting, the RTC tool uses two separate video streams (no SVC, streams are not related): high quality video feed (the dynamic bitrate and quality, see uplink adaptation) and low quality feed (fixed bitrate and quality). In one embodiment, the high quality feed is the primary one exchanged between the peers by default.","The low quality feed is used when one of the peers involved in a session has problems with the reception of the data. The streamer can detect this by increased loss and\/or queuing delay. In this case the streamer will request one or more other participants to start publishing an extra low quality feed, which gets delivered to the peer with issues to reduce the bandwidth utilization and avoid congestion.","Peer to Peer Adaptation","When session has only two users connected, the session uses a single layer of dynamic quality. Each peer can reduce quality when there are issues on the uplink side, exactly as per the uplink adaptation. When it comes to congestion when receiving the data, each peer reports to the other peer the capacity of the downlink. When the uplink side detects that the other end has problems with the reception, it will back off the quality to a level where the queuing delay is stable (thus, the capacity of the channel was reached).","RTC Tool Reliability","The following paragraphs provide a brief overview of the reliability of the RTC tool. In some embodiments, the RTC tool can ensure a 99.95% up-time reliability policy. In some embodiments, to ensure the reliability, the RTC tool focuses on the streaming service .","Streamer Reliability","The RTC tool is built on the assumption that each instance of the streamer  may fail at any time. The following paragraphs describe the techniques to ensure service resilience to outages of a single instance of the streamer .","Streamer Reliability\u2014Reconnects","The key facility to achieve this resilience is the reconnects. When the client SDK  detects a lost connection, it will automatically try to recover by reestablishing a connection. To achieve this it will request a streaming endpoint from the CnC application . This request can contain two additional query string parameters (in addition to applicationld and scopeld): e.g., \u201creconnect=true\u201d to explicitly indicate that this is a reconnect request, \u201cstreamer=endpoint\u201d to inform the CnC application  about which instance of the streamer potentially failed.","The CnC application  handles those special mapping requests by checking the health of the Streamer reported and by returning a new one if necessary. The exact procedure can be described using the following example procedure:\n\n","If the above procedure reports that the streamer is functional, the existing mapping will be returned to the client. Otherwise, a new instance of the streamer  can be selected using the following example procedure:\n\n","Finally, an embodiment of the locking subroutine is composed of following example steps:\n\n","Before sending this request, the client SDK  can wait a random amount of milliseconds (between one and two seconds). This approach can serve two purposes: to prevent a flood of similar requests and to cover the case when a streamer  crashed and instantly restarted by the supervisor daemon.","Streamer Reliability\u2014Monitoring","As another reliability measure, the RTC tool monitors the health of the streamer processes  and hosts. It allows the RTC tool to detect issues before they are experienced by end users such as end users , , ,  and . In one embodiment, the monitoring facility is composed of the following layers:\n\n","The CnC application  is a web application can be implemented with Python\u00ae and Flask\u00ae. In some embodiments, reliability of the CnC application  can be ensured using tools and methodologies publicly available. The CnC application  can run on completely separate deployments in different cloud server regions, e.g., Amazon EC2\u00ae regions (North Virginia and Oregon). Both of these deployments can use distinctive domain names, e.g., cnc2.addlive.com and cnc3.addlive.com.","The implementation of the client SDK  uses all configured CnC endpoints for the streamer endpoint resolution. At first, it will choose a random endpoint from the list configured. If the resolution fails, it will iterate repeatedly through the available resolvers until one succeeds or the retry limit is reached.","Both CnC deployments use the same setup. This configuration uses Nginx\u00ae as a reverse proxy with multiple nodes attached to a single upstream. Subsequently each node that is linked the master Nginx\u00ae server, uses Nginx\u00ae as a reverse proxy and has multiple uWSGI processes as final workers. Additionally, the configuration of the leaf http server uses a retry policy where an error result triggers the request to be passed to the next uWSGI process in the upstream. This approach allows the platform to seamlessly handle temporal issues with e.g., database connectivity.","Redis\u00ae Reliability","The Redis\u00ae datastore  is used throughout the RTC tool. The RTC tool uses two separate deployments of Redis\u00ae 115, e.g., one to store the API keys and the other to maintain the session-streamer mappings. The reliability of both deployments is achieved in different ways due to different usage patterns. This is described in the following paragraphs.","Redis\u00ae Reliability\u2014Credentials Store Reliability","Each streaming node runs a local copy of the Redis\u00ae server  and communicates with it using the Unix\u00ae domain sockets. Every local database server is connected to a single master as a read-only slave. Whenever customers create, modify or remove the API credentials, these data are stored in a SQL database and in the Redis\u00ae master server. The Redis\u00ae master server then populates the API credentials to all the slaves.","This approach makes the authentication process robust. Since the local instances of Redis\u00ae are employed for authentication, the service will operate seamlessly even if the master node fails or any network partitioning occurs. In case of master failure, to restore the API credentials store manageability, the RTC tool administrator is only required to start another host running an instance of the Redis\u00ae server, populate it with the data from the MySQL database  and assign the designated elastic IP.","Furthermore, a failure of a slave usually occurs due to a failure of the complete host, in which case the streaming service is already compromised on the node. The crash of a Redis\u00ae server  is highly unlikely and is handled manually either by restarting the Redis\u00ae server  process or by replacing the streaming node with a completely new instance.","Redis\u00ae Reliability\u2014Streamer Mapping Reliability","In some embodiments, to scale the service horizontally, the RTC tool uses multiple instances of the Redis\u00ae database  to store the session-streamer mappings. The instance to be used by a particular mapping is defined using a simple partitioner, which uses an application id and a session id to generate an index of the Redis\u00ae node to be used. Additionally, this approach improves reliability as there is no single point of failure.","To keep the service operational when one of those instances fails, every instance has a read-only slave. When there is an issue with one of the master database servers, the CnC application  that detected it instantly falls back to the slave, effectively promoting it to a new master. This is possible because Redis\u00ae 115 allows itself to be reconfigured on-line using the CONFIG SET commands.","Temporary Infrastructure Creation Kit","The temporary infrastructure creation kit provides entities using the RTC tool to provide RTC features to their clients, with a package (e.g., bundle, distribution) that will contain RTC tool provider assets (e.g., server side components, client SDKs, Plug-in installers, etc.) and a set of scripts that will take a descriptor as an input and will spin off a cluster of all the necessary infrastructure.","With this approach, whenever the infrastructure maintained, e.g., streamer , by the RTC provider for the functioning of the RTC tool fails, the entities can still provide RTC services to their clients, with no to minimal downtime. The above described method provides an effective disaster recovery technique. This way, the entities using the RTC tool can be sure of the RTC tool's availability and trust the RTC tool provider. The temporary infrastructure creation kit can be used when the RTC infrastructure maintained by the RTC tool provider fails. In some embodiments, a client will have to initiate it manually if certain outage was reached or we went out of business.","RTC Tool Security","The following paragraphs explain the security features of the RTC tool. The security analysis covers following areas: (1) Connection Authentication\u2014validation that only allowed users can connect to a particular session, (2) Communication security\u2014assessment of the media and signaling channels security to prevent eavesdropping, (3) Binary components security\u2014assessment of the security of the binaries installation processes to prevent use of the RTC tool as a target vector for installation of malicious software.","RTC Tool Security\u2014Connection Authentication","Within the RTC tool each and every connection made to the WebRTC streaming server  needs to be authenticated. This is to ensure that only the users that are allowed by the original application, connect and receive streams from other peers. The authentication scheme does not require any communication between the server side components and the RTC tool. Instead, on the server side, the application should prepare all the required data, sign them using a shared secret (a.k.a. \u201cAPI Key\u201d) and pass it to the client component of the application. The client side then, should use the data given, to prepare the connection descriptor.","To authenticate a given connection request, the RTC tool expects data, including the following data to be provided:\n\n","The above authentication data should be passed, e.g., in the authDetails attribute of the ConnectionDescriptor object passed to the connect method of the API binding.","Communication Security","Communication Security\u2014Signaling","In order to protect user data from eavesdropping, the signaling messages are transmitted over the TLS\/TCP channel using the TLS 1.0 encryption scheme. In some embodiments, the scheme is configured as follows: (1) cipher suites are restricted to 128 and 256 bit key AES encryption, (2) key exchange is done using the Ephemeral Diffie-Hellman algorithm, (3) for peer authentication, the RSA algorithm is employed, (4) for message (block) authentication the SHA1 algorithm is employed.","Communication Security\u2014Media Streaming","In some embodiments, the media data flow is protected using the Secure Real-time Transport Protocol (SRTP). The SRTP provides confidentiality, message authentication and replay protection. The keys used for media encryption are volatile, generated by the streamer  during the session creation (when the first participant joins the session). Once generated, the key is not persisted anywhere and is transmitted to peers within the auth response message over the already secured signaling channel.","In some embodiments, the SRTP encryption scheme is configured in the following way: (1) AES CBC 128 bit key for RTP packet encryption, (2) HMAC SHA1 for packet authentication and integrity, (3) No RTCP packets authentication.","Communication Security\u2014Binary Components Security","This section covers briefly the security of the binary components installed on the end-user computer, e.g., RTC Plug-in  installation and self-updating.","The RTC Plug-in  is available for various operating systems, including Apple Mac OS X\u00ae and Microsoft Windows\u00ae operating systems. On the Windows\u00ae platform, the installation process is done using a custom installer binary. Also on this platform, all the binaries used by the RTC Plug-in  or Native Desktop SDK are cryptographically signed, using a certificate issued by a well trusted certifying authority, e.g., GlobalSign\u00ae Inc.","On The Mac OS X\u00ae platform, all the binaries are signed using the certificate issued by Apple\u00ae as a part of Mac OS X\u00ae developer program.","The RTC Plug-in  self-update process from security perspective works in the same way on both desktop platforms. In some embodiments, it can be described in following high-level steps:\n\n","Also as an additional security means, all the update components and installers are protected by a monitoring service ensuring that the binaries available are those uploaded by the RTC tool provider responsible for the distribution.",{"@attributes":{"id":"p-0098","num":"0165"},"figref":"FIG. 4","b":"400"},"In some embodiments, the RTC application can also be used for commercial purposes. For example, service providers, such as attorneys, can providing counseling to their clients using the RTC application. The service provider and the client may view and hear each other using the RTC application. In some embodiments, the RTC application may require the users who wish to the use the RTC application to sign up and create a profile with the RTC application.","The RTC application includes a mechanism for a service provider to bill a client who wishes to use his\/her services. In the GUI , a service provider \u201cKavan\u201d receives a call from a user or a client \u201cBob\u201d who wishes to talk to Kavan. The service provider can choose whether to accept or reject the call from the client. If the service provider chooses to accept the call, the service provider may also choose to bill the call. The service provider may send the charge to the client using the mechanism, e.g., a button \u201cBill Bob?\u201d provided on the GUI . The client can choose to accept or reject the charge as explained at least with reference to . Accordingly, embodiments of the disclosed technology enables billing a user in a single click of a button.",{"@attributes":{"id":"p-0101","num":"0168"},"figref":"FIG. 5","b":["500","500"]},"In some embodiments, upon accepting the charge, the client may be presented with a list of available payment methods that the client can choose from to pay the service provider. An example GUI showing the list of available payment methods is illustrated in GUI  of . Upon selecting one of the payment methods displayed in GUI , the RTC application requests the client to provide the payment details, e.g., credit card number, checking account number, etc.  illustrates an example GUI  for providing payment details to the RTC application, consistent with various embodiments of the disclosed technology. After the payment is successfully completed, the client is connected to the service provider.","The client can be charged in various ways, e.g., a flat fee, per hour, etc. If the client is charged on a per hour basis, the client may billed at the end of the call in which case the RTC application does not charge the client upon receiving the payment details in GUI . The RTC application may just validate the payment method in GUI  and then connect the call. The service provider and the client may engage in conversation as illustrated in GUI  of . The GUI  can display a variety of information including, charge per hour, duration of the call, current charges for the call, whether the call is billed, etc. Upon completing the call, the client is billed using the payment details provide in GUI .","In some embodiments, the client may provide a default payment method in his\/her user profile created with the RTC application. If the client has a default payment method and enabled a single click payment, the client may make the payment in a single click of a button. For example, consider that the client has configured a default payment method and enabled single click payment in his profile. When the client receives a charge from the service provider, as illustrated in GUI , on selecting accept, the client is directly connected to the call and the GUI  is presented to the client. The payment method GUI  and payment detail GUI  may not displayed to the client.","Accordingly, embodiments of the disclosed technology enables a user of the RTC application to bill in a single click and to pay in a single click. It should be noted that the GUIs illustrated in  are examples only. The GUIs can be designed in various ways, for example, the \u201cBill Button\u201d can be implemented as a link or any other GUI element. The GUI - can display additional or less information, e.g., information related to the RTC application, users, the call, charges, etc.",{"@attributes":{"id":"p-0106","num":"0173"},"figref":["FIG. 9","FIGS. 1-8"],"b":["900","900","905","910","925","920","930","915","915","915"]},"The memory  and storage devices  are computer-readable storage media that may store instructions that implement at least portions of the described technology. In addition, the data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communications link. Various communications links may be used, such as the Internet, a local area network, a wide area network, or a point-to-point dial-up connection. Thus, computer-readable media can include computer-readable storage media (e.g., \u201cnon-transitory\u201d media) and computer-readable transmission media.","The instructions stored in memory  can be implemented as software and\/or firmware to program the processor(s)  to carry out actions described above. In some embodiments, such software or firmware may be initially provided to the processing system  by downloading it from a remote system through the computing system  (e.g., via network adapter ).","The technology introduced herein can be implemented by, for example, programmable circuitry (e.g., one or more microprocessors) programmed with software and\/or firmware, or entirely in special-purpose hardwired (non-programmable) circuitry, or in a combination of such forms. Special-purpose hardwired circuitry may be in the form of, for example, one or more ASICs, PLDs, FPGAs, etc.","The above description and drawings are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding of the disclosure. However, in certain instances, well-known details are not described in order to avoid obscuring the description. Further, various modifications may be made without deviating from the scope of the embodiments. Accordingly, the embodiments are not limited except as by the appended claims.","Reference in this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the disclosure. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment, nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover, various features are described which may be exhibited by some embodiments and not by others. Similarly, various requirements are described which may be requirements for some embodiments but not for other embodiments.","The terms used in this specification generally have their ordinary meanings in the art, within the context of the disclosure, and in the specific context where each term is used. Certain terms that are used to describe the disclosure are discussed below, or elsewhere in the specification, to provide additional guidance to the practitioner regarding the description of the disclosure. For convenience, certain terms may be highlighted, for example using italics and\/or quotation marks. The use of highlighting has no influence on the scope and meaning of a term; the scope and meaning of a term is the same, in the same context, whether or not it is highlighted. It will be appreciated that the same thing can be said in more than one way. One will recognize that \u201cmemory\u201d is one form of a \u201cstorage\u201d and that the terms may on occasion be used interchangeably.","Consequently, alternative language and synonyms may be used for any one or more of the terms discussed herein, nor is any special significance to be placed upon whether or not a term is elaborated or discussed herein. Synonyms for certain terms are provided. A recital of one or more synonyms does not exclude the use of other synonyms. The use of examples anywhere in this specification including examples of any term discussed herein is illustrative only, and is not intended to further limit the scope and meaning of the disclosure or of any exemplified term. Likewise, the disclosure is not limited to various embodiments given in this specification.","Those skilled in the art will appreciate that the logic illustrated in each of the flow diagrams discussed above, may be altered in various ways. For example, the order of the logic may be rearranged, sub-steps may be performed in parallel, illustrated logic may be omitted; other logic may be included, etc.","Without intent to further limit the scope of the disclosure, examples of instruments, apparatus, methods and their related results according to the embodiments of the present disclosure are given below. Note that titles or subtitles may be used in the examples for convenience of a reader, which in no way should limit the scope of the disclosure. Unless otherwise defined, all technical and scientific terms used herein have the same meaning as commonly understood by one of ordinary skill in the art to which this disclosure pertains. In the case of conflict, the present document, including definitions will control."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
