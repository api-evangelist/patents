---
title: Method and system for copying a snapshot tree
abstract: Various embodiments of the present invention are directed to an instant snapshot-tree-copy operation that, when directed to an existing snapshot tree, generates a data-structure framework for a copy of the existing snapshot tree that can be immediately accessed while a background-copy process copies data from the existing snapshot tree to the copy snapshot tree. The background-copy process copies data from the existing snapshot tree to the copy snapshot tree in top-down fashion, from the source logical device through each of the snapshot logical devices. While copying each logical device, the background-copy process sequentially copies data-storage units from a corresponding logical device of the existing snapshot tree to the copy-snapshot-tree logical device, making sure to adjust chains of dependencies within the copy snapshot tree to reflect modifications to the snapshot copy tree that occur independently from the background-copy process. A host computer may immediately access the copy snapshot tree, both for READ and WRITE access, even before completion of the background-copy process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07788244&OS=07788244&RS=07788244
owner: Hewlett-Packard Development Company, L.P.
number: 07788244
owner_city: Houston
owner_country: US
publication_date: 20070731
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Mass-Storage Systems","Snapshot Operation","Embodiments of the Present Invention"],"p":["The present invention is related to mass-storage systems that provide logical-device-based data-storage interfaces to accessing host computers that include snapshot operations and, in particular, to a method and system for providing an instant-copy operation for making a copy of a snapshot tree.","Mass-storage devices and mass-storage systems have evolved, during the past 60 years, as rapidly and profoundly, if not more rapidly and profoundly, than computer processors and electronic memories. Initially, mass-storage devices were either incorporated within, or directly connected to, computer systems, for exclusive access by the computer systems in which they were included. Later, dual-ported mass-storage devices that could support connections to two or more computer systems were developed, in order to provide for more reliable data storage within multi-computer systems. Techniques for concurrent access to mass-storage devices by multiple computers were developed, as well as additional techniques for using redundantly stored data to increase the reliability and fault-tolerance of mass-storage devices. With the advent of computer networking, computer systems became capable of accessing remote mass-storage devices via servers that managed the mass-storage devices on behalf of accessing host computers. More recently, and continuing to the present time, autonomous mass-storage systems have been developed to allow computers to access the mass-storage systems directly through network communications. These autonomous mass-storage systems often feature redundant controllers and redundant internal communications paths, and store data redundantly according to one or more of the various RAID schemes to provide highly available and highly fault-tolerant data storage. Presently, there is a wide range of available mass-storage systems for use in computer systems and networked computer environments.","Mass-storage systems generally provide a logical-device-based data-storage interface to accessing host computers. Host computers create, store data to, and retrieve data from, logical devices. Each logical device comprises a set of consecutively-addressable data-storage units. For example, a logical device may be considered, by the host computer, as comprising a linear array of data blocks that include either a fixed or a variable number of bytes, words, or another smallest-granularity unit of data storage. Mass-storage systems also generally provide various management and administrative operations to host computers, including a snapshot operation. A snapshot operation generates a logical copy of the contents of a logical device at a fixed point in time. The logical copy is contained in a snapshot logical device. Once a snapshot operation has been directed to a logical device, the logical device may continue to be accessed by host computers and modified by WRITE operations. Should, at a future point in time, a host computer wish to restore the logical device to the data state at the point in time at which a snapshot operation was directed to the logical device, the host computer can direct a RESTORE command to the logical device, specifying the snapshot logical device that corresponds to the point in time or the time point. Snapshot operations can be issued, one after another, at fixed points in time in order to provide a set of potential restore points to allow a host computer to restore a logical device to the data state that the logical device had at any of the restore points represented by snapshot logical devices generated by the snapshot operations.","The set of snapshots, or snapshot logical devices, generated for a source logical device, along with the source logical device, together comprise a snapshot tree. A host computer can restore the source logical device to the data state that the source logical device had at any in point in time represented by a snapshot in the snapshot tree. In general, the snapshots in the snapshot tree are not full copies of the source logical device, but contain only differential data sufficient to restore the logical device to the data state at the time represented by the snapshot. The snapshots within the snapshot tree are generally interdependent, and often, during a restore operation, a number of different snapshots within the snapshot tree need to be accessed in order to restore the source logical device to a previous data state. The entire snapshot tree is therefore a rather complex set of interdependent, somewhat special types of logical devices. While current mass-storage systems provide snapshot and restore operations, current mass-storage systems do not provide a convenient means for managing the entire set of source and snapshot logical devices that together compose a snapshot tree. Researchers, developers, manufacturers, vendors, and users of mass-storage systems thus recognize a need to continue to develop and provide new and improved methods and systems for managing snapshot trees within a complex mass-storage system.","Various embodiments of the present invention are directed to an instant snapshot-tree-copy operation that, when directed to an existing snapshot tree, generates a data-structure framework for a copy of the existing snapshot tree that can be immediately accessed while a background-copy process copies data from the existing snapshot tree to the copy snapshot tree. In one embodiment of the present invention, he background-copy process copies data from the existing snapshot tree to the copy snapshot tree in top-down fashion, from the source logical device through each of the snapshot logical devices. While copying each logical device, the background-copy process sequentially copies data-storage units from a corresponding logical device of the existing snapshot tree to the copy-snapshot-tree logical device, making sure to adjust chains of dependencies within the copy snapshot tree to reflect modifications to the snapshot copy tree that occur independently from the background-copy process. A host computer may immediately access the copy snapshot tree, both for READ and WRITE access, even before completion of the background-copy process.","The present invention is directed to a method and system for instant snapshot-tree copy within a mass-storage system. In a first subsection, below, an exemplary mass-storage system is discussed to provide a suitable foundation for the following discussion of the present invention. In the second subsection, details of the snapshot operation and snapshot trees are discussed, to complete the foundation information for discussion of the present invention. Finally, in a third subsection, embodiments of the present invention are discussed.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1A","FIG. 1A"],"b":["102","104","105","106","107","110","104","105","112","129","129","132","134","136","138","144"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B","FIG. 1B"],"b":["150","160","170"]},"As one example of the complexities of mass-storage systems, most mass-storage systems employ one of various techniques of redundant data storage in order to increase the reliability and fault-tolerance of the mass-storage system. In one redundant-data-storage scheme, the mass-storage system mirrors mass-storage devices, so that each data block within a logical device is stored twice, on two different mass-storage devices, within the mass-storage system. A second redundant-data-storage scheme is referred to as \u201cerasure coding\u201d redundancy. Erasure coding redundancy is somewhat more complicated than mirror scheme. Erasure coding redundancy often employ Reed-Solomon encoding techniques used for error control coding of communications messages and other digital data transferred through noisy channels. These error-control-coding techniques are specific examples of binary linear codes. Data blocks are striped across multiple mass-storage devices along with additional blocks containing parity, or checksum, data. Depending on the specific error-control-coding technique and the amount of parity data stored for each block of data, failure of one, two, or more mass-storage devices in the set of mass-storage devices across which data blocks are striped can be accommodated without data loss, since the surviving mass-storage devices contain sufficient data and parity information to completely recover those data and parity blocks lost due to failure of the one, two, or more mass-storage devices. The second redundant-data-storage scheme is somewhat more complex than mirroring, but is much more efficient with respect to the amount of data that needs to be stored redundantly in order to recover from particular mass-storage-device-failure scenarios.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["202","204","206","208","210","212","214","216","216","204","206","208","210","212","214","216","212","214"]},"A common high-level data-storage interface that can be provided by both individual mass-storage systems and by mass-storage-system aggregators\/servers is next described. This data-storage interface is but one example of many possible general data-storage interfaces that can be provided by mass-storage systems. Rather than attempt to discuss the present invention with respect to all possible data-storage interfaces, the present invention is described, below, with respect to the general data-storage interface now discussed with reference to .",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 3","FIG. 3","FIG. 3"],"b":["302","303","302","304","305","303","306","308","310","313","304","310","314"]},"The LDADs shown in  may, in many cases, map to individual mass-storage systems. Thus, a mass-storage-system aggregator\/server may provide the general data-storage interface shown in  to host computers, and may map each LDAD provided to host computers to a different mass-storage system. However, a mass-storage system may also choose to provide a general data-storage interface that includes two or more LDADs, and a mass-storage-system aggregator\/server may map a given LDAD to multiple mass-storage systems or may map two or more LDADs to a single mass-storage system. Logical devices are consecutive sequences of addressable data-storage units. In the general data-storage interface shown in , an Rstore object is data-storage space allocated on a number of mass-storage devices within a mass-storage system according to a redundant-data-storage scheme, such as mirroring or an erasure-coding-based redundant-data-storage scheme. For example, an Rstore may be several gigabytes of data striped across a number of mass-storage devices, along with parity information. The Rseg objects are smaller-granularity partitions of the Rstore space. For example, each Rseg may contain one megabyte of data-storage space. The Rstore and Rseg data objects conveniently abstract the contents of a logical device from the particular redundant-data-storage-based scheme used for storing the data contained in the logical device. The particular sizes of the Rstore and Rseg data objects are not relevant to discussion of the present invention. The particular redundant-data-storage-based data-storage schemes that are used for storing data are also not relevant.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 4","FIG. 4"],"b":["402","404","411","412","416","413","404","1","404"]},"Various data structures are employed within a mass-storage system or mass-storage aggregator\/server, both subsequently referred to as \u201cmass-storage systems,\u201d for managing the data-storage objects within a mass-storage system. One possible set of data structures is next described.  illustrates a logical-device table associated with each LDAD for representing the logical devices within an LDAD. The logical device table  includes a number of entries, each entry corresponding to a different logical device. Each entry of the logical device table contains, or references, a data structure that includes a number of different fields that describe the logical device represented by the entry. In , the first entry of the logical device table  is shown to reference a data structure  containing a number of different fields that describe the logical device represented by the first entry of the logical device table. One field  references an L2MAP  which contains detailed information about the contents of the logical device. The data structure  also contains source and destination pointers  and  that point back into the logical device table  to indicate the source and destination for restore operations. The data structure further includes a successor pointer  and a predecessor pointer  that also refer to entries in the logical device table, as well as an ir_source pointer used during restore operations . The successor and predecessor references allow logical devices to be linked together into snapshot trees. Use of the successor and predecessor references  and  is described further, below. The data structure  may contain many additional fields that describe various aspects of, or current operations performed on, logical devices.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 6","FIG. 5","FIG. 6","FIG. 6","FIG. 6","FIG. 6"],"b":["600","601","602","604","602","606","608","604","610","612","606","608","610","612","602","604","614","616","618","620"]},"Each RSD data structure contains metadata describing the Rstore which the RSD represents, a representation of the physical segments onto which the Rstore is mapped , and information about each of the Rsegs contained within the Rstore. For purposes of describing the present invention, each Rseg is described, in part, in the RSD by three single-bit fields. For example, as shown in , the first Rseg  described in RSD  is described, in part, by: (1) an ss bit  that indicate whether the Rseg depends on data stored in a corresponding Rseg of a successor logical device; (2) an sp bit  that indicates whether or not the Rseg depends on data stored in a corresponding Rseg of a predecessor logical device; and (3) an ir bit  used during restore operations. The use of the ss and sp bits is described, in greater detail, below, as is the use of the ir bit and ir_source field during instant snap tree copy operations. Again, it should be noted that many different possible data structures can be used to represent logical devices within a mass-storage system. The data structures discussed with reference to  provide a convenient foundation, or exemplary data-structure scheme, for discussion of embodiments of the present invention, below. However, the present invention may be practiced on, or applied to, many different data-structure representations of LDADs and logical devices within many different types of mass-storage systems. Even for the described data structures, many different implementations and layouts are possible, and the present invention may be practiced on, or applied to, any of the many possible implementations and layouts.","Next, a snapshot operation is described with reference to .  use similar illustration conventions, described below with respect to .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 7A","FIG. 7A","FIG. 7A"],"b":["702","704","704","702","706"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 7B","FIG. 7B"],"b":["702","708","712","714","716"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 7C","FIG. 7C","FIG. 7B"],"b":["704","719","723","711","712","716"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7D","b":["730","716","702"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 7E","FIG. 7E"],"b":["740","742","744","742","743","744"]},"Snapshot operations are quite useful for data-management applications. For example, a relational database management system (\u201cRDMS\u201d) may frequently, at a fixed interval in time, or following fixed amounts of accesses or activity, take snapshots of one or more logical devices within which the RDMS stores tables, views, and other data. Should, for some reason, one or more of the logical devices become corrupted, due to problems at the RDMS level, the RDMS can restore the logical devices to successively more distant points in time from the current time until a version of the logical devices is obtained in which there is no data corruption. The RDMS can then use separate log files stored within separate logical devices to re-execute intervening transactions in order to bring the state of the RDMS up to a most recent state prior to detection of the data corruption. Snapshot operations also find use in data archiving and other applications.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIGS. 8A-G","FIGS. 3-4","FIGS. 5-6"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 8A","FIG. 7A","FIG. 8A"],"b":["802","804","806","808"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 8B","b":["810","810","800","810","810","800","800","800","810","808","812","810"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 8C","FIG. 8B","FIG. 8C"],"b":["814","800","814","816","810","814","816","810","818","816","820","814","816","814"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 8D","FIG. 8A","FIG. 8B"],"b":["810","826","800","810","810","826","826","810"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 8E","FIG. 8E","FIG. 8F","FIG. 8G","FIG. 8F","FIG. 8F"],"b":["830","831","832","837","800","826","826","800","840","826","840","800","840"]},"The snapshot operation illustrated in  is space efficient. Rsegs are allocated and filled with data in snapshot logical devices only when necessary. Thus, the snapshot logical devices , , and  are sparse, and essentially contain data-state differences that occur in the source logical device from the time that the snapshot logical device is created until the time that a successor snapshot logical device is created. It should be noted that snapshot logical devices can be separately accessed in both READ and WRITE operations. For example, snapshot logical device  can be accessed to write the contents of Rseg . If the contents of Rseg  are altered by a WRITE operation, then the current contents of Rseg  are first copied into a newly allocated Rseg corresponding to Rseg  in snapshot logical device , since snapshot logical device  depends on snapshot logical device  with respect to that Rseg. Only when the contents of Rseg  have been copied to snapshot logical device  can the contents of Rseg  be modified, in order to maintain logical consistency within the snapshot tree comprising source logical device  and snapshot logical devices , , and .","Were a RESTIORE command to be directed to the source logical device  to retired the source logical device to the data state at the point in time represented by the first snapshot logical device , data from all three snapshot logical devices would be needed. For example, data for the first two Rsegs, \u201cA\u201d and \u201cB,\u201d is found, by following ss-bit-encoded dependency chains, in the second snapshot logical device , while data for the third Rseg, \u201cC,\u201d is found, by following an ss-bit-encoded dependency chain, in the third snapshot logical device . By contrast, data for the fourth, fifth, and sixth Rsegs, \u201cD,\u201d \u201cE,\u201d and \u201cF,\u201d is found in the first snapshot logical device. In other words, to restore the source logical device to a previous data state, the restore operation starts with a snapshot logical device corresponding to that data state, and locates the data for each Rseg either in that snapshot logical device, when it is present, or in successor logical devices when data is not present in the snapshot logical device corresponding to the data state to be restored.","For various reasons, it would be desirable to provide a snapshot-tree copy operation.  illustrates a snapshot-tree copy operation. As shown in , a snapshot tree  in a first LDAD  needs to be copied to a second LDAD . Currently, mass-storage systems do not provide a snapshot-tree copy operation. At best, a system administrator would need to employ restore operations in order to transform the snapshot logical devices with a snapshot tree into stand-alone logical devices, and then copy each of the separate logical devices. However, such a restore-based copy of a snapshot tree does not produce an equivalent snapshot tree, but instead produces a sequence of stand-alone logical devices that reflect the data state captured at particular points in time represented by the original snapshot logical devices. Moreover, the restore-based snapshot-tree copy results in significant expansion in the amount of data-storage space needed to store the copy snapshot tree. The original snapshot tree  is efficiently stored, as illustrated in . However, using a restore-based snapshot-tree copy operation, the resulting copy snapshot tree would essentially consist of four different, complete versions of the source logical device, rather than containing the sparse snapshot logical devices contained in the original snapshot tree .","The present invention provides a true snapshot-tree copy operation, as illustrated in , that preserves the logical structure of the original snapshot tree. The snapshot-tree copy operation of the present invention is first discussed, below, using the example snapshot logical tree shown in . Following this discussion, control-flow diagrams are provided to illustrate a snapshot-tree copy that represents one embodiment of the present invention.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIGS. 10A-K","FIGS. 10A-K","FIG. 10A"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 10A","FIG. 10A","FIG. 8G","FIG. 10A","FIG. 10A"],"b":["1002","8","1004","1002","1004","1004","1004","1006","1008","1004","1006","1010","1012","1002","1014","1015","1006","1010","1002","1016","1006"]},"Once the data-structure framework for the copy snapshot tree has been created, as shown in , the copy snapshot tree can be immediately written to and read from, even though it does not yet contain data. A background copy process is launched in order to copy data from the source snapshot tree  into the copy snapshot tree , while the copy snapshot tree  is essentially live, and accessible. The background copy process is illustrated in . The background copy process considers each logical device within the copy snapshot tree in order, starting with the logical device corresponding to the source logical device in the source snapshot tree. In alternative embodiments, the Rsegs of the copy snapshot tree may be processed in different orders, with logical devices, for example, of the snapshot tree processes in parallel. Thus, in , in the first step in the background copy process, the first Rseg  of the first logical device of the copy snapshot tree  is considered. Initially, the ir bit associated with this Rseg was cleared, as shown in . This means that data for the Rseg must be copied from the source snapshot tree . Therefore, the contents of the corresponding Rseg  in the source snapshot tree  are copied into a newly allocated Rseg within the copy snapshot tree , and the ir bit  is set to \u201c1,\u201d to indicate that the Rseg has been processed by the background-copy process. As shown in , this process continues, Rseg-by-Rseg, and results in the first logical device  within the copy snapshot tree  being fully allocated and containing data copied from the source snapshot tree .","Next, as shown in , attention turns to the second logical device  in the copy snapshot tree . The Rseg in the source snapshot tree  corresponding to the first Rseg  in the second logical device  of the copy snapshot tree  does not contain data, as indicated by the ss bit being set. Therefore, no data is copied into Rseg , but the ir bit  associated with Rseg  is set to indicate that Rseg  has been considered by the background-copy process. Consideration, by the background-copy process, of the first Rseg  in the second logical device  of the copy snapshot tree  with an associated ir bit that is not set and an associated ss bit that is not set, results in allocation of a new physical storage space for the Rseg  of the second logical device  and copying of data from the corresponding Rseg  from the source snapshot tree  into the newly allocated Rseg . As shown in , this process continues until all of the Rsegs in the second logical device  of the copy snapshot tree  have been considered. Note that, as a result of consideration by the background process, all of the Rsegs containing data in the corresponding logical device  in the source snapshot tree  resulted in allocation of Rsegs in the second logical device  in the copy snapshot tree  and copying of the contents of the Rsegs in the source snapshot tree  into the corresponding Rsegs of the second logical device  of the copy snapshot tree .","Next, as shown in , the background process considers the third logical device  in the copy snapshot tree  and begins to copy data, as needed, from the corresponding logical device  of the source snapshot tree .  illustrates completion of the background-copy process, after which the contents of the copy snapshot tree  are identical to the contents of the source snapshot tree . Of course, actual numerical contents of the data structures representing the copy snapshot tree are not identical to the numerical contents of the data structures representing the source snapshot tree since, for example, the detailed information within RSD data structures within the data-structure framework describing the copy snapshot tree may be quite different from corresponding details in the RSD data structures for the source snapshot tree . These differences reflect a generally different mapping of the logical structure of the copy snapshot tree to physical devices than the mapping of logical structures of the source snapshot tree  to physical storage. However, the copy snapshot tree  is logically identical to the source snapshot tree .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIGS. 10H-I","FIG. 10H","FIG. 10A","FIG. 10I"],"b":["1046","1008","1004","1002","1004","1048","1002","1046","1050","1020","1004","1050","1020","1046","1050","1050","1050","1046","1046","1046","1046"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIGS. 10J-K","FIG. 10J","FIG. 10K"],"b":["1056","1020","1004","1002","1056","1058","1008","1056","1058","1056","1060","1038","1004","1060","1002","1060","1056","1002","1002","1062","1062","1060"]},"Next, a series of control-flow diagrams are presented to illustrate a method embodiment of the present invention.  is a top-level control-flow diagram for the instant snapshot-tree copy operation that represents one embodiment of the present invention. In step , the command receives an indication of the snapshot tree to copy and an indication of the domain in which the copy is to be located. As discussed below, the RAID scheme used for the copy snapshot tree may be specified, in an additional parameter, to be different from that of the source snapshot tree. The snapshot tree to be copied is referred to as the \u201csource snapshot tree,\u201d and the copy snapshot tree is referred to as the \u201ctarget snapshot tree.\u201d Next, in step , the source snapshot tree is frozen, since the source snapshot tree cannot be modified during the embodiment of the instant snapshot-tree copy discussed with reference to . However, as discussed below, the target snapshot tree is essentially immediately available once a data-structure framework is created for the target snapshot tree. In certain embodiments, WRITEs and READs directed to the source snapshot tree may be accumulated for later application to the source snapshot tree. Next, in step , a data-structure framework for the target snapshot tree is created in the domain, or LDAD, in which the target snapshot tree resides. This involves creating and at least partially populating entries in the logical-device table, L2MAPs, LMAPs, and RSD data structures.  illustrates creation of a data-structure framework. Next, in step , all of the share bits, including the ss and sp bits, of the source snapshot tree are duplicated in the target snapshot tree. The ir bits for the Rsegs of the target snapshot tree are cleared, and the ir_source fields for the target snapshot tree are initialized with pointers to corresponding logical devices in the source-snapshot-tree, as discussed above with reference to . Next, in step , the background-copy process is launched. In step , the target snapshot tree is made active, or, in other words, available for READs, WRITEs, and other accesses. In step , the snapshot-tree copy routine waits for the background-copy process to finish before unfreezing the source snapshot tree in step  and, optionally, applying any accumulated READs, WRITEs, and other operations which have been directed to the source snapshot tree during the snapshot-tree-copy operation. Alternatively, the snapshot-tree-copy routine can provide a callback reference to the background-copy process, so that when the background-copy process finishes, the background-copy process can call the callback routine to unfreeze the source snapshot tree and, optionally, apply accumulated READs, WRITEs, and other such operations.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 12","FIG. 11","FIG. 9","FIGS. 10B-10G"],"b":["1110","1202","1208","908","910","912","914","916","1203","1207","1204","1205","1206","1207","1204","1208","1203"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 13","FIG. 12","FIGS. 10J-K"],"b":["1205","1302","1304","1306","1304","1308","1310","1312","1310","1312","1304","1314","1316","1318","1320","1318","1322"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 14","FIG. 11"],"b":["1110","1402","1404","1406","1408","1410","1406","1412","1414","1416","1418","1420","1406","1408","1410","1418","1420"]},"When the target Rseg for the WRITE operation has already been considered by the background-copy process, as determined in step , then the WRITE can be immediately directed to the target Rseg, in step . Then, if the ss bit associated with the target Rseg is set, as determined in step , the corresponding Rseg in a successor logical device within the target snapshot tree needs to be located so that the sp bit of the corresponding Rseg in the successor logical device can be cleared in step . The target Rseg's ss bit is also cleared, in step . Steps  and  break the dependency between the target Rseg and the corresponding Rseg of the successor logical device. If the sp bit associated with the target Rseg is set to \u201c1,\u201d as determined in step , then the sp bit associated with the target Rseg is cleared in step . Step  partially breaks the dependency between the target and the corresponding Rseg of the predecessor logical device. Partial removal of the dependency alerts the background-copy process that the background-copy process needs to find data for the corresponding Rseg of the predecessor logical device in the source snapshot tree in steps  and  in .","Finally,  provides a simple control-flow diagram for executing a READ operation directed to the target snapshot tree during execution of the background-copy process. In step , the target Rseg for the READ is located in the target snapshot tree. If the ir bit associated with the target Rseg is set, as determined in step , then the READ is satisfied by accessing the corresponding Rseg in the target snapshot tree, in step . Otherwise, the READ is executed with respect to the target Rseg in the source snapshot tree, in step .","While the instant snapshot-tree copy operation has been discussed, above, reference to a particular data-storage interface and a particular set of data structures that describe logical devices within the data-storage interface, the instant snapshot-tree copy operation of the present invention can be implemented in any of a large number of different types of mass-storage systems using many different data-storage interfaces and different data structures describing data objects stored via the data-storage interface, with a variety of different software and firmware implementations. In the described embodiment, the target snapshot tree is essentially immediately available for READ and WRITE operations, even while the background-copy process is executing, but the source snapshot tree is not available during the execution of the background-copy process. In alternative, more complex embodiments, both the source snapshot tree and the target snapshot tree can be made essentially instantly available for continuing READ and WRITE operations. As with any software implementation, careful use of critical sections needs to be made in routines that access data structures, such as in the background-copy process and in routines that carry out READ and WRITE operations directed to either the source or target snapshot tree during the snapshot-tree-copy operation. For example, critical sections in the code are necessary to avoid the background-copy process considering a target-copy-tree Rseg just after a WRITE operation directed to the target Rseg has begun to be carried out.","The instant snapshot-tree copy operation provides a number of advantages and desirable features to system administrators, to automated logical-device management routines, and to designers and developers of data-storage interfaces and mass-storage systems. First, snapshot trees can be copied in one operation, resulting in a logically equivalent snapshot tree that can be placed in a different LDAD from the LDAD containing the source snapshot tree. The copy snapshot tree is immediately available for READ, WRITE, and other access operations. Moreover, a snapshot-tree copy can be implemented to use a different redundant-data-storage scheme for Rstores of the copy snapshot tree than used for the source snapshot copy tree. As discussed above, the instant snapshot-tree copy operation of the present invention is not dependent on the detailed information contained in the RSD data structures that specify the redundant-data-storage scheme. The data-structure framework initially created for the copy snapshot tree can therefore be initialized to specify any of the possible redundant-data-storage schemes.","Although the present invention has been described in terms of particular embodiments, it is not intended that the invention be limited to these embodiments. Modifications within the spirit of the invention will be apparent to those skilled in the art. For example, many different implementations of the instant snapshot-tree copy operation that represents an embodiment of the present invention are possible, with variations in a variety of different implementation parameters, such as modular organization, data structures, control structures, programming languages, implementation platforms, and other such parameters. While relatively small snapshot trees are discussed in the examples above, the instant snapshot-tree-copy operation of the present invention may be carried out on snapshot trees of arbitrary size. In the embodiment of the present invention discussed above, particular fields in address fields associated with Rsegs in the RSD data structure are employed for bookkeeping during the instant snapshot-tree operation. In alternative embodiments, separate data structures could be used for this purpose, or, in yet additional embodiments, alternative bit fields and reference fields in the Rseg, and Rseg-like data structures, or in other data structures may be employed. As discussed above, the instant-snapshot-tree copy operation that represents an embodiment of the present invention may be implemented in a wide variety of different types of mass-storage systems using different architectures, data-storage interfaces, and data-structure representations of data objects stored within the mass-storage systems.","The foregoing description, for purposes of explanation, used specific nomenclature to provide a thorough understanding of the invention. However, it will be apparent to one skilled in the art that the specific details are not required in order to practice the invention. The foregoing descriptions of specific embodiments of the present invention are presented for purpose of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments are shown and described in order to best explain the principles of the invention and its practical applications, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents:"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 7A-E"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIGS. 8A-G","FIGS. 3-4","FIGS. 5-6"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 10A-K"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 12","FIG. 11"],"b":"1110"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 13","FIG. 12"],"b":"1205"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 14","FIG. 11"],"b":"1110"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
