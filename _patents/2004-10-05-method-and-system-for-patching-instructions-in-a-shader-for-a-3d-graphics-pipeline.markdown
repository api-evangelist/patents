---
title: Method and system for patching instructions in a shader for a 3-D graphics pipeline
abstract: A method and system for patching instructions in a 3-D graphics pipeline. Specifically, in one embodiment, instructions to be executed within a scheduling process for a shader pipeline of the 3-D graphics pipeline are patchable. A scheduler includes a decode table, an expansion table, and a resource table that are each patchable. The decode table translates high level instructions to an appropriate microcode sequence. The patchable expansion table expands a high level instruction to a program of microcode if the high level instruction is complex. The resource table assigns the units for executing the microcode. Addresses within each of the tables can be patched to modify existing instructions and create new instructions. That is, contents in each address in the tables that are tagged can be replaced with a patch value of a corresponding register.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07852341&OS=07852341&RS=07852341
owner: Nvidia Corporation
number: 07852341
owner_city: Santa Clara
owner_country: US
publication_date: 20041005
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["Embodiments of the present invention relate to graphics processors. More specifically, embodiments of the present invention relate to patching instructions in a graphics pipeline unit.","Graphics processing is an important feature of modern high performance computing systems. In graphic processing, mathematical procedures are implemented to render, or draw, graphic primitives, e.g., a triangle or a rectangle, on a display to produce desired visual images. Real time graphics processing requires high speed processing of graphic primitives to produce visually pleasing moving images.","The rendering of three-dimensional graphical images is of interest in a variety of electronic games and other applications. Rendering is the general term that describes the overall multi-step process of transitioning from a database representation of a three-dimensional object to a two-dimensional projection of the object onto a viewing surface, e.g., computer display.","The rendering process involves a number of steps, such as, for example, setting up a polygon model that contains the information which is subsequently required by shading\/texturing processes, applying linear transformations to the polygon mesh model, culling back facing polygons, clipping the polygons against a view volume, scan converting\/rasterizing the polygons to a pixel coordinate set, and shading\/lighting the individual pixels using interpolated or incremental shading techniques.","Graphics Processing Units (GPUs) are specialized integrated circuit devices that are commonly used in graphics systems to accelerate the performance of a 3-D rendering application. GPUs are commonly used in conjunction with a central processing unit (CPU) to generate three-dimensional images for one or more applications executing on a computer system. Modern GPUs typically utilize a graphics pipeline for processing data.","Prior Art  illustrates a simplified block diagram of a graphics system  that includes a graphics processing unit . As shown, that graphics processing unit  has a host interface\/front end . The host interface\/front end  receives raw graphics data from central processing hardware  that is executing an application program stored in memory . The host interface\/front end  buffers input information and supplies that information to a geometry engine . The geometry engine  produces, scales, rotates, and projects three dimensional vertices of graphics primitives in \u201cmodel\u201d coordinates into 2 dimensional frame buffer coordinates. Typically, triangles are used as graphics primitives for three dimension objects, but rectangles are often used for 2-dimensional objects (such as text displays).","The 2 dimensional co-ordinates of the vertices of the graphics primitives are supplied to a rasterizer . The rasterizer  determines the positions of all of the pixels within the graphics primitives. This is typically performed along raster (horizontal) lines that extend between the lines that define the graphics primitives. The rasterizer  also generates interpolated colors, depths and other texture coordinates for each pixel. The output of the rasterizer  is referred to as rasterized pixel data.","The rasterized pixel data are applied to a shader  that adds texture, color, and optical features related to fog and illumination to the rasterized pixel data to produce shaded pixel data. The shader  includes a texture engine  that modifies the rasterized pixel data to have desired texture and optical features. The texture engine  can be implemented using a hardware pipeline that can process large amounts of data at very high speed. The shaded pixel data is input to a Raster Operations Processor  (Raster op in ) that performs color blending on the shaded pixel data. The result from the Raster Operations Processor  is frame pixel data that is stored in a frame buffer memory  by a frame buffer interface . The frame pixel data can be used for various processes such as being displayed on a display . Frame pixel data can be made available as required by way of the frame buffer interface .","The stages of the traditional GPU pipeline architecture illustrated in  may be typically optimized for high-speed rendering operations (e.g., texturing, lighting, shading, etc.) using a widely implemented graphics programming API (application programming interface), such as, for example, the OpenGL\u2122 graphics language, Direct3D\u2122, and the like. The architecture of the graphics processing unit  is configured as a multi-stage deep pipeline architecture in order to maximize the overall rendering throughput of the pipeline. Generally, deep pipeline architectures have sufficient data throughput (e.g., pixel fill rate, etc.) to implement fast, high quality rendering of even complex scenes.","A particular issue in the GPU processing unit of  is that the scheduling of high level instructions (operational codes) in the shader  is inflexibly hard coded into the chip platform that contains the GPU processing unit . The scheduling process translates a stream of high level instructions (e.g., operational codes) into a very long instruction word (VLIW) that is executed in the shader . However, errors within the scheduling process are difficult to repair. Moreover, modifications to the scheduling process generally cannot be made. As a result, performance within the shader  suffers because of the limitations introduced by errors in the scheduling process. Therefore, what is desired is a scheduling process that is suitable for repair and modification.","Accordingly, the present invention provides, in various embodiments, a method and system for patching instructions in a shader pipeline of a 3-D graphics pipeline. The present invention provides for the repair, modification, and introduction of new high level instructions within the scheduling process that transforms a stream of high level instructions (e.g., operational codes) into a stream of very long instruction words (VLIWs) that are then executed within the shader pipeline of a 3-D graphics pipeline.","Embodiments of the present invention pertain to methods and systems for patching instructions in a 3-D graphics pipeline. Specifically, in one embodiment, high level instructions to be executed within a scheduling process for a shader pipeline of the 3-D graphics pipeline are made patchable herein. A scheduler for implementing the scheduling process is described in three stages. A first stage includes a decode table for translating a high level instruction to an appropriate microcode for execution of the high level instruction when the high level instruction is simple. The first stage also provides entry into a patchable expansion table when the high level instruction is complex. A second stage includes the patchable expansion table for translating the high level instruction into a program of microcode when the high level instruction is complex. A third stage includes a patchable resource lookup table for determining a first available unit in the shader pipeline that can execute a particular microcode associated with executing the high level instruction. The resource lookup table provides a list of units in a shader pipeline that can execute the particular microcode.","In another embodiment, a method for patching instructions in a graphics pipeline is disclosed. Specifically, addresses within each of the decode, expansion and resource tables can be patched to modify existing instructions and create new instructions. That is, contents in each address in the tables that are tagged can be replaced with a patch value of a corresponding register. In particular, an address is accessed in one of the patchable lookup tables (e.g., decode, expansion, and resource tables). The contents of the address provide execution information that is associated with the high level instruction. In addition, the address is compared to a list of tagged addresses to determine if the address is tagged for patching. If the address is tagged for patching, an associated register is accessed to read a patch value. The patch value is selected as a replacement for the content of the address in the lookup table, implemented in read only memory (ROM), and is used for further processing of the high level instruction. The ROM lookup table, though hardwired, is a highly efficient implementation of a lookup table, as opposed to random access memory (RAM) which is significantly larger in area and has longer latency.","In still another embodiment, a scheduler for a shader pipeline in a 3-D graphics pipeline is disclosed that is capable of patching instructions. The scheduler includes a ROM lookup table that includes a plurality of addresses containing execution information for a plurality of high level instructions. A plurality of address tags is also included each identifying an address in the lookup table whose contents are tagged for patching. The scheduler also includes a patch block that contains a plurality of patch values for replacing contents of addresses that are tagged in the lookup table. A comparator in the scheduler determines when contents of an address in said lookup table associated with a high level instruction are tagged for patching, and determines a corresponding patch value for replacing the contents of the address. A multiplexor selects the accessed contents when the address is not tagged for patching, and selects the corresponding patch value when the address is tagged for patching for further processing of the high level instruction.","In its various embodiments, the present invention can significantly expand the functionality of the scheduling process of a shader by providing high level instructions that can be modified or newly created through a multistage scheduling process that is implemented with patchable ROM, memory, e.g., lookup tables.","Reference will now be made in detail to the preferred embodiments of the present invention, examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with the preferred embodiments, it will be understood that they are not intended to limit the invention to these embodiments. On the contrary, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the spirit and scope of the invention as defined by the appended claims. Furthermore, in the following detailed description of embodiments of the present invention, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be recognized by one of ordinary skill in the art that the present invention may be practiced without these specific details. In other instances, well-known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the embodiments of the present invention.","In general, embodiments of the present invention are capable of patching instructions in a scheduler of a shader pipeline in a 3-D graphics pipeline. Specifically, the present invention provides for the repair, modification, and introduction of new high level instructions within the scheduling process that transforms a stream of high level instructions (e.g., operational codes) into a stream of very long instruction words (VLIWs) that are then executed within the shader pipeline of a 3-D graphics pipeline. These provisions result in significant expansion of the functionality of the scheduling process of a shader by providing high level instructions that can be modified or newly created through a multistage scheduling process that is implemented with patchable lookup tables (e.g., read only memory [ROM] lookup tables). Embodiments of the present invention and their benefits are further described below.","Although embodiments of the present invention are disclosed within a graphics pipeline, other embodiments are well suited for implementation within similar pipelines of varying nomenclature that render pixelated data, such as video pipelines, and the like, etc.","Notation and Nomenclature:","Some portions of the detailed descriptions, which follow, are presented in terms of procedures, steps, logic blocks, processing, and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. A procedure, computer executed step, logic block, process, etc., is here, and generally, conceived to be a self-consistent sequence of steps or instructions leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated in a computer system. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the present invention, discussions utilizing terms such as \u201caccessing\u201d or \u201cdetermining\u201d or \u201cselecting\u201d or \u201ccomparing\u201d or \u201cpatching\u201d or the like, refer to the action and processes of a computer system (e.g., computer system  of ), or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","Computer System Platform:","With reference now to , an exemplary computer system  in accordance with one embodiment of the present invention is shown. Computer system  in accordance with one embodiment of the present invention may provide the execution platform for implementing certain software-based functionality of the present invention. As depicted in , the computer system  includes a CPU  coupled to a graphics processor  via a host interface . The host interface  translates data and commands passing between the CPU  and the graphics processor  into their respective formats. Both the CPU  and the graphics processor  are coupled to a memory  via a memory controller . In the system  embodiment, the memory  is a shared memory, which refers to the property whereby the memory  stores instructions and data for both the CPU  and the graphics processor . Access to the shared memory  is through the memory controller . The shared memory  also stores data comprising a video frame buffer which drives a coupled display .","As described above, certain processes and steps of the present invention are realized, in one embodiment, as a series of instructions (e.g., software program) that reside within computer readable memory (e.g., memory ) of a computer system (e.g., system ) and are executed by the CPU  and graphics processor  of system . When executed, the instructions cause the computer system  to implement the functionality of the present invention as described below.","Additionally, it should be appreciated that although the components - are depicted in  as discrete components, several of the components - can be implemented as a single monolithic integrated circuit device (e.g., a single integrated circuit die) configured to take advantage of the high levels of integration provided by modern semiconductor fabrication processes. For example, in one embodiment, the CPU , host interface , graphics processor , and memory controller  are fabricated as a single integrated circuit die.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3","b":["330","330"]},"In particular, the scheduler  schedules and translates a stream of high level instructions  into a stream of low level very long instruction words (VLIWs)  that are microcode understandable by the execution units of the shader pipeline . In one embodiment, the VLIW is suitable for parallel execution in the shader pipeline .","The scheduler provides the VLIW  to the shader pipeline . The VLIW  provides execution instructions to each of the execution units (e.g., execution units  and  in the shader pipeline . Pixel data  is sent to the shader pipeline  for processing after the execution units in the shader pipeline  have been instructed by the VLIW .","The output from the shader pipeline  may be recirculated back through the shader pipeline  in an iterative process until processing of the pixel data  is completed. The registers  provide necessary input data for the execution units in the shader pipeline  as requested by the VLIW. In addition, a path from the output of the shader pipeline  back to the scheduler  allows the scheduler to monitor the shader pipeline  as well as the registers for scheduling purposes. The register data can contain per pixel state information that can alter the program flow, such as in a program branch.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 4A","FIG. 3","FIG. 4A","FIG. 4A"],"b":["400","310","410","460"]},"In particular, the scheduling process implemented within the data flow diagram of  can be described in three stages, according to one embodiment. A high level instruction sequence  that is processed through the three stages is translated into microcode .","A first stage  includes a logic block  and a patchable decode table  that decodes the high level instruction sequence. Each addressable entry in the decode table describes the high level instruction as described by attributes within the fields of the entry. For instance, the attributes may define the number and type of inputs required by the high level instruction , whether the instruction is of a first type (e.g., simple instruction), whether the instruction is of a second type (e.g., complex instruction), etc. As a further example, the decode table  in addition to the logic block  are used to convert an operational code to an internal microcode format for further processing. In one embodiment, the patchable decode table is a ROM lookup table.","Table 1 illustrates exemplary entries for the decode table . The fields in the entry define attributes associated with an associated high level instruction, such as, high level instruction .",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Entries for Decode Lookup Table"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ 00: suffix, d a b c execM C1 uExp, uPers, tex, prj, hem"},{"entry":"{ \/*MUL*\/hxcsSuf,4,4,4,0,W1111,3, eNon, \u2003\u20030, \u2003\u20020, \u2003\u20020, \u2003\u20020} ,"},{"entry":". . ."},{"entry":"{ \/*TXBM*\/csSuf ,4,2,2,4,E1111,1, eTXM, \u2003\u20031, \u2003\u20031, \u20030, \u2003\u20021} ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In general, the first stage includes a patchable decode table  and logic block . The logic block receives as an input the high level instruction  and the output of the decode table . The decode table  keys off specific information contained in the high level instruction, such as the operational code. The logic block  provides further decoding of the additional information (e.g., operands, modifiers, etc.) contained in the high level instruction  and provides further functionality to generate internal microcode that provides further instructions and indicates if the high level instruction is a simple or complex instruction. For instance, the logic block  is able to implement information from prior clocks, as history information, that is used in processing the high level instruction .","If the high level instruction is simple, the first stage  translates the high level instruction  to an appropriate microcode for execution of the high level instruction . That is, the first stage  provides the appropriate microcode sequence (e.g., from the decode table ) that can be executed by execution units. In a sense, there is a one-to-one correspondence between the high level instruction , it's operands, modifiers, and the resultant microcode  created by the overall decoding process. For instance, an \u201cMUL\u201d function is a simple high level instruction. The decode table  able to provide the translation for \u201cMUL\u201d high level instruction. An exemplary \u201cMUL\u201d instruction is illustrated in Table 1.","On the other hand, if the high level instruction  is of a second type (e.g., complex instruction), the first stage also provides entry into a second stage  that includes a patchable expansion table . A complex high level instruction requires more than one executable microcode. The expansion table  provides a program or sequence of microcode that is associated with a complex high level instruction. For instance, the high level instruction \u201cTXBM\u201d in Table 1 is a complex instruction.","The second stage  includes the patchable expansion table  and a corresponding logic block  for translating the high level instruction into a program of microcode when the high level instruction is complex. The expansion table  is coupled to receive data from the decode table through the logic block .","Specifically, in one embodiment, the second stage includes both the optional index table  and the expansion table . In other embodiments of the present invention, the expansion table  is capable of performing the functions of the index table . In one embodiment, the expansion table  is a ROM lookup table.","The index table  is also patchable and is coupled to receive data from the decode table  through the logic block . The index table  is used to determine an appropriate address in the patchable expansion table  that is associated with the high level instruction . The appropriate address is dependent on the type of attributes that are associated with the high level instruction . For instance, in one embodiment, the appropriate address is determined by the type of inputs required by the high level instruction. As such, if the high level instruction requires 3 inputs, there are eight possible programs of microcode possible that are associated with the high level instruction. If the high level instruction requires 2 inputs, there are four possible programs of microcode possible that are associated with the high level instruction. In one embodiment, the index table  is a ROM lookup table.","The logic block  receives as an input the internal microcode from the logic block  of the first stage  and the output of the expansion table . The logic block  combines information (e.g., operands, modifiers, etc.) contained in the high level instruction  as processed through the first stage  and provides further functionality to generate the program of microcode. For instance, the logic block  is able to implement information from prior clocks, as history information, that is used in processing the high level instruction . The data outputted from the logic block  is in the form of associated microcode that execute the high level instruction .","Table 2 illustrates exemplary entries for expansion table . For instance, the entries in Table 2 are associated with the complex high level instruction \u201cTXBM\u201d of Table 1. Because \u201cTXBM\u201d is described as having three inputs, there are up to eight possible programs (, , , , , , and ) of sequences of microcode, as illustrated in Table 2.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Entries for \u201cTXBM\u201d Expansion Table"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/118:eTXM",{},{}]},{"entry":[{},"{ \u2003\u20033, uD2A, \u2003T|X,","B, C,","A|SX\u2002} ,"]},{"entry":[{},"{ \u2003\u20032, uD2A, \u2003T|Y,","B, SZWZW,","A|SY\u2002} ,"]},{"entry":[{},"{ \u2003\u20031, uTEX, \u2003D,","T, 0,","0 \u2003\u2003} ,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/121:eTXM_a"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u2003\u20035, uDIV, \u2003T|X|Y,","A, _W,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20034, uDP2, \u2003T|W,","B, C|SZWZW,","0 \u2003\u2003} , \/\/ co-issue"]},{"entry":[{},"{ \u2003\u20033, uDP2, \u2003T|Z,","B, C,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20032, UADD, \u2002T|X|Y,","T|SZWZW,T,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20031, uTEX, \u2003D,","T, 0,","0 \u2003\u2003} ,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/126:eTXM_b==eTSM_c"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u2003\u20035, uDP2, \u2003T|W,","B, C|SZWZW,","0 \u2003\u2003} , \/\/ co-issue"]},{"entry":[{},"{ \u2003\u20034, uDP2, \u2003T|Z,","B, C,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20033, uDIV, \u2003T|Z|W,","T, _W,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20032, UADD, \u2002T|X|Y,","T|SZWZW,A,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20031, uTEX, \u2003D,","T, 0,","0 \u2003\u2003} ,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/131:eTXM_ab==eTXM_ac"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u2003\u20034, uD2A, \u2003T|X,","B, C,","A|SX\u2002} ,"]},{"entry":[{},"{ \u2003\u20033, uD2A, \u2003T|Y,","B, SZWZW,","A|SY\u2002} ,"]},{"entry":[{},"{ \u2003\u20032, uDIV,\u2002\u2003T|X|Y,","T, _W,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20031, uTEX, \u2003D,","T, 0,","0 \u2003\u2003} ,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/135:eTXM_bc"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u2003\u20036, uDIV, \u2003T,","C, _W,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20035, uDP2, \u2003T|W,","B, T|SZWZW,","0 \u2003\u2003} , \/\/ co-issue"]},{"entry":[{},"{ \u2003\u20034, uDP2, \u2003T|Z,","B, C,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20033, uDIV, \u2003T|X|Y,","T|SZWZW, W,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20032, uADD, \u2002T|X|Y,","T, A,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20031, uTEX, \u2003D,","T, 0,","0 \u2003\u2003} ,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/141:eTXM_abc"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u2003\u20036, uDP2, \u2003T|W,","B, C|SZWZW,","0 \u2003\u2003} , \/\/ co-issue"]},{"entry":[{},"{ \u2003\u20035, uDP2, \u2003T|Z,","B, C,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20034, uDIV, \u2003T|X|Y,","T|SZWZW, W,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20033, uADD, \u2002T|X|Y,","T, A,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20032, uDIV, \u2003T|X|Y,","T, _W,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20031, uTEX, \u2003D,","T, 0,","0 \u2003\u2003} ,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/141:eTXM_3regs"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u2003\u20034, uDP2, \u2003T|W,","B, C|SZWZW,","0 \u2003\u2003} , \/\/ co-issue"]},{"entry":[{},"{ \u2003\u20033, uDP2, \u2003T|Z,","B, C,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20032, UADD, \u2002T|X|Y,","T|SZWZW,A,","0 \u2003\u2003} ,"]},{"entry":[{},"{ \u2003\u20031, uTEX, \u2003D,","T, 0,","0 \u2003\u2003} ,"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"A third stage  includes a patchable resource lookup table  and a logic block . The resource table  is coupled to receive the previously described data from the decode table  through logic block  and the expansion table  through logic block . The resource table  in combination with the logic block  are used to determine a first available unit in the shader pipeline that can execute a microcode, for a simple instruction, or microcode, for a complex instruction, associated with executing the high level instruction . The resource lookup table  provides a list of units in a shader pipeline that can execute the associated microcode element or elements. In one embodiment, the patchable resource lookup table  is a ROM lookup table.","The logic block  combines information (e.g., operands, modifiers, etc.) contained in the high level instruction  as processed through the first and second stages  and , respectively, and provides further functionality to generate the microcode sequence  that is executed at the various selected execution units. For instance, the logic block  is able to implement information from prior clocks, as history information, that is used in processing the high level instruction . As such, microcode resulting from the high level instruction can be placed into a history file in the logic block  to be processed in the next clock cycle or to be used as input information in later clock cycles.","Table 3 illustrates an exemplary entry for the resource table , in accordance with one embodiment of the present invention. Table 3 lists the available execution units in a shader pipeline that can execute the \u201cMUL\u201d microcode. Five execution units are available in the shader pipeline. The execution units in the shader pipeline that can execute the \u201cMUL\u201d microcode are as follows: SCT0, SCT1, SRB, SCB0, and SCB1.",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Entry for Resource Lookup Table"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/00","SCT01","TEXSRB","SCB01"]},{"entry":[{},"\/*MUL* \/","{ Either,","None,","Eiether, Compwise}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"In one embodiment, each of the decode table , index table , expansion table , and the resource table  comprise read only memory (ROM) lookup tables. Other embodiments are well suited to supporting other types of lookup tables for the decode table, index table, expansion table, and the resource table. Each of the entries are preloaded to provide the scheduling and translating of high level instruction into microcode in a scheduler of a shader pipeline, in one embodiment. However, the entries in each of these tables are patchable, or replaced, with content in associated registers, as will be described in full below in relation to the remaining figures.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 4B","b":["400","400"]},"The flow chart B can be described in three major stages. The first stage comprises , , and . The second stage comprises  and . The third stage comprises .","In the first stage, at , the present embodiment accesses a patchable decode table in order to decode a high level instruction (e.g., operational code). As described previously, in the decoding process, the present embodiment determines attributes of the high level instruction that is input into a scheduler. Specifically, at , the scheduler begins the process to determine an appropriate microcode sequence for execution of the high level instruction.","Each of the entries in the decode table are patchable. That is, the present embodiment can replace the contents of an entry in the decode table with contents, or a patch value, from a register.","At , the present embodiment determines if the high level instruction is a simple instruction or a complex instruction. The decode table provides this information. If the high level instruction is simple, the present embodiment proceeds to . If the high level instruction is complex, the present embodiment proceeds to .","At , the present embodiment determines the corresponding microcode from the decode table. Specifically, since the high level instruction is simple, there is a one-to-one relationship between the high level instruction and a single microcode that is executable by one of the execution units in the shader pipeline. The decode table provides key information to perform this one-to-one translation.","In the second stage, at , the present embodiment accesses an index table if the high level instruction is complex. The index table provides information to determine an appropriate entry in an expansion table to use for executing the high level instruction. As described previously, a number of programs of microcode sequences may be associated with a high level instruction depending on the number and type of inputs required by the high level instruction. The expansion table includes those programs that can execute the high level instruction.","At , the present embodiment accesses the patchable expansion lookup table to translate the high level instruction to a program of microcode. That is, the complex high level instruction has been translated to a sequence of microcode that is executable by units in the shader pipeline to execute the high level instruction.","At , the present embodiment takes the microcode output from  for a simple high level instruction or the program of microcode output from  for a complex high level instruction and accesses the resource table in order to assign the appropriate execution unit in the shader pipeline that is used to execute the high level instruction. As described previously, the resource table includes entries that list the execution units in the shader pipeline and their corresponding ability to execute each of the microcode available in the hardware of the shader pipeline.","In one embodiment, for a particular microcode associated with executing the high level instruction, the first available unit that can execute the particular microcode is assigned. That is, more than one execution unit can possibly execute the particular microcode. For example, from table 3, the \u201cMUL\u201d microcode can be executed in either execution unit SCT0 or SCT1. As such, if SCT0 has already been assigned, then the present embodiment will assign execution unit SCT1, if available, to execute the \u201cMUL\u201d microcode.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 5","FIG. 4B"],"b":["500","500","470","485","490","495","400"]},"At , the present embodiment accesses an address in a patchable ROM lookup table for execution information that is associated with a high level instruction. The address is accessed to read contents of the address. For instance, at , the present embodiment accesses an address that is associated with a high level instruction in a decode table , or an index table , or an expansion table , or a resource table  of .","At , the present embodiment determines if the address that is accessed is tagged for patching. If the address is not tagged for patching, then the content of the address in the ROM lookup table are used to schedule the high level instruction in the shader pipeline.","On the other hand, if the address is tagged for patching, then the present embodiment at  accesses an associated register that contains a patch value that replaces the contents of the address in the ROM lookup table.","At , the present embodiment selects the patch value as a replacement for the contents of the address for further processing of the high level instruction. That is, the present embodiment reads the patch value from the associated register and uses the patch value to schedule the high level instruction in the shader pipeline.","In particular, embodiments of the present invention are capable of replacing, modifying, or creating new high level instructions by patching the entries in the ROM lookup tables. For instance, in the decode table, if an entry associated with a high level instruction incorrectly identifies the instruction as being simple, when it should be defined as complex, that entry can be patched with a corresponding register whose contents identify the high level instruction as being complex.","Moreover, the expansion table provides the capabilities to repair errors in an existing program of microcode, as well as modify an existing program of microcode by patching an entry with a corresponding register whose contents includes the repaired program of microcode, or the modified program of microcode.","In addition, the expansion able provides the capability to support new high level instructions. For instance, new application program interfaces utilizing the shader pipeline may implement new high level instructions that previously were not supported by the scheduler associated with the shader pipeline.","However, the present embodiment is capable of supporting the new high level instruction. In one embodiment, if entry space is available in each of the decode, index, and expansion tables, then patching those unused entries with execution information to support the new high level instruction can be implemented. For instance, an unused entry in the expansion table can be patched with a new program of microcode to support the new high level instruction.","On the other hand, if there are no available entries in each of the tables, one of the existing high level instructions can be modified through patching its associated entries in the decode, index, and expansion tables. In that case, the previously existing high level instruction would no longer be supported.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 6","b":"600"},"The scheduler  includes a ROM lookup table . Entries in the ROM lookup table include execution information for a plurality of high level instructions. For instance, the ROM lookup table may include attributes in a decode table, or a program of instructions in an expansion table. As shown in diagram , a read address command is received by the ROM lookup table . The ROM lookup table  outputs the contents of the identified address, and sends it to a multiplexor .","In one embodiment, the ROM lookup table  is a decode lookup table. As described previously, the decode lookup table includes a plurality of entries providing attributes for a plurality of high level instructions in an instruction set of the shader pipeline. In part, the decode lookup table determines whether the high level instruction is a simple or complex instruction.","In another embodiment, the ROM lookup table  is an expansion lookup table. As described previously, the expansion lookup table provides an appropriate program of microcode for execution of high level instructions that are complex.","In still another embodiment, the ROM lookup table includes a resource lookup table. As described previously, entries in the ROM lookup table each provide a list of execution units in the shader pipeline that are capable of executing a respective microcode associated with executing high level instructions.","In addition, the read address command is received by the comparators . The comparators  are communicatively coupled to access the address tags . A respective comparator in the comparators  compares the address that is accessed in the ROM lookup table to the address tags . The address tags  each identify an address in the ROM lookup table  whose contents are tagged for patching. The respective comparator informs the multiplexor  if the accessed address is tagged for patching. That is, the respective comparator informs the multiplexor  when the accessed address is also included in the list of addresses in the address tags .","If there is a match, such that the accessed address is tagged for patching, the respective comparator is able to identify an associated register in the patch block . The patch block  includes a plurality of patch values for replacing contents of addresses that are tagged in the ROM lookup table. As such, the associated register includes the patch value for replacing the contents of the accessed address in the ROM lookup table. That is, the contents of the accessed address in the ROM lookup table can be patched by storing a patch value in the associated register. Additionally, a valid bit is necessary to indicate that the patch value is valid. As a result, an entry address, a patch value, and a valid bit are needed to enable a patch. This applies to all patchable lookup tables.","The multiplexor  is coupled to receive data from the ROM lookup table , the comparators  and the patch block . The multiplexor  selects between the contents of the address accessed in the ROM lookup table  and the patch value in the patch block .","Specifically, the multiplexor selects the accessed contents in the ROM lookup table  when said address is not tagged for patching. As such, the contents of the accessed address are used for further processing of the high level instruction. On the other hand, the multiplexor  selects the corresponding patch value when the address accessed in the ROM lookup table  is tagged for patching. That is, the multiplexor  includes a circuit for selecting the corresponding patch value. In that case, the patch value is used for further processing of the high level instruction.","In still another embodiment, the patch value is selected by the multiplexor when a valid bit is enabled for the patch value. When the valid bit is enabled, the multiplexor selects the patch value to replace the contents of the accessed address in the ROM lookup table . On the other hand, if the valid bit is not enabled, then the multiplexor selects the contents of the accessed address in the ROM lookup table  for further processing of the high level instruction.","Accordingly, the present invention provides, in various embodiments, a method and system for patching instructions in a shader pipeline of a 3-D graphics pipeline. The present invention provides for the repair, modification, and introduction of new high level instructions within the scheduling process that transforms a stream of high level instructions (e.g., operational codes) into a stream of very long instruction words (VLIWs) that are then executed within the shader pipeline of a 3-D graphics pipeline. In its various embodiments, the present invention can significantly expand the functionality of the scheduling process of a shader by supporting high level instructions that can be repaired or modified, and creating new instructions through a multistage scheduling process that is implemented with patchable ROM lookup tables.","The foregoing descriptions of specific embodiments of the present invention have been presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed, and obviously many modifications and variations are possible in light of the above teaching. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and form a part of this specification, illustrate embodiments of the present invention and, together with the description, serve to explain the principles of the invention:","Prior Art  shows a diagram depicting the various stages of a traditional prior art pipeline.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
