---
title: Secure collection synchronization using matched network names
abstract: One embodiment provides a system that facilitates facilitate secure synchronization of manifests using exact network names. During operation, the system generates an interest of advertisement comprising a name of a content object of the system. This name represents a collection of objects of the system and includes a first hash that is based on a key of the system. The first hash corresponds to a respective content object hash of one or more segments of a manifest representing the collection of objects. The system also determines a request for the content object based on the name in an interest of data from a remote node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09390289&OS=09390289&RS=09390289
owner: PALO ALTO RESEARCH CENTER INCORPORATED
number: 09390289
owner_city: Palo Alto
owner_country: US
publication_date: 20140407
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field","This disclosure is generally related to data security. More specifically, this disclosure is related to secure synchronization of collections in a network using exact match names.","2. Related Art","In many computing applications, it is often important for peers on a network to synchronize their respective collections of data. The proliferation of digital content creates a vast number of collections which require reconciliation. Content-Centric Network (CCN) architectures have been designed to facilitate accessing and processing such digital content. A CCN includes entities, or nodes, such as network clients, forwarders (e.g., routers), and content producers, which communicate with each other by sending \u201cinterest\u201d packets for various content items and receiving \u201ccontent object\u201d packets in return. CCN interests and content objects are identified based on a unique name, which is typically a hierarchically structured variable length identifier (HSVLI) comprising contiguous name components ordered from a most general level to a most specific level.","In many computing applications, it is often important for devices in a network to express interests for their respective collections of data. The proliferation of digital content creates a vast number of collections which require reconciliation. CCN architectures have been designed to facilitate accessing such digital content. These networks include entities, or nodes, such as network clients, forwarders (e.g., routers and switches), and content producers, which communicate with each other by sending \u201cinterest\u201d packets for various content items and receiving \u201cresponse\u201d packets comprising content objects in return. Unlike a traditional Internet Protocol (IP) network, where an object is tied to its location and its IP address, the content objects in a CCN are identified based on a specific name, which is location-independent and typically is an HSVLI.","For example, a border router that is connected to multiple areas of a computer network can subscribe to namespaces for those areas (e.g., \u201cArea \u201d and \u201cArea \u201d). Other routers that are not border routers may only subscribe to a single area. This way, a router that subscribes to the namespace \u201cArea \u201d only obtains network-configuration items for Area , and a router that subscribes to the namespace \u201cArea \u201d only obtains network-configuration items for Area . The border router that subscribes to both namespaces can obtain network-configuration items for Area  and Area .","Because a network-configuration item's structured name is unique and persistent, a node in a CCN can generate a hash value for each network-configuration item based on the structured name, without having to process the data for each content item. The node can also generate an additive hash for each routing-data collection, based on the hashes for the individual network-configuration items of a routing-data collection, so that the additive hash represents the contents of the routing-data collection. For example, the node can generate the additive hash by using an addition operation (or some other mathematical function) to process the hashes for the individual network-configuration items of the routing-data collection.","A typical CCN synchronization protocol uses a longest-prefix match method, where an interest in \u201c\/parc\/events\/\u201d matches both \u201c\/parc\/events\/calendar.txt\u201d and \u201c\/parc\/events\/conference.txt.\u201d As CCN architectures evolve, the synchronization protocol also evolves to allow the use of exact name match, rather than the current longest-prefix match. During synchronization, a node hosting a collection advertises the collection using its name. Any other node needing to synchronize the collection sends a request with the exact name and receives a response back comprising the collection. However, an adverse node can send a malicious advertisement. As a result, the node receiving the advertisement needs assurance that the advertisement is a valid one. Though CCN brings many desirable features to a network, some issues remain unsolved for secure synchronization of collections.","One embodiment provides a system that facilitates secure synchronization of manifests using exact network names. During operation, the system generates an interest of advertisement comprising a name of a content object of the system. This name represents a collection of objects of the system and includes a first hash that is based on a key of the system. The first hash corresponds to a respective content object hash of one or more segments of a manifest representing the collection of objects. The system also determines a request for the content object based on the name in an interest of data from a remote node.","In a variation on this embodiment, the content object is a first segment of the manifest and comprises a second hash of a second segment of the manifest.","In a further variation, the system elects the manifest in the system for the interest of advertisement from a plurality of manifests with a same manifest hash. The plurality of manifests is distributed among a plurality of nodes.","In a variation on this embodiment, the content object is a secure catalog in the system. This secure catalog comprises the respective content object hash of the segments of the manifest; and the first hash is a hash of the secure catalog.","In a further variation, the system signs the secure catalog using the key of the system.","In a further variation, the system elects the secure catalog at the system for the interest of advertisement from a plurality of secure catalogs with a same content object hash. The plurality of secure catalogs is distributed among a plurality of nodes.","In a further variation, the secure catalog is distributed among a plurality of segments. A content object of a first segment of the secure catalog includes a hash of a content object of a second segment of the secure catalog.","In a variation on this embodiment, the system generates a message comprising a segment of the manifest in response to an interest of data from a remote node for the segment. The interest of data includes one of the content object hashes in the secure catalog.","In a variation on this embodiment, the key of the computing device identifies the computing device as a trusted publisher.","One embodiment provides a system that facilitates multi-object interest using network names. During operation, the system obtains a name of a content object of a remote node from an interest of advertisement. The name represents a collection of objects at the remote node and includes a first hash that is based on a key of the remote node. The first hash corresponds to a respective content object hash of one or more segments of a manifest representing the collection of objects. The system further generates for the remote node an interest of data comprising a request for the content object based on the name.","In the figures, like reference numerals refer to the same figure elements.","The following description is presented to enable any person skilled in the art to make and use the embodiments, and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art, and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present disclosure. Thus, the present invention is not limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.","Overview","In embodiments of the present invention, the problem of securely synchronizing a collection of objects using exact matched name is solved by incorporating a cryptographic hash with the interest for the collection of objects within the Content-Centric Network (CCN) namespace. In this disclosure, the terms \u201ccontent object\u201d and \u201cobject\u201d are used interchangeably. With existing technologies, in a CCN, a host node can notify regarding a content object (i.e., a new content item), or an object, at any time by broadcasting an interest packet comprising the persistent name of the object. This interest packet can be referred to as an interest. Dissemination of interests allows other nodes to be aware of the object. In response to receiving an interest of advertisement, an interested node sends an interest of data to obtain the desired object. In response, the host node can send a response packet comprising the object. This response packet can be referred to as a response. In this disclosure, the terms \u201cinterest packet\u201d and \u201cinterest\u201d are used interchangeably. The terms \u201cresponse packet\u201d and \u201cresponse\u201d are also used interchangeably.","An interest of advertisement is an interest used for advertising a content object in a CCN. A node can send an interest of advertisement upon obtaining or updating a content object. On the other hand, an interest of data is an interest used for requesting a content object (i.e., data) in a CCN. A node can send an interest of data to express an interest (or request) for any content object.","In either interest, a name in the CCN namespace (e.g., a hierarchically structured variable length identifier (HSVLI)) is used to identify the content object. In some embodiments, the name includes an identification of the relevant namespace (or a namespace identification). This namespace identification is part of a CCN name which distinguishes between the interests. For example, the name can include \u201c\/adv\u201d for advertisements and \u201c\/data\u201d for data.","For a large collection of objects, sending a respective interest for a respective object leads to inefficient, bandwidth-intensive, and repetitive dissemination of interests. CCN can be extended to incorporate Manifest-Based Content Networking (MBCN). A content consumer node in a CCN can express an interest for a collection of objects using a manifest name representing the collection. In some embodiments, the manifest is an ordered list of objects in the collection. The manifest can include the respective names of the objects and their corresponding hash. By sending an interest of advertisement, which can also be referred to as an advertisement, for a manifest, a host node can make remote nodes aware of the collection. However, the host node can be malicious and send an adverse interest of advertisement.","To solve this problem, embodiments of the present invention incorporate a cryptographic hash with such an interest of advertisement. For example, this hash can be the part of the name of the manifest in the interest. In some embodiments, this secure synchronization with exact match names can be obtained using a hash chain. If the manifest is large and requires segmentation for dissemination, the interest of advertisement can include the hash of the first segment of the manifest. A respective segment, except the last one, can contain the hash of one or more subsequent segments in a designated field, thereby forming a hash chain. As a result, upon obtaining each segment, a node becomes aware of the hash of the next segment. In some embodiments, this secure synchronization with exact match names can be obtained using a secure catalog. The interest of advertisement can contain the hash of the secure catalog (or the first segment of the secure catalog). The secure catalog contains the hash of a respective segment of the manifest. By receiving the catalog, a node can obtain the respective hash of a respective manifest segment and send an interest for that segment using the corresponding hash.","Embodiments of the present invention provide a system which facilitates synchronization of manifests among nodes on a network by using exact match names. In the following description of embodiments of the present invention, the relevant CCN entities are a local node and a remote node, although the roles can be reversed. Each of the local and remote nodes is associated with a manifest, which represents a collection of content objects at a node. A manifest is identified by a specific prefix, such that two manifests with the same prefix correspond to the same collection of content objects.","In some embodiments, the manifest is an ordered list identifying a collection of content objects. Each content object in a collection is identified by its name and corresponding digest, where the digest is the hash value of the content object. In some embodiments, each content object is also identified by a modified time, which indicates the time that the content was modified. For the purposes of this description, the manifest is described as an ordered list, but other embodiments include the manifest structured as a synchronization tree, which contains content objects as well as nested collections of content objects. The system generates a root hash value for the manifest. The root hash value is an additive hash value based on the hash values of the individual content objects of the collection. The root hash value of the manifest is a unique identifier for the manifest.","The system can synchronize the collections in a local manifest with the contents in a local manifest using exact match names. A remote node advertises a hash of its manifest. A local node receives the advertisement and determines that the advertised remote manifest corresponds to a local manifest, where the remote manifest and the local manifest correspond to the same collection of content objects. The local node determines whether the contents of the local manifest are synchronized with the contents of the remote manifest by comparing the root hash value of the local manifest with the root hash value of the remote manifest. If they do not match, then the local node retrieves the remote manifest by sending a request for the remote manifest to the remote node.","In some embodiments, the local node sends a set of interests based on a segmentation protocol, and each interest corresponds to a numbered segment of the manifest. In some embodiments, the remote node can advertise the number of segments corresponding to its manifest. The local node, in possession of the remote manifest, determines which content objects indicated in the remote manifest are different from the content objects indicated in the local manifest. Subsequently, the local node transmits a set of interests for the content objects that are different, where the interest includes the name of the requested content object. In some embodiments, the interest also includes the corresponding hash value of the requested content object. In this manner, the system uses an exact name match to request and receive the set of different content objects.","In some embodiments, the manifest is transmitted using a structured technique, such as the rolling hash technique in the rsync protocol, rather than sending the complete manifest. The rsync protocol allows efficient transmission of the manifest between two nodes because the nodes already have a similar, but not identical, version of the same manifest.","In some embodiments, a content object in a collection is further identified by a corresponding modified time, which indicates the time the content object was modified. For each content object that is determined to be different, the local node determines whether the modified time of the content object in the remote manifest is more or less recent than the corresponding content object in the local manifest. If the remote content object corresponds to a modified time that is more recent, then the local node updates the value of the content object in the local manifest with the value of the content object from the remote manifest. A description of how to remove, or \u201cwhite-out,\u201d a content item from a data collection is contained in U.S. patent application Ser. No. 13\/681,306, titled \u201cData Transport by Named Content Synchronization,\u201d by inventors Van L. Jacobson and Marc E. Mosko, filed 19 Nov. 2012, the disclosure of which is incorporated by reference herein.","In some embodiments, if the remote content object corresponds to a modified time that is less recent, the system can determine whether to retain the history by inserting the value of the content object from the remote manifest in a history field of the corresponding content object in the local manifest. The system updates the values accordingly for each content object that is determined to be different. In this manner, the system synchronizes the manifest at a local node with the manifest at a remote node.","In some embodiments, the network clients, network nodes (e.g., forwarders such as routers), and publishers communicate over an information-centric network (ICN). In ICN, each piece of content is individually named, and each piece of data is bound to a unique name that distinguishes the data from any other piece of data, such as other versions of the same data or data from other sources. This unique name allows a network device to request the data by disseminating a request or an interest that indicates the unique name, and can obtain the data independently of the data's storage location, network location, application, and means of transportation. Named Data Networks (NDNs) or CCNs are examples of ICN architecture; the following terms describe elements of an NDN or CCN architecture:","Content Object: A single piece of named data, which is bound to a unique name. Content Objects are \u201cpersistent,\u201d which means that a Content Object can move around within a computing device, or across different computing devices, but does not change. If any component of the Content Object changes, the entity that made the change creates a new Content Object that includes the updated content, and binds the new Content Object to a new unique name.","Unique Names: A name in an ICN is typically location-independent and uniquely identifies a Content Object. A data-forwarding device can use the name or name prefix to forward a packet toward a network node that generates or stores the Content Object, regardless of a network address or physical location for the Content Object. In some embodiments, the name may be a hierarchically structured variable-length identifier (HSVLI). The HSVLI can be divided into several hierarchical components, which can be structured in various ways. For example, the individual name components parc, home, ndn, and test.txt can be structured in a left-oriented prefix-major fashion to form the name \u201c\/parc\/home\/ndn\/test.txt.\u201d Thus, the name \u201c\/parc\/home\/ndn\u201d can be a \u201cparent\u201d or \u201cprefix\u201d of \u201c\/parc\/home\/ndn\/test.txt.\u201d Additional components can be used to distinguish between different versions of the content item, such as a collaborative document.","In some embodiments, the name can include a non-hierarchical identifier, such as a hash value that is derived from the Content Object's data (e.g., a checksum value) and\/or from elements of the Content Object's name. A description of a hash-based name is described in U.S. patent application Ser. No. 13\/847,814 (entitled \u201cORDERED-ELEMENT NAMING FOR NAME-BASED PACKET FORWARDING,\u201d by inventor Ignacio Solis, filed 20 Mar. 2013), which is hereby incorporated herein by reference. A name can also be a flat label. Hereinafter, \u201cname\u201d is used to refer to any name of a piece of data in a name-data network, such as a hierarchical name or name prefix, a flat name, a fixed-length name, an arbitrary-length name, or a label (e.g., a Multiprotocol Label Switching (MPLS) label).","Interest: A packet that indicates a request for a piece of data, and includes a name (or a name prefix) of the piece of data. A data consumer can disseminate a request or Interest across an information-centric network, which CCN\/NDN routers can propagate toward a storage device (e.g., a cache server) or a data producer that can provide the requested data to satisfy the request or Interest.","In some embodiments, the ICN system can include a CCN architecture. However, the methods disclosed herein are also applicable to other ICN architectures as well. A description of a CCN architecture is described in U.S. patent application Ser. No. 12\/338,175 (entitled \u201cCONTROLLING THE SPREAD OF INTERESTS AND CONTENT IN A CONTENT CENTRIC NETWORK,\u201d by inventors Van L. Jacobson and Diana K. Smetters, filed 18 Dec. 2008), which is hereby incorporated herein by reference.","In this disclosure, the description in conjunction with  is associated with the general architecture of synchronization of a collection of objects using a manifest; and the description in conjunction with  and onward provides more details on the mechanism for facilitating a secure synchronization of the collection objects.","Exemplary Network and Manifest",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","116","116","118","118","102","104","106","108","110","112","114","102","114","112","120","120","122","130","1","130","132","1","132","134","1","134","132","1","132","130","1","130","120","124","132","1","132","124","120"],"i":["n","n","n","n ","n","n "]},"In some embodiments, a manifest indicates a name and a corresponding digest, but does not indicate a modified time. Such a system can include, e.g., a file server where prior versions of a text file are important and thus retained by the system. In other embodiments, a manifest indicates a name, a corresponding digest, and a modified time. The system can use the modified time to determine which version of the content item should be retained. For example, if the content items indicate a link state, then the system does not need information relating to previous versions. In this case, only the content object with the most recent modified time is retained.","Any two nodes in a network can contain a manifest that represents the same collection of data, where the manifests can be synchronized using the methods described herein. The terms \u201clocal node\u201d and \u201cremote node\u201d can apply to any node in a content-centric network (CCN) and are used in this disclosure to differentiate between two nodes in a CCN.","Structure of Names","Synchronization of manifests representing the same collection of data between two nodes is based on a three-part name. The first part is a routable prefix that identifies the collection, such as \u201c\/a\/b.\u201d The second part contains an identification of the relevant namespace (or a namespace identification), and can be \u201c\/adv\u201d for advertisements or \u201c\/data\u201d for data transfers. The third part is the hash value or content being advertised or transferred. Thus, a CCN name is of the form:\n\n",{"@attributes":{"id":"p-0065","num":"0070"},"figref":"FIG. 2","b":["200","102","106","102","106","202","102","220","106","222","106","202","106","106","224","226","0","1","2","228","102","0"]},"Local node , in possession of the remote manifest, performs a determine_set_difference procedure . In some embodiments, the result of this procedure is a list of content objects identified by name. In other embodiments, the result is a list of content objects identified by their corresponding digest. Local node  then transmits a request_set_difference interest  for each content object that is determined to be different. The interest takes the form, e.g.: \u201c\/a\/b\/data\/name 130.3\u201d. Local node  receives the requested content object when remote node  transmits a send_set_difference content object , where the requested content object takes the form: \u201c\/a\/b\/data\/name 130.3+payload.\u201d Thus, local node  performs resolve_set_difference procedure  by requesting and receiving the content objects determined to be different such that the contents of the local manifest are synchronized with the contents of the remote manifest. In some embodiments, local node  performs a sync_based_on_mod_time procedure , which is described below in relation to .",{"@attributes":{"id":"p-0067","num":"0072"},"figref":["FIG. 3","FIG. 2","FIG. 2"],"b":["106","102","302","304","222"]},"In some embodiments, the local node determines if the manifest indicates the same collection by comparing the collection name, or routing prefix, of the manifests. The local node then determines whether the root hash value of its local manifest is different from the root hash value of the remote manifest (operation ). The root hash value of a manifest is a unique identifier for the manifest, and comprises an additive hash value of the digests of the content objects represented in the manifest. If the root hash value of the local manifest is not the same as the root hash value of the remote manifest (operation ), the local and remote manifests, which represent the same collection, are not synchronized and need to be reconciled. The local node downloads or transfers the remote manifest by sending a request for, and receiving in response to the request, the remote manifest (operation , corresponding to retrieve_manifest procedure  in ).","The local node determines which content objects identified in the remote manifest are different from the content objects identified in the local manifest (operation , corresponding to the determine_set_difference procedure  in ). In some embodiments, the local node determines the set difference by comparing the digests of the content objects identified in the local manifest with the digests of the same named content objects identified in the remote manifest. If the local node determines a difference, the local node transmits a set of interests of data corresponding to the determined different set of content objects (operation ), and receives the requested content objects in return (operation ). This corresponds to the resolve_set_difference procedure  shown in . Thus, the contents of the local manifest are synchronized with the contents of the remote manifest.","If the local node has changes, the local node advertises the new root hash value. It can do so immediately, or schedule a next advertisement based on network or other timing considerations. For example, the local node can advertise its root hash at least once per second, but no more than four times a second. Therefore, during reconciliation, as the root hash changes due to updates, the node can advertise up to four changes per second. Otherwise, in a steady state, the node can advertise once per second.","Synchronization Based on Modified Time",{"@attributes":{"id":"p-0071","num":"0076"},"figref":["FIG. 4","FIG. 2"],"b":["240","402","404","406","408","410","404"]},"If the modified time of the content object from the remote manifest is less recent than the corresponding content object in the local manifest (operation ), then the system determines whether to save the value of the (less recent) content object from the remote manifest (operation ) by inserting a corresponding value and modified time of the (less recent) content object into a history field in the local manifest (operation ). If there are more content objects in the set that need to be retrieved (operation ), then the system returns to operation . If not, then the system has finished retrieving the necessary content objects. Thus, all content objects determined to be different have been updated, and possibly retained or saved in a history field of the local manifest, such that the contents of the local manifest are synchronized with the contents of the remote manifest.","Transmitting Advertisement, Manifest, and Contents for Synchronization",{"@attributes":{"id":"p-0073","num":"0078"},"figref":["FIG. 5","FIG. 5","FIG. 5","FIG. 2"],"b":["102","102"]},"A local node transmits an interest of advertisement corresponding to a manifest, where the manifest represents a collection of content objects at a node (operation , corresponding to send_advertisement message  in ). This advertisement is an interest that is akin to a beacon and, based on the \u201c\/add\u201d namespace identification used, does not request any content in return. Upon receiving an interest of data from a remote node requesting the manifest, the local node transmits the manifest to the remote node (operation , corresponding to receiving request_remote_manifest_in_segments interest  and send_remote_manifest_in_segments message  in ). Upon receiving a request from a remote node for a content object identified in the local manifest, the local node transmits the requested content object to the requesting remote node (operation , corresponding to receiving request_set_difference interest  and send_set_difference message  in ).","Manifest Contents During Synchronization",{"@attributes":{"id":"p-0075","num":"0080"},"figref":"FIG. 6A","b":["120","122","130","1","130","132","1","132","134","1","134","132","1","132","130","1","130","120","124","132","1","132","124","120","120"],"i":["n","n","n","n ","n","n "]},"As described in relation to , manifest  can indicate a name and corresponding digest for each content object represented in the collection. In some embodiments, manifest  can also include a modified time for each content object represented in the collection. The use of the modified time field depends on the underlying application or service being performed. Note that manifest  indicates collection name . The manifests depicted in  also include a collection name, but because the exemplary manifests comprise the same collections of data, the collection name is not included in .",{"@attributes":{"id":"p-0077","num":"0082"},"figref":"FIGS. 6B-6E","b":["102","106","102","106","106","160","102","140","140","160","1","2","140","160"]},"Recall that a manifest is further identified by a root hash value, illustrated as root hash  in , which is an additive hash value based on the digests of the individual content objects of the collection. In the following examples, the root hash value and the digests are indicated as a number in brackets, e.g., \u201c{999}\u201d, although the number can be much larger than this. In addition, both the digests of the content objects and the exemplar root hash values of manifests  and  that change over time are depicted only as sample representations of additive hash values.","Local Manifest Missing a Content Object from Remote Manifest",{"@attributes":{"id":"p-0079","num":"0084"},"figref":"FIG. 6B","b":["1","106","102","140","106","160","140","140","106","160","140","106","160","140","160","106","102","102","2","106","160","160","2","160","160","2"]},"Local and Remote Manifests Contain Content Object with Same Name, but Different Digest: Local Node Retrieves Manifest First",{"@attributes":{"id":"p-0080","num":"0085"},"figref":"FIG. 6C","b":["3","106","102","140","106","160","140","140","106","160","140","106","160","140","160","106","102","102","4","106","160","160","4","160","160","4","140","160"],"i":["a","a","a"]},"Subsequently, remote node  receives a hash advertisement from local node  of manifest , with the new root hash of {772}. Remote node  determines that its manifest  represents the same collection of data as manifest  and retrieves manifest . Remote node  determines that manifest , with a root hash of {999}, is not synchronized with manifest , which has a root hash of {772}. Remote node  then determines the set difference between its manifest  and manifest . In this example, manifest  is missing the content object identified by a name of \u201cfruit\/lychee\/peel\u201d with a digest of {41}, so remote node  sends an interest to local node  for the content object based on that name and digest. Local node  returns the requested content object. At time T., remote node  updates it manifest  with the missing content object. Based on the contents of manifest  at time T., the system generates a new root hash for manifest . This is depicted by the root hash value of manifest  at time T.: {999}\u266f{772}. Thus, at time T., manifest  at node  is in sync with manifest  at node . Nodes  and  have synchronized their collections and both contain the same root hash value of {772}.","Local and Remote Manifests Contain Content Object with Same Name, but Different Digest: Remote Node Retrieves Manifest First",{"@attributes":{"id":"p-0082","num":"0087"},"figref":"FIG. 6D","b":["3","102","106","160","102","140","160","160","102","140","160","102","140","160","140","102","106","106","4","102","140","140","4","140","140","4","160","140"],"i":["b","b","b"]},"Subsequently, local node  receives a hash advertisement from remote node  of manifest , with the new root hash of {772}. Local node  determines that its manifest  represents the same collection of data as manifest  and retrieves manifest . Local node  determines that its manifest , with a root hash of {53}, is not synchronized with manifest , which has a root hash of {772}. Local node  then determines the set difference between its local manifest  and remote manifest . In this example, manifest  is missing the content object identified by the name of \u201c\/fruit\/lychee\/peel\u201d with a digest of {41}, so local node  sends an interest to remote node  for the content object based on that name and digest. Remote node  returns the requested content object. At time T., local node  updates its manifest  with the missing content object. Based on the contents of manifest  at time T., the system generates a new root hash for manifest . This is depicted by the root hash value of manifest  at time T.: {53} \u266f {772}. Thus, at time T., manifest  at node  is in sync with manifest  at node . Nodes  and  have synchronized their collections and both contain the same root hash value of {772}.",{"@attributes":{"id":"p-0084","num":"0089"},"figref":"FIGS. 6C and 6D","b":["140","160","3","4","5","3","15","4","5"],"i":["a","a","b","b"]},"Synchronization Using Modified Time",{"@attributes":{"id":"p-0085","num":"0090"},"figref":"FIG. 6E","b":["6","106","102","140","106","160","140","140","106","160","140","106","160","140","140","160","134","140","160"]},"It should be noted that a modified time can include information relating to the second, minute, hour, day, month, and year that a corresponding content object was modified. For simplicity, the exemplary manifests in  contain only a time of day. Manifest  contains a content object identified by a name of \u201c\/chef\/events\/calendar.txt\u201d with a digest of {1} and a modified time of 8:05 am. Manifest  contains a content object identified by the same name with a different digest of {320} and a different modified time of 7:30 am. Local node  then sends an interest to remote node  for the content object based on the name and digest of the different content object. Remote node  returns the requested content object.","Local node  determines that the content object from remote manifest  with a modified time of 8:05 am is more recent than the content object from its local manifest  with a modified time of 7:30 am. So, at time T, local node  updates its manifest  with the different and more recent content object. Based on the contents of manifest  at time T, the system generates a new root hash for manifest . This is depicted by the root hash value of manifest  at time T: {80}\u266f{999}. Thus, at time T, manifest  at local node  is in sync with manifest  at remote node . Nodes  and  have synchronized their collections and both contain the same root hash value of {999}.","In some embodiments, the system will retain the previous version of the changed content object (e.g., the content object identified by name \u201c\/chef\/events\/calendar.txt\u201d with a digest of {320} and a modified time of 7:30 am) in a history field of manifest . In other embodiments, when remote node  receives a hash advertisement from local node  of manifest  with a root hash of {80} and downloads the local manifest , remote node  determines that the version of the received content object identified by name \u201c\/chef\/events\/calendar.txt\u201d with a digest of {320} and a modified time of 7:30 am is less recent than the version in its own manifest. In this case, manifest  at remote node  remains out of sync with manifest  at local node . The manifests will undergo synchronization at a later time when local node  receives a hash advertisement from remote node  of manifest , which contains the more recently updated content object, as described above.","Secure Synchronization of Manifest Using a Hash Chain","In the embodiments of the present invention, in addition to the three-part name comprising a routable prefix, identification of the relevant namespace, and a root hash value of the manifest, an interest of advertisement for a manifest also carries a hash of a content object.  illustrates an exemplary secure synchronization of manifests, in accordance with an embodiment of the present invention. During operation, node  transmits a send_advertisement interest  (i.e., an interest of advertisement), which is a hash advertisement containing the root hash value of its manifest identified by collection name \u201c\/a\/b.\u201d In addition, interest  further comprises a first content hash (denoted as contenthash_). The first content hash is the cryptographic hash of the first segment (i.e., segment ) of the manifest, as described in conjunction with . A cryptographic hash is a hash generated based on the cryptographic identity (e.g., a key) of a node. This allows network  to disambiguate all potential segment 's of the manifest to the one given by the content object hash.","If another node  also includes the manifest, the first content hash of node  (denoted as contenthash_) can be different than contenthash_. Node  also transmits a send_advertisement interest . Upon receiving interests  and , node  can determine from which node the manifest should be obtained. In some embodiments, nodes  and  use a distributed election to pick one hash chain for both nodes  and  to use. This leads to reduction of the multiplicity of hashes used to describe one manifest. In some embodiments, the hash chain with the largest hash value is elected. Suppose that contenthash_ has a higher value than contenthash_. As a result, node  retrieves the first segment of the manifest from node  by sending an interest of data in response to interest  and obtains the first content hash of the corresponding hash chain.","If node  is a valid publisher (i.e., a valid publisher node), node  obtains the entire hash chain of node  and begins advertising the hash value of node . However, the node with the larger content hash value may not be a trusted publisher. For example, adverse node  can also transmit a malicious send_advertisement interest  (denoted with a dotted line) with the largest hash value. If the key of node  is not trusted, node  can discard such an interest of advertisement and continue advertising the hash of node . Node , seeing multiple interests (e.g., interests , , and ) for a manifest, can select the largest content object hash of node  first. However, because the corresponding hash chain is not from a trusted publisher, node  tries another interest of advertisement based on a selection policy. Examples of the selection policy include, but are not limited to, the order of content hash values and a random order to avoid a front-loading attack. Suppose that contenthash_ has the highest hash value. Node  then sends a request_remote_manifest interest  comprising contenthash_.","If adverse node  fabricates the root hash (denoted as roothash_), node  can flood the network with one or more fabricated content object hashes (e.g., contenthash_). Node  retrieves the first segment of the fabricated advertisement to look at a key identifier and determines whether node  is a trusted participant. Because the key identifier of node  is fabricated, node  does not trust interest of advertisement . On the other hand, if adverse node  uses a true root hash but fabricates the content object hash, node  retrieves the first segment corresponding to a respective interest of advertisement (e.g., interests , , and ) to look at the corresponding key identifier and determines whether the node is an acceptable participant. Node  can stop this iteration after the first acceptable advertisement and follow its hash chain. Because a node must follow a hash chain, pipelining the download is limited by the fan-out of the hash chain.",{"@attributes":{"id":"p-0093","num":"0098"},"figref":"FIG. 7B","b":["700","736","1","736","0","730","1","730","732","1","732","700","732","1","700","730","1","0","700","700","0"],"i":["n ","n","n"]},"In this example, the content object representation of manifest  results in n objects. Working backwards from the final object, the content object hash of the next object is inserted into the previous object in a distinguished field. It should be noted that the last content object of the manifest may not have a hash of the next content object and the corresponding field can be empty. The hashes for content objects .-.are .-., respectively (it should be noted that .is not shown on ). In some embodiments, a respective hash is generated using key identifier  associated with a node hosting the manifest. This key identifier  can be included in a respective content object. The hash of content object . (not shown on ) is . and is included in the previous content object .. Similarly, the hash for content object . is . and is included in the previous content object .. In this way, the first content object . includes the hash . of the next content object ..","In some embodiments, a respective content object in manifest  includes a signature of the content object. For example, content objects ., ., ., . . . , .include signatures ., ., ., . . . , ., respectively. A signature corresponds to a signature of the rest of the elements in the corresponding content object. For example, signature . is a signature of {name ., key identifier , manifest segment , hash .}.","Once the first content object . is generated, the first hash . of the hash chain is generated. The first content object hash of . covers the content object and the hash chain pointer. Therefore, the interest of advertisement for secure synchronization is represented by a name comprising the collection name, an identification of the relevant namespace (e.g., \u201cadv\u201d), a root hash of manifest , and content object hash .. If a respective node has a different key identifier, each node produces a unique hash chain, even for the same manifest . As a result, the interest of advertisement based on key identifier  is unique and interest aggregation at the forwarder is avoided. However, if a node already knows the hash of manifest , that node does not need to retrieve each instance of manifest , so long as the node has at least one instance from a trusted source.","Operations of Secure Synchronization of Manifest Using a Hash Chain",{"@attributes":{"id":"p-0097","num":"0102"},"figref":"FIG. 8A","b":["0","802","804","806","808","810","806","0","812"]},{"@attributes":{"id":"p-0098","num":"0103"},"figref":["FIG. 8B","FIG. 7B","FIG. 2","FIG. 7B"],"b":["852","712","0","700","730","1","854","856","734","858","854"]},"If the interest is from a valid publisher, the node checks whether the root hash is different than the local root hash (operation ). If the root hash is different, the node initiates the synchronization process (operation ), as described in conjunction with . Otherwise, the node determines whether the valid identified content object hash value is larger than the local content object hash value (operation ). If the valid identified content object hash value is larger than the local content object hash value (operation ), the node obtains the hash chain with the larger content object hash value (operation ).",{"@attributes":{"id":"p-0100","num":"0105"},"figref":"FIG. 8C","b":["0","882","884","886","888","890"]},"Secure Synchronization of Manifest Using Secure Catalog","In the embodiments of the present invention, in addition to the three-part name comprising a routable prefix, identification of the relevant namespace, and a root hash value of the manifest, an interest of advertisement for a manifest also carries a hash of a content object. This content object can correspond to a secure catalog comprising hash values of the respective content objects of the manifest. Rather than advertising the content object hash of the first segment of the manifest, a node may advertise the name of a secure catalog that enumerates all segments of the manifest. In some embodiments, the secure catalog can also be segmented. This can allow a faster performance by pipelining a download because a device may retrieve a plurality of segments of the catalog after one round trip.","This embodiment has a further benefit. Because it uses a secure catalog for the signature, the individual content objects that comprise the manifest are not publisher specific. Therefore, the hash values of the content objects do not depend on which has node generated the catalog, thereby improving the caching and reusing.",{"@attributes":{"id":"p-0103","num":"0108"},"figref":"FIG. 9A","b":["900","700","732","1","730","1","700","900","738","1","738","700","700","700","900","900","700"],"i":"n "},"In this example, a system breaks manifest  into n content objects .-., with hashes .-., respectively. In some embodiments, content objects .-.do not include publisher-specific data and are unsigned. The system creates a secure catalog  with entries comprising hashes .-.. Catalog  can be signed. The content object of catalog  can have a hash <cataloghash>. The resulting interest of advertisement has a name of the form \u201c\/a\/b\/adv\/<roothash>\/<cataloghash>.\u201d Secure catalogs from multiple publishers for the same manifest may use a distributed election to converge on one secure catalog. Examples of a distributed election include, but are not limited to, the largest and the smallest hash value. One advantage of secure synchronization using secure catalog is that the content objects of the catalog can be identical among all publishers. As a result, the distributed election is only for using the secure catalog name. In some embodiments, the contents of the catalog can be identical among all publishers for the same manifest hash.",{"@attributes":{"id":"p-0105","num":"0110"},"figref":"FIG. 9B","b":["102","912","900","106","914","914","0","914"]},"In some embodiments, upon receiving the interest of data, node  signs the catalog (procedure ) and sends a send_catalog message  comprising the corresponding content object (CO). This message  includes the first segment S of the catalog and takes the form: \u201c\/a\/b\/datakroothash>\/catalog\/S+payload,\u201d wherein the payload contains the requested segment of the catalog. The hash of the content object in message  is <cataloghash> (i.e., hash(CO)=<cataloghash>). Upon receiving the catalog, node  verifies the signature of node  to ensure that node  is the valid publisher of the catalog and retrieves the respective content object hash (procedure ). Node  then sends a set of interests for the segments of the manifest. The set of interests is segmented based on a segmentation protocol. The interests are sent in a request_manifest_in_segments message  (i.e., an interest of data), and are of the form: \u201c\/a\/b\/data\/<roothash>\/<contenthash_>\u201d, \u201c\/a\/b\/data\/<roothash>\/contenthash_,\u201d \u201c\/a\/b\/data\/<roothash>\/contenthash_,\u201d etc. In the example , <contenthash_>, <contenthash_>, and <contenthash_> correspond to hashes ., ., and ., respectively.","Operations of Secure Synchronization of Manifest Using Secure Catalog",{"@attributes":{"id":"p-0107","num":"0112"},"figref":"FIG. 10A","b":["0","1002","0","1004","0","1006","1008","1010","1012","1008"]},"If the current content object is the last content object, the node signs the catalog, and transmits an interest of advertisement with the catalog name comprising a prefix (or collection name), a namespace identification (e.g., \u201cadv\u201d), the root hash of the manifest, and the hash of the catalog comprising the signature of the catalog (i.e., the signature of the catalog is a part of the hash of the catalog) (operation ). The node receives an interest of data with the catalog name comprising the prefix, the namespace identification (e.g., \u201cdata\u201d), the root hash of the manifest, and the hash of the catalog (operation ). The node transmits the signed catalog based on the catalog name (operation ), as described in conjunction with .",{"@attributes":{"id":"p-0109","num":"0114"},"figref":["FIG. 10B","FIG. 2"],"b":["1052","1054","1056"]},"The node then checks whether the catalog is a valid catalog (operation ) based on the signature verification. If the catalog is valid, the node obtains a respective content object hash of a corresponding manifest segment from the catalog (operation ). The node then initiates the secure synchronization process by transmitting a respective interest of data with a corresponding content object name comprising the prefix, the namespace identification, the root hash, and the respective content object hash from the catalog (operation ).","Computer System",{"@attributes":{"id":"p-0111","num":"0116"},"figref":"FIG. 11","b":["1102","1104","1106","1108","1106","1102","1110","1112","1114","1108","1116","1118","1132"]},"Secure content-processing system  can include instructions, which when executed by computer and communication system , can cause computer and communication system  to perform methods and\/or processes described in this disclosure. Specifically, secure content-processing system  can facilitate secure synchronization of manifests in a CCN. In some embodiments, secure content-processing system  can be executed on a plurality of computer and communication systems, which are able to exchange data that describes the state of the operation associated with secure content-processing system .","In summary, embodiments of the present invention provide a computer system and a method that facilitates secure synchronization of manifests in a CCN. During operation, the system generates an interest of advertisement comprising a name of a content object of the system. This name represents a collection of objects of the system and includes a first hash that is based on a key of the system. The first hash corresponds to a respective content object hash of one or more segments of a manifest representing the collection of objects. The system also determines a request for the content object based on the name in an interest of data from a remote node.","The data structures and code described in this detailed description are typically stored on a computer-readable storage medium, which may be any device or medium that can store code and\/or data for use by a computer system. The computer-readable storage medium includes, but is not limited to, volatile memory, non-volatile memory, magnetic and optical storage devices such as disk drives, magnetic tape, CDs (compact discs), DVDs (digital versatile discs or digital video discs), or other media capable of storing computer-readable media now known or later developed.","The methods and processes described in the detailed description section can be embodied as code and\/or data, which can be stored in a computer-readable storage medium as described above. When a computer system reads and executes the code and\/or data stored on the computer-readable storage medium, the computer system performs the methods and processes embodied as data structures and code and stored within the computer-readable storage medium.","Furthermore, the methods and processes described above can be included in hardware modules or apparatus. The hardware modules or apparatus can include, but are not limited to, application-specific integrated circuit (ASIC) chips, field-programmable gate arrays (FPGAs), dedicated or shared processors that execute a particular software module or a piece of code at a particular time, and other programmable-logic devices now known or later developed. When the hardware modules or apparatus are activated, they perform the methods and processes included within them.","The foregoing descriptions of embodiments of the present invention have been presented for purposes of illustration and description only. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly, many modifications and variations will be apparent to practitioners skilled in the art. Additionally, the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6D"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6E"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 8C"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
