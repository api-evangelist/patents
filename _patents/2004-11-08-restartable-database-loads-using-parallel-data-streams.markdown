---
title: Restartable database loads using parallel data streams
abstract: A method and computer program for reducing the restart time for a parallel application are disclosed. The parallel application includes a plurality of parallel operators. The method includes repeating the following: setting a time interval to a next checkpoint; waiting until the time interval expires; sending checkpoint requests to each of the plurality of parallel operators; and receiving and processing messages from one or more of the plurality of parallel operators. The method also includes receiving a checkpoint. request message on a control data stream, waiting to enter a state suitable for checkpointing, and sending a response message on the control data stream.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07689863&OS=07689863&RS=07689863
owner: Teradata US, Inc.
number: 07689863
owner_city: Miamisburg
owner_country: US
publication_date: 20041108
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation of application Ser. No. 09\/819,275, titled \u201cRestartable Database Loads Using Parallel Data Streams\u201d and filed on Mar. 28, 2001 now U.S. Pat. No. 6,834,358, by Gregory Korenevsky and Alex Yung.","Relational Database Management Systems (RDBMS) have become an integral part of enterprise information processing infrastructures throughout the world. An RDBMS , as shown in , maintains relational data structures called \u201crelational tables,\u201d or simply \u201ctables\u201d . Tables  consist of related data values known as \u201ccolumns\u201d (or \u201cattributes\u201d) which form \u201crows\u201d (or \u201ctuples\u201d).","An RDBMS \u201cserver\u201d  is a hardware and\/or software entity responsible for supporting the relational paradigm. As its name implies, the RDBMS server provides services to other programs, i.e., it stores, retrieves, organizes and manages data. A software program that uses the services provided by the RDBMS Server is known as a \u201cclient\u201d .","In many cases, an enterprise will store real-time data in an operational data store (ODS) , illustrated in , which is designed to efficiently handle a large number of small transactions, such as sales transactions, in a short amount of time. If the enterprises wishes to perform analysis of the data stored in the ODS, it may move the data to a data warehouse , which is designed to handle a relatively small number of very large transactions that require reasonable, but not necessarily instantaneous response times.","To accomplish this, data is \u201cimported,\u201d or \u201cloaded\u201d (block ) from various external sources, such as the ODS , into the data warehouse . Once the data is inside the data warehouse , it can be manipulated and queried. Similarly, the data is sometimes \u201cunloaded\u201d or \u201cexported\u201d from the data warehouse  into the ODS  or into another data store. Since both load and unload processes share many similarities, in terms of the processing they perform, they will be referred to hereinafter as \u201cdatabase loads\u201d or \u201cloads.\u201d","A database load is typically performed by a special purpose program called a \u201cutility.\u201d In most cases the time required to perform a database load is directly proportional to the amount of data being transferred. Consequently, loading or unloading \u201cVery Large Databases\u201d (i.e. databases containing many gigabytes of data) creates an additional problem\u2014increased risk of failure. The longer a given load runs, the higher the probability is that it will be unexpectedly interrupted by a sudden hardware or software failure on either the client  or the server . If such a failure occurs, some or all of the data being loaded or unloaded may be lost or unsuitable for use and it may be necessary to restart the load or unload process.","\u201cParallel Processing,\u201d a computing technique in which computations are performed simultaneously by multiple computing resources, can reduce the amount of time necessary to perform a load by distributing the processing associated with the load across a number of processors. Reducing the load time reduces the probability of failure. Even using parallel processing, however, the amount of data is still very large and errors are still possible.","One traditional approach to handling errors in non-parallel systems is called \u201cmini-batch\u201d or \u201ccheckpointing.\u201d Using this approach, the overall processing time for a task is divided into a set of intervals. At the end of each interval, the task enters a \u201crestartable state\u201d called a \u201ccheckpoint\u201d and makes a permanent record of this fact. A restartable state is a program state from which processing can be resumed as if it had never been interrupted. If processing is interrupted, it can be resumed from the most recent successful checkpoint without introducing any errors into the final result.","Applying checkpointing to a parallel process is a significant challenge.","In general, in one aspect, the invention features a method for reducing the restart time for a parallel application. The parallel application includes a plurality of parallel operators. The method includes repeating the following: setting a time interval to a next checkpoint; waiting until the time interval expires; sending checkpoint requests to each of the plurality of parallel operators; and receiving and processing messages from one or more of the plurality of parallel operators.","Implementations of the invention may include one or more of the following. Before entering the repeat loop the method may include receiving a ready message from each of the plurality of parallel operators indicating the parallel operator that originated the message is ready to accept checkpoint requests.","Receiving and processing messages from one or more of the plurality of parallel operators may include receiving a checkpoint information message, including checkpoint information, from one of the plurality of parallel operators and storing the checkpoint information, along with an identifier for the one of the parallel operators, in a checkpoint data store. Receiving and processing messages from one or more of the plurality of parallel operators may include receiving a ready to proceed message from one of the plurality of parallel operators, marking the one of the plurality of parallel operators as ready to proceed, and, if all of the plurality of parallel operators has been marked as ready to proceed, marking a current checkpoint as good. Receiving and processing messages from one or more of the plurality of parallel operators may include receiving a checkpoint reject message from one of the plurality of parallel operators, sending abandon checkpointing messages to the plurality of parallel operators, and scheduling a new checkpoint. Receiving and processing messages from one or more of the plurality of parallel operators may include receiving a recoverable error message from one or more of the plurality of parallel operators, sending abandon checkpointing messages to the plurality of parallel operators, waiting for ready messages from all of the plurality of parallel operators, and scheduling a new checkpoint. Receiving and processing messages from one or more of the plurality of parallel operators may include receiving a non-recoverable error message from one of the plurality of parallel operators, and sending terminate messages to the plurality of parallel operators.","The method may further include restarting the plurality of parallel operators. Restarting may include sending initiate restart messages to the plurality of parallel processors and processing restart messages from the plurality of parallel processors. Processing restart messages may include receiving an information request message from one or more of the plurality of parallel operators, retrieving checkpoint information regarding the one or more of the plurality of parallel operators from the checkpoint data store, and sending the retrieved information to the one of the plurality of parallel operators. Processing restart messages may include receiving a ready to proceed message from one of the plurality of parallel operators, marking the one of the plurality of parallel operators as ready to proceed, and sending proceed messages to all of the plurality of parallel operators if all of the plurality of parallel operators have been marked as ready to proceed. Processing restart messages may comprise receiving an error message from one or more of the plurality of parallel operators and terminating the processing of the plurality of parallel operators.","In general, in another aspect, the invention features a method for one of a plurality of parallel operators to record its state. The method includes receiving a checkpoint request message on a control data stream, waiting to enter a state suitable for checkpointing, and sending a response message on the control data stream.","Implementations of the invention may include one or more of the following. Waiting to enter a state suitable for checkpointing comprises receiving a checkpoint marker on an input data stream, finishing writing data to an output data stream, and sending a checkpoint marker on the output data stream. Waiting to enter a state suitable for checkpointing may comprise waiting for all of the parallel operator's outstanding input\/output requests to be processed.","The method may further comprise determining that the parallel operator is not in a state suitable for checkpointing and sending a response message on the control data stream may include sending a checkpoint reject message on the control data stream. The method may further comprise experiencing a recoverable error. Sending a response message on the control data stream may include sending a recoverable error message on the control data stream. The method may further comprise experiencing a non-recoverable error. Sending a response message on the control data stream may include sending a non-recoverable error message on the control data stream.","In general, in another aspect, the invention features a computer program, stored on a tangible storage medium, for use in reducing the restart time for a parallel application. The parallel application includes a plurality of parallel operators. The computer program includes a CRCF component which includes executable instructions that cause a computer to repeat the following: set a time interval to a next checkpoint, wait until the time interval expires, send checkpoint requests to the plurality of parallel operators, and receive and process messages from one or more of the plurality of parallel operators. The computer program also includes a plurality of parallel components, each of which is associated with one of the plurality of parallel operators, and each of which includes executable instructions that cause a computer to: receive a checkpoint request message from the CRCF, wait to enter a state suitable for checkpointing, and send a checkpoint response message to the CRCF.","Implementations of the invention may include one or more of the following. Each of the parallel components may include executable instructions that cause a computer to determine that the parallel operator is not in a state suitable for checkpointing. In sending a response message to the CRCF, the parallel component associated with that parallel operator may cause the computer to send a checkpoint reject message to the CRCF. In receiving and processing messages from one or more of the plurality of parallel operators, the CRCF may cause the computer to receive the checkpoint reject message and send abandon checkpoint messages to the plurality of parallel operators in response to the checkpoint reject message. Each of the parallel components may include executable instructions that cause a computer to determine that one or more of the parallel operators has experienced a recoverable error. In sending a response message to the CRCF, the parallel component or components associated with the one or more parallel operator that experienced the recoverable error or errors may cause the computer to send a recoverable error message to the CRCF, proceed with recovery, and send a ready message to the CRCF. In receiving and processing messages from one or more of the plurality of parallel operators, the CRCF may cause the computer to: receive the recoverable error message, send abandon checkpoint messages to the plurality of parallel operators in response to the recoverable error message, wait for the ready messages, receive the ready messages, and schedule a checkpoint.","Each of the parallel components may include executable instructions that cause a computer to determine that one of the parallel operators has experienced a non-recoverable error. In sending a response message to the CRCF, the parallel component associated with the one parallel operator may cause the computer to send a non-recoverable error message to the CRCF. In receiving and processing messages from one or more of the plurality of parallel operators, the CRCF may cause the computer to receive the non-recoverable error message and send stop processing messages to the plurality of parallel operators in response to the non-recoverable error message. The CRCF may further include executable instructions that cause the computer to send an initiate restart message to one of the plurality of parallel operators. In response to the restart message from the CRCF, the parallel component associated with the one parallel operator may cause the computer to send an information request to the CRCF. In responding to the information request, the CRCF may cause the computer to retrieve checkpoint information regarding the one parallel operator from a checkpoint data store and send the checkpoint information to the one parallel operator. The parallel component associated with one of the parallel operators may further comprise executable instructions that cause the computer to send a ready to proceed message to the CRCF. In responding to the ready to proceed message, the CRCF may cause the computer to mark the one parallel operator as ready to proceed and, if all of the plurality of parallel operators have been marked as ready to proceed, send proceed messages to all of the plurality of parallel operators. The parallel component associated with one of the parallel operators may further comprise executable instructions that cause the computer to send an error message to the CRCF. In responding to the error message, the CRCF may cause the computer to send messages to all of the parallel operators to terminate their processing.","The following definitions, abbreviations, and phrases, which are used in this application, are not intended to limit the scope of the invention in any way. They are provided for the benefit and convenience of the reader:","1. \u201cRelational tables,\u201d or simply \u201ctables,\u201d are conceptual relational data structures maintained by the RDBMS.","2. Tables consist of related data values known as \u201ccolumns\u201d (or \u201cattributes\u201d) which form \u201crows\u201d (or \u201ctuples\u201d).","3. An RDBMS Server is a hardware and\/or software entity responsible for supporting the relational paradigm. As its name implies, the RDBMS server provides miscellaneous services that enable storage, retrieval, organization and management of data.","4. A software and\/or hardware entity that utilizes the services provided by the RDBMS server is known as a client.","A database load process usually:","1. Introduces data into newly created tables. The tables are initially created empty and require an outside process to populate them with data. This type of load is commonly known as an \u201cinitial load.\u201d","2. Introduces new data into previously created (existing) tables. This type of load is sometimes referred to as an \u201cappend.\u201d","3. Modifies data in existing tables through one of the following operations:",{"@attributes":{"id":"p-0039","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["INSERT\u2014add new rows to the tables","UPDATE\u2014modify current column values","DELETE\u2014delete existing table rows\n\nThis type of load is sometimes called an \u201cupdate.\u201d\n"]}}}},"A \u201cdatabase export\u201d process usually extracts data from existing tables and copies it to an external data store.",{"@attributes":{"id":"p-0041","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DBMS","Database Management Systems"]},{"entry":["RDBMS","Relational Database Management Systems"]},{"entry":["Parallel Computer","A set of processors which can work"]},{"entry":[{},"cooperatively to solve a computational"]},{"entry":[{},"problem"]},{"entry":["Parallel Program","A program designed to take advantage of"]},{"entry":[{},"the parallel processing capability of the"]},{"entry":[{},"underlying hardware"]},{"entry":["Data Partitioning","Division of a data source into multiple"]},{"entry":[{},"disjoint partitions"]},{"entry":["Functional Partitioning","Division of a process into multiple"]},{"entry":[{},"processes along functional boundaries"]},{"entry":["Functional Parallelism","see Functional Partitioning"]},{"entry":["Pipelining","see Functional Partitioning"]},{"entry":["Scalability","The ability of a program to take advantage"]},{"entry":[{},"of additional computing resources, such as"]},{"entry":[{},"I\/O devices, CPUs, memory, network"]},{"entry":[{},"connections, etc., to accommodate an"]},{"entry":[{},"increase in computational load"]},{"entry":["Database Load","The process of transferring data from an"]},{"entry":[{},"external source into a DBMS"]},{"entry":["Database Unload","The process of transferring data from a"]},{"entry":[{},"DBMS to an external target. The opposite"]},{"entry":[{},"of Database Load"]},{"entry":["State","A representation of a program's execution"]},{"entry":[{},"at a given point in time."]},{"entry":["State Transition","A process whereby the program enters a"]},{"entry":[{},"new state"]},{"entry":["Checkpoint","Program's state information recorded"]},{"entry":[{},"externally"]},{"entry":["Checkpointing","A technique designed to reduce risk due to"]},{"entry":[{},"failure"]},{"entry":["Restart","A process whereby a previously terminated"]},{"entry":[{},"program resumes its processing."]},{"entry":["Collective State","A combined state of a parallel program"]},{"entry":["PEI","Parallel Execution Infrastructure"]},{"entry":["ADSF","Asynchronous Data Stream Facility"]},{"entry":["CRCF","Checkpoint and Restart Coordination"]},{"entry":[{},"Facility"]},{"entry":["MPP","Massively Parallel Processors"]},{"entry":["Parallel Instance","A copy of a program running as a separate"]},{"entry":[{},"processes"]},{"entry":["I\/O","Input\/Output"]},{"entry":["OLTP","On-Line Transaction Processing"]},{"entry":["Distributed Process","A logical process carried out by several"]},{"entry":[{},"distinct processes"]},{"entry":["DSM","Distributed State Machine"]},{"entry":["Dialog","A multiple data interchange between"]},{"entry":[{},"programs within a given context"]},{"entry":["CPM","Checkpoint Partitioning Mark"]},{"entry":["API","Application Programming Interface"]},{"entry":["Virtual Table","A table that does not exist in its own right,"]},{"entry":[{},"except its definition."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Although parallel processing has been successfully used for database loading, and error handling approaches such as checkpointing have been successfully used to recover conventional database load utilities from failures, combining both of these techniques in a single program\u2014a restartable parallel database utility\u2014presents its own set of challenges. Below are some of the issues:","1. Failure Detection","As mentioned above, many parallel programs consist of a set of independently executing processes. A given failure may not affect all the processes in the same way. For example, the failure may affect only one process, or a subset of processes. While the affected processes may terminate, others belonging to the same program may continue executing. In this case, the final overall result produced by the parallel program may be incomplete or incorrect. Therefore, it is important for a parallel program as a whole to sense the failure of any one of its constituent processes, so that it can carry out the appropriate error recovery.","2. Consistency of Checkpoints","Checkpointing works well for conventional sequential programs because a checkpoint needs to capture the state of only one process. In contrast, a parallel program consists of two or more such processes, each with its own state. Further, due to the non-deterministic (unpredictable) way most host operating systems handle such processes, each one may perform its checkpoint at a different time. Since in almost all cases processes share data, restarting each process individually using only its own checkpoint information would not produce the correct overall result for the parallel program. This means a parallel program must coordinate checkpointing of its individual processes.","3. Resumption After a Failure","This issue is related to the checkpoint consistency issue discussed above. Not only should a parallel program coordinate the checkpointing of its constituent processes, it should also coordinate the resumption of processing after a failure. Resuming some processes and not resuming others may produce an erroneous result. If processes share data, allowing some to proceed while others are still recovering from an error may also produce an error.","All of these considerations suggest that a restartable parallel database utility should have coordination capabilities that are not normally found in regular parallel programs or restartable non-parallel programs.","Checkpointing","As discussed above, checkpointing is a technique that enables programs to recover from unexpected failures, such as unexpected power loss, severe hardware malfunctions, etc., not easily handled by other means. Without checkpointing, such failures may require a failed program to be re-executed from the very beginning. For long-running tasks, such as many loads and unloads, this may result in hours of lost computing time and missed deadlines. Checkpointing makes it possible to control this situation.","Checkpointing is based on a notion of a program's \u201cstate,\u201d which, in one example, can be defined as a combination of some or all of the following:\n\n","During execution a program transitions from one state to another. Checkpointing records a program's current state to an external persistent storage location, such as a file. To simplify this task, checkpointing is preferably performed when a minimum amount of information is required to describe the program's state. The program records its state information, verifies that the store occurred, and then proceeds with the rest of its processing.","State information recorded in this manner is known as a \u201ccheckpoint.\u201d Checkpoints can be taken at regular time intervals, which are called \u201ccheckpointing intervals.\u201d When an unexpected failure occurs, processing can be resumed, or \u201cre-started,\u201d from the most recent checkpoint that occurred before the failure. During re-start, the program reads the most recent valid checkpoint, set its state according to the information it contains, and proceeds with the rest of the processing. In effect, the processing continues as if it were never interrupted.","Checkpointing makes it possible to control the maximum amount of time necessary to re-run a failed program, since that time would not exceed the size of the most recent checkpointing interval. The downside of checkpointing is that it imposes a certain amount of processing overhead, thereby slowing down program execution. However, since the overhead is proportional to the checkpointing frequency, the user can choose the checkpointing interval that represents the best compromise between increased overhead and potential re-run time.","Checkpointing in Parallel Application","A parallel \u201capplication\u201d executes as a set of distinct \u201cprograms,\u201d each having its own state. Therefore, in general, at any given point in time such an application cannot be described in terms of a single-process state, but instead requires a \u201ccollective state.\u201d A collective state is a combination of the states of all the participating programs. A parallel application which contains N programs, where each program can have M states, can have N*M collective states.","Checkpointing a parallel application requires that the collective state of the application be recorded. Since a parallel application's constituent programs execute independently, typically their states and state transitions are independent of the states and transitions of other programs. As a result, the collective state of a parallel application can be difficult to determine at any given point in time, unless the programs are somehow synchronized.","Further, from time to time the programs may inter-communicate and exchange data with each other. For example, one program may supply data required by another program. The program that supplies data, in effect, becomes an external resource for the program that consumes data. In order to record its own state, the consumer program must also record some state information related to the producer program. To do that, the programs may have to coordinate their processing. In essence, in this situation each program cannot perform its checkpointing independently, but instead needs to coordinate it with other programs in an application.","Checkpointing Facilities","A database load utility, which combines parallel processing with checkpointing, includes the following components:\n\n","The API also defines a protocol that dictates the sequence and the timing of requests and responses. The parallel programs are designed to operate and communicate in accordance with this protocol.","The Parallel Execution Infrastructure is initialized before it runs any parallel utilities. It can be started independently on a single multi-processing node, or span several processing nodes, including massively parallel processors (\u201cMPP\u201d) and network-connected processors (\u201cnetwork clusters\u201d), using the nomenclature associated with the Teradata Active Data Warehousing System available from NCR Corporation.","Parallel utility program execution is initiated by submitting a request to the PEI to create a \u201cParallel Application,\u201d which represents a particular execution of a parallel program. Multiple distinct executions of a given parallel program correspond to multiple distinct Parallel Applications within PEI. After a Parallel Application is created, it can be referred to by name in subsequent requests to the PEI. Once a Parallel Application is created, additional requests are submitted to the PEI instructing it to launch the programs for a given parallel application.","Parallel database utility programs execute as parallel applications within the PEI. The PEI provides low-level, system-oriented services, while the utilities implement higher-level, database-oriented functions.","Operators","Internally, the utilities are structured as a set of \u201coperators\u201d that can create, modify and consume \u201cvirtual table\u201d rows. Each operator is designed to perform a specific function, e.g. retrieve rows of data from external files, store rows of data in database tables, evaluate logical expressions involving column values, etc. \u201cVirtual tables\u201d represent an operator's inputs and outputs.","Operators are divided into four general categories based on the function they perform:\n\n","Asynchronous Data Streams are used to interconnect the operators. They enable the flow of data between the operators. A data stream has an origin and a destination. In order for the data to flow through the data stream, it has to be opened both at the origin and at the destination. Once the data stream is open, the origin and the destination programs can issue read and write requests to initiate the transfer of data. In one example, the read and write operations can be issued in any order, i.e. in a non-synchronized manner, or \u201casynchronously.\u201d For this reason, these data streams are referred to as \u201casynchronous.\u201d The data streams provide the buffering mechanism that enables each operator to execute independently of and in parallel with the other operators that either consume or provide its data. Further, since operators interchange data only through the data streams, they are not concerned with the specifics of the interconnection, and can be arranged in many different sequences to accomplish a wide variety of tasks.","Another benefit of using asynchronous data streams is that they obviate the need for intermediate data stores, which typically results in faster execution times and helps avoid various system limitations, such as limitations on maximum file size. For example, a utility operator can export data from an OLTP DBMS server, send it via the data stream to a filtering and conditioning operator, which, in turn, can send it to a data warehouse loading operator. The entire process can be performed in a single step without storing intermediate results on external media, resulting in faster execution time.","In addition to transferring data between the operators, the data streams make it possible to inter-connect multiple operators, to merge their outputs into a single data stream or to split it into multiple data streams. The actual mechanism underlying the data streams varies from one architecture to another and includes various memory-based and communication protocol-based implementations.","Checkpoint-Restart Coordination Facility","From time to time the operators may need to coordinate their processing, e.g. during checkpoint processing. A Checkpoint-Restart Coordination Facility (\u201cCRCF\u201d) is provided to enable this coordination. The CRCF works by means of \u201cexecutors,\u201d which are special components designed to control operator execution.","The CRCF includes a central coordinator, which supervises a given coordination activity, such as the processing of a checkpoint. The coordinator maintains two-way communications with executors, which, in turn, relay requests to the operators. The sequence and the timing of the requests are dictated by the coordination protocol, which is implemented by all the components: the CRCF, the executors, the operators and the asynchronous data streams. The flow of coordination requests and responses forms a \u201ccontrol data stream.\u201d","An example parallel load utility, illustrated in , is used to load data from a first data source  and a second data source  to a DBMS . A first producer operator  provides an interface to the first data source , a second producer operator  provides an interface to the second data source , and a first consumer operator  provides an interface to the DBMS .","A first producer operator  extracts data from a first data source  and writes it to a first extracted data stream ; a second producer operator  extracts data from a second data source  and writes it to a second extracted data stream . A first consumer operator  reads data from conditioned data streams  and  and loads it into the DBMS .","A first extracted data stream  is opened between the first producer operator  and a first filter operator  and a first conditioned data stream , which carries a filtered version of the first extracted data stream , is opened between the first filter operator  and the first consumer operator . A second extracted data stream  is opened between the second producer operator  and a second filter operator  and a second conditioned data stream , which carries a filtered version of the second extracted data stream , is opened between the second filter operator  and the first consumer operator . The first consumer operator conceptually combines the first conditioned data stream  and the second conditioned data stream .","To load data from the first data source  and the second data source  to the DBMS , data is extracted from the first data source  through the first producer operator , and filtered by the first filter operator . That data is combined by the first consumer operator  with data extracted from the second data source  by the second producer operator  and filtered by the second filter operator . The combined data stream is stored in the DBMS through the first consumer operator .","A checkpoint-restart coordinator (CRCF)  coordinates checkpointing and restart operations. Control data streams are opened to accommodate checkpointing information that passes between the CRCF  and the first producer operator , the second producer operator , the first consumer operator , the first filter operator  and the second filter operator , respectively. A checkpoint data store  stores the checkpoint data.","Normal Execution and Checkpointing","When the utility illustrated in  begins to run (block ), it records the state of all registered operators as \u201cready\u201d (block ), which means that each of the registered operators is ready to accept checkpoint requests, as shown in . An operator becomes registered by sending a ready message to the CRCF, as shown in .  shows parallel timelines ,  and  for processing being performed by Operator , Operator  and the CRCF, respectively, with time increasing with distance toward the bottom of the page. The ready messages  and  from Operator  and Operator , respectively, to the CRCF cause Operator  and Operator  to be registered.","Once all of the operators have been registered, the CRCF sets a time interval  for the next checkpoint (block  in ). When the interval expires (block ), the CRCF initiates checkpoint processing (block ), as illustrated in . Checkpoint processing begins when the CRCF sends a checkpoint request ,  to every registered operator (block ). The checkpoint requests ,  are preferably sent asynchronously, as shown in . They may, however, be sent virtually simultaneously.","Assuming they are executing properly, every operator should respond to the checkpoint requests. In a normal situation, each operator will respond with a checkpoint ,  (). The CRCF will store the checkpoint in the checkpoint data store. The CRCF will then schedule another checkpoint and the process will repeat. A checkpoint ,  may include more than one message conveying information from the operator to the CRCF.","The CRCF will receive a message from an operator (block  in ). The CRCF first determines if the message is an error message (block ). If it is not, which means that the message includes checkpoint information , the CRCF will add information to the message identifying the operator that sent the message (block ) and store the augmented message in the checkpoint data store (block ). The CRCF will then mark the responding operator as ready to proceed (block ), and determine if all of the operators have provided checkpoint information (block ). If they have not, the CRCR will loop back and wait for a message from another operator. If all of the operators have checked in (block ), the CRCF will mark the checkpoint as good (block ), send proceed messages ,  () to the operators (block ) and return (block ).","It is also possible that the CRCF will receive an error message from one of the operators, as shown in . Those messages include reject , recoverable error , and non-recoverable error  messages.","Returning to , if a good checkpoint was received, the CRCF sets a time interval to the next checkpoint (block ) and the process repeats.","Checkpoint Reject","An operator can also reject a checkpointing request if its current state doesn't allow it. In this context, an operator rejects a checkpoint request if it wants to defer checkpoint processing. If any one of the operators rejects the request, by sending a checkpoint reject message , checkpoint processing is abandoned, as illustrated in . The CRCF sends an \u201cabandon checkpointing\u201d notification ,  to every operator with instructions to abandon the current checkpoint processing (block ). The checkpoint is then re-scheduled by setting an interval to the next checkpoint (block ) and, after the interval expires (block ), the CRCF resends checkpoint requests ,  (block ). If none of the operators reject the checkpoint requests, the CRCF proceeds with the next phase of checkpointing and the operators send checkpoint messages ,  to the CRCF.","The checkpoint request message  allows the data access components to achieve an appropriate state before responding to a checkpointing request. For example, an appropriate state may be when all of a producer operator's input\/output (\u201cI\/O\u201d) requests have completed (block ), as shown in . The producer operator would then process the data already in its input queue or queues (block ) and then gather restart information from its data source files (block ), where such data is available, and its own internal restart information (block ). The producer operator would include this restart information in its checkpointing message (block ). If an error occurs and the application is restarted, the producer operator could use this restart information to re-position the source file, to allow the processing to resume without causing conflicts. Consumer operators would follow similar procedures.","Checkpoint Partitioning Marks","One particular aspect of checkpoint processing concerns data streams. Since data streams act as shared resources between multiple operators, it is important to ensure that the state of each data stream is perceived consistently by all the operators. Since data streams are asynchronous, an operator that is reading a data stream cannot determine how much more data, if any, it will receive through that data stream. At the same time, the sending operator cannot reliably determine how much data, and when, the receiving operator will read. This means that during checkpointing it is important for the sender to indicate that it has finished sending all the data that should be counted towards the current checkpoint. It also is important for the receiver to know that it has read all the data that should be counted towards the current checkpoint.","In one example, operators that have finished processing all their input data and are ready to checkpoint issue special checkpointing requests against their output data streams. These requests result in special records being written to the data streams, called \u201ccheckpoint partitioning marks,\u201d or \u201cCPM.\u201d An operator would recognize that receipt of a CPM would indicate that the receiving operator had read the last row that must be counted toward the current checkpoint. This means that the receiving operator has processed all the data created by the sending operator and the data stream is in a consistent state. If the receiving operator is otherwise ready to checkpoint, it can do so. If the receiving operator is itself writing data to an output data stream, it will also issue a checkpointing request against the data stream by writing a CPM into that data stream to indicate to the receiving operator on that data stream that it has processed all incoming data. In general, as shown in , an operator cannot complete its checkpoint processing until it has read CPMs from all of its input data streams (block ), finishes writing data to the output data stream (block ), and then writes CPMs to all of its output data streams (block ). Once it finishes this processing, it can send a checkpoint message (block ). In this manner, checkpoint processing is \u201ccascaded\u201d from one operator to another.","This sequence of events is illustrated in . In both figures, Operator  and Operator  are each assumed to have an input data stream and an output data stream, and are assumed to be connected to the CRCF for the purposes of checkpointing. In the examples shown in , Operator  and Operator  are not connected to the same data stream. After it receives a checkpoint request message  from the CRCF, Operator  waits until it has received a CPM  on its input data stream, completes processing the data in its input buffers, transmits a CPM  on its output data stream, and only then sends its checkpoint message  to the CRCF. Similarly, after Operator  receives a checkpoint request message  from the CRCF, it waits until it has received a CPM  on its input data stream, completes processing the data in its input buffers, transmits a CPM  on its output data stream, and only then sends its checkpoint message  to the CRCF.",{"@attributes":{"id":"p-0083","num":"0109"},"figref":["FIG. 7","FIG. 7"],"b":["1","530","700","1","705","710","1","2","2","735","710"]},"As described above, after it issues the abandon checkpoint messages , , the CRCF reschedules the checkpoint and, after the next checkpoint interval expires, the CRCF transmits new checkpoint requests , . Operator  waits until it receives a CPM  on its input data stream, finishes processing, transmits a CPM  on its output data stream, and then transmits its checkpoint message . Operator , which has already received a CPM  and transmitted a CPM  by the time the checkpoint request  arrives, can transmit its checkpoint message  almost immediately.","Once an operator is in a state suitable for checkpointing, it records information about that state by issuing checkpoint information messages  () to the CRCF. Checkpoint message , shown in , is an example of such a request. The processing of checkpoint information messages was described above in the discussion of . As illustrated above, the checkpointing process is accomplished asynchronously. This is safe with respect to checkpoint consistency, because it relies on two of the following complementary synchronization mechanisms:","1. The CRCF and its checkpointing protocol, which carries out checkpoint processing by means of dialogs. The dialogs allow the CRCF to control the timing of steps in checkpoint processing.","2. The Asynchronous Data Stream API and the Checkpoint Partitioning Marks. These marks make it possible for operators to exchange checkpoint-related information. Essentially, operators can get limited information about each other's states, without relying on CRCF.","Further, the asynchronous data streams are presumed to be unidirectional, i.e., from a sending operator to a receiving operator, which means that the sending operator will not receive any information from a receiving operator connected to the same data stream. Consequently, a sending operator can complete its checkpoint processing as soon as it has written a CPM to its output data stream or streams. This assumption of unidirectional data flow is especially applicable to database load and unload utilities, which typically transfer data in one direction.","Recoverable Error","If an error occurs anytime during the checkpoint processing, the operator which detects the error notifies the CRCF identifying the error as a recoverable error , or a non-recoverable error , as shown in . If the error is recoverable , the CRCF performs recoverable error processing  and if the error is non-recoverable , the CRCF performs non-recoverable error processing , as shown in .","In response to a recoverable error, the CRCF abandons the checkpoint processing already in progress (block ), as shown in . It does so by sending \u201cabandon checkpoint\u201d requests  and  to every operator, as shown in . The CRCF then waits for the each operator to respond with a \u201cready\u201d message ,  (block , ). The CRCF then reschedules the checkpoint (block , ) and, at the scheduled time, sends checkpoint request messages ,  () to the registered operators, which respond with checkpoint messages , .","Non-Recoverable Error","An operator may experience a non-recoverable error at any point during its processing, as illustrated in . In , Operator  and Operator  have sent ready messages ,  to the CRCF, and the CRCF has responded with checkpoint requests , , when the error  occurs in Operator . When Operator  revives, it sends a non-recoverable error message  to the CRCF. When the CRCF receives a message indicating that an operator has experienced a non-recoverable error, it will send \u201cterminate\u201d messages ,  to the registered operators (block , ) which causes the registered operators to terminate processing.","Restart","If a parallel program terminates because of a non-recoverable error, as shown in , it may be possible to restart the parallel program. Typically, however, before the restart can be accomplished, the problem that caused the non-recoverable error is remedied. For example, if the job control language (\u201cJCL\u201d) controlling a database load or unload was incorrect or improperly formatted, the operator should correct the JCL before attempting a restart. In one implementation, the restart operation is requested by adding a \u201crestart\u201d switch to the appropriate JCL command. As a consequence, the CRCF will issue restart requests ,  to the operators, such as Operator  and Operator , as shown in .","When Operator  and Operator  receive the restart requests , , they will seek to restore their state to that described in the most recent good checkpoint. The operators send requests ,  to the CRCF to get information recorded during the most recent good checkpoint. When the CRCF receives an message from an operator (block ), as shown in , and recognizes it as an information request , it retrieves the requested information from an external source (block ) and passes it to the operator (block ) using checkpoint information messages , . An operator can issue multiple requests ,  if it had previously saved multiple pieces of information as part of its checkpoint.","Once an operator has restored its state, it is ready to resume processing. It sends the CRCF a notification ,  that it is ready to proceed","When the CRCF receives a \u201cready to proceed\u201d message  from an operator, it marks the operator as ready to proceed (block ). The CRCF waits until it receives such a message from every registered operator (block ). After that, it sends out notifications ,  to the operators, allowing them to proceed (block ). At this point the restart processing is finished and the CRCF begins scheduling checkpoints.","If an error occurs anytime during the restart processing, the operator that detects an error notifies the CRCF. Upon receipt of an error message , the CRCF cancels the entire restart by sending out \u201cabandon restart\u201d requests to the parallel operators. In response to these messages, the entire application terminates. In essence, the restart processing is \u201cpessimistic,\u201d i.e., it assumes that until and unless all the operators are ready to restart, application processing cannot be resumed.","An example architecture for a system capable of checkpointing as described above with very large databases using a parallel database system, such as a Teradata Active Data Warehousing System available from NCR Corporation, is illustrated in .  shows a sample architecture for one node of the DBS. The architecture can be extended with additional nodes, . The DBS node includes one or more executors , each of which manages one or more operators , connected by a network . Each of the operators may be one or more physical processors or each may be a virtual processor, with one or more virtual processors running on one or more physical processors.","For the case in which one or more virtual processors are running on a single physical processor, the single physical processor swaps between the set of N virtual processors.","For the case in which N virtual processors are running on a M-processor node, the node's operating system schedules the N virtual processors to run on its set of M physical processors. If there are 4 virtual processors and 4 physical processors, then typically each virtual processor would run on its own physical processor. If there are 8 virtual processors and 4 physical processors, the operating system would schedule the 8 virtual processors against the 4 physical processors, in which case swapping of the virtual processors would occur.","Each of the operators has a certain purpose and carries out a particular function necessary within the overall database loading or unloading task. A load task may include multiple operators, each one capable of executing independently and in parallel with other operators. An asynchronous data stream facility that inter-connects the operators, shown on the diagram as arrows between the operators, enables parallelism for operators that share data. As a result of this arrangement, many operations within the load or unload task can be performed simultaneously and in parallel, resulting in reduction of the overall execution time.","The CRCF  controls the operation of the executor . The CRCF may run on one or more physical processors or it may be a virtual processor running on more than one physical processors.","Parallel DBMS Load Utilities have the following advantages over conventional, single-process sequential utilities:\n\n","The reduction in execution time is especially useful for operators with lengthy execution times, such as DBMS utilities which handle large volumes of data. It makes it possible for such utilities to load more data in the same amount of time. It also means that computing resources can be reassigned to other work more quickly than with conventional DBMS load utilities.","The integrated Checkpoint and Restart Coordination Facility and its API simplify the design and development of parallel utility programs. This results in a lower cost of development.","The various implementations of the invention are realized in electronic hardware, computer software, or combinations of these technologies. Most implementations include one or more computer programs executed by a programmable computer. In general, the computer includes one or more processors, one or more data-storage components (e.g. volatile and nonvolatile memory modules and persistent optical and magnetic storage devices, such as hard and floppy disk drives, CD-ROM drives, and magnetic tape drives), one or more input devices (e.g., mice and keyboards), and one or more output devices (e.g., display consoles and printers).","The computer programs include executable code that is usually stored in a persistent storage medium and then copies into memory at run-time. The processor executes the code by retrieving program instructions from memory in a prescribed order. When executing the program code, the computer receives data from the input and\/or storage devices, performs operations on the data, and then delivers the resulting data to the output and\/or storage devices.","The text above described one or more specific embodiments of a broader invention. The invention also is carried out in a variety of alternative embodiments and thus is not limited to those described here. For example, while the invention has been described here in terms of a DBMS that uses a massively parallel processing (MPP) architecture, other types of database systems, including those that use a symmetric multiprocessing (SMP) architecture, are also useful in carrying out the invention. Many other embodiments are also within the scope of the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
