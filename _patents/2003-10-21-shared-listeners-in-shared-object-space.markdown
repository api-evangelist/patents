---
title: Shared listeners in shared object space
abstract: A system for sharing listeners monitoring events occurring in objects shared by multiple applications each running inside its own virtual machine in a computer system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07689986&OS=07689986&RS=07689986
owner: GemStone Systems, Inc.
number: 07689986
owner_city: Beaverton
owner_country: US
publication_date: 20031021
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["Not applicable","The present invention relates to a system for sharing listener objects among multiple applications each running inside its own virtual machine.","Computer hardware and storage media can only create, store, and process binary information, i.e. information written using only two digits, \u201c0\u201d and \u201c1\u201d. A compact disc, for example, has a surface subdivided into tiny sections that are either pitted (1) or not pitted (0) such that a laser can detect the presence or absence of pits. Similarly, microprocessors have inputs and outputs to which a reference voltage either is (1) or is not (0) present. (Microprocessors repeatedly measure the voltage at each input and output at regular intervals, or cycles\u2014hence the speed of a processor is expressed in cycles per second, or \u201cHertz.\u201d) Accordingly, any computer program, as well as any data used in that computer program, must first be expressed in binary code for a computer to run the program or process the data.","Though binary code is conceptually simple, its use to perform computerized tasks introduces two drawbacks. First, binary code is a relatively inefficient way to express information. As a simple example, the number \u201c100\u201d in decimal notation is expressed as \u201c1100100\u201d in binary code, and therefore must at a minimum occupy seven \u201cpits\u201d on a compact disc and\/or occupy either a single input of a processor for seven cycles (if entered serially) or seven inputs for one cycle (if entered in parallel). In technical terms, the space that a piece of information occupies, or alternatively the number of time cycles a piece of information occupies, is referred to in \u201cbits.\u201d That is to say, the number \u201c100\u201d is a 7-bit number because it takes seven digits to express in binary code. The number \u201c101\u201d is also a 7-bit number, coded as 1100101, as is every number between \u201c64\u201d (1000000) and \u201c127\u201d (1111111).","In computer applications, binary code is even more inefficient because computerized information is, by convention, typically expressed in multiples of 8 bits, e.g. 8-bit, 16-bit, 24-bit, etc. The reason for this convention is that a computer processing or storage device has no physical way of distinguishing when one number ends and another number begins. Accordingly, the convention is to write a program that specifies the bit-rate, i.e. the number of bits that each piece of data processed in the program will occupy. If a program is written in 8-bit code, for example, every piece of data occupies eight bits, e.g. the number 0 is coded as 00000000, the number 1 is coded as 00000001, and the number 255 is coded as 11111111. In 8-bit code, therefore, every piece of data has a value between 0 and 255 and every piece of data occupies 8 bits even if it could theoretically be represented by a single bit. If a program requires that any piece of data take on a value greater than 255, the bit-rate for the program must be increased incrementally to 16-bit, 24-bit, etc. as appropriate.","A computer program operating in binary code may therefore use a tremendous amount of storage space and processor cycles, particularly when graphics are involved. For example, a photographic quality image is often coded at 24-bits for every pixel. If the image resolution is 2 million pixels, as is common with today's digital cameras, each image would occupy 48 million bits, or 4 Megabytes, where a byte is defined as 8 bits per byte (due to the convention of expressing binary code in multiples of 8 bits). Manipulating that image would similarly require 48 million cycles of processor time for each manipulation. The amount of storage space and processing time increases exponentially when manipulating video because the computer system must process and store many such images every second. In addition, there are many other computer applications that are at least as intensive as image processing. Applications of such intensity tend to slow considerably as data is \u201cbottlenecked\u201d in the computer system.","One way of minimizing the impact of the inefficiency of binary code has been to increase the amount of storage space and processing speed of computers. For example, personal computers sold commercially today offer up to 300 gigabytes (300 billion bytes) of hard drive storage, 4 gigabytes (4 billion bytes) of temporary memory storage, and processing speeds of over 4 gigahertz (4 billion cycles per second). Business computers, such those used in the motion picture industry are even faster and include more storage. In other words, as computer applications have demanded more storage space and processing time, the computers have become faster with higher storage capacity. Still, while these numbers are impressive, computer systems are not sufficiently fast as to eliminate all bottlenecks, and in fact, as computers become faster with more available storage, new applications are developed to take advantage of the improved technology so as to provide the need for even faster computers, even more storage space, etc.","Another way of minimizing the impact of the inefficiency of binary code is to write computer programs and applications as efficiently as possible. Thus there is always an emphasis on writing computer code that achieves its outcome in as few steps or calculations as possible. Similarly, a computer program should not be written in 24-bit code when only 8-bit code is required for the application, and the computer program may compress data when appropriate.","A second drawback of using binary code to perform computerized tasks is that it is impractical to write a computer program in binary code, particularly with complex programs. The first rudimentary computers, for example, were operated by mechanically toggling electrical switches between on and off states to enter a sequence of binary instructions. Computer programs simply specified the sequence of binary instructions to enter. This method was feasible so long as the program was no more than about a hundred instructions long. Beyond that point, programming directly in binary code became too complex, and programs too difficult to correct, or debug. Moreover, because the binary instructions were dependent upon the particular electrical circuitry of the computer processor and related hardware, the programmer was required to know in detail the particular architecture of the computer being used by the program.","To accommodate computer programs of increasing complexity, as well as to facilitate the introduction of personal computers into the marketplace, modern operating systems were developed. Early computer operating systems, such as Microsoft Corporation's MS-DOS disk operating system (DOS) software, essentially acted as an interface with a computer's hardware so that a user could issue specific commands or instructions to the computer written in more ordinary language. The operating system would recognize the commands, and automatically issue the instructions to the computer in binary code. For example, in MS-DOS software, entering the command \u201cMEM\u201d into the computer would result in the computer displaying the types and amounts of computer memory available. The person issuing the command did not need to know anything about binary code or the manner in which the command being entered produced the desired result. The user simply needed to either memorize or look up a set of commands in an instruction manual.","Further, early operating systems recognized simple programming languages, such as Beginner's All-purpose Symbolic Instruction Code (BASIC) and FORTRAN, written in terms more intuitive than binary code. In these languages, commands such as WRITE, READ, LOOP, SET and other intuitive terms provided a means to write computer programs in a manner easily learned and perhaps more importantly, in a manner more easily readable when debugging the program. A simple computer program to calculate the area of a circle, for example, might have been written in BASIC approximately in this form:",{"@attributes":{"id":"p-0013","num":"0012"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"10","PROGRAM 1"]},{"entry":[{},"20","WRITE \u201cThis is a program to calculate the area of a circle.\u201d"]},{"entry":[{},"30","WRITE \u201cPlease enter the radius of the circle\u201d"]},{"entry":[{},"40","READ R"]},{"entry":[{},"50","SET A=\u03a0 *R{circumflex over (\u2009)}2"]},{"entry":[{},"60","WRITE \u201cThe area of the circle is\u201d R"]},{"entry":[{},"70","END"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In this example, after a person typed \u201cRUN PROGRAM 1\u201d, the computer would execute the command lines in numerical sequence, whereby a person would be prompted to enter the value for a radius, defined as \u201cR\u201d, after which the computer would square that value, multiply the squared value by pi and print out the computed area. Writing this same program in binary code not only would have required much more time and effort on the part of the programmer, but the programmer also would have had to know the technical specifications of the computer processor. Obviously, the introduction of operating systems along with intuitive programming languages was a boon to both consumers and computer programmers.","A number of such operating systems and programming languages became prevalent. For example, Apple Inc.'s MAC OS and Microsoft's WINDOWS operating systems improved (from a consumer's perspective) upon simple text-based operating systems such as DOS by allowing a user to issue instructions to the computer using a point-and-click graphical interface displayed on a computer monitor. Computer applications, such as word processing programs, computer games, and a host of others took advantage of this functionality to provide products that could be used more intuitively through the graphical interface. Today, a host of operating systems are used, such as many versions of the WINDOWS, MAC OS, LINUX and WINDOWS NT software, among others.","A wide variety of programming languages also became prevalent. At first, most new programming languages followed the model of the early FORTRAN language by structuring the programming language as a series of commands by which a programmer would issue instructions to a computer in a logical order. The most popular of these language types is a program called \u201cC.\u201d The creation of \u201cC\u201d is considered by many to have marked the beginning of the modern age of computer languages. \u201cC\u201d successfully synthesized what had seemed to be conflicting attributes of several existing programming languages, adding new attributes to form a single, powerful structured language that also happened to be easy to learn. Moreover, it was a programmer's language. Prior to the development of \u201cC\u201d, computer languages were generally designed either as academic exercises by engineers or designed by bureaucratic committees. \u201cC\u201d, however, was developed by programmers, reflecting the way they approached the task of programming. As a result, \u201cC\u201d found wide and rapid acceptance in the programming community, attracting many followers who had near-religious zeal for it.","Once again, however, the increasing complexity of computer programs exposed an underlying flaw of \u201cC\u201d as well as its predecessors. Each of these programming languages requires that a program be written as a series of linear steps or instructions (with an occasional loop or branch thrown in). In fact, writing such a program is similar to constructing a geometric proof, and like a proof, once a program such as C or FORTRAN exceeds a certain number of steps (somewhere between 25,000 and 100,000 lines of code), the program becomes too complex to write effectively.","Therefore a new approach to computer programming began to find acceptance in the programming community, commonly referred to as object-oriented programming. Object-oriented programming approaches a programming task in roughly the same way that a person's mind might approach that task\u2014by abstracting a solution. Rather than defining a series of steps, or instructions by which a task could be accomplished, an object-oriented program focuses first on a program's data, defining classes of data and objects, where an object is a particular instance of a class. An object-oriented program still contains instructions, referred to as methods, which often are embedded within the classes or objects themselves. An example of a simple object oriented program that displays the volume of two boxes might look like this:",{"@attributes":{"id":"p-0019","num":"0018"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Box {"]},{"entry":[{},"\u2003\u2003\u2003double width;"]},{"entry":[{},"\u2003\u2003\u2003double height;"]},{"entry":[{},"\u2003\u2003\u2003double depth;"]},{"entry":[{},"\u2003\u2003\u2003\/\/ display volume of a box"]},{"entry":[{},"\u2003\u2003\u2003void volume ( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003System.out.print (\u201cVolume is \u201d);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003System.out.println (width*height*depth);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"class BoxDemo {"]},{"entry":[{},"\u2003\u2003\u2003public static void main (String args[ ] {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Box mybox1 = new Box ( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Box mybox2 = new Box ( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ assign values to mybox 1's variables"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003mybox1.width = 3"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003mybox1.height = 20"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003mybox1.depth = 15"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ assign values to mybox2's variables"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003mybox 2.width = 3"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003mybox2.height = 6"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003mybox2.depth = 9"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ display volume of mybox1"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003mybox1.volume ( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ display volume of mybox2"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003mybox2.volume ( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this example program, a box class is first defined having the variables of width, height, and depth (the term \u201cdouble\u201d identifies the type of number that the variable is allowed to be). The box class also defines a method to display the volume of an object box of this class by multiplying width by height by depth. Once this class has been defined, the program defines a second class BoxDemo which includes two objects of the initial box class. The class BoxDemo then twice calls the method of the first box class for displaying the volume of a box, once to display the volume of mybox 1 and once to display the volume of mybox2.","Object oriented programming has quickly gained widespread popularity. One particularly popular object oriented language is called JAVA, which is the programming language used in the foregoing example. JAVA is a registered trademark of Sun Microsystems Inc. The reason the JAVA programming language has become so popular is its versatility in defining classes and objects, as well as its ability for one class or object to call functions in other classes and objects as well as to reuse data in other objects simply by referencing the function or the data. In the JAVA language, therefore, it is very easy to create multiple variations of a defined class, to create new variations of an old class, and to reuse a method previously defined by one class in a new class. Parenthetically, another object oriented programming language that has become popular is C++, which expands C to include the functionality of both object oriented programming and the instruction oriented programming of C.","The JAVA language, like any other programming language relies upon an interface to convert the program to the required binary instructions. With the JAVA programming language, this interface is called a \u201cVirtual Machine\u201d (VM) because the interface behaves as if it were a computer unto itself. Every time a JAVA language based computer application is initiated, the application initiates a VM to run the application. The JAVA virtual machine (VM) will be described in much greater detail later in this specification, but several important principles will be introduced now. First, while the input to a JAVA VM is always the JAVA programming language, the output of a JAVA VM is customized to the particular platform, or operating system, that hosts the JAVA VM. In other words, every JAVA application must be customized to the host operating system so that the VM that it creates is capable of converting the JAVA programming language to the commands unique to the host operating system, which in turn issues the appropriate binary instructions to the computer.","Second, JAVA VMs are designed to be independent of one another. If two JAVA applications are running on the same computer, each application creates its own VM which is self sufficient, i.e. neither VM needs rely upon the VM of the other application. If one application should close, the other application will not be affected. This often becomes problematical, however. Recall that even with today's processors and storage devices, a computer's resources may still be strained by intensive applications. With multiple JAVA applications running simultaneously, each creating its own VM, system resources may be strained and slowdowns may result. In other words, there is often a trade off between the desired independence of multiple JAVA applications and the speed at which the applications may run.","Third, the creators of the JAVA VM, Sun Microsystems, emphasized uniformity of the JAVA VM with respect to all of the host operating systems. Thus, while the \u201cguts\u201d of each VM will of necessity be different across each platform, a user of a JAVA VM was not intended to be able to recognize any difference, seeing the same functionality regardless of the host platform. This, however, became problematical. Many operating systems offer unique features not available to other operating systems. Thus a business operating on the WINDOWS NT operating system might desire to have a JAVA VM, and hence the JAVA application running the VM, take advantage of that unique functionality. The same would hold true for a user of a system with a MAC OS, LINUX, WINDOWS 9\u00d7 or other operating system. Therefore, although Sun Microsystems' JAVA VM is uniform across all platforms, an industry has blossomed by which JAVA applications may be truly customized to a host operating system whereby the features of the host operating system are more fully exploited, and custom tailored to the particular needs of the business or person running the application.","This diversity among JAVA VMs tends to hinder the improvement of the JAVA VM and the programming language because many such improvements are tied to the particular species of JAVA VM upon which the improvement was developed. Many businesses may like the particular improvement, but dislike other aspects of the JAVA VM. In that instance, a business with its own custom or proprietary VM would have the options of buying the new VM with its perceived advantages and faults, or spend the time and resources to engineer its own VM, which it likes, to include the new improvement. Exacerbating this problem is that the new improvement may be proprietary, thus eliminating the second option.","What is desired then, is an improved system for implementing object-oriented computer applications that both efficiently allocates computer hardware resources among multiple computer applications running simultaneously on the same computer or network of computers, or among multiple threads of a single computer application running on a computer or network of computers, while also preserving the independence of multiple, simultaneous applications. What is further desired is such an improved system that is sufficiently flexible so as to be compatible not only with the diverse range of existing object-oriented computer applications, but also with object-oriented applications that are developed or modified in the future.","A computer system for concurrent operation of plural applications is disclosed comprising a memory, including a shared object space; a shared object stored in the shared object space and accessible to at least two applications so that at least a first application running in a first virtual machine is capable of causing an event in the shared object; and a listener stored in the shared object space, attached to the shared object and operably associated with a second application running in a second virtual machine. The listener listens for the event and notifies the second application when the first application has caused the event.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIGS. 1-4B","FIGS. 1-4B","FIG. 1","FIG. 1"],"b":["10","12","10","16","18","16","10"]},"Specifically, the class loader  may comprise a system class loader and one or more user-defined class loaders. The system class loader is a part of the JAVA VM implementation and loads classes, including the JAVA application programming interface (API) class files , in some default way and usually from the local disk of the host computer. As previously stated, the particular default manner in which the system class loader loads classes is specific to the particular VM implementation being used and may be customized. The term \u201csystem class loader\u201d is sometimes referred to as a \u201cprimordial class loader\u201d, a \u201cbootstrap class loader\u201d, or a \u201cdefault class loader.\u201d","At run time, a JAVA application may also load application class files  in custom ways through user-defined class loaders, such as by downloading class files across a network. While the system class loader is an intrinsic part of the VM implementation, the user-defined class loaders are not. Instead, user-defined class loaders are written in the JAVA programming language, compiled to class files, loaded into the virtual machine, and instantiated just like any other object, becoming a part of the executable code of a running JAVA application. User defined class loaders enable a programmer to dynamically extend a JAVA application at run time. As the application runs, it can determine what extra classes are needed and load them through one or more user-defined class loaders. Because the user defined class loaders are written in the JAVA language, classes can be loaded in any manner expressible in the JAVA programming language.","For each class loaded by the virtual machine , the virtual machine  records which class loader loaded the class. When a loaded class refers to another class, the virtual machine  requests the referenced class from the same class loader that originally loaded the referencing class. For example, if the virtual machine  loads the class \u201cVolcano\u201d through a particular class loader, it will attempt to load any classes to which Volcano referred with the same class loader. In this way, the architecture of the JAVA language enables a programmer to create multiple \u201cname spaces\u201d inside a single JAVA application. Each class loader in the executing JAVA application has its own name space, which is populated by the names of all the classes it has loaded.","The execution engine  executes instructions contained in the methods of loaded classes in \u201cbytecode\u201d, essentially JAVA machine language. The JAVA language specification describes what is to result from a given instruction retrieved from a JAVA method, but a programmer of a JAVA application determines the best way of achieving the result using software, hardware, or a combination of both. The execution engine  is an abstraction; JAVA is a programming language capable of simultaneously running multiple threads, i.e. distinct paths of execution, hence the execution of each thread can be considered an \u201cinstance\u201d of the abstract execution engine . Thus at any given time, there may be multiple \u201cinstances\u201d of the execution engine .","The execution engine  receives a bytecode stream of instructions in a thread and executes the thread one instruction at a time. The execution engine  executes the actions requested by each thread, and whenever intended by the JAVA application, sends instructions to the operating system in the code that the operating system recognizes. From time to time, the execution engine  might encounter an instruction that requests a method written in some other language than the JAVA language, referred to as a \u201cnative method.\u201d On such occasions, the execution engine  will attempt to invoke that native method by accessing native method libraries  through a native method interface  (shown in ). When the native method returns, the execution engine  will continue executing the next instruction in the bytecode stream.","When the JAVA virtual machine  runs an application, it needs memory to store many items, including information it extracts from class files, objects that the program instantiates, parameters to methods, return values, local variables, and intermediate results of computations. The JAVA VM  organizes the memory it needs to execute a program into several runtime data areas, depicted in . These runtime areas may include a method area , a heap , one or more JAVA stacks , one or more program counter (PC) registers , and one or more native method stacks . Although the same runtime data areas exist in some form in every JAVA VM implementation, the structural details of these areas are left to the designers of the VM and may therefore vary considerably from one JAVA application to another.","Each instance of a JAVA VM  has one method area  and one heap . These areas are shared by all threads running inside the VM . As each thread comes into existence, it receives its own PC register  and JAVA stack . When the VM  runs a method contained in a thread, several things happen. First, the value of the PC register is used to tell the next instruction in the method's sequence to execute. Second, the thread's JAVA stack  stores the state of each executing JAVA method in a stack frame, which includes the thread's local variables, the parameters with which it was invoked, its return value if any, and intermediate calculations. When the VM  has invoked a method in a thread and that method subsequently completes, the VM  discards the stack frame for that method from the JAVA stack . The state of native method invocations is stored in the native method stack  in a manner dictated by the designer of the JAVA VM .","Information about loaded data types are parsed from class files as they are loaded and stored in the method area . A data type refers to the format in which the data is expressed, e.g. an integer, a float, etc. A data type could also be an address of an op code within a method or a reference to an object on the heap . The VM  uses the type information stored in the method area  as it executes the application it is running.","For each data type the VM  loads, it should store the following kinds of information in the method area: (1) the fully qualified name of the type; (2) the fully qualified name of the type's superclass; (3) whether or not the type is a class or an interface; (4) the type's modifiers; (5) an ordered list of the fully qualified names of any direct superinterfaces; (6) the constant pool for the type; (7) field information; (8) method information; (9) all class variables declared in the type except constants; (10) a reference to class CLASSLOADER; and (11) a reference to class CLASS. Each of these kinds of information is well known to those in the art who design JAVA virtual machines and program in the JAVA programming language.","Referring to , whenever an object  is created by a JAVA application, memory for the new object  is stored in the heap . Because there is only one heap  inside of any instance of a JAVA VM , all threads share the heap  and because each JAVA application runs inside its own JAVA VM , there is a separate heap  for every JAVA application running. In this manner, one JAVA application cannot affect the objects  in the heap  of another application. Two different threads  and  of the same application, however, could affect each other's heap data, i.e. the objects . For this reason, synchronization of the access to objects of multiple threads must be planned.","The existing JAVA VM , as illustrated in  has several disadvantages. First, it is inherently redundant. Referring to , a single computer  when running multiple JAVA applications (or other applications that run in a VM) typically creates a separate VM for each application. Each VM, in turn, generates its own method area, heap, PC register, etc., using a good deal of the resources of the underlying computer. This is true even when each VM is running a separate instance of the same application where many of the objects created by the application will be identical. This is illustrated in  where three computers , , and  are running the same application  through a server . In this instance, many of the runtime data areas may be located on the server , creating the same kind of redundancy as seen in .","The redundancy of existing VM systems translates to a loss in system speed for two reasons. First, each VM must use its own resources, i.e. time, to load objects already loaded in other applications. Second, the combined memory space of all VM applications often bottlenecks system resources. In many cases, the speed at which an application or series of simultaneously running applications may operate defines the upper limit of a system's performance\u2014the number of trades processed, web pages served, or billing records updated per second. In other words, the speed at which individually well-tuned processes can operate determines how much value that system can provide on a second-to second basis, i.e. lost system speed means lost revenue.","The existing wisdom is that the redundancy and the associated loss of speed that results from designing every VM application to run in its own isolated VM  is a small price in exchange for the assurance that one application cannot change or otherwise corrupt the data being used by another application. In addition, the isolation of applications each within its separate VM ensures that if one application should close, or suddenly crash, the other applications would remain unaffected. The present inventors, though, came to the realization that there are a variety of applications in which the sharing of data across applications might actually be beneficial. In those instances, the redundancy of the existing system for running VM applications and the associated loss of system speed would be needless.","With this in mind,  shows an improved system for running VM applications, which broadly stated may comprise a shared object space  and a native access layer  operably connectable with a plurality of application programming interfaces (API) ,  of independent VMs, for example VM , or other applications such as the C\/C++ application . The access layer  permits each application , , through its associated, API ,  to load objects  into the shared object space  where the objects  may be read and\/or modified by the particular applications , . Although in some instances, the individual applications may duplicate some of the objects  stored in the shared object space  within its own respective heap or other memory area, the shared object space  permits an application to store an object  in the shared object space  instead of its own heap or other memory area, thus avoiding the redundancy of existing VM systems. Access to the objects  in the shared object space  may be synchronized for controlling access to shared objects in a heap by multiple concurrently running threads. Further, the shared object space  will store an object  so long as a thread of any connected application is using the object . In this manner, even if the application that placed a particular object in the shared object space  closes or crashes, that object will still be available to other applications as necessary. Thus the shared object space  permits multiple applications running simultaneously on a system or network to enjoy the stability of existing VM systems, while providing a substantial boost in performance.","The shared object space  is accessible to an application through the native access layer . Thus a JAVA application or other object oriented application will recognize the shared object space  as simply another resource accessible through the native methods interface that already exists in JAVA applications and other object-oriented applications. Once accessed, all the functionality of the shared object space  will be instantly accessible to the connected application. Further, the shared object space  does not need to be tied to a particular VM, but instead is backwards compatible with any individual VM, whether it is a standard JAVA VM provided by Sun Microsystems or a customized VM of a particular business, and forwardly compatible with any VM including improvements that have yet to be developed. Thus the versatility of the shared object space  can not be overstated. The versatility of the shared object space  is furthered by its compatibility with a wide variety of application interfaces. As can be seen in , the native access layer  provides access to the shared object space  by both JAVA applications and C or C++ applications. It should be understood that these examples are illustrative only, and that the native access layer  could provide access to the shared object space  by a number of other application types, whether object-oriented like JAVA applications or command oriented like C or C++.","The advantages of the shared object space  are readily apparent, particularly with respect to applications that benefit from the ability of multiple, simultaneously running applications to update a shared object rather than simply read or copy a shared object. One such application might be online trading. As the popularity of online trading increases, trading exchanges are faced with ever-growing volumes of market data and concurrent trader activity. Systems that were built to handle moderate volumes now have to handle thousands of traders and billions of dollars in daily transactions. Such systems have to accommodate huge spikes in demand. For instance, a single trade may require thousands of traders to be notified. Many traders watch for these price changes, then jump in to sell or buy very quickly, causing even more notification demand and more trading volume. The faster a trading system reacts to changes, the more transactions an exchange can execute, increasing its commissions while maximizing trader satisfaction with the service.","Another example of the utility of the shared object space  might be its potential in improving speed of computerized activity in the telecommunications industry. Modern telecommunication networks have to process vast amounts of data very quickly. Every time a call is placed, for example, an application needs to access the customer's subscription information, apply any special discounts that may be applicable, monitor the call duration and establish a rate based on the time and distance to the terminating number. Given that the number of such calls can run into the thousands at any given moment, a memory based data sharing facility is a necessity. In the past, such telecommunications applications have been written from scratch in C at enormous expense. The availability of an off-the-shelf shared memory component that provides a shared object space  makes it possible to write such systems in the JAVA programming language or another object-oriented language more quickly, cheaply, and with less risk.","Yet another example of the utility of the shared object space  is its potential use in large scale internet applications. Large internet content syndication and portal applications depend on fast caching for scalability. The shared object space  provides an ideal caching facility for HYPERTEXT MARKUP LANGUAGE (HTML) and EXTENSIBLE MARKUP LANGUAGE (XML) program fragments, XML DOCUMENT OBJECT MODEL (DOM) program interfaces and streams, HYPERTEXT TRANSFER PROTOCOL (HTTP) session information, and JAVA Database Connectivity (JDBC) query results. It can also hold very fast page request queues and other operational data structures. The shared object space  may include multi-language support which may be exploited when connected to web servers, servlet engines, content management suites, and XML transcoders to speed up every phase of a sites operation.","In use, the shared object space  may be one element in a larger computing system . Specifically, it is anticipated that the shared object space , along with its associated native access layer  may be used in conjunction with a console , an administrative processor , disk storage  and a display  suitable for displaying system statistics. The console  is used to configure and start the system  which may comprise a system manager , the shared object space , and the native access layer . The system manager  creates and initializes the shared object space , collects garbage, gathers statistics, and logs both system and user-defined events. Once the system  has been started, the system manager  can also be used to browse the shared object space , enable statistics collection from individual objects, and display the statistics graphically for analysis.","The system  is preferably stored on a disk  in a default directory, e.g. \u201cdefaultSystem\u201d, that holds the system's configuration file and log file. The system  may be included on an executable storage media such as a compact disk that include an installation tool that may be used to create the requisite directories on the disk . Additional custom system directories may also be installed on the same disk  as desired. Preferably, the system  includes a number of default tools that operate on the default system; however the console  and a command line utility may allow the user to specify a different system.","To make use of the system  and its shared object space , the system  includes a library file in the default directory. JAVA applications should include a reference to this library (e.g. productdir\/lib\/gemfire.jar) on its CLASSPATH. On systems utilizing the WINDOWS operating system, the library may be made available by adding productDir\/bin to PATH and on systems having the Solaris operating system, the library can be made available by adding productDir\/lib to LD_LIBRARY_PATH. An application process connects to the system  by making a call that contacts the system manager , such as GemFireConnection.myConn=GemFireConnection.getinstance (\u201cGemfire\u201d). The system manager  then returns information that enables the application process to map the shared object space  into its address space.","Each system  preferably maintains a global name space  in the shared object space . The name space  provides a fast object registry in which applications can register and look up \u201croot\u201d objects by name. Objects that are referenced from this name space are protected from garbage collection. Once connected to the system , an application can look up shared objects in the name space  with a command such as\n\n","The system  may include a Class Enhance tool that prepares an application class for sharing by modifying the class's bytecodes to provide transparent instantiation in shared memory and automatic read-through and write-through for field access methods. By default, all fields may be shared, but a user may establish more selective policies by providing an XML description of the fields to be shared in each domain class. Once a class is enhanced, making an object of that class automatically puts the object into shared memory.","Referring to , the system  may support two methods of sharing objects, copy sharing and direct sharing. An object  that is copy shared is allocated twice, once in the local memory of an application and again in shared memory .  shows an example of a copy sharing method where application A creates an object  in its local address space. The object  is shared by putting it into the shared name space . At this point, the object  is not immediately written to a field in the shared object space ; instead the object  is written to shared memory  only after a user \u201cflushes\u201d, i.e. updates the object to a new version, for the first time. Once an object  is written to shared memory, application B is able to copy the object  to its local memory by accessing the shared object  by name in the shared name space . Application B may modify the copy of the object  obtained from shared memory, and may also flush to update the shared memory copy of the object. If application B wishes to see the most recently updated version of the object , a refresh command may be used.",{"@attributes":{"id":"p-0066","num":"0069"},"figref":"FIG. 7","b":["128","128","100"]},{"@attributes":{"id":"p-0067","num":"0070"},"figref":"FIG. 8","b":["201","200","202","202","200","204","206","201","200","100"]},{"@attributes":{"id":"p-0068","num":"0071"},"figref":"FIG. 9","b":["301","300","302","304","306","308","304","306","308","302","302","304","306","308"]},"As stated previously, when multiple threads from multiple applications are sharing objects in a shared object space, access to the objects should be synchronized.  illustrates this necessity. In this figure, application  is running in a VM  while application  is running in another VM . Both VM  and VM  are sharing the shared object space  that is storing a shared object . In this figure, application  is simultaneously running two threads, thread  and thread , both of which are calling shared object . At the same time, application  is running a thread  which also is calling the shared object . Absent synchronization, each thread , , and  could all access the shared object and make simultaneous, possibly conflicting changes to the object  without any knowledge of each other's changes.","Also, as stated previously, existing methods provide for synchronization of multiple threads in a single application accessing a shared object in a single VM. Extended synchronization techniques, as described herein, may be used to provide synchronization for concurrent access to objects in shared memory by multiple applications illustrated in .","In , a shared object space  stores objects O, P, Q, and R. Each of these objects includes an object header . Each object header  may include a lock info field  which is used to indicate whether a thread of an application has locked that object. The lock info field  may contain either a \u201ccheap lock\u201d or a reference to a \u201clock node\u201d, i.e. an \u201cexpensive lock.\u201d A \u201ccheap lock\u201d directly encodes the identity of the application and the thread that owns the lock by inserting a value into the lock info field  unique to the thread of that application. (The value \u201c0\u201d may be used to indicate that an object is not locked by any thread of any application.) When thread A of application  seeks to acquire object O, for example, thread A checks the header of object O to test whether the value in the lock info field  is \u201c0\u201d, representing that it is not locked. If the value is \u201c0\u201d then thread A  substitutes its unique number in the header of object O and acquires the lock with a \u201ccheap lock.\u201d","This compare and swap informs subsequent threads that wish to acquire object O that the object is \u201clocked\u201d and these threads will wait. This compare and swap is preferably \u201catomic\u201d in nature, meaning that the issued command(s) is performed in such a manner that there is no potential for another thread or otherwise to lock the object in the interim, especially when the command is executed by the processor. In many cases, the swap is performed in a manner internal to the microprocessor, and is accordingly a very efficient mechanism. For example, if thread B  of application  seeks to acquire the object O while thread A  already has it, thread B will test to see whether the lock info field  is \u201c0\u201d. The test will fail and thread B will recognize that thread A has the object because of the number in the header. At this point, thread B does several things. Thread B makes two entries in a lock table  called \u201clock nodes\u201d  and . The lock node  is unique to thread A and the lock node  is unique to thread B. Also, thread B updates the \u201ccheap lock\u201d of the lock info field  to an \u201cexpensive lock\u201d that contains a reference to the lock node  in the lock table . Thread B then goes to sleep waiting on its lock node . When thread A is finished it notifies the lock manager  which removes the lock node  from the lock table and swap's B's \u201cexpensive lock\u201d. i.e. a reference to the lock node , into the lock info field  of the object's header. Thread B thereby gains control of the object.","A lock node, such as  and , is an internal object, not visible to the application. When a lock node is created, it is added to the lock table . If a thread of an application wanting to acquire the lock must wait for another thread to release the lock, it waits on the unique lock node object representing its lock request. The lock table  holds instances of lock nodes. A given lock node in the table represents either a thread that currently holds a lock or a thread that is waiting to acquire a lock. The lock node contains information pertaining to the virtual machine that has or wants the object, as applicable, the thread that has or wants the object, as applicable, and the object had or wanted, as applicable. When the lock manager  successfully grants a lock to a thread by setting the target object's lock info field  to be a reference to the lock node representing the waiting thread, using the compare and swap technique, it signals the lock node. The waiting thread then gets the object and proceeds.","All of the aforementioned activities of thread B occur without any effect on thread A. Stated differently, thread A is unaware of anything that B is doing and hence is not slowed down by thread B's activities. When thread A is finished and seeks to release the lock on object O, it will check the lock node  and see that there are one or more threads waiting for access to the object O. A first assumes that the lock is still a \u201ccheap lock\u201d and does a compare and swap. If the lock has been updated to an expensive lock, its value is no longer in the lock info field, so the test and swap will fail. In that case, two implementations might occur.","In the first implementation, the object's lock info field is set to \u201c0\u201d and the lock manager is signaled that there may be another lock node in the lock table that can be granted the lock. (This is generally faster for the application thread). The lock manager  will then consult the lock table to see which thread has priority, in this case thread B, and therefore grant thread B access to object O, at which point thread B's \u201cexpensive lock\u201d will be inserted in the header of object O, etc. The second implementation is that the thread, i.e. A, does the work of determining the next owner of the lock and atomically changes the object's lock info field  from a reference to its lock node to a referenced to the next owner's lock node. This eliminates the need for a lock manager, at the expense of making the application slower.","The following is an example of a JAVA program fragment that might be used to invoke the procedures described above:",{"@attributes":{"id":"p-0077","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Lockservice.synchronize ("]},{"entry":[{},"\u2003\u2003\u2003anObject,new Runnable ( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Lockservice.notify (anObject);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Lockservice.wait (anobject);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following is an example of a C fragment that may be used to invoke the procedures described above:\n\n","The foregoing example illustrated the process that would occur if two threads were contending for access to the same object. Obviously there may be quite a few threads seeking access to an object simultaneously, and in that event the foregoing procedure will control the priority of access in an orderly fashion through the lock table  which records the relative priority of access to an object between multiple threads. In the foregoing example, access to an object by multiple threads is granted in order of the requests, i.e. first come, first served. Other systems may be used. For example, some systems may provide for threads to be indicated as priority threads whose function is of some critical importance, and their place in the lock table accordingly bumped up. In some cases there is no guarantee to priority of access, so that if threads B. C. and D all try to obtain a lock while thread A has it, thread B may not be next in line even if it were the first to try to obtain the lock with respect to threads C and D.","The advantage of the foregoing system is a considerable boost in speed. For example, when there is no contention for an object at the time a thread is trying to acquire it, the object may be obtained by a thread in as little as 10 microseconds. Where there is contention, however, it may take more than 100 microseconds to acquire the object after it has been released. Thus the ability to quickly detect whether or not there is contention for an object permits a thread to acquire the object by the quicker method.",{"@attributes":{"id":"p-0081","num":"0087"},"figref":"FIG. 10B","b":"332"},"Many processes or threads in an application are contingent upon the occurrence of an event. For example, when a user of a word processing program presses a font button, such as an italics button, the application must respond appropriately. When an online buyer clicks a \u201cproceed to checkout\u201d button or an \u201center\u201d button after typing in a credit card number for a purchase, the web server must respond appropriately by either loading another screen, verifying the credit card account information, etc. In each of these instances, the event that triggers the response is uncertain, i.e. it may or may not occur. To handle these contingencies, many object oriented programs use \u201clisteners\u201d, which are defined as objects that are notified when an event has occurred. There exist many types of listeners, such as an ActionListener (which defines a method to receive an action event), a ContainerListener (which defines two methods to recognize when a component is added to or removed from a container), a KeyListener (which defines three methods to recognize when a key is pressed, released, or typed), and a WindowListener (which defines seven methods to recognize when a window is activated, closed, deactivated, deiconified, iconified, opened, or quit). This list is not exhaustive as there are several other predefined types of listeners, and others may be customized as the need arises by using the EventObject utility to define a desired event that is to be listened for.","To attach a listener to an object, that object registers a listener with a command of the general form\n\n","Listeners consume a relatively large amount of system resources, and the use of multiple listeners in a computing system tends to slow the system down. For that reason, it is often desirable to program an application using as few listeners as possible while still achieving the functions of the application","Referring to , the shared object space  permits multiple applications, such as , , , and  to each listen for an event in a shared object such as  in a highly efficient manner by placing listeners  and  into the shared object space  as well as the object . For example, Applications , , and  may each be programmed to listen for the same event in object . In the system depicted in , each of these applications , , and  need not create its own separate listener, but instead may share a single listener. In addition, a single application, such as application , may have more than one listener, such as  and  attached to the shared object . Thus a system in which listeners are shared by multiple applications improves over existing systems by utilizing less system resources and increasing the speed at which the multiple applications may operate.","It should be understood that other implementations of shared listeners may have each listener associated with only one application running in a single virtual machine, such as that shown in . Referring to this figure, listeners are a common pattern implemented by an application with two main roles involved\u2014an event producer and an event listener. The event producer typically holds a set of listeners and provides a method such as addListener( ) where the listener is an object that implements an application-defined listener interface. The listener typically either implements this interface directly, or with an anonymous inner class.","In the situation where a listener is implemented in an application running in its own VM, with no shared object memory, this common pattern requires no special language support. When an event is produced, the event producer simply iterates over its collection of listeners and invokes the appropriate method in each one. For example, assume that a single VM has a listener where TradeFloor is the event producer, which invokes the listener's stockOffered( ) method, as defined by a listener interface OfferListener. Trader is the listener\u2014it implements and listens for stockOffered( ) using the following code:",{"@attributes":{"id":"p-0088","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class TradeFloor {"]},{"entry":[{},"\u2003\u2003\u2003Collection listeners = new ArrayList( );"]},{"entry":[{},"\u2003\u2003\u2003public void addOfferListener( OfferListener listener ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003listeners.add(listener);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\/\/ Stock is being offered"]},{"entry":[{},"\u2003\u2003\u2003Iterator listenersIterator = listeners.iterator( );"]},{"entry":[{},"\u2003\u2003\u2003while (listenersIterator.hasNext( )) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003((OfferListener)listenersIterator.next( ))."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003stockOffered( ticker, price );"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},"public class Trader {"]},{"entry":[{},"\u2002TradeFloor floor = TradeFloor.getInstance( );"]},{"entry":[{},"\u2002public Trader( ) {"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003\u2003\u2003floor.addOfferListener( new OfferListener( ) {"]},{"entry":[{},"\u2003\u2003\u2003public void stockOffered( String ticker, int price ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2002\/\/ Just got notified that stock is offered"]},{"entry":[{},"\u2003\u2003\u2003<do stuff>"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"});"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"When the TradeFloor is instantiated, it initializes listeners to be an empty ArrayList. When a Trader is instantiated, it looks up the singleton instance of TradeFloor and adds itself as a listener (using an inner class). When the TradeFloor has a stock offered, it iterates over its listeners to send stockOffered( ). This invokes code in class Trader.","In the system shown in , however, the event may occur in a different VM from where a listener was registered, which precludes a simple method invocation from the event producer to the listener. The foregoing code should therefore be changed to provide a mechanism that allows applications to implement the listener pattern such that the code that produces the event (in this case, the TradeFloor) executes in one VM, and listeners can be invoked in one or more other VMs. For example, the line \u201cCollection listeners=new ArrayList( )\u201d in the foregoing one-VM example could be changed to \u201cCollection listeners=new SharedListenerList( )\u201d to provide the desired functionality. In this multi-VM example, the SharedListenerList (which is a shared object) should be the same shared object across all VMs. This usually occurs naturally by having the object that holds it be a common shared object. TradeFloor, for instance is a shared object, and its instance variable listeners are part of its shared state. All uses of the shared instance of TradeFloor will share the same listeners. TradeFloor.getInstance( ) performs a lookup in the shared namespace. Further, the classes that define the listener interface(s), listener method argument types, return values and exceptions must be loadable across all participating VMs.","The systems shown in  permit a listener to distinguish not only when an event occurs in object R, but also what particular application caused that event. Because any given application, such as , , , and  may access an object, such as object R  for instance, by swapping into the object header's lock info field  a value unique to that particular application, the listener may include code that allows it to identify the particular application that caused the event that it is listening for. Because the lock info field  may be any desired bit length, the system of  can accommodate any desired number of applications, each of which can then be individually identified by the listeners such as  and  when causing an event. In order to implement this feature in the manner just described, the listener's code could be customized in a variety of ways. The listener could be modified to listen for an event defined as the conjunction of the event or events typically associated with that listener (e.g. the depression of a key for a KeyListener) and any change in the lock info field  so that any time a key is depressed, the listener detects the event and notes the application that caused the event. Alternatively, if the value of the lock info field  is known for each of the applications permitted to access the shared object space , then the listener may be modified to listen for an event defined as the conjunction of the event or events typically associated with that listener (e.g. the depression of a key for a KeyListener) and the change in the lock indicator value  to a specific identifier in order to listen for an event taken by a specific application.","Many other modifications to the code of a listener are available to the programmer to permit the association of an event with the application (or possibly applications) that caused the event. For example, if the programmer has the ability to modify the code of the applications accessing the shared object space , another method may be to simply require the applications to include an identifier in the argument of the change they make to the object, such as , and customize the listener to include that value in its argument once it detects that the event it is listening for has taken place.","Whatever particular modification is chosen by the programmer, the ability to associate an event with the application that caused that event may be of considerable advantage. For example, this feature could be used to collect statistics as to activities of all applications using the shared object space . Alternatively, where desired, the response of one particular application may be keyed to a particular action taken by another application, or one of a subset of the total number of applications using the shared object space .","The terms and expressions that have been employed in the foregoing specification are used therein as terms of description and not of limitation, and there is no intention, in the use of such terms and expressions, of excluding equivalents of the features shown and described or portions thereof, it being recognized that the scope of the invention is defined and limited only the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIGS. 10A and 10B"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
