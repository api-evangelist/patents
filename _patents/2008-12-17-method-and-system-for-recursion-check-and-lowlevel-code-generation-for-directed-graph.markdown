---
title: Method and system for recursion check and low-level code generation for directed graph
abstract: A method and a system for fast recursion check and low-level code generation for directed graph. In a directed graph each vertex is connected to at least one other vertex with a directed edge to form an ordered pair of a source vertex and a target vertex. Low-level codes are assigned to the vertices of the directed graph, where for each ordered pair the low-level code of the target vertex is bigger than the low-level code of the source vertex. A new edge is added to connect a first vertex and a second vertex of the graph, where the first vertex is the source vertex and the second vertex is the target vertex of the new ordered pair. The low-level code of the target vertex of the new ordered pair is not bigger than the low-level code of the source vertex. For the new ordered pair and all ordered pairs that descend from the new ordered pair, the low-level codes of the target nodes are changed to values bigger than the low-level codes of the corresponding source vertices, when necessary.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08275645&OS=08275645&RS=08275645
owner: SAP AG
number: 08275645
owner_city: Walldorf
owner_country: DE
publication_date: 20081217
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The field of the invention relates generally to electronic data processing and more particularly to recursion check and low-level code generation for directed graphs in enterprise computer systems.","With the beginning of its development, computer technology broadly implements graph theory. Every computer network could be viewed as a graph with certain properties including a plurality of computer devices as nodes. In software applications, graph theory provides various algorithms for data processing. The automation of an increasing number of business processes is one of the most challenging areas for the development of computer technology. In this field, graph theory helps with efficient solutions of numerous problems.","For example, bill of materials (BOM) is commonly used by manufacturers to describe raw materials, sub-assemblies, intermediate assemblies, sub-components, components and parts, and the quantities of each needed to manufacture a final product. BOMs are exchanged between manufacturers and suppliers and are used for planning and controlling the process of producing final product. In general, BOMs could be described as a directed acyclic graph with the final product as a root vertex, and a plurality of leaf vertices representing the raw materials or components necessary to produce the final product.","To each vertex or component in a BOM directed graph could be assigned a low-level code, e.g., a number, to facilitate the material requirements planning. When a bill of materials is changed, it has to be checked if BOM recursion occurs. Further, the low-level codes need to be recalculated when the added vertices and edges violate the previously established order. This is important in order to keep a consistent relationships between the materials. For large and complex BOMs, these tasks are time consuming for the currently applied algorithms, and may lead to system performance problems.","There are other business applications that apply the same concept of directed graphs with assigned low-level codes to the nodes. In addition to BOM relations, a directed graph could contain edges that represent material or component replacement, material transportation from one site to another, etc.","A method and a system for fast recursion check and low-level code generation for directed graph are described. In a directed graph, each vertex of a set of vertices is connected to at least one other vertex with a directed edge to form an ordered pair of a source vertex and a target vertex. Low-level codes are assigned to the vertices of the directed graph, where for each ordered pair the low-level code of the target vertex is bigger than the low-level code of the source vertex. A new edge is added to connect a first vertex and a second vertex of the graph, where the first vertex is the source vertex and the second vertex is the target vertex of the new ordered pair. For the new ordered pair and all ordered pairs that are direct or indirect successors of the second vertex a topological sort is performed. During the sorting, for each ordered pair in the subgraph a new low-level code to a target vertex is assigned when an old low-level code of the target vertex is not greater than a low-level code of a corresponding source vertex, the new low level code is greater than the low-level code of the corresponding source vertex.","Bill of Materials (BOM), as well as a large number of other business objects and processes, may be efficiently represented by directed acyclic graphs or networks. In a directed graph, each vertex or node of a set of vertices is connected to at least one other node with a directed edge or arc. In a directed graph isolated vertices may also exist, then the set of vertices is a subset of all vertices of the directed graph. A directed arc flows out from a source node and goes to a target node. Every directed acyclic graph has one or more topological sorts. In graph theory, topological sorting or ordering means linear ordering of the vertices in which each vertex comes before all its target vertices within the ordering. A source vertex and a target vertex connected with a directed arc form an ordered pair. If there is at least one cycle, topological ordering is not possible.","In the BOM example, the vertices of the directed graph represent components necessary to build a particular product.  is block diagram  of a simplified BOM for manufacturing a kitchen chair. Node  represents the finished product and, in this example, is the root node of the directed graph of the BOM. The chair is built by three major components represented by nodes: seat , back support , and legs . These three major components are connected together with glue, node . Each major component comprises one or more lower level components represented by nodes cloth , foam , plywood , yarn , plastic , wood , cotton , and oil . A source component is produced by traversing the source components target or lower level components or ingredients.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1B","b":["150","153","155","157","159","161","163","165","167","169","171","173","175","177","152","154","156","158","160","162","164","166","168","170","172","174","176"]},"For example, low-level codes are required in material requirements planning (MRP) for managing manufacturing process. In general, an MRP creates requirement coverage elements, e.g production or purchase orders, for independent requirements, e.g. customer orders, and dependent requirements. A dependent requirement for product B is caused by a production order of product A if product B is a component that is needed to assemble product A. If the MRP run for multiple products and processes the products in a random order, it might happen that a product needs to be processed multiple times. For example, product B is processed before product A, but processing of product A creates a dependent requirement for product B, hence, product B needs to be processed again. This can be prevented by processing the products in the order of ascending low-level codes. In the example, product B has a higher low-level code than product A and product A is processed first.","Low-level codes may be unique when each node or vertex in the acyclic directed graph has its own low-level code. For some processes or tasks, it is not necessary to define unique level codes. In such a case, low-level codes provide information for the depth or the order of a material within a BOM. The non-unique low-level code may equal the longest path from the root to the particular node for a material. The low-level code for a root vertex is zero. The low-level code of a target node is always bigger than the low-level code of a source node. This requirement is referred to as a rule for any directed acyclic graph throughout this document, regardless if the low-level codes are unique or not. An ordered set of unique low-level codes assigned to the nodes of a directed acyclic graph correspond to a topological sort of the graph.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2A","b":["200","202","0","203","204","1","205","206","2","207","208","3","209","210","4","211","212","5","213"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":"V={A, B, C, D, E, F}\n\nThe illustrated edges or arcs identify set A:\n"}}}},"A={(A, B), (A, C), (B, D), (C, E), (C, F), (D, E), (D, F), (E, F)}","The assigned low-level codes define a topological order of the vertices.",{"@attributes":{"id":"p-0026","num":"0026"},"figref":"FIG. 2B","b":["220","220","200","230","224","230","224","230","231","224","225"],"br":[{},{}],"in-line-formulae":[{},{}]},"As  illustrates, the new ordered pair (E, B) creates a loop in graph . In such a case, it is not possible to order the vertices of graph  topologically, according to graph theory. If the low-level code of node B  is changed to 5 in tag  in order to be greater than the low-level code of node E , then the low-level code of node D  has to be changed to a value greater than the new low-level code of node B , as nodes B and D form an ordered pair in which D is the target node. For example, if the low-level code of node D  is changed to 6 in tag . For the same reason, the low-level code of node E has to be changed to a value bigger than the new low-level code of node D . This would lead to an endless loop of increasing the values of low-level codes of nodes E , B  and D  in tags ,  and . Thus, it is not possible to assign low-level codes to these vertices consistent with the rule as stated above.",{"@attributes":{"id":"p-0028","num":"0028"},"figref":"FIG. 2C","b":["240","240","200","248","246","248","246","240"]},"Using an alternative approach, only the existing low-level codes that conflict with the change are recalculated. The new arcs are examined for recursion and the conflicting low-level codes are recalculated. In a recursive routine, when the low-level code of a node is changed, the low-level code of one of its target nodes needs to be checked for a loop and for consistency with the rule (1(source)<1(target)). This process continues until there are no more detected violations of the rule or until a recursion is detected. While in the most cases this is more effective than reordering of the whole graph, there are situations in which this approach will need more than the linear time of the reordering process. For example, in a graph with n nodes and arcs (i, i+1) for all i=1, . . . , n\u22121 and (i, i+2) for all i=1, . . . , n\u22122; if the arcs are processed with descending source node id, this algorithm requires quadratic run time.","According to an embodiment of the present invention, a topological ordering in linear time is applied to a minimum set of nodes and arcs that potentially could violate the rule. This approach implements a process that guarantees linear running time over a subset of the entire graph. The implemented process determines a set of all nodes and arcs that are direct or indirect successors of the target nodes of those new arcs that violate the established rule. Referring back to , a set B is identified to include:\n\n","Set B defines a directed subgraph of graph . The low-level code of the target node of the new arc that conflicts with the established rule is changed to a higher value. As illustrated in , the low-level code of node C  is changed from 2 to 4 and the new code is stored in tag . Subgraph B is sorted topologically, assigning new low-level codes to the target nodes, to comply with the rule. The low-level code of node E  is changed from 4 to 5 and the new code is stored in tag  and the low-level code of node F  is changed from 5 to 6 and the new code is stored in tag . Thus, there is no need to reorder the entire graph . Also, the risk to check, and possibly change, the low-level code of a node more than once is avoided (e.g., to compare the low-level code of node F  with the low-level code of node C , and then with the low-level code of node E ).",{"@attributes":{"id":"p-0032","num":"0033"},"figref":"FIG. 3A","b":["300","300","300","302","0","303","304","1","305","306","308","2","307","309","310","312","314","3","311","314","315","316","318","4","317","319","321","5","321"]},{"@attributes":{"id":"p-0033","num":"0034"},"figref":["FIG. 3B","FIG. 3A"],"b":["330","330","300","330"],"br":[{},{}],"in-line-formulae":[{},{}]},"Because there are zero incoming edges, new vertex L  is assigned low-level code  and the code is stored in tag . New vertices K  and M  are assigned low-level code  and the code is stored in tags  and  respectively. This value is greater by a unit than the low-level codes assigned to their corresponding source nodes A  and L , which are stored in tags  and  respectively.","The new edges in graph  define new ordered pairs that need to be checked for consistency. If the low-level code of a target node violates the rule, its value is changed to be greater than the low-level code of the source node. A subgraph B is identified to include the violating target nodes of all new edges, together with all nodes and edges that are direct or indirect successors of the violating target nodes.","For graph  in , a new edge connects source node C  with target node D , and both nodes have low-level code , the code stored in tags  and  respectively. Node C  is a source vertex and node D  is a target vertex in the new ordered pair. To align the graph with the rule, the low-level code of node D  is changed to a greater value (e.g., to  as shown in tag ). Because node D  is an violating target node, subgraph B is identified including vertices D , E , F , G , H , I , J , N , and O . Further, subgraph B includes the following edges:\n\n","Subgraph B is sorted topologically and new low-level codes are assigned when needed. In subgraph B, node D  has zero in-degree and low-level code , the code stored in tag . According to one embodiment of the invention, for each ordered pair in directed subgraph B, the low-level code of the target vertex is compared with the low-level code of the source vertex. If not greater, the low-level code of the target vertex is recalculated to a unit greater than the low-level code of the source vertex. Thus, for ordered pairs (D, E), (D, F), and (D, G), low-level codes of nodes E , F  and G  are changed from 3 to 4 and the new codes are stored in tags , , and  respectively. For ordered pairs (F, H) and (G, N), the low-level codes of nodes H  and N  are recalculated to 5 and the new codes are stored in tags  and  respectively. Further, for ordered pairs (N, J) and (N, O), the low-level codes of nodes I  and O  are recalculated to 6 and the new codes are stored in tags  and  respectively. Finally, for ordered pair (I, J), the low-level code of node J  is recalculated from 5 to 7 and the new code is stored in tag , which is a unit greater than the low-level code of node I  as stored in tag .",{"@attributes":{"id":"p-0038","num":"0040"},"figref":"FIG. 4","b":["400","400","405"],"br":[{},{}],"in-line-formulae":[{},{}]},"At block , the directed graph is extended with one or more new vertices. At block , one or more new directed edges are added to the directed graph. Optionally, at block , low-level codes may be associated with the new vertices in compliance with the rule stated in the previous paragraph. In one embodiment of the invention, low level codes with zero value could be assigned to all new vertices at block . If the new edges connect vertices with already assigned low-level codes, occurrences of violations of the rule are possible. Therefore, according to one embodiment of the invention, at block , one of the new edges is selected. At block , the low-level codes of the vertices connected by the edge are checked whether they comply with the rule. If they do not comply, at block , the low-level code assigned to the target vertex is recalculated to a new value that is greater than one unit of the low-level code assigned to the source vertex. The target vertex with the recalculated low-level code is added to a set A at block .","Operations of blocks  to  are executed repeatedly for all new edges, until, at block , it is confirmed that all new edges are checked for compliance with the rule. At this point, set A contains all vertices with recalculated low-level codes. At block , the first part of the process ends. Referring back to , for directed graph , set A would contain vertex D , and, depending on whether and how low-level codes were assigned to the new vertices, vertex I .",{"@attributes":{"id":"p-0041","num":"0043"},"figref":"FIG. 5","b":["500","400","505","510","515","520","525","530"],"br":{},"in-line-formulae":[{},{}]},"At block , the selected edge is removed from subgraph B. The operations of blocks  through  are repeated for all outgoing edges from the vertex selected at block . At block , it is determined whether any more outgoing edges from this vertex are left. When all outgoing edges from the selected vertex are processed, the selected vertex itself is removed from subgraph B at block . The operations of blocks  through  are repeated until, at block , no more vertices are left in subgraph B. The process illustrated with flow chart  ends at block , according to one embodiment of the invention. At that point, all low-level codes in the directed graph are consistent with the rule. The process runs in linear time on a subset of the edges of the graph that includes the new edges and the successors of the infringing new edges. The process processes each edge of the subset only once. Thus, compared to the previous solutions, the process requires significantly on average less execution time.","The presented process could be implemented in various technical environments. According to one of the embodiments of the invention, the process is implemented in a computer system, as illustrated in .  is a block diagram of system  for extending an acyclic directed graph and recalculating a number of resulting inconsistent low-level codes. The system includes directed graph , network , and computer system . Directed graph  is shown in  as nodes A , B , C , D , E , F , G , and H . Directed graph  is defined by its edges:\n\n","Computer system  includes at least one application server . When computer system  has distributed architecture, it could comprise more than one application server  with similar structure. Application servers  could run as a cluster. The different tasks performed by computer system  are routed to a particular application server  by load balancer  in accordance with predefined criteria, not limited to the current load of each application server . Application servers  could store common data on separate storage .","Application server  could be built in compliance with any established standardized application server (AS) software technology; e.g., Java Enterprise Edition (Java EE) AS or the like. Application server  runs a variety of applications to perform different tasks for automating one or more processes. Here it is assumed that application server  runs an enterprise application, e.g., supply chain management (SCM) system, customer relationship management (CRM) system, human resource (HR) planning system, etc. Computer system  could be established to automate the overall information processing in an enterprise.","Application server  comprises container  where a number of objects  are running. Container  provides an executing environment for the various enterprise applications and its functionality depends from the AS software technology standard that is applied. Application objects  in this document also represent instances of application objects. The object itself is the structure of a program or business element. Application objects  or the instances of application objects  could represent elements of directed graph . Each object could have numerous instances that have the same structure, but different content. For example, the names, types and providers of all elements required for manufacturing of a specific product could be entered in matching number of instances of \u201celement\u201d object in a SCM system.","Each object  is characterized by a number of attributes  and executes a number of functions , both specific for the object. Attributes  contain data pertinent to the programming or business entity represented by the object. For each instance of the object, attributes  contain data describing that particular instance. For example, an \u201celement\u201d object could have attributes that describe the name of the element, its supplier, the type of the element, its quantity, the relations with other instances, the assigned low-level code, etc.","Further, application server  comprises processor  to execute logic  for defining and managing a plurality of application object instance among objects  based on the structure of directed graph . In one embodiment of the invention, processor  is running in the environment provided by container . Logic  could be coupled with functions  trough a specific container interface (not shown), an application programming interface (API), or other interface. When application server  receives data about directed graph , the appropriate application objects  are identified by logic  executed by processor . The received data is assigned to relevant objects  and kept in storage .","According to one embodiment of the invention, application server  builds a structure of application object instances  to resemble the structure of directed graph . This structure includes appointing an object or object instance from objects  corresponding to each element of directed graph  and defining relationships between these objects (object instances) corresponding to the edges of directed graph . Consequently, to each object or object instance corresponding to an element of directed graph  a low-level code is assigned to each node compliant with the rule\n\n1(source)<1(target).\n\nWhen a change is made to directed graph , it is reflected in application server  and low-level codes are recalculated by processor  applying logic , using the process illustrated in  and .\n","Application server  receives data about directed graph  at communicator . Communicator  could further carry on a number of other tasks. For example, communicator  could send requests to a third parties for additional data regarding components of directed graph  (the third parties are not shown). The data about directed graph  could be entered manually through means of a user interface provided by communicator . Alternatively, the data about directed graph  could be received at communicator  automatically through network .","Communicator  includes display module  to provide a graphical user interface (GUI) to the users of enterprise applications running on application server . Display module  renders, via the GUI, attributes  of application objects . Further, the graphical user interface could render the data received from directed graph . The GUI also allows the users to interact with the applications running on application server . Through the GUI, a user could access different functionalities provided by the applications. In the context of the current invention, for example, a user could search for data received from directed graph . Data could be entered and assigned to a particular object and assigned data could be reassigned to another application object . The user could navigate through the GUI by using hyperlinks, menus, or other means.","Display  provides, via the GUI, access to a set of functions or a tool for managing logic  for reacting on adding new edges to acyclic directed graph  and recalculating the resulting inconsistent low-level codes.","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however that the invention can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure or characteristic described in connection with the embodiment is included in at least embodiment of the invention. Thus, the appearance of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures or characteristics may be combined in any suitable manner in one or more embodiments."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained from the following detailed description in conjunction with the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
