---
title: System and method for establishing a shared secret for communication between different security domains
abstract: Embodiments may include generating an initial verifier for a first process, the initial verifier generated based on a trusted image of the first process. Embodiments may include, subsequent to generating an untransformed secret associated with the first process, using a reversible transform to transform the untransformed secret with the initial verifier to generate a transformed secret associated with the first process. Embodiments may also include, subsequent to the first process being launched outside of a secure domain, and dependent upon a second verifier generated from a current state of the first process being the same as the initial verifier: using the reversible transform to reverse transform the transformed secret with the second verifier to generate a de-transformed secret equal to the untransformed secret. Embodiments may include performing a secure communication protected with a cryptographic key generated based on the de-transformed secret. The communication may be performed across different security domains.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09367700&OS=09367700&RS=09367700
owner: Adobe Systems Incorporated
number: 09367700
owner_city: San Jose
owner_country: US
publication_date: 20110216
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["This disclosure is directed to computer systems. More particularly, it is directed to the secure communications within a computing environment.","Elements within a computing environment (executable components, applications, processes, etc.) may communicate with each other through secure techniques, such as encryption. For instance, a first element may encrypt data before providing that data to a second element within the computing environment. In conventional systems, a shared secret (e.g., a symmetric encryption key) may be provided to both elements to enable encrypted communications between such elements. Within the context of the previous example, the first element may encrypt the data with its shared secret and provide the encrypted data to the second element. The second element may decrypt the data with its shared secret. In this way, other elements within the computing environment will not be able to determine the clear version of the data because such elements do not possess the shared secret. In some instances, these elements may operate within an environment that cannot ensure the secrecy of the shared secret. For instance, an attacker or malicious application may utilize a debugger to inspect an element to determine that element's shared secret. Mechanisms such as code obfuscation may prevent casual observers from deciphering the shared secret; secrecy of shared secrets when faced with a detailed inspection of an element may not be guaranteed. In some cases, once a shared secret has been comprised, any element that has access to the compromised secret may decipher the clear version of data or information protected with that secret.","Embodiments may include generating an initial verifier for a first process, the initial verifier generated based on a trusted image of the first process. For example, a cryptographic hash function may be utilized to generate a digest of a given process. Embodiments may also include, subsequent to generating an untransformed secret associated with the first process, using a reversible transform (e.g., an exclusive-or operation) to transform the untransformed secret with the initial verifier to generate a transformed secret associated with the first process. Embodiments may also include, subsequent to the first process being launched outside of a secure domain, and dependent upon a second verifier generated from a current state of the first process being the same as the initial verifier (e.g., to ensure the first process has not been modified): using the reversible transform to reverse transform the transformed secret with the second verifier to generate a de-transformed secret equal to the untransformed secret. For instance, such protocol may be performed when the first process requests its secret for use in a secure communication (e.g., the secret may be used as an encryption key or an encryption key may be generated from the secret). Embodiments may include performing a secure communication between the first process outside of the secure domain and a secure process executing within the secure domain; the secure communication may be protected with a cryptographic key generated based on the de-transformed secret. The secure domain may have one or more safeguards in place to prevent unauthorized access to information or processes within the secure domain. For instance, the secure domain may prevent elements outside of the secure domain from altering the state of processes or other elements within the secure domain. Likewise, the secure domain may also include one or more data stores including information that is not accessible to elements outside of the secure domain. In various embodiments, the contents of the secure domain may not be susceptible to security attacks, such as debugging inspection or other malicious techniques.","While the system and method for establishing a shared secret for communication between different security domains is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the system and method for establishing a shared secret for communication between different security domains is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit embodiments to the particular form disclosed. Rather, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the system and method for establishing a shared secret for communication between different security domains as defined by the appended claims. Any headings used herein are for organizational purposes only and are not meant to limit the scope of the description or the claims. As used herein, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","Various embodiments of a system and method for establishing a shared secret for communication between different security domains are described. In the following detailed description, numerous specific details are set forth to provide a thorough understanding of claimed subject matter. However, it will be understood by those skilled in the art that claimed subject matter may be practiced without these specific details. In other instances, methods, apparatuses or systems that would be known by one of ordinary skill have not been described in detail so as not to obscure claimed subject matter.","Some portions of the detailed description which follow are presented in terms of algorithms or symbolic representations of operations on binary digital signals stored within a memory of a specific apparatus or special purpose computing device or platform. In the context of this particular specification, the term specific apparatus or the like includes a general purpose computer once it is programmed to perform particular functions pursuant to instructions from program software. Algorithmic descriptions or symbolic representations are examples of techniques used by those of ordinary skill in the signal processing or related arts to convey the substance of their work to others skilled in the art. An algorithm is here, and is generally, considered to be a self-consistent sequence of operations or similar signal processing leading to a desired result. In this context, operations or processing involve physical manipulation of physical quantities. Typically, although not necessarily, such quantities may take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared or otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to such signals as bits, data, values, elements, symbols, characters, terms, numbers, numerals or the like. It should be understood, however, that all of these or similar terms are to be associated with appropriate physical quantities and are merely convenient labels. Unless specifically stated otherwise, as apparent from the following discussion, it is appreciated that throughout this specification discussions utilizing terms such as \u201cprocessing,\u201d \u201ccomputing,\u201d \u201ccalculating,\u201d \u201cdetermining\u201d or the like refer to actions or processes of a specific apparatus, such as a special purpose computer or a similar special purpose electronic computing device. In the context of this specification, therefore, a special purpose computer or a similar special purpose electronic computing device is capable of manipulating or transforming signals, typically represented as physical electronic or magnetic quantities within memories, registers, or other information storage devices, transmission devices, or display devices of the special purpose computer or similar special purpose electronic computing device.","Note that the description presented herein may include one or more references to a one-way function or a cryptographic hash function, either of which may be referred to herein as simply a hash function. Generally speaking, a hash function may operate on a block of data in order to return a fixed-size bit string (e.g., the hash value, or simply \u201chash\u201d) such that an accidental or intentional change to the block of data will result in a different hash value if the hash function is performed on that changed data (although variations thereof may be utilized in various embodiments). In some cases, the aforesaid block of data may be referred to as a \u201cmessage\u201d and the corresponding hash value may be referred to as the \u201cmessage digest\u201d or simply a \u201cdigest.\u201d In various embodiments, a hash function may include any function or set of operations operating as described above. Examples of hash functions include, but are not limited to, the Secure Hash Algorithm (SHA) (e.g., SHA-1, SHA-0, SHA-224, SHA-256, SHA-384, SHA-512, and other SHA variations), the RACE Integrity Primitives Evaluation Message Digest (RIPEMD) (e.g., RIPEMD-128, RIPMED-160, RIPEMD-256, RIPEMD-320, and other RIPEMD variations), the Message Digest algorithm (MD) (e.g., MD-3, MD-4, MD-5, and other MD variations), the Tiger and Tiger2 hash functions (e.g., Tiger-128, Tiger-160, Tiger-192, Tiger2-128, Tiger2-160, Tiger2-192, and other Tiger variations), the Very Efficient Substitution Transposition (VEST) (e.g., VEST-4, VEST-8, VEST-16, VEST-32, and other VEST variations), the WHIRLPOOL hash function, some other hash function whether presently known or developed in the future, and\/or some combination or variation of any of the aforesaid hash functions. In various embodiments, references to performing cryptographic hash functions may include generating a keyed-Hash Message Authentication Code (HMAC), such as HMAC-SHA1 or HMAC-MD5.","Various embodiments include encryption and\/or decryption keys, any of which may be generated via a key derivation function (KDF). Key derivation functions may include the completion of one or more iterations or instances of cryptographic operations in order to generate an encryption or decryption key. Examples of key derivation function may include but are not limited to any key derivation functions specified by Public Key Cryptography Standards (PKCS) (e.g., PKCS-5 or PKCS-12) or Adobe\u00ae Password Security. In various embodiments, KDFs may be utilized by any of the various components described herein to generate symmetric encryption keys for symmetric encryption.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","120","100","120"]},"Various embodiments may enable secure communication  between process  and process . In some embodiments, process  may be referred to as an insecure process by virtue of process  executing outside of the secure domain. However, it should be noted that this is a term of convenience and does not imply any specific deficiency with the process itself. Similarly, process  may be referred to herein as a secure process by virtue of process  executing within the secure domain. In various embodiments, while only one insecure process and one secure process are illustrated, embodiments may generally include any quantity of insecure and secure process. In various embodiments, these processes may be distinguished within the illustrated domains by identifiers, which may be referred to as process identifiers or process IDs.","As illustrated, the secure domain may include a secure kernel , the operation of which is described in more detail with respect to subsequent Figures. In general, the secure kernel may include one or more core components of an operating system executing within the secure domain. In various embodiments, other components of the operating system may execute within insecure domain . In various embodiments, the operating system of which the kernel is a component may be loaded via a secure boot process. This secure boot process may include loading the operating system from an operating system image after successfully verifying that image as being secure. For example, the operating system image may be digitally signed; verifying the operating system may include verifying the digital signature as authentic. Once the image is verified, the operating system may be booted from that image. In various embodiments, the operating system image may be stored in memory of the secure domain or retrieved from another location accessible to the secure domain.","In various embodiments, secure kernel  may be configured to enable secure communication  through various techniques, which are described in more detail below with respect to .",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2","b":["110","130","130","110","110","130","110","202","130","202","150","150","204","110","150","202","150","204"]},"As described in more detail below, inclusion of certain information within the trusted process image may strengthen overall security, according to various embodiments. For instance, the image may also include values of certain registers (e.g., debugging registers). As described in more detail with respect to , if these values change during runtime (e.g., if an attacker is trying to inspect the code with a debugger thus causing the register values to change), then the secure kernel create an incorrect de-transformed secret, which may prevent secure communication between the insecure process and the secure process.","Secure kernel  may include a verifier generator  configured to generate a verifier from the trusted process image. In various embodiments, verifier generator  may be configured to perform a cryptographic hash function on the trusted process image to generate a hash. For instance, verifier generator  may perform a hash function that inputs trusted process image  as a message and outputs verifier as a message digest. In general, verifier generator  may perform an irreversible transform on the trusted process image  in order to generate verifier . In various embodiments, each verifier generated by verifier generator  may have a fixed width data size (e.g., 128 bits).","Secure kernel  may also include a secret generator  configured to generate a secret ; secret  may also be referred to herein as an untransformed secret. In various embodiments, the secure kernel may include a reversible transform component  configured to transform untransformed secret  with verifier in order to generate transformed secret . In various embodiments, the reversible transform may be a bitwise transform, such as a bitwise exclusive-or (\u201cXOR\u201d) operation. In cases where reversible transform  performs a bitwise operation, verifier , secret , and transformed secret may have the same data size (e.g., each may be 128 bits in length). At , the transformed secret is stored within memory in table . Within the table, transformed secret may be associated (or \u201ckeyed\u201d) to the process ID , which identifies the insecure process for which the transformed secret was generated (e.g., process ). As illustrated by process IDs -and transformed secrets -, multiple other transformed secrets may be generated for other insecure process according to similar techniques. As described in more detail below, a given transformed secret may enable secure communication between a process in the insecure domain and a process in the secure domain. As illustrated at , verifier may be returned to process , which at  may store the verifier in table . Table  may associate process IDs (e.g., process IDs -) with associated verifiers generated by the secure kernel (e.g., verifiers -). As described in more detail below with respect to , this table may be utilized by a secure process to retrieve the correct verifier when submitting requests to secure kernel .",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 3","FIG. 3","FIG. 2"],"b":["110","250","110","100"]},"As illustrated at , in response to the request, secure kernel  may capture the current state of process  while that process resides in the insecure domain. The captured state is illustrated as process state  in the illustrated embodiment. In various embodiments, as long as process  has not been altered (e.g., by a virus or malware), the current process state  should be the same as trusted process image . In various embodiments, the format or structure of process state  may be the same as the original trusted image . For instance, as described above, the trusted image may also include values of certain registers (e.g., debugging registers). If these values change during runtime in the insecure domain (e.g., if an attacker is trying to inspect the code with a debugger thus causing the register values to change), then process state  will not be the same as trusted process image . As described below, this may cause the secure kernel to create an incorrect de-transformed secret, which may prevent secure communication between the insecure process and the secure process.","As illustrated, verifier generator  may generate a second verifier  for the insecure process based on the acquired process state . In various embodiments, the verifier generator  may generate this verifier according to the same technique used to generate verifier . For instance, if verifier were generated as the digest of a cryptographic hash function applied to trusted process image , verifier  may be generated as the digest of the same cryptographic hash function applied to process state .","As illustrated at , secure kernel  may use the process ID of the insecure process to locate the previously generated transformed secret from table . Reversible transform  may reverse transform transformed secret with verifier . As should be apparent from the configuration of , if verifier  is the same as verifier (i.e., if the process has not been altered, maliciously or otherwise), the de-transformed secret  will be equivalent to secret . If verifier  is not the same as verifier (i.e., if the process has been altered, maliciously or otherwise), the de-transformed secret  will not be equivalent to secret .","In the illustrated embodiment, the secure kernel may provide the de-transformed secret  to process . Process  may use the de-transformed secret to decrypt information received from process  and\/or to encrypt information sent to process . To perform such decryption\/encryption, process  may utilize de-transformed secret  as a cryptographic key (e.g., a symmetric key). In other cases, process  may generate a cryptographic key based on the transformed secret. For instance, process  may apply a key derivation function to de-transformed secret  and use the result as a cryptographic key.","Secure communication  may represent the transfer of information from process  to process  and\/or the transfer of information from process  to process . For information sent to process  during secure communication , process  may first encrypt the information using the cryptographic key (based on de-transformed secret ). As describe in more detail below, process  may be able to decrypt this information because process  may have access to an equivalent key. For information received from process  during secure communication , process  may decrypt this information using the cryptographic key (based on de-transformed secret ). In various embodiments, this may be the correct key because process  may have encrypted the information with an equivalent key, as described in more detail with respect to .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 4","FIG. 3","FIG. 2"],"b":["110","250","110"]},"As illustrated at , process  may provide an encryption or decryption request  to secure kernel . For instance, process  may have received information (e.g., during secure communication ) from process  that resides in an encrypted form; process  may submit such information as part of the request in order to have such information decrypted and returned. In another example, prior to process  sending information to process , process  may submit such information to be encrypted by the secure kernel. An encryption and decryption unit  may extract such information, which is illustrated as data , and perform encryption or decryption as specified by request . The key with which data  is encrypted or decrypted may be generated by encryption\/decryption unit  based on de-transformed secret , which is described in more detail below.","As illustrated at , in response to request , secure kernel  may capture the current state of process  while that process resides in the insecure domain. The captured state is illustrated as process state  in the illustrated embodiment. In various embodiments, as long as process  has not been altered (e.g., by a virus or malware), the current process state  should be the same as trusted process image . In various embodiments, the format or structure of process state  may be the same as the original trusted image . For instance, as described above, the trusted image may also include values of certain registers (e.g., debugging registers). If these values change during runtime in the insecure domain (e.g., if an attacker is trying to inspect the code with a debugger thus causing the register values to change), then process state  will not be the same as trusted process image . As described below, this may cause the secure kernel to create an incorrect de-transformed secret, which may prevent secure communication between the insecure process and the secure process.","As illustrated, verifier generator  may generate a second verifier  for the insecure process based on the acquired process state . In various embodiments, the verifier generator  may generate this verifier according to the same technique used to generate verifier . For instance, if verifier were generated as the digest of a cryptographic hash function applied to trusted process image , verifier  may be generated as the digest of the same cryptographic hash function applied to process state .","As illustrated at , secure kernel  may use the process ID of the insecure process to locate the previously generated transformed secret from table . Reversible transform  may reverse transform transformed secret with verifier . As should be apparent from the configuration of , if verifier  is the same as verifier (i.e., if the process has not been altered, maliciously or otherwise), the de-transformed secret  will be equivalent to secret . If verifier  is not the same as verifier (i.e., if the process has been altered, maliciously or otherwise), the de-transformed secret  will not be equivalent to secret .","In the illustrated embodiment, encryption\/decryption unit  may be configured to encrypt or decrypt data  with de-transformed secret  to generate encrypted or decrypted information , respectively. In other cases, encryption\/decryption unit may generate a cryptographic key from the de-transformed secret  (e.g., with a key derivation function) and use that key to encrypt or decrypt data  to generate encrypted or decrypted information . Once encrypted or decrypted (depending upon what operation was requested), information  may be provided to process . If the information were decrypted, process  may now decipher a clear version of the information. If the information were encrypted, process  may communicate the encrypted information to process .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5","b":["540","130","110","130","110","130"]},"As illustrated at , prior to generating a request for the secret, process  may perform a lookup operation in table  in order to determine the verifier that corresponds to process  (e.g., as specified by process ID). Process  may generate a request for secret at ; this request may include verifier retrieved from table  (note verifier was generated for process  as described above). Secure kernel  may receive the request and process the request differently than the requests of  and  by virtue of the request originating from secure process . In some cases, secure kernel  may provide an application programming interface (API) accessible to secure process and not accessible to processes outside of the secure domain. Request  may be provided through such API.","As illustrated, secure kernel  may extract verifier from the request. The secure kernel may also perform a lookup operation  to determine the transformed secret previously generated for process . For instance, the secure kernel may extract the process ID of the insecure process from request  and use that process ID to find the associated transformed secret in table . In various embodiments, secure kernel  may use reversible transform  to reverse transform transformed secret with verifier to generate de-transformed secret . The secure-kernel may prove de-transformed secret  to process .","As described above, process  may have received an encrypted communication from process  and\/or may be tasked with sending encrypted information to process . In either case, process  may generate a cryptographic key from de-transformed secret  (or may use the de-transformed secret itself as a key) and use such key for decrypting information received from process  and\/or encrypting information sent to process .","In various embodiments, secure communication may be facilitated due to information being sent from process  to process  (and vice versa) protected (e.g., encrypted) with the same cryptographic key. For instance, the techniques described herein may ensure that both process  and process  are utilizing equivalent keys as long as process  has not been modified relative to the original trusted image of process . For instance, in one example, de-transformed secret  and de-transformed secret  (or ) may be the same in accordance with the description herein provided process  has not been modified. For instance, as described above, if the insecure process has been modified (e.g., by malware or otherwise), this will \u201ctrickle down\u201d to the de-transformed secret created for the insecure process. As should be apparent from , for example, modifying process  would cause the captured state of that process to be incorrect, which would also cause the generated verifier to be incorrect. If that verifier is incorrect, the de-transformed secret (and any cryptographic keys generated therefrom) will also be incorrect. As such, the techniques described herein may ensure that an insecure process in an insecure domain and a secure process in a secure domain may communicate securely (e.g., through the encryption described herein) without embedding (e.g., hard-coding) a cryptographic key within process . By not embedding a key in process , embodiments may prevent an inspection of the executable instructions and data implementing process  (or some other attack) from yielding knowledge of the key.","In various embodiments, the transformed secret associated with the secure process may be updated over time (e.g., similar to a key rollover operation).  illustrates a flow diagram of an example embodiment for refreshing the transformed secret associated with an insecure process. As illustrated at , process  may initiate the refresh of the secret by sending a request to refresh the secret to secure kernel . This request may include the process ID of process  as well as the verifier (e.g., verifier ) of that process as determined by lookup operation . Secure kernel  may generate a new secret  (different than secret ) and then transform that new secret with verifier to generate new transformed secret . In various embodiments, this transformation may be performed with the reversible transform previously utilized (e.g., reversible transform ). In other cases, the transformation may be performed with a different transform provided that transform is a also a reversible transform. In some embodiments, a different reversible transform may be utilized each time the secret is refreshed. At , secure kernel  may perform an update operation to store the new transformed secret within table  thereby replacing the old secret. As illustrated at , process  may notify process  of the key refresh. For instance, the notification may specify that the secret is going to change soon or that the secret is scheduled to change at a specific time.","Embodiments may also include methods for implementing the techniques described herein, an example of which is illustrated in . In various embodiments, the method of  may be implemented on a computer system, such as computer system  described below. In various embodiments, one or more portions of the method may be performed within a secure domain (e.g., secure domain ) that provides a level of security greater than one or more or more other domains (e.g., insecure domain ).","The method may begin at , which may include generating an initial verifier for a first process, wherein the initial verifier is generated based on a trusted image of the first process. For instance, this portion of the method may include utilizing the techniques described above with respect to generating of  (e.g., generating a hash of the trusted image). At , the method may include subsequent to generating an untransformed secret (e.g., secret  of ) associated with the first process, using a reversible transform (e.g., reversible transform ) to transform the untransformed secret with the initial verifier to generate a transformed secret (e.g., transformed secret ) associated with the first process. At , the method may include subsequent to the first process being launched outside of the secure domain (e.g., initiate process  of ), and dependent upon a second verifier generated from a current state of the first process being the same as the initial verifier (e.g., process state  or  of previous Figures), using the reversible transform (e.g., reversible transform ) to reverse transform the transformed secret with the second verifier to generate a de-transformed secret equal to the untransformed secret (e.g., creating de-transformed secret  or  described above). At , the method may also include performing a secure communication between the first process outside of the secure domain and a secure process executing within the secure domain (e.g., secure communication  or ). The secure communication may be protected with a particular cryptographic key generated (e.g., with a KDF) based on the de-transformed secret (e.g., de-transformed secret  or  described above). In various embodiments, various addition or modifications may be performed on the method described above. It should be understood that the illustrated method is only one example within the spirit and scope of various embodiments. In general, the methods may include performing any functionality or operation described herein.","Example Computer System","Various embodiments of a system and method for establishing a shared secret for communication between different security domains, as described herein, may be executed on one or more computer systems, which may interact with various other devices. One such computer system is computer system  illustrated by , which may in various embodiments implement any of the systems, devices, elements or methods illustrated in . For instance, any of the functionality described above may be stored in memory as processor-executable executable program instructions  (e.g., program instructions executable by processor(s) ). In one non-limiting example, computer system  may be configured to implement one or more domains, such as a secure domain and an insecure domain (e.g., domains  and  described above). In the illustrated embodiment, computer system  includes one or more processors  coupled to a system memory  via an input\/output (I\/O) interface . Computer system  further includes a network interface  coupled to I\/O interface , and one or more input\/output devices , such as cursor control device , keyboard , and display(s) . In some cases, it is contemplated that embodiments may be implemented using a single instance of computer system , while in other embodiments multiple such systems, or multiple nodes making up computer system , may be configured to host different portions or instances of various embodiments. For example, in one embodiment some elements may be implemented via one or more nodes of computer system  that are distinct from those nodes implementing other elements.","In various embodiments, computer system  may be a uniprocessor system including one processor , or a multiprocessor system including several processors  (e.g., two, four, eight, or another suitable number). Processors  may be any suitable processor capable of executing instructions. For example, in various embodiments processors  may be general-purpose or embedded processors implementing any of a variety of instruction set architectures (ISAs), such as the x96, PowerPC, SPARC, or MIPS ISAs, or any other suitable ISA. In multiprocessor systems, each of processors  may commonly, but not necessarily, implement the same ISA.","System memory  may be configured to store program instructions  and\/or data  accessible by processor . In various embodiments, program instructions  may be executable by the processor(s) to implement the functionality of any component or element described above, such as process , process , and\/or secure kernel . As illustrated, in various embodiments, data  may store any data or information described herein, such as tables  and  described above. In various embodiments, system memory  may be implemented using any suitable memory technology, such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), nonvolatile\/Flash-type memory, or any other type of memory. In the illustrated embodiment, program instructions and data implementing any of the elements of the framework described above may be stored within system memory . In other embodiments, program instructions and\/or data may be received, sent or stored upon different types of computer-accessible media or on similar media separate from system memory  or computer system .","In one embodiment, I\/O interface  may be configured to coordinate I\/O traffic between processor , system memory , and any peripheral devices in the computer system, including network interface  or other peripheral interfaces, such as input\/output devices . In some embodiments, I\/O interface  may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory ) into a format suitable for use by another component (e.g., processor ). In some embodiments, I\/O interface  may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I\/O interface  may be split into two or more separate components, such as a north bridge and a south bridge, for example. Also, in some embodiments some or all of the functionality of I\/O interface , such as an interface to system memory , may be incorporated directly into processor .","Network interface  may be configured to allow data to be exchanged between computer system  and other devices attached to a network (e.g., network ), or between nodes of computer system . In various embodiments, network interface  may support communication via wired or wireless general data networks, such as any suitable type of Ethernet network, for example; via telecommunications\/telephony networks such as analog voice networks or digital fiber communications networks; via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and\/or protocol.","Input\/output devices  may, in some embodiments, include one or more display terminals, keyboards, keypads, touchpads, scanning devices, voice or optical recognition devices, or any other devices suitable for entering or accessing data by one or more computer systems . Multiple input\/output devices  may be present in computer system  or may be distributed on various nodes of computer system . In some embodiments, similar input\/output devices may be separate from computer system  and may interact with one or more nodes of computer system  through a wired or wireless connection, such as over network interface .","In some embodiments, the illustrated computer system may implement any of the process or methods described above, such as those of . In other embodiments, different elements and data may be included.","Those skilled in the art will appreciate that computer system  is merely illustrative and is not intended to limit the scope of embodiments. In particular, the computer system and devices may include any combination of hardware or software that can perform the indicated functions of various embodiments, including computers, network devices, Internet appliances, PDAs, wireless phones, set top television boxes, pagers, and\/or any other electronic device described herein. Computer system  may also be connected to other devices that are not illustrated, or instead may operate as a stand-alone system. In addition, the functionality provided by the illustrated components may in some embodiments be combined in fewer components or distributed in additional components. Similarly, in some embodiments, the functionality of some of the illustrated components may not be provided and\/or other additional functionality may be available.","Those skilled in the art will also appreciate that, while various items are illustrated as being stored in memory or on storage while being used, these items or portions of them may be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively, in other embodiments some or all of the software components may execute in memory on another device and communicate with the illustrated computer system via inter-computer communication. Some or all of the system components or data structures may also be stored (e.g., as instructions or structured data) on a computer-accessible medium or a portable article to be read by an appropriate drive, various examples of which are described above. In some embodiments, instructions stored on a computer-accessible medium separate from computer system  may be transmitted to computer system  via transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a network and\/or a wireless link. Generally speaking, a computer-accessible medium may include a computer-readable storage medium or memory medium such as magnetic or optical media, e.g., disk or DVD\/CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR, RDRAM, SRAM, etc.), ROM, etc. In some embodiments, a computer-accessible medium may include transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The methods described herein may be implemented in software, hardware, or a combination thereof, in different embodiments. In addition, the order of methods may be changed, and various elements may be added, reordered, combined, omitted, modified, etc. Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. Realizations in accordance with embodiments have been described in the context of particular embodiments. These embodiments are meant to be illustrative and not limiting. Many variations, modifications, additions, and improvements are possible. Accordingly, plural instances may be provided for components described herein as a single instance. Boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of claims that follow. Finally, structures and functionality presented as discrete components in the example configurations may be implemented as a combined structure or component. These and other variations, modifications, additions, and improvements may fall within the scope of embodiments as defined in the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
