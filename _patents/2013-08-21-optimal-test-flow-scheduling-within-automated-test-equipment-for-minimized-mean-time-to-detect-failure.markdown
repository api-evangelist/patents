---
title: Optimal test flow scheduling within automated test equipment for minimized mean time to detect failure
abstract: The present invention describes a method and system for optimizing a test flow within each ATE (Automated Test Equipment) station. The test flow includes a plurality of test blocks. A test block includes a plurality of individual tests. A computing system schedule the test flow based one or more of: a test failure model, test block duration and a yield model. The failure model determines an order or sequence of the test blocks. There are at least two failure models: independent failure model and dependant failure model. The yield model describes whether a semiconductor chip is defective or not. Upon completing the scheduling, the ATE station conducts tests according to the scheduled test flow. The present invention can also be applied to software testing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09342424&OS=09342424&RS=09342424
owner: International Business Machines Corporation
number: 09342424
owner_city: Armonk
owner_country: US
publication_date: 20130821
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation of U.S. patent application Ser. No. 12\/784,142, filed May 20, 2010 the entire content and disclosure of which is incorporated herein by reference.","The present invention generally relates to an ATE (Automated Test Equipment). More particularly, the present invention relates to optimizing a test flow within an ATE.","An ATE station refers to any automated device that is used to test printed circuit boards, integrated circuits or any other electronic components. Agilent\u00ae Medalist i1000D, Agilent\u00ae Medalist i3070, Teradyne\u00ae Catalyst, Teradyne\u00ae Tiger, Teradyne\u00ae FLEX and Teradyne\u00ae UltraFLEX are examples of an ATE station.","A semiconductor manufacturing process requires a sequence of complex operations on each wafer to create multi-layered physical and electrical structures that form a desired very large scale integrated circuitry (VLSI). Defects in the process may occur due to several operational, mechanical or chemical control errors, or due to environmental uncertainty, e.g., contamination during the process. After manufacturing of semiconductor chips on each wafer is complete, a set of comprehensive electrical (e.g., a test for power consumption of each semiconductor chip on each wafer), functional (e.g., a behavioral test on each semiconductor chip on each wafer), and characterization tests (e.g., tests measuring area or clock frequency of semiconductor chip on each wafer) are performed to determine an actual wafer and semiconductor chip yield. These tests require several detailed measurements of various electrical parameters, using different test configurations. An automated test equipment (ATE) station operates a sequence of such tests on all pins on all semiconductor chips on each wafer. Additional stages of tests may then be performed by other ATE stations to simulate different environmental settings, or measure different parameters etc. An end-to-end test process (i.e., process running all tests on every semiconductor chip) consumes a significant amount of time, and it is critical that the process be optimized appropriately. Optimization of the test process involves an appropriate scheduling of wafers and lots onto multiple ATE stations and across stages of test settings in order to optimally utilize testers and maximize test throughput.","It would be desirable that the optimization of the test process includes an optimization of a test flow within each ATE station to minimize a time to detect any defects or failures on a semiconductor chip or a wafer.","The present invention describes a system and method for optimizing a test flow within an ATE station to minimize the time to detect any defects or failures on a semiconductor chip or a wafer.","In one embodiment, there is provided a computer-implemented system for optimizing a test flow within an ATE (Automated Test Equipment) station for testing at least one semiconductor chip. The test flow lists a plurality of test blocks or tests in a sequence according to which the plurality of test blocks or tests are run. A test block including one or more tests that need to be run together in a specific sequence. The system determines one or more of: a test failure model, a test block duration and a yield model. The test failure model determines an order or sequence of the test blocks. The test block duration describes how long it takes for the ATE station to complete all tests in a test block. The yield model describes whether a semiconductor chip is defective or not. The system schedules the test flow based on said one or more of: the test failure model, the test block duration and the yield model. The system automatically conducting tests in the plurality of test blocks on at least one wafer or at least one semiconductor chip according to the scheduled test flow.","In a further embodiment, the test failure model comprises: an independent failure model and a dependent failure model. The independent failure model represents that a success or failure of a test, or test block, does not depend on a success or failure of any other tests or test blocks run before or after in the test flow. The dependent failure model represents that the success or failure of a test depends on a success or failure of another test or test block run before or after in the test flow.","In a further embodiment, the independent and dependant failure models respect the test process constraint on particular test blocks.","In another embodiment, there is provided a computer-implemented method for optimizing a test schedule of programming codes. The test schedule lists a plurality of test blocks or tests in a sequence according to which the plurality of test blocks or tests are run. A test block includes one or more tests that need to be run together in a specific sequence. The method comprises a step of determining one or more of: an independent failure model and a dependent failure model, a step of ordering the plurality of the test blocks according to the determined failure model, and a step of testing the programming codes according to the order. The independent failure model represents that a success or failure of a first test does not depend on a success or failure of a second test run before or after the first test. The dependent failure model represents that the success or failure of the first test depends on a success or failure of the second test run before or after the first test.","According to one embodiment of the present invention, a test floor may include a plurality of ATE stations (i.e., individual testers). An ATE station includes at least one test flow, which is defined by a test program (e.g., a test program  in ). A test flow comprises a plurality of test blocks. The test flow lists the plurality of tests or test blocks in a sequence according to which they are run. A test block includes one or more individual tests, e.g., tests measuring leakage current and threshold voltage. The test block refers to a group of individual tests that could not or should not be separated. The individual tests in the test block need to be run together in a specific sequence. The individual testers may perform the individual tests.","According to one embodiment of the present invention, an ATE station receives as input one or more of: a test process structure, a test process constraint and a stopping criterion. The test process structure includes, but is not limited to: a list of tests to be performed or already performed on a wafer and\/or a semiconductor chip, characteristics of the tests and individual durations of the tests. The test process constraint describes relationships between the tests, e.g., precedence and dependence relationships between the tests. The test stopping criterion describes when one or more of the tests will stop, e.g., stop on a single test fail or stop on successful completion of all tests. A computing system (e.g., a computer  in ) running one or more of failure models (e.g., an independent failure mode illustrated in  and\/or a dependent failure mode illustrated in ) optimally order the tests to minimize a mean time (i.e., an average time) to detect a failure on a semiconductor chip or a wafer. The computing system may utilize history data (e.g., history data ) to determine an optimal sequence of the tests.","According to one embodiment of the present invention, the computing system  determines one or more of: a test failure model, a test block duration and a yield model. The test failure model determines an order or sequence of the test blocks. The test failure model includes, but is not limited to: an independent failure model (i.e., method steps described in ) and a dependent failure model (i.e., method steps described in ). The independent failure model represents that a success or failure of a test does not depend on a success or failure of any other test(s) in the test flow. The dependent failure model represents that the success or failure of a test depends on a success or failure of another test(s) in the test flow. The test block duration describes how long it takes for the ATE station to complete all tests in a test block. The yield model describes whether a semiconductor chip is good or defective, e.g., labeling a semiconductor chip as defective if a test on the semiconductor chip resulted in a fail. Then, the computing system  schedules a test flow within an ATE station according to one or more of: the test failure model, the test block duration and the yield model. After the computing system  completes the scheduling, the ATE station (e.g., an ATE station  in ) automatically conducts the tests included in the test flow on at least one wafer and\/or at least one semiconductor chip according to the scheduled test flow.","According to a further embodiment, to schedule the test flow, the computing system  respects the test process constraints (e.g., particular test blocks and individual tests cannot be reordered) while running the failure model(s).","During a manufacturing test on a wafer or semiconductor module lot, an ATE station  tests all semiconductor chips on the wafer by running through its test flow (comprising electrical, functional and characterization tests) on each semiconductor chip to determine semiconductor chip yield and defects. Traditionally, this test flow is pre-determined and fixed for all the semiconductor chips. However, according to one embodiment of the present invention, the computing system  determines and\/or modifies the test flow at real-time, e.g., by executing the failure models. Additionally, the test flow is logically partitioned into test blocks, e.g., by grouping inseparable tests (i.e. tests that must be tested together in a specific sequence, e.g., a test sequence for a memory test and repair) or groping tests that need to be tested in a specific order in the test flow. For example, electrical tests for detecting open circuits and short circuits may be grouped together and run first. When a semiconductor chip fails specific electrical or functional tests, the semiconductor chip is considered to have zero yield (along with a reason or sort code), and testing on the semiconductor chip may be stopped after performing all the tests in the relevant test block. Unless further characterization is warranted, remaining tests in other test blocks are not performed on the failed semiconductor chip and the ATE station starts testing a next semiconductor chip. An example of test names, test blocks, times per test for a semiconductor wafer or chip test is shown Table 1.",{"@attributes":{"id":"p-0023","num":"0022"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Semiconductor test table illustrating test blocks, tests in each test "},{"entry":"block and test duration of each test."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Test Block","Test name","Test Duration"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Block 1","Test 05034","\u20020.05 sec"]},{"entry":[{},"Test 07803","\u20020.03 sec"]},{"entry":["Block 2","Test 01111","\u20020.04 sec"]},{"entry":[{},"Test 09093","\u20020.01 sec"]},{"entry":[{},"Test 07044","0.005 sec"]},{"entry":["Block 3","Test 04342","\u20020.02 sec"]},{"entry":[{},"Test 98743","\u20020.05 sec"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In the Table 1, tests are grouped into three test blocks: a test block 1 including tests 05034 and 07803, a test block 2 including tests 01111, 09093 and 07044 and a test block 3 including tests 04342 and 98743. Though Table 1 illustrates these three test blocks, there may be a plurality of test blocks each including one or more tests. The Table 1 illustrates test duration per each test. The Table 1 may further include a separate column (not shown) for a sort code to indicate a sort associated with a failure. When a particular test results in a fail and a semiconductor chip is determined as a defective chip, the ATE station may stop testing the semiconductor chip and identify it with a fail sort. When multiple tests are grouped into a test block, even if one test results in a fail, the testing may continue until the end of the test block before stopping and assigning a sort. For example, even if Test 05034 results in a fail on a semiconductor chip, the ATE station will also run Test 07803 on that semiconductor chip before stopping. Other tests\/test blocks will not need to be run on that semiconductor chip to determine it is defective. Additionally, in one embodiment, there may be fixed precedence constraints between blocks, e.g., the first five test blocks are required to be performed for an initialization of the ATE station. A goal of test flow optimization performed by the computing system  involves reordering the test blocks, while satisfying the test process constraint(s), to minimize a mean time to detect failure(s) on a semiconductor chip or a wafer. The computing system  runs both the independent failure model and the dependent failure model.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":"1","sup":["st ","th "]},"The computing system  accesses and retrieves from a storage device (e.g., a storage device ) history data (e.g., a history of N number of tested semiconductor chips) representing a typical distribution of fails and passes of tests. At step  in , for each test block b, the computing system  computes N, the number of pass chips (i.e., the number of semiconductor chips passed all tests within the test block b) and N, the number of chips that were failed by a test within the test block b based on the history data. The computation done by the computing system  is based on",{"@attributes":{"id":"p-0027","num":"0026"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"N","mo":"=","mrow":{"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"b","mo":"=","mn":"1"},"mi":"B"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msubsup":{"mi":["N","b","f"]}},"mo":"+","msup":{"mi":["N","P"]}}}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}}},"At step , the computing system  obtains or computes the test block duration of each test block b from the history data. At step , the computing system  schedules a test flow including the B number of test blocks to optimize a mean time to detect a failure for a set of N number of semiconductor chips, e.g., by ordering test blocks F+1through Bin a decreasing order of a fraction",{"@attributes":{"id":"p-0029","num":"0028"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"msubsup":{"mi":["N","b","f"]},"msub":{"mi":["t","b"]}},"mo":","}}},"br":{},"b":"305"},{"@attributes":{"id":"p-0030","num":"0029"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"msubsup":{"mi":["N","b","f"]},"msub":{"mi":["t","b"]}}}},"br":{},"sup":"st ","b":"305"},{"@attributes":{"id":"p-0031","num":"0030"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"msubsup":{"mi":["N","b","f"]},"msub":{"mi":["t","b"]}}}},"br":{},"sup":"nd "},{"@attributes":{"id":"p-0032","num":"0031"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"msubsup":{"mi":["N","b","f"]},"msub":{"mi":["t","b"]}}}},"br":{},"sup":"th ","b":["305","305","100","120"],"figref":"FIG. 1"},"The scheduled test flow can be implemented in a straightforward manner: the computing system  places tests with the highest likelihood of catching defective semiconductor chips in the shortest amount of times as early in the test flow as possible. Thus, the computing system  ensures that a resulting test flow minimizes a time to detect defective chip.","According to one embodiment, the independent failure model assumes that the computing system  can use the history data of the already tested or currently tested semiconductor chips or wafers to build an optimized test flow for testing. The computing system  may dynamically change the test flow in real-time. In order to achieve the dynamic real-time update of the test flow, the computing system  tracks N, N, and tand periodically (e.g., every 0.1 second) reorders the tests in the test flow. A period of the update depends on variability in data characteristics of the history data. Additionally, there may be different optimal test flows for different collections of wafers based on their common manufacturing equipment or period of manufacturing. The optimal test flow can also be different for different spatial locations of semiconductor chips on the wafer, as semiconductor chips in edge locations may experience different defect types than semiconductor chips in center locations of the wafer. The historical data may also include semiconductor chips' test data from previous test operations\u2014once the semiconductor chips have been properly identified through electronic chip identification (ECID), and any newly acquired test data that is pertinent.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":"305"},"The computing system  determines an optimal test flow by an iterative approach. At the end of iteration i, the computing system  determines the iblock to be scheduled in the test flow. Let N, Nand N denote the number of pass chips within a test block b, the number of semiconductor chips that were failed by a test within the test block b, and the total number of chips tested in the test block b respectively. Let N(i) denote the number of semiconductor chips that were failed by the test block b given that the semiconductor chips did not fail at all the test blocks , . . . , i, where the i represents a test block number i which is less than or equal to b. At step  in , for each test block b, computing system  computes the N(i) based on the history data. The history data may include, but is not limited to: a summary of test effectiveness over time, i.e., for each test, the history data includes the number of semiconductor chips for which the test resulted in a success and the number of semiconductor chips for which the test resulted in a failure over a period of time. At step , the computing system  computes or obtains a test block duration tfor each test block b from the history data. At step , the computing system  respects a test process constraint, e.g., by scheduling F number of blocks which cannot be reordered at a beginning of the test flow. The F+1block to be scheduled is a test block b with a largest ratio",{"@attributes":{"id":"p-0037","num":"0036"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":{"msubsup":{"mi":["N","b","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}},"msub":{"mi":["t","b"]}},"mo":","}}},"br":{},"b":"305"},{"@attributes":{"id":"p-0038","num":"0037"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":{"msubsup":{"mi":["N","b","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}},"msub":{"mi":["t","b"]}}}},"br":{},"sup":["th ","st "]},{"@attributes":{"id":"p-0039","num":"0038"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":{"msubsup":{"mi":["N","b","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["F","i"],"mo":"+"}}},"msub":{"mi":["t","b"]}},"mo":"."}}},"br":{}},{"@attributes":{"id":"p-0040","num":"0039"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":{"msubsup":{"mi":["N","b","f"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}},"msub":{"mi":["t","b"]}},"mo":"."}}}},"After the computing system  completes scheduling the test flow, e.g., by running method steps -, the ATE station conducts tests according to the scheduled test flow. The ATE station or computing system  may update the history data based on test results of the conducted tests. The computing system  may periodically, e.g., every 0.1 second, re-run steps - in .","According to one embodiment of the present invention, the computing system  uses history data to build an optimal schedule for testing as described above. The computing system  dynamically updates the scheduled test flow in real-time. In order to achieve the dynamic real-time update, the computing system  tracks quantities N, N(i), N, tand periodically reorders the tests in the test flow. A period of the update depends on the variability in data characteristics obtained during the testing.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3","b":["310","300","305","310","330","335","330","310","310","335","335","350","340","325","350","355","350","355","340","345","340","340","325","300","360","325","360","305","305","320","300","360","305","370","310","370","310","370","305","305"]},"According to one exemplary embodiment, the computing system  accesses and retrieves history data of N semiconductor chips, e.g., N=21,645, with N=13,822. In this history data, a distribution for Nand tfor all 33 test blocks (i.e., B=33), given a predefined order (i.e., testing in an sequential order of a test block , test block , . . . , test block ), is illustrated in . Based on this predefined order, the mean time to detect a fail (a sum of test times for failing chips\/the number of failing chips) on a semiconductor chip is 3.03 seconds, while the mean time for pass chips (i.e. chips that successfully pass all tests, and hence are tested by all blocks) is 7.57 seconds (a sum of test times for passing chips\/the number of passing chips).","Given that the first five test blocks cannot be reordered, i.e., F=5, the computing system  schedules a rest of the test blocks (i.e., test block  to test block ) based on a decreasing order of a fraction",{"@attributes":{"id":"p-0046","num":"0045"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"msubsup":{"mi":["N","b","f"]},"msub":{"mi":["t","b"]}},"mo":"."}}},"br":{},"b":"305"},{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Test block reordering"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pre","Opt","Pre","Opt","Pre","Opt"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1","1","12","5","23","21"]},{"entry":[{},"2","2","13","13","24","10"]},{"entry":[{},"3","3","14","8","25","12"]},{"entry":[{},"4","4","15","9","26","22"]},{"entry":[{},"5","5","16","19","27","29"]},{"entry":[{},"6","18","17","17","28","20"]},{"entry":[{},"7","25","18","28","29","30"]},{"entry":[{},"8","26","19","6","30","23"]},{"entry":[{},"9","24","20","15","31","31"]},{"entry":[{},"10","27","21","11","32","32"]},{"entry":[{},"11","7","22","16","33","33"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"305"},{"@attributes":{"id":"p-0048","num":"0047"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mfrac":{"mrow":{"mn":["3.03","1.52"],"mo":"-"},"mn":"3.03"},"mo":"\u00d7","mn":"100"},"mo":"=","mn":"49.8"}}}},"br":{}},{"@attributes":{"id":"p-0049","num":"0048"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mfrac":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mn":["3.03","7.57"],"mo":"+"}},{"mo":["(",")"],"mrow":{"mn":["1.52","7.57"],"mo":"+"}}],"mo":"-"},{"mo":["(",")"],"mrow":{"mn":["3.03","7.57"],"mo":"+"}}]},"mo":"\u00d7","mn":"100"},"mo":"=","mn":"14.2"}},"mo":","}}},"br":{}},"According to one embodiment of the present invention, the computing system  optimizes a test schedule of programming codes (e.g., codes written by C\/C++, Java\u00ae, or .Net, etc.). The test schedule includes a plurality of test blocks. A test block comprises at least one test including, but not limited to: a unit test, an integration test, a regression test, a system test, a simulation test, compile\/build time test, runtime test. The unit test is a software verification method that evaluates whether an individual unit (e.g., a class or function) of programming codes meets its intended design or behavior. The integration test is a software testing method in which individual software units are combined and evaluated together as a group. The regression test is a software testing method for discovering software bugs which did not exist in a previous software version but emerged in a current software version. For example, a function that worked correctly in the previous version might stop working properly at the current version. The system testing refers to a testing performed on a complete system to evaluate the system's performance and functionality. The simulation testing includes a simulation of a logic behavior of the programming code for various configurations of a software design. The compile\/build time test is a test done during the compilation of the programming codes. The compile\/build time test includes, but not limited to: checking syntaxes of the programming codes. The runtime test evaluates whether the programming codes operates as intended.","In this embodiment, Nrefers to the number of programming codes failed within a test block b. In this embodiment, trefers to a test duration of a test block b. N(i) refers to the number of programming codes failed given those programming codes passed test blocks 1, 2, . . . i.","In this embodiment, the computing system  determines whether the independent failure model or the dependent failure model is used for the optimizing the test schedule. If there exist a plurality of dependencies between programming codes, e.g., methods or functions frequently calls other methods or functions, the computing system  may choose the dependent failure model. If the programming codes are independent each other, e.g., a unit testing, the computing system  may choose the independent failure model. Then, the computing system  arranges or orders test blocks according to the chosen model. The computing system  tests the programming codes according to the order.","In a further embodiment, the computing system  optimizes a test schedule for the system test and\/or the simulation test conducted on the programming codes. In this embodiment, a test block is a stage of the system test and\/or the simulation test. Upon choosing a failure model (the independent failure model or the dependent failure model), the computing system  arranges or orders the test blocks (stages) in the system test and\/the simulation test according to the chosen failure model. Then, the computing system  conducts the system test and\/or simulation test in the order.","In one embodiment, the method steps in  are implemented in hardware or reconfigurable hardware, e.g., FPGA (Field Programmable Gate Array) or CPLD (Complex Programmable Logic Device), using a hardware description language (Verilog, VHDL, Handel-C, or System C). In another embodiment, the method steps in  are implemented in a semiconductor chip, e.g., ASIC (Application-Specific Integrated Circuit), using a semi-custom design methodology, i.e., designing a chip using standard cells and a hardware description language. Thus, the hardware, reconfigurable hardware or the semiconductor chip operates the method steps described in .",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 5","FIGS. 1-2"],"b":["305","511","511","512","514","516","518","521","540","512","522","524","526","528","532","512","534","305","536","512","538","539"]},"Although the embodiments of the present invention have been described in detail, it should be understood that various changes and substitutions can be made therein without departing from spirit and scope of the inventions as defined by the appended claims. Variations described for the present invention can be realized in any combination desirable for each particular application. Thus particular limitations, and\/or embodiment enhancements described herein, which may have particular advantages to a particular application need not be used for all applications. Also, not all limitations need be implemented in methods, systems and\/or apparatus including one or more concepts of the present invention.","The present invention can be realized in hardware, software, or a combination of hardware and software. A typical combination of hardware and software could be a general purpose computer system with a computer program that, when being loaded and run, controls the computer system such that it carries out the methods described herein. The present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which\u2014when loaded in a computer system\u2014is able to carry out these methods.","Computer program means or computer program in the present context include any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after conversion to another language, code or notation, and\/or reproduction in a different material form.","Thus the invention includes an article of manufacture which comprises a computer usable medium having computer readable program code means embodied therein for causing a function described above. The computer readable program code means in the article of manufacture comprises computer readable program code means for causing a computer to effect the steps of a method of this invention. Similarly, the present invention may be implemented as a computer program product comprising a computer usable medium having computer readable program code means embodied therein for causing a function described above. The computer readable program code means in the computer program product comprising computer readable program code means for causing a computer to affect one or more functions of this invention. Furthermore, the present invention may be implemented as a program storage device readable by machine, tangibly embodying a program of instructions executable by the machine to perform method steps for causing one or more functions of this invention.","The present invention may be implemented as a computer readable medium (e.g., a compact disc, a magnetic disk, a hard disk, an optical disk, solid state drive, digital versatile disc) embodying program computer instructions (e.g., C, C++, Java, Assembly languages, .Net, Binary code) run by a processor (e.g., Intel\u00ae Core\u2122, IBM\u00ae PowerPC\u00ae) for causing a computer to perform method steps of this invention. The present invention may include a computer program product including a computer readable storage medium having computer readable program code embodied therewith. The computer readable program code runs the one or more of functions of this invention.","It is noted that the foregoing has outlined some of the more pertinent objects and embodiments of the present invention. This invention may be used for many applications. Thus, although the description is made for particular arrangements and methods, the intent and concept of the invention is suitable and applicable to other arrangements and applications. It will be clear to those skilled in the art that modifications to the disclosed embodiments can be effected without departing from the spirit and scope of the invention. The described embodiments ought to be construed to be merely illustrative of some of the more prominent features and applications of the invention. Other beneficial results can be realized by applying the disclosed invention in a different manner or modifying the invention in ways known to those familiar with the art."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings are included to provide a further understanding of the present invention, and are incorporated in and constitute a part of this specification. The drawings illustrate embodiments of the invention and, together with the description, serve to explain the principles of the invention. In the drawings,",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4","sub":["b","b "],"sup":"f "},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
