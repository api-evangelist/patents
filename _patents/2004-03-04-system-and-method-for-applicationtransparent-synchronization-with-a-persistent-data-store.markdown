---
title: System and method for application-transparent synchronization with a persistent data store
abstract: A system and method for application-transparent synchronization with a persistent data store. In one embodiment, the system may include a persistent data store configured to store a plurality of data items, such as a relational database, for example. The system may further include an application configured to modify a local data subset including a local copy of a given data item. The local data subset may be a disconnected rowset object, for example. Additionally, the system may include a first synchronization provider configured to synchronize the modified local data subset with the persistent data store, where synchronization of a given modified local copy with a corresponding data item occurs transparently to the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07146385&OS=07146385&RS=07146385
owner: Sun Microsystems, Inc.
number: 07146385
owner_city: Santa Clara
owner_country: US
publication_date: 20040304
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates to computer systems and, more particularly, to synchronization of persistent data stores.","2. Description of the Related Art","Computer systems are commonly configured to process large quantities of data on behalf of numerous applications and users. For example, some computer systems may be configured to track business activities at a whole-enterprise level, including manufacturing and production data, procurement data, sales data, human resources data, as well as many other types of data. Further, some such computer systems may execute applications configured to perform sophisticated functions on enterprise data, such as real-time inventory management, cash flow monitoring, web-based ordering, and other types of functions.","In some computer system software architectures, data may be stored (or \u201cpersisted\u201d) in large data repositories or \u201cdata stores.\u201d For example, one or more databases may be used as data stores for enterprise data. In some such architectures, data stores may be separate software systems from applications that generate, modify, or consume enterprise data, which may allow for greater flexibility in developing and maintaining applications.","Depending on the system implementation, applications may execute on distinct computer systems that may be remote from the computer systems implementing data stores. Additionally, a given application may process a substantial amount of data while executing a given operation. Consequently, in some embodiments an application may be configured to retrieve data from a data store and process it locally before committing any changes back to the data store.","If multiple applications are configured to perform local processing of data, it is possible that one application may modify data within a data store that another application is processing. In some instances, such data transience may create inconsistencies in application operation, for example if a given application operation is predicated on consuming the most recent value of a given data item. Consequently, in some embodiments that support local processing of application data, applications may include synchronization resources to detect and resolve conflicts that may occur when multiple applications access and modify the same data.","However, coding synchronization functionality into each application that requires it presents several shortcomings. For example, numerous possible methods for implementing data synchronization may exist, each method being more optimal for some data usage scenarios than others. Therefore, an application developer is required to choose and develop each foreseeable synchronization method for each application, thus increasing development and validation effort for each given application. Further, implementing synchronization functionality within each application may increase development redundancy, for example if the same synchronization functionality is employed by several applications. Finally, to the extent that the correctness of synchronization functionality at a system level requires each application to exhibit the same synchronization behavior (i.e., that each application implementing a given synchronization protocol does so consistently, so that protocol assumptions are uniform), implementing synchronization functionality within each application increases overall system validation effort.","Various embodiments of a system and method for application-transparent synchronization with a persistent data store are disclosed. In one embodiment, the system may include a persistent data store configured to store a plurality of data items, such as a relational database, for example. The system may further include an application configured to modify a local data subset including a local copy of a given data item. The local data subset may be a disconnected rowset object, for example. Additionally, the system may include a first synchronization provider configured to synchronize the modified local data subset with the persistent data store, where synchronization of a given modified local copy with a corresponding data item occurs transparently to the application.","In one specific implementation of the system, the first synchronization provider may be configured to lock the given data item in the persistent data store, in response to the application modifying the local copy of the given data item.","In another specific implementation of the system, the first synchronization provider may be configured to determine whether a difference exists between an original value of the modified local copy of the given data item and the given data item stored in the persistent data store, in response to the application modifying the local copy of the given data item.","In one embodiment, the method may include storing a plurality of data items in a persistent data store, an application modifying a local data subset including a local copy of a given data item, and synchronizing the modified local data subset with the persistent data store, where synchronization of a given modified local copy with a corresponding data item occurs transparently to the application.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","Overview of Software System Architecture","Turning now to , a block diagram illustrating one embodiment of a software system is shown. In the illustrated embodiment, software system  includes a plurality of client processes and configured to communicate with a plurality of server processes and via an interprocess communication facility . Server processes and are in turn configured to communicate with a plurality of data stores and . It is noted that like reference numbers refer to like elements herein, and that a plurality of like elements distinguished by a letter suffix may be referred to generically in the plural or singular by a reference number without a letter suffix. For example, it is contemplated that in various embodiments, an arbitrary number of client processes , server processes , and data stores  may be employed.","In one embodiment, system  may be representative of a three-tier software architecture. Generally speaking, three-tier architectures provide separate processing resources for user interface processing, application or \u201cbusiness logic\u201d processing, and data storage. For example, an inventory management system may be implemented as a three-tier system. In such a system, users may submit inventory transactions and queries such as sales, returns, ordering\/procurement, and reporting operations via a user interface. Transactions and queries may be received and processed by application server processes, which may in turn access and modify a data store. For example, a given application server process may collect sales transactions from multiple point-of-sale user interfaces and update a database that includes inventory records to reflect the effects of item sales. A given application server process may also generate transactions in response to the effects of other transactions or detected database states. For example, an application server process may detect that as a result of sales activity, inventory of a particular item has fallen below a desired threshold. Responsively, the application server process may be configured to generate a purchasing transaction and\/or to notify relevant personnel of the condition, such as by generating a report or sending an email.","In one embodiment of system , clients and may be configured as user interface clients, through which users may submit transactions or other types of processing requests. For example, clients  may be configured as web interface clients, coded in a platform-independent language such as Java, which a given user may access by navigating to a particular Uniform Resource Locator (URL) using a web browser. Alternatively, clients  may be configured as standalone, platform-specific client processes that may be invoked independently of a web browser.","Interprocess communication (IPC) facility  may be configured to convey processing requests and data between clients  and servers . In embodiments where clients and are configured to run on computer systems that are remote to the computer systems hosting servers and , IPC facility  may include networking protocols (such as Internet Protocol, for example) and system calls whereby the communicating processes may establish a network connection. In other embodiments, clients  as well as servers  may be configured to run on a single machine, such as a large server system. In such embodiments IPC facility  may comprise an application programming interface (API) whereby client and server processes may directly interact with one another. It is contemplated that in some embodiments, IPC facility  may implement a combination of network connectivity and direct interprocess communications via one or more APIs.","Server processes  may in one embodiment be configured to implement one or more applications for processing transactions, such as transactions received from client processes or . A given server process  may be implemented in a programming language such as Java or C++, for example, and may be configured to interact with clients and via IPC facility  as well as data stores and via an API. Referring to the inventory management example cited above, upon receiving a sales transaction from a given client , a given server process may be configured to query data store to ascertain the current inventory level of the requested item. If the requested item is available, server process may update data store to reflect the effect of the sale on inventory, while if the requested item is not available, server process may notify the requesting client and may take further actions such as generating an order to replenish inventory, requesting customer information to generate a back-order record, or any other action. Server process may further be configured to update financial records stored in data store to reflect the effects of a sales transaction, such as by posting the actual sales price, terms of sale, discount applied, etc.","Data stores  may be configured to store data items on which server processes  may operate. In one embodiment, a given data store  may be configured as a relational database, storing data items in one or more tables including rows and columns, while in other embodiments given data store  may have a different data organization. Data stores and may also include software functionality for evaluating data queries submitted by server processes and and selecting data items to be returned in response to such queries, which functionality may be referred to as a query engine. Data stores  may provide an API through which a server process  may submit queries. For example, a given server process may interact with a given data store via the Java Database Connectivity (JDBC) standard API, the Open Database Connectivity (ODBC) standard API, or another API.","Although software system  has been described as a three-tier architecture, it is contemplated that in other embodiments, a different architecture may be employed. For example, in one alternative embodiment, client processes  and server processes  may be combined into a single software entity including both user interface and application logic functionality. In another embodiment, server processes  and data stores  may be combined into a single database\/application logic entity. Additionally, it is contemplated that in various embodiments, client processes , server processes , and data stores  may be configured to operate on one or more computer systems, as described in greater detail below. For example, in one embodiment client processes  may be configured to operate on respective point-of-sale computer systems, whereas server processes  and data stores  may be configured to operate on one or more server computer systems. Numerous other mappings of specific processes to computer system hardware are possible and contemplated.","Data Manipulation and Synchronization","In some embodiments of software system , numerous transactions may be in various states of completion at any given point in time. For example, at one point in time, client processes  may be submitting new status or transaction requests to the system on behalf of one or more users and\/or conveying results of previous requests to those users, while server processes  may be generating queries corresponding to previously received requests and data stores  may be evaluating previously received queries.","In one embodiment, server processes  may operate on data items stored within data stores  in a roughly synchronous fashion, such as by establishing and maintaining an interface connection with a pertinent data store  for the duration of a server processing operation, and updating the data store as results are generated by the operation. For example, a server process may implement an operation to read inventory data from data store , perform an analysis to determine whether to order additional inventory, and write data back to data store indicating the quantity and type of newly ordered inventory. In performing this operation, server process may be configured to open a connection to data store via an API, which may include establishing a network connection and providing user authentication information to data store . Server process may then use the established connection to query data store to retrieve the relevant inventory data, and may leave the connection open while performing its analysis. When new data is ready to be written to data store , server process may convey the new data via the previously established connection. Such a mode of operation may be referred to as a connected mode of operation.","Connected operation may allow a connected server process  to manipulate data items within a data store  without repeatedly incurring the overhead of establishing a connection to the data store. However, in some embodiments, data stores  may be capable of simultaneously servicing only a limited number of connections. In some such embodiments, system resources may be better utilized by allowing server processes  to obtain data and operate on it locally, in a disconnected fashion, prior to storing modified data items back to data stores . For example, in a system concurrently processing numerous transactions with variable operation latencies in server processes , allowing server processes to connect to data stores  only when data items need to be read or written may improve the ability of data stores  to service requests.","In one embodiment of a disconnect mode of operation, a given server process  may be configured to obtain a relevant subset of the data items stored in one or more data stores , such as by connecting to and querying the data store. Server process  may then be configured to disconnect from the data store and to store the obtained subset locally, such as in a buffer internal to server process , or as a distinct data object as described in greater detail below. The desired operations may then be performed on the locally stored, disconnected subset of data items.","The local, disconnected subset of data items may be transient, in that any changes made to the subset are not immediately reflected in the relevant data stores . Likewise, changes to data items within data stores  that correspond to data items within the disconnected subset (for example, changes due to modifications by other server processes ) may not be immediately reflected in the disconnected subset. Data stores  may be referred to as persistent, in contrast to the transience of a given disconnected data subset.","As a consequence of this transience, in some embodiments server processes  may be configured to retain the original value (prior to any local modification) of each value in a given local, disconnected subset, and to compare the original value of a given data item in the given disconnected subset against a corresponding item within a data store  to determine whether the data item was changed in data store  subsequent to being read into the disconnected subset. This process may be referred to as data synchronization, or simply synchronization.","Transparent Synchronization","Numerous possible variations of synchronization strategies are possible and contemplated, as set forth in greater detail below. For example, in one embodiment only data items that have been locally modified within a given disconnected subset may be synchronized, whereas in another embodiment all data items in the disconnected subset may be synchronized regardless of their modification status. Further, the type of strategy employed may vary according to the expected volatility of the data items being considered.","In embodiments where synchronization is implemented directly within the application functionality of server processes , the complexity of developing and validating that functionality may be increased. For example, each server process  may need to independently implement each synchronization strategy whose use is foreseeable at the time the application functionality is developed. Such independent implementations may contribute to redundant development effort and may increase the possibility of implementation error.","By contrast, in some embodiments the synchronization of modified disconnected data may be implemented transparently to the application process that modified the data.  illustrates one embodiment of a software system configured to provide transparent synchronization of a locally modified data subset. System  includes applications and , each of which interacts with a respective data subset object and . Synchronization of each data subset object is performed by a respective synchronization provider (SP) and . Both data subset objects and SPs are configured to interact with each of a plurality of persistent data stores and . It is contemplated that in various embodiments, system  may implement arbitrary numbers of applications , data subset objects , synchronization providers , and persistent data stores .","In the illustrated embodiment, applications  may be illustrative of server processes of . For example, applications  may be configured to generate queries to data stored in persistent data stores  and to locally process such data in response to requests from client processes, such as client processes  of . Applications  may allocate corresponding data subset objects  to store local, disconnected subsets of data items for application processing, wherein each data item stored within a given data subset object  may be a local copy of a data item stored in one of persistent data store . In some embodiments, an application may populate a given data subset object with a disconnected subset of data items by submitting a query specifying the desired subset to one or more of persistent data stores . Such a query may be formulated in any suitable query language, such as Structured Query Language (SQL), for example.","In one embodiment, data subset objects  may be rowsets structured as subsets of database tables, such as JDBC rowsets, for example. In some embodiments, data subset objects  may be object-oriented-programming (OOP) software objects and may include data as well as procedural methods. In other embodiments, data subset objects  may be implemented as simple buffers that may be allocated internally to their corresponding applications .","Synchronization providers  may be configured as software modules separate from applications . In the illustrated embodiment, a given SP  may be configured to monitor modifications to a given data subset object  by a corresponding application , and to synchronize the data items stored in data subset object  with their corresponding items stored within persistent data stores  according to a particular grade of synchronization. For example, as described in greater detail below, a given SP  may implement an optimistic grade of synchronization that assumes changes by other applications to data items within a given data subset object  are generally unlikely, or a pessimistic grade of synchronization that assumes that such changes are generally likely. It is noted that in the illustrated embodiment, synchronization activities performed by an SP  may occur without intervention on the part of corresponding application .","In some embodiments, a plurality of types of SP  may be provided, with each SP  configured to implement a particular grade of synchronization, and a given application  may be configured to select a specific SP  to be used dependent upon a desired grade of synchronization. For example, a given application  may have some information regarding volatility of a particular data subset object  and may select a specific SP  that implements a synchronization grade consistent with that information. In some embodiments, such an application  may select a SP  at the time data subset object  is instantiated or initialized, for example through a constructor method in embodiments where data subset object  is an OOP software object. In other embodiments an application  may assign or reassign an SP  to a data subset object  at any time. In some embodiments, if an application  does not specify a particular SP  when a given data subset object  is instantiated or initialized, a default SP  may be associated with the given data subset object .","Persistent data stores  may be illustrative of data stores  of . In various embodiments, persistent data stores  may be relational databases comprising one or more tables including data items organized in rows and columns. Alternatively, data items stored within persistent data stores  may be structured in other formats, such as self-describing data formats using tags to describe and delimit data items. For example, in one embodiment a given persistent data store  may use Extensible Markup Language (XML) tags to structure stored data items, although use of any suitable self-describing data format is contemplated. In some embodiments, a combination of different types of persistent data stores  may be employed. Generally speaking, data items stored in persistent data stores  are persistent in that they may be visible to any application . In contrast, data items stored within a given data subset object  may be transient, in that they may not be visible to applications  other than the particular application  corresponding to given data subset object  until those data items are synchronized with the relevant persistent data store .","In the illustrated embodiment, data subset objects  may be populated with data items that comprise subsets of one or more persistent data stores . Where a given data subset object  includes data items corresponding to more than one persistent data store , its corresponding SP  may be configured to synchronize each respective data item within data subset object  with its respective persistent data store .","Several exemplary embodiments of persistent data stores  and data subset objects  are illustrated in . In the illustrated embodiment, persistent data store includes a database table of financial information for a collection of products. Specifically, persistent data store includes columns designated \u201cproduct name,\u201d \u201csales price,\u201d \u201ccost,\u201d \u201cunits sold,\u201d \u201crevenue,\u201d and \u201cprofit\u201d as well as rows for each of five products designated A\u2013E. The intersection of each row and each column designates a data item that may store a particular value, such as a text value or a numerical value.","Data subset object , in the illustrated embodiment, corresponds to a subset of the data items stored in persistent data store . Specifically, data subset object includes columns designated \u201cproduct name,\u201d \u201ccost,\u201d \u201crevenue,\u201d and \u201cprofit,\u201d which columns are populated by data items corresponding to the row of persistent data store associated with product C. Data subset object might result from any of a number of queries submitted by an application such as application of . For example, such an application may submit a query requesting the data items \u201cproduct name,\u201d \u201ccost,\u201d \u201crevenue,\u201d and \u201cprofit\u201d corresponding to the row having \u201cproduct name\u201d equal to \u201cProduct C.\u201d Alternatively, such an application may submit a query for the same data items for any row having a \u201cprofit\u201d value between 500 and 700. Numerous other possible queries may result in the data values shown populating data subset object ","Persistent data store includes a database table of supplier contact information for a collection of products. In the illustrated embodiment, the table is formatted into rows and columns similar to those shown in persistent data store . Specifically, persistent data store includes columns designated \u201cproduct name,\u201d \u201csupplier name,\u201d and \u201csupplier address\u201d and rows for each of the aforementioned five products A\u2013E.","Data subset object differs from data subset object in the illustrated embodiment, in that data subset object includes data values corresponding to values stored in both persistent data stores and (i.e., data subset object results from a \u201cjoin\u201d of persistent data stores ). Specifically, data subset object includes a column \u201cproduct name\u201d common to both persistent data stores and , as well as a column \u201csupplier name\u201d corresponding to persistent data store and columns \u201cunits sold,\u201d \u201crevenue,\u201d and \u201cprofit\u201d corresponding to persistent data store . In the illustrated embodiment, data subset object is populated with data values corresponding to the respective rows of persistent data stores associated with product E. As with data subset object , data subset object may result from numerous possible queries submitted by an application.","It is noted that any of the exemplary embodiments of persistent data stores  may include more than one table, and that such tables as well as the data subset objects  described above may include different numbers and designations of rows and\/or columns, depending on implementation requirements. It is also contemplated that in various embodiments, data subset objects  of arbitrary complexity of rows and columns may result from queries selecting rows and columns from an arbitrary number of joined persistent data stores . Further, as noted previously, in some embodiments persistent data stores  and data subset objects  may include data formatted in other than a tabular structure, such as data formatted in a self-describing format, for example.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4","FIG. 1","FIG. 4"],"b":["400","150"]},"A given application may subsequently populate a local buffer or object with a subset of data items stored in the persistent data store (block ). For example, in one embodiment an application  may submit a query to one or more persistent data stores  to obtain a subset of data items, which may then be used to populate a data subset object . As described above, data subset object  may be a rowset object in some embodiments, such as a JDBC rowset object, for example.","The given application may also specify a particular synchronization provider to be used to synchronize the local data subset (block ). For example, in one embodiment application  may specify a particular SP  at the time data subset object  is instantiated, or alternatively at a later time. Additionally, application  may select SP  from a plurality of synchronization providers according to a desired grade of synchronization.","Following population of the local data subset, the given application may modify one or more data items included in the local data subset (block ). For example, application of  may be configured to modify the \u201ccost\u201d and \u201cprofit\u201d data items stored within data subset object of  in response to a transaction initiated by a user to adjust inventory costs.","Subsequent to modification of the local data subset, the selected synchronization provider may synchronize the modified local data items with the corresponding data items stored within the relevant persistent data store, where the synchronization occurs transparently to the modifying application (block ). For example, in one embodiment application  may issue a commit operation to the selected SP  subsequent to modifying data. In response to detecting the commit operation, SP  may synchronize the corresponding data subset object  according to a particular synchronization grade. Alternatively, SP  may synchronize data subset object  without detecting a commit operation. For example, SP  may synchronize data subset object  after detecting that a given number of data items stored therein have been modified, or after detecting that a given interval of time has elapsed since a previous synchronization. In any case, the specific synchronization of a given data item of data subset object , such as by comparing the original, unmodified value of the data item with the current value of the corresponding data item within persistent data store , may be performed entirely by SP , transparently to the modifying application .","Synchronization Grades","As noted above, in some embodiments of system  multiple synchronization providers  may be available, from which a given application  may select a particular SP  dependent on the synchronization grade it provides. By selecting a synchronization grade that corresponds to the expected volatility of the selected data items in a given data subset object , system resources may be more optimally distributed. For example, in one embodiment, synchronization of modified local data may not be required because the underlying persistent data store  does not support techniques for ensuring coherence of multiple data writers (e.g., certain XML implementations). In such an embodiment, an SP  that performs no synchronization, but rather simply propagates modified data items in a given data subset object  directly into the corresponding persistent data store , may be selected, and the computational overhead associated with synchronization may be avoided.","In other cases, a particular SP  implementing an optimistic or pessimistic synchronization grade may be selected depending on the likelihood that data items within corresponding data subset object  will be modified by other applications . For example, a particular application may be configured to perform an operation on a data field (e.g., a row or column, or other general record type) within a given persistent data store , which data field is rarely (or alternatively, often) accessed by other applications . Correspondingly, application may select an instance of SP  that provides an optimistic (or alternatively, pessimistic) synchronization grade.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 5","FIG. 2","FIG. 5","FIG. 4"],"b":["500","110","120","120","130"]},"At some point after modification of data subset object , SP  may begin synchronizing (block ). For example, given application  may convey a commit operation to SP , or SP  may detect some other criterion for synchronization, such as the expiration of a specified interval of time since the last synchronization.","SP  may then synchronize each modified data item within data subset object . In one embodiment, SP  may determine whether a difference exists between an original, pre-modification value of a given modified data item within data subset object  and the corresponding data item stored in persistent data store  (block ). If no difference exists, SP  may update persistent data store  to reflect the data item as modified within data subset object  (block ). If a difference does exist, SP  may notify given application  that a conflict has occurred (block ). In some embodiments, SP  may check all modified data items and update persistent data store  in each case that no conflict is detected, while in other embodiments, SP  may abort synchronizing after the first conflict is detected.","Additionally, in some embodiments SP  may determine whether a difference exists between an unmodified data item within data subset object  and the corresponding data item stored in persistent data store  (block ). If such a difference is detected, SP  may update the data item within data subset object  with the value indicated in persistent data store  (block ). For example, even though given application  may not have modified a particular data item within data subset object , that data item may have been modified within persistent data store  by a different application  subsequent to initialization of data subset object . In some instances, given application  may require that all data items within data subset object  be current with respect to the relevant persistent data store . If no difference is detected at block , or if the embodiment of SP  does not implement synchronization of unmodified local data, synchronization is complete at block .","As just illustrated, optimistic synchronization grades may generally assume that conflicts where multiple applications attempt to write the same data item to a given persistent data store  will not occur, and may generally make no attempt to prevent conflicts from occurring. In contrast, pessimistic synchronization grades may generally assume that such conflicts are likely, and may attempt to prevent them. In some embodiments, SPs  that implement pessimistic synchronization grades use locks of varying scope to prevent conflicts from occurring.","Generally speaking, a lock may be a convention employed by a data source, such as a persistent data store , configured to coordinate access to one or more data items. For example, a lock may be a semaphore or status field stored within persistent data store  along with data items that may be asserted or deasserted to indicate the status of the lock. In various embodiments, locks may be implemented with differing degrees of granularity. For example, a given persistent data store  may be configured to support locking of individual data items. Further, if persistent data store  organizes data into tables including rows and columns, locking of entire rows, columns, or tables may be supported, as may the entirety of persistent data store . In some embodiments, more than one of these types of locks may be concurrently available. Further, it is contemplated that in some embodiments, locks having granularity other than the types just described may be employed.","One embodiment of operation of a pessimistic synchronization grade employing locks is illustrated in . Referring collectively to  and , operation begins in block  where a given application  populates a local, disconnected data subset object  with one or more data items, such as in response to a query of one or more persistent data sources  as described previously. As in the optimistic synchronization embodiment described previously, it is noted that in one embodiment, the data subset object  may have been previously allocated and a corresponding SP  previously selected as illustrated in the method of .","In response to given application  populating data subset object  with data items, SP  may be configured to attempt to lock the corresponding data items within their respective persistent data stores  (block ). In one embodiment, locking a data item within a persistent data store  may include SP  querying that persistent data store  to determine whether the data item has already been locked, such as by a different SP  on behalf of a different application . If no previous lock exists, the locking attempt may succeed. For example, persistent data store  may return an indication to SP  indicating lock success or failure.","After attempting to lock a given data item, SP  may determine whether it successfully obtained a lock (block ). If so, given application  may proceed to modify the data items within data subset object  (block ). At some point after modification of data subset object , SP  may begin synchronizing (block ). For example, given application  may convey a commit operation to SP , or SP  may detect some other criterion for synchronization, such as the expiration of a specified interval of time since the last synchronization.","For modified data items within data subset object  for which locks were successfully obtained, SP  may be configured to update persistent data store  to reflect those data items as modified within data subset object  (block ). In one embodiment, no further comparison to determine whether a difference exists between the original, pre-modification value of the locked modified data item and the corresponding data item stored in persistent data store  may be necessary, as the lock may ensure that the data item stored in persistent data store  remains unmodified by another SP .","If SP  did not successfully obtain a lock for a given data item within data subset object , in one embodiment SP  may prevent given application  from modifying that given data item (block ) while SP  continues attempting to obtain a lock (block ). For example, SP  may convey an indication to given application  that the unlocked data item is not writable. If a lock is ultimately obtained, execution may proceed from block , where given application  may modify the locked data items within data subset object .","Subsequent to synchronization, given application  may deallocate data subset object  (block ) in response to which SP  may release locks held on corresponding data items within persistent data store  (block ).","In the aforementioned locking protocol embodiment, locks are generally mandatory, in that modification of a data item by an application  may not occur until a lock is obtained. However, numerous other possible embodiments of lock implementations are possible and contemplated. For example, in one alternative embodiment, SP  may check the status of a lock prior to synchronizing a corresponding given data item. If a previously obtained lock is no longer asserted, SP  may compare the original value of a modified data item within data subset object  with the corresponding value within the relevant persistent data store  to check for conflicts, as described above in the embodiment illustrated in . In such an embodiment, given application  may proceed to modify a given data item within data subset object  even though SP  was not able to obtain a lock for the given data item. In this case, SP  may instruct persistent data store  to deassert the existing lock, and may also perform the conflict-detection comparison described above when synchronizing the given data item. In such an alternative embodiment, locks are generally advisory, in that a lock may not be guaranteed to be held until released (i.e., deasserted) by the original lock requester, but rather may be \u201cbroken\u201d by a subsequent lock requester.","In still another embodiment, SP  may be configured to attempt to lock a given data item only when a given application  modifies that data item within data subset object , rather than attempting to lock each data item at the time data subset object  is populated. Further, in such an embodiment, SP  may be configured to release a previously granted lock following synchronization of the modified data item with persistent data store , rather than releasing such locks when given application  deallocates data subset object .","Numerous other variants of optimistic and pessimistic synchronization grades are possible and contemplated. It is noted that, as illustrated in the previously described embodiments, a given application  may be configured to select a desired synchronization grade for a given data subset object  by selecting a particular SP  to synchronize that object. Further, it is noted that the actual procedural steps of synchronizing that object may be performed by the selected SP , rather than by given application  itself.","Resolving Synchronization Conflicts","As described above, in some instances a synchronization provider may detect a conflict in the process of synchronizing a particular data item. In some embodiments, upon detecting a conflict, a given SP  may indicate the conflict to the corresponding application . For example, SP  may generate or \u201cthrow\u201d an exception that is then conveyed to or \u201ccaught\u201d by corresponding application .","In some embodiments, additional information about the conflict may be provided to application . For example, in one embodiment SP  may be configured to create a new data subset object , which may be referred to as a resolver object, in response to detecting a conflict associated with synchronizing a data item of an existing data subset object . A given resolver object  may be configured with the same data structure as its corresponding data subset object ; for example, the two may share the same number of data rows and columns. In one embodiment, a given resolver object  may include only those values from persistent data store(s)  for which a conflict occurred when attempting to synchronize corresponding data subset object , while setting all nonconflicting data items to a default or null value. In another embodiment, a given resolver object  may include all corresponding values from persistent data store(s)  while indicating conflicting data items, such as by flagging conflicting items.","In addition to the values of conflicting data items, resolver object  may include additional information regarding the source of the conflict. In one embodiment, resolver object  may define one or more additional data fields corresponding to each data item, where the additional data fields indicate the type of operation that was underway at the time the conflict was detected. For example, resolver object  may indicate via the additional data fields that a given data item of corresponding data subset object  was being inserted into, deleted from, or simply updated within a given persistent data store . Broadly speaking, any information regarding the source of a particular conflict may be referred to as conflict status information.","In some embodiments in which locks are supported as described above, resolver object  may variously attempt to lock rows, columns, tables, or the entirety of the persistent data store  corresponding to each conflicting data item, according to the lock implementation. Such locking of conflicting data items may simplify conflict resolution by preventing other applications  from modifying data items known to at least one application  to be in conflict.","An application  may be configured to utilize a resolver object  to resolve synchronization conflicts when they occur. In one embodiment, when notified of a conflict (such as by catching an exception thrown by SP , for example) an application  may interact with resolver object  to identify the conflicting data items and reasons for the conflict. In some embodiments, resolver object  may present the same types of methods of navigation as do data subset objects , such as methods for navigating to a particular row or column in absolute and\/or row- or column-relative terms. In some instances, data item conflicts may be infrequent, and a given resolver object  configured to store only conflicting data items may be correspondingly sparse. Therefore, in some embodiments, additional navigation methods for resolver object  may be provided that may, for example, more efficiently navigate to rows and\/or columns including conflict values while skipping those that do not.","After navigating resolver object  to retrieve available information regarding a conflict, application  may be configured to choose how to resolve the conflict. For example, application  may determine that the data value in data subset object  is the value that should be persisted within persistent data store . Alternatively, application  may discard the conflicting data item stored within data subset object  in favor of the copy of the conflicting data item stored within resolver object  (i.e., the data value reflected within persistent data store  at the time the conflict was detected). In some embodiments, resolver object  may present methods whereby application  may specify a data value to be persisted. In such embodiments, resolver object  may interact with SP  to overwrite the data item in the data store accordingly. In other embodiments, application  may interact directly with SP  to specify data values to be persisted after obtaining conflict information from resolver object . In some embodiments, if application  determines that it should discard the value in data subset object  in favor of the value in resolver object , application  may be configured to take further action. For example, in such a case application  may be configured to recompute other data items whose values depend on the conflicting data item.","Exemplary Computer System","Referring once again to , as described above, in various embodiments any of the software modules shown as part of software systems  and  may be executed on one or more computer systems. One exemplary embodiment of a computer system is illustrated in . In the illustrated embodiment, computer system  includes a processor  coupled to a system memory  via interface logic .","Processor  may be any type of processor. In some embodiments, processor  may be a general-purpose microprocessor that implements one or more instruction set architectures such as x86, Power\/PowerPC, SPARC, or any other suitable architecture or variant thereof. In other embodiments, processor  may be an embedded processor, a digital signal processor, or another processor capable of executing instructions. In the illustrated embodiment, processor  may be configured to access system memory  or another device to store and retrieve program instructions and data.","Interface logic  may be configured as bridge logic. In some embodiments, interface logic  may function as a \u201cnorth bridge\u201d coupling processor  and system memory , and may be configured to translate memory access requests originating from processor  to the appropriate format for system memory  and vice versa. In such an embodiment, interface logic  may also be configured for coupling to other peripheral buses to which peripheral devices may be attached, such as graphics adapters, storage devices, network interfaces, and other such devices. In some embodiments, interface logic  may couple to a \u201csouth bridge\u201d interface circuit (not shown), which may be configured for coupling to additional peripheral devices such as pointing devices, keyboards, etc. In other embodiments, interface logic  may incorporate all peripheral interface logic in addition to providing a memory interface. It is contemplated that in some embodiments, all or part of interface logic  may be incorporated into processor .","System memory  may include any of various types of memory technologies, or combinations thereof. In some embodiments, system memory  may be largely comprised of some variant of synchronous dynamic RAM (SDRAM), but in other embodiments static RAM (SRAM) or another RAM technology may be used. In some embodiments, system memory  may include additional resources for error detection and\/or correction, such as parity bits or error correcting code (ECC) bits, which may be separate from resources dedicated to storage of data or instructions.","In some embodiments, system memory  may be one embodiment of a computer-accessible medium configured to store program instructions executable by processor  as well as data accessible by processor . The program instructions and data may comprise any software program, module or application, such as any of the software modules illustrated in  or , for example. Such program instructions and data are illustrated as code  within system memory  in the illustrated embodiment. However, in other embodiments, program instructions and\/or data may be received, sent or stored upon different types of computer-accessible media. Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, such as may be coupled to computer system  through interface logic , for example. A computer-accessible medium may also include volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc, such as may be included within system memory . Further, a computer-accessible medium may include transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
