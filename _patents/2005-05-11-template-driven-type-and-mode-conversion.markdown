---
title: Template driven type and mode conversion
abstract: Techniques for providing type (and/or mode) conversion of parameters for software applications are provided. In general, a type conversion utility accesses a template that defines type and mode conversions for parameters between different components. The type conversion utility utilizes information stored in the template for that direct how the parameters will be converted. Additionally, techniques are provided for returning output values.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07860894&OS=07860894&RS=07860894
owner: Oracle International Corporation
number: 07860894
owner_city: Redwood Shores
owner_country: US
publication_date: 20050511
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims priority to U.S. Provisional Application 60\/570,344, filed May 12, 2004, which is hereby incorporated by reference for all purposes.","The present invention relates to computer systems. More specifically, the invention relates to providing template driven type and mode conversion for parameters in software applications.","Soon after the development of programming languages for computers, the concept of modular programming was developed. Modular programming encourages designing and writing programs as interactions among functions where each performs a single well-defined function.","For example, a call is made to a function. The function call typically specifies one or more parameters (or arguments). Each parameter has a specified type, which defines the meaning of the value of the parameter. The one or more bits passed in as a parameter are interpreted according to the format specified by the type (e.g., integer, floating point, string). In modern programming languages, there are a myriad of different types specified by standards, but the type refers to the format that should be utilized to give the bits meaning and therefore their value.","Parameters can also have different modes. The mode defines the relationship of the parameter between the caller and the callee (or function). For example, an \u201cin\u201d parameter is a parameter that is an input to the function. Even if the function modifies the parameter during execution, the modification will not affect the parameter from the caller's end.","An \u201cout\u201d parameter is a parameter that is an output of the function. Typically, the caller provides a pointer to a memory location (e.g., address) and the function writes the return value at that location. As with \u201cin\u201d parameters, the format of the parameter is specified by the type. Lastly, an \u201cin out\u201d parameter is one that is both an input and an output.","The above describes the basic initial concepts, but it may be beneficial to describe a typical, more complex application.  shows a database environment that uses different interfaces between components. A database  includes the hardware and software for performing, among other things, database queries. A Java virtual machine  executes computer programs that can interact with database .","As shown, Java Database Connectivity (\u201cJDBC\u201d) provides Application Programming Interfaces (\u201cAPIs\u201d) for Java that supports Structure Query Language (\u201cSQL\u201d) commands to database . Additionally, SQLJ can be utilized to embed SQL statements in Java source code that interacts with JDBC. As is known, the APIs for JDBC have a defined call structure including parameter types and modes.","As shown, web services  of a web server communicates with Java virtual machine  utilizing Apache web service types and modes. Extensible Markup Language (\u201cXML\u201d)  is utilized to communicate input and output to web services  as specified by XML schemas.","Database  may have stored procedures that it would be desirable to access from web services . However, there may be call mismatches, such as parameter type and mode, that make this difficult. For example, the Oracle database system has stored procedures written in Procedural Language extensions to SQL (\u201cPL\/SQL\u201d), which is different than web service types such as XML values used by Apache. A conversion may need to be performed in order to allow calls from web services  to stored procedures in database .","Additionally, PL\/SQL supports parameters of in, out and in out. However, JDBC that provides calling mechanisms to database  sends a copy of each parameter. If the parameter is modified, a copy of the modified parameter is returned. Thus, the \u201cbefore\u201d and \u201cafter\u201d values of the parameter appear in separate objects. This creates a mode inconsistency between these parameters.","One solution is for the programmer to manually write Java classes in order to allow access (or publish) to the stored procedures in database  by web services . Unfortunately, this solution is very time consuming and prone to errors.","A utility know as JPublisher has been developed by Oracle Corporation in order to, among other things, facilitate accessing SQL objects and PL\/SQL in database . Although JPublisher has met with extreme success, interfaces to PL\/SQL procedures are still manually created in many cases because the data types used by JDBC, and the way in which \u201cout\u201d or \u201cin out\u201d arguments are treated necessitates writing code by hand to match the intended usage.","Accordingly, it would be beneficial to have innovative techniques automatically publishing stored procedures of a database for use by other applications. Additionally, it would be beneficial to provide type and mode conversions where desired.","The present invention provides innovative techniques for providing type and\/or mode conversion of parameters for software applications. In general, a type conversion utility accesses a template that defines type and mode conversions for parameters. The type conversion utility utilizes information stored in the template that direct how the parameters will be converted. This provides great flexibility in publishing procedures and can be done efficiently as the manual writing code for this purpose is not necessary. The main use of the application is in the type and mode conversions between different models for desired type and mode representations. It encompasses different models between different programming languages, as well as different models of type and mode mapping in the same programming language. Some specific embodiments of the invention are described below.","In one embodiment, the invention provides a method of converting types of parameters between two applications utilizing different types. A first type is received for a parameter from a first application to be sent to a second application utilizing different types. A template is retrieved that specifies a conversion of the first type to a second type for the second application. The first type is converted to the second type as specified in the template and the parameter is passed to the second application as the second type. In addition, a returned data type can be converted as specified in the template.","In another embodiment, the invention provides a method of returning an output value as a parameter. An array is declared and a before value of a parameter is assigned to an element of the array. The array is passed to a wrapper method. An underlying method of the wrapper method is then executed. An after value of the parameter is assigned to an element of the array. Lastly, the after value of the parameter is extracted from the array.","An embodiment of the invention in the JPublisher product utilizes this template-driven mechanism to create Java language sources that implement an API for invoking stored procedures running in an Oracle database and implemented in PL\/SQL. The advantage of the template mechanism lies in the fact that different mode and type models can be mapped, simply and quickly by switching, modifying, or extending the template. This invention is not limited to a particular programming language, to particular type models, or to particular models for representing modes.","Other features and advantages of the invention will become readily apparent upon review of the following description and association with the accompanying drawings, where the same or similar structures are designated with the same reference numerals.","In the description that follows, the present invention will be described in reference to embodiments that provide template driven type and mode conversion for software applications. Additionally, embodiments will be described in terms of a three-tiered database architecture such as is available from Oracle Corporation, Redwood Shores, Calif. However, embodiments of the invention are not limited to any particular architecture, language, environment, application, or implementation. For example, although some embodiments utilize stored procedures in specific languages, the invention can be advantageously applied to any programming language or environment. Therefore, the description of the embodiments that follows is for purposes of illustration and not limitation.","A fairly common database management system architecture is the three-tiered architecture that is shown in . At the core of the database management system is a central storage  that stores a database . Database  is typically stored on one or more hard drives, which is typically part of a larger computer system. The information can be stored on database  in a variety of formats with relational database management systems relying heavily on tables to store the information.","Database servers  are instances of a program that interacts with database . Each instance of the database server can, among other things, independently query database  and store information therein. Database servers  may not include user friendly interfaces to access database . Database  and database servers  comprise the lowest tier of the hierarchy.","One or more application server  can provide the user interfaces to database server . For example, application server  can be a web application server on the Internet (or other network). Application server  can accept commands from users for accessing database  through database server . As an example, application server  can be an SQL server. Thus, application server  is in the middle tier of the hierarchy.","Although application server  can accept user commands, a web browser  (or other client application) can be utilized to access application server  through a user-friendly interface. Web browser  is an example of an application in the highest tier in the hierarchy.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3","b":["101","103","103","105"]},"A fixed storage  can store computer programs and data such that it is typically persistent and provides more storage when compared to memory . At present, a common fixed storage for databases is multiple (e.g., arrays) hard drives. A removable storage  provides mobility to computer programs and\/or data that are stored thereon. Examples of removable storage are floppy disks, tape, CD\/ROM, flash memory devices, and the like.","Memory , fixed storage  and removable storage  provide examples of computer readable storage media that can be utilized to store and retrieve computer programs incorporating computer codes that implement the invention, data for use with the invention, and the like. An input  allows a user to interface with the system. Input can be done through the use of a keyboard, a mouse, buttons, dials, or any other input mechanism. An output  allows the system to provide output to the user. Output can be provided through a monitor, display screen, LEDs, printer or any other output mechanism.","A network interface  allows the system to interface with a network to which it is connected. The system bus architecture of computer system  is represented by arrows . The components shown in  can be found in many computer systems. However, components can be added, deleted and combined. For example, fixed storage  could be a file server that is accessed through a network connection. Thus,  is for illustration purposes and not limitation.","Now that exemplary database applications and environments have been described, it may be beneficial to discuss embodiments of the invention. Although specific embodiments are described, features can be added and combined without departing from the spirit and scope of the invention. For example, features from more than one of the embodiments can be advantageously implemented in other embodiments.","Embodiments of the invention can convert simultaneously both, modes of parameters between two different models of representing modes, as well as types of parameters between two different models of representing types. The \u201couter function\u201d will refer to the function that utilizes the first (or \u201couter\u201d) parameter type and mode model. The \u201cinner function\u201d will refer to the function that utilizes the second (or \u201cinner\u201d) parameter type and mode model. A template is used for driving the automatic creation of an application that implements the outer function and that in turn invokes the inner function.","The following describes the principles for conversion between parameter types in the first (outer) model and parameter types in the second (inner) model. For every parameter type or possibly sets of parameter types in the outer model, the template includes, among others, definitions of the following:\n\n","In one embodiment of the invention the inner parameter mode model utilizes arrays to represent \u201cout\u201d or \u201cin out\u201d values. In that particular embodiment the inner parameter mode and type model may, for example, utilize a particular style of Java code generated for invoking PL\/SQL stored procedures in an Oracle database via JDBC.",{"@attributes":{"id":"p-0047","num":"0048"},"figref":"FIG. 4","b":["151","153","155"]},"Although  shows both a type and mode conversion, embodiments can implement type or mode conversion. The following will describe different variants of the steps of  in more detail.","A first variant of step  is described herein. The following description of the template-driven conversion process of will be common when the inner parameter mode utilizes arrays to represent \u201cout\u201d or \u201cin out\u201d values. For parameters with \u201cout\u201d or \u201cin out\u201d modes, a one-element array of type array parameter type of inner type model is declared. For parameters with \u201cin\u201d modes, a variable of type parameter type of inner type model is declared instead. The outer-to-inner conversion expression is constructed as follows:\n\n","A second variant of step  is described herein. The following description of the template-driven conversion process will be common when the inner parameter mode utilizes holders to represent \u201cout\u201d or \u201cin out\u201d values. For parameters with \u201cout\u201d or \u201cin out\u201d modes, a corresponding holder instance of parameter type of inner type model is defined. If the holder type of parameter type of inner type model is neither predefined nor previously defined, then define it. For parameters with \u201cin\u201d modes, a variable of type parameter type of inner type model is declared instead. The outer-to-inner conversion expression is constructed as follows:\n\n","A third variant of step  is described herein. The following description of the template-driven conversion process will be common when the inner parameter mode utilizes a compound return type to represent \u201cout\u201d and \u201cin out\u201d values as well as a return value (if any). For parameters with \u201cout\u201d or \u201cin out\u201d modes and for the return value, a corresponding compound type is declared. This compound type holds instances (fields, attributes) for each \u201cout\u201d and \u201cin out\u201d parameter is of type parameter type of inner type model. If the inner function returns a value, then this compound type also holds an instance for the return value of type return type of inner type model. Typically, the names of the instances (attributes, fields) of this compound type could be derived from the parameter names. For parameters with \u201cin\u201d modes and for parameters with \u201cin out\u201d modes a variable of type parameter type of inner type model is declared. The outer-to-inner conversion expression is constructed as follows:\n\n","At step , the inner-to-outer conversion expression for all \u201cout\u201d and \u201cin out\u201d parameters and the return, if any, of the inner method, is constructed similarly to what was described earlier. This time, the inner placeholder in the inner-to-outer conversion expression is replaced by the \u201cafter value.\u201d The \u201cafter value\u201d is obtained as follows. In the particular case where the inner parameter mode uses one-element arrays to represent \u201cout\u201d and \u201cin out\u201d arguments, the \u201cafter value\u201d is obtained by accessing the first element of the array. In the particular case where the inner parameter mode uses holders to represent \u201cout\u201d and \u201cin out\u201d arguments, the \u201cafter value\u201d is obtained by retrieving the underlying value in the holder. In both of these cases, the return value (if any) is directly retrieved from the invoked function. In the case where the inner parameter mode uses the return value to represent \u201cout\u201d and \u201cin out\u201d arguments, a structured type with components consisting of an attribute for the return value (if any), and an attribute each for all \u201cout\u201d and \u201cin out\u201d parameter values would be returned, and the \u201cafter value\u201d is obtained by accessing the specific return or parameter attribute.","The following describe cases for the outer parameter mode model for \u201cout\u201d and \u201cin out\u201d parameters.\n\n",{"@attributes":{"id":"p-0054","num":"0085"},"figref":["FIG. 5","FIG. 1"],"b":["211","213","211"]},"As shown, Java Database Connectivity (\u201cJDBC\u201d) provides Application Programming Interfaces (\u201cAPIs\u201d) for Java that supports Structure Query Language (\u201cSQL\u201d) commands to database . Additionally, SQLJ can be utilized to embed SQL statements in Java source code that interacts with JDBC. As is know, the APIs for JDBC have a defined call structure including parameter types and modes.","Web services  of a web server communicate with Java virtual machine  and XML  is utilized to communicate input and output to web services  as specified by XML schemas.","A type conversion utility  is responsible for performing type and\/or mode conversions of parameters as specified by a template . As will be described below, there may be multiple templates, but one is shown for simplicity.","Type conversion utility  can be written in the Java programming language and therefore interact with Java virtual machine . However, the type conversion utility can be implemented in any programming language. Template  specifies, among other things, mappings between source types and target types. Additionally, template  can include computer code for performing actions for the conversion, where desired.","Thus, stored procedures on database  may be conveniently published through wrapper methods (a wrapper method \u201cwraps\u201d an underlying method and may include computer code before and\/or after the call to the underlying method) by specifying type conversions for the stored procedures in template . As web services  access the stored procedures through the wrapper methods, type conversion is provided as specified in template .",{"@attributes":{"id":"p-0060","num":"0091"},"figref":"FIG. 6"},"At a step , a first type for a parameter from a first application is received. The parameter is to be sent to a second application that utilizes different types than the first application. A template is retrieved that specifies a conversion of the first type to a second type for the second application at a step . The template can specify mappings from source types to target types.","The first type is converted to the second type as specified in the template at a step . At a step , the parameter is passed to the second application as the second type. Although the flowchart in  is directed to type conversions, a similar process can be performed for mode conversions, which can also be specified in a template.","After the second application finishes, the return data from the second application, if any and if necessary, is converted to a type that is supported by the first application. Such mapping, from the target type to the source type, is also defined in the template.","An embodiment of the invention can be implemented in the JPublisher utility (from Oracle Corporation) that uses the Oracle SQLJ (\u201cSQL in Java\u201d) implementation, generating SQLJ code as an intermediate step in most circumstances\u2014whenever wrapper methods are created, either for classes representing PL\/SQL packages or for classes representing SQL object types that define methods (PL\/SQL stored procedures). In these circumstances, JPublisher uses the Oracle SQLJ translator during compilation, and the Oracle SQLJ runtime during program execution. In addition to mapping SQL objects, the entire PL\/SQL packages can be encapsulated as Java classes. JPublisher offers functionality to create Java wrapper methods for the stored procedures of a PL\/SQL package.","The concept of representing PL\/SQL stored procedures as Java methods can present problems, however. Arguments to such functions or procedures may use the PL\/SQL mode \u201cout\u201d or \u201cin out,\u201d but there are no equivalent modes for passing arguments in Java. A method that takes an int argument, for example, is not able to modify this argument in such a way that its callers can receive a new value for it.","In one embodiment, JPublisher generates single-element arrays for out and in out arguments. For an array int[ ] abc, for example, the input value is provided in abc[0], and the modified output value is also returned in abc[0]. JPublisher also uses a similar pattern when generating code for SQL object type methods.","To publish database entities, JPublisher connects to the database and retrieves descriptions of SQL types, PL\/SQL packages, or server-side Java classes that can be specified on the command line or in an INPUT file.","JPublisher generates a Java class for each SQL type or PL\/SQL package that it translates, and each server-side Java class that it processes. Generated classes include code required to read objects from and write objects to the database. When a wrapper method on an instance of a class that was generated for a SQL object is called, the SQL value for the corresponding object is sent to the server along with any in or in out arguments. Then the underlying method (stored procedure or function) is invoked, and the new object value is returned to the client along with any out or in out arguments.","The JPublisher code that is generated is in terms of parameter types and modes are the inner parameter type and mode methods. The generated Java code typically ends up with a different type and\/or mode model than the code that is desired by the user, which are the outer parameter and mode methods. Embodiments of the invention allow efficient translation between these two, when desired.","JPublisher style files allow Java-to-Java type mappings to be specified. This is to ensure, for example, that generated classes can be used in Web services. As a particular example, CLOB types such as java.sql.Clob and oracle.sql.CLOB cannot be used in Web services, but the data can be used if converted to a type, such as java.lang.String, that is supported by Web services.","Typically, templates or style files are provided by Oracle, but there may be situations in which a user would want to edit or create her own. The key portion of a style file is the TRANSFORMATION section\u2014everything between the TRANSFORMATION tag and END_TRANSFORMATION tag. This section describes type transformations (Java-to-Java mappings) to be applied to types used for object attributes or in method signatures.","For convenience, there is also an OPTIONS section in which any other JPublisher option settings can be specified. In this way, a style file can replace the functionality of any other JPublisher properties file, in addition to specifying mappings.","This Style File TRANSFORMATION Section provides a template for a style file TRANSFORMATION section, with comments. Within the TRANSFORMATION section, there is a MAPPING section (from a MAPPING tag to an END_MAPPING tag) for each mapping that is specified. Each MAPPING section includes a number of subtags with additional information. SOURCETYPE and TARGETTYPE subtags are required. Within each TARGETTYPE section, information for at least the RETURN, IN, and OUT cases, using the corresponding tags should be specified.","Below is a high-level outline of the template format and of the various pieces of information that can be supplied in the template.","TRANSFORMATION","IMPORT","# Packages to be imported by the generated classes","END_IMPORT","# THE FOLLOWING OPTION ONLY APPLIES TO PL\/SQL PACKAGES","# This interface should be implemented\/extended by","# the methods in the user subclasses and interfaces","# This option takes no effect when subclass is not generated.","SUBCLASS_INTERFACE<java interface>","# THE FOLLOWING OPTION ONLY APPLIES TO PL\/SQL PACKAGES","# Each method in the interface and the user subclass should","# throw this exception (the default SQLException will be caught","# and re-thrown as an exception specified here)","# This option takes no effect when subclass is not generated.","SUBCLASS_EXCEPTION Java_exception_type","STATIC","# Any code provided here is inserted at the","# top level of the generated subclass regardless","# of the actual types used.","END_STATIC","# Enumerate as many MAPPING sections as needed.","MAPPING","SOURCETYPE Java_source_type","# Can be mapped to several target types.","TARGETTYPE Java_target_type","# With CONDITION specified, the source-to-target","# mapping is carried out only when the listed Java","# classes are present during publishing.","# The CONDITION section is optional.","CONDITION list_of_java_classes","IN","# Java code for performing the transformation","# from source type argument %1 to the target","# type, assigning it to %2.","END_IN","IN_AFTER_CALL","# Java code for processing IN parameters","# after procedure call.","END_IN_AFTER_CALL","OUT","# Java code for performing the transformation","# from a target type instance %2 to the source","# type, assigning it to %1.","END_OUT","RETURN","# Java code for performing the transformation","# from source type argument %1 to the target","# type and returning the target type.","END_RETURN","# Include the code given by a DEFINE . . . END_DEFINE block","# at the end of this template file.","USE defined_name","# Holder for OUT\/INOUT of the type defined by SOURCETYPE.","HOLDER Java_holder_type","END_TARGETTYPE","# More TARGETTYPE sections, as needed","END_MAPPING","DEFAULT_HOLDER","# JPublisher will generate holders for types that do","# not have HOLDER entries defined in this template.","# This section includes a template for class definitions","# from which JPublisher will generate .java files for","# holder classes.","END_DEFAULT_HOLDER","# More MAPPING sections, as needed","DEFINE defined_name","# Any code provided here is inserted at the","# top level of the generated class if the","# source type is used.","END_DEFINE","# More DEFINE sections, as needed","END_TRANSFORMATION","The details about templates or style files are provided to illustrate an exemplary embodiment. Other embodiments may utilize different templates so the invention is not limited to the embodiments described herein.\n\n","By using a template mechanism, the JPublisher product can easily be adapted to generate code for different platforms:\n\n","For convenience, in the concrete JPublisher embodiment, templates can include other templates using an INCLUDE directive. For example, webservices-common.properties is used by webservices.properties and webservices.properties. Additionally, via the OPTIONS section, the templates in the concrete JPublisher embodiment are enabled to provide directives into JPublisher, such as the style for the representation of out and in out arguments. For example, jpub.outarguments=return specifies that out, in out, and return values be represented through a compound return type in the outer method representation.","The TRANSFORMATION section consist of a sequence of MAPPING directives that map between SOURCETYPE (described as the outer parameter or return type in the rest of this document) and the TARGETTYPE (described as the inner parameter or return type in the rest of this document). In some cases it need only be noted that a particular predefined HOLDER is to be employed. In some cases patterns are employed to define whole families of conversions. A pattern may, for example, use %p to correspond to the package name, and %c to correspond to the class name.","If the identity constitutes the conversion function, then no conversion expressions need to be defined. Otherwise the code fragment between IN and END_IN defines the conversion from the outer type to the inner type, where the placeholders %1 and %2 stand in for instances of outer and, respectively, inner types that may be appropriately replaced with expressions or variables, depending on the concrete type and mode representation in effect.","Conversely, code fragments between OUT and END_OUT define conversion expressions in the opposite directions from an inner type to a corresponding outer type. Again, placeholders %1 and %2 stand in for instances of the outer type and, respectively, for the inner type.","Additional facilities used in the concrete embodiment of the template-driven type and mode conversion in the JPublisher product are as follows:\n\n","The DEFAULT_HOLDER segment provides a generic definition of holder classes, as well as code fragments that define how values are inserted into or extracted from the generated holder class in the various cases that we have described.","In the following we provide additional details on the template-driven type and mode conversion as embodied in JPublisher.","The Oracle style files webservices-common.properties, webservices.properties, and webservices.properties, through their SOURCETYPE and TARGETTYPE specifications, have a number of important Java-to-Java type mappings to support Web services and mappings of REF CURSORs.","The webservices and webservices files include webservices-common before specifying their own mappings. For SimpleXMLType, note that DocumentFragment overrides String if -style=webservices is set, and Source overrides String if -style=webservices is set.",{"@attributes":{"id":"p-0157","num":"0195"},"figref":["FIG. 11","FIG. 11"]},"JPublisher allows multiple -style options in the command line. The OPTIONS sections are concatenated and the TRANSFORMATION sections are concatenated, except entries in MAPPING subsections are overridden as applicable. A MAPPING entry from a style file specified later in the command line overrides a MAPPING entry with the same SOURCETYPE specification from a style file specified earlier in the command line.","This functionality is useful if it is desirable to overwrite earlier defined type mappings or add new type mappings. For example, if to map SYS.XMLTYPE into java.lang.String, the setting -style=xml2string can be appended to the JPublisher command line, assuming for this example that this will access the style file .\/xml2string.properties, which is defined as follows:",{"@attributes":{"id":"p-0160","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OPTIONS"]},{"entry":[{},"jpub.defaulttypemap=SYS.XMLTYPE:oracle.sql.SimpleXMLType"]},{"entry":[{},"END_OPTIONS"]},{"entry":[{},"TRANSFORM"]},{"entry":[{},"MAPPING"]},{"entry":[{},"SOURCETYPE oracle.sql.SimpleXMLType"]},{"entry":[{},"TARGETTYPE java.lang.String"]},{"entry":[{},"# SimpleXMLType => String"]},{"entry":[{},"OUT"]},{"entry":[{},"%2 = null;"]},{"entry":[{},"if (%1!=null) %2=%1.getstringval( );"]},{"entry":[{},"END_OUT"]},{"entry":[{},"# String => SimpleXMLType"]},{"entry":[{},"IN"]},{"entry":[{},"%1 = null;"]},{"entry":[{},"if (%2!=null)"]},{"entry":[{},"{"]},{"entry":[{},"%1 = new %p.%c(_getConnection( ));"]},{"entry":[{},"%1 = %1.createxml(%2);"]},{"entry":[{},"}"]},{"entry":[{},"END_IN"]},{"entry":[{},"END_TARGETTYPE"]},{"entry":[{},"END_MAPPING"]},{"entry":[{},"END_TRANSFORM"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Continuing this example, assume the following PL\/SQL stored procedure definition:","procedure foo (arg xmltype);","JPublisher maps this as follows in the base class:","void foo (arg oracle.sql.SimpleXMLType);","And JPublisher maps it as follows in the user subclass:","void foo (arg String);","Stored procedures called through JDBC do not have the same parameter-passing behavior as ordinary Java methods. This affects the code that is written that calls a wrapper method that JPublisher generates.","When ordinary Java methods are called, parameters that are Java objects are passed as object references. The method can modify the object. By contrast, when a stored procedure through JDBC is called, a copy of each parameter is passed to the stored procedure. If the procedure modifies any parameters, copies of the modified parameters are returned to the caller. Therefore, the \u201cbefore\u201d and \u201cafter\u201d values of a modified parameter appear in separate objects.",{"@attributes":{"id":"p-0169","num":"0207"},"figref":"FIG. 12A","b":["1","2"]},"A wrapper method that JPublisher generates contains JDBC statements to call the corresponding stored procedure. The parameters to the stored procedure, as declared in the CREATE TYPE or CREATE PACKAGE declaration, have three possible parameter modes: IN, OUT, or IN OUT. Parameters that are IN OUT or OUT are returned to the wrapper method in newly created objects. These new values must be returned to the caller somehow, but assignment to the formal parameter within the wrapper method does not affect the actual parameter visible to the caller.","In Java, there are no OUT or IN OUT designations, but values can be returned through holders. In JPublisher, one of three alternatives for holders that handle PL\/SQL OUT or IN OUT parameters can be utilized: arrays, JAX-RPC holder types and function returns.","The simplest way to solve the problem of returning output values in Java is to pass an OUT or IN OUT parameter to the wrapper method in a single-element array. Think of the array as a \u201ccontainer\u201d that holds the parameter.",{"@attributes":{"id":"p-0173","num":"0211"},"figref":"FIG. 12B"},"The \u201cbefore\u201d value of the parameter is assigned to the first element of the array (show as Array[0]). A call is then made to the wrapper method passing the array as a parameter. The wrapper method then makes a JDBC call to the stored procedures passing the first element of the array as a parameter.","After the database stored procedure executes, the wrapper method assigns the \u201cafter\u201d value of the parameter to the first element of the array. In this way, the \u201cafter\u201d value is extracted from the array. The array is then returned to the web service as the output parameter.","A setting of -outarguments=array (the default) instructs JPublisher to use this single-element array mechanism to publish any OUT or IN OUT argument.","Here is another example:","Person [ ] pa={p};","x.f(pa);","p=pa[0];","Assume that x is an instance of a JPublisher-generated class that has the method f( ), which is a wrapper method for a stored procedure that uses a SQL PERSON object as an IN OUT parameter. The type PERSON maps to the Java class Person; p is a Person instance; and pa[ ] is a single-element Person array.","Although  shows an array data structure array that can be used for passing parameters or return values, other data structures can also be utilized. For example, holders and compound types can be utilized in other embodiments.",{"@attributes":{"id":"p-0183","num":"0221"},"figref":"FIG. 13","b":"401"},"The \u201cbefore\u201d value of the parameter is assigned to the first element of the array. Although in some embodiments, the parameter is assigned to the first element, the parameter can be assigned to any element in the array so long as the location is known. For example, an array could store values for multiple parameters that were of the same type.","At a step , the array is passed to a wrapper method. The wrapper method \u201cwraps\u201d an underlying method and includes a call to the underlying method. The underlying method is executed at a step .","After the underlying method is executed, the \u201cafter\u201d value is assigned to the first element (or a known element) of the array. This is performed in the wrapper method. Upon returning from the wrapper method, the \u201cafter\u201d value is extracted from the array at a step .","The array technique for passing OUT or IN OUT parameters may require the addition of a few extra lines of code to the program for each parameter. As another example, consider the PL\/SQL function created by the following SQL*Plus command:","SQL>create or replace function g (a0 number, a1 out number, a2 in out number, a3 clob, a4 out clob, a5 in out clob) return clob is begin return null; end;","With -outarguments=array, this is published as follows:","public oracle.sql.CLOB g (","java.math.BigDecimal a0,","java.math.BigDecimal a1[ ],","java.math.BigDecimal a2[ ],","oracle.sql.CLOB a3,","oracle.sql.CLOB a4[ ],","oracle.sql.CLOB a5[ ])","Problems similar to those described earlier arise when the this object of an instance method is modified.","The this object is an additional parameter, passed in a different way. Its mode, as declared in the CREATE TYPE statement, may be IN or IN OUT. If the mode of this is not explicitly declared, its mode is IN OUT if the stored procedure does not return a result, or IN if it does.","If the mode of the this object is IN OUT, then the wrapper method should return the new value of this. The code generated by JPublisher implements this functionality in different ways, depending on the situation:","For a stored procedure that does not return a result, the new value of this is returned as the result of the wrapper method. As an example, assume that the SQL object type MYTYPE has the following member procedure:","MEMBER PROCEDURE f1 (y IN OUT INTEGER);","Also assume that JPublisher generates a corresponding Java class, MyJavaType. This class defines the following method:","MyJavaType f1 (int[ ] y)","The f1 ( ) method returns the modified this object value as a MyJavaType instance.","For a stored function (a stored procedure that returns a result), the wrapper method returns the result of the stored function as its result. The new value of this is returned in a single-element array, passed as an extra argument (the last argument) to the wrapper method.","Assume that the SQL object type MYTYPE has the following member function:","MEMBER FUNCTION f2 (x IN INTEGER) RETURNS VARCHAR2;","Then the corresponding Java class, MyJavaType, defines the following method:","String f2(int x, MyJavaType[ ] newValue)","The f2 ( ) method returns the VARCHAR2 function-return as a Java string, and returns the modified this object value as an array element in the MyJavaType array.","For PL\/SQL static procedures or functions, Jpublisher generates instance methods, not static methods, in the wrapper class. This is the logistic for associating a database connection with each wrapper class instance. The connection instance is used in initializing the wrapper class instance so that it is not required to subsequently explicitly provide a connection or connection context instance when calling wrapper methods.","The JAX-RPC specification explicitly specifies holder classes in the javax.xml.rpc.holders package for the Java mapping of simple XML data types and other types. Typically, \u201cHolder\u201d is appended to the type name for the holder class name. For example, BigDecimalHolder is the holder class for BigDecimal.","Given a setting of -outarguments=holder, JPublisher uses holder instances to publish OUT and IN OUT arguments from stored procedures. Holder settings are specified in a JPublisher style file, in the HOLDER subtag inside the TARGETTYPE section for the appropriate mapping. If no holder class is specified, then Jpublisher can choose one according to defaults.","As an example, again consider the PL\/SQL function created by the following SQL*Plus command:","SQL>create or replace function g (a0 number, a1 out number, a2 in out number, a3 clob, a4 out clob, a5 in out clob) return clob is begin return null; end;","With -outarguments=holder, the following is an example of how the function is published. In this case, there is an extra level of abstraction\u2014because oracle.sql.CLOB is not supported by Web services, it is mapped to String, the JAX-RPC holder class for which is StringHolder.","Assume the following JPublisher command to publish the function g. (The webservices style file contains an entry for -outarguments=holder.)","% jpub -u scott\/tiger -s toplevel\u201c(g)\u201d:ToplevelG -style=webservices","Here is the published interface:","public java.lang.String g\n\n","throws java.rmi.RemoteException;","The setting -outarguments=return can be used as a workaround for supporting method signatures in Web services that do not use JAX-RPC holder types or arrays. In a situation in which there is no support for JAX-RPC holders, the -outarguments=return setting allows OUT or IN OUT data to be returned in function results.","Once again, consider the PL\/SQL function created by the following SQL*Plus command:","SQL>create or replace function g (a0 number, a1 out number, a2 in out number, a3 clob, a4 out clob, a5 in out clob) return clob is begin return null; end;","Assume the following JPublisher command (a wraparound command, with output also shown) to publish the function g. Although the webservices style file specifies -outarguments=holder, the -outarguments=return setting comes after the -style setting so takes precedence.","% jpub -u scott\/tiger -s toplevel\u201c(g)\u201d:ToplevelG -style=webservices\n\n","SCOTT.top_level_scope","ToplevelGUser_g_Out","The JPublisher output acknowledges that it is processing the SCOTT top level, and also indicates the creation of the Java class ToplevelGUser_g_Out to support output values of the function g through return data.","JPublisher generates the following interface to take input parameters and return output parameters:",{"@attributes":{"id":"p-0231","num":"0276"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public ToplevelGUser_g_Out g"]},{"entry":[{},"(java.math.BigDecimal a0,"]},{"entry":[{},"\u2003\u2003java.math.BigDecimal xxa2_inoutxx,"]},{"entry":[{},"\u2003\u2003java.lang.String a3,"]},{"entry":[{},"\u2003\u2003java.lang.String xxa5_inoutxx)"]},{"entry":[{},"throws java.rmi.RemoteException;"]},{"entry":[{},"JPublisher generates the TopLevelGUser_g_Out class as follows:"]},{"entry":[{},"public class ToplevelGUser_g_Out"]},{"entry":[{},"{"]},{"entry":[{},"public ToplevelGUser_g_Out( ) { }"]},{"entry":[{},"public java.math.BigDecimal getA1Out( ) { return a1_out; }"]},{"entry":[{},"public void setA1Out(java.math.BigDecimal a1_out)"]},{"entry":[{},"{ this.a1_out = a1_out; }"]},{"entry":[{},"public java.math.BigDecimal getA2Inout( ) { return a2_inout; }"]},{"entry":[{},"public void setA2Inout(java.math.BigDecimal a2_inout)"]},{"entry":[{},"{ this.a2_inout = a2_inout; }"]},{"entry":[{},"public java.lang.String getA4Out( ) { return a4_out; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The return type ToplevelGUser_g_Out encapsulates the values of the OUT and IN OUT parameters to be passed back to the caller of the function. As in the preceding section, oracle.sql.CLOB is mapped to String by the webservices style file.","JPublisher style files enable Java-to-Java type mappings to be specified in some embodiments. A typical use for such mappings is to ensure that generated classes can be used in Web services. As a particular example, CLOB types such as java.sql.Clob and oracle.sql.CLOB cannot be used in Web services. However, the data can be used if converted to a type, such as java.lang.String, that is supported by Web services.","If the JPublisher -style option is used to specify a style file, JPublisher generates subclasses that implement the Java-to-Java type mappings specified in the style file. This includes the use of \u201cholder\u201d classes for handling output arguments\u2014data corresponding to PL\/SQL OUT or IN OUT types.","For example, consider the following PL\/SQL package, foo_pack, consisting of the stored function foo:","create or replace package foo_pack as\n\n","end;","Assume that the foo_pack package is translated as follows:","% jpub -u scott\/tiger -s foo_pack:FooPack -style=webservices","This command uses the style file webservices.properties for Java-to-Java type mappings. (This style file is supplied by Oracle and is typically appropriate for using Web services in an Oracle Database 10g environment.) The webservices.properties file specifies the following (among other things):","The mapping of the Java type oracle.sql.SimpleXMLType (which is not supported by Web services) to the Java type javax.xml.transform.Source (which is):","SOURCETYPE oracle.sql.SimpleXMLType","TARGETTYPE javax.xml.transform.Source",". . .","The use of holder classes for PL\/SQL OUT and IN OUT arguments:","jpub.outarguments=holder","This setting directs JPublisher to use instances of the appropriate holder class, in this case javax.xml.rpc.holders.SourceHolder, for the PL\/SQL output argument of type XMLTYPE.","The inclusion of webservices-common.properties:","INCLUDE webservices-common","The webservices-common.properties file (typically supplied by Oracle) specifies the following:","The mapping of SYS.XMLTYPE to oracle.sql.SimpleXMLType in the JPublisher default type map:","jpub.adddefaulttypemap=SYS.XMLTYPE:oracle.sql.SimpleXMLType","A code generation naming pattern:","jpub.genpattern=%2Base:%2User#%2","Based on the \u201c-s foo_pack:FooPack\u201d specification to JPublisher, the genpattern setting results in generation of the interface FooPack, the base class FooPackBase, and the user subclass FooPackUser, which extends FooPackBase and implements FooPack.","The mapping of the Java type oracle.sql.CLOB (which is not supported by Web services) to the Java type java.lang.String (which is):","SOURCETYPE oracle.sql.CLOB","TARGETTYPE java.lang.String",". . .","Recall the calling sequence for the foo stored function:","function foo(a IN OUT sys.xmltype, b integer) return CLOB;","The base class generated by JPublisher, FooPackBase, has the following corresponding method declaration:","public oracle.sql.CLOB_foo (oracle.sql.SimpleXMLType a[ ], Integer b);","As described above, the base class can uses an array to support the output argument.","The user subclass has the following corresponding method declaration:","public java.lang.String foo (SourceHolder_xa_inout_x, Integer b);","This is because of the specified mapping of oracle.sql.SimpleXMLType to javax.xml.transform.Source, the specified use of holder classes for output arguments, and the specified mapping of oracle.sql.CLOB to java.lang.String (all as described earlier).","Following is the class SourceHolder, the holder class for Source:",{"@attributes":{"id":"p-0269","num":"0315"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Holder class for javax.xml.transform.Source"},{"entry":"public class SourceHolder implements javax.xml.rpc.holders.Holder"},{"entry":"{"},{"entry":"\u2003\u2003public javax.xml.transform.Source value;"},{"entry":"\u2003\u2003public SourceHolder( ) { }"},{"entry":"\u2003\u2003public SourceHolder(javax.xml.transform.Source value)"},{"entry":"\u2003\u2003{ this.value = value; }"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Generated user subclasses employ the following general functionality for Java-to-Java type transformations in the wrapper method:",{"@attributes":{"id":"p-0271","num":"0317"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"User subclass method"},{"entry":"{"},{"entry":"\u2003\u2003Enter Holder layer (extract IN data from the holder)"},{"entry":"\u2003\u2003Enter Java-to-Java mapping layer (from target to source)"},{"entry":"\u2003\u2003Call base class method (uses JDBC to invoke wrapped procedure)"},{"entry":"\u2003\u2003Exit Java-to-Java mapping layer (from source to target)"},{"entry":"\u2003\u2003Exit Holder layer (update the holder)"},{"entry":"}"},{"entry":"For the example, this is as follows in the foo( ) method of"},{"entry":"the class FooPackUser:"},{"entry":"foo (SourceHolder, Integer)"},{"entry":"{"},{"entry":"\u2003\u2003SourceHolder -> Source"},{"entry":"\u2003\u2003Source -> SimpleXMLType"},{"entry":"\u2003\u2003_foo (SimpleXMLType[ ], Integer);"},{"entry":"\u2003\u2003SimpleXMLType -> Source"},{"entry":"\u2003\u2003Source -> SourceHolder"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The holder layer retrieves and assigns the holder instance.","In the example, the holder layer in foo( ) performs the following:","1. It retrieves a Source object from the SourceHolder object that is passed in to the foo( ) method (data input).","2. After processing (which occurs inside the type conversion layer), it assigns the SourceHolder object from the Source object that was retrieved and processed (data output).","The type conversion layer first takes the target type (TARGETTYPE from the style file), next converts it to the source type (SOURCETYPE from the style file), then calls the corresponding method in the base class (which uses JDBC to invoke the wrapped stored function), and finally converts the source type returned by the base class method back into the target type to return to the holder layer.","In this example, the type conversion layer in foo( ) performs the following:","1. It takes the Source object from the holder layer (data input).","2. It converts the Source object to a SimpleXMLType object.","3. It passes the SimpleXMLType object to the _foo( ) method of the base class, which uses JDBC to invoke the foo stored function.","4. It takes the SimpleXMLType object returned by the _foo( ) method (output from the foo stored function).","5. It converts the SimpleXMLType object back to a Source object for the holder layer (data output).","While the above is a complete description of preferred embodiments of the invention, various alternatives, modifications, and equivalents can be used. It should be evident that the invention is equally applicable by making appropriate modifications to the embodiments described above. For example, although properties of specific embodiments have been described, embodiments of the invention are not limited to these properties. Therefore, the above description should not be taken as limiting the scope of the invention that is defined by the metes and bounds of the appended claims along with their full scope of equivalents."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 7A and 7B","b":"9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 8A-8C","b":"10"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 9A-9J"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 10A and 10B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 12A","FIG. 12B"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
