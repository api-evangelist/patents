---
title: Cross-environment application compatibility for single mobile computing device
abstract: A seamless cross-environment workflow is provided in a multi-operating system computing environment. The multi-operating system computing environment may include a mobile operating system and a desktop operating system running concurrently and independently on a mobile computing device. Two or more application programs, running in independent operating systems, share user interaction state information including user data, user settings, and/or application context information. Interaction state information may be shared for applications that are used primarily to access and edit local user content as well as applications that communicate to a remote server or access and navigate other remote content (e.g., Internet-based application, browser, etc.). The mobile computing device may be a smartphone running the Android mobile operating system and a full desktop Linux distribution on a modified Android kernel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09160796&OS=09160796&RS=09160796
owner: Z124
number: 09160796
owner_city: George Town
owner_country: KY
publication_date: 20111003
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This Application is a non-provisional of and claims the benefit of the filing date of U.S. Provisional Application Nos. 61\/389,117, filed Oct. 1, 2010, entitled \u201cMulti-Operating System Portable Docking Device\u201d; 61\/507,199, filed Jul. 13, 2011, entitled \u201cDockable Mobile Software Architecture\u201d; 61\/507,201, filed Jul. 13, 2011, entitled \u201cCross-Environment Communication Framework\u201d; 61\/507,203, filed Jul. 13, 2011, entitled \u201cMulti-Operating System\u201d; 61\/507,206, filed Jul. 13, 2011, entitled \u201cAuto-Configuration of a Docked System in a Multi-OS Environment\u201d; and 61\/507,209, filed Jul. 13, 2011, entitled \u201cAuto-Waking of a Suspended Secondary OS in a Dockable System,\u201d wherein the entire contents of the foregoing priority applications are incorporated herein by reference for all purposes.","1. Field","This Application relates generally to the field of mobile computing environments, and more particularly to supporting multiple user environments through the use of multiple operating systems in a single mobile computing device.","2. Relevant Background","Mobile computing devices are becoming ubiquitous in today's society. For example, as of the end of 2008, 90 percent of Americans had a mobile wireless device. At the same time, the capabilities of mobile devices are advancing rapidly, including smartphones that integrate advanced computing capabilities with mobile telephony capabilities. Mobile providers have launched hundreds of new smartphones in the last three years based upon several different platforms (e.g., Apple iPhone, Android, BlackBerry, Palm, and Windows Mobile). In the U.S., smartphone penetration reached almost 23% by the middle of 2010, and over 35% in some age-groups. In Europe, the smartphone market grew by 41% from 2009 to 2010, with over 60 million smartphone subscribers as of July 2010 in the five largest European countries alone.","While smartphones are gaining in popularity and computing capability, they provide a limited user experience. Specifically, they typically have an operating system that is modified for mobile device hardware and a restricted set of applications that are available for the modified operating system. For example, many smartphones run Google's Android operating system. Android runs only applications that are specifically developed to run within a Java-based virtual machine runtime environment. In addition, while Android is based on a modified Linux kernel, it uses different standard C libraries, system managers, and services than Linux. Accordingly, applications written for Linux do not run on Android without modification or porting. Similarly, Apple's iPhone uses the iOS mobile operating system. Again, while iOS is derived from Mac OS X, applications developed for OS X do not run on iOS. Therefore, while many applications are available for mobile operating systems such as Android and iOS, many other common applications for desktop operating systems such as Linux and Mac OS X are not available on the mobile platforms.","Accordingly, smartphones are typically suited for a limited set of user experiences and provide applications designed primarily for the mobile environment. In particular, smartphones do not provide a suitable desktop user experience, nor do they run most common desktop applications. As a result, many users carry and use multiple computing devices including a smartphone, laptop, and\/or tablet computer. In this instance, each device has its own CPU, memory, file storage, and operating system.","Connectivity and file sharing between smartphones and other computing devices involves linking one device (e.g., smartphone, running a mobile OS) to a second, wholly disparate device (e.g., notebook, desktop, or tablet running a desktop OS), through a wireless or wired connection. Information is shared across devices by synchronizing data between applications running separately on each device. This process, typically called \u201csynching,\u201d is cumbersome and generally requires active management by the user.","Embodiments of the present invention are directed to providing the mobile computing experience of a smartphone and the appropriate user experience of a secondary terminal environment in a single mobile computing device. A secondary terminal environment may be some combination of visual rendering devices (e.g., monitor or display), input devices (e.g., mouse, touch pad, touch-screen, keyboard, etc.), and other computing peripherals (e.g., HDD, optical disc drive, memory stick, camera, printer, etc.) connected to the computing device by a wired (e.g., USB, Firewire, Thunderbolt, etc.) or wireless (e.g., Bluetooth, WiFi, etc.) connection. In embodiments, a mobile operating system associated with the user experience of the mobile environment and a desktop operating system associated with the user experience of the secondary terminal environment are run concurrently and independently on a shared kernel.","According to aspects consistent with various embodiments, a cross-environment workflow is provided by opening a document file with a first application running on a first operating system, the user content of the document file representing a stored document state, accepting user input in the first application, the first application having, as a result of responding to the user input, a first user interaction state, the first user interaction state including a modified document state, storing application state information representing the first user interaction state within the first computing environment, the application state information including application context information, releasing a file lock of the document file by the first application without saving the modified document state to the document file, opening, by a second application running on a second operating system, the document file, accessing, by the second application, the application state information associated with the first user interaction state, and applying, by the second application, the application context information to present an interaction state of the second application that is substantially similar to the first user interaction state.","According to other aspects consistent with various embodiments, the cross-environment workflow includes opening, by the second application, a temporary document file created by the first application, the temporary document file representing changes between the stored document state and the modified document state. The application context information may include a hint to the temporary file. The first application may be displayed within a first user environment and the second application may be displayed within a second user environment. The first and second operating systems may run concurrently on a shared kernel of a mobile device. The application context information may be stored in a database accessed by the first and second applications through an application programming interface.","According to other aspects consistent with various embodiments, the application context information may include at least one user interaction state parameter not represented in the document file. The application context information may include information associated with a non-completed user action and\/or a current user selection of user content information. The opening of the document file by the second application may be in response to detecting a docking event of a mobile device.","Mobile telephony devices, (i.e., smartphones, handsets, mobile stations, portable communication devices, etc.) that include computing capabilities are increasing in popularity. Many of these smartphones include a mobile operating system (\u201cOS\u201d) running on a mobile processor. While mobile processors and mobile OS's have increased the capabilities of these devices, smartphones have not tended to replace personal computer (\u201cPC\u201d) environments (i.e., Windows, Mac OS X, Linux) such as desktop or notebook computers at least because of the limited user experience provided. In particular, the user interface device(s) found on smartphones are typically tailored to the mobile environment. For example, smartphones typically use a small thumb-style QWERTY keyboard, touch-screen display, click-wheel, and\/or scroll-wheel as user interface devices. Mobile OSs, as well as applications (i.e., \u201cApps\u201d) developed for mobile OSs, are typically designed for the constraints of the mobile environment including a mobile processor and the user interface device(s) present on mobile devices. Therefore, many applications that have been developed for PC operating systems are not available for mobile OSs (i.e., are not compiled for and do not run on mobile OSs). In addition, for some tasks such as typing or editing documents, a full-size keyboard and large display are easier to use than the user interface components typically found on a smartphone.","Accordingly, users typically use separate computing devices for each computing experience, including a smartphone, tablet computer, laptop computer, and\/or desktop computer. In this instance, each device has its own CPU, memory, file storage, and OS. Connectivity and file sharing between smartphones and other devices involves linking one device (e.g., smartphone, running a mobile OS) to a second, wholly disparate device (e.g., notebook, desktop, or tablet running a desktop OS), through a wireless or wired connection. Information is shared across devices by synchronizing data between applications running separately on each device. This process, typically called \u201csynching,\u201d is cumbersome and generally requires active management by the user.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","115","100","116","118","110","110","130","115","130","115","116","118","116","130","130","116"]},"In computing environment , mobile computing device  may be docked with secondary terminal environment  that includes I\/O devices , , and\/or . In embodiments, mobile computing device  is docked with secondary terminal environment  by connecting port  of mobile computing device  to port  of secondary terminal environment . In this instance, secondary terminal environment  presents a second user interaction space of computing environment . In some instances, the second user interaction space may be more suited to a desktop computing experience. In these instances, desktop OS  can be associated with secondary terminal environment  to provide the full capabilities of a notebook, tablet, or desktop computer environment through the second user interaction space.","In embodiments, mobile OS  and desktop OS  run concurrently on a shared kernel on a processor of mobile computing device . Concurrent execution of a mobile OS and a desktop OS on a shared kernel is described in more detail in U.S. patent application Ser. No. 13\/217,108, filed Aug. 24, 2011, entitled \u201cMULTI-OPERATING SYSTEM,\u201d herein incorporated by reference. In this way, a single mobile computing device can provide a mobile computing experience through a first user interaction space and a desktop computing experience through a second user interaction space. While the ability to carry one mobile device that can execute multiple operating systems concurrently through separate user interaction spaces solves a number of problems for a user, each user interaction space (through the concurrently running mobile OS and desktop OS) generally provides a separate set of available applications and user functionality.","Embodiments of the invention are directed to providing a seamless cross-environment workflow using multiple applications providing similar functionality running on separate, independent operating systems. Embodiments facilitate multiple applications sharing a single apparent user interaction state. In embodiments, a user can switch seamlessly from interacting with user content with an application running on a first OS (e.g., mobile OS ) to interacting with the same user content with an application running on a second OS (e.g., desktop OS ). Notably, application context information of the current user interaction state is maintained when the user switches to the second application, including application context information not typically stored as part of a document file for the applications.","Consider, for example, that a user is editing a document using a first word processing application running on a first OS through a first user environment. The user wishes to switch to editing the same document through a second user environment using a similar word processing application that runs on the second OS associated with the second user environment. For example, the user may have docked a mobile computing device with a second user environment and wishes to switch to editing the document with the second user environment. The user desires that the transition occur seamlessly, so they can pick up using the second application exactly where they left off with the first application, including any non-saved data and incomplete user actions. Handling this scenario involves managing user document files and application state information in a way that applications running in separate processes on separate operating systems present a single apparent application user interaction state.","Accordingly, embodiments provide various novel techniques for managing application state information and document files of multiple applications running on multiple separate operating systems. The embodiments include techniques for managing application state information for applications that primarily operate on local user content, client-server applications, and Internet-based applications.","As described above, computing environment  provides multiple user computing experiences through multiple user interaction spaces associated with a mobile device running multiple operating systems concurrently. Specifically, because mobile computing device  includes multiple OSs, where each OS is suited to a particular computing environment, mobile computing device  may be adapted with external I\/O devices to provide a broad range of user experiences with a single mobile computing device. For example, a user may have a mobile computing device  and a secondary terminal environment  that includes a keyboard, display, and\/or pointing device(s) in a laptop-type enclosure. When mobile computing device  is docked with this laptop-like secondary terminal environment, the full capabilities of desktop OS  are available through the secondary terminal environment .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["110","112","114","204","220","112","118","206","208","210","116","214","216","218","222","224","114","118","110","118","224","220"]},"Processor  may be an ARM-based mobile processor. In embodiments, mobile processor  is a mobile ARM-based processor such as Texas Instruments OMAP3430, Marvell PXA320, Freescale iMX51, or Qualcomm QSD8650\/8250. However, mobile processor  may be another suitable ARM-based mobile processor or processor based on other processor architectures such as, for example, x86-based processor architectures or other RISC-based processor architectures.","While  illustrates one exemplary hardware implementation 112 for mobile computing device , other architectures are contemplated as within the scope of the invention. For example, various components illustrated in  as external to mobile processor  may be integrated into mobile processor . Optionally, external display interface , shown in  as integrated into mobile processor , may be external to mobile processor . Additionally, other computer architectures employing a system bus, discrete graphics processor, and\/or other architectural variations are suitable for employing aspects of the present invention.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 3","FIG. 3"],"b":["300","130","160","110","130","160","130","160","300","110","300","208","112"]},"In OS architecture , mobile OS  and desktop OS  run concurrently on shared kernel . This means that mobile OS  and desktop OS  are running on shared kernel  at the same time. Specifically, mobile OS  and desktop OS  both interface to shared kernel  through the same kernel interface , for example, by making system calls to shared kernel . Shared kernel  manages task scheduling for processes of both mobile OS  and desktop OS . In this regard, mobile OS  and desktop OS  are running independently and concurrently on shared kernel . In addition, shared kernel  runs directly on mobile processor  of mobile computing device hardware , as illustrated by hardware interface . Specifically, shared kernel  directly manages the computing resources of mobile computing device hardware  such as CPU scheduling, memory access, and I\/O. In this regard, hardware resources are not virtualized, meaning that mobile OS  and desktop OS  make system calls through kernel interface  without virtualized memory or I\/O access.","As illustrated in , mobile OS  has libraries layer , application framework layer , and application layer . In mobile OS , applications  and  run in application layer  supported by application framework layer  of mobile OS . Application framework layer  includes manager(s)  and service(s)  that are used by applications running on mobile OS . For example, application framework layer  may include a window manager, activity manager, package manager, resource manager, telephony manager, gesture controller, and\/or other managers and services for the mobile environment. Application framework layer  may include a mobile application runtime environment that executes applications developed for mobile OS . The mobile application runtime environment may be optimized for mobile computing resources such as lower processing power and\/or limited memory space. The mobile application runtime environment may rely on the kernel for process isolation, memory management, and threading support. Libraries layer  includes user libraries  that implement common functions such as I\/O and string manipulation, graphics functions, database capabilities, communication capabilities, and\/or other functions and capabilities.","As illustrated in , desktop OS  has libraries layer , framework layer , and application layer . In desktop OS , applications  and  run in application layer  supported by application framework layer  of desktop OS . Application framework layer  includes manager(s)  and service(s)  that are used by applications running on desktop OS . For example, application framework layer  may include a window manager, activity manager, package manager, resource manager, and\/or other managers and services common to a desktop environment. Libraries layer  may include user libraries  that implement common functions such as I\/O and string manipulation, graphics functions, database capabilities, communication capabilities, and\/or other functions and capabilities.","In various embodiments of the present disclosure, desktop OS  runs in a separate execution environment from mobile OS . For example, mobile OS  may run in a root execution environment and desktop OS  may run in a secondary execution environment established under the root execution environment. Processes and applications running on mobile OS  access user libraries , manager(s)  and service(s)  in the root execution environment. Processes and applications running on desktop OS  access user libraries , manager(s)  and service(s)  in the secondary execution environment.","In embodiments, mobile OS  and desktop  are independent operating systems with incompatible user libraries, graphics systems, and\/or application frameworks. Therefore, applications developed for mobile OS  may not run directly on desktop OS , and applications developed for desktop OS  may not run directly on mobile OS . For example, application , running in application layer  of mobile OS , may be incompatible with desktop OS , meaning that application  could not run on desktop OS . Specifically, application  may depend on manager(s) , service(s) , and\/or libraries  of mobile OS  that are either not available or not compatible with manager(s) , service(s) , and\/or libraries  of desktop OS .","As a result, mobile OS  and desktop OS  may have different sets of available applications. In this regard, mobile OS  and desktop OS  of OS architecture  provide separate user experiences through separate sets of applications accessible through separate user interaction spaces. The user may access the applications available on (i.e., compiled for and loaded within the execution environment of) mobile OS  through a first user interaction space associated with mobile OS , and the applications available on desktop OS  through a second user interaction space associated with desktop OS .","As described above, mobile operating systems typically do not use the same graphics environment as desktop operating systems. Graphics environments for desktop OS's were designed for flexibility and high performance. For example, the X-window system, used by some desktop OSs, provides platform and network independence at the expense of greater processing and system resources. In contrast, graphics environments for mobile OSs are designed more for efficiency and the specific user input devices of a mobile computing environment and less for flexibility. Because the graphics environments of mobile and desktop OS's are often different, an application running on a mobile OS may not be re-directed to display within a user space of a desktop OS by re-directing the graphics information from the graphics server of the mobile OS to the graphics server of the desktop OS.","The most widely adopted mobile OS is Google's Android. While Android is based on Linux, it includes modifications to the kernel and other OS layers for the mobile environment and mobile processors. In particular, while the Linux kernel is designed for a PC (i.e., x86) CPU architecture, the Android kernel is modified for ARM-based mobile processors. Android device drivers are also particularly tailored for devices typically present in a mobile hardware architecture including touch-screens, mobile connectivity (GSM\/EDGE, CDMA, Wi-Fi, etc.), battery management, GPS, accelerometers, and camera modules, among other devices. In addition, Android does not have a native X Window System nor does it support the full set of standard GNU libraries, and this makes it difficult to port existing GNU\/Linux applications or libraries to Android.","Apple's iOS operating system (run on the iPhone) and Microsoft's Windows Phone 7 are similarly modified for the mobile environment and mobile hardware architecture. For example, while iOS is derived from the Mac OS X desktop OS, common Mac OS X applications do not run natively on iOS. Specifically, iOS applications are developed through a standard developer's kit (\u201cSDK\u201d) to run within the \u201cCocoa Touch\u201d runtime environment of iOS, which provides basic application infrastructure and support for key iOS features such as touch-based input, push notifications, and system services. Therefore, applications written for Mac OS X do not run on iOS without porting. In addition, it may be difficult to port Mac OS X applications to iOS because of differences between user libraries and\/or application framework layers of the two OSs, and\/or differences in system resources of the mobile and desktop hardware.","In one embodiment consistent with OS architecture , an Android mobile OS and a full Linux OS run independently and concurrently on a modified Android kernel. In this embodiment, the Android OS may be a modified Android distribution while the Linux OS (\u201cHydroid\u201d) may be a modified Debian Linux desktop OS.  illustrate Android mobile OS , Android kernel , and Hydroid OS  that may be employed in OS architecture  in more detail, according to various embodiments.","As illustrated in , Android OS  includes a set of C\/C++ libraries in libraries layer  that are accessed through application framework layer . Libraries layer  includes the \u201cbionic\u201d system C library  that was developed specifically for Android to be smaller and faster than the \u201cglibc\u201d Linux C-library. Libraries layer  also includes inter-process communication (\u201cIPC\u201d) library , which includes the base classes for the \u201cBinder\u201d IPC mechanism of the Android OS. Binder was developed specifically for Android to allow communication between processes and services. Other libraries shown in libraries layer  in  include media libraries  that support recording and playback of media formats, surface manager  that managers access to the display subsystem and composites graphic layers from multiple applications, 2D and 3D graphics engines , and lightweight relational database engine . Other libraries that may be included in libraries layer  but are not pictured in  include bitmap and vector font rendering libraries, utilities libraries, browser tools (i.e., WebKit, etc.), and\/or secure communication libraries (i.e., SSL, etc.).","Application framework layer  of Android OS  provides a development platform that allows developers to use components of the device hardware, access location information, run background services, set alarms, add notifications to the status bar, etc. Framework layer  also allows applications to publish their capabilities and make use of the published capabilities of other applications. Components of application framework layer  of Android mobile OS  include activity manager , resource manager , window manager , dock manager , hardware and system services , desktop monitor service , multi-display manager , and remote communication service . Other components that may be included in framework layer  of Android mobile OS  include a view system, telephony manager, package manager, location manager, and\/or notification manager, among other managers and services.","Applications running on Android OS  run within the Dalvik virtual machine  in the Android runtime environment  on top of the Android object-oriented application framework. Dalvik virtual machine  is a register-based virtual machine, and runs a compact executable format that is designed to reduce memory usage and processing requirements. Applications running on Android OS  include home screen , email application , phone application , browser application , and\/or other application(s) (\u201cApp(s)\u201d) .","The Android OS graphics system uses a client\/server model. A surface manager (\u201cSurfaceFlinger\u201d) is the graphics server and applications are the clients. SurfaceFlinger maintains a list of display ID's and keeps track of assigning applications to display ID's. In one embodiment, mobile computing device  has multiple touch screen displays . In this embodiment, display ID  is associated with one of the touch screen displays  and display ID  is associated with the other touch screen display . Display ID  is associated with both touch screen displays  (i.e., the application is displayed on both displays at the same time). Display ID's greater than 2 are virtual displays, meaning that they are not associated with a display physically present on mobile computing device hardware .","Graphics information for Android applications includes windows, views, and canvasses. Each window, view, and\/or canvas is implemented with an underlying surface object. Surface objects are double-buffered (front and back buffers) and synchronized across processes for drawing. SurfaceFlinger maintains all surfaces in a shared memory pool which allows all processes within Android to access and draw into them without expensive copy operations and without using a server-side drawing protocol such as X-Windows. Applications always draw into the back buffer while SurfaceFlinger reads from the front buffer. SurfaceFlinger creates each surface object, maintains all surface objects, and also maintains a list of surface objects for each application. When the application finishes drawing in the back buffer, it posts an event to SurfaceFlinger, which swaps the back buffer to the front and queues the task of rendering the surface information to the frame buffer.","SurfaceFlinger monitors all window change events. When one or more window change events occur, SurfaceFlinger renders the surface information to the frame buffer for one or more displays. Rendering includes compositing the surfaces, i.e., composing the final image frame based on dimensions, transparency, z-order, and visibility of the surfaces. Rendering may also include hardware acceleration (e.g., OpenGL 2D and\/or 3D interface for graphics processing hardware). SurfaceFlinger loops over all surface objects and renders their front buffers to the frame buffer in their Z order.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 5","b":["520","520","521","522","523","524","525","526","527","528","530","528","110","120","520"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 6","b":["660","662","660","662","664","662","661","674","673","672","681","682","683","684","685"]},"The Linux OS graphics system is based on the X-windows (or \u201cX11\u201d) graphics system. X-windows is a platform-independent, networked graphics framework. X-windows uses a client\/server model where the X-server is the graphics server and applications are the clients. The X-server controls input\/output hardware associated with the Linux OS such as displays, touch-screen displays, keyboards, pointing device(s), etc. In this regard, X-windows provides a server-side drawing graphics architecture, i.e., the X-server maintains the content for drawables including windows and pixmaps. X-clients communicate with the X-server by exchanging data packets that describe drawing operations over a communication channel. X-clients access the X communication protocol through a library of standard routines (the \u201cXlib\u201d). For example, an X-client may send a request to the X-server to draw a rectangle in the client window. The X-server sends input events to the X-clients, for example, keyboard or pointing device input, and\/or window movement or resizing. Input events are relative to client windows. For example, if the user clicks when the pointer is within a window, the X-server sends a packet that includes the input event to the X-client associated with the window that includes the action and positioning of the event relative to the window.","Because of the differences in operating system frameworks, graphics systems, and\/or libraries, applications written for Android do not generally run on Hydroid OS  and applications written for standard Linux distributions do not generally run on Android OS . In this regard, applications for Android OS  and Hydroid OS  are not bytecode compatible, meaning compiled and executable programs for one do not run on the other.","In one embodiment, Hydroid OS  includes components of a cross-environment communication framework that facilitates communication with Android OS  through shared kernel . These components include IPC library  that includes the base classes for the Binder IPC mechanism of the Android OS and remote communications service .","In one embodiment, Hydroid OS  is run within a chrooted (created with the \u2018chroot\u2019 command) secondary execution environment created within the Android root environment. Processes and applications within Hydroid OS  are run within the secondary execution environment such that the apparent root directory seen by these processes and applications is the root directory of the secondary execution environment. In this way, Hydroid OS  can run programs written for standard Linux distributions without modification because Linux user libraries  are available to processes running on Hydroid OS  in the chrooted secondary execution environment.","Referring back to , mobile OS  and desktop  are in active concurrent execution on shared kernel  on a mobile device. Mobile OS  and desktop OS  may be incompatible with regard to user libraries, graphics systems, and\/or application frameworks. This means that an application compiled for one OS (i.e., compiled against the user libraries, etc., of that OS) will not execute on the other OS. Accordingly, mobile OS  and desktop OS  of OS architecture  provide separate user experiences through different applications accessible through separate user interaction spaces.","In some instances, an application may be available for mobile OS  that provides similar functionality to an application available for desktop OS . These applications, while separate applications compiled for different OSs, may be compatible from the standpoint of user data including document files. Examples of applications available on (compiled for and loaded within the execution environment of) both OSs may include web browsers, email client applications, office productivity applications (e.g., word processing, spreadsheet, presentation, etc.), photo and video editing applications, and\/or other applications. Consequently, it may be possible for a user to edit a certain document file using a first application running on mobile OS , and later edit the same document file using a second application running on desktop OS . However, this does not provide a seamless user experience. To switch between editing the document file with the first application and editing the document using the second application, the user must close the document file with the first application, launch the second application on the desktop OS, and re-open the document file with the second application. In this process, the user loses any application state information related to their current state of use of the first application not saved in the document file. This may include, for example, the current editing or cursor position, the current view, undo information, the current editing mode (e.g., viewing with markup or without, etc.), currently selected text, selected menu tabs, application options (open toolbars, printing options, etc.).","Embodiments of the present invention extend the functionality of OS architecture  to provide a more seamless computing experience in a multi-OS computing environment by sharing application state information across applications executing on different OSs such that they provide a single apparent application interaction state. This functionality enables, for example, a user to seamlessly switch from interacting with a set of user data using a first application running in a first OS to interacting with the same set of user data using a second application running in a second OS. Notably, the current user interaction state is maintained to provide a seamless cross-environment workflow. This means that the user does not have to close application documents associated with the user data before switching to interacting with the user data using the second application. Further, application interaction state information that may not be part of an application document file is maintained across the separate applications running on separate OSs. For example, user selected objects or text may be maintained across applications running in separate OSs such that a user can begin a user action on a set of user data with an application running in a first OS, and complete the action with an application running on a second, separate OS.","To provide a seamless cross-environment workflow, the embodiments described below provide methods and systems that allow two or more application programs running in independent operating systems to share user interaction state information. The embodiments provide for sharing user interaction state information across applications running in two or more separate operating systems. Shared user interaction state information may include user data, user settings, and\/or application context information. In this way, two or more applications, compiled for and running on separate OSs, can present a single apparent user interaction state.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 7","FIG. 3"],"b":["300","300","300","752","754","130","782","784","160","130","320","130","160","754","130","130","782","160","160","300"],"i":["a ","a","a "]},"In computing environment , application state information is stored within application state data store  of mobile OS . While application state data store is illustrated as a component of mobile OS , application state data store  may alternatively be a component of desktop OS . Application state data store  is accessible by applications within mobile OS  and applications within desktop OS . In one embodiment, application state data store  is a database maintained by a service of mobile OS . Communication between applications running on desktop OS  with the application state data store is provided through an inter-process communication channel  of shared kernel . A cross-environment communication framework that provides a communication channel for applications of desktop OS  to communicate with services and applications of mobile OS  is described in more detail in co-pending U.S. patent application Ser. No. 13\/217,099, filed Aug. 24, 2011, entitled \u201cCross-Environment Communication Framework,\u201d and Ser. No. 13\/247,885, filed Sep. 28, 2011, entitled \u201cCross-Environment Communication Using Application Space API,\u201d the entire contents of each of which are incorporated herein by reference. However, any suitable inter-process communication mechanism may be used to provide access to application state data store by processes running on desktop OS .","In the embodiment illustrated by , computing environment includes application communication API  of mobile OS  and application communication API  of desktop OS . Application communication API  and application communication API  provide the low-level functions for applications to communicate with application state data store  to set and query application state information. Using these functions, mobile OS applications call down to application communication API  to set and query application state data. For example, application  calls functions of API  with name\/value pairs to set and query application state data. Desktop OS applications call down to application communication API  to set and query application state data from application state data store .","The application communication APIs of computing environment may be in application space within the first and\/or second OS. For example, API  could be implemented as a runtime library of mobile OS . In one embodiment, API  is implemented as a JAR file for a Dalvik runtime environment of an Android mobile OS. In other embodiments, the application communication APIs of computing environment may be within user libraries or other libraries accessible to applications of the OS. For example, in one embodiment, API  of desktop OS  is implemented as a shared user library in a Linux OS.","In alternative embodiments, computing environment does not include APIs in mobile OS  and desktop OS . In these embodiments, the applications communicate directly with the application state data store to set and query application state information. Applications of mobile OS  and desktop OS  may also communicate to the application state data store through a service of mobile OS  or desktop OS .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIGS. 8-10","FIG. 8"],"b":["300","800","130","110","160","114","110","130","320"],"i":["a ","a "]},"User content may include the data and formatting of the data that the user is editing. User content may be stored in a document file  stored on a non-volatile storage medium of the mobile computing device. A temporary document file  may also contain user content. In various embodiments, temporary document file  includes user content that has not been saved to document file  by the user. For example, temporary document file  may include the changes made to the user document since it was last saved to document file  by the user.","It is worth noting that the document file  and\/or the temporary document file  can alternatively be stored remote to the mobile computing device. For example, embodiments may store some or all of the data in external storage (e.g., an external hard drive, a thumb drive, etc.), on a remote server accessible to the mobile computing device over a local or non-local network, on remote (e.g., \u201ccloud\u201d) storage accessible to the mobile computing device over the public Internet, or in any other useful location. Other embodiments store some files locally and others non-locally. Still other embodiments locally store copies (e.g., temporary versions, etc.) of non-local files and provide additional functionality to synchronize those files (e.g., or keep track of revisions, perform other file management tasks, etc.). Accordingly, embodiments described herein with reference to locally stored files are intended to be applicable to applications storing some or all of their files in non-local storage. In some cases, handling of remote files is facilitated by client-server interactions, or the like, as discussed more fully below.","User settings include user selected options, such as, for example, default document formatting and views, visible menus, hotkeys, document review options, proofing options, and\/or user customizations. Typically, document specific settings and options are stored in the document file while other options may be stored in a file associated with the application program. In computing environment , options that are typically stored in the file associated with the application program may be stored in application state data store .","The application context includes additional information that defines the current user interaction state of the application. For example, application context information not typically stored in a document or user settings file may include the current cursor position, selected text or objects, previous user actions (e.g., undo levels and actions), current view, selected menu tab, and\/or other information. In computing environment configuration , application context information includes cursor position  and selected cell . This application context information is maintained in application state data store , and is represented in computing environment configuration by application state . In addition, the user has entered data since last saving document file . For example, the user may have entered a formula in computing environment configuration since last saving the user document. This information is stored in temporary document file .","After some time period of interacting with the set of information using the first spreadsheet application on the mobile device, the user docks the mobile device with a second user environment (e.g., desktop user environment). For example,  illustrates computing environment configuration in which mobile computing device  is docked with secondary terminal environment , according to various embodiments. Secondary terminal environment  includes display , keyboard , and pointing device . In this regard, secondary terminal environment  is a desktop-like terminal environment. When docked through dock interface , the mobile device associates desktop OS  with secondary terminal environment  such that the user interface  of the desktop OS is displayed on the display  of the second user environment . As illustrated in , dock interface  may include a dock cradle  and\/or dock cable .","In this instance, the user wishes to continue to interact with the same user content (i.e., spreadsheet data represented by file \u2018File.ods\u2019) using an application that is tailored to the context of the second user environment, without losing the current user interaction state. For example, while compatible from the standpoint of document file types, applications available for the mobile OS may differ in some respects to applications available for the desktop OS. These differences may include the screen resolution, menus, visible document area, functionality, etc. For these reasons, it may be easier for the user to edit user content using the desktop OS application when the mobile computing device is docked to a secondary terminal environment.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 10","FIG. 10"],"b":["800","700","110","940","854","824","834","130","1084","160","742","854","854","110","940"],"i":"c "},"As described above, the user interaction state information  includes user content, user settings, and application context information. User interaction state information  includes pointers to document file  and temporary file  that contain the user content information. The second spreadsheet application opens the document file  and temporary document file , and queries the application state information  for user settings and application context information. For example, the second application retrieves the cursor position  and active cell , among other application context information. Accordingly, the second spreadsheet application  presents an application window  on the secondary terminal environment that allows the user to seamlessly pick up interacting with spreadsheet user data exactly where they left off with the first application . Using a similar process, the user may switch back to editing user data using the first spreadsheet application  running on the mobile OS when the user undocks the mobile computing device.","It is not necessary for a first application running on a first OS to have exactly the same user interface as a second application running on a second OS to present a single apparent user interaction state using the above embodiments. For example, the user interface style, way of interacting with the user interface, and\/or user interface components may be different while still considered to be presenting a single apparent user interaction state. In particular, each application may be tailored to the context of the operating system on which it is running as well as the user environment on which it is displayed, while sharing a single apparent user interaction state. For example, mobile applications may be tailored to the touch-based user input and smaller display screen present on typical mobile computing environments. In contrast, desktop applications may be tailored to larger screens and pointing device(s) based input. For example, a desktop word-processing application may have more visible menus and menu icons that does a word-processing application designed for a mobile OS GUI. However, using the embodiments described above, application context information may be shared to provide a single apparent user interaction state that provides, to the user, a seamless workflow for editing user content using either the mobile application or the desktop application.","In the embodiment described above, switching between applications running on separate operating systems and sharing application state information occurred automatically based on an event (e.g., docking, undocking, etc.). That is, the computing environment assumed that the user intends to switch to the desktop application when the user docks the mobile device. However, switching between applications with which the user is actively interacting may occur as a result of a user prompt, or based on user settings. For example, when the user docks the mobile device, the user could be prompted to determine whether they want to continue to interact with the first application running on the mobile OS, or switch to interacting with the same user data through a second application running on the desktop OS. Alternatively, user settings could determine that for some applications the user wants to switch automatically when the mobile device is docked, while for other applications the user either wants to be prompted or does not want to switch to the desktop application.","In embodiments, applications running on separate OSs and sharing a single apparent user interaction state may both be running at the same time. For example, application , running on mobile OS  may be running and presenting a user application window through the user environment associated with mobile OS . At the same time, application  is running on desktop OS  and presenting application window  on a second user environment associated with desktop OS . In this instance, applications  and  may share user settings and application context information as described above. When application context information is changed (i.e., the user interaction state is updated) in response to a user input to one of applications  and , the application context information is updated in application state data store . Application state data store  pushes the change to the other application through a notification channel such that the other application maintains a consistent user interaction state with the first application. For concurrently running applications on separate operating systems, releasing locks on document file  and temporary document file  may be done in several ways. In one embodiment, document files are released or established in response to user input in one of the concurrently running applications.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 11","b":["1100","1100","1102","1104","1106","1108","1110","1112","1114"]},"Seamless translation of application data between applications running on separate operating systems presents different issues for different types of applications. The description provided above shows how a seamless workflow may be provided across applications running on multiple separate operating systems for a category of applications that are used primarily to create and modify local user content. This category includes, for example, word processing applications, spreadsheet applications, presentation applications, and photo and video editing applications, among others.","Another category of applications includes applications that include, as a primary aspect, communication with a remote server. These applications may be said to be client-server type applications. For example, this category can include client-server communication applications, such as e-mail client applications, web browser applications, cloud-based or \u201csoftware-as-a-service\u201d applications, and the like. These applications may store user data and settings differently than applications that primarily operate on local user content. For example, an email client application may connect to an email server that provides storage for email folders. The email server may maintain folders of most user content and allow multiple email clients on multiple platforms to connect to the server to interact with the user content. The server may push received emails to connected email clients.","Accordingly, client-server type applications may store a more limited set of information locally than do applications that operate primarily on local user content. It will be appreciated, however, that it is becoming increasingly common for applications to store some information locally and other information non-locally. As such, the categorization of applications according to their type of data storage is intended only to add clarity to the discussion of functionality of various embodiments and is not intended to limit the scope of any embodiment as falling within only a single category of functionality. For example, an email client may act more like a local storage type of application in certain use cases (e.g., when composing a locally-saved draft of an email using a non-web-based email client), while the same email client may act more like a client-server application in other use cases (e.g., when exchanging email data with a remote email server). Indeed, when an application is (or is acting more like) a client-server type application, the application may need to provide functionality that may not be needed in an application having purely local interactions. For example, for a particular client-server application, multiple clients may each need to send and receive information from the server while maintaining a single, substantially unified application interaction state.","In one embodiment for providing seamless translation of application state between multiple client applications in a client-server context, a first client application (e.g., email client), running on a first operating system (e.g., mobile OS ), communicates with a remote communications server over a communications protocol (e.g., IMAP, POP3, Exchange, etc.). The first client stores all application state information in an application state data store on the first operating system. For example, an email client application may store user data (e.g., email folders, draft email, calendar appointments, etc.), user settings (e.g., screen layout, message appearance, notification settings, etc.), and application context information (e.g., current cursor position, highlighted text, undo information and levels, etc.). As a result of user interaction with the first client application, the first client application has a current user interaction state.","In response to an event (e.g., dock event), a second client application launches on a second operating system and connects to the application state data store. The second application receives the application state information for the current user interaction state of the first application including user content, user settings, and application context information from the application state data store. That is, the second client application does not directly communicate with the server. Instead, the first client application performs all communication with the server and maintains a local copy of all application state data in the application state data store. The second client application receives application state information from the application state data store.","In an alternative embodiment for providing seamless translation of application state between multiple client applications in a client-server context, a first client application (e.g., email client), running on a first operating system (e.g., mobile OS ), communicates with a remote communications server over a communications protocol (e.g., IMAP, POP3, Exchange, etc.). The first client stores application state information in an application state data store. The application state information includes user content, user settings, and application context information that is not typically stored on the remote server. For example, an email client application may store user settings (e.g., screen layout, message appearance, notification settings, etc.), and application context information (e.g., current cursor position, highlighted text, undo information and levels, etc.). As a result of user interaction with the first client application, the first client application has a current user interaction state.","In response to an event (e.g., dock event), a second client application launches on a second operating system, connects to the remote server, and connects to the application state data store to receive the application state information. For example, an email client application running on the second OS may connect to the server for most user content (e.g., email folders, draft email, calendar appointments, etc.), and connect to the application state data store for additional application state information including user settings (e.g., screen layout, message appearance, notification settings, etc.) and application context information (e.g., current cursor position, highlighted text, undo information and levels, etc.). The second application rebuilds the current user interaction state of the first application from the user content received from the remote server and the application state information received from the application state data store.","Some other types of client-server applications provide an interface and functionality to navigate and present Internet-based content. These types of applications may include, for example, web browsers and cloud-based applications (e.g., productivity applications, file management and\/or storage applications, streaming media applications, Internet radio applications, IP-based telephony and\/or conferencing applications, etc.). Preserving an apparently common application interaction state across these types of applications running in multiple user environments can present different and\/or additional issues from those situations involving purely local applications. For example, web browsers can maintain a substantial amount of information relating to user settings and sessions of the browser. In addition, web content can be highly dynamic and interactive (e.g., CSS, flash animation, applets, javascript, forms, etc.). A web-browser may also run applications within the browser (e.g., applets, etc.), have varying access to or support for plug-ins, etc. In some instances, the web-browser may be used as a virtual operating system within an operating system (e.g., applets, cloud-based applications). Further, web browsers may be used to provide secure sessions and\/or other secure communications, user authentication and\/or tracking, and the like.","Returning to  for the sake of illustration, a mobile browser is running as application  on mobile OS  and is presenting a user application window through the user environment associated with mobile OS . Desktop OS  is running concurrently on the mobile device (on processor  of the mobile device ) with mobile OS  on shared kernel . The current user interaction state of the mobile browser application includes user content, user settings, and an application context. User content for the mobile browser application may include cookies, tokens, user data (e.g., being provided to a form, etc.), and\/or any other information generated for or by the user in relation to the browser (e.g., including any browser-implemented applications or sessions). User settings may include home page settings, saved browser history, saved bookmarks or favorites, proxy settings, and\/or any other information stored for the user in relation to the browser. Application context may include current state information for the browser. In some embodiments, application context only includes the currently displayed URL. In other embodiments, the application context includes additional information, such as currently selected text, current pointer location, etc.","At some time, the user docks mobile computing device  to secondary terminal environment  (e.g., as illustrated in ). It may be desirable to switch the user's interaction context from the mobile browser to a desktop browser application  running on desktop OS  and presenting application window  on a second user environment associated with desktop OS  (e.g., as illustrated in ). Mobile browser application  and desktop browser application  may share user settings and application context information as described above. In some cases, the shared application context involves passing only the current URL; while in other cases, more advanced context sharing occurs, as described more fully below. As discussed above, application context information can be updated in the application state data store , and the application state data store  can push the change to the other application through a notification channel to maintain a consistent user interaction state, where desired.","A number of browser-specific issues may be handled in different ways by different embodiments. One such issue is that many web servers are configured to deliver different content (or the same content displayed in a different format) for different types of browsers. This can be particularly true for mobile versus desktop types of browsers, as many web pages are designed to exploit the different user interaction environments differently (e.g., to exploit differences in display size, resolution, support for plug-ins like Flash, etc.). An HTML request for a webpage from a browser may include an \u201cagent string\u201d that identifies browser characteristics, including browser type. A web server can respond to the request differently depending on whether the agent string indicates that the request came from a mobile versus a desktop browser. Suppose a user is viewing a mobile version of a webpage on the mobile device through the mobile browser application, and the user then docks with the desktop environment.","In one scenario, the mobile version of the webpage is displayed on the desktop environment as a remotely rendered window of the mobile browser. For example, techniques for remote rendering in this way are described in U.S. patent application Ser. No. 13\/246,665, filed Sep. 27, 2011, entitled \u201cInstant Remote Rendering,\u201d the entire contents of which is incorporated herein by reference. This type of remote rendering may be implemented as a default condition for all pages being viewed prior to a docking event. Alternatively, the remote rendering may be invoked after a determination is made that the mobile version of the webpage would not render (e.g., that requesting the mobile version of the webpage from the desktop browser would result in an error) or that the webpage would render improperly or in an undesirable way.","In another scenario, the URL of the mobile version of the webpage is transferred to the desktop browser as context information. The desktop browser can then request the URL again and\/or use any cached information (e.g., which may be stored as user data or context information). Depending on the implementation of the webpage, a number of results are possible. For example, the desktop may be able to display the information returned from the web server, the web server may return an error indicating that the browser is incompatible with the request, the web server may reinterpret the request and return the desktop version of the requested website, etc. Alternatively, the desktop browser may be configured to change the agent string in the request to appear as a mobile browser.","Another such browser-related issue can occur when the user is interacting with content over an SSL session, or the like. Some embodiments may simply not allow transfer of this session to the desktop environment (e.g., to the desktop browser), and may, for example, return an error, warning, or other indication. Other embodiments establish the SSL session through a proxy server, which may effectively route the SSL session to the appropriate mobile or desktop browser. For example, the proxy server may be configured to act as a network address translator (NAT), which handles the SSL session and routes the session communications (e.g., securely) to one or more of the mobile or desktop browsers. Still other embodiments remotely render the SSL session from the mobile browser to the desktop environment, as discussed above. Any of these embodiments may further include detecting the SSL session prior to performing functionality to handle the SSL session.","Yet another such browser-related issue can occur when the user is interacting with a webpage that involves cookies, or the like, prior to the docking event. According to some embodiments, the cookie information either transfers to the desktop browser environment upon docking or is stored as context information that is accessible to the desktop browser. Certain types of cookies and the like cannot transfer (or at least cannot transfer in a way that is reliable or useful). Accordingly, some embodiments handle this type of cookie information either by ignoring it, by translated it to transferable information where possible, etc. Similar scenarios may be handled by various embodiments in the context of user authentication information, tokens, etc. For example, in the case of a webpage to which the user has logged in, after docking, the desktop browser may return the user to a login page or display the page without incident, depending on the implementation of the webpage's source code, etc. Alternatively, that type of user authentication may be detected, and the docking event may cause the transfer of the interaction environment to be handled otherwise (e.g., by remote rendering, by proxy server handling, etc.).","Still another such browser-related issue can occur when the user is interacting with web-based content that involves user data. Depending on the implementation of the content, the user data may be stored locally and\/or non-locally. For example, a web-based productivity application (e.g., word processor, spreadsheet application, etc.), game, etc. may include a current user state, selected text, settings, etc. Embodiments typically handle locally stored data as discussed above. Regarding non-local data, some embodiments either re-request the data for the new browser environment when needed after docking or ignore the data when it cannot practically be re-requested.","Even another such browser-related issue can occur when the user is interacting with (e.g., actively interacting or just has open) multiple webpages concurrently. Typically, mobile browsers are configured to display only a single webpage (or a very limited number of webpages) at a time, while desktop browsers can use multiple browser windows and\/or multiple tabs to display many webpages at a time. Some embodiments transfer each open webpage in the mobile browser to a new tab or window in the desktop browser (e.g., according to user settings, default settings, etc.). As discussed above, a number of cases can arise in which the webpage cannot simply be transferred (or cannot be transferred in a desirable way) from the mobile environment to the desktop environment. According to certain embodiments, each webpage to be transferred is treated independently. For example, for each webpage that cannot be simply transferred, the webpage is either not transferred (e.g., kept on the mobile environment only), displayed through remote rendering, translated to an appropriate desktop version, routed through a proxy, etc.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 12","b":["1200","1200","1202","1204","1206","1208","1200"]},"It will be appreciated that the above issues and scenarios are intended only to be illustrative of possible cases and techniques for handling those cases. Many other similar cases are possible and can be handled according to the techniques described above. Further, descriptions referring specifically to webpages can, in most cases, also be handled similarly for other web-based content, such as web-based (e.g., cloud-based, software-as-a-service, etc.) games and applications. As such the specific descriptions above of client-server applications should not be construed as limiting the scope of embodiments described herein.","The foregoing description has been presented for purposes of illustration and description. Furthermore, the description is not intended to limit embodiments of the invention to the form disclosed herein. While a number of exemplary aspects and embodiments have been discussed above, those of skill in the art will recognize certain variations, modifications, permutations, additions, and sub-combinations thereof.","The various operations of methods described above may be performed by any suitable means capable of performing the corresponding functions. The means may include various hardware and\/or software component(s) and\/or module(s), including, but not limited to a circuit, an application specific integrated circuit (ASIC), or processor.","The various illustrative logical blocks, modules, and circuits described may be implemented or performed with a general purpose processor, a digital signal processor (DSP), an ASIC, a field programmable gate array signal (FPGA), or other programmable logic device (PLD), discrete gate, or transistor logic, discrete hardware components, or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor, but in the alternative, the processor may be any commercially available processor, controller, microcontroller, or state machine. A processor may also be implemented as a combination of computing devices, e.g., a combination of a DSP and a microprocessor, a plurality of microprocessors, one or more microprocessors in conjunction with a DSP core, or any other such configuration.","The steps of a method or algorithm described in connection with the present disclosure, may be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module may reside in any form of tangible storage medium. Some examples of storage media that may be used include random access memory (RAM), read only memory (ROM), flash memory, EPROM memory, EEPROM memory, registers, a hard disk, a removable disk, a CD-ROM and so forth. A storage medium may be coupled to a processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor. A software module may be a single instruction, or many instructions, and may be distributed over several different code segments, among different programs, and across multiple storage media.","The methods disclosed herein comprise one or more actions for achieving the described method. The method and\/or actions may be interchanged with one another without departing from the scope of the claims. In other words, unless a specific order of actions is specified, the order and\/or use of specific actions may be modified without departing from the scope of the claims.","The functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored as one or more instructions on a tangible computer-readable medium. A storage medium may be any available tangible medium that can be accessed by a computer. By way of example, and not limitation, such computer-readable media can comprise RAM, ROM, EEPROM, CD-ROM, or other optical disk storage, magnetic disk storage, or other magnetic storage devices, or any other tangible medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc, as used herein, include compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk, and Blu-ray\u00aedisc where disks usually reproduce data magnetically, while discs reproduce data optically with lasers.","Thus, a computer program product may perform operations presented herein. For example, such a computer program product may be a computer readable tangible medium having instructions tangibly stored (and\/or encoded) thereon, the instructions being executable by one or more processors to perform the operations described herein. The computer program product may include packaging material.","Software or instructions may also be transmitted over a transmission medium. For example, software may be transmitted from a website, server, or other remote source using a transmission medium such as a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technology such as infrared, radio, or microwave.","Further, modules and\/or other appropriate means for performing the methods and techniques described herein can be downloaded and\/or otherwise obtained by a user terminal and\/or base station as applicable. For example, such a device can be coupled to a server to facilitate the transfer of means for performing the methods described herein. Alternatively, various methods described herein can be provided via storage means (e.g., RAM, ROM, a physical storage medium such as a CD or floppy disk, etc.), such that a user terminal and\/or base station can obtain the various methods upon coupling or providing the storage means to the device. Moreover, any other suitable technique for providing the methods and techniques described herein to a device can be utilized.","Other examples and implementations are within the scope and spirit of the disclosure and appended claims. For example, due to the nature of software, functions described above can be implemented using software executed by a processor, hardware, firmware, hardwiring, or combinations of any of these. Features implementing functions may also be physically located at various positions, including being distributed such that portions of functions are implemented at different physical locations. Also, as used herein, including in the claims, \u201cor\u201d as used in a list of items prefaced by \u201cat least one of\u201d indicates a disjunctive list such that, for example, a list of \u201cat least one of A, B, or C\u201d means A or B or C or AB or AC or BC or ABC (i.e., A and B and C). Further, the term \u201cexemplary\u201d does not mean that the described example is preferred or better than other examples.","Various changes, substitutions, and alterations to the techniques described herein can be made without departing from the technology of the teachings as defined by the appended claims. Moreover, the scope of the disclosure and claims is not limited to the particular aspects of the process, machine, manufacture, composition of matter, means, methods, and actions described above. Processes, machines, manufacture, compositions of matter, means, methods, or actions, presently existing or later to be developed, that perform substantially the same function or achieve substantially the same result as the corresponding aspects described herein may be utilized. Accordingly, the appended claims include within their scope such processes, machines, manufacture, compositions of matter, means, methods, or actions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present invention are illustrated in referenced figures of the drawings, in which like numbers refer to like elements throughout the description of the figures.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 10","FIG. 7"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
