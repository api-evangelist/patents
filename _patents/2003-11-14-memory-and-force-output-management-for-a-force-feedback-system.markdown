---
title: Memory and force output management for a force feedback system
abstract: Methods and apparatus for efficient management of memory and force output in a force feedback system including a host computer and a force feedback device. A representation of device memory is maintained on the host computer to allow the host computer knowledge and control over storage and force effects in the device memory. A host cache for force effects is provided to allow almost unlimited numbers of force effects to be created for the device, where any force effects not able to fit in device memory are stored in the host cache. Other aspects of the invention include a playlist stored on the device of force effects being played by the device, and management of force output using relatively small, discrete time intervals.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07299321&OS=07299321&RS=07299321
owner: 
number: 07299321
owner_city: 
owner_country: 
publication_date: 20031114
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS","Host Computer Force Feedback Architecture","Memory Management of Force Effects","Effect Caching on the Host Computer"],"p":["This application claims the benefit of and is a divisional of U.S. application Ser. No. 10\/060,472, filed Jan. 29, 2002, now U.S. Pat. No. 6,715,045, which is a continuation of U.S. application Ser. No. 09\/401,564, filed on Sep. 22, 1999, now U.S. Pat. No. 6,343,349, which is a continuation of U.S. application Ser. No. 09\/305,872, filed on May 5, 1999, now U.S. Pat. No. 6,252,583, which is a continuation-in-part of U.S. application Ser. No. 08\/970,953, filed Nov. 4, 1997, now U.S. Pat. No. 6,300,936, each of which is assigned to the assignee of the present application, and each of which is incorporated in its entirety herein by reference.","The present invention relates generally to interface devices for allowing humans to interface with computer systems, and more particularly to computer interface devices that allow the user to provide input to computer systems and provide force feedback to the user.","Computer systems are used extensively to implement many applications, such as word processing, data management, simulations, games, and other tasks. A computer system typically displays a visual environment to a user on a display screen or other visual output device. Users can interact with the displayed environment to perform functions on the computer, play a game, experience a simulated environment, use a computer aided design (CAD) system, etc. One visual environment that is particularly common is a graphical user interface (GUI), and include such systems as the Windows\u2122 operating system from Microsoft Corporation, the MacOS operating system from Apple Computer, Inc., and X-Windows for the Unix operating system. Most GUI's are currently 2-dimensional as displayed on a computer screen; however, three dimensional (3-D) GUI's with 3-D environments can also be provided. Other graphical environments include games, simulations, CAD environments, World Wide Web\/Internet interfaces, etc. which present 2-D or 3-D interactive environments manipulatable by the user.","The user interaction with and manipulation of the computer environment is achieved using any of a variety of types of human-computer interface devices that are connected to the computer system controlling the displayed environment. In most systems, an application program running on the host computer updates the environment in response to the user's manipulation of a user manipulandum that is included in the interface device, such as a mouse, joystick handle, track ball, steering wheel, etc. The computer provides feedback to the user utilizing the display screen.","Force feedback interface devices allow a user to experience forces on the manipulandum based on interactions and events within the displayed graphical environment. Force feedback devices can be implemented in many forms, such as a joystick, mouse, steering wheel, etc. Typically, computer-controlled actuators are used to output forces on the user object in provided degrees of freedom to simulate various sensations, such as an obstruction force when moving a cursor into a wall, a vibration force when a virtual race car drives off a race track, or a spring force to bias a cursor to move back toward a starting position of the spring.","Force sensations are usually commanded to be output on the device by the application program running on the host computer. Most consumer-market force feedback devices include a microprocessor and memory to parse host commands and store and manage various force feedback effects local to the device. The device microprocessor can check user input and other conditions based on commands from the host, and can output force sensations using the force sensation data stored in local memory. The local management of force sensations on the device greatly increases the realism of generated force sensations due to the responsiveness of the device processing; if the host had to process all input and generate all forces, the transmission of data between host and device would cause delays in responsiveness that would seriously degrade the quality of force sensations. Thus, the ability of the device to store force sensation data and independently command those force sensations when conditions warrant is critical to realistic force feedback.","When providing force feedback sensations on a force feedback device, several issues arise as to the management of force feedback sensations. One problem is that the memory on the force feedback device is limited due to cost concerns. A device may only be able to store a certain limited number of force sensation data (\u201cforce effects\u201d) before the local memory is filled. An application program, however, may require a large number of different force effects to be output during different conditions and events in the program. For example, a racing game program may wish to output 20 different force effects for various racing conditions during a game; however, the device may only be able to store data for 10 force effects at a time.","Since data for a force effect should be stored local to the device before the force is output, the application program must first attempt to store effect data to the device. One existing way to store force effects on a device is for the host application to send a request to the device to store a specified force effect in device memory. The device determines if sufficient memory is available and responds to the host that either the requested force effect has been stored in device memory, or that the requested force effect could not be stored due to lack of sufficient space. If the effect could not be stored, the host application can send a \u201cdestroy\u201d command to the device to remove a currently-unused force effect from device memory to free up sufficient room for the requested force effect, and then send the request again to store the new force effect. However, this method can cause some degradation in force quality on the device since the device and host must transmit data several times back and forth to free up device memory and store a new force effect.","In addition, since the device memory usually cannot store all the force effects which a host application wishes to use, the host application must spend processing time for memory management tasks. For example, the host application must determine whether to swap out an old force effect in device memory with a new force effect and then command that such a swap take place. The application must keep track of how much space is available in device memory and which force effects are currently being output. Such extra processing by the host application can degrade the overall performance of the application and compels the designer of the application to focus on low-level processing, thereby detracting from the higher-level force design process.","The present invention is directed to memory management of force effects and other management of force sensations for a force feedback system. Embodiments are disclosed which provide for efficient management of device memory and force effect output.","More specifically, the present invention provides force effects with a force feedback device having local control of the output of force sensations. A representation of device memory is created, where the device memory is provided on the force feedback device, and the representation is allocated in memory of the host computer. A force effect load command is received from an application program running on the host, where the force effect load command instructs that data for a force effect be stored in the device memory. It is then determined whether the device memory can store the force effect by examining the representation of device memory. If the device memory can store the force effect, the data for the force effect is send to the force feedback device to be stored in the device memory. The force feedback device uses the data to control a force output to a user of the force feedback device. If the device memory can store the force effect, the data for said force effect can be stored in a location of the representation of device memory, or an indication of the memory space taken by the force effect can be stored. The application program can later send a play command or a stop command, which is sent to the force feedback device to output or stop the output of force based on the loaded force effect. The total number of playing force effects loaded to the device are summed to provide the total output force on the user.","In a different aspect of the present invention, the management of storage of force effects in a force feedback system includes receiving a force effect create command by a driver running on the host computer. The command is sent from an application program running on the host computer and instructs that particular force effect data for a particular force effect be stored in memory local to the force feedback device. It is then determined whether the local memory has sufficient space to store the particular force effect data. If there is sufficient space, the particular force effect data is sent to the force feedback device to be stored in the local memory. If there is not sufficient space, the particular force effect data is stored in a cache implemented in host computer memory instead of the local memory. When a command is later received by the driver to output the cached force effect to a user of the force feedback device, the driver swaps the particular force effect data with loaded force effect data in the local memory and instructs the force feedback device to output the particular force effect.","Preferably, the driver creates a representation of the local memory in the host computer memory, and the representation can be examined for sufficient space for the force effect. Alternatively, the force feedback device can be queried and a response can be received indicating whether sufficient space is available. In addition, it can be determined whether a force effect can be loaded by comparing a priority of the particular force effect with a priority of one or more loaded force effects, where the greater priority effect can be loaded to the device memory. Priority of the loaded force effect(s) can be determined based at least partially on whether the loaded force effect is currently being output by the device, on the time period since the loaded force effect was last output by said device, and\/or on whether said loaded force effect is likely to be output based on a direction of movement of a manipulandum of the force feedback device in a workspace of the manipulandum of the device. The priority can also be predefined, e.g. by the application program. Furthermore, force effects can be grouped in categories to help determine which loaded force effects can be swapped with cached force effects. An apparatus for managing storage of effect using a host cache operates as described above.","In a different aspect of the present invention, forces are output from a force feedback device coupled to a host computer. A force effect play command is received from the host computer which instructs that a particular force effect be output by the force feedback device. The data for the particular force effect and data for at least one other force effect is stored in a memory local to the force feedback device. An identification of the particular force effect is designated in a playlist in local memory. When a force is to be output, the playlist is examined to determine which of the stored force effects are to be output. A force is then determined based on the force effects designated in the playlist and the force is output to a user of the force feedback device. Preferably, the output force is based on a sum of contributions from the force effects designated in the playlist. A number can be stored in local memory indicating how many the force effects stored in local memory are currently designated to be output. This allows efficient access to only the playing force effects on the device.","In yet another aspect of the present invention, force output is provided to a user of a force feedback device only at predetermined time intervals. A first force to be output by actuators of the force feedback device is determined and then output at a first point in time occurring when a predetermined time interval has passed. A second force to be output is then determined. If the predetermined time interval has not passed when the second force has been determined, then the device waits for a second time interval and outputs the second force at a second point in time. If the predetermined time interval has passed when the second force has been determined, indicating the processing of the force has taken longer than one time interval, then the device waits for a successive time interval after an integer number of the predetermined time intervals has passed, and outputs a third force at the successive point in time. The third force is appropriate to the successive point in time. For example, the first force and the second force can be at least partially based on a periodic function that varies with time, so that the third force is based on an appropriate later point of the periodic function. This allows a small time interval to be used and thus faster updating of output forces; during infrequent intervals where force processing takes longer than one time interval, the force can be output at later intervals.","The present invention provides several embodiments for managing force effect and force output in a force feedback system. A representation of the device memory is preferably maintained in host computer memory to allow the host computer to efficiently determine when effects can be loaded in device memory. Host caching of force effects allows the application program to function as if the device can store an almost unlimited number of effects, thereby freeing the application from managing low-level processing and swapping of force effects. The playlist and discrete interval force output on the force feedback device allows efficient and high fidelity output of force sensations.","These and other advantages of the different embodiments of the present invention will become apparent to those skilled in the art upon a reading of the following specification of the invention and a study of the several figures of the drawing.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["10","10","18","11"]},"Host computer  is preferably a personal computer or workstation, such as a PC compatible computer or Macintosh personal computer, or a SUN or Silicon Graphics workstation. Alternatively, host computer system  can be one of a variety of home video game systems commonly connected to a television set, such as console systems available from Nintendo, Sega, or Sony. In other embodiments, host computer system  can be a \u201cset top box\u201d which can be used, for example, to provide interactive television functions to users, or a \u201cnetwork-\u201d or \u201cinternet-computer\u201d which allows users to interact with a local or global network using standard connections and protocols such as used for the Internet and World Wide Web.","Host computer  commonly includes a host microprocessor , random access memory (RAM) , read-only memory (ROM) , input\/output (I\/O) electronics , a clock , a display device , and an audio output device . Host microprocessor  can include a variety of available microprocessors from Intel, AMD, Motorola, or other manufacturers. Microprocessor  preferably retrieves and stores instructions and other necessary data from RAM  and ROM  as is well known to those skilled in the art. In the described embodiment, host computer  can receive sensor data or a sensor signal via a bus  from sensors of device  and other information. Microprocessor  can receive data from bus  using I\/O electronics , and can use the I\/O electronics, bus , and\/or other buses to control other peripheral devices, such as disk drives, hard drives, CDROM, DVDROM, non-volatile memory etc. Host computer  can also output commands to interface device  via bus  to cause force feedback for the system .","Computer  can operate under the Window\u2122, MacOS, Unix, or other operating systems, or other software. Host computer  preferably implements one or more application programs (\u201capplications\u201d) with which a user is interacting via mouse  and other peripherals, if appropriate, and which can include force feedback functionality. For example, the host applications can include a simulation, video game, Web page or browser that implements HTML or VRML instructions, word processor, drawing program, spreadsheet, scientific analysis program, or other application program that utilizes user input from device  and outputs force feedback commands to the device . In the preferred embodiment, multiple applications can run simultaneously in a multitasking environment of the host computer. Herein, computer  may be referred as displaying \u201cgraphical objects\u201d or \u201ccomputer objects.\u201d These objects are not physical objects, but are logical software unit collections of data and\/or procedures that may be displayed as images by computer  on display screen , as is well known to those skilled in the art. A displayed cursor or a simulated cockpit of an aircraft might be considered a graphical object. Suitable software drivers which interface such applications with computer input\/output (I\/O) devices are available from Immersion Corporation of San Jose, Calif.","Display device  can be included in host computer  and can be a standard display screen (LCD, CRT, etc.), 3-D goggles, or any other visual output device. Typically, the host application provides images to be displayed on display device . For example, display screen  can display images from a GUI, from a moving, first person point of view in a virtual reality game, a third-person perspective of objects, backgrounds, a simulation (such as a medical simulation), etc.","Clock  is a standard clock crystal or equivalent component used by host computer  to provide timing to electrical signals used by host microprocessor  and other components of the computer . Audio output device , such as speakers, can be coupled to host microprocessor  via amplifiers, filters, and other circuitry well known to those skilled in the art. Host processor  outputs signals to speakers  to provide sound output to the user when an \u201caudio event\u201d occurs during the implementation of the host application program. Other types of peripherals can also be coupled to host processor , such as storage devices (hard disk drive, CD ROM drive, floppy disk drive, etc.), printers, and other input and output devices.","Force feedback device  is coupled to host computer system  by a bi-directional bus . The bi-directional bus sends data in either direction between host computer system  and the interface device . Bus  can be a serial interface bus providing data according to a serial communication protocol, a parallel bus using a parallel protocol, or other types of buses. An interface port of host computer system , such as a USB or RS232 serial interface port, connects bus  to host computer system . Alternatively, Firewire (also called IEEE 1394) can be used as bus ; or, the bus can be between an interface card in the host computer , where the interface card holds components of device  such as microprocessor . In other embodiments, signals can be sent between interface  and computer  by wireless transmission\/reception.","Force feedback device  includes an electronic interface , a mechanical portion , and a manipulandum or \u201cuser object\u201d . Electronic interface , mechanical portion , and user object  can also collectively be considered the force feedback device .","The electronic portion  of interface  may couple the mechanical portion  of the interface to the host computer . The electronic portion  is preferably included within a housing of the device  or, alternatively, the electronic portion may be included in host computer  or as a separate unit with its own housing. Electronic interface  includes a local microprocessor , local clock , local memory , sensor interface , and actuator interface . Interface  may also include additional electronic components for communicating via standard protocols on bus . In various embodiments, electronic interface  or components thereof can be included in mechanical portion , in host computer , or in its own separate housing.","Local microprocessor  preferably coupled to bus  and may be closely linked to mechanical portion  to allow fast communication with other components of the interface device. Processor  is considered \u201clocal\u201d to interface device , where \u201clocal\u201d herein refers to processor  being a separate microprocessor from any processors  in host computer . \u201cLocal\u201d also preferably refers to processor  being dedicated to force feedback and sensor I\/O of the system , and being closely coupled to sensors and actuators of the mechanical portion , such as within the housing of or in a housing coupled closely to portion . Microprocessor  can be provided with software instructions to wait for commands or requests from computer host , parse\/decode the command or request, and handle\/control input and output signals according to the command or request. In addition, processor  preferably operates independently of host computer  by reading sensor signals and calculating appropriate forces from those sensor signals, time signals, and force processes selected in accordance with a host command, and output appropriate control signals to the actuators. A suitable microprocessor for use as local microprocessor  includes the 8X930AX by Intel; or alternatively the MC68HC711E9 by Motorola or the PIC16C74 by Microchip, for example. Microprocessor  can include one microprocessor chip, or multiple processors and\/or co-processor chips. In other embodiments, microprocessor  can include digital signal processor (DSP) functionality or be implemented as state logic or circuitry.","In a local control embodiment that utilizes microprocessor , host computer  provides high level supervisory commands to microprocessor  over bus , and microprocessor  manages low level force control loops to sensors and actuators in accordance with the high level commands and independently of the host computer . The microprocessor  can process inputted sensor signals to determine appropriate output actuator signals by following the instructions of a \u201cforce process\u201d that may be stored in local memory and includes calculation instructions, formulas, force magnitudes, or other data. The force process can command distinct force sensations, such as vibrations, textures, jolts, or even simulated interactions between displayed objects. The microprocessor can be provided with the necessary instructions or data to check sensor readings, determine graphical object positions, and determine output forces independently of host computer . The host can implement program functions (such as displaying images) when appropriate, and synchronization commands can be communicated between the microprocessor and host  to correlate the microprocessor and host processes. Sensor signals (and\/or processed sensor signals) received and used by microprocessor  are also reported to host computer system , which updates the host application program. Such commands and related functionality is discussed in greater detail in U.S. Pat. No. 5,734,373. The host can send the local processor a spatial layout of objects in the graphical environment to store in local memory  so that the microprocessor has a mapping of locations of graphical objects like enclosures and can determine interactions with the cursor locally. Alternatively, the computer  can directly send force feedback signals to the microprocessor  to be directly output to actuators and provide forces on user object . Force feedback used in graphical environments is described in greater detail in co-pending patent application Ser. Nos. 08\/571,606, and 08\/924,462, and U.S. Pat. No. 5,825,308, all of which are incorporated by reference herein. In a different embodiment, host computer  can provide low-level force commands over bus , which microprocessor  directly transmits to the actuators.","A local clock  can be coupled to the microprocessor  to provide timing data, similar to system clock  of host computer ; the timing data might be required, for example, to compute forces output by actuators  (e.g., forces dependent on calculated velocities, accelerations, or other time dependent factors). In alternate embodiments using the USB communication interface or other bus having a synchronization signal, timing data for microprocessor  can be retrieved from the USB interface.","Local memory , such as RAM and\/or ROM, is preferably coupled to microprocessor  in interface  to store force sensations (\u201cforce effects\u201d), other instructions for microprocessor , and store temporary and other data. Microprocessor  may also store calibration parameters in a local memory . Memory  may also be used to store the state of the force feedback device, including a reference position, current control mode or configuration, etc. Memory management techniques of the present invention for local memory  are described in greater detail below.","Sensor interface  may optionally be included in electronic interface  to convert sensor signals to signals that can be interpreted by the microprocessor  and\/or host computer system . Such circuits, or equivalent circuits, are well known to those skilled in the art. Alternately, microprocessor  or host  can perform these interface functions. Actuator interface  can be optionally connected between the actuators  and microprocessor  to convert signals from microprocessor  into signals appropriate to drive the actuators. Interface  can include power amplifiers, switches, digital to analog controllers (DACs), and other components as well known to those skilled in the art. In alternate embodiments, interface  circuitry can be provided within microprocessor  or in the actuators. Power supply  can be used to supply power to the actuators  and other components. Power can also be supplied by the host computer over USB .","Mechanical portion  is coupled to electronic portion  and preferably includes sensors , actuators , and mechanism . Sensors  sense the position, motion, and\/or other characteristics of manipulandum  along one or more degrees of freedom and provide signals to microprocessor  including information representative of those characteristics. A sensor  is provided for each degree of freedom of the manipulandum , or, a single compound sensor can be used for multiple degrees of freedom. Example of sensors suitable for embodiments described herein are rotary optical encoders, as described above, linear optical encoders, analog sensors such as potentiometers, or non-contact sensors, such as Hall effect magnetic sensors or an optical sensor such as a lateral effect photo diode having an emitter\/detector pair. In addition, velocity sensors (e.g., tachometers) and\/or acceleration sensors (e.g., accelerometers) for measuring acceleration can be used. Furthermore, either relative or absolute sensors can be employed.","Actuators  transmit forces to user object  in one or more directions along one or more degrees of freedom in response to signals output by microprocessor  and\/or host computer , i.e., they are \u201ccomputer controlled.\u201d Typically, an actuator  is provided for each degree of freedom along which forces are desired to be transmitted. Actuators  can be electromagnetic actuators such as DC motors, or can be other active actuators, such as linear current control motors, stepper motors, pneumatic\/hydraulic active actuators, a torquer (motor with limited angular range), voice coil motors; or passive actuators such as magnetic particle brakes, friction brakes, or pneumatic\/hydraulic passive actuators, passive damper elements, an electrorheological fluid actuator, a magnetorheological fluid actuator. In some embodiments, all or some of sensors  and actuators  can be included together as a sensor\/actuator pair transducer.","Mechanism  can any of several types of mechanisms. For example, mechanisms disclosed in co-pending patent applications Ser. Nos., 08\/664,086, 08\/709,012, and 08\/736,161, or U.S. Pat. Nos. 5,623,582, 5,731,804, 5,767,839, 5,721,566, 5,805,140, and 5,691,898, all incorporated herein by reference, can be included.","User object  is a physical object that is preferably grasped or gripped and manipulated by a user. By \u201cgrasp,\u201d it is meant that users may physically engage a portion of the object in some fashion, such as by hand, with their fingertips, etc. A great number of types of user manipulable objects can be used with the method and apparatus of the present invention. For example, such objects may include a mouse, sphere, a puck, a joystick, cubical- or other-shaped hand grips, a fingertip receptacle for receiving a finger or a stylus, a flat planar surface like a plastic card having a rubberized, contoured, and\/or bumpy surface, a gamepad, a steering wheel, a pool cue, a handheld remote control used for controlling web pages or other devices, or other objects.","Other input devices  can optionally be included in system  and send input signals to microprocessor  and\/or host computer . Such input devices can include buttons, switches, dials, knobs, or other controls used to supplement the input from the user to an application program. Also, voice recognition hardware (with software implemented by host ), or other input mechanisms can be used. Safety or \u201cdeadman\u201d switch  is preferably included in interface device to provide a mechanism to allow a user to deactivate actuators  for safety reasons. The user must continually close safety switch  during manipulation of user object to enable the actuators . A capacitive contact sensor, mechanical switch, electrostatic contact switch, or optical switch, z-axis force sensor, piezo electric sensor, force sensitive resistor, a strain gauge, or a hand weight safety switch can be used to sense the presence of the user's contact with the user object.","The host computer  interacts with interface device , in the present invention, using a number of different levels of controllers. These controllers are preferably implemented in software, e.g. program instructions or code, and such is the embodiment described herein; however, all or part of the controllers may also be implemented in hardware, where the conversion of functionality of the software to hardware is well known to those skilled in the art. The architecture described herein is oriented towards providing force feedback functionality for a system including a host computer connected to a force feedback interface device, where the interface device stores force information from the host and receives commands from the host to implement forces based on the stored information. The described architecture is most applicable to a computer such as a PC, Macintosh, workstation, etc., and is not as applicable to other host computers such as console game systems. However, such other systems often include the equivalent to many of the described control levels. For example, a game program on a console can be considered an application and a library on the console that is accessed by function calls from the game program can be the equivalent of the API and\/or translation layers.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 2","b":["11","202","204","18","20"]},"A master application  may also be running on host computer  and is referred to as the \u201cbackground\u201d force feedback application. This application is preferably a general purpose program that always runs inactively in the operating system and whose set of commanded forces are always available to be output and controlled on the interface device  and\/or other devices. An example interface window for master application is a \u201cdesktop\u201d control panel for force feedback, described in greater detail in the parent application Ser. No. 08\/970,953. The types of forces possible to be output by the device are described in greater detail in co-pending patent applications Ser. Nos. 08\/839,249 and 08\/877,114 and U.S. Pat. No. 5,734,373, all incorporated by reference herein.","The force sensations specified by the background application will be output by the force feedback device by default, unless a different foreground application program deactivates the force sensations or replaces a force sensation with its own. For example, a background-specified snap force is preferably applied to all menus of all running application programs in the GUI, since it is a background force effect. If the foreground active application program has its own force sensations which define that application's menus to have a jolt instead of a snap, then the jolt will be superimposed on the snap unless the active application program deactivates the background force(s). In general, a particular active application program can only command forces to objects of its own, e.g., that application's own menus, windows, scrollbars, icons, window borders, etc.","A user can specify multiple background force sensations for each graphical object. This allows the multiple force sensations to be superimposed on each other, unless the application program overrides one or more of the superimposed forces. Thus, a user can assign a damper force sensation and a \u201cticks\u201d force sensation to scrollbars, and all scrollbars will have these forces associated with them unless overridden by the foreground application program. Other controls in the background application can include a device gain to set the percentage of maximum magnitude for all the forces of the background application.","Application programs , , and  communicate with a force feedback Application Programming Interface (\u201cAPI\u201d)  which is resident in the host computer's memory and which allows a given application program to communicate with lower level drivers and other force feedback functions. For example, in the Windows operating system, API's are commonly used to allow a developer of an application program to call functions at a high level for use with the application program, and not worry about the low level details of actually implementing the function.","The API of the present invention includes a set of software \u201cobjects\u201d that can be called to command a force feedback interface device . Objects are a set of instructions and\/or data which can be called by a pointer and\/or an identifier and parameters to implement a specified function. For example, three types of objects are provided in one preferred API implementation: interface objects, device objects, and effect objects. Each of these objects makes use of one or more force feedback device drivers which are implemented as objects in the API .","Interface objects represent the API at the highest level. An application program (which is referred to as a \u201cclient\u201d of the API) can create an interface object to access lower level objects and code that implement force feedback device functionality. For example, the interface object allows an application program to enumerate and receive information about individual devices and create lower level objects for each device used by the application program.","Device objects each represent a physical force feedback device (or other compatible device or peripheral) in communication with the host computer . For example, the force feedback device  would be represented as a single device object. The device objects access the set of force feedback routines to receive information about an associated physical device, set the properties of the physical device, register event handlers (if events are implemented on the host), and to create effect objects.","Effect objects each represent a force feedback effect defined by the application program to be output one or more times to the user using a force feedback device. The effect objects access the set of force feedback routines to download force effects to the force feedback device, start and stop the output of force effects by the force feedback device, and modify the parameters of the effects.","A \u201cforce effect,\u201d as referred to herein, is a definition for a force or series of forces that may be commanded within the API. The force effect typically has a name (identifier) to identify it and one or more parameters to characterize the force effect as desired. For example, several types of force effects have been defined, including vibrations, enclosures, grids, textures, walls, dampers, snap sensations, vibrations, circles, ellipses, etc. For example, a vibration force effect may have parameters of duration, frequency, magnitude, and direction. The force sensations output to the user can be derived from one or more force effects (e.g., force effects can be superimposed on each other). Force effects, in turn, are made up of one or more basic force prototypes, such as springs, dampers, and vector forces.","In some embodiments, an application program client interacts with the API  by first receiving a pointer to a resident force feedback interface; for example, a preferred interface includes procedures specified by the Component Object Model (COM) of Microsoft Windows, an object oriented model for constructing interfaces (embodiments in which host computer  is a console game system, for example, may use other software architectures). Using the force feedback interface, the application program enumerates the force feedback devices on the computer system . The application program selects a desired one of the force feedback devices and creates a device object associated with that device. Using the force feedback interface, the application then acquires the device, sets the device up with setup and default parameters, and creates effect objects and event objects during the execution of the application program at times designated by the developer of the application. At appropriate times, the application program will command the creation\/destruction of force effects and the start, stop, or, pause of the playback of force effects by accessing the appropriate interface instructions associated with the desired effect. If appropriate (see below), the API can indicate to a context driver  to create a \u201ccontext\u201d (i.e. \u201ceffect set\u201d) for an application program, and sends effects and events to be associated with that context. A \u201ccontext\u201d is a group or set of effects and events that are associated with a particular application program.","In embodiments allowing multiple application programs to be simultaneously running on the host, each application program may have its own set of force sensations to output to the force feedback device. Since the device cannot implement all force sensations at any one time due to cost and hardware constraints, the forces commanded by each application must be organized by the architecture to take these limitations into account.","Context driver  is used to implement force effects for multiple application programs. Context driver  receives contexts  and device manipulation data  from the API . The context driver is provided at a level below the API to organize contexts for applications  and  running on the host computer. In the preferred embodiment, the effects and events in a context are not known to the application program itself, rather, the context driver  creates a context internally for an application. Thus, an application commands that a particular force sensation be output in response to different interactions or occurrences, e.g., an interaction of a cursor with an object or region, or the output of a force based on other criteria (time, received data, random event, etc.). The API sends the commanded effect(s) to the context driver , and the context driver stores the effects in the context created for that application program.","Since each application may have a completely different set of force effects to output, each context must be associated with its particular application program. In the preferred embodiment, there are two types of contexts: foreground contexts and background contexts. One foreground context is associated with the application program  or  that is currently active in the operating system. Different foreground contexts can include the effects and events for inactive application programs. A background (primary) context includes effects for the master application program . In addition, a \u201cglobal context\u201d can be provided, which includes common effects almost always used by application programs (e.g. a pop force) and which can automatically be downloaded to the force feedback device. Effects in the global context need not be stored in individual contexts for particular application programs.","When an application program is first executed by the host computer and loaded into memory, if the application is able to command a force feedback device, the application will query for the API . Once communication is established, the API will contact the context driver  to create an entry location for a context set for the initiated application program.","The context driver  receives individual effects and events as they are created by the application program using API  and stores the effects and events in a context list , storing each context in a different storage location in the host's memory or on some other type of storage device. An active or inactive application program can create a context and have it stored, but only the active application's context will be sent to the force feedback device. The context driver  can examine an identifier in a created effect or event to determine which application program is associated with it and thus store the effect or event in the proper memory location. The context driver sets pointers to the contexts and to the effects and events in the contexts to access them. An effect can be created initially when the application program is first executed, before any forces are commanded, or the effect can be later created during application execution and then immediately commanded to be played by the force feedback device. Each context also preferably includes an entry into a device state structure. This entry governs the \u201cgain\u201d or force level for all effects in the context. For example, all the forces in the context can be cut to 50% of full magnitude by storing a value of 50 in the device state structure. One of the contexts stored in list  is a primary context , which is the list of effects and events used by the master application  or \u201cbackground\u201d application.","At a later time, after the context driver has stored the contexts in list , an application program may send a command to the API to output or \u201cplay\u201d a particular force sensation. The API checks whether the application program is active or in the background (primary); if not, the API does not send any data to the device and\/or to the lower drivers. Alternatively, the commands from an inactive foreground application can be stored and then sent to the device when the application becomes active. If the application is active or background, the API sends the start information to the context driver  indicating the application program that commanded the force and the particular force effects to be commanded. The context driver  then associates the commanding application program with a context  in list  and sends the effects from the context to the force feedback device (if not previously sent). For example, if a context for a particular application program includes a spring effect, a damper effect, and a vibration effect, and the application program commands the vibration to be output, then the context driver selects the vibration effects to be output to the device. The data describing this effect is then output by the context driver . Similarly, the application program can send a command to stop particular force effects, to pause the effects, to get the status information of an effect, or to destroy an effect. Some of these commands are described in greater detail below. Thus, the application program believes it is the only one using the force feedback device when in actuality the context driver uses one particular set of multiple sets of force effects based on the active application. In effect, there is a virtual force feedback device dedicated to each running application program.","A context is therefore only allowed to exert forces with the force feedback device when that context is active, i.e., is associated with an active application program or the background application. In the described embodiment, only one foreground context can be active at any given time. Any number of background contexts may be simultaneously active; however, there may be a device limit on the number of background contexts that may be created. For example, the device  may only allow one background context to be created at any one time, which is the preferred embodiment. Thus, if an inactive (not in focus) foreground application program commands a force to be output, the API will ignore the command after determining that the commanding application is not active (or, the command will only be sent to the device when that application becomes active).","If the active application program becomes inactive (or is removed from the host's memory) and a different application becomes active, then the API indicates this to the context driver , which then deactivates the context associated with that application program and loads the effects from the new active context to the force feedback device . Likewise, when the original application program again becomes active, the API tells the context driver to activate the associated context and load the appropriate effects to the force feedback device.","Device manipulation data  is also received by context driver . Data  is used to set a global device state on the force feedback device, as described below, and this information is passed unmodified to the translation layer.","Some embodiments may not allow multiple simultaneous application programs to each command forces; there is only one active application that uses the device . For example, in such an implementation, a force feedback game might be running on the host, and no other application programs can be allowed to command forces to the device . Such an implementation does not require the context driver  to operate; commands from the API can be passed directly to the translation layer , described below. The translation layer would access a single context list  in such a case, i.e., there would be no need to provide multiple contexts .","Translation layer  manages the sending of effects to the device , receives information from the device to the host (in some embodiments), and maintains a representation or model of the memory of device . Translation layer  receives an individual effect  for the active (or background) application program and device manipulation data  sent by the context driver  (or from the API  if no context driver  is used). The translation layer provides the effect from a context list  of individual effects  (list  represents a context ). A different context list  is provided in each context  of list . Each effect  in list  defines a force or series of forces that is to be output on the user object  by the force feedback device . When the effects are to be loaded on the device  (\u201ccreated\u201d) by the application, they are selected and copies are output to the device by the translation layer. Preferably, each effect is output by the translation layer as soon as it is received by the layer . Each effect stored in list  as examined by the translation layer is available on force feedback device , i.e., the local microprocessor  should recognize the effect and be able to output the effect immediately or when conditions dictate.","In a multiple-application system, when an active application becomes inactive, the translation layer is instructed by the context driver  to \u201cunload\u201d the effects of the context of the previous active application from the force feedback device (e.g., designate the memory space for those effects as free), receives the effects from the now active application and loads those effects to the force feedback device  (the effects for the background (primary) application are preferably never unloaded).","The translation layer also preferably handles events. For example, when a screen position is received from the device , the translation layer can check whether any of the conditions\/triggers of the active events are met. If so, a message is sent which eventually reaches the associated active or background application program. In alternate embodiments, the microprocessor  on device  can check for events and send event notifications through translation layer  up to the application program.","The translation layer also can store a device state  in memory. Device manipulation data  from the active application and the background application determines the device state. This is the state that the active application program wishes to impose on the device, if any. For example, an overall condition can be stored, such as an enable or disable for all forces, so that if all forces are disabled, no forces will be output by the device. An overall gain can also be set to limit all output force magnitudes to a desired level or percentage of maximum output.","The translation layer outputs device messages  (commands) to the device  by way of the next layer. Messages may include force effects to be output and\/or any other information such as device identification numbers or instructions from the context driver for an effect (start, stop, pause, reset, etc.) The translation layer outputs messages  to the device driver .","Device communication driver  communicates directly with the force feedback device. Driver  receives the device messages  from translation layer  and directly transmits the messages to the force feedback device over bus , e.g. a USB, in a form the device  can understand. The driver  is implemented, in the preferred embodiment, as a standard device driver to communicate over such a serial port of host computer . Other types of drivers and communication interfaces can be used in other embodiments.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 3","FIG. 7"],"b":["134","11","18","11","220","134"]},"Example data structure  may include several fields, such as duration  indicating the amount of time the force effect is to be played, direction  indicating the direction in one or more degrees of freedom the force is applied, an envelope pointer  pointing to an envelope data structure , and a type pointer  pointing to a type data structure. The duration  and direction  fields can simply store one or more values associated with those characteristics. The envelope data structure  can either be null if the force effect does not use an envelope (e.g. a condition force), or the data structure  can hold several values that define an \u201cenvelope\u201d for a periodic wave, such as impulse time , impulse level , fade time , and fade level . Shaping of waves using such parameters is described in greater detail in co-pending patent application Ser. No. 08\/747,841, incorporated by reference herein. Type pointer  can point to one of multiple possible different data structures, depending on the type of force effect. For example, if it is a constant force effect, data structure  is pointed to, having a magnitude parameter  (which can be signed). If it is a periodic effect, data structure  is referenced, having values of magnitude , offset , phase , and period  that define the periodic effect. If it is a condition effect, such as a spring or damper, then data structure  is referenced, having offset , deadband , constant  (e.g., spring constant or damping constant), and saturation  values.","As exemplified by , different force effects have different storage requirements. Some force effects may not need to store envelope data from structure , while some periodic and constant effects may require additional space to store the envelope information. Condition force effects require a different amount of memory space for data in structure  than do constant force effects for data in structure . Since a model of the device memory is maintained on the host computer, the host knows how much memory is available on the device, i.e., when a particular effect can be stored by the device and when an effect cannot be stored.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 4","FIG. 4","FIG. 2"],"b":["134","11","300","300","11","300","302","302","304","134","304","220"]},"As explained above, the translation layer on the host computer preferably maintains a model of the device memory  to determine where to store parameters and to determine when the memory is full. Initially, such as at power up of the device , the host preferably asks the device for any relevant information to model the memory, such as the size of the available effect and parameters blocks, as well as the number of effects that can be stored in effect block  (which can vary depending on the device ). Some devices  may be able to inform the host how much space must be allocated for each effect slot , parameters for an effect, and\/or how to specify the usage of parameter pointers.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 5","b":["310","310"]},"The process  begins at . In step , the host  creates a memory model using information from the device . For example, a context  can be created as explained above with reference to . The model used in  can be used; this model is referred to in the following discussion. As explained above, the device can send the host  information such as the size of memory and number of effects that can be stored.","In step , the process determines whether the application program (e.g. by a function call to the API or library) is commanding to create or destroy any force effects on the device . Creation of effects typically occurs when the application program is first executed on the host computer, but also may occur at other times during application execution. For example, when a game program is first executed, the program has a set of force effects which are intended to be used by and with the game. The game typically creates the force effects on the device  at startup of the game so the effects will be available immediately for output. Different effects can also be later created during the game if needed. If a GUI is executed on the host, the GUI can immediately create background (primary) force effects on the device  so that such effects are immediately available.","If the application has not commanded to create or destroy any effects on the device in step , the process continues to step , explained below. If the application wishes to create an effect on the device, then in step  the host determines if there is any device memory available to store the effect. The host driver (e.g. translation layer or, alternatively, the API) checks the host model of device memory to determine if there is sufficient space. Preferably, the host driver checks for sufficient space both in the effect block  and in the parameter block ; there should be sufficient space in both blocks. If there is not, in step  the force effect is discarded, never to be used; preferably, the application program is informed that the effect could not be created, i.e. that the create command failed (in an alternate embodiment of the present invention described below, the effect can be cached by the host). The process then continues to step , described below. If there is sufficient memory for the created effect in step , then in step  the host stores the effect in its memory model and also sends one or more create commands are sent to the device to load the effect in the actual device memory. It should be noted that, in embodiments providing multiple concurrently-running application programs, the device  can includes a number of effects standardized in its memory which it can implement if the effects are within the active or background context. Such effects do not need to be downloaded from the host and stored in an effect slot.","As an example, a set of commands and appropriate parameters are shown below to create a periodic effect on the device:","SET_ENVELOPE (offset1, values)","SET_PERIODIC (offset2, values)","SET_EFFECT (effect_index, values, flags, offset1, offset2)","The SET_ENVELOPE command provides a \u201cmsg_id\u201d value indicating its command type (identifier). The offset value \u201coffset 1\u201d indicates the offset into the parameter block  at which to store the accompanying values. The values can be, in this example, the envelope parameters in the data structure  shown in , such as impulse time, impulse level, fade time, and fade level. Alternatively, for other types of force effects (e.g. conditions), the envelope parameters can be null, or the envelope command need not even be sent. The SET_PERIODIC command similarly provides an identifier and a second offset value \u201coffset2\u201d (different from offset1) at which to store the values in the periodic command. The host  knows how much memory space is taken by each effect and parameters and thus can determine the appropriate offsets at which to store the effect data in the device memory without writing over other values. For example, the host knows how much space the envelope parameters of the SET_ENVELOPE command take, and can calculate offset2 to be appropriately located in the parameter block. The values for a periodic command can be those shown in data structure  of , for example.","The SET_EFFECT command provides the data to be stored in the effect block  of the device memory. After an identifier value, the \u201ceffect_index\u201d value indicates which effect slot  in which the effect is to be stored. Since the host is modelling the device memory, the host knows which effect slots are available, e.g. open or no longer used. The values can be those shown in structure  of , for example. Offset1 and offset2 indicate where the envelope parameters and the periodic parameters, respectively, are stored in the parameter block (if these parameters are not used then the offset values can be null).","It should be noted that the host can store in its memory model either the actual data for the effect, or only the location and size of the portion of memory space that the effect occupies. This is because, at a basic level, the host is only keeping track of available device memory and does not need the actual effect data. However, in a preferred embodiment, the host does store the actual effect data in the memory model. In some embodiments, this allows the host driver to examine effect data and to perform some decisions about whether to send a command to the device. For example, the application may command that a new effect be created which is a periodic wave having a frequency of 20 Hz. The host driver might examine the data for currently-loaded effects in its memory model and find that there is already a periodic wave loaded on the device having a frequency of 25 Hz. The host driver could then decide that the new, 20 Hz periodic is redundant in view of the 25 Hz periodic, and thus ignore the create command (and use the 25 Hz effect whenever the 20 Hz effect is commanded to be played). This type of host driver ability can be performed only if actual effect data is stored in the host memory model. Furthermore, this type of \u201csmart\u201d effect management must be balanced in view of extra processing time and the intentions of the application developer. For example, if the application believes that multiple (redundant) effects are stored in the device and will provide an additive force output, the host driver will not want to simply modify an existing effect but should create a new effect. Also, the efficiency in effect storage gained may not in some cases be worth the extra processing time in managing the effects intelligently. After step , the process continues to step , described below.","If in step  the application has commanded to destroy an effect, then in step  an effect slot is freed up in the host memory model. In the preferred embodiment, the device  need not be instructed to destroy an effect in the device memory in most cases; rather, old effect data can be simply written over with new effect data in the device memory when the new data is ready to be loaded. The host, however, must free up memory space in its own memory model to allow other effects to be stored and thus the driver should be instructed to destroy an effect to clear the effect data in the memory model. After a destroy command has been received, the host driver knows that the slot of the destroyed effect is available to store a different force effect that may be created in the future by the application program.","In some cases, the device needs to be informed that an effect has been destroyed. For example, a trigger effect can be loaded into device memory and outputs a force if a particular trigger condition occurs, such as a button being pressed on the user manipulatable object. If a trigger effect is being stored in the device memory and is destroyed by the application, that trigger effect cannot be simply left in device memory until it is written over, since a trigger condition may occur before the trigger is overwritten; instead, the device must be immediately informed that the trigger effect should be destroyed or flagged appropriately. Likewise, if an effect is playing when it is destroyed, the device should be immediately informed so that it can turn off the effect. After step , the process continues to step , described below.","If no create or destroy command is received in step , the process checks in step  whether the application program on the host is commanding to change an effect state. Herein, an effect state is the current status of the effect, e.g. \u201cplaying,\u201d \u201cstopped,\u201d \u201cpaused,\u201d etc. If no effect state is being commanded, the process continues to step , described below. In a preferred embodiment, steps  and  are actually function calls made to and implemented by the API which can be made at any time, such that steps  and  need not be implemented in the sequence shown.","If in step  the effect state being commanded is to \u201cplay\u201d or \u201cstart\u201d (output) a particular force effect to the user, then in step  an appropriate \u201cplay\u201d command is sent from the host driver to the device. For example, the command can be SET_EFFECT_STATE (effect_index, state, loop_count). The effect_index value indicates the slot in the effect block in device memory and thus the particular force effect which is to be played. The state value indicates to \u201cplay\u201d the designated effect. The loop_count value can optionally be used to designate a number of times for the device to repeat playing the entire force effect. In step , the host (e.g. translation layer) \u201ctags\u201d the effect (i.e. sets a flag) in its memory model so that the host knows which effects are currently playing on the device (the device also tags the effect, as described in greater detail with respect to ). The process then returns to step .","If in step  an effect state is being commanded to stop playing a particular force effect, then in step  an appropriate command is sent from the host to the device. Such a command can be similar to the play command described above except that the state indicates to stop playing the designated effect. In step , the host \u201cuntags\u201d the designated effect in its model of device memory, i.e. removes the tag for the designated effect. The process then returns to step . In other embodiments, additional changes in effect states can also be commanded, such as to pause and resume a force effect, etc.","In step , the host can check whether any playing effect has expired or finished, e.g. whether an effect has played to its full duration. The device preferably keeps track of effect duration since it is actually implementing the output of the forces. To inform the host of the expiration of an effect, the device preferably sends a status report to the host, which is checked in step . In some embodiments, the host can also independently keep track of the duration of a force effect for memory management purposes, i.e. it can be useful for the host to independently determine when a force effect is finished playing to help determine which cached effects can be loaded. Furthermore, the host can resynchronize its tracked durations if the host and device durations are learned to be out of synchronization. If no effects have expired, the process returns to step . If at least one effect has expired, then the process continues to step  to untag the expired effect in the host memory model. The process then returns to step .","The host can also receive status reports from the device  at periodic intervals and\/or when the status of force effects and other conditions change, such as an effect starting to play or finishing playing, a deadman switch being activated, power supply interrupted, etc.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 6","b":["350","11","351","352","18","352","362"]},"If a host command has been received by the device and that command creates a force effect on the device, then in step  the process writes the effect data in the device memory in the effect slot designated by the command, i.e. the identifier and the parameters are stored in device memory . For example, the local microprocessor  can parse the msg_id value (identifier) of each command to determine the type of command. Once the device knows the type of command, it also knows how to store and process each of the succeeding parameters in the command. Thus, the device knows that the second value in the SET_EFFECT command indicates the effect slot in the effect block  at which to store the succeeding values. The device also knows to store values at the appropriate offsets provided in the periodic and envelope commands. The process then continues to step , described below.","If a command has been received to change the state of an effect already created on the device, then in step  the process parses the command to check whether the command is a \u201cplay\u201d command. If so, then in step  the device \u201ctags\u201d the effect designated in the command. The tag is an indication (such as a flag) that the effect is to be played, to be later examined by the process as detailed below. The process then continues to step .","If the command received in step  is not a \u201cplay\u201d command, then it is a \u201cstop\u201d command to cause the designated force effect to stop playing. Additional commands can also be implemented in other embodiments, such as \u201cpause\u201d, which can stop the playing of a force effect in its current state; after a \u201cresume\u201d or \u201cunpause\u201d command is received, the effect would continue playing from the point at which it was paused rather than restarting; or a \u201cstop_all\u201d command which stops the playing of all effects; or a \u201cmodify\u201d command, which modifies only the parameters of a previously-loaded effect. In step , the process \u201cuntags\u201d the effect designated in the command, i.e. indicates the designated effect should not be played The process then continues to step .","In step , the process checks whether the time interval has lapsed, i.e. whether a time event has occurred. In the described embodiment of the present invention, the device operates according to a time interval as measured by a clock. At each time interval, the device  should output a force for that interval as contributed to by any playing force effects. For example, the time interval can be 1 millisecond, where the device is expected to process any required information and output a force on the user object  every millisecond. When the millisecond time interval passes, it is considered an event which causes the microprocessor to output a force. Thus, if no time interval has elapsed in step , the process returns to step , e.g. the microprocessor continues to wait for an event such as a command or time interval. Before the next event occurs, the device can perform other tasks such as suspending operation until the next event, processing input sensor values, calculating the next forces, building and sending messages to the host computer, and\/or updating force output from the actuators.","If a time interval has elapsed, then a force should be output, and the process continues to step  to start the implementation of force output. In step , a variable N is set to 1. N indicates the index or slot of an effect in the effect block of device memory. In step , the process examines the effect(N), i.e. the effect stored at slot(N). If the examined effect is determined in step  to be untagged, then in step  N is incremented. In step  the process checks whether N>M, where M is the number of effects that the device  can store. If N>M, then all the effects have been checked, and the process continues to step , explained below. If N is not greater than M, then the process examines the next effect in the device memory in step . For an alternate method of examining effects in memory, see the \u201cplaylist\u201d embodiment of .","If the effect(N) is determined in step  to be tagged, then in step  a force is calculated by the device microprocessor  based on the data for effect(N), e.g. the parameters such as magnitude, direction, and the like. The microprocessor  can use locally-stored force processes, force algorithms, stored force magnitudes, functions of space and\/or time, a history of stored motion values of the user object, and\/or other instructions to calculate the force as explained above with reference to . For example, the microprocessor can calculate the raw contribution to the output force from the effect and apply an envelope scaling (detailed in copending application Ser. No. 08\/747,841, incorporated by reference herein). In step , the calculated force is added to a sum of forces calculated for the other playing effects. In determining the total sum, the device preferably combines all constant forces (e.g., conditions and time-based forces) and limits the constant force sum to a predetermined magnitude, then combines all dynamic forces and limits the dynamic force sum to a predetermined magnitude. Dynamic forces are detailed in application Ser. No. 08\/846,011, incorporated herein by reference. The two sums are then added together and the total force sum is output by the actuators of the device . Alternatively, all forces can be treated the same and summed together. Furthermore, steps  and  can be processed together or intermixed when determining the effect force and the total force.","In step , any working values in parameter block  are updated. For example, such values can include a time value that indicates the amount of time that has expired for the current force effect. If the microprocessor  has determined that the time value for the effect has reached the duration limit for the effect, the microprocessor  preferably untags the effect so that it will no longer be played. Parameters for the effect can also be updated if a command has required such. After step , the process continues to step , where N is incremented, and then to step , where N is compared to M as described above to determine whether all the effects in the device memory have been checked. If N>M, step  is implemented, where the total force is output by the device to the user. The total force is the sum of each force contributed by each playing force effect. The process outputs force signals to one or more actuators to apply a force in the appropriate direction with the appropriate magnitude. The process then returns to step  to wait for the next command event or in step , the next time interval. The device also preferably sends status reports to the host concerning the status of effects, and these status reports can be sent periodically and\/or when the status of an effect changes. Of course, other data and conditions of the device are also reported to the host (sensor data, button data, whether power is being received, deadman switch state, etc.) which are not detailed in process .","The processes described with reference to  are very efficient. Since the host knows the layout of memory and what is currently stored there, the host need only send one command to load new effects; the host already knows when effects can or cannot be created. In previous embodiments, the host would have to query the device and wait for an answer from the device as whether an effect could be created, thus slowing down communication and response of the device and creating potential confusion when multiple application programs are running and commanding forces.","One aspect of the present invention concerns the time interval event and its implementation as described above for step . One way to implement the time interval is to choose a long enough period of time that allows the microprocessor to perform any potential required calculation and still output a force at each time interval. A different implementation of the present invention can provide a smaller time interval which usually is sufficiently long to allow a force to be output at each interval, but which may be insufficient in length in particular circumstances. If the time interval is too short in a particular circumstance, the microprocessor  preferably then waits the next discrete time interval to output the force instead of outputting force as soon as it has been determined. This allows a consistent period of force output to be maintained. Preferably, the force output at the second interval point is appropriate to that interval and is not necessarily the force which should have been output at the skipped interval point. For example, if the time interval is specified as 1 ms, the device is usually able to make calculations and output a force every millisecond. However, in some cases such as when a complex command is received, when calculations for several and\/or complex force effects are made, or other condition requiring more processing occurs, the extra processing might cause a delay in the output of the force past the 1 ms interval point. Instead of outputting the force when the calculation is complete, the process delays the output of the force until the next discrete interval point, i.e. after an integer number of time intervals have passed. Furthermore, the process also computes the force which should be output at the second interval rather than the first. For example, if the force is based on a periodic function, then the force that should be output at the second interval can be determined using the periodic function. This maintains the fidelity of the force sensation to the user and is important for time-based effects. This method allows a faster update interval with only occasional delays in force output, thus providing better overall force output quality than if a longer time interval is used.","One limitation of force feedback devices is the relatively small amount of memory included on the devices. To create a realistic, immersive environment, many different force effects should be output by an application program. However, only a small number of effects can usually be stored on a force feedback device, often less than the application program wishes to use. In current implementations, if an application program commands the creation of more force effects than can be stored by the device, the effects that cannot be stored are simply discarded and not output, and the application program is informed of the failure (the application program can react to the failure in any way the developer desires). One way around the limitation is to provide a \u201csmart\u201d application program that only outputs a small number of force effects at once which can all be stored on the device; when the application wishes to create and output a new, different force effect, it destroys a previously-used effect and commands a new force effect. However, ideally the application program should be able to output as many force effects as it wishes without having to consider the memory limitations of the force feedback device and without having to spend extra processing time swapping force effects.","Effect caching by the host is a way to use to the host's memory in addition to limited device memory to store as many force effects as an application program needs to use. Host memory is used as an overflow cache for the device to store any effects not able to be stored on the device. In the view of the application program, all commanded effects have been stored on the device, so that the application program need never receive a failure message for running out of device memory. A driver program on the host (such as the translation layer, API or other library, or a lower-level driver) handles all the effect caching at a lower level than the application program.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 7","b":"400"},{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 7","FIG. 5","FIG. 5","FIGS. 9"],"b":["400","18","400","310","400","402","404","18","312","406","11","418","408","412","9","438","408","410","438"],"i":["a ","b"]},"If in step  the application has commanded to destroy an effect, then in step  an effect slot is freed up on the host, creating an open slot in the device memory model. In next optional step , the host can send a create command to the device to load a cached effect into the empty slot in device memory. Since there is an empty slot in device memory, and since the host cache may include effects that the application program assumes are loaded on the device, it can be efficient to have all the slots in the device memory filled. The host can load a cached effect based on the order in which it was cached, e.g. the effect that was cached first has the highest priority to be loaded. Alternatively, the host can prioritize the cached effects in some way and load the effect having the highest priority. For example, trigger effects may be considered higher priority than other effects. Effects can also be assigned priority based on several factors including the effect's magnitude, type, duration, or age, and\/or a weighted combination of several of these factors. In other embodiments, step  is not implemented and the host can load cached effect data to the device at the time the effect is commanded to be played, as in step  below. The process then continues to step , described below.","If no create or destroy command is made in step , the process checks in step  whether the application program on the host is commanding an effect state. If in step  a \u201cstop\u201d command has been made, then in step  the host sends a stop command to the device similarly to step  of . In step  the host untags the effect in the host memory model similarly to step  of . Next step  is similar to step , described above, where the host can send a create command to the device to load a cached effect into the memory space occupied by the effect that was commanded to stop. As explained above, the host can determine which of the cached effects has the highest priority to be loaded. However, step  has the additional step of checking whether any cached effect, such as the highest-priority cached effect, has a greater priority than the stopped effect. In some cases, the stopped effect may have a higher priority than any cached effects and thus should remain in device memory, e.g. in an implementation placing high priority on trigger effects, the stopped effect may be a trigger and the cached effects may be periodics with lesser priority. Priority of effects is described below with respect to step . The process then continues to step , described below.","If in step  a \u201cplay\u201d command was made, then in step  the process checks whether the commanded effect is already loaded on the device. The host can maintain a list indicating which of the effects have been loaded to the device and which have been cached on the host, as shown in and . If the commanded effect has previously been loaded on the device, then the play command is sent to the device in step  similarly to step  of , and the effect is tagged in step  in the host memory model similarly to step  of  (the device also tags the effect, as described in greater detail with respect to ). The process then continues to step .","If the commanded effect(s) has not been loaded on the device, i.e., has been cached on the host, then in step  the process checks whether there is an open slot in the device memory in which to store the cached effect. An open slot does not have any effect data stored therein. If there is an open slot, then the process continues to step ","If it is determined that the commanded effect (or a waiting effect; in step  any waiting effect that is to loaded can be considered a \u201ccommanded effect\u201d) can be loaded on the device, then in step  the host sends a create command to the device to create the commanded effect in the available effect slot of the device memory in step , e.g. the effect is stored in the effect block and parameter block (if such a memory structure is being used), as explained with reference to step  of . The process then continues to step  to send the \u201cplay\u201d command for the created effect as explained above. After the effect is tagged in step  on the device and the host, the process continues to step , described below.","If there is no open slot on the device in step , then in step  the process checks whether any of the loaded effects can be \u201cswapped\u201d with the commanded effect, e.g. whether the loaded effect can be unloaded (written over) in its device memory slot and the commanded effect stored in its place.","The process can use many different criteria to determine if any slots are available in the device memory. In one embodiment, the process checks whether all the loaded effects are currently playing; the slots of all of the loaded effects that are not currently playing might be considered available slots. The host can simply write the commanded effect in the first available slot of memory.","In some embodiments, time-based (temporal) criteria can be used. For example, a long period of time may have passed since a loaded effect was last played, such that this effect can be considered to be expendable and the slot it occupies can be available for the newly-commanded effect. Such an expendable effect may perhaps no longer be in immediate use by the application program and thus is most eligible to be unloaded. The loaded effect having the longest time since last played can be considered the most eligible to be unloaded.","In other embodiments, instead of or in addition to using such time-based criteria, spatially-based criteria can be used to determine slot availability. This method predicts movement of the user object  by the user to help determine which effects should be loaded on the device.  illustrates one use of spatial caching. In a GUI  displayed on screen , the user of device  can move a cursor  to different areas of the GUI. Many force effects are output based on the cursor's location in the GUI. For example, an attractive gravity field can be output to bias the cursor\/user object to an icon  when the cursor is moved within an external range  around the icon. Or, a snap force can be output when the cursor moves over a window border  of window .","Using spatial criteria, those force effects that are associated with graphical objects in the current path of movement of the cursor can be considered more essential since they are more likely to have to be output in the immediate future when the cursor moves to the associated graphical objects. Those effects associated with graphical objects away from the current path of the cursor are more expendable since they are less likely to require immediate output. Thus, the host can determine the current direction (and velocity, if desired) of the cursor  to determine which graphical objects and effects are in the current path of movement of the cursor and which graphical objects and effects are far away from the current path of movement. The effect associated with the graphical object furthest away from the cursor path can be considered the most expendable effect and can be unloaded and replaced by an effect closer to the cursor path of movement.","For example, in , it has been determined by the host, e.g. by examining a history of two or more cursor positions, that the cursor  is currently moving in the direction . The cursor is likely to continue moving in the direction  (the velocity of the cursor can optionally influence this determination; if the cursor is moving fast, it is much more likely to continue in the same direction  than if it is moving slower or is currently stopped). Therefore, the icons  and  and the window  are away from the likely path of the cursor and any force effects associated with these objects may not be required to be output in the immediate future. However, the cursor may be heading directly to icon ; since the attractive field associated with the icon range  may have to be output very soon, the attractive field effect has a much higher spatial priority than the effects associated with objects , , . Window  is not in a direct a path of the cursor as is icon , but since it is near the path , the effects associated with window  should have a higher spatial priority than the effects of objects , , and  and should be loaded in place of one of the lower-priority effects.","In a more general sense, the host can monitor the motion of the user object  and swap multiple effects on the device with cached effects that are more likely to be output in the immediate future. Spatially-based criteria also can be used in conjunction with time-based criteria for determining memory slot availability.","Referring back to , a priority system can also be used to determine which effect is most eligible to be unloaded or swapped out and replaced with a cached effect. For example, each type of force effect can be assigned a priority in an absolute priority system, where each effect can be given a rank in a priority list according to the type of effect. For example, a damping effect may be considered lower priority than a vibration periodic effect that may be more noticeable to the user. A \u201ctrigger\u201d effect preferably has a higher priority than non-trigger effects. A trigger effect is an effect that is not always playing, but which must be immediately output if a predefined event or condition occurs. For example, a gun recoil trigger effect can be played each time a button on the device  is pushed by the user. Since trigger effects need to be played quickly, they should remain loaded in device memory as much as possible. Furthermore, an effect that is currently playing can have a higher priority than non-playing effects (including trigger effects not currently being played), since it can be disruptive to a user to suddenly stop playing an effect before it has finished. However, this may not be the case when using spatial caching since an effect currently playing can be immediately turned off if the user moves the user object  to a different location.","The priority of the commanded effect is compared to the priorities of the loaded effects; the first effect having a lower priority is eligible to be swapped with the commanded effect. Alternatively, all the loaded effects can be examined, and the effect having the lowest priority can be eligible to be replaced with the commanded effect if the commanded effect has a higher priority than that effect. In some embodiments, only effects not currently playing are examined for availability; alternatively, all the loaded effects, whether currently playing or not, can be examined and the lowest priority effect unloaded.","Furthermore, in some embodiments the priorities of effects for caching purposes can be changed by an operating system, application, or other program or user. For example, a developer of a force feedback application program can in some embodiments assign priorities to particular effects so that the developer has the flexibility to designate the importance of various effects to his or her particular application program. A priority system for a particular application could be provided to the host driver upon start-up of the application program. Such a priority system could be stored in a context for that application program, as described for , for example. In such a system, the developer should be able to assign the highest possible priority to any effect desired, which will cause a commanded effect having such a priority to be always loaded on the device regardless of which effects are already loaded. This allows the application to directly command force feedback on the device with no concerns about receiving failure messages.","In addition, effects can be organized into various categories or \u201csuites\u201d, where the effects in a category are assigned priorities and\/or where only particular categories need be in use at a particular time. This allows effects from other \u201cinactive\u201d categories to be unloaded from the device and effects included in the \u201cactive\u201d category to be loaded. The priorities in some cases can be assigned by the developer of an application program. For example, a developer of a game application can make a category \u201cOn Land\u201d which includes a collision effect and a weapon fire effect as priority , an engine rumble effect as priority , and a \u201cslight breeze\u201d effect as priority . The developer also can make a category of \u201cIn Water\u201d including a water resistance (damping) effect and explosion effect as priority , a \u201cstrong current\u201d effect as priority , and \u201chitting sea kelp\u201d as priority . The application program calls the API to inform the host driver which category is currently in use, and when to switch categories. When, in the game, the user controls a vehicle to move from land into water, the application program indicates that the \u201cOn Land\u201d category of effects should be switched to the \u201chi Water\u201d category of effects. The host driver then knows that all \u201cOn Land\u201d effects are free to be unloaded from the device memory and that the \u201cIn Water\u201d effects should be loaded. Furthermore, since each effect has been assigned a priority, the host driver knows that if there is not enough slots to store all of the \u201cOn Water\u201d effects, the water resistance and explosion effects should be loaded before the lower priority effects. Other uses of categories and priorities is described in co-pending patent application Ser. No. 09\/306,002 entitled \u201cCommand of Force Sensations in a Force Feedback System using Force Effect Suites,\u201d filed concurrently herewith, and incorporated herein by reference.","The priority system described above can also be combined with other criteria, such as time-based and\/or spatially-based criteria described above. For example, a priority can be assigned to a loaded effect based on multiple factors such as its effect type, its application-assigned priority, its time-based criteria, and\/or its spatially-based criteria. For example, some force effects may be \u201cone-shot\u201d effects which are played once and then not used. These effects could have an initially high priority; once they are played, their priority can go to zero. In some embodiments, a total weighted priority can be assigned to the effect based on these factors and any weights assigned to the factors. The weighted priority of the loaded effect can then be compared to the (weighted) priority of the commanded effect to determine if the loaded effect can be swapped with the commanded effect.","Furthermore, other criteria may also determine whether the commanded effect can be loaded. When implementing more sophisticated comparisons, weights, etc. the tradeoffs between available host processing power and gains in caching efficiency should be considered.","A further consideration is whether the commanded effect can actually fit into the memory space occupied by a particular loaded effect. All effects occupy the same amount of space in the effect block , but different effects occupy different amounts of space in the parameter block  based on how many parameters are used and workspace required for an effect. If the commanded effect will not fit into the space occupied by the loaded effect with the lowest priority, then that loaded effect should be excluded from comparison and other loaded effects are examined for eligibility. Alternatively, if the examined loaded effect does not occupy sufficient space for the commanded effect, the loaded effect can still be unloaded or destroyed. The process then examines another low-priority loaded effect and unloads that effect as well; this process may continue until sufficient space is freed for the commanded effect.","If it is determined that the commanded effect can be loaded over a loaded effect in step , then in step  a create command(s) is sent to the device to load the data for the commanded effect in the space of the expendable effect. It should be noted that the expendable effect is still available to be commanded by the application since it still resides in the host cache and memory model. The process then continues to step  to send a play command to the device and play the commanded effect as described above.","If it is determined that the commanded effect cannot be loaded in step , then in step  the command is given a failure status, and the commanded effect is not loaded to the device. Of course, only the \u201cplay\u201d command itself has failed; the effect data still resides in the host cache and memory model. In some embodiments, the application program can remain ignorant of the failure; this allows the application program to believe that the force effect is playing properly and to issue another play command for that effect at a later time without disruption or additional processing (and the later command may succeed); in addition, this prevents the application from overreacting to the failure. In other embodiments, it may be desirable to inform the application program of any failure to play an effect so that the application program can compensate for the failure in other ways. The application program can be provided with varying degrees of information; for example, that the effect has been cached but did not play, or that the effect simply did not play. The process continues to step , described below.","In an alternate embodiment, the process can mark a failed cached commanded effect as \u201cwaiting.\u201d Effects which have a status of \u201cwaiting\u201d can be given a high priority to be loaded if any of the effect slots on the device should open up in future iterations. The host can maintain the effect's duration while it has a waiting status so that if an effect slot opens up, the host will know whether the waiting effect should still be output and if so, at which point in its duration. Thus, only effects which have a relatively long duration need be given a waiting status. For example, if a periodic effect having a duration of 4 seconds is waiting to be loaded on the device, the host keeps track of the duration; if 2 seconds have elapsed before an effect slot is available, the host commands the periodic effect starting at the third second. If four seconds have elapsed before an effect slot becomes available, then the host should cancel the effect since its duration has expired. In such a waiting embodiment, the process can check whether any waiting effects can be loaded to the device after an effect is untagged in step  or destroyed in step ; if so, the create command of step  or step  can be sent for the waiting effect (if the waiting effect has a high enough priority), and a play command can be sent, if appropriate, to play the formerly-waiting effect. Also, in steps  and , a waiting effect can be assigned a priority or its existing priority can be increased due to the waiting status, and the waiting effect may be loaded before a currently-commanded effect if its priority is higher. It should be noted that in many implementations, such a waiting status is unnecessary, since many force effects are too short in duration to justify the extra processing required. In addition, devices having several effect slots can usually maintain realistic forces even if some force effects are discarded.","In step , the host can check whether any playing effect has expired, similarly to step  of . If no effects have expired, the process returns to step . If at least one effect has expired, then the process continues to step  to untag the expired effect in the host memory model. In other embodiments, steps  and  can be omitted. The process then returns to step .","Force effect caching on the host can also be useful in other memory management paradigms in addition to the implementation described above where the host maintains a device memory model. For example, if only the device knows whether a commanded force effect can be stored in device memory, the device is queried by the host. If the device says that it cannot store any more effects, a driver on the host can create and cache the effect and inform the application program that its effect has been created, rather than indicating that the create command has failed.","It is important to note that the process described above preferably is implemented at a level on the host computer lower than the application program controlling the forces. The application program thus is unaware of all the effect processing that may be going on. This relieves the application program from having to determine which effects should be destroyed and which should be created at different times, and allows the developer of the application to focus on other important aspects of application and force design.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":["FIGS. 9","FIG. 7","FIG. 9"],"i":["a ","b ","a"],"b":["9","480","482","484","485"]},"As shown in column , the host driver keeps track of which force effects have actually been created (loaded) on the device. The host driver also keeps track in column  of which force effects are currently playing, i.e. output to the user. Thus, in the example shown, the host knows that the effects in slots , , , , and  of the host are loaded in the available slots of the device. The slots of the host and the device need not correspond since the host loads and unloads different effects from the device during application execution; however, the host driver does need to know which slots of the device the effects are stored so that the proper index into the effect block may be sent to the device. The host also knows that the effects in slots  and  of the host are currently playing on the device. If a cached effect is commanded to be played by the application, such as the Spring effect in slot  of the host, then the host can examine the loaded effect slots  to determine which slot the Spring effect can be loaded to. For example, the Periodic, TriggerForce, and Periodic effects on the device are not currently playing; since Trigger effects have a high priority, the Periodic or Periodic effect could likely be unloaded and the Spring effect loaded in the available slot, depending on the conditions of availability and priorities used. In addition, in some embodiments the host can also maintain a \u201cpriority\u201d field for each effect in the model  to allow the comparison of priorities for loading purposes.",{"@attributes":{"id":"p-0140","num":"0139"},"figref":["FIG. 9","FIG. 7"],"i":"b ","b":["490","436","492","1","3","4","5","6","1","2","1"]},{"@attributes":{"id":"p-0141","num":"0140"},"figref":["FIG. 10","FIG. 6","FIG. 10","FIG. 5"],"b":["11","11","12","500","502","310","328","500","504","500","502"]},"When an effect finishes or is stopped by a command, the effect is removed from the playlist. If there are other effects still playing which are located further down in the list past the removed effect, then one or more of these later effects can be moved to maintain a continuous playlist without gaps. For example, the last effect in the playlist can be moved to the location at which the removed effect used to be stored. In addition, after the effect is removed from the playlist, the total number of effects in location  is decremented.","The efficiency of the playlist  is demonstrated when the playing process  of  examines the device memory to determine which effects are to be output as forces. Instead of sequentially examining each slot in the effect block  as described in , the process instead simply examines the memory location  for the number of effects currently tagged (playing). Once this number T is known, the process then looks at the top T entries in the playlist  to determine which particular effects are playing, and calculates forces for those effects. This is much more efficient than examining the tag field for each entry in the effect block , especially when there are many effects in the effect block . Furthermore, if no effects or only a small number of effects are playing, no processing time is wasted checking each slot in the effects table.","While this invention has been described in terms of several preferred embodiments, it is contemplated that alterations, permutations and equivalents thereof will become apparent to those skilled in the art upon a reading of the specification and study of the drawings. Also, the various features of the embodiments herein can be combined in various ways to provide additional embodiments of the present invention. Furthermore, certain terminology has been used for the purposes of descriptive clarity, and not to limit the present invention. It is therefore intended that the following appended claims include all such alterations, permutations, and equivalents as fall within the true spirit and scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 9","i":["a ","b "],"b":"9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
