---
title: System and method for defining and using subclasses declaratively within markup
abstract: Described is a system, method, and data structure that enables an executable assembly associated with a subclass to be generated from a subclass definition within a markup document. In accordance with the invention, the subclass definition is written based on a schema. The schema may be XML-based. The schema includes a subclass tag for defining a name for the subclass. The name is associated with a type for an object that is instantiated when the executable assembly executes. The schema further includes one or more hints, such as for specifying a programming language to compile the subclass definition, for specifying a superclass from which the subclass derives, for specifying actions to perform when the object becomes instantiated, for creating an event definition and event handler for the subclass, and for specifying a property that becomes a member within the object when the object is instantiated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07120618&OS=07120618&RS=07120618
owner: Microsoft Corporation
number: 07120618
owner_city: Redmond
owner_country: US
publication_date: 20030228
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["Today, software development tools allow software developers the ability to build executable components using one or more programming languages, such as C, C++, C#, and the like. One advantage for building executable components is that the components, once built, may be re-used by other software programs. Another advantage for building executable components is that new components may be easily extended from existing components.","Generally, components are extended by subclassing, which means deriving a new class from an existing class. These classes and subclasses are written using one of the programming languages. The code that is written is commonly referred to as source code. For traditional runtime environments, the software development tools compile the source code into object code and then link multiple object codes together to create an executable. However, one of the problems with these traditional runtime environments is that each programming language and each version of the programming language require a different runtime environment.","To overcome this problem, a new type of runtime environment has been designed that effectively eliminates many of the cross-language interface and language version problems of the traditional runtime environments. In this new type of runtime environment, development tools compile the source code into an intermediate language. During runtime, the runtime environment compiles the intermediate language into native binary executable code. Thus, the new runtime environment performs the \u201clinking-type\u201d process during runtime. In order to perform this \u201clinking-type\u201d process, the runtime environment reads information (e.g., metadata) and accesses IL assemblies for the components associated with the program that is being run. The metadata includes descriptions for types, versions, resources, and the like. The IL assemblies may be a single dynamic link library (DLL), or numerous DLLs and resources.","For both the traditional and the new type of runtime environment, the source code is written using a programming language. Each programming language has its own unique syntax and set of application programming interfaces (API) specific to the runtime environment. In order for a software developer to write source code, the developer must learn the syntax of the programming language and the APIs associated with the runtime environment. Learning the syntax and APIs is very time consuming and challenging. In addition, if a developer wishes to program using multiple programming languages and\/or different runtime environments, the developer must remember the similarities and the subtle differences between each of the programming language's syntax and the APIs for the various runtime environments.","Given the advantages of using components, there is a need for a better mechanism for building, extending, and using components.","The present invention is directed at a system and method for defining, extending, and using subclasses declaratively within markup. The invention provides a mechanism for developers to build, extend, and use components using a markup language. These components include reusable components, application user interfaces, document user interfaces, and the like. The mechanism does not require a developer to know a programming language. Instead, the mechanism allows the developer to use a familiar markup language, such as XML (extensible markup language), to build components. Because XML is much easier to learn and is becoming more familiar within the general computer programming community, the present invention offers several advantages over using traditional programming languages. One advantages is that components may be defined within a markup document, along with other markup text, to create a very sophisticated electronic document. Another advantage is that developers do not need to know or understand any programming language in order to generate an executable component.","The system, method, and data structure of the present invention enable an executable assembly associated with a subclass to be generated from a subclass definition written within a markup document. In accordance with the invention, the subclass definition is written based on a schema. The schema may be XML-based. The schema includes a subclass tag for defining a name for the subclass. The name is associated with a type for an object that is instantiated when the executable assembly executes. The schema further includes one or more hints, such as for specifying a programming language to compile the subclass definition, for specifying a superclass from which the subclass derives, for specifying actions to perform when the object becomes instantiated, for creating an Event definition and associated EventHandler for the subclass, and for specifying a property that becomes a field within the object when the object is instantiated.","The present invention is directed at a system and method for defining, extending, and using subclasses declaratively within a markup document. The invention provides a mechanism for developers to build, extend, and use components using a markup language. The mechanism does not require a developer to know a programming language. Instead, the mechanism allows the developer to use a familiar markup language, such as the extensible markup language (XML), to create components.","Illustrative Computing Environment",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","102","104","100","104","104","105","106","107","106","108"]},"Computing device  may have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. These devices are well know in the art and need not be discussed at length here.","Computing device  may also contain communication connections  that allow the device  to communicate with other computing devices , such as over a network. Communication connections  is one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.","Illustrative Implementation",{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 2","FIG. 1","FIG. 1","FIGS. 4-6"],"b":["202","204","202","204","106","100","202","206","206","206","202","204"]},"In one embodiment, the functionality provided by parser  may be provided within markup compiler . In another embodiment, the functionality provided by parser  may be provided by deriving a parsing class from an existing parser class within the markup compiler . The derived parsing class may include function overrides for each of the subclass tokens (i.e., tags) defined in accordance with the present invention. Briefly, the function overrides, illustrated in  and described in detail later, may be part of a series of callback functions that signal a beginning and an ending for the definitions of the elements associated with the subclass.","Parser  is configured to parse subclass definitions within markup document . Briefly, the markup compiler  compiles content within the markup document . In one embodiment, the markup compiler  converts the content into a tokenized binary stream that is saved in a tokenized binary file . The tokenized binary file  may be one of several forms known to those skilled in the art. The tokenized binary file  represents a tree of components specified in the markup document . However, the markup compiler  may be unable to convert some of the content directly, this content may be sent to the parser . The subclass definitions defined within the markup document  in accordance with the present invention is an example of such content. Parser  identifies properties, events, and the like within the subclass definitions and relays pertinent information about these items to the markup compiler .","Upon receiving the pertinent information, markup compiler  adds tokens to the markup document  that are associated with the subclass definition. The markup compiler  may also generate representative source code  from which IL assemblies  are created. IL assemblies  include computer instructions for subclasses (e.g., components) defined within markup document . In the past, these IL assemblies were generated using a software development tool that compiled and linked source code written using a programmatic language. One skilled in the art will also appreciate that, in another embodiment, the markup compiler  may generate the IL assemblies  without generating the tokenized binary file .","IL assemblies  created by markup compiler  may be re-used by traditional programming development tools. In addition, the IL assemblies  may be re-used in other markup documents. The ability to re-use IL assemblies  within a markup document is illustrated in  and described in conjunction therein. Thus, the present invention allows component developers the ability to easily build and extend components using a markup language. Once new components have been built in accordance with the present invention, the new components appear as if built using a traditional programming language. Thus, developers using the mechanism and method of the present invention may build components without learning the syntax and nuances of one or more programming languages.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 3","FIG. 2","FIG. 1"],"b":["302","304","306","302","206","302","308","308","206","208","302","306","208","208","210","208","306","210","208","210","304","208","210","102","304","310","310","310","304","208","206","210"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIGS. 4\u20136","FIG. 10","FIGS. 4-6"],"b":["206","202","202","206","202","202","208","210"]},"In overview, the series of  incrementally describe various aspects for defining a subclass declaratively within markup in accordance with the present invention.  illustrates an exemplary syntax for defining a subclass and a subclass hierarchy.  illustrates an exemplary syntax for defining identifiers, code, and constructors for the subclass.  illustrates an exemplary syntax for defining properties and events for the subclass. Each of these figures will now be described in detail.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4","b":["400","402","402","400","404","406","408","410","404","406","400"]},"For example, hint  (hereinafter referred to as language hint ) indicates to the compiler to generate the IL assembly using the language (e.g., C#) assigned to the language hint . The language hint  may have any one of a various number of programming languages assigned, such as C, C++, and the like. Hint  (hereinafter referred to as def:Class hint ) indicates to the compiler to define the subclass using a name  (e.g., MyButton) assigned to the def:Class hint . The def:Class hint  may also include a subclass namespace  that identifies the namespace (e.g., \u201cMyControlLib\u201d) in which the new subclass should be associated. Thus, in , a developer has declaratively defined a new subclass named \u201cMyButton\u201d that extends the \u201cButton\u201d class located in the \u201cSystem.Controls\u201d namespace. The new subclass will be associated with the \u201cMyControlLib\u201d namespace.","In the markup  illustrated in , an element declaration tag  (e.g., \u201cImage\u201d) is defined. Because a specific namespace is not defined within the element declaration tag , the namespace attribute  also defines the location for the element (e.g., \u201cImage\u201d) associated with the element declaration tag . The element declaration tag  includes an element  and a source attribute . Source attribute  includes a property  (e.g., \u201cSource\u201d) and a value  (e.g. \u201cHappyFace.jpg\u201d). Because element declaration tag  is within the subclass definition for the subclass defined as \u201cMyButton\u201d, the elements associated with the element declaration tag  will be instantiated when the subclass is instantiated. In addition, the elements associated with the element declaration tag  are contained within a children collection of the new subclass. In other words, the subclass is the parent to the elements associated with element declaration tags . Thus, one skilled in the art will appreciate that the markup  allows developers to express hierarchy in a manner that allows the compiler to generate element trees that are rooted to the subclass being defined (e.g., \u201cMyButton\u201d).",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 5","FIG. 4","FIG. 5","FIG. 5"],"b":["500","400","420","520","526","520","521","523","520"]},"The event attribute  includes an event trigger  (e.g., \u201cDataLoaded\u201d) and an event value  (e.g., \u201cOnLoaded\u201d). The event trigger  specifies the event that is monitored and the event value  specifies the method that is executed when the event trigger  occurs. The event value  is associated with a method  (e.g., \u201cOnLoaded\u201d function). The method  may be written using a programming language. Method  may reference instances of a class and subclasses defined within markup . When method  is written using a programming language within a markup document, method  is associated with a code hint . The code hint  allows developers to add code snippets to the body of the subclass definition. In one embodiment, the code follows the code hint  and is a callable method or event handler. In markup , for example, OnLoaded function  serves as the event handler for the DataLoaded event that is raised by the Image control. Other code snippets may also be added to the body of the subclass definition, such as CustomInit function  shown in .","Markup  also includes a constructor hint . The constructor hint  allows the developer to write a supplemental constructor that supplements the default constructor that is created for a subclass. In one embodiment the supplemental constructor is the last behavior executed by the generated default constructor. The supplemental constructor may contain code that affects the behavior of the subclass at construction time. The developer may call the constructor of the superclass within the supplemental constructor. The supplemental constructor shown in  calls CustomInit function , which is a user-defined private method.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 6","FIGS. 4-5","FIG. 6"],"b":["600","400","500"]},"Markup  includes property hint  that allows properties to be defined on the subclass. The property acts as a member variable of the subclass. The property hint  may include one or more attributes, such as name attribute , type attribute , default values attribute , and flag attribute . The name attribute  specifies a name for the property. In one embodiment, names are case sensitive and the runtime engine places no restrictions on the characters that are used for the name. The name must be unique to the owner who registers the name. The type attribute  specifies a type for the value of the property. The type includes intrinsic, user-defined, struct, class, interface, enum, and the like. The default values attribute  specifies a value that is assigned when the property is instantiated. The flag attribute  specifies the type of methods that are created by the wrapper when the property is instantiated. The flags may have the ability to control characteristics of the property, such as ReadOnly, Inheritable to child elements, Private, and the like.","Markup  also includes event hint . The event hint  allows events to be defined on the subclass. The event hint  may include attributes, such as name attribute , route attribute , flags attribute , and the like. Name attribute  specifies the string that refers to this event. When an xml file uses the subclass, the xml file uses this string to attach the appropriate application developer defined code. Route attribute  specifies the method, which determines the elements in the tree to raise the event on. Flags attribute  specifies other characteristics associated with the event. For example, for markup , the markup compiler will generate code to enable an eventcalled DblClick and include information associated with the event, such as routing supported, flags, and the like. One skilled in the art will appreciate that the names and values associated with the attributes may be modified without departing from the scope of the present invention.","Markup  also includes an event handler declaration . Event handler declaration  may have associated event handler modifiers , such as public\/private, delegate, return type, and the like. In , event handler declaration  declares an event handler (i.e, method)(e.g., \u201cDblClickEventHandler\u201d) that is called when the associated event occurs.","Other tags may be defined within markup documents too. For example, a root tag (e.g., \u201cdef:Library\u201d) may be used to inform the compiler and\/or parser to define the subclass in a separate file, to define the subclass with other subclasses in one file, and the like. A namespace may be declared for a custom Element, for all classes defined within the root tag, and the like.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 7","b":["700","702","704","706","708","708","704","700","704","706","700","706","708","710","712","714","710","712","710"]},"Generalized Operation of the Illustrative Implementation",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 8","FIGS. 4-6","FIG. 10","FIG. 8","FIG. 10","FIG. 10"],"b":["800","800","600"]},"The process  begins at block , where a markup compiler is compiling a markup document and encounters markup having a subclass definition. The markup compiler may determine that it has encountered a subclass definition by any mechanism, such as not recognizing the markup as any other format, recognizing a subclass tag (e.g., def:Class), and the like. For example, in markup , the markup compiler may process several statements before encountering the subclass tag (e.g., def:Class hint ) that identifies the subclass definition. In other embodiments, the subclass tag may be encountered before other statements, such as when the subclass does not specify a base class (e.g., button). In general, the subclass tag may appear anywhere that an element tag can appear within markup. Once markup is identified as having a subclass definition, processing continues at block .","At block , the subclass tag is processed. As described with reference to , the subclass tag (also referred to as the def:Class hint ) is assigned a name , which may also include a subclass namespace . Based on this information, representative code, such as line  in , may be generated for the assembly. In addition, a class having the assigned name is generated, such as shown on line  in . Line  will be augmented with other generated code once additional statements (e.g., namespace and superclass) have been processed. As part of processing the subclass tag, the process identifies whether the subclass extends from any class (i.e., a superclass) and obtains information associated with the superclass. In , the subclass being created \u201cMyButton\u201d extends from \u201cButton\u201d as defined by the superclass tag . Thus, line  in  includes representative code that extends MyButton from Button as shown.","In addition, a default constructor for the subclass is generated. Again, upon processing additional statements, this default constructor may be augmented with additional representative code. Lines - and  in  correspond to the representative code that is generated. However, \u201cthis._Initialize_This( )\u201d is code that is added after processing another statement as will be described below. Once the subclass tag is processed, processing continues to block .","At block , the next statement in the markup is retrieved. The next statement may be the statement before or may be the statement after the subclass tag statement depending on the location of the subclass tag statement within the subclass definition. Once the next statement is retrieved, processing continues to decision block .","At decision block , a determination is made whether the statement defines a class. As mentioned above, the present invention allows hierarchy to be expressed declaratively. In one embodiment, a statement defining another class (i.e., element) that is a child to the subclass will occur after the subclass tag statement. For the moment, assuming that the current statement does not define a class, processing continues to block .","At block , the statement is processed. There are various types of statements that may occur within the subclass definition. These statements may occur in various orders. The processing involved for each type of statement will be described below in detail. However, in general, each statement that is processed will result in the generation of additional representative code for the subclass definition. Once one of the statements has been processed in block , processing continues to decision block .","At decision block , a determination is made whether any statements remain to be processed for the subclass definition. If there is another statement, processing loops back through blocks - and processes that statement. Once all the statements within the subclass definition have been processed, the process continues from decision block  to block .","At block , the representative code that has been generated during the above process is used to generate the IL assemblies for the subclass definition. The developer may have specified in one of the compiler hint statements (block ) the programmatic language to use when generating the representative code, may have specified which assembly file to store the subclass definition, and the like. Once the IL assembly or IL assemblies have been generated, processing is complete. As mentioned above, the above created assembly is now available to be executed using traditional programming languages, using markup statements in accordance with the present invention, and the like. The assembly appears as if written using a programmatic language.","Returning to decision block , if the statement begins a definition for a new class (i.e., element), processing continues at block . At block , the statements pertaining to this new class are processed using processing within block  for each statement until all the statements pertaining to the new class have been processed. For example, in , statements , ,  are processed for the new class \u201cImage\u201d. Image is then a child of the subclass \u201cMyButton\u201d. Processing continues at block  to continue processing statements associated with the subclass.","Now, returning to block , the processing for each individual type of statement (blocks -) that may occur within the subclass definition is described. At block , statements that are compiler hints are processed. In general, the statements that are compiler hints provide information to the markup compiler as to how the assembly should be generated. For example, in , language hint  is a compiler hint statement that informs the markup compiler the programming language to use when generating the representative code. In , the language hint  is assigned C#, thus, the representative code illustrated in  is C# source code.","At block , statements that define namespaces are processed. These namespaces are then included in the representative code, such as shown on lines  and  in .","At block , statements that define an identifier (id) for a class are processed. For any id attributes within the markup document, the markup compiler generates a field member for the associated class. The field member is generated having a type that is the same as the class for which the id attribute is defined. The name of the field member is the id value assigned to the id attribute. For example, in , when processing the statements pertaining to the Image class, an id attribute  is encountered. Thus, as shown on line  in , the markup compiler will generate representative code for the MyButton class that has a field member defined as:\n\n","During runtime, the field member is initialized to an instance of the corresponding type (e.g., Image) that is created in the InitComponent( ) method. As a result, any code in the MyButton class may access any other element instance in its hierarchy simply by the id value for the class. Initializing the field member is shown on line  in .","At block , statements that define a property for a class are processed. For any properties defined within the markup document, the markup compiler generates representative source code for the property and registers the property if needed. For example, in , markup  includes a property hint  that has various attributes -. The property hint  will inform the markup compiler that the statements following the property hint  are for a property. The attributes - are then read in as property statements. The markup compiler will generate representative code for the \u201cLabel\u201d property to register the property for the MyButton class as shown on lines - in . The markup compiler will also generate representative code to define the property as shown on lines - in . Lines - illustrate how the name attribute  becomes the name of the property in the representative code and the type attribute  becomes the type for the property in the representative code.","In one embodiment, the process generates code for the values of the property by calling the TypeConverter for the type of the property, which executes code at runtime using reflection and converting the string to an actual object instance of the property type. In another embodiment, process  calls the type converter for the property in order to get the actual object value and converts the value to an InstanceDescriptor object. The InstanceDescriptor object contains sufficient information so that the markup compiler can reflect on the object to generate representative code that creates a new instance of the value's type as specified in the attributes associated with the property hint. Lines - in  illustrate how the labelProperty will be set on an instance of MyButton during runtime with the assigned value of the Label property. The assigned value may be assigned declaratively in markup (as shown in ) or assigned programmatically using any programming language.","At block , statements that define an event for a class are processed. For event statements, the markup compiler generates representative code for the event. Events may be defined in markup using various mechanisms, such as an event attribute  shown in  and as an event hint  shown in . First, the mechanism using the event attribute is described. The event attribute includes the event trigger and the event value. The event trigger corresponds to the event and the event value corresponds to the method that gets executed when the event trigger occurs. Referring to , the event value  (\u201cOnLoaded\u201d) is added as an event handler on lines - of the representative code in  by defining \u201cthis.OnLoaded\u201d as the new System.Controls.DataLoadedEventHandler. The event trigger  (\u201cDataLoaded\u201d) is added as the event on line  of the representative code in  by defining the first parameter of AddHandler as System.Controls.Image.DataLoadedEvent. The other parameter for the AddHandler may use default values or may be specified in the markup document.","The mechanism using the event hint  is now described. The event hint  includes an event name attribute and other attributes. The name assigned to the event name attribute is registered as the event. For example, referring to , \u201cDblClick\u201d is the name assigned to the event name attribute. Thus, \u201cDblClick\u201d is the first parameter of the RegisterEvent method that is generated on lines - in . The type of the event handler declaration  for the method \u201cDblClickEventHdlr\u201d is also included as a parameter of the RegisterEvent method in . Again, the other parameters to the RegisterEvent method may use default values or may be specified in the markup document using other attributes. During runtime, in accordance with one embodiment, the event is hooked up using reflection to identify the type of DblClickEventHandler and to locate the method. In another embodiment, the event is hooked up in a manner such that reflection is unnecessary, as described in the commonly assigned co-pending application entitled \u201cSystem and Method for Creating a Runtime Connection Interface for Attributes and Element Tags Defined within a Page Subclass in a Markup Document\u201d, patent application Ser. No. 10\/377,196, filed on Feb. 28, 2003, which is hereby incorporated by reference.","At block , statements that define code are processed. Statements that define code follow a compiler hint statement (block ), such as code hint. These statements are written in a programming language and will appear as is in the representative code. For example,  illustrates method  and Customnit Function . Method  and CustomInit Function  appear on lines - and , respectively, in .","At block , statements that define a supplemental constructor are processed. Again, statements that define a supplemental constructor follow a compiler hint statement (block ), such as constructor hint. The markup compiler generates a supplemental constructor (\u201cthis._Initialize_This( )\u201d in ) and adds the statements within the supplemental constructor. For example, in , the statement after the constructor hint  calls \u201cCustomInit( )\u201d. Thus, in  on line , the markup compiler adds \u201cCustomInit( )\u201d to the supplemental constructor in the representative source code.","Those skilled in the art will appreciate that block  may be performed incrementally while processing blocks - without departing from the present invention. In addition, depending on the functional implementation of parser  and markup compiler , there may be callbacks between parser  and markup compiler  during process .",{"@attributes":{"id":"p-0062","num":"0062"},"figref":["FIG. 9","FIG. 7","FIG. 9","FIG. 7"],"b":["900","900","900","901","700","708","900","902"]},"At block , the tokenized binary file is loaded. The tokenized binary file may be loaded incrementally or in its entirety. The tokenized binary file may identify IL assemblies associated with the tokenized binary file that need to be loaded. With reference to , for example, the IL assemblies associated with the MyButton class are loaded. Processing continues at block .","At block , a token is retrieved from the tokenized binary file. As mentioned above, in the new runtime environment, the tokenized binary file that is generated is independent from the programming language that was used to generate the tokenized binary file. Thus, the runtime engine may process the tokenized binary file without regard to the programming language that was originally used to create the tokenized binary file. Processing continues at decision block .","At decision block , a determination is made whether the token that was retrieved is an event. If the token is not an event, processing continues at block .","At block , the token is processed. As mentioned above, the processing of the token does not depend on the manner in which the tokenized binary file is generated. In other words, token processing a token in an tokenized binary file that was created declaratively from within a markup document or using a programming language will proceed in the same manner. Therefore, because the processing of tokens within a tokenized binary file is known to those skilled in the art, the processing of the token need not be discussed at length here. Processing continues at decision block .","At decision block , a determination is made whether there are any more tokens in the tokenized binary file. If there are more tokens, processing loops back to block  and proceeds as described above. On the other hand, if there are no more tokens, processing is complete and continues to the end block.","Returning to decision block , if the token is an event, processing continues at block . At block , metadata associated with the tokenized binary file is loaded. The metadata includes descriptions for types, resources, methods, and the like. Processing continues at block .","At block , using the metadata and reflection, the process finds a target element type for the event. This involves accessing the metadata and going through each field to determine the type. Processing continues at block .","At block , the event is validated for the target element type. This insures that the event is a valid event. If the event is not a valid event for the target element type, an error results. Processing continues at block .","At block , reflection is used on the target element type to obtain the event method, which is then executed. Execution of the event method involves executing code within the associated IL assembly. Thus, referring to , once the MyButton becomes instantiated and the event is found, the event method (\u201cDblClickEvent\u201d) is attached. This attaches an event handler (e.g., DblClickEventHandler) to the event (e.g. DblClick). Processing continues at decision block  and proceeds as described above.","Thus, as described, the present invention provides a mechanism for defining subclasses declaratively within a markup document and for using subclasses from within a markup document. This allows developers to focus more on ways to use the components instead of worrying about how to implement the components in any one programming language.","The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 4-6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 10","FIG. 2","FIGS. 4-6"]}]},"DETDESC":[{},{}]}
