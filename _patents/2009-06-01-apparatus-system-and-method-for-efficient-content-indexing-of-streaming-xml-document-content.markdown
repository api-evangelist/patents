---
title: Apparatus, system, and method for efficient content indexing of streaming XML document content
abstract: An apparatus, system, and method are disclosed for efficient content indexing of streaming XML document content. A forest generator generates an XML pattern forest from a set of structured index path expressions, the XML pattern forest includes trees and twigs generated from structured index path expressions uniquely associated with a namespace indicator for an XML node. The XML node is identified in a stream of at least one XML document. A comparison module compares the XML node to nodes of trees and twigs of the XML pattern forest. A determination module determines a match between the XML node and an index node in one of a tree and a twig of the XML pattern forest. The index node has a path from an ancestor node to the index node that matches the axis steps of at least one of the structured index path expressions. A storage module stores an index entry for the XML node in response to the determined match, the index entry includes a XML document identifier, an XML node name, a namespace indicator for the XML node, and XML node content.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08255394&OS=08255394&RS=08255394
owner: International Business Machines Corporation
number: 08255394
owner_city: Armonk
owner_country: US
publication_date: 20090601
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","This invention relates to content indexing of content in streaming XML documents within a stream of one or more XML documents.","2. Description of the Related Art","In processing XML or other forms of hierarchical data including SGML, JSON, and the like different areas of optimization are developing. The first is dividing up of Extensible Markup Language (XML) data in an XML document for storage and later retrieval in a conventional relational hierarchical such as XML databases, and\/or hybrid database systems. In this area, optimization focuses on storing parts of the XML document to facilitate locating and retrieving the data of the XML document. The second area focuses on optimizing queries for XML data by re-writing the XML query and\/or adjusting query execution plans such that the data requested is located and retrieved as efficiently as possible. A third area seeks to optimize how an entire XML document can be marked, tagged, or otherwise identified as having content that will merit future retrieval of the entire XML document. Operations in this third area may be referred to as subject indexing, tagging, cataloging, indexing, content indexing (as used herein), or search engine indexing of content in an XML document. Such operations are distinct from creation and maintenance of indexes in a database system.","Optimizations in relation to databases benefit from the ability to expend time and overhead processing and manipulating an XML document or XML data query once in exchange for optimization benefits over time due to the large collection of documents and high query request rates. In contrast, content indexing takes place during the update or storage of an XML document and so the impact of content indexing on performance should be minimal. Unfortunately, convention solutions in the area of content indexing have used XPATH processors that load the entire XML document into memory as a Document Object Model (DOM). This requires significant processing resources and delay waiting for the DOM instance to be generated. Furthermore, the set of XML documents that will be the subject of content indexing is unknown and thus conventional techniques are unpredictable. Typically, while the set of XML documents that will be the subject of content indexing is unknown it is known that the XML documents are generally very large often many tens of megabytes in size each. Consequently, the inefficient use of memory and processing resources of conventional content indexing solutions have prompted a search for more efficient solutions.","From the foregoing discussion, it should be apparent that a need exists for an apparatus, system, and method that optimally indexes XML document content. Beneficially, such an apparatus, computer program product, system, and method would efficiently use both processing resources as well a memory resources to index content of streaming hierarchical documents.","The present invention has been developed in response to the present state of the art and in particular, in response to the problems and needs in the art that have not yet been fully solved by currently available content indexing solutions. Accordingly, the present invention has been developed to provide an apparatus, computer program product, system, and method for content indexing of streaming Extensible Markup Language (XML) document content that overcome many or all of the above-discussed shortcomings in the art.","The computer program product for content indexing of streaming XML document content is provided with a plurality of components and modules configured to functionally execute the necessary steps of efficient content indexing. These modules in the described embodiments include a scanner, an identification module, a forest generator, a comparison module, a determination module, and a storage module.","In one embodiment, the scanner is an optional component that scans a streaming XML document in a stream of XML documents. The streaming XML document is streamed in document order according to XML tree traversal protocol. In one embodiment, the identification module is an optional component that identifies an XML node of the streaming XML document. The XML node may include an XML document element node and\/or an XML document element attribute node.","In one embodiment, the forest generator generates an XML pattern forest from a set of structured index path expressions. Each set of structured index path expressions is uniquely associated with a namespace indicator. Each structured index path expression includes a series of one or more steps, each step comprising an axis step and each step having a node test and no predicates. The XML pattern forest comprising at least one of a tree and a twig generated from one or more structured index path expressions uniquely associated with a namespace indicator for the XML node.","In certain embodiments, the forest generator includes a read module that reads the set of structured index path expressions from a repository. The set of structured index path expressions may be identified by way of the namespace indicator for the XML node.","In certain embodiments, the forest generator includes a skip module that ignores each structured index path expression having no descendent axis steps and each structured index path expression having a first axis step that is different from a root node of the streaming XML document. The forest generator may also include a twig generator that defines a new twig for each index path expression having a descendent-or-self axis for a first step, the new twig comprising nodes representing the index path expression. The forest generator may also include a tree generator configured to define a new tree for each index path expression having a first axis step different from a root of an existing tree in the XML pattern forest, the new tree comprising nodes representing the index path expression.","In one embodiment, the forest generator may also include a grafting module configured to identify an existing tree in the forest having a root node matching the first axis step of an index path expression and appending a branch of nodes to the existing tree. The branch of nodes corresponding to one or more axis steps of the index path expression that differ from nodes of the existing tree, the branch anchored at a node that matches a last matching axis step of the index path expression evaluated from left to right.","In one embodiment, the forest generator may also include a completion module that identifies a second streaming XML document in the stream of XML documents. The completion module discards the XML pattern forest in response to identifying the second streaming XML document.","In one embodiment, the comparison module compares the XML node to nodes of the XML pattern forest. In certain embodiments, the comparison module determines that the namespace indicator for the XML node is different from a previously identified namespace indicator and causes the forest generator to reference a second set of structured index path expressions. The second set of structured index path expressions may be identified by way of the namespace indicator, the forest generator may be further configured to modify the XML pattern forest to include at least one of a tree and a twig representative of the second set of structured index path expressions and the set of structured index path expressions. In one embodiment, the comparison module includes a pruning module configured to determine that the XML node is a root node for the streaming XML document, and remove one or more trees from the XML pattern forest having a root node that does not match the XML node.","In one embodiment, the determination module determines a match between the XML node and an index node in one of a tree and a twig of the XML pattern forest, the index node having a path from an ancestor node to the index node that matches the axis steps of at least one of the structured index path expressions for the namespace indicator.","In one embodiment, the storage module stores an index entry for the XML node in response to the determined match. The index entry comprises an XML document identifier, an XML node name, a namespace indicator for the XML node, and XML node content.","It should be noted that while the embodiments of the invention described herein refer to Extensible Markup Language (XML) nodes, XML data, streaming XML documents XML documents, and XML content. Certain embodiments of the present invention are not limited to handling XML structured documents, nodes, and or content. Specifically, those of skill in the art recognize that embodiments of the present invention may operate on other forms of streaming hierarchical data including, but not limited to Standard Generalized Markup Language (SGML), JavaScript Object Notation (JSON), Hypertext Markup Language (HTML), and the like.","A method, apparatus, and system are also provided for efficient content indexing of streaming XML document content each providing a plurality of components, modules, and operations to functionally execute the necessary steps of efficient XML content indexing. The method, apparatus, and system may also be configured to functionally perform the necessary steps as described above in relation to the computer program product. The computer program product may be embodied as part of a SAX parser or as an add-on to a SAX parser.","Reference throughout this specification to features, advantages, or similar language does not imply that all of the features and advantages that may be realized with the present invention should be or are in any single embodiment of the invention. Rather, language referring to the features and advantages is understood to mean that a specific feature, advantage, or characteristic described in connection with an embodiment is included in at least one embodiment of the present invention. Thus, discussion of the features and advantages, and similar language, throughout this specification may, but do not necessarily, refer to the same embodiment.","Furthermore, the described features, advantages, and characteristics of invention may be combined in any suitable manner in one or more embodiments. One skilled in the relevant art will recognize that the invention may be practiced without one or more of the specific features or advantages of a particular embodiment. In other instances, additional features and advantages may be recognized in certain embodiments that may not be present in all embodiments of the invention.","These features and advantages of the present invention will become more fully apparent from the following description and appended claims, or may be learned by the practice of the invention as set forth hereinafter.","Many of the functional units described in this specification have been labeled as modules, in order to more particularly emphasize their implementation independence. For example, a module may be implemented as a hardware circuit comprising custom VLSI circuits or gate arrays, off-the-shelf semiconductors such as logic chips, transistors, or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays, programmable array logic, programmable logic devices or the like.","Modules may also be implemented in software for execution by various types of processors. An identified module of executable code may, for instance, comprise one or more physical or logical blocks of computer instructions which may, for instance, be organized as an object, procedure, or function. Nevertheless, the executables of an identified module need not be physically located together, but may comprise disparate instructions stored in different locations which, when joined logically together, comprise the module and achieve the stated purpose for the module.","Indeed, a module of executable code may be a single instruction, or many instructions, and may even be distributed over several different code segments, among different programs, and across several memory devices. Similarly, operational data may be identified and illustrated herein within modules, and may be embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set, or may be distributed over different locations including over different storage devices, and may exist at least partially, merely as electronic signals on a system or network. Where a module or portions of a module are implemented in software, the software portions are stored on one or more computer readable media.","Reference throughout this specification to \u201cone embodiment,\u201d \u201can embodiment,\u201d or similar language means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, appearances of the phrases \u201cin one embodiment,\u201d \u201cin an embodiment,\u201d and similar language throughout this specification may, but do not necessarily, all refer to the same embodiment.","Reference to a computer readable storage medium may take any form capable of storing machine-readable instructions on a digital processing apparatus. A computer readable medium may be embodied a compact disk, digital-video disk, a magnetic tape, a Bernoulli drive, a magnetic disk, a punch card, flash memory, integrated circuits, or other digital processing apparatus memory device.","Furthermore, the described features, structures, or characteristics of the invention may be combined in any suitable manner in one or more embodiments. In the following description, numerous specific details are provided, such as examples of programming, software modules, user selections, network transactions, database queries, database structures, hardware modules, hardware circuits, hardware chips, etc., to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention may be practiced without one or more of the specific details, or with other methods, components, materials, and so forth. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","The schematic flow chart diagrams included herein are generally set forth as logical flow chart diagrams. As such, the depicted order and labeled steps are indicative of one embodiment of the presented method. Other steps and methods may be conceived that are equivalent in function, logic, or effect to one or more steps, or portions thereof, of the illustrated method. Additionally, the format and symbols employed are provided to explain the logical steps of the method and are understood not to limit the scope of the method. Although various arrow types and line types may be employed in the flow chart diagrams, they are understood not to limit the scope of the corresponding method. Indeed, some arrows or other connectors may be used to indicate only the logical flow of the method. For instance, an arrow may indicate a waiting or monitoring period of unspecified duration between enumerated steps of the depicted method. Additionally, the order in which a particular method occurs may or may not strictly adhere to the order of the corresponding steps shown.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 1","b":["100","100"]},"The system  includes a storage services module , a storage engine , a storage repository , a document indexer , a content indexer , an expressions repository , an index store , and a query services module .","The storage services module  serves to store and retrieve XML documents from the storage repository . A hardware processor may execute the storage services module  within a computer readable storage medium. The storage services module  differs from a database in that the storage services module  stores the XML documents intact, meaning the structure of the XML document is preserved once the XML document is stored in the storage repository . Users or other clients may send XML documents to the storage services module  for storage and safe keeping. The storage services module  passes the XML documents to the storage engine  to store the XML document.","The storage engine  simply stores the XML document while preserving the structural metadata defining the XML document. In one embodiment, the storage engine  stores the XML document as a Large Binary Object (BLOB) data type. Alternatively, the storage engine  stores the XML document in native text format.","The storage repository  serves to store the XML document in such a manner that the entire XML document can be retrieved in response to a unique identifier associated with the XML document. In one embodiment, the unique identifier is a Uniform Resource Identifier (URI) such as a Uniform Resource Locator (URL). The URL may serve to identify where the associated XML document is stored in the storage repository . The storage repository  may be implemented using a file system, a web server, a database or the like. Those of skill in the art will recognize that while the storage repository , storage engine and storage services module  may be embodied by a database, such a database would not include or utilize the complex indexes and optimization functionality of such a database. Except to identify and stream new or updated XML documents to the document indexer .","In one embodiment, the storage engine  does not do any parsing or processing of the XML document unless the XML document is a new XML document that has not previously been stored in the repository  or is an XML document that updates a previously stored XML document. If the XML document is a new XML document or an update for an existing XML document, the storage engine  streams the XML document to the document indexer . In one embodiment, the storage engine  comprises a Simple API for XML (SAX) module that is a serial access parser Application Programming Interface (API) for XML. Advantageously, the SAX module parses the XML document and creates a stream of data nodes representative of the XML document. The document indexer  then listens for specific types of nodes as the SAX module streams the XML document.","The document indexer  serves to collect, parse and store data for fast retrieval from a structured, but undefined set of documents such as a set of XML documents, HMTL documents, or the like. A document indexer  may also be referred to as a web crawler, web indexer, a search engine indexer, and the like.","The document indexer  serves to identify nodes in an XML document that match previously defined structured index path expressions . In one embodiment, the structured index path expressions  are stored in an expression repository . In one embodiment, the expression repository  comprises a data structure such as a data file, a database, or the like and may be stored in persistent storage such as on a disk drive or other form of persistent data storage device. In certain embodiments, the expression repository  comprise a cache of efficient and fast memory that is loaded and updated as needed with structured index path expressions  from a more persistent memory storage device, or a combination of persistent and non-persistent memory devices.","As used herein, the term \u201cstructured index path expressions\u201d refers to a pre-defined XML node and\/or content value(s) including XML nodes content and XML attribute content that is to be identified and extracted from an arbitrary and unknown set of XML documents if that XML node and\/or content value(s) occurs in the set of XML documents. Structured index path expressions  are described and explained in more detail in relation to . It should be noted that a structured index path expressions  differs from a database query because at the time the structured index path expressions  is defined the set of XML documents that may or may not include the XML node and\/or content value(s) is arbitrary and unknown. While a database query may return no results, the structure of the database (its tables, indexes, and the like) are well defined and known before the query is formed.","Because the size of XML documents and number of XML documents in the set of XML documents that the document indexer  processes is unknown, the document indexer  preferably uses a minimal amount of memory and processes each XML document as quickly as possible. To satisfy these constraints, the document indexer  operates on a stream  of one or more XML documents. The document indexer  sends this stream  of XML documents to a content indexer . The content indexer  listens for particular types of data to pass by in the stream of XML documents. When a particular type of data as indicated by the content indexer  comes along in the stream , the document indexer  signals the content indexer . All other data in the stream  that is not of interest to the content indexer  simply passes through the stream  and is ignored by the content indexer . In this manner, a minimal amount of memory is used and the XML documents can be of any size and the stream can have an unlimited number of XML documents without impacting the performance of the document indexer .","The content indexer  seeks to match content and\/or document structure in the XML stream  with one or more structured index path expressions . If a match is found, the content indexer  stores an index entry  in the index store . The match provides an indicator that the content described in the matching structured index path expressions  can be found in the XML document that included a data node that satisfied the structured index path expressions . The content indexer  the watches for particular types of data to occur in the stream of XML documents. In one embodiment, the content indexer  watches for XML nodes that are one of XML document element nodes and\/or XML document element attribute nodes.","The index entry  serves to identify the XML document that matched an existing structured index path expression . The form and structure of the index entry  may vary so long as the index entry  includes a unique identifier of the corresponding XML document. In one embodiment, the index entry  comprises an XML document identifier, an XML node name for the XML node that satisfied a structured index path expression , a namespace indicator for the XML node and the content or value contained within the XML node. The unique identifier for the corresponding XML document may comprise a single element of the index entry  or a composite of multiple elements of the index entry .","In one embodiment, the index store  comprises a data structure such as a data file, a database, or the like and may be stored in persistent storage such as on a disk drive or other form of persistent data storage device. The index store  interfaces with the query services module .","The query services module  accepts queries from a user or client for index entries  that satisfy the query. The query services module  searches the index store  for one or more index entries  that match the provided query. If a match is found, in one embodiment, the matching index entries  are returned. In an alternative, embodiment, a unique XML document identifier is returned for each matching index entry . The client or user may then use the unique XML document identifier to retrieve the corresponding XML document if desired. For example, the user\/client may send a request for a corresponding XML document to the storage services module . In this manner, the system  provides a very efficient and fast indexing system for a set of XML documents having an undefined number of XML documents and undefined size of each XML document based on structured index path expressions .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","110","200","210","220","230","240","250","260"]},"The scanner  serves as an optional component that may be included in certain embodiments and may not be included in other embodiments. The scanner  scans a streaming XML document in a stream  of XML documents. The streaming XML document flows through the stream in document order in accordance with the XML tree traversal protocol. An XML document is a hierarchical structure that includes a root node at the top and zero or more levels of children of the root node. Each node in the XML document may include child nodes.","Document order in the XML tree traversal protocol means that the root node is first in the order, each node is processed before all of its children and descendants, attribute nodes immediately follow the element node they are associated with, sibling nodes are ordered in the order in which they occur in a children property of their parent node, and children and descendants occur before following sibling nodes. Streaming the XML document in document order permits the apparatus  to implement efficiency improvements because the order of each XML document is set.","The identification module  serves as an optional component that may be included in certain embodiments and may not be included in other embodiments. The identification module  identifies an XML node of the streaming XML document that may include content that matches one or more of the structured index path expression . In a particular embodiment, the identification module  identifies XML nodes that have a type of either XML document element node or XML document element attribute node. As is known in the art, XML documents may include a variety of types of XML nodes including comment nodes, text nodes, namespace nodes, and processing instructions nodes. By identifying just XML document element nodes and. or XML document element attribute nodes, the identification module  ignores the other XML node types which improves the efficiency of the apparatus .","In one embodiment, the identification module  is integrated with or operates in conjunction with a SAX parser. The identification module  may register one or more XML node types for the SAX parser to watch for in the XML document stream. Once the SAX parser locates an XML node of the type registered, the SAX parser may signal the identification module  which may optionally then signal the forest generator  and\/or the comparison module .","The forest generator  generates an XML pattern forest from a set of structured index path expressions . The XML pattern forest facilitates matching of structured index path expressions  to XML nodes in the streaming XML document while minimizing or eliminating the need to evaluate and\/or reevaluate the structured index path expressions  as each XML node i located. The XML pattern forest is a data structure having zero or more hierarchical tree structures and zero or more hierarchical twigs. The XML pattern forest generates a twig and\/or a tree for each structured index path expressions  in a set of structured index path expressions . Each member of the set of structured index path expressions  is associated with a namespace by a unique namespace indicator. Each XML node in the streamed XML document is associated with a namespace indicator. An XML pattern forest is described in more detail below in relation to .","The comparison module  compares the XML node identified by the identification module  to nodes within the XML pattern forest. In certain embodiments, the comparison module  tracks where the XML node partially matches a tree of the XML pattern forest as the XML document passes by in the stream. By tracking the partial matches within one or more trees and\/or one or more twigs of the forest, the comparison module  maintains a context for determining whether the particular XML node in the stream  may match one or more of the structured index path expressions .","The determination module  determines a match between the XML node and an index node in either a tree and\/or a twig of the XML pattern forest. In one embodiment, the determination module  examines the current XML node and nodes of one or more of the trees and\/or twigs of the XML pattern forest in order to determine that the XML node matches an index node of either a tree and\/or a twig of the XML pattern forest. An index node is a node of a tree or a twig of that XML pattern forest that has a path from an ancestor node in the tree or twig to the index node that matches the axis steps of at least one of the structured index path expressions  for a specific namespace identified by a unique namespace indicator. Each node of the at least one tree and\/or at least one twig is associated with a unique namespace indicator. Each tree may comprise index nodes from a plurality of namespaces.","The storage module  stores an index entry  built from the XML node in response to the determination module  finding a match between the XML node and at least one index node of the XML pattern forest. In one embodiment, the index entry  comprises an XML document identifier such as a URL or URI, an XML node name for the XML node, a namespace indicator for the XML node and the content or value contained within the XML node. Alternatively, the index entry may include just the XML document identifier so long as the XML document identifier uniquely identifies the XML document. In another embodiment, the index entry  comprises an XML document identifier, composite field of the XML node name and the namespace indicator for the XML node, and the content or value contained within the XML node.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 3","b":"340"},"For example, in one embodiment, the comparison module  may maintain a listing of each unique namespace for the XML nodes that are compared in a given XML document. The comparison module  may determine whether the namespace indicator of an XML node currently being compared includes a namespace indicator that is different from a previously identified namespace indicator. If the XML node includes a namespace indicator that has not yet been previously identified for this XML document, the comparison module may signal the forest generator  to reference a second set of structured index path expressions .","This second set of structured index path expressions  is uniquely associated with the namespace indicator that has not previously been identified for this XML document. In response to the signal from the comparison module , the forest generator \/ may modify the XML pattern forest to include at least one of a tree and\/or a twig that represents the second set of structured index path expressions . In this manner, the XML pattern forest now represents the structured index path expressions  for each previously identified namespace indicator as well as for the namespace indicator of the XML node currently being compared.","In addition or alternatively, the comparison module  may include a pruning module . The comparison module  may activate the pruning module  if the present invention has previously identified the root node of the streaming XML document. If the root node is not the same as the current XML node being compared, then any tree in the XML pattern forest having a root node that is not the same as the root node of the streaming XML document will never match any other XML node in the streaming XML document.","Consequently, in certain embodiments, in order to further increase efficiency, the pruning module  may delete or remove each tree in the XML pattern forest having a root node that is different from the root node for the streaming XML document. Removing the trees that will never match descendent of XML nodes of the current streaming XML document reduces the number of nodes the comparison module must search for subsequent XML nodes of the streaming XML document.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 3","b":["330","330","320","350","360","370","380","390"]},"The read module  reads a set of structured index path expressions  from a repository. In one embodiment, the repository is a structured index path expression repository . Alternatively, the structured index path expression repository is a dedicated portion of non-persistent memory, a file data structure, a cache, or the like. The set of index path expressions  are uniquely associated with a particular namespace. That namespace is represented by a specific namespace indicator. In certain embodiments, the forest generator  activates the read module  to reference or read a set of structured index path expressions  for each namespace indicator. As noted above, each XML node may be associated with a different namespace as defined by its namespace indicator. Associating each set of structured index path expressions  with a particular namespace indicator provides flexibility in defining structured index path expressions  since a set of particular structured index path expressions  can be defined for each namespace indicator.","The skip module  identifies structured index path expressions  that should not be added to the XML pattern forest. Typically, the index path expressions  that should not be added are those which had no further information beyond what is already represented. Or, the index path expressions  represent a match that not possible with the current a streaming XML document. In one embodiment, the skip module  ignores each index path expression  that has no descendent axis steps. In addition, the skip module  eight north each index path expression  having a first axis step that is different from a root node of the current streaming XML document. As used herein the term \u201cskip\u201d and \u201cignore\u201d refer to the act of reviewing and the index path expression  and determining to make no additions to the XML pattern forest to represent that index path expression .","The twig generator  defines a new twig in the XML pattern forest for each index path expression  that includes a descendant-or-self axis for a first step. A descendant-or-self axis is typically represented by the abbreviation \u201c\/\/\u201d. A twig is a special form of a hierarchical structure. The twig does not include a particular root node limitation. Instead, a branch of a hierarchical structure can match the twig so long as each step of the branch matches each descendent node of the twig below the descendant-or-self axis. Twigs are described in more detail in relation to .","The tree generator  defines a new tree in the XML pattern forest for each index path expression  that includes a first axis step different from a root node of an existing tree in the XML pattern forest. A tree is a hierarchical structure having a root node and descendent nodes that follow the similar structural limitations to an XML document. Trees are described in more detail in relation to .","The grafting module  identifies an existing tree in the forest having a root node matching the first axis step of an index path expression . The grafting module  evaluates the index path expression  from left to right. The grafting module  appends a branch of nodes representing the index path expression  to the existing tree. Each node of the branch corresponds to an axis step of the index path expression that differ from nodes already present in the existing tree. The branch is anchored, or connected to the existing tree at a node that matches a last matching axis step of the index path expression  when the index path expression  is evaluated from left to right.","The read module , skip module , twig generator , tree generator , and grafting module  cooperate to augment or shrink the XML pattern forest as XML nodes of a streaming XML document are processed. Advantageously the forest generator  is capable of handling XML nodes from a plurality of namespaces.","Optionally, the forest generator  also includes a completion module . The completion module  identifies a second streaming XML document in the stream of XML documents. For example, in one embodiment, the completion module  identifies a second streaming XML document by identifying a close tag a first streaming XML document. In addition, the completion module  may discard, delete, or remove the XML pattern forest as a result of identifying the second streaming XML document. In one embodiment, the completion module  discard the XML pattern forest by deleting each tree and each twig in the pattern forest. In addition, the completion module  may reset a list of identified namespaces such that a new XML pattern forest can be generated for the second streaming XML document.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 4","FIG. 2","FIG. 1"],"b":["200","110"]},"The example set forth in  includes a collection  of sets of structured index path expressions , a sample XML document  illustrated for discussion purposes, an illustrated representation of an XML pattern forest , and an illustrated representation of a streaming XML document  that indicates nodes identified during the processing of the sample XML document .","The collection  includes sets of structured index path expressions  includes one or more sets of structured index path expressions . Each structured index path expression  is defined previously by a client or user. The client or user may be an administrator or other user who has determine an attribute value, node characteristic, node name, or set of nodes relative to an ancestor node or even a set of wild card nodes (\u201c*\u201d) that make the associated XML document that includes those nodes of interest for identifying and indexing or cataloging in an index store .","A structured index path expression  is similar in structure and format to an XML path language (XPATH) expression with certain constraints. First, a structured index path expression  includes no predicates in the axis steps that define the structured index path expression . Second, axis steps of the structured index path expression  include exclusively a node test. Consequently, a structured index path expression as used herein is a series of one or more steps, each step comprising an axis step having a node test and no predicates. In addition, a structured index path expression may start with a descendent or descendent-or-self axis but can then only be followed by a descendent or attribute axis. With the given definition of structured index path expressions , a very robust set of expression can be defined in order to identify both nodes and attributes of interest in a given XML document.","Examples of both valid and invalid structured index path expressions  include, \u201c\/Glossary\u201d\u2014valid, \u201c\/Glossary\/name\u201d\u2014valid, \u201c\/Glossary\/*\/name\u201d\u2014valid, \u201c\/*\/*\u201d\u2014valid, \u201c\/\/term\/name\u201d\u2014valid, \u201c\/\/term@name\u201d\u2014valid, \u201c\/term\/\/name\u201d\u2014invalid, because descendent-or-self axis is only allowed as a first step, \u201cterm\/name\u201d\u2014invalid, because structured index path expressions may not be relative.","The collection  illustrates two sets of structured index path expressions . Of course, the collection  can include one or more sets, those of skill in the art recognize that two sets are illustrated here for the example. Each set of structured index path expressions  is uniquely associated with a namespace represented by a namespace indicator. In the collection , the example namespace indicators are \u201cNS,\u201d and \u201cNS.\u201d","The sample XML document  includes ten nodes, the root node is A. Suppose the sample XML document  has a unique document identifier \u201chttp-www.example.com\\Sample.xml.\u201d Nodes B, D, X, Y, X are descendent nodes and nodes B, Y, Z, and C are leafnodes and descendent nodes. As explained above, the embodiments of the present invention does not read the whole sample XML document  into memory as in the DOM model. Instead, the embodiments of the present invention operate on the nodes of the sample XML document  as they stream past in a stream of XML documents . Examining nodes in the stream of XML documents  saves memory as the XML documents streamed may be very large and require significant memory and processing overhead if the XML documents were to be completely represented in memory before being analyzed. Those of skill in the art recognize that certain embodiments of the invention may watch the stream  for other types of XML nodes such as text nodes, and\/or comment nodes. In the stream of XML documents, the sample XML document  is represented with each listed in document order from the root down in the stream reading from right to left.","Operation of one embodiment such as the apparatus  of  by way of illustration is now described. Initially, the sets of structured index path expressions  are defined and made accessible to the forest generator . Next, a scanner  streams the sample XML document  to generate the streaming XML document . The identification module  watches the stream  for nodes of interest. In this example, the nodes of interest are XML document element nodes and XML document element attribute nodes.","Those of skill in the art will recognize that the sample XML document  and thus, the streaming XML document  may include nodes that are not of the type XML document element node and\/or XML document element attribute node. For example, the sample XML document  and corresponding streaming XML document  may include text nodes, comment nodes and the like. Examples of such nodes in the sample XML document  have not been included for clarity of the example.","Arrow N represents the identification by the identification module  of XML element node A. In one embodiment, the identification module  sends node A to the forest generator . The identification module  or the forest generator  may identify the namespace indicator for node A. Suppose the namespace indicator is \u201cNS.\u201d","The forest generator  generates as much of the XML pattern forest  as possible based on the structured index path expressions  associated with NS, see collection . Here, there are four structured index path expressions . Those of skill in the art recognize that any number of structured index path expressions  may be associated with a namespace indicator.","The forest generator  evaluates each structured index path expression  in turn. Evaluation of \u201c\/A\/B\/C\u201d results in the left-most branch of the tree . Evaluation of \u201c\/A\/B\/D\u201d results in a grafting into the tree  of the left-most D leaf node.","Evaluation of \u201c\/A\/B\u201d results in the marking of the B node as an index node. An index node is a node of an XML pattern forest tree or twig that has a path from an ancestor node to the index node that matches the axis steps of at least one of the structured index path expressions for the namespace indicator. Evaluation of \u201c\/A\/D\/C\/E\u201d results in a grafting into the tree  of the right branch D-C-E below the root A. Nodes in the forest  that are index nodes are illustrated by the stippled background for the node. In the XML pattern forest  nodes B, C, D, E, Y, Z, and Y are each index nodes.","Next, the comparison module  compares node A to the nodes of the pattern forest and finds a match at the root of tree . However, because root node A is not an index node no match is identified by the determination module . The apparatus  then waits for the next node of interest to come by in the stream .","Next, the identification module  sends node B (arrow N) to the forest generator . Suppose node B has the same namespace NS and content value of \u201cB is for Boy\u201d and further suppose that nodes A, B, B, D, C of the streaming XML document  also are in namespace NS. The forest generator  determines that no adjustments to trees or twigs of the forest  are needed.","The comparison module  compares node B to the nodes of the pattern forest and the determination module  finds a match at the left-most B node of tree . Because node B is an index node, the comparison module  identifies node B as a match and signals the storage module  to store an index entry  for node B. The index entry  includes an XML document identifier, an XML node name, a namespace indicator, and XML node content. In the example, of , the index entry  may be (\u201chttp:\\\\www.example.com\\Sample.xml,\u201d \u201cB,\u201d \u201cNS,\u201d \u201cB is for Boy\u201d). The apparatus  then waits for the next node of interest to come by in the stream .","Those of skill in the art will recognize different techniques for the determination module  to determine whether an XML node matches one or more of a tree and\/or a twig of the XML pattern forest . For example, the determination module  may maintain a set of hierarchical structures such as software objects that represent the trees and\/or twigs of the forest . The determination module  may manage pointers that indicate which node in each tree and\/or twig the last processed XML node of the streaming XML document matched, even if the match did not result in creation of an index entry . These pointers may serve as a context in relation to the XML pattern forest .","Alternatively, or in addition, rather than maintaining tree objects in memory and associated pointers, the determination module  may simply maintain a list of trees and a list of twigs in the forest . Each list includes nodes of the forest and each node identifies its child nodes as well as a flag indicating if that node is an index node. The determination module  may also maintain a listing of stack of previous partial matches between a XML node of the XML document and a node of a tree or twig, even if the partial match did not result in creation of an index entry .","The set of partial matches serves as a context in relation to the XML pattern forest . For a subsequent XML node from the XML document, if the determination module  determines the subsequent XML node is a child of a member of the partial matches, the determination module  has located another partial match that extends further down into a tree or twig of the forest. In addition, if the child of a partial match matches the subsequent XML node and the child nodes is also an index node, then the determination module  has found a complete match and an index entry  can be generated.","In one embodiment, the determination module  operates using partial matches as a context with the understanding that if the context is null the matching operation has not been previously called and that matching should start with the root nodes in the trees list. If the context is not null the determination module  recognizes that the context is not null and includes the last set of partial match as a result of a previous call to the determination module .","Next, the identification module  sends node B (arrow N) to the forest generator  (or signals the forest generator  to examine node B). The forest generator  makes no changes because the namespace is the same and has been already used to populate the forest . The comparison module  compares node B to the nodes of the pattern forest  and finds no match for \/A\/B\/B. The apparatus  then waits for the next node of interest to come by in the stream .","Next, the identification module  sends node D (arrow N) to the forest generator . The forest generator  makes no changes because the namespace is the same and has been already used to populate the forest . The comparison module  compares node D to the nodes of the pattern forest  and finds a match for \/A\/B\/D because the left-most D node is an index node. The comparison module  may signal the storage module  to store an index entry  for node D, such as for example, (\u201chttp:\\\\www.example.com\\Sample.xml,\u201d \u201cD,\u201d \u201cNS,\u201d \u201cD is for Doll\u201d). The apparatus  then waits for the next node of interest to come by in the stream .","Next, the identification module  sends node X (arrow N) to the forest generator . Suppose that nodes X, Y, X, Y, and Z of the XML document  are each for namespace \u201cNS.\u201d In one embodiment, the comparison module  of the apparatus  determines that the namespace of node X is different from the previously identified namespace \u201cNS.\u201d Consequently, the comparison module  may signal or otherwise case the forest generator  to reference, read, load, and\/or retrieve a second set of structured index path expressions . As illustrated in this example, the second set of structured index path expressions  may comprise all those expressions associated with namespace \u201cNS\u201d including \/X\/Y, \/X\/Z, and \/\/X\/Y. Next, the forest generator  may modify the XML pattern forest  to include at least one of a tree and a twig that represents each structured index path expressions  in the second set of structured index path expressions .","In this example, this means that the forest generator  may generate the new tree rooted at X node having descendent nodes Y and Z that are index nodes. In addition, the forest generator  may generate a twig data structure comprising X as the top node with the descendent index node Y. It should be noted that the relative descendent-or-self structured index path expression  \u201c\/\/X\/Y\u201d is not rooted in the X node. The triangle indicates that this is a twig representing a relative structured index path expressions .","In one embodiment, the tree generator  generates the new tree  and the twig generator  generates the new twig . In certain embodiments, or in addition, the forest generator  may execute the skip module  which prevents the generation of the new tree  because the skip module  may recognize that the root node of the XML document is A and has already been identified and thus no descendent nodes of the XML document can have X as a root node. Alternatively, the comparison module  may execute the pruning module  which removes  the tree  for these same reasons. In contrast, the twig  is not removed because node X\u2014in the triangle, is not a root node and thus can match in the XML document on later encountered descendent nodes.","The comparison module  compares node X to the nodes of the pattern forest  and finds a match in the twig  for node X but node X is not an index match. The apparatus  then waits for the next node of interest to come by in the stream .","Next, the identification module  sends node Y (arrow N) to the forest generator . The forest generator  makes no changes because the namespace is the same and has been already used to populate\/modify the forest . The comparison module  compares node Y to the nodes of the pattern forest  and finds a match for \/\/X\/Y in the twig  because the Y node is an index node. The comparison module  may signal the storage module  to store an index entry  for node Y, such as for example, (\u201chttp:\\\\www.example.com\\Sample.xml\u201d \u201cY,\u201d \u201cNS,\u201d \u201cY is for Yack\u201d). The apparatus  then waits for the next node of interest to come by in the stream . This process repeats until the completion module  determines that a second streaming XML document is next to arrive in the XML document stream . The completion module  may identify a second streaming XML document by identifying the last node of the current streaming XML document . Alternatively, or in addition, the completion module  may identify a second streaming XML document by identifying the first node of the a second streaming XML document.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 5","b":["500","500","210","510","408","120","408","220","520","408","120","220"]},"Next, the forest generator  generate or modifies  an XML pattern forest  based on a set of structured index path expressions . The XML pattern forest  includes one or more trees  or one or more twigs  generated from a set of structured index path expressions  uniquely associated with a namespace indicator for the XML node. With certain iterations, the pruning module , skip module , twig generator , tree generator , and\/or grafting module  may modify the XML pattern forest  for efficiency and to accurately represent the structured index path expressions  referenced by different namespace indicators.","Next, the comparison module  compares  the XML node to nodes of the XML pattern forest . Preferably, the comparison module  searches nodes in each tree and in each twig of the forest . In one embodiment, the comparison module  may determine that the namespace indicator is different from a previously identified namespace indicator and cause the forest generator  to reference a second set of structured index path expressions, the second set of structured index path expressions identified by way of the namespace indicator, the forest generator  may further modify the XML pattern forest to include at least one of a tree and a twig representative of the second set of structured index path expressions and the set of structured index path expressions.","The determination module  determines  if there is a match between the XML node and an index node in one of the trees and\/or twigs of the XML pattern forest . If not, the method  returns to scanning  the streaming XML document. If there is a match, the storage module  stores  an index entry  representative of the XML node.","The completion module  determines  if the end of the streaming XML document has been reached and\/or whether a second streaming XML document is now present in the stream . If not, the method  returns to scanning  the streaming XML document. If so, the completion module  may discard  or delete  the members of the XML pattern forest . Then the method  returns to scanning  a subsequent streaming XML document.","The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is, therefore, indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order that the advantages of the invention will be readily understood, a more particular description of the invention briefly described above will be rendered by reference to specific embodiments that are illustrated in the appended drawings. Understanding that these drawings depict only typical embodiments of the invention and are not therefore to be considered to be limiting of its scope, the invention will be described and explained with additional specificity and detail through the use of the accompanying drawings, in which:",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
