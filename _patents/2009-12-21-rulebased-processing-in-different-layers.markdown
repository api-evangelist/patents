---
title: Rule-based processing in different layers
abstract: In an embodiment, a method is provided for processing rules within a layer of an application. In this method, a rule defining a condition and a functionality associated with the condition is received at runtime of the layer. This functionality is provided by the layer. Using a microprocessor, a fulfillment of the condition is identified and the functionality is executed based on this identification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08635178&OS=08635178&RS=08635178
owner: SAP AG
number: 08635178
owner_city: Walldorf
owner_country: DE
publication_date: 20091221
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["The present disclosure relates generally to rule-based systems. In an embodiment, the disclosure relates to rule-based processing in different layers.","Software and hardware components can often have errors that produce incorrect or unexpected results, or cause the components to behave in unintended ways. Debugging is a process of finding and correcting the errors, and currently, a large number of diagnostic applications may be used to \u201cdebug\u201d errors. For example, dedicated traces and\/or logging extensions may be deployed within a system for use in extracting more information about particular errors. This information can then be used to fix the errors. Often, these dedicated traces and logging extensions are deployed using a software patch, which is a piece of software designed specifically to update a software application or its supporting data. However, the use of software patches can be troublesome because it takes time to download and apply the patches. Furthermore, the patches themselves can cause additional errors especially when the patches are incorrectly applied.","The description that follows includes illustrative systems, methods, techniques, instruction sequences, and computing machine program products that embody illustrative embodiments of the present invention. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide an understanding of various embodiments of the inventive subject matter. It will be evident, however, to those skilled in the art that embodiments of the inventive subject matter may be practiced without these specific details. In general, well-known instruction instances, protocols, structures and techniques have not been shown in detail.","The embodiments described herein provide techniques for processing rules in different layers. Here, a rule-based engine is tightly integrated within a layer of an application, such as an application server layer, an operating system layer, and\/or a virtual machine layer. As a result of this integration, the rule-based engine can access functionalities provided by the layer at runtime. As explained in more detail below, the functionalities can be triggered and controlled based on rules provided to the rule-based engine.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":["106","104","104","104","104","104","106"]},"In the embodiment depicted in , the rule engine module  is integrated or embedded within the operating system layer . That is, the operating system layer  does not run or manage the rule engine module . Rather, the rule engine module  is a part of the operating system layer . A \u201clayer,\u201d in one example, may refer to one or more programs or hardware that embody a particular software and\/or hardware functionality or system, such as an operating system (or operating system layer ). That is, a layer can be a framework that embodies a particular software and\/or hardware functionality or system. For example, a layer may refer to an application or hardware itself. In another example, a layer may refer to a set of applications and\/or hardware that provides a particular functionality.","It should be appreciated that an operating system layer  itself may be comprised of individual modules, and the rule engine module  may be integrated within one or more of these modules. Examples of such modules include a hardware abstraction module, a system interface or kernel module, a file system module, a driver module, and an application programming interface module.","As a result of the rule engine module  being integrated within the operating system layer , the rule engine module  has access to and can execute functionalities that are provided by the operating system layer . That is, the rule engine module , in this embodiment, can consume and control the functionalities provided by the operating system layer . Examples of such functionalities that are provided by the operating system layer  include creation of processes or threads, allocation of memory resources, connections to sockets, opening of Transmission Control Protocol (TCP)\/Internet Protocol(IP) connections, and other functionalities provided by the operating system layer . As described in more detail below, the operating system layer  or other layers may provide its functionalities through application programming interfaces.","It should be appreciated that in other embodiments, the rule engine module  may include fewer, more, or different modules apart from those shown in . For example, in other embodiments, the rule engine module  may be comprised of a sub-module that loads or receives rules and another sub-module that executes rules.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2","b":["106","108","108","105","108","108","108","108","108"]},"In the embodiment depicted in , the rule engine module  is integrated within the application server layer . It should be appreciated that the application server layer  itself may be comprised of individual modules, and the rule engine module  may be integrated within one or more of these modules. Examples of such modules include a dispatcher module, a gateway module, and a work process module.","As a result of the integration, the rule engine module  has access to and can execute functionalities that are provided by the application server layer . Examples of such functionalities that are provided by the application server layer  include activation and deactivation of diagnostic tools, authentication, authorization, session management, transaction management, cache infrastructure management, and other functionalities provided by the application server layer .",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3","b":["106","110","110","108","104","110","110","110","110","110"]},"In the embodiment depicted in , the rule engine module  is integrated within the virtual machine layer . It should be appreciated that the virtual machine layer  itself may be comprised of individual modules, and the rule engine module  may be integrated within one or more of these modules. Examples of such modules include a diagnostic module, a memory management module, a class loader module, and an interpreter module.","As a result of this integration, the rule engine module  has access to and can execute functionalities that are provided by the virtual machine layer . Examples of such functionalities that are provided by the virtual machine layer  include language dependent functionalities (e.g., security), file handling functionalities, execution of modules, tracing functionalities, logging functionalities, debugging functionalities, memory management capabilities, interactions with databases, transaction and communication management, parallel processing of modules, and other functionalities provided by the virtual machine layer .",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 4","FIGS. 1","FIG. 4"],"b":["400","400","106","2","3","402"]},"With receipt of a rule, the rule engine module at  identifies satisfaction or fulfillment of a condition defined by the rule. In one embodiment, the condition can be fulfilled based on the occurrence of one or more specific events. An \u201cevent,\u201d in one example, may refer to an occurrence or happening of significance to a task or program application. Examples of events include a completion of an input\/output operation, a program error that indicates a significant problem, a completion of a successful operation of an application, driver, or service, receipt of a particular message, and other events. For example, a rule may define a condition based on the occurrence of a specific event (e.g., \u201cif\u201d event). The condition is deemed fulfilled upon identification of the occurrence of this event. In one embodiment, the identification of the occurrence of the event can be made by detecting the occurrence of the event. In an alternate embodiment, the identification can be made by receiving messages or other notifications that indicate the occurrence of the event.","In another embodiment, the condition can be fulfilled based on the non-occurrence of one or more specific events. For example, a rule may define a condition based on the non-occurrence or absence of a specific event (e.g., \u201cif not\u201d event). The condition is deemed fulfilled upon identification of the absence of the particular event. Similarly, in one embodiment, the identification of the non-occurrence of the event can be made by detecting a non-occurrence of this event. In an alternate embodiment, the identification can be made by, for example, not receiving messages or other notifications that indicate the occurrence of the event.","Upon identification of the fulfillment of the condition, the rule engine module executes at  one or more functionalities associated with the condition, as defined by the rule. As discussed above, depending on where the rule engine module is integrated, the functionalities can be provided by, for example, the operating system layer, the application server layer, and\/or the virtual machine layer. The execution of a functionality may include, for example, activating a particular functionality. It should be appreciated that in addition to functionalities based on the type of layer, the rules may also define functionalities provided by the rule engine module itself. For example, such a functionality may include the triggering the execution of other rules received by the rule engine module.","Given that a rule engine module can be dynamically updated with new or updated rules, the rule engine module may provide a flexible infrastructure that can adapt to system changes. For example, rather than to develop a new software patch to diagnose an error in a particular software application, a new rule can be provided to the rule engine module at runtime that provides diagnostic functionalities without modifying the particular software application.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5","b":["500","500","520","521","522","500"]},"It should be appreciated that defects or faults may exist in software or hardware components. The diagnostic-based system  is an infrastructure that provides various functionalities for troubleshooting or diagnosing these components. As a result, users may troubleshoot components by accessing the various diagnostic functionalities provided by an application server layer or a virtual machine layer through an application programming interface, such as the diagnostic interface  included in the interface layer .","With the diagnostic-based system , a user can diagnose any suitable software and\/or hardware error by activating diagnostic tools - used for diagnosing components. These diagnostic tools - are applications that provide functionalities for use in diagnosing and resolving hardware and\/or software problems. An example of a diagnostic tool is a debugger , which is an application used to test and debug software and\/or hardware components. The debugger  may, for example, provide a display of the contents of a computer memory, including source code and variables. Another example of a diagnostic tool is a memory analyzer  that can analyze or check allocated memories during execution. Yet other examples of diagnostic tools are functional and performance tracing tools  and , respectively, that provide functionalities such as measuring execution (e.g., consumed time for execution of modules), tracing the execution path of an application, and performing class trace generation. In particular, the functional trace  dumps or provides information regarding the execution of certain functionalities in, for example, an operating system layer or an ABAP application server. The performance trace  delivers information regarding time consumption or measurements during execution. Other examples of diagnostic tools include application log , network route tracers, security monitors, performance monitors, configuration monitors, and other diagnostic tools. In one embodiment, the diagnostic tools - may be plug-in applications, which are computer programs that interact with a host application to provide certain functionalities (e.g. diagnostic functionalities).","The interface layer  includes a diagnostic interface , which is a component-specific interface that enables the diagnostic tools - to register their implementing class for the dedicated interface. Some examples of these functionalities provided by way of the diagnostic interface  include getActivationLevel( ) Activate( ), Deactivate( ) and other functionalities. Generally, this interface layer  serves as a repository layer to identify available and connected diagnostic tools -. Additionally, the interface layer  provides the interface methods or capabilities, which can be addressed and used by the diagnostic rule engine module .","The rule-based layer  includes the diagnostic rule engine module  that can receive rules at runtime through, for example, scripts, command line interfaces, or electronic documents (or rule documents -). In one embodiment, the rules may be included in an electronic document. An electronic document generally refers to electronic media content that is accessible by computer technology. For example, an electronic document can be a file that is not an executable file or a system file and includes data for use by a computer program. Examples of electronic documents include a single or multiple files that are accessible by and\/or associated with electronic document processing applications such as word processing applications, document viewers, email applications, spreadsheet applications, and other applications. Therefore, the electronic document may be composed of alphanumeric texts, symbols and other data. It should be appreciated that the electronic document can have a variety of file formats that, for example, may be identified by data within the electronic document and\/or by the filename extension. Examples of electronic documents with different file formats include text documents, Hypertext Markup Language (HTML) documents, and Extensible Markup Language (XML) documents. As an example, the following Table A shows an XML format of a rule \u201cWhen process type=batch && user=\u2018mustermann\u2019 && day=20091216 && time=&&2200","Then functional.trace.level=2,\u201d which activates some functional traces when a batch job getting executed for certain user account (user id: mustermann) at a certain time (on Sunday at 10:00 PM):",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<rd-troubleshooting>"]},{"entry":[{},"<rd-condition>"]},{"entry":[{},"<process-type>batch<\/process-type>"]},{"entry":[{},"<user-session><user-id>mustermann<\/user-id><\/user-session>"]},{"entry":[{},"<day>20091216<\/day><time>2200<\/time>"]},{"entry":[{},"<\/rd-condition>"]},{"entry":[{},"<rd-action>"]},{"entry":[{},"<functional-trace><level>2<\/level><\/functional-trace>"]},{"entry":[{},"<\/rd-action>"]},{"entry":[{},"<\/rd-troubleshooting>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"512"},"These electronic documents with the rules (or rule documents -) are interpreted and executed at runtime by the diagnostic rule engine module  on the basis of functionalities provided through the interface layer . Additionally, the rule documents - may be stored in a variety of locations depending on, for example, associated functionalities and activity ranges. Examples of locations where the rule documents - may be stored include a file system, a database, shared memory, or in a central or distributed registry. As an example, rule documents - used for diagnosing a Web server can be stored either in a file system or in a database. The deployment of the rule documents - in an ABAP Web Application server can be based on a database such that the rule documents - could be applied to all involved or available application server in a system if requested. The rule documents - could also be retrieved at runtime from the database and cached in the share memory to possibly accelerate, for example, access to the rule documents - document when multiple parties or processes (e.g., application server work processes) simultaneously access the rule documents -.","Still referring to , in one example, the diagnostic-based system  may be embodied in an ABAP application server. As used in a software development environment, the development, function correctness tests, and error analysis can be executed together in parallel. To use the diagnostic-based system  for both development and function correctness tests (e.g., unit and verification tests and sandbox performance tests), the side effects of parallel execution should be reduced when performance tests are executed. The performance tests may be based on cleanroom or sandbox methodologies. The cleanroom methodology exclusively reserves an environment (e.g., a server) for performance measurements. The cleanroom methodology may provide absolute values regarding, for example, response times and overall performance results. The sandbox methodology allows parallel execution of activities and excludes activities that may have a negative influence on the execution. However, the sandbox methodology delivers relative results based on approximate comparisons of the performance results of different runs.","In an example using the cleanroom methodology for performance tests, cleanroom performance measurements are carried out by deactivation of all other activities in the diagnostic-based system  with the exception of performance runs. With the diagnostic rule engine module , rules may be defined to automatically execute functionalities for establishing an environment for cleanroom performance measurements. In one example, these functionalities may relate to the deactivation of performance degrading methods in a system. Here, all active users are informed about the performance measurements and automatically logged out. Subsequent logons to the system are prohibited for the duration of the measurement. All performance degrading tools (e.g., error analysis methods and planned jobs for the performance runs) are deactivated.","In another example, the functionalities relate to the deactivation of performance degrading methods on the ABAP application server. Here, all active users on that affected ABAP application server in a system of application servers are informed about the performance measurement runs and automatically logged out. Similarly, subsequent logons to the ABAP application server are prohibited for the duration of the measurement. All performance degrading tools on this ABAP application server are deactivated. The requests addressed to this ABAP application server are rerouted (e.g., by way of a load balancing infrastructure) to other application servers. The performance degrading tools can be deactivated temporarily (e.g., for a period to take the performance measurements), with the server load balancing groups removed.","In an example using the sandbox methodology, a more granular deactivation of performance degrading tools is used when compared with the cleanroom methodology. In an example where functionalities relate to the deactivation of performance degrading methods for a dedicated user account (e.g., a client and user), all sessions of the dedicated users in the system are informed about the performance measurements, and all performance degrading tools for the associated user account are deactivated. Furthermore, the deactivation of performance degrading tools can be applied to all derived sessions (e.g., remote function calls or HyperText Transfer Protocol (HTTP) calls) that originated from the same active session. In another example where functionalities relate to the deactivation of performance degrading methods for dedicated requests, all performance degrading tools during the performance runs for the dedicated request are deactivated. Again, the deactivation of performance degrading tools can be applied to all derived sessions that originated from the same active session.","In both cleanroom and sandbox methodologies, the diagnostic rule engine module  can receive rule documents  and  that include rules that specify the deactivation of all diagnostic tools - as soon as a request arrives in preparation for performance analysis. For example, if a request is received on the respective ABAP application server independently of the underlying communication layer (e.g., Remote Function Call (RFC), HTTP, and batch), the diagnostic rule engine module  checks the present status of the diagnostic tools - for this request. If any of the diagnostic tools - is active before the request is executed by the engine (compiler), the diagnostic tool , , , , or  is temporarily deactivated and the present state of the diagnostic tool , , , , or  is preserved (stacked). As soon the resource (e.g., work process) is not in use by that request, the previous preserved state is re-established for the processing of subsequent requests. If the diagnostic tools - are activated for a user or a request before the request is executed by the engine, then these diagnostic tools - are deactivated for this run. If further activities (e.g., asynchronous events) are triggered during a request, the present status of the diagnosis is passed on to subsequent actions. The reduction of possibly conflicting influences may, for example, facilitate the execution of different activities (e.g., development, tests, and performance analysis runs).","It should also be appreciated that one or more diagnostic tools - may be activated with a performance analysis tool. For example, the diagnostic tools - may be activated when the performance analysis tool is itself analyzed. Here, rules in the rule document - may enable the co-existence of several diagnostic tools -. As discussed above, it should also be noted that performance-degrading diagnostic activities (e.g., tracing, logging, debugging, and memory analysis) should not be activated for a dedicated measurements run. Here, the ABAP application server can be adapted to deactivate the diagnostic tools - to avoid, for example, any unintended negative influence on the performance run.","Still referring to , the diagnostic-based system  may also be embodied within a virtual machine layer, in accordance with alternate embodiment. In a virtual machine layer, many programming languages, such as ABAP, provide functionalities for activation of debugger  (e.g., BREAK-POINT), activation of application log  (e.g., LOG-POINT), and also activating application programming interfaces for activating performance measurements. Accordingly, the functionalities may be defined in rules accordingly. Additionally, when an error occurs, in addition to processing and recording the dedicated error (e.g., short dumps in ABAP due to memory shortage as defined in, for example, CALL_FUNCTION_BLOB_NO_MEMORY, CALL_FUNCTION_TABLE_NO_MEMORY), additional memory analysis trace (e.g., top ten memory areas, internal tables, or the maintained memory size of sessions) can also be provided. The rules can also define the conditions of when and how this additional information can be provided.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 6","b":["600","600","520","521","522","600","520","601","602","603","604","605","521","610","610","522","612"]},"In the process-based system , the various components - and their operational behaviors can be automatically managed by the process rule engine module . In particular, the process rule engine module  can control process operations, software layers, layers, and schedulers, as defined by the rules in the rule documents -. For example, many of these services (e.g. batch processes ) can be disabled or enabled. In another example, resources (e.g., memory available for the user session or application server) can also be reduced or extended.","With the process rule engine module , a set of rule documents - in the form of templates can be applied for particular situations. For example, specific rule documents - related to customer support can be applied to support certain capabilities in a customer system to obtain, for example, additional information (e.g., activation of health checks of components - under certain circumstances). Additionally, the process rule engine module  also allows the deployment of rule documents - in a collection of computing devices within a system landscape to uniformly activate or deactivate certain capabilities.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 7","b":["700","700","520","521","522","600"]},"Here, the interface layer  can address or include several interfaces. For example, as depicted in , the interface layer  includes a diagnostic interface  and a runlevel interface . Accordingly, the component layer  includes components , , , and  that map to the underlying diagnostic interface  and the runlevel interface . For example, the component layer  includes application log  and memory analyzer  that can interface with the diagnostic interface . Additionally, the component layer  also includes work process  and batch scheduler  that interface with the runlevel interface .","In this embodiment, the rule-based layer  may include a global rule engine module  that is adapted to execute all the functionalities associated with different rule-based engines, such as a diagnostic rule engine module and a runlevel rule engine module. Accordingly, the rules included in the rule documents - can define functionalities provided by different layers through different application programming interfaces, such as the diagnostic interface  and the runlevel interface .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 8","b":["812","800","800","520","521","522","800"]},"In this embodiment, the component layer  includes different types of servers, such as an ABAP application server , a J2EE application server , an Internet information server , and an Apache server . Here, the collection of application servers - within a system landscape can be controlled by a single rule-based engine, such as the system landscape rule engine module . Each server , , , or  can delegate its global functionalities to a server interface  included in the interface layer , and in turn, these functionalities are made available to the system landscape rule engine module . With the hierarchical layering -, the system landscape rule engine module  can control application servers - and also indirectly influence the behavior of software processes. For example, rules included in the rule documents - can specify the deactivation of one or more application servers - when no activities on the application servers - take place or start one or more additional application servers - with an increase of load of certain application servers -.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 9","b":["900","900"]},"The machine is capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine. Further, while only a single machine is illustrated, the term \u201cmachine\u201d shall also be taken to include any collection of machines that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein.","The example of the computing device  includes a processor  (e.g., a central processing unit (CPU), a microprocessor, a graphics processing unit (GPU), or both), a main memory  (e.g., random access memory (a type of volatile memory)), and static memory  (e.g., static random access memory (a type of volatile memory)), which communicate with each other via bus . The computing device  may further include video display unit  (e.g., a plasma display, a liquid crystal display (LCD) or a cathode ray tube (CRT)). The computing device  also includes an alphanumeric input device  (e.g., a keyboard), a user interface (UI) navigation device  (e.g., a mouse), a disk drive unit , a signal generation device  (e.g., a speaker), and a network interface device .","The disk drive unit  (a type of non-volatile memory storage) includes a machine-readable medium  on which is stored one or more sets of data structures and instructions  (e.g., software) embodying or utilized by any one or more of the methodologies or functions described herein. The data structures and instructions  may also reside, completely or at least partially, within the main memory  and\/or within the processor  during execution thereof by computing device , with the main memory  and processor  also constituting machine-readable, tangible media.","The data structures and instructions  may further be transmitted or received over a computer network  via network interface device  utilizing any one of a number of well-known transfer protocols (e.g., HTTP).","Certain embodiments are described herein as including logic or a number of components, modules, or mechanisms. Modules may constitute either software modules (e.g., code embodied on a machine-readable medium or in a transmission signal) or hardware modules. A hardware module is a tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments, one or more computer systems (e.g., the computing device ) or one or more hardware modules of a computer system (e.g., a processor  or a group of processors) may be configured by software (e.g., an application or application portion) as a hardware module that operates to perform certain operations as described herein.","In various embodiments, a hardware module may be implemented mechanically or electronically. For example, a hardware module may comprise dedicated circuitry or logic that is permanently configured (e.g., as a special-purpose processor, such as a field programmable gate array (FPGA) or an application-specific integrated circuit (ASIC)) to perform certain operations. A hardware module may also comprise programmable logic or circuitry (e.g., as encompassed within a processor  or other programmable processor) that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically, in dedicated and permanently configured circuitry, or in temporarily configured circuitry (e.g., configured by software) may be driven by cost and time considerations.","Accordingly, the term \u201chardware module\u201d should be understood to encompass a tangible entity, be that an entity that is physically constructed, permanently configured (e.g., hardwired) or temporarily configured (e.g., programmed) to operate in a certain manner and\/or to perform certain operations described herein. Considering embodiments in which hardware modules are temporarily configured (e.g., programmed), each of the hardware modules need not be configured or instantiated at any one instance in time. For example, where the hardware modules comprise a processor  (e.g., a general-purpose processor) configured using software, the processor  may be configured as respective different hardware modules at different times. Software may accordingly configure the processor , for example, to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.","Modules can provide information to, and receive information from, other hardware modules. For example, the described hardware modules may be regarded as being communicatively coupled. Where multiples of such hardware modules exist contemporaneously, communications may be achieved through signal transmission (e.g., over appropriate circuits and buses) that connect the hardware modules. In embodiments in which multiple hardware modules are configured or instantiated at different times, communications between such hardware modules may be achieved, for example, through the storage and retrieval of information in memory structures to which the multiple hardware modules have access. For example, one hardware module may perform an operation, and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware module may then, at a later time, access the memory device to retrieve and process the stored output. Hardware modules may also initiate communications with input or output devices, and can operate on a resource (e.g., a collection of information).","The various operations of example methods described herein may be performed, at least partially, by one or more processors  that are temporarily configured (e.g., by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors  may constitute processor-implemented modules that operate to perform one or more operations or functions. The modules referred to herein may, in some example embodiments, comprise processor-implemented modules.","Similarly, the methods described herein may be at least partially processor-implemented. For example, at least some of the operations of a method may be performed by one or more processors  or processor-implemented modules. The performance of certain of the operations may be distributed among the one or more processors , not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the processor or processors  may be located in a single location (e.g., within a home environment, an office environment or as a server farm), while in other embodiments the processors  may be distributed across a number of locations.","While the embodiment(s) is (are) described with reference to various implementations and exploitations, it will be understood that these embodiments are illustrative and that the scope of the embodiments) is not limited to them. In general, techniques for processing rules may be implemented with facilities consistent with any hardware system(s) defined herein. Many variations, modifications, additions, and improvements are possible.","Plural instances may be provided for components, operations or structures described herein as a single instance. Finally, boundaries between various components, operations, and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the embodiment(s). In general, structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements fall within the scope of the embodiment(s)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The present disclosure is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
