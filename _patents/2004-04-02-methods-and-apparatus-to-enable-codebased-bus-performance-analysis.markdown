---
title: Methods and apparatus to enable code-based bus performance analysis
abstract: Methods and apparatus to enable code-based bus performance analysis are disclosed. In one example, a method identifies a bus transaction request with a virtual machine monitor and stores a record associated with the bus transaction request in a virtual machine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07290178&OS=07290178&RS=07290178
owner: Intel Corporation
number: 07290178
owner_city: Santa Clara
owner_country: US
publication_date: 20040402
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["The present disclosure is directed generally to computer systems and, more particularly, to methods and apparatus to enable code-based bus performance analysis.","Bus performance analysis such as transaction turn-around times and performance tuning provide useful mechanisms for debugging device drivers that initiate transactions with hardware devices via a bus. Current bus performance analysis techniques require the use of a hardware bus analyzer inserted into the bus under analysis.","Hardware bus analyzers have many shortcomings, such as cost, compatibility, scalability, and capability. For example, the cost of a typical hardware bus analyzer may exceed many thousands of dollars. When analyzing a peripheral component interconnect (PCI) bus, an industry standard architecture (ISA) hardware bus analyzer is not compatible with the PCI bus and therefore a PCI hardware bus analyzer is required. The hardware bus analyzer solution has poor scalability because it requires a one-to-one relationship between the hardware to be analyzed (i.e., the bus) and the number of hardware bus analyzers required. For example, to test a software or firmware device driver that initiates more than one transaction with more than one bus requires more than one hardware bus analyzer. Additionally, the capability of hardware bus analyzers is also a drawback. For example, the trace capability of a typical hardware bus analyzer is limited in size and functionality by the hardware bus analyzer, which typically has only one megabyte of trace capability.","In general, the methods and apparatus disclosed herein may be used to enable code-based bus performance analysis by capturing bus transaction activity via software and\/or firmware. More specifically, some or all of the functionality of a hardware bus analyzer may be performed by software and\/or firmware in a more cost-efficient, flexible, scalable, and productive fashion.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":["100","100","102","104","106"]},"The bus  and the processor  may be similar or identical to the bus  and the processor , respectively, discussed in further detail below in conjunction with . The peripheral hardware  is hardware that is not part of the elementary computer system and may be implemented as a disk controller and mass storage (e.g., the disk controller and mass storage  of ), an adapter card (e.g., the adapter card  of ), an input device (e.g., the input device  of ), a network adapter (e.g., the network adapter  of ), a removable storage device drive (e.g., the removable storage device drive  of ), etc.","The processor  may include one or more of any type of well-known processor, such as a processor from the Intel\u00ae family of microprocessors having virtualization hardware, which allows for virtualization of hardware for a computer system, which may be implemented by a virtual machine monitor (VMM)  having a first application programming interface (API)  and a second API  that are communicatively coupled to a virtual machine (VM)  and a VM  via a plurality of communication links , , , and .","The VMM  may be a firmware or a software component that is configured to enable and support a series of virtual environments or VMs (e.g., the VM  and the VM ). The VMM  ensures that the operation of each of the plurality of VMs does not interrupt the operation of any other VM. In particular, the VMM  takes control of the code execution system  when one of the plurality of VMs attempts to perform an operation that may affect other VMs and\/or the processor .","The API  and the API  (i.e., a plurality of APIs) serve as a well-defined or published interface between the VMM  and the VM  and the VM  that make up a plurality of VMs. The plurality of VMs operates like a complete physical machine that can run instances of different and\/or the same operating system (OS). For example, a first VM may include an OS such as the Microsoft\u00ae Windows\u00ae XP OS, a second VM may include an OS such as the Microsoft\u00ae Windows\u00ae 95 OS, and a third VM may include an OS such as the Linux OS. Typically, a crash of an OS in one of the plurality of VMs may not affect an OS executing in a different VM because the VMs have isolated resources. For example, the Microsoft\u00ae Windows\u00ae XP OS in the first VM and the Linux OS in the third VM may not be affected by a crash in the Microsoft\u00ae Windows\u00ae 95 OS in the second VM. The OS  may be any of the above mentioned OSs, such as a Microsoft\u00ae Windows\u00ae OS, UNIX\u00ae OS, Linux OS, etc.","The VM  includes an OS  having a plurality of applications and services  and a plurality of device drivers  that include a code library . The VM  includes a transaction profiler  that is communicatively coupled to the bus  via a write communication link  and a read communication link . Similarly, the VMM  is communicatively coupled to the bus  via a communication link .","The applications and services  may include any application or service running on the OS . For example, the applications and services  may include programs such as Microsoft\u00ae Word\u2122, IBM\u00ae, Lotus Notes\u00ae, etc. that include instructions compiled, interpreted, or assembled from source code written in a computer programming language such as C\/C++, Java, .NET, practical extraction and reporting language (Perl), assembly language, or any other suitable programming language.","The device drivers  may be software or firmware programs that enable the use of a device (e.g., the devices , , , , and  of ). For example, the device drivers  may include instructions compiled or assembled from source code written in a computer programming language such as C\/C++, assembly language, or any other suitable programming language.","The code library  may be software or firmware that enables the device drivers  to communicate with the VMM . For example, the code library  may include a function, a macro, etc. capable of generating the communication link  and a function, macro, call-back function, etc. capable of receiving data through the communication link . While the device drivers  are shown as using the code library  to communicate with the VMM , one of ordinary skill in the art will readily appreciate that communication between the device drivers  and the VMM  may be accomplished without the use of the code library . For example, instructions embedded directly in the code of the device drivers  may enable communication with the VMM .","The transaction profiler  may be one or more software or firmware programs that are capable of communicating directly with the bus . For example, the transaction profiler  may be an application, a service, a device driver, etc. that executes with or without the assistance of an OS. The transaction profiler  reads and writes to one or more buses and stores logging information associated with the bus activity.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 6","FIG. 6","FIG. 6"],"b":["200","200","104","104","200","104","104","200","202","202","606","104","108","114","116","104","100","104","626","624"]},"After initialization of the system (block ), the processor  launches the VMM  and one or more VMs (e.g., the VM  and VM ) (block ). The VMM , which is executing in the processor , virtualizes and boots up the VMs to partition the resources of the code execution system . Each of the plurality of the VMs operates as if the all resources of the code execution system  are at the disposal of the VM and the VMM  coordinates the usage of the resources.","After launching the VMM  and one or more VMs (block ), the processor  determines if a start trap command has been requested from a requester (e.g., the code library  of the VM ) (block ). The processor  may implement the start trap command as a function, a macro, an inline instruction, an interrupt based instruction, a flag based instruction, or any other programming construct. For example, the start trap command may be implemented as a start trap function including a port address parameter that specifies a port address or a range of port addresses to be used as criteria for trapping. The start trap function may be part of the API  of the VMM . When invoked by the requester (e.g., the code library  of the VM  or any other suitable requester), the start trap function may generate the communication link  and information about the requester (e.g., a callback function, an identifier of the VM, etc.). The information about the requester, which may be used for communicating with the requester, may be stored by the VMM . If the start trap command has not been requested from the requester (e.g., the code library  of the VM ) (block ), the processor  performs system operations (block ). The system operations may perform normal OS operations until a function call, an interrupt based instruction, a flag based instruction, etc. is invoked, causing the processor  to determine if the start trap command has been requested from the requester (e.g., the VM ) (block ).","On the other hand, if the start trap command has been requested from the requester (e.g., the code library  of the VM ) (block ), the processor  generates a time stamp (e.g., a time stamp A) (block ). The time stamp may be generated by the transaction profiler , the VMM , etc. and is representative of a time (e.g., a current time) at which an event occurs in a program. For example, the time stamp may be generated by the processor  based on a hardware timer. In particular, the time stamp may be generated by calling a function defined by an API specified by a programming language. For example, calling the C language function time ( ) returns the current time as a time stamp.","After generating the time stamp (block ), the processor  invokes an analyze performance process (block ). The analyze performance process performs code-based bus performance analysis on the bus . The analyze performance process is described below in greater detail in conjunction with .","After returning from execution of the analyze performance process (block ), the processor  generates a time stamp (e.g., a time stamp A) (block ) and then returns control to block . The time stamp A may be generated by the transaction profiler , the VMM , etc. and may implement a method similar or identical to the time stamp generation method described above in conjunction with block .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 3","FIG. 1","FIG. 2","FIG. 3","FIG. 1"],"b":["300","102","300","300","108","104","300","108","300","302","108"]},"After activating the trap on the registered transaction (block ), the VMM  determines if a stop trap command has been requested from a requester (e.g., the code library  of the VM ) (block ). The VMM  may implement the stop trap command as a function, a macro, an inline instruction, an interrupt based instruction, a flag based instruction, or any other programming construct. For example, the stop trap command may be implemented as a stop trap function including a port address parameter that specifies a port address or a range of port addresses no longer to be used as criteria for trapping. The stop trap function may be part of the API  of the VMM  and, when invoked by the requester (e.g., the code library  of the VM  or any other suitable requester), may generate the communication link . If the stop trap command has been requested from the requester (e.g., the code library  of the VM ) (block ), the analyze performance process  ends and\/or returns control to any calling routine(s) (block ).","On the other hand, if the stop trap command has not been requested from the requester (e.g., the code library  of the VM ) (block ), the analyze performance process  determines if the VMM  has trapped on the registered transaction from a requester (i.e., has received a transaction to be monitored) (block ). The received transaction is a transaction that is transmitted from the requester (e.g., the VM ) to the API  of the VMM  via the communication link . The VMM  may compare the port address of the received transaction from the VM  to the trap variable for a match, and if a match occurs, the VMM  may determine that that the registered transaction has been trapped.","If the VMM  has trapped on a registered transaction (block ), the VMM  redirects or proxies the registered transaction to the transaction profiler  (block ) and invokes a profile trapped transaction process (block ). The registered transaction is redirected by the VMM  to the transaction profiler  via the communication link  (block ) to allow the transaction profiler  to process a trapped transaction (i.e., the received transaction from the VM ). Additionally or alternatively, the redirecting and invocation of the profile trapped transaction process may be implemented as a single activity. The profile trapped transaction process profiles and records information about the execution of the trapped transaction and is described below in greater detail in conjunction with .","After returning from execution of the profile trapped transaction process (block ), the VMM  transmits the received data (i.e., data that has been received on the bus ) to the requester (block ) and returns control to block . The transmission of the received data may be implemented as a function call, a macro call, an inline instruction, an interrupt based instruction, a flag based instruction, or any other programming construct. The function that is called may be, for example, a call-back function in the code library  and\/or the device drivers  of the VM  and the function call may generate the communication link .","On the other hand, if the VMM  has not trapped on the registered transaction from the requester (block ), the VMM  determines if an extract transaction data command has been requested (block ). The extract transaction data command may be implemented as a function call, a macro, an inline instruction, an interrupt based instruction, a flag based instruction, or any other programming construct. For example, the extract transaction data command may be implemented as an extract transaction data function including a port address parameter that specifies a port address or a range of port addresses from which to extract the data. The extract transaction data function is invoked by a requester (e.g., the code library ) and information about the requester (e.g., a callback function, an identifier of the VM, etc.), which may be used for communicating with the requester, may be stored by the VMM . The requester may be the same as or different from the requester. If the extract transaction data command has not been requested (block ), the VMM  returns control to block .","On the other hand, if the extract transaction data command has been requested (block ), the VMM  transmits the received data to the requester (block ) and then returns control to block . The received data may be requested by a requester (e.g., the requester) via the communication link  (block ), then the VMM  may request the data from the transaction profiler  via the communication link , then the data may be transmitted from the transaction profiler  to the VMM  via the communication link , and then further from the VMM  to the requester (e.g., the VM ) via the communication link  (block ).",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 4","FIG. 3","FIGS. 2 and 3","FIG. 4","FIG. 1"],"b":["400","312","400","400","134","102","102","102","102","134","400","108","402","134","120"]},"After receiving a trapped transaction (block ), the transaction profiler  generates a time stamp (i.e., a time stamp B) that is associated with a time before the processing of the trapped transaction (block ). The time stamp B may be generated using a method similar or identical to the time stamp generation method described above in conjunction with block  of .","After generating the time stamp B (block ), the transaction profiler  inserts the trapped transaction onto the target bus (e.g., the bus ) (block ). The transaction profiler  may insert the trapped transaction onto the target bus (e.g., via the write communication link ) without transmitting the trapped transaction to the VMM  to avoid temporal latencies associated with the VMM .","After inserting the trapped transaction onto the target bus (block ), the transaction profiler  receives data from the target bus (block ). For example, the transaction profiler  may wait until data on the target bus is received on the requested port address (e.g., via the read communication link ). Additionally, a timeout period may be implemented to stop waiting for the data if the data is not received.","After receiving the data on the target bus (block ), the transaction profiler  generates a time stamp (i.e., a time stamp B) that is associated with a time after the processing of the trapped transaction (block ). The time stamp B may be generated using a method similar or identical to the time stamp generation method described above in conjunction with block  of .","After generating the time stamp B (block ), the transaction profiler  stores a record of the trapped transaction (block ). The record is information associated with the trapped transaction and may include the port address, the time stamp B, the time stamp B, historical data, such as if data was returned on the target bus, etc. The record may be stored in one or more database files (e.g., a Microsoft Access database, an IBM DB2 database, database products from companies such as Oracle, Sybase, and Computer Associates, etc.), structures in memory (e.g., the system memory  of ), and\/or any other suitable data storage mechanism or structure.","After storing a record of the trapped transaction (block ), the transaction profiler  transmits the received data to the VMM  (block ) and the process  ends and\/or returns control to any calling routine(s) (block ). For example, the received data may be transmitted via the communication link  to the API  and, as discussed in further detail above in conjunction with block  of , the API  may transmit the received data to the requester (e.g., the VM ) via the communication link .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5","FIG. 2"],"b":["500","500","502","504","506","508","502","508"]},"The start trap time stamp  is associated with the time at which a start trap has been received (e.g., the time stamp A of block  of ). The stop trap time stamp  is associated with the time at which a stop trap has been received (e.g., the time stamp A of block  of ). The start trap time stamp  and the stop trap time stamp  may be used to calculate the amount of time that occurs in executing one or more instructions. For example, the example pseudo code below shows a function definition called exampleFunction including a start trap function call (i.e., startTrap) and a stop trap function call (i.e., stopTrap) with a device driver that is being tested (i.e., deviceDriver) sequentially interposed between the two function calls.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void exampleFunction (void)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"startTrap (portAddress);"]},{"entry":[{},"deviceDriver( );"]},{"entry":[{},"stopTrap (portAddress);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Upon invocation of exampleFunction, the startTrap function is invoked, which results in the generation of the start trap time stamp . After invocation of the startTrap function, the deviceDriver function is invoked. The deviceDriver function may issue, for example, a write request to the port address being monitored (i.e., the value of the portAddress variable). The transaction profiler  receives the write request from the VMM  and indirectly from the VM  as described above in conjunction with block  of . The transaction profiler  generates the time stamp B (i.e., the before transaction time stamp ) as described above in conjunction with block  of  and generates the time stamp B (i.e., the after transaction time stamp ) as described above in conjunction with block  of .","Upon completion of the deviceDriver function, the stopTrap function is invoked, which results in the generation of the stop trap time stamp . The start trap time stamp  and the stop trap time stamp  may be used by a human or a machine to calculate the duration of the execution time of the deviceDriver function. The before transaction time stamp  and the after transaction time stamp  may also be used by a human or a machine to calculate the duration of a first transaction on the bus . Additional before and after transaction time stamps may be processed in a similar manner to the before transaction time stamp  and the after transaction time stamp  and may be used for calculation of the duration of additional transactions requested by the deviceDriver function.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 6","b":["600","600","602","604","606","608","610","602","614","614","616","620","624","626","600","630","632","636"]},"The example processor system  may be implemented using, for example, a server, a conventional desktop personal computer, a notebook computer, a workstation, or any other computing device. The processor  may be any type of processing unit, and may be similar or identical to the processor  of .","The memories , , and , which form some or all of the system memory , may be any suitable memory devices and may be sized to fit the storage demands of the example processor system . The RAM  may be implemented using a dynamic random access memory (DRAM), a static random access memory (SRAM), or any other suitable memory device. The flash memory  is a low-cost, high-density, high-speed architecture having low power consumption and high reliability. The flash memory  is a non-volatile memory that is accessed and erased on a block-by-block basis.","The input device  may be implemented using a keyboard, a mouse, a touch screen, a track pad, or any other device that enables a user to provide information to the processor . The mass storage device  may be, for example, a conventional hard drive or any other magnetic or optical media that is readable by the processor . For example, the mass storage device  may be a hard drive having storage capacity on the order of hundreds of megabytes to tens or hundreds of gigabytes.","The removable storage device drive  may be, for example, an optical drive, such as a CD-R drive, a CD-RW drive, a DVD drive, or any other optical drive. It may alternatively be, for example, a magnetic or solid state media drive. The removable storage media  is complementary to the removable storage device drive , inasmuch as the media  is selected to operate with the removable storage device drive . For example, if the removable storage device drive  is an optical drive, the removable storage media  may be a CD-R disk, a CD-RW disk, a DVD disk, or any other suitable optical disk. On the other hand, if the removable storage device drive  is a magnetic media device, the removable storage media  may be, for example, a diskette or any other suitable magnetic storage media.","The adapter card  may be any standard, commercially available adapter card that is used to interface the processor  to the display device . The display device  may be, for example, a liquid crystal display (LCD) monitor, a cathode ray tube (CRT) monitor, or any other suitable device that acts as an interface between the processor  and a user via the adapter card . The adapter card  is any device used to interface the display device  to the bus . Such cards are presently commercially available from, for example, Creative Labs and other like vendors.","The network adapter  provides network connectivity between the processor  and a network , which may be a local area network (LAN), a wide area network (WAN), the Internet, public switched telephone network (PSTN), or any other suitable network. The network  may include one or more network nodes, such as a network node .","The network node  may be implemented using a server, a personal computer (PC), a personal digital assistant (PDA), an Internet appliance, a cellular telephone, or any other computing device. In an alternative example processor system, the processor  may be operatively coupled to the network node  without the assistance of the network , such as via a serial adapter, a parallel adapter, the network adapter  operatively coupled to a cross-over Ethernet cable, etc.","As shown in , , and , the processes , , and  may be implemented using one or more software programs or sets of machine readable instructions that are stored on a machine readable medium (e.g., the system memory  and\/or the mass storage device  of ) and executed by one or more processors (e.g., the processor  of ). However, some or all of the blocks of the processes , , and  may be performed manually and\/or by some other device. Additionally, although the processes , , and  are described with reference to the flow diagram illustrated in , , and , persons of ordinary skill in the art will readily appreciate that many other methods of performing the processes , , and  may be used instead. For example, the order of many of the blocks may be altered, the operation of one or more blocks may be changed, blocks may be combined, and\/or blocks may be eliminated.","Although certain apparatus, methods, and articles of manufacture have been described herein, the scope of coverage of this patent is not limited thereto. On the contrary, this patent covers every apparatus, method and article of manufacture fairly falling within the scope of the appended claims either literally or under the doctrine of equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 5","FIG. 2"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
