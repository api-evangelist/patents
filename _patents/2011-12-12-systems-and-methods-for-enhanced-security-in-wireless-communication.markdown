---
title: Systems and methods for enhanced security in wireless communication
abstract: A communication system having a policy server coupled to a communications network for managing secure communication with and among end instruments (EI). The EI comprises a memory, and a processor coupled to the memory with processor-executable instructions, including instructions for an operating system kernel; and instructions for a protection core that monitors operations of the operating system kernel in accordance with a security policy for the EI. Security policies can intercept calls to an operating system kernel and for each call, determining whether the call is allowed under the security policy(ies). Policies are stored in a policy library and transmitted to an EI over a wireless communication network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09514300&OS=09514300&RS=09514300
owner: Redwall Technologies, LLC
number: 09514300
owner_city: Beavercreek
owner_country: US
publication_date: 20111212
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of priority to U.S. Provisional Application No. 61\/445,319 filed Feb. 22, 2011, the entire contents of which is incorporated herein by reference.","This invention relates generally to wireless communications. More particularly this invention relates to a method and apparatus for implementation of a secure wireless communication device and an associated network.","Communication using wireless communication devices, such as cellular phones, is not inherently secure. There are multiple ways that such communication can be compromised. Various approaches used currently to provide secure communication in wireless communication devices do not provide the security necessary for many government and commercial users.","In one embodiment, a communication system comprises a policy server coupled to a communications network, and an end instrument (EI) configured to communicate with the server over the communications network, wherein the EI comprises a memory, and a processor coupled to the memory and configured with processor-executable instructions, including instructions for an operating system kernel; and instructions for a protection core that monitors operations of the operating system kernel in accordance with a security policy.","In embodiments, the policy server comprises a memory, and a processor coupled to the memory and configured with processor-executable instructions, including instructions to store a plurality of security policies for one or more EIs in a security policy library.","In another embodiment, a method of operating an End Instrument (EI) in a first security mode defined by a first security policy comprises intercepting calls to an operating system kernel; for each call, determining whether the call is allowed under the first security policy; and passing calls to the operating system kernel only when allowed by the first security policy.","In yet another embodiment, a method of managing the security posture of a plurality of End Instruments (EIs) over a wireless communication network comprises storing a plurality of security policies in a security policy library, and transmitting all or a portion of at least one security policy to at least one EI over the wireless communication network.","The various embodiments will be described in detail with reference to the accompanying drawings. Wherever possible, the same reference numbers will be used throughout the drawings to refer to the same or like parts. References made to particular examples and implementations are for illustrative purposes, and are not intended to limit the scope of the invention or the claims.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","102","1","102","2","102","104","100","106","104","106","110","100","108"],"i":"n"},"The policy server , which typically includes a processor coupled to a memory and may also include a number of connector ports coupled to the processor for establishing data connections the network , may in accordance with various aspects of the invention store policies , commands  and\/or data for each of the respective EI's -, -, . . . , -, as is described in further detail below.","The EI's -, -, . . . , -typically include a processor coupled to a memory and may further include an antenna and\/or wireless transceiver for sending and receiving electromagnetic radiation over wireless link . In some implementations, the transceiver and portions of the processor and memory used for cellular telephone communications are collectively referred to as the air interface since it provides a data interface via a wireless data link . The EI's typically also include a display , which may be a touchscreen interface display, and may include interface button(s) , such as a keypad or miniature keyboard and\/or menu selection buttons for receiving user inputs.","Each EI -, -, . . . , -may store in memory a set of policies and\/or data (Pa-a\u2032, Pb-b\u2032, . . . , Pc-c\u2032), which may or may not be distinct from the policies and\/or data stored on other EIs. Each EI -, -, . . . , -may also be configured to continuously interpret and process commands received from the policy server , which may include commands to update one or more policies.","The precise manner in which the respective EI's -, -, . . . , -and the at least one policy server  are connected via wireless network  is not critical to the various embodiments. For example, the EI  may be a tactical radio using a proprietary network interface in some embodiments, or it may be a smartphone using 3G protocols in other embodiments. Similarly, the policy server  may be connected to the Internet, or to a dedicated satellite network. In some embodiments, it may not be required for the EI  and policy server  to communicate at all after an initial provisioning process, and the initial provisioning process can be performed through a proxy or physical transfer.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2","FIG. 2"],"b":["102","102","102","202","102"]},"Daemons and system processes  are software processes which may run in the background, and the user and administrator may or may not be aware of them. They may perform maintenance tasks, or provide internal and external communication conduits between processes and devices. In a system running the GOOGLE\u00ae ANDROID\u2122 mobile operating system, these processes run inside the operating system, and possibly inside the kernel . They often run with elevated privileges over a user's app .","The EI  may further include a mobile operating system , which in one embodiment may be, but is not limited to, the GOOGLE\u00ae ANDROID\u2122 mobile operating system. In this context, the ANDROID\u2122 operating system refers to the ANDROID\u2122 native application framework, libraries, the Dalvik virtual machine, and any other elements of the ANDROID\u2122 runtime environment. The mobile operating system  may include a kernel , which may be a Linux kernel, such as used in the ANDROID\u2122 operating system.","The memory  may a volatile or non-volatile memory, and may be RAM or Flash memory storage, or any other permanent or temporary storage. In various embodiments, the memory  may include any computer-readable medium for storing data, such as security policies, and\/or executable programs (e.g., software) for execution by a processor, including application processor  and\/or baseband processor , described below.","The application processor  may interpret and execute program code, including but not limited to user applications (e.g., apps ), the mobile operating system , including the kernel , daemons and processes , device drivers , etc. The application  may also interpret and execute program code for the protection core  as described in further detail below.","The baseband stack  is the element of the EI  responsible for source coding, channel coding, modulation (as well as the inverses of these), channel decoding and demodulation. The baseband processor  interprets and executes baseband code, including but not limited to code corresponding to the baseband stack . The baseband processor  may in some embodiments be a set of physical or virtual processors, and be single or multi-cored.","The devices  may include any peripherals or physical interfaces, such as network interfaces, microphones, speakers, accelerometers, motors, etc., or the associated chipsets to communicate to any such devices. The device drivers  may be software elements that the kernel  uses to communicate to devices .","In various embodiments, the EI  includes the protection core , which may be implemented in software, and which conceptually constitutes a thin layer surrounding the operating system kernel . The protection core  includes a security monitor that performs various operations, which may include monitoring for potentially dangerous system behavior and\/or continually checking system integrity. Either or both of these operations may be performed pursuant to a security policy.","In various embodiments, the protection core  may surround the operating system kernel  to provide these protections on the applications processor  side of the EI . However, in embodiments the protection core  or a separate protection core process may operate on the baseband processor  side of the EI . Where the EI  includes multiple protection core processes running on the application processor and baseband processor sides of the EI, the protection core processes may cross check and cross verify each side.","To provide strong separation between the protection core , the individual processes inside the operating system (e.g., Linux) kernel , and the mobile operating system environment  (e.g., ANDROID\u2122) itself, various embodiments may include modifications to the kernel  to support policy enforcement by the protection core  and enhanced memory management, which are described in further detail below.","In various embodiments, the EI  may include a protection core init subsystem , which may be implemented in software, and which may include processor-executable instructions to perform certain operations which may include communicating to the protection core  a security policy to enforce, and which may also participate in bringing up the protection core system during a policy activation. In addition to the subsystem itself, the protection core init subsystem  may provide an externally accessible Application Programming Interface (API). The mode switch API provides applications and processes, for example, a Mode Switch App, which may initiate a change from one security mode to another, i.e. to change which security policy or policies the protection core  is currently enforcing, in response to an input from a user or a policy server.","The protection core  may also include a protection core client subsystem  which may communicate with the policy server  to download policies, commands, and other data to the EI , and may also communicate with the protection core init subsystem  as required to process the incoming data and\/or to send data to the policy server , such as request data about the status of the EI .","In various embodiments, the security enhancements to the EI  described herein, including the protection core  and\/or modifications to the operating system kernel , may be implemented entirely in software (firmware), though it will be understood that at least some of these features could be implemented using hardware components, such as with a FPGA and\/or ASIC.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":["104","104","102","106","102","104","104","102","102","104","102","104","102"]},"As illustrated in , the policy server  may include several elements, including typical server elements and other elements and\/or subsystems that are used in implementing security enhancements according to the various embodiments. The policy server  includes at least one operating system, which may be a trusted Real-Time Operating System (RTOS) . The RTOS  may provide higher assurance and a smaller code base than an OS such as Linux. This trusted distinction, while not required for the architecture, may be beneficial because of the critical nature of the security posture of the policy server. For example, should an adversary control the policy server, they may gain access or control of a plurality of EIs . Since the policy server  may also incorporate third party tools and databases, however, it may additionally include a Linux or Unix operating system , which may run as a task within the RTOS . Many commercial RTOSs allow for such an arrangement.","The policy server  may also include a storage system , as is typical of server devices, and which may include a file system or database stored on media such as a magnetic or flash-based hard drive.","The policy server  may also include a number of server subsystems, including for example, a policy library , a protection core server , a policy editor , and\/or a protection core weaver tool . The policy library , which may be a part of the storage system , may store security policy data for all EIs, as well as any outstanding commands, warrants, updates, instructions, or other data for the EIs.","The protection core server subsystem  may perform functions including, but not limited to listening for connections from EIs, sending queries to the policy library  for any outstanding data and commands for the EI, and sending such data and commands to the respective EIs.","The policy editor  may provide a user interface for authorized administrators to communicate to the policy server  using a Web browser or other application though the protection core server subsystem  to create and edit security policies, and enter data and commands either as templates or for specific EIs.","The protection core weaver is a tool that may run on the policy server  or offline to create firmware images for EIs. This tool creates a record of all images (e.g., the entire package of policies and code bundled to an EI) that exist at any given time for each individual EI that is registered to the policy server . This record confirms the policies that have been served to each individual EI and allows the policy server to update the policies as needed based on the version that is on the policy server as compared to the image on a particular EI.","In some embodiments, an EI  utilizing the present security enhancements may be prevented from receiving firmware updates from certain sources (e.g., from Google), or use the same updates as phones without the present enhanced security solution. In some embodiments, the updates must either come from the policy server , or from a proprietary system adapted to the protocols as defined in the API documentation, such as where the policy server  and protection core client  use open standards. Updates may also travel virally from EI to EI if the applicable policy allows it.","In overview, embodiments of the invention include a protection core  which runs on an EI  to enforce at least one security policy on an operating system , and preferably the operating system kernel . Whereas many security solutions for mobile devices (EIs) focus on specific known threats, the protection core  in various embodiments may focus on how the EI should behave when not under attack or influence by an adversary, and may treat any other behavior as a security danger. For example, a conventional virus scanner may look for a specific file as being dangerous, but the iscore  may instead look for unusual behavior, such as the microphone suddenly turning on when the device is not in an active call. Even when the cause of the behavior is not known, the protection core  may still stop the threat. This approach may be more effective in stopping both known and unknown security threats than a more traditional scanning and analysis technique.","Embodiments may include multiple, distinct security policies, each defining which processes may access which system features and what the EI  should do when that policy is put into effect. In embodiments, only one security policy may be active at a time. This may enable the EI  to operate in multiple modes, each corresponding to a different security context. The EI  may switch modes in response to user input and\/or as directed by the system infrastructure (e.g., as directed by a server or another EI). Current \u201csecure\u201d mobile devices may provide a device that is highly-trusted, but so feature-limited the device is nearly useless. Sandboxing data and applications, while better than no security at all, is not as effective as providing temporal isolation (e.g., switching between security modes), such that applications in different security domains may not be permitted to run at the same time.","In embodiments, in the event of a violation of a security rule or suspicious application behavior is found, the protection core  may take appropriate \u201cgraduated\u201d action depending on the violation of security policy. Such graduated action may comprise disabling a particular device or shutting the EI down, for example. The protection core  may include a series of instructions for taking protective actions in a layered fashion that reflects the severity of the threat detected. For example, the protection core  may direct that the application be shut down as one limit and\/or the EI be shut down as another limit. Other actions may be for the EI to send an alert to the security policy server notifying of the violation and providing details of the violation including the application that triggered the violation, what actions were being attempted and what security countermeasures were triggered. Thereafter, the security server may analyze the information and communicate what, if any action should be taken by the smart phone.","Embodiments may further use \u201cdefense-in-depth\u201d techniques to provide multiple layers of security and to increase the effort required by an adversary to compromise the security of the communication system. Embodiments may use biomorphic techniques to modify the operation of a memory of the EI , and to modify the way files are delivered to different EIs. \u201cBiomorphics\u201d in this context refers to the adaptation of each individual EI over time such that each individual EI or component becomes probabilistically unique over time to create ideal diversity as a defensive or survival technique against security threats that would otherwise jeopardize a network of devices, all of which would be the same. Additionally, over a period of time each individual EI may be configured to deviate from the initial deployed configuration and the associated initial conditions of EI, the longer the individual EI is running or the more input the individual EI receives. This has the effect of making each individual EI unique, so that an attack on one EI only can compromise that one device, and even then only for a short window of time. Thus, even if a skilled attacker breaks the encryption or finds vulnerability on one EI, the attack may be unlikely to work on any other EIs, and the attack may not work again on the first EI.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 4A","b":["401","102","102","403","102","405","102","102","104","102","102","102","507","104","102","102","102","102","102","104"]},"In various embodiments, switching between modes and thus changing the security policy in effect of the multiple security policies stored on the EI  may be performed by the protection core init subsystem , described above. The protection core init  may inform the protection core  of a security policy change via a special system call available only to the protection core init subsystem .","In various embodiments, security policies may be used to determine what behaviors are allowed by the EI  in a particular mode. The security policies may achieve this by, for example, limiting the capabilities of the system, grouping capabilities into categories, and telling the EI what steps it must take when entering a mode.  schematically illustrates the structure of a policy set  according to one embodiment. The policy set  may include one or more policies . Each policy  may include one or more characteristics , and each characteristic may have one or more attributes . The policy set  may further include a set of commands  and data. Each command  may include one or more characteristics , and each characteristic may include one or more attributes . The commands  and data may or may not be specific to a particular policy  in the policy set .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 5","b":["102","408","402","402","102","504","102","408","502","504","102","408","408","104"]},"Commands  may be instructions to an EI  (or group of EIs) to take a specified action. There is no constraint on the definition of these actions other than what is defined and hence understood in the EI firmware. Commands  may include, but are not limited to, the following examples:","Update or install: Update the policies or firmware, installing any specified firmware images and files, or applying any updates.","Perform attestation: Verify a set of requested parameters with another entity, which may be the policy server, a network server, and\/or other EIs, as indicated in the specifics of the command. The verification may include proving the identity of the EI  through cryptographic mechanisms, verifying that a certain policy is in effect, forcing all internal integrity checks and reporting the results, and\/or simply offering the contents, digital signatures, or hashes of the requested data.","Change policy: An instruction to the EI  to switch from one mode to another, i.e. to change which policy or policy set is in effect.","Data wipe: Erase (e.g., zeroise) all data indicated by the specifics of the command. The data could be from memory, including from semi-permanent storage.","Data lock: Encrypt all data indicated by the specifics of the command using a specified key. The data could be from memory, including from permanent or semi-permanent storage, and the key may be given by the command, already on the EI, or chosen by the EI.","Lock: Prevent all further use of the EI until a specified action takes place. The action could be an authentication using specified credentials (e.g. a password or a certificate), a device reboot, attestation, or completion of any other policy command.","Enable\/disable propagation: Enable or disable the EI from sending commands and data to other EIs within range, and\/or order them to begin to do so or cease to do so. The propagation can be optional or mandatory. The propagation command may enable so-called viral updates, which allow for both distributing data and enforcing policy changes among a plurality of EIs.","Update key: Update a specified cryptographic key with data which may be specified by the command, or if no data is given, generate a new value for the specified key.","In embodiments, the EI  may contain files, which may be stored in a memory, and which may be data files and\/or executable program files and may be used to implement a security policy and\/or respond to a command. Files may include, but are not limited to, the following examples:","Initialization script: The initialization script may be an executable program file that may be executed using the EI's operating system upon activation of a policy (or at boot, which activates the default policy). In the ANDROID\u2122 operating system, this script is the init.rc file. In one embodiment, each security policy has its own init script.","Certificate: An X.509 or similar certificate containing cryptographic keys, key material, and identity information.","App: Applications that the user may launch.","Daemons and command line utilities: Background processes to launch when a policy is activated, or Command Line Utilities (CLUs) for those daemons or apps to invoke.","Firmware image: A new binary image or image update for the device. A firmware image is binary data containing the fixed data, policies, programs, micro-code, machine code, and other elements that the EI uses to operate. The EI typically stores the firmware image in flash memory or some other non-volatile storage.","Arbitrary file: An arbitrary file may be any data, such as an application, a document, or audio file, that the EI may store somewhere on its file system. An arbitrary binary or text file may be stored at a specified location.","Note that in the case of both commands and files, numerous third-party tools exist to perform remote mobile management, and these tools may either integrate with the security policies or, more likely, be independent of them. The commands and data support herein are generally meant only to support the security policy implementation, and not to provide or replace an overarching Mobile Device Management (MDM) solution.","Categories are defined compartments into which a security policy may place sets of programs and data to be partitioned or separated, and to control access to specific capabilities of the system. For each category, a policy can define various parameters, including, but not limited to:","ID: The ID of the category used to identify it from the other categories.","Available system calls: For each system call in the operating system, the policy may define whether or not processes in a particular category are permitted to make the system call.","File paths: The policy may specify a \u201cdeny\u201d list of complete file paths and prefixes to which processes in a particular category have no access, and\/or an \u201callow\u201d list of complete file paths and prefixes to which processes in a particular category are specifically allowed to access, which may also include an access mode indicated if the process in the category can read, write, or execute the file or files in the specified path. For example, for a given category, the list could be defined as:\n\n","A process in this category would be allowed to:","1. Read and execute files in the directory\/system\/bin and all directories under it;","2. Read and write files in directory\/sdcard and all directories under it;","3. Read, write, and execute the single file\/data\/data\/myscript.sh; and","4. Read and write to devices that begin with\/dev\/ttyUSB (e.g. \/dev\/ttymon, \/dev\/ttymon005, etc.).","Attempts to read, write, or execute files anywhere else on the file system in this example will result in an error.","Subnets: The policy can specify a \u201cdeny\u201d list of network IP addresses, hostnames, or subnets to which processes in a particular category have no access, and then a list to specifically allow access to. For example, for a given category, the list could be defined as:\n\n","A process in this category would be allowed to:","1. Open network connections to and from the IP address 172.16.0.5;","2. Open network connections to and from all IP addresses in the 10.X.X.X network;","3. Open network connections to and from the host vpn.a.disa.mil, assuming that it could somehow be resolved to an IP address using an existing rule; and","4. Use networking between processes using the loopback interface (this rule could also be expressed as allow 127.*, or allow 127.0.0.1).","Attempts to communicate with other networks in this example will result in an appropriate error.","In some embodiments, there may be special categories with reserved names, including:","INIT: Processes in the \u201cINIT\u201d category have the ability to set the category of a process as it is created. According to some embodiments, once a process is placed in a category, it cannot be changed. Thus, the process must be killed (process must end) and be re-spawned by a process in the \u201cINIT\u201d category.","DFLT: The \u201cDFLT\u201d category is the default category, which the system may give to any processes for which the policy has not specified a category.","In embodiments, a security policy may specify how and when to perform integrity checking on specific data. In one embodiment, integrity checking may include performing a cryptographic hash on specified data and comparing the result to a known value to verify the data has not been altered either accidentally or maliciously. In one embodiment, the security policy may specify integrity checks on at least the following three types of data: a named data set that the integrity checking routine is aware of and processes though its internal logic, such as \u201ckernel,\u201d or \u201cself\u201d; a file specified by the path to that file on the storage system; and\/or a memory range specified by the inclusive starting and ending address.","The security policy may also specify different options on how to perform the integrity check, including, but not limited to:","an expected value to use (e.g. the specified value, the last known value) when performing the integrity check;","whether or not it is acceptable to have no known previous value if this is the first time running the check;","a specified algorithm to use (e.g. SHA256, a digital signature, CRC32) when performing the integrity check;","how often to repeat the check (which could be not at all for a startup test);","whether or not it is acceptable to stop during the integrity check to perform other tasks and free up the processor, and if so, to do so for fixed or pseudorandom intervals;","whether to check all the data from start to finish or to check portions of the data (e.g., selected pseudorandom blocks within the data);","what to do if the check fails; and\/or","an initialization vector, or additional data to include in the check. Security policies may also contain violation definitions, which define what actions the EI  must take when a policy is violated. For example, if the EI  attempts to access a blocked network, or attempts a restricted system call, the violation definitions may tell the EI  what action to take in response.","Violation definitions may be applied to entire policy sets, policies, characteristics, or attributes. Each container inherits its parent's violation definition, but may also override that definition with its own. In embodiments, the EI  may choose the violation definition with the smallest applicable scope. That is, violation definitions of attributes can override those of characteristics, characteristics of policies, and policies of policy sets.","The violation definition is in essence a pre-defined value of an enumeration of a set of possible actions. These actions could contain, but are not limited to:\n\n","Definitions may include combinations of these actions, such as informing the policy server and then rebooting the device. In cases where highly complex actions are required, the EI can change policies and execute a script as part of the startup process after entering into that policy.","Violation definitions may also include one or more thresholds, whereby the EI can take different actions based on the number of times the violation has occurred. In embodiments, the threshold can be static, meaning the counters do not reset to zero across reboots of the device, or upon leaving and entering the mode for the policy, or dynamic, in which the counters reset after a reboot of the device or upon first entering a mode for a policy.","Thresholds may be defined as a simple integer value, and when the number of violations exceeds the value, the EI  may take the specified action(s) in the violation definition. For example, a value of zero would mean to take the action upon the first violation, whereas a value if one would mean to take the action after upon the second violation (but before a third, e.g. \u201cone violation is allowed\u201d).","One possible action of a violation definition can be to reset the violation counter, otherwise the actions will repeat upon each violation following the threshold.","Each security policy may include its own initialization script, which in an ANDROID\u2122 system is init.rc. In order to support some of the security policy features, the initialization script (e.g., init.rc) may include several additional commands, including a command to set the category. This command may set the category of all processes forked from this point on to be in the name and mode specified. A verify command may perform the integrity check and\/or decryption described by the arguments. A respawning command may indicate whether or not subsequent forked processes should be periodically restarted (where the approximate time between restarts may be set in the security policy).","In various embodiments, security policy definition files may be a binary representation or data structure containing the policy. In some embodiments, the policy definition files may be XML files, which may enable the files to conform to open standards such as the Open Mobile Alliance (OMA) and make parsing and editing the policy definitions relatively simple to implement. The policy data may be stored and transmitted in any format convenient to the policy server and EI, and embodiments may bypass the XML altogether in favor of a more efficient proprietary mechanism that maps to the policy server and EI data structures.","In various embodiments, the policies and commands preferably do not include any cryptographic material appearing as plaintext anywhere in the policy or command. In the event the material is not encrypted, it may be encoded with a scrambling function to perform a technique known as covering.","Policy data scrambling exchanges bits inside the data based on a key that both the sending and receiving party already have, can derive separately using zero-knowledge techniques, or can exchange out of band. For example, a message could use every other byte of the SHA-256 result of the plaintext of the previous message when sending the current message. The scramble cipher is meant to disguise data when an attacker may scan for known plaintext, but not to replace more robust cryptographic methods.","The scramble cipher may send a word, which may be a 32-bit big-endian word, along with the data as follows:\n\n","Since the policy contains large, static blocks of predictable text, cryptographic methods to secure the transmission are vulnerable to attack. Therefore, in certain embodiments a protocol may be defined for securely transmitting the policy and all associated elements.","An exemplary embodiment method  for transmitting security policy data, which may include policies and\/or commands as described above, is illustrated in . The method  may be used to transmit security policy data from a security policy server  to an EI . In other embodiments, the method may be used by an EI  to transmit security policy data to another entity, including to another EI or to a policy server. In embodiments, the method may be designed to \u201cblur\u201d blocks of predictable data by both surrounding them with random data, and sending the true data out of order.","As shown in block , the server allocates an initial block of data, which may be a pseudorandom sized block of data. In block , the server may fill the initial block with random or pseudorandom data. The random or pseudorandom data may exclude the ASCII digits 0-9 and the ASCII NULL (ASCII code 0). In block , the server inserts a representation of the size of the policy and\/or data to be transmitted, randomly spaced, within the block. The representation may be an ASCII representation of the size of the policy and\/or data, with the digits in their proper order, but pseudorandomly spaced throughout the block. For example, if the packet block was of size 10, and the policy of size 345, the block would contain 7 pseudorandom characters and the digits 3, 4, and 5 at random places as in \u201cJ#3&g4h,d5.hFRq;\u201d (with \u201c.\u201d representing the ASCII NULL, and using only printable characters).","The server may send the initial block to the EI (client) in block . The EI may strip away non-ASCII digits in the data, and allocate space or otherwise prepare to receive data of the indicated size. In block , the server may select a portion of the policy and\/or data to be transmitted, which may be a pseudorandom portion of the policy\/data, preferably including mostly data it has not yet transmitted. The server may then repeat the \u201cblurring\u201d procedure, by allocating a block of data, which may be pseudorandomly sized, in block , and filling the block with random or pseudorandom data, which may exclude the ASCII digits 0-9 and the ASCII Null (ASCII code 0) in block .","In block , the server may then insert characteristics of the selected portion of the policy and\/or data to be transmitted in to the allocated \u201cblurred\u201d block. In one embodiment, the characteristics may include the starting byte of the selected portion followed by length of the selected portion. For example, the server may insert the starting byte of the pseudorandomly selected portion followed by a NULL code, followed by the length of the portion and another NULL code. These characteristics may be inserted in their proper order, but pseudorandomly spaced. For example, if the selected portion of the policy is of length , and the sender is transmitting bytes -, the \u201cblurred\u201d block could contain (with NULL represented as \u201c.\u201d and using only printable characters) \u201c5T1E.P!z0r.Tra&w\u201d, which effectively blurs the data \u201c5 (NULL)  (NULL).\u201d In block , the server may send the \u201cblurred\u201d block to the EI, optionally followed by an extra ASCII NULL. The EI (client), upon receipt of the blurred block, may decode the blurred block, discarding any extraneous ASCII NULL, and may then prepare to receive data of the indicated size. The server may send the selected portion of the security policy in block .","The server may then repeat blocks  though  until all of the data has been sent (i.e., block =No), at which point the process may terminate in block . If it is determined that an error has occurred (i.e., block =Yes), then the process may be restarted in block .","To make the process more efficient, especially in a mobile environment, the recipient of the policy and associated data (e.g., an EI ) may also initiate the request.  is a process flow diagram illustrating an embodiment method  for requesting security policy data from a security policy server .  illustrates the parallel method  of transmitting security policy data from a security policy server  in response to such a request. In block  of method , a client, which may be an EI , sends a request to a security policy server for security policy data in block . The server receives the request in block , and may allocate an initial data block, which may be a pseudorandom sized data block, and fill the initial data block with random or pseudorandom data in block , where this data may exclude the ASCII digits 0-9 and the ASCII NULL (ASCII code 0). In block , the server may insert a representation of the size of the security policy data to be transmitted in the initial data block. The representation may be a NULL (ASCII 0) terminated ASCII string representation of the size of the data in bytes, and the characters from the string may be inserted in their proper order, but pseudorandomly spaced within the initial data block. For example, if the initial data block is of size 16, and the security policy data is of size 345, the block may contain 12 pseudorandom characters and the digits 3, 4, and 5 plus an ASCII NULL at pseudorandom locations, as in \u201cJ#3&g4h,d5w.G;!s\u201d (with \u201c.\u201d representing the ASCII NULL, and using only printable characters). The server may send the initial data block to the client in block .","In block , the client may receive the initial data block from the server and may determine the size of the requested security policy data (e.g., by stripping away the non-ASCII numeric digits in the initial data block). The client may then allocate space or otherwise prepare to receive a policy of the indicated size.","The client may then select what portion of the data it would like to receive next by specifying the starting byte offset and length of the selected portion in bytes in block . The client may use a zero starting index to indicate a pseudorandom starting index and\/or a zero length to indicate a pseudorandom length. The client may then utilize the same \u201cblurring\u201d process as described above in connection with  to hide characteristics of the requested policy data. More specifically, the client may allocate a data block, which may be pseudorandomly sized, and fill the block with random or pseudorandom data, which may exclude the ASCII digits 0-9 and the ASCII Null (ASCII code 0) in block . In block , the client may then insert characteristics of the requested portion of the security policy data (e.g., the starting byte offset and length of the selected portion) into the \u201cblurred\u201d block, preferably in their proper order, but randomly spaced through the block. The client may send the \u201cblurred\u201d data block in block .","The server may receive the \u201cblurred\u201d data block from the client in block . The server may decode the blurred block and determine the requested data to send in block . When sending the data to the requesting client, the server may use the \u201cblurring\u201d procedure described above, in which the server prepares and sends a \u201cblurred\u201d data block with the starting index and length of the data it is about the send, which may be followed by a single ASCII NULL, in block , and then sends the requested portion of the security policy data in block . The client may receive the blurred data block in block , decoding the blurred data and discarding the extraneous ASCII NULL, and receives the requested portion of the security policy data in block . The client may repeat the process until it has all the data it needs, or stop at any time by simply making no further requests","Transmissions between the policy server  and EIs , or between two or more EIs , may be performed using conventional encryption methods, using a pre-shared key or other key material. Since an attacker does not have a known plaintext sequence to lock onto, cryptanalysis will be difficult if the encompassing protocol is properly implemented. (e.g., TLS with most cipher suites may not be appropriate, since that protocol introduces large known plaintext blocks).","In various embodiments, the protection core  may provide functionality for protecting the kernel from malicious malware through system call interception and on-line integrity checking. Embodiments may include modifications to the operating system kernel , described in further detail below, that may enable the protection core  to operate in a special privilege mode, and to offer new system calls with which code can access protection core functionality from outside this privilege space.","In one embodiment, the protection core  may include a system call filtering functionality, configured by a security policy, that may be used to protect the kernel  against threats such as fuzz attacks. The protection core  may also include code for performing all integrity checks on the kernel, itself, or any other data as specified in the governing security policy. The protection core  may also provide ancillary functions to defeat Differential Power Analysis (DPA) attacks.","In various embodiments, the protection core  may require cryptographic material which may be used in, for example, encryption, decryption, pseudorandom number generation (which circularly is sometimes co-dependent with encipherment), and\/or initialization vectors for secure hashing.","Pseudorandom number generators (PRNGs) are an important tool for cryptography and a good security posture in general. It is a common misconception that truly random numbers are cryptographically secure, or that any algorithm passing a minimal set of statistical tests is secure. In fact, the entropy, or source of randomness, impacts the security posture of the algorithm.","In embodiments, the protection core  may have at least two layers of randomness and at least two modes, and a function requesting a pseudorandom numbers may select which layer and mode is required. A first layer (i.e., Layer One) may use a Substitution-box (B-box) and a feedback mechanism, as is known in the field of cryptology. A second layer (Layer Two) may pseudorandomly select from a plurality of S-boxes, making the results less predictable","The two modes may include a first mode (e.g., normal mode), which provides no special functionality, and at least one second mode (e.g., FIPS mode) which ensures that the result conforms to the Federal Information Processing Standard (FIPS) - or higher.","According to one embodiment, in all layers and modes, the requesting function may choose to pass in a context, which will store the internal state of the PRNG across subsequent calls. The caller may also choose to reseed the PRNG in that context, or to use a temporary seed that will not change the internal state of the PRNG, but will give deterministic results (i.e. always give the same result for the same seed). The PRNG may include a default context that is used when the caller does not specify a context.","Key generation is often specific the algorithm used, however in embodiments the protection core  may provide key generation in accordance with the guidelines in FIPS - or higher and may implement all necessary functions for NSA suite B cryptography. Keys may be set by the governing security policy, though in embodiments there may be at least one protection core  root EI key, which the protection core  may generate upon finding that it does not exist, and then store the key. The protection core root EI key may be a private\/public key pair, and the protection core may divulge the public key, but never the private key.","As with keys, certificates and certificate revocations can also be part of a security policy.","The protection core  may handle storage of cryptographic material, including keys, certificates, temporal references, version counters, and the policies that contain them, differently depending on the nature of the storage.","In embodiments, the protection core  may store cryptographic material that must be persistent across reboots in non-volatile memory, which could take the form of specialized hardware, an SD card, flash memory, etc. When stored in non-volatile memory, the protection core may encrypt and sign the material using the protection core root EI key, described above, with the exception of the root EI key itself, which may be encrypted with a device ROM key, stored in external secure memory, or provided by an external device (e.g. TPM or smartcard), depending on the available hardware features on the particular EI.","Preferably, the protection core  leaves cryptographic material in volatile memory (e.g. RAM) for as little time as practical. Since it may be impractical to constantly load and decipher or encipher the material, the protection core  may employ a scrambling function to perform a technique known as key covering. The scramble function may have two modes: bitwise mode and bytewise mode. Bitwise mode includes exchanging bits inside the given memory region. It is less computationally expensive than encryption, but not as robust. It may be used to disguise data when an attacker scans for known plaintext. Bytewise mode fills a buffer of pseudorandom size that is greater than or equal to the data to scramble, and then randomly places the bytes of the data to scramble pseudorandomly throughout the buffer. The two modes can be combined and a hash added to form a weak but fast cipher.","In preferred embodiments, the protection core  may store security policies statically as part of the image, i.e. they are built into the protection core  as needed. This can provide robust security, since the security policies generally form the base of the security model and posture of the system. In other embodiments, the protection core  may allow for dynamic security policies. With the static configuration, changing the policy may involve an update to, at the very least, the protection core subsystem, and a reboot of the EI .","In various embodiments, the protection core  may perform run-time integrity scanning to determine whether specified data have been altered from their expected values. The governing security policy may determine exactly what integrity checks are performed and how often. The protection core  may contain the necessary timers and algorithms to support those options, and may expose the interface to the algorithms via an API in the form of one or more special system calls.","In addition to the API granting the ability to perform the arbitrary integrity checks on files and memory, there may be a set of pre-determined checks that the protection core  runs internally upon certain events, or that may be requested via the API. These pre-determined integrity checks may include, but are not limited to:","Boot check: At boot or upon request, the protection core  may automatically perform an integrity check of the entire image.","Known answer tests (KATs): At boot or upon request, protection core  may perform a series of tests on all cryptographic routines and verifies they return expected results.","Security Policy checks: At boot up, the protection core  may verify one or more security policies, or all security policies, and may also verify a specific security policy by name on request.","Self check: The iscocore  may perform a self check upon request, or at pseudorandom intervals. The governing security policy may determine how frequently to perform these checks, as more frequent checks may improve the security posture but degrade EI performance and battery life.","Kernel check: The protection core  may perform a check on the entire kernel upon request, or at pseudorandom intervals. The governing security policy may determine how frequently to perform these checks, as more frequent checks may improve the security posture but degrade EI performance and battery life.","The security policies may determine what action to take on an integrity check failure, and a default action may be to panic the system and attempt a reboot, halt, or infinite lock on the system until an external force applies a power cycle, depending on the capabilities of the EI .","The protection core  may further provide system call interception. Invalid system calls, and specific parameter checking may be provided in a trusted manner by the protection core  to protect against potential bugs within the operating system kernel .","When a process is created (e.g., forks), the protection core  may intercept the fork and, based on the governing security policy, place the process in the proper category. The protection core  may place processes forked from an existing process into the same category, with the exception of processes in the INIT category, which have the ability to tell the protection core  to place their processes in a specific category.","An embodiment method  of intercepting system calls to an operating system kernel by the protection core  is illustrated in . Upon initiation of a system call by a process in the EI , the protection core may intercept the system call in block . The protection core  may determine the category of the system call based on the security policy currently in effect at block . If the call is allowed in the applicable category (i.e., block =Yes), then the protection core may proceed with the call in block . If the call is not allowed (i.e., block =No), then the protection core  may deny the call and return an error in block .","For calls that involve networks and\/or files, the protection core  may check the denied list as defined in the governing security policy to determine whether the system call should be denied in block . Where the call is not on the pre-defined denied list (i.e., block =No), the protection core  may allow the call at block . If the call is on the denied list (i.e., block =Yes), then the protection core  may check the allow list as defined in the security policy to determine whether the system call should be allowed at block . Where the call is on the pre-defined allow list (i.e., block =Yes), the protection core  may allow the call to proceed to the kernel at block . Where the call is not on the allow list (i.e., block =No), then the protection core  may deny the call and return an error in block .","In some embodiments, the protection core  may specifically deny some system calls, paths, or networks, even if the policy allows them. When there is a conflict between the policy and the protection core, the protection core's rules and logic may apply in certain embodiments.","In embodiments, the protection core  may provide defenses against Differential Power Analysis (DPA) and timing attacks. DPA attacks attempt to extract keys by measuring the power usage by the system. Timing attacks measure the time it takes the system to respond to glean information about key material and other aspects of the security process. True resilience against these attacks generally requires specialized hardware such as FPGAs, EMI shielding, etc. However, the protection core  may utilize techniques used in secure embedded systems to offer resistance against these types of attacks.","In one embodiment, the protection core  employs pseudorandom delays to protect against certain types of attacks. The protection core  may provide a function that will not return until some time between the minimum and maximum specified time has elapsed. The rest of the protection core  may or may not continue to run during this time. This helps to defeat timing attacks by obfuscating the time it takes a given cryptographic function to return, especially in cases where there is an error, where the time to return is often a strong indicator during cryptanalysis and other attacks.","In some embodiments, the protection core  may include pseudorandom CPU spinning. In particular, the protection core  may provide a function which, when invoked, pseudorandomly calls all the available cryptographic routines, and performs read accesses on pseudorandom memory areas. Each routine and read combo is considered a spin cycle, and the caller can specify a number of cycles to execute before continuing.","While this defense is immediately obvious to an attacker with physical adversary to the device, an adversary watching the power consumption (either wired or via EM fields), will see only a sudden increase in power consumption, and the nature of the cryptographic routines and the memory accesses will cause the power usage to be random enough to obfuscate any true error handling or real power consumption when called wisely.","The protection core  may further include one or more ancillary features, including for example, mechanisms to decrypt and flash (depending on the hardware capabilities of the EI) the firmware images.","In certain embodiments, the operating system kernel  may be modified to provide certain features, including enabling the protection core  to operate in a special privilege mode, to offer new system calls with which code can access protection core  functionality from outside this privilege space, and to perform some of its base functionality.","In overview, the kernel  modifications may be similar to techniques originally applied to virtualization software, and they are designed to enhance the robustness and integrity of the kernel, which in one embodiment is a Linux kernel.","Along with the protection core , the modifications may ensure that the kernel , most notably its \u201ctext\u201d segment, cannot be modified during execution, removing a large attack vector from the EI . The kernel's text segment is where the operating system program code resides. If this code is modified, it causes the behavior of the operating system to change, potentially removing security checks, introducing code from an adversary, or even defeating, through impersonation, some of the protection core's features. Embodiments may make novel use of the ARM hardware's Memory Management Unit (MMU), including pagetables and domains, and these changes may ensure that this text cannot be modified.","A combination of off-line analysis tools and online checks by the protection core  may be used to ensure that the kernel  cannot remove these enhanced protections. As used herein, \u201coff-line\u201d analysis includes scanning a particular code or portion of code for certain instructions, op codes, or patterns, and includes scanning in real-time as the kernel or kernel module is loading while the code being scanned is not yet executing (i.e., it is not yet \u201con-line\u201d).","In embodiments, one implementation change to the kernel  is the addition of a security monitor. The security monitor may create a \u201csecure zone\u201d inside the kernel  to protect \u201cprivileged\u201d kernel instructions and data against the rest of the kernel code.","Conceptually, the technique adds a third privilege level to the operating system (e.g., Linux). In addition to the existing kernel mode and user mode, embodiments may add a \u201csuper-privileged\u201d mode, or Secure Monitor Mode (SMM). The security monitor may move a task up or down by one level at a time to carry out operations in different levels.","To isolate the security monitor, its code and data may be located in a secure section distinct from the rest of the kernel, and an API may be used to enter and exit SMM, just as a Linux uses system calls (and other exceptions) to switch between user mode and kernel mode.","In embodiments, the security monitor may use ARM domain memory access control, combined with an off-line ARM instruction scan tool. The technology may be implemented on a variety of architectures, including on any ARM core with the domain feature, and on any operating system. Furthermore, although reference is made to certain architectures, including the ARMv6 and ARMv7 architectures from ARM Holdings, plc (Cambridge, UK), both of which may be utilized with the present invention, it will be understood that embodiments may use other processor architectures, now known or later developed.","In embodiments, the security monitor may protect critical parts of the kernel against code that may be able to run in privileged mode by essentially creating a super-privileged layer against normal kernel, which it relegates to a less privileged layer (but still higher than user mode). Only a small amount of code can run in the super-privileged mode, and this code monitors the rest of the kernel code and protects the kernel from malicious attacks or kernel bugs.","The security monitor utilizes the access domain feature of the processor combined with modification to the operating system's memory mapping to create a \u201csuper-privileged\u201d layer in the kernel, which may be without the drawbacks of virtualization.","Embodiments may include changes to the memory mapping performed by the operating system. There are a number of security issues in existing systems (e.g., Linux-based systems) that may be addressed by the various embodiments.","For example, in a conventional Linux-based system, the entire kernel direct-mapping area that includes the kernel text and data segments has full access permission in privileged mode, and thus has no defense against code running in privilege mode, which includes Loadable Kernel Modules (LKM). This means that any user who can access the file system where the LKM binaries are stored is able to change kernel code and data. There are many explanations as to why LKMs exist and the security compromises they bring to the system. Linux assumes we can \u201ctrust\u201d the LKMs, and it is with this in mind, together with the fact that direct-mappings are created in boot time using ARM assembly, it is not surprising that Linux implements the mapping this way.","This mapping is created at the same time that one-to-one physical mapping is created, which is before the Memory Management Unit (MMU) is enabled. It is almost impossible to allocate a second level page table at that time without breaking the memory management system Linux later uses. Therefore, the minimum security section unit is 1 MB, and it obviously cannot fit Linux kernel sections without creating memory segmentation or a large increase in kernel image size.","Also, it is somewhat inefficient that although most ARM V6 cores support dual page table and split address spaces, Linux chooses to use the same mechanism as it does in AMR V5 instead of the same as in ARM V7. This may be for reasons of backwards compatibility with earlier ARM V6 cores. However, a consequence of such a mechanism is duplicated kernel address mappings in all address spaces. This redundancy makes it difficult to protect these mappings from malicious processes.","In addition, in existing Linux-based systems, the PTEs (2level page tables) are allocated from SLAB, which could be any address in the RAM, which makes it difficult to monitor the memory mappings.","In embodiments, the security monitor feature of the kernel  may include several memory mapping rules that provide increased security. In one embodiment, all critical data may be placed in a secure segment. The secure monitor code and data may be stored in a contiguous memory segment with domain set to be domain_monitor. The kernel address space 1st level page table (section table) and 2nd level page table may also be allocated from this segment. This segment may also include the .init section, which is not freed after boot time, since the monitor checks the integrity of the kernel boot code as well.","An exemplary embodiment of a memory layout of a kernel  with a security monitor is illustrated in Table 1:",{"@attributes":{"id":"p-0175","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},{},"Access"]},{"entry":[{},"Section",{},"Per-"]},{"entry":["Range","Name","Notes","missions"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x80000000-0x80004000",{},"Not used","Domain"]},{"entry":[{},{},{},"monitor,"]},{"entry":[{},{},{},"R\/W"]},{"entry":["0x80004000-0x80008000",{},"Used as pgd","Domain"]},{"entry":[{},{},"(1st level page","monitor,"]},{"entry":[{},{},"table) for kernel","R\/W"]},{"entry":[{},{},"address space"]},{"entry":["0x80008000-0x80008400",".text.head","Assembly boot","Domain"]},{"entry":[{},{},"head code","monitor,"]},{"entry":[{},{},"R\/X"]},{"entry":["0x80008400-0x80300000",".init","All","Domain"]},{"entry":[{},{},"\u201c.secure_monitor.*\u201d","monitor,"]},{"entry":[{},{},"sections, including","R\/W\/X"]},{"entry":[{},{},"kernel 2nd page table."]},{"entry":["0x80300000-0x80783000",".text","Text segment","Domain"]},{"entry":[{},{},{},"kernel,"]},{"entry":[{},{},{},"R\/X"]},{"entry":["0x80783000-0x809e4000",".rodata","Read only data","Domain"]},{"entry":[{},{},{},"kernel,"]},{"entry":[{},{},{},"Rd only"]},{"entry":["0x809e4000-0x80a24ee0",".data","Data section","Domain"]},{"entry":[{},{},{},"kernel,"]},{"entry":[{},{},{},"R\/W"]},{"entry":["0x80a24ee0-0x80a2a000",".bss","BSS section","Domain"]},{"entry":[{},{},{},"kernel,"]},{"entry":[{},{},{},"R\/W"]},{"entry":["0x80a2a000-0x8d200000",{},"Free RAM, will","Domain"]},{"entry":[{},{},"be added in free","kernel,"]},{"entry":[{},{},"list, used by SLAB","R\/W"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"As the table shows, the area 0x80000000\u22120x80300000, is set to monitor the segment mapped to domain_monitor. When the Domain Access Control Register (DACR) is set so that the domain_monitor has no access permission, and any access from any mode (privileged mode or user mode) will generate a domain fault. Also, the kernel PGD (1level page table) and PTE (2level page table) are always allocated from this segment. The absolute size of the PTE is calculated as:\n\nPTE size=0100000(1level page size)\/4(bytes per entry)=0400Total PTE size=100000000(4 GB memory bus limit)\u221208800000(VMALLOC_START)\/0100000(1 MB)*PTE size=0100\n","Therefore, the size of the monitor segment needs to be larger than 0x1 CA00, and should be aligned on a 1 MB boundary, since a domain may only be set in the 1st level page table entry. Considering the code and data section for the security monitor and init, 3 MB is a typical size. If the user address space page tables are also allocated from this segment, the segment may be larger. However, there are typically only a small number of PTEs in kernel address space, therefore, for efficient memory usage, the system can choose to reduce the size of security monitor segment, keeping in mind the 1 MB minimum.","In embodiments, the security monitor may also use a split page table. The address space switch may be similar to that in an ARM V7 system. Specifically, the Translation Table Base Control Register (TTBCR) may be set so that Modified Virtual Address (MVA) translation less than 0x80000000 goes to Translation Table Base Register  (TTBR), and MVA translation equal to or greater than 0x80000000 goes to Translation Table Base Register  (TTBR). There is no need, therefore, to copy kernel mappings across address spaces, and kernel address space may be located on a fixed physical address.","In various embodiments, the kernel address space (excluding the security monitor segment described above) may only have three privileged access permissions, and no user access permissions. These may include privileged Read Only, which may be for rodata segment, privileged Readable and Writable, which may be for the data segment including kernel address space 1and 2level page tables, and Privileged Readable and Executable, which may be for the text segment. In one embodiment, there are no allowed Writable and Executable permissions, which can help prevent self-modifying code in kernel mode, which could be from an LKM.","In embodiments, only the security monitor has access to kernel 1and 2level page tables, since the page tables are allocated from the security monitor segment. Therefore, change of access permission and physical address is not possible for privileged but non-security monitor kernel code or user code.","In summary, in one embodiment of a security monitor, there is a special segment in kernel address space, having an associated domain (e.g., domain_monitor), other than domain_kernel, domain_user or domain_io in normal Linux mappings. The 1level and 2level page tables for kernel address space, as well as the 1level and 2level page tables for user address space may be allocated from the monitor segment. All security monitor text and data sections, as well as Linux init text and data sections, may be located in the monitor segment. Modification of the Domain Access Control Register (DACR) may only be done by code in the monitor segment and memory abort exception handler, as guaranteed by off-line verification tools, only kernel and LKM binaries verified by the off-line verification tools may be installed on the system. Writes to TTBRs and the TTBCR may only be done by the monitor segment, and writes to the Instruction Fault Status Register (IFSR) and the Data Fault Status Register (DFSR), and disabling of the MMU, Translation Lookaside Buffer (TLB) and Cache debug instructions, may only be allowed in a Secure Monitor Mode (SMM). Except the monitor segment, all kernel address space mapping (e.g., addresses\u22670x80000000) do not allow writable and executable access permission at the same time. In some embodiments, the kernel text pages are not writable, and kernel data pages are not executable.","Entering \u201csuper-privileged\u201d mode (i.e., Secure Monitor Mode) may be done by setting domain_monitor in DACR to \u201cclient access\u201d (only allow access in privileged mode), and exiting SMM may be done by setting domain_monitor in DACR to \u201cno access\u201d and setting IFSR and DFSR to an invalid value.","During operating system (e.g., Linux) boot-up, init code may first enter the SMM in the security monitor segment, may enhance kernel page table and initializes for SSM, and may exit SMM before the rest of the kernel is initialized. After this, no privileged kernel code nor userland code may run in the SMM unless the kernel calls routines in the monitor segment or accesses the secure monitor segment. There are generally only a limited number of SMM entries in the kernel and all entries may be registered and may be checked in run-time when switching into SMM. In some embodiments, it is not possible to switch to SMM directly from user mode.","On a domain fault, the faulting PC may be checked against registered SMM entries and only registered entries may be allowed. On entry of SMM for memory mapping, there may be code to check physical addresses in the critical area that includes the secure segment, exception area and any other area that should not be remapped.","The API may include at least two calls for the security monitor, including calls for entering and exiting the Secure Monitor Mode (SMM). When the operating system boots, before it turns on the MMU, the Domain Access Control Register (DACR) may to be set to allow all domain access to be able to perform the initialization of the kernel and monitor. After the kernel memory map has been set up for the security monitor and kernel initialization is finished, the kernel may call the exit SMM routine for the first time to disable access to the monitor domain segment by the rest of the kernel and user code.","The code for exiting the Secure Monitor Mode should be located within the secure monitor segment (e.g., domain_monitor) in kernel address space.","The goal of running the exit secure monitor function is generally to execute non-SMM code, which may be untrusted. In this function, when DACR is still set to allow access for the domain_monitor, execution of this instruction remains in SMM. However, in one embodiment, the exit secure mode function includes changing the domain access rights, such as by writing to the DACR and\/or ISB (Instruction Synchronization Barrier) to restrict access to the secure monitor segment. After writing to DACR and ISB, the MMU's view of domain access right has updated, and prefetch of the next instruction address (e.g., return_addr, which is located in the monitor segment) by the MMU would result in a prefetch abort, and hence branch to prefetch abort handler.","In embodiments, the exception vector area and exception handler may not be in the monitor segment, since if they are, the branch to exception vector instruction itself would trigger a new round of prefetch abort and the CPU will then enter an infinitive loop of generating prefetch aborts. Note that this situation will not compromise the secure monitor mode, since self-modifying kernel text segments are not possible, and modifying IFSR or DFSR can only be done in SMM, therefore, exploit code cannot make the PC jump to the exception handler and safely return to non-SMM code.","One challenge is how to return from the exception handler to the next instruction address and then continue to non-SMM kernel code after a genuine prefetch abort triggered by the exit secure mode function. In one embodiment, the solution may include using a continuation function. Before changing DSFR, the monitor may store the continuation function pointer for this task. In the prefetch abort handler, it checks if IFSR is a domain fault, and if so enters a domain fault handler. The domain fault handler checks if the faulting PC is the ISB instruction in the exit secure mode function, and if so branches to the continuation function.","Before writing DACR, however, there are 4 registers that have been pushed onto the kernel stack as part of C EABI function entry code to save other registers used in this function, as well as the return address for the calling function. The domain fault handler fixed the return program counter (PC), however, the kernel stack pointer (SP) has changed and the restore registers and return to calling function instruction ldm sp, {fp, sp, pc} is bypassed by the monitor's mechanism. The calling function is expecting the stack to point to sp_kernel(), but it is actually pointing to sp_kernel(). The stack must be repaired, therefore, before branching to the continuation function.","Since the number of the registers and which set of registers are pushed onto the stack vary with the ABI of the tool chain and the context that the exit secure monitor function is invoked, any change of the function calling arguments, or even the code in the this function, would cause the compiler to choose to push different set of registers. One solution is to implement the exit secure monitor in assembly. This will ensure the ABI is satisfied, and the code can easily read registers from the context in domain fault handler, and the fix stack as needed. After returning from the exception handler, floating point (fp) and stack pointer (sp) along with the program counter (pc) will be set to correct value.","The exit secure monitor function may be set in the security monitor segment by a Linux linker script. In embodiments, there may be only one exit routine of the SMM throughout the kernel so that the domain fault handler can always check if the faulting PC is the address of the instruction after the ISB in the exit secure mode function.","After exiting the Secure Monitor Mode (SMM), the operating system (e.g., Linux) may run in \u201cnormal\u201d privileged mode, or user mode. There may be cases, however, where the operating system re-enters SMM from kernel mode.","For example, the SMM may be re-entered for monitoring kernel code behavior. These entries to the SMM may be in exception handlers, and the security rules for the kernel can be added here. For example, rules allowing or forbidding system calls can be added in the entry of SMM in swi_handler. Kernel integrity checking can be added into the SMM entry code in irq_handler, etc.","The SMM may also be re-entered for performing \u201csuper-privileged\u201d operations. In embodiments, the kernel needs \u201csuper privileged\u201d instructions to do kernel work. For example, change TTBR for switch_mm( ), change DACR for accessing user pages, etc. When the kernel needs to use these instructions, it may re-enter SMM.","The SMM may also be re-entered for accessing the security monitor segment. The kernel may sometimes need to access memory in the security monitor segment. For example, when adding kernel mappings, Linux Memory Management (MM) code may need to write to a kernel page table.","As a result, there could be more than one entry point into SMM within the kernel, and these entries may be tracked by monitor entry code. For each entry point, there may be an API function defined inside the security monitor segment that actually does the job. In one embodiment, all the non-SMM kernel code needs to do is call the API function.","The entering of SMM may also generate a prefetch abort exception, and a check for the faulting PC to see if this domain fault is caused by branching from a legitimate registered SMM entry. The check may be a linear search in an entry table in a read-only data segment in an exception handler section. The table may be generated at compile time, and all return virtual addresses of declared SMM entries may be added in that table. In embodiments, the table may not be located in security monitor segment since the domain fault exception handler cannot be running in SMM on ARM V6, and hence it cannot access security monitor segment. Thus, all entries to SMM in non-trusted kernel code may register themselves in the monitor entry table, and any other domain fault on the domain monitor segment would be an illegitimate access.","In Linux, different architectures have different degrees of hardware support for the kernel accessing user memory. This may be important for the performance for an Operating System. In the ARM V6 architecture, the instructions LDRT and STRT provide kernel access memory to memory in user mode (i.e. the MMU treats memory accesses issued by LDRT\/STRT as if it was issued in user mode, even though the CPSR mode bits are set to none-user mode). The kernel uses these instructions to access user address spaces directly without generating page faults if the page is mapped in the user space. However, this is extremely dangerous for kernel implementations. If kernel code unintentionally uses LDRT\/STRT on an incorrect but nevertheless mapped user address, there is no page fault generated, and user address space could be contaminated by kernel bugs.","Linux ARM V6 enables the use of the Domain Access Control Register (DACR) as a mechanism to prevent the kernel from accessing user memory. All user address space is associated with a different domain from the kernel space. If the kernel intentionally accesses user address space, it will change DACR to allow kernel access of user address space which has domain_user. If the kernel code unintentionally uses LDRT\/STRT on user address space, domain access control denies access, and a domain fault is generated.","In embodiments implementing the security monitor, modifying the DACR may be a \u201csuper-privileged\u201d instruction, therefore it has to be moved into the security monitor segment, and is tracked and monitored by SMM. In this embodiment, non-SMM kernel code cannot access user address space without registering with the security monitor. Self-modification of user address space by the kernel can also be prevented as long as the user page table has the domain set correctly (this may easily be guaranteed by putting the 1st and 2nd user page table in the security monitor segment, for instance).","In embodiments, the kernel may prevent nested entry into SMM. Embodiments may allow a security monitor entry function to calls another secure monitor entry. In this case, the second entry of SMM does not cause a domain fault, since it's already in SMM, but its exit secure monitor routine does exit SMM. The subsequent return calling code is then executed in non-SMM mode. When branching to the exit secure monitor function for the second time, a domain fault is generated since the exit secure monitor is in the monitor segment. However, the return address of the second exit secure monitor is not a registered SMM entry, and is detected by domain fault handler and treated as an error. Therefore, there may be code at the entry of SMM to check the SMM mode and not perform the exit secure monitor function if it is determined that it is a nested entry.","The Security Monitor Mode (SMM) may provide a framework or a secure vault for critical kernel data and code. Security algorithms and checks can be put inside this secure area and monitor the rest of the kernel and user behavior.","In embodiments, security related global data can be placed in the SMM segment, and then can be used by security algorithms. For example, if any of the algorithms implements a state machine, the state (or other context information) can be reside in the SMM segment and be safe from non-SMM code.","One important state in the various embodiments is the current Security Mode of the EI . Upon calling a special system call to switch security modes, system call monitoring code may change the security mode according to the parameter of this system call. The current security policy may then change depending on the new security mode. This global variable should not be accessed by non-SMM code, and SMM protection mechanisms can guarantee that.","In embodiments, system call monitoring resides in the entry of SMM in an interrupt handler (e.g., swi_handler). All Linux system calls must to pass the system call security policy check to reach the OS (e.g., Linux) system call handler. System call monitoring code has access to the kernel context of the SWI exception and userland parameters of the system call. It can perform any security policy check on both kernel space and user space. The security policy can be defined at compile time and be built into the SMM segment as well (with proper signature verification), as it is a data structure with a function pointer to a function with which to do the check, and other policy data associated with the function. There may be a static array of security policy maps to each OS (e.g., Linux) system call. At run time, the check function defined for the system call number may be called to perform the policy check for a given system call, and if the check fails, the interrupt (SWI) may return directly with an error number and never actually reaches a Linux system call handler which is located outside the SMM segment.","In embodiments, at least two mechanisms may be used to prevent the run-time modification of kernel code, rodata, and security monitor code: address space protection and run-time hashing. In embodiments, non-SMM code may not access kernel address space, as the only way to do so is through SMM entry in a mapping function (e.g., vmap). In the SMM entry of the mapping function, the code forbids any mapping (including DMA mapping) of physical frames that overlap above the critical area, and thus prevents any writes to physical RAM of above that area.","Run-time hashing may include a redundancy check to ensure the first mechanism has not failed in some way, or that an adversary has not physically altered a portion of memory. This mechanism may involve choosing random (e.g., 4K) pages, performing a cryptographic hash (e.g., SHA256) on the page. The system may compare the digest to statically generated digest values, and any differences may result in a system panic or other exceptions.","Since run-time integrity checking is processor-intensive and may impact cache and system performance in general, the frequency may be configurable in the security policy definition in various embodiments.","As discussed above, embodiments include an EI  having plurality of security policies corresponding to different operating modes, where the EI  may operate in a single mode at any different time. Mode switching enables the EI  to switch between different security policies at runtime, providing better security than sandboxing or virtualization alone by introducing further robustness through temporal isolation.","The protection core init subsystem , which is illustrated in , may process the change to a new security policy, and may inform the protection core  of the corresponding change in mode so that the protection core  may enforce the new policy. A mode switch according to one embodiment is illustrated conceptually in . In this example, the EI has four security policies (Policies A-D), which may be stored in memory on the EI . The protection core init subsystem  may change the governing security policy from Policy A to Policy C at time t, and the protection core  may begin to enforce policy C at t. The EI may thus operate in a new mode.","In one embodiment, when a mode switch occurs, the old mode is completely deactivated, its processes are killed, and memory zeroed. This generally does not effect apps or non-volatile storage, nor does it preclude the protection core init  from encrypting and storing the contents of any memory and restoring that memory when the mode is re-activated, but it does provide strong temporal isolation between processes running under different security policies.","The protection core init  subsystem may provide a flexible mode switch API to indicate that it should initiate a mode change, and from there on its behavior may be driven by the current and indicated policy. In various embodiments, the mode switch API provides a way for apps, processes, and other EI subsystems to initiate a mode change. For example, a timer could indicate that a mode change must occur each evening at a specified time, an app could request a mode change each time it sees a particular wireless network appear, or a user could write their own app with its own user interface, etc.",{"@attributes":{"id":"p-0214","num":"0237"},"figref":"FIG. 10","b":["1000","1002","224","1004","1006","224","1008","1006","1010","1012","1014","222","1016","1018","102"]},"The API may be a system call, and is thus controlled by the system call monitoring, and access is defined by the current policy in place. A binary executable could also place the system call, in which case the file could also fall under the control definitions of the current policy.","In embodiments, the protection core init  subsystem may run the initialization script (e.g., init.rc in the case of ANDROID\u2122), and may make the calls into the protection core  to place the processes launched during the running of the script into the proper categories, as defined by the applicable security policy. In embodiments, only the protection core init  may have this capability, and only the protection core init  may be in the special \u201cINIT\u201d category, described above. For each process in the init script, the protection core init  may inform the protection core  of the category in which to place subsequent forks from the protection core init  into, unless the category has been set and has not changed since the previous fork. If the fork is to launch a binary executable, the protection core init  may look in the current policy for a hash or key to decrypt or verify the integrity of the executable, and may do so via the protection core's API. If the security policy marks the process about to be launched as re-spawnable, the protection core init  may add the process ID to a list of processes to re-spawn.","The protection core init  subsystem may also be responsible for respawning certain processes, as specified in the security policy. In embodiments, various process and their data may be moved around, which may provide a level of biomorphic security for the EI. The protection core init  subsystem may pseudorandomly kill and re-spawn certain processes that were marked as willing to be so in the init script. After a pseudorandom number of clock ticks equal to between once and twice the period specified in the policy, protection core init  may chose a process, preferably pseudorandomly, from the list of processes to re-spawn, and kills and re-spawns the process.","The protection core client subsystem , which is illustrated in , may communicate with the policy server  to download policies, commands, and other data. The protection core client  may also communicate with the protection core init  as required to process the incoming data, and may send the policy server  any request data about the status of the EI .","The governing security policy includes at least two important characteristics for the protection core client : the policy server(s)  with which the protection core client  may communicate, and when these policy server(s)  may or must be contacted.","The list of policy servers, each as an attribute to the policy server characteristic of the policy, contains one or more policy server(s), where a policy server may be defined by: an ID used as a tag or reference; an IP address or hostname (one of these should be unique in the list); a user name; a password; an X.509 or similar server certificate or certificate chain to verify the identity of the server; an X.509 or similar client certificate to use when accessing this policy server; a list of supported authentication methods in order starting with the most preferred to least preferred; a list of supported Transport Layer Security (TLS) cipher suites in order starting with the most preferred to least preferred; and\/or a priority for the particular policy server over other servers, which may be expressed as an integer from 0-255 where 0 is the highest priority.","The governing security policy may also determine how frequently the protection core client  contacts a policy server  and requests new data and commands. Since EIs  are likely to be in a mobile environment where their IP addresses and availability on the network are fluid, in preferred embodiments the protection core client  will contact a policy server  on a periodic basis.",{"@attributes":{"id":"p-0222","num":"0245"},"figref":["FIG. 11","FIG. 11"],"b":["226","226","226","1102","1104","226","1106","1108","1110","226","1112","1114","226","1116","226","102","1118","1120","1122"]},"In embodiments, when the protection core client  contacts a policy server , it may select which policy server to contact from the list of policy servers, as described above. It may do so by selecting the server with the lowest priority number. If, however, the protection core client  is unable to reach this policy server on its last attempt, the protection core client  may set an error flag on the server and move to the next policy server in the list. Upon the first successful, complete dialog with the policy server, the protection core client  may ignore all previous error flags.","If several policy servers have the same priority, the protection core client  may choose among them in an arbitrary order, including pseudorandomly or by selecting the server with the lowest number of connection errors from previous attempts.","As part of attestation with the network or another EI, the EI  may be asked to report the time it last contacted a policy server , either to a policy server or to another EI. The EI  has several choices for policy server attestation, including immediate and stored attestation.","In immediate attestation, any client (or indeed a server the EI is attempting to contact, but in this case that server is the attestation client) may provide the EI a pseudorandom value, and optionally ask for other data the EI may have or for the EI to calculate certain results. The EI  may cryptographically sign the requested results and the pseudorandom data with its own private key, and send the resulting signature to the requesting client. If the EI is truly the correct EI, and the client has the public key of that EI, the signature should be valid. If not, the EI is an impostor, does not have the proper data, or is not in the proper state.","In stored attestation, at any time, most likely as directly by the current policy, the protection core client  may request an attestation value from the policy server . The protection core client  may store this value, and be prepared to offer it to anyone who asks as proof that the client  did indeed communicate with the policy server.","Attestation mechanisms are independent of the data involved, which could include anything from a hash on the EI's firmware to a timestamp from a trusted NTP or other network clock source.","The protection core client  may communicate using HTTP over TLS, but in embodiments may not support the complete HTTP protocol, but rather only a small, limited subset that may be designed to work with the policy server and still be compatible with arbitrary commercial HTTP servers.","For transmission of security policies and\/or other security data, the protection core client  may use a policy transmission protocol such as described above in connection with , and the transmission may be wrapped inside TLS and use a cipher suite dictated by the policy server upon establishing a connection.","The protection core client  may process and store data from policy sets, including files to save on the EI's file system and firmware updates. Firmware may be encrypted, compressed, or in a variety of formats that are device specific. The process for writing to non-volatile storage and flashing new firmware is also device specific. In addition to storing data from the policy server, the protection core client  may process all the commands from the policy server, including mode switches, which involves performing any protection core client  actions and then subsequently informing the appropriate subsystems of the command.","Embodiments also include a protection core weaver , which is illustrated in . The protection core weaver  may run on a server, such as policy server  in . In one embodiment, the protection core weaver  is a tool that generates a firmware image for an EI or set of EIs. The firmware image may be a copy of a particular version of the system firmware with associated metadata. The protection core weaver tool may be available to authorized administrators only, and may be accessed via the policy server's Web-based administration tools or via a Linux or Unix command line interface.","The protection core weaver  may include a number of specific capabilities for generating a firmware image. For example, the protection core weaver  may be able to generate keys and certificates for individual EIs or groups of EIs. Certificates are typically X.509 format, and all cryptography is typically NSA suite B.","The protection core weaver  may also include a scramble cipher function. In one embodiment, the protection core weaver  may never place any keys into any file as plaintext, or transmit them as plaintext even when the transport protocol provides encipherment. In the event the keys are not covered with a secondary encryption scheme, the protection core weaver  may use a scramble cipher as described above.","The protection core weaver  may also provide image generation. In one embodiment, the protection core weaver  may take all data, commands, and policies for an EI or group of EIs, and packages them into forms that the protection core client  (and ultimately other subsystems of the protection core ) can understand. The protection core weaver  may then package this data into a single file for the policy server . In doing so, the protection core weaver  may in some embodiments use biomorphic algorithms to place data in different offsets in the firmware image for different EIs. This is schematically illustrated in , which shows a firmware image  containing a set of data, including policies and files and a function (Function A) in a first configuration. The protection core weaver , implementing one or more biomophic algorithms , may modify the firmware image by applying different offsets to the data contained therein to produce modified firmware image files , ,  for three different EIs (i.e., EI A, EI B, EI C).","After generating a firmware image, the protection core weaver  may store the image for the policy server  to transmit to an EI.","The policy server  may support the delivery of data and commands to the EIs, editing of policies, creation of firmware images, and all attestation requirements. The policy server is generally the most security-critical architectural element of the security solution, as its compromise could result in sending unauthorized policies to the EIs. For this reason the policy server may use a more robust operating system than traditional servers, along with specialized software to fulfill its primary tasks.","The policy server may communicate with EIs via HTTP inside TLS (HTTPS), but since the policy server is a fixed architectural element in terms of the network, even when part of a mobile tactical network, it may be the HTTP server where the EIs and authorized desktops and other devices are the clients.","Preferably, the policy server does not use a commercial HTTP server for the security reasons noted, but rather a specialized real-time embedded server designed specifically to provide enhanced security by scanning for properly formatted requests for known resources. In some embodiments, the policy server may have its own security policy, which an authorized administrator can configure using the policy server's Web-based administration.","Embodiments may also include a policy editor , such as shown in . The policy editor  may be a Web-based tool to create and edit policies and policy sets, or templates to use in their subsequent creation. The policy editor  may run on the policy server , as shown in .","In embodiments, the policy editor  allows an authorized administrator to edit all aspects of the policy, while hiding as much of the complexity as possible. Every aspect of the policy may be editable from the policy editor, however, the editor may present the administrator with the opportunity to use multiple views and templates. Views may determine what characteristics and attributes are visible on the master editing page, and may create a map of links to other maps on which those named characteristics are editable. File uploads, editors, and other UI of pages may all be specified using a view. By authoring a view, an administrator can place the most commonly changed elements on the first page they see, and relegate the more esoteric aspects of policy management to several links deep. In preferred embodiments, views are stored in the policy server's database .","In some embodiments, in the same way an authorized administrator can create views, they may also create policy and data templates. These templates can map to specific IA policies (e.g. FISMA frameworks, NIST guidelines, STIGs, etc.). Templates may also be stored in the policy server's database .","The policy editor  may also provide an analysis of how robust the policy is, by looking for key problems or issues such as: dead or cyclic policy change attributes that would create a condition where once the EI is in a particular policy, it could never transition to a given other policy; overlapping access rights, especially for file system write access; a measure and description of deviation from established policy templates; no access to the mode switch or other important system calls (the system may become unusable); too many or inappropriate categories with access important system calls (the system may become less robust); requiring an integrity check on a file or other resource but not specifying it in the policy (because that would mean it is stored by the EI at an unknown security posture); use of plaintext keys or passwords, or other data that appears sensitive as plaintext, etc.","Such an analysis may produce a policy strength assessment that goes into the firmware image, and networks and EIs may request this assessment as part of the measurement for attestation. This would prevent EIs with less robust policies from accessing some networks or resources, such as communicating with EIs which require a higher policy assessment level.","The policy server may store all images, policies, and other data in a database  for easy searching and retrieval. Given that images may created for individually for EIs, however, and that there may be millions of EIs, the database may not contain every image, but rather digital signatures of the images.","The policy server  may provide a Web-based editor for text files, and may also allow for the download and upload of arbitrary text and binary files per the policy server's security policy. For example, binary data is not allowed in an upload of \u201cinit.rc\u201d, an ANDROID\u2122 Initialization script which should contain only text.","When saving the data, the administrator can choose to save a digital signature of the file as well.","A command editor may be used to send commands to an EI or group of EIs. Commands are sent as policy commands, however since the EI may not be listening at any given time, commands may be \u201cpulled\u201d from the policy server when the EI makes it's next request from the policy server. For this reason, when an administrator stores a command for an EI or group of EIs, it may be stored in the database , and then delivered, and the delivery history updated in the database, upon the next connection by the EI. The threat library is a portion of the database  that EIs may query to determine if an application, another EI, a network, or other resource is a known threat or a known safe resource. The database  may be broken up into three types of entries, those for attestation, Violations, and known adversaries.","Attestations: The attestation entries in the library contain the IDs of EIs that either have performed or need to perform attestation, and the associated status and parameters.","Violations: The violation entries in the library contain the IDs of EIs that have reported violations, and the specifics on the violations they have reported. The number and type of violation may determine the security posture of the EI and the behavior or authenticity of the user, and so any authorized EI may query as to the status on the violations of another EI before entering into a transaction (e.g. a VoIP call) with that EI. The policy server itself may also use this part of the library to form commands for the EI, such as telling an EI to change policies or to require re-authentication of its user.","Known adversaries: The known adversaries entries in the library contain information on entities known to be hostile or compromised. These entities could include, but are not limited to: networks, EIs, applications (as defined by a SHA256 hash or other signature), server host names, domain names, IP addresses or address ranges, URLs or URIs (Web sites, FTP servers, and other online resources).","The EIs may query these entries, however it is more likely that this information will be useful in authoring and checking the strength of policies before sending them to EIs, or in determining, via an addition to these entities, if new policies are required.","In embodiments, the policy server may act as the primary key server, or there may be an external key server distinct from the policy server. The key server may send cryptographic keys to the EIs and respond to queries for keys, key material, and encipher\/decipher messages from the EIs and other servers. The key server may also have the ability to generate keys for servers and EIs.","The key server may store all keys in a key database, however no private keys are stored as plaintext (i.e. private keys are encrypted) even locally on the key server in the database, in memory, and anywhere else they may be used. Private keys are only decrypted for short periods of time as needed for decryption, and plaintext versions are immediately erased.","When a plurality of policy servers  act in a cluster, they may share their databases or perform database duplication and replication. Nothing other than network configuration that is specific to a policy server is stored anywhere other than in the database.","The foregoing method descriptions and the process flow diagrams are provided merely as illustrative examples and are not intended to require or imply that the steps of the various embodiments must be performed in the order presented. As will be appreciated by one of skill in the art the order of steps in the foregoing embodiments may be performed in any order. Words such as \u201cthereafter,\u201d \u201cthen,\u201d \u201cnext,\u201d etc. are not intended to limit the order of the steps; these words are simply used to guide the reader through the description of the methods. Further, any reference to claim elements in the singular, for example, using the articles \u201ca,\u201d \u201can\u201d or \u201cthe\u201d is not to be construed as limiting the element to the singular.","The various illustrative logical blocks, modules, circuits, and algorithm steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware, computer software, or combinations of both. To clearly illustrate this interchangeability of hardware and software, various illustrative components, blocks, modules, circuits, and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.","The hardware used to implement the various illustrative logics, logical blocks, modules, and circuits described in connection with the aspects disclosed herein may be implemented or performed with a general purpose processor, a digital signal processor (DSP), an application specific integrated circuit (ASIC), a field programmable gate array (FPGA) or other programmable logic device, discrete gate or transistor logic, discrete hardware components, or any combination thereof designed to perform the functions described herein. A general-purpose processor may be a microprocessor, but, in the alternative, the processor may be any conventional processor, controller, microcontroller, or state machine. A processor may also be implemented as a combination of computing devices, e.g., a combination of a DSP and a microprocessor, a plurality of microprocessors, one or more microprocessors in conjunction with a DSP core, or any other such configuration. Alternatively, some steps or methods may be performed by circuitry that is specific to a given function.","In one or more exemplary aspects, the functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored on or transmitted over as one or more instructions or code on a computer-readable medium. The steps of a method or algorithm disclosed herein may be embodied in a processor-executable software module executed which may reside on a computer-readable medium. Computer-readable media includes both computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another. A storage media may be any available media that may be accessed by a computer. By way of example, and not limitation, such computer-readable media may comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage or other magnetic storage devices, or any other medium that may be used to carry or store desired program code in the form of instructions or data structures and that may be accessed by a computer. Also, any connection is properly termed a computer-readable medium. For example, if the software is transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk, and blu-ray disc where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media. Additionally, the operations of a method or algorithm may reside as one or any combination or set of codes and\/or instructions on a machine readable medium and\/or computer-readable medium, which may be incorporated into a computer program product.","The preceding description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present invention. Various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the invention. Thus, the present invention is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the following claims and the principles and novel features disclosed herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated herein and constitute part of this specification, illustrate exemplary embodiments of the invention, and together with the general description given above and the detailed description given below, serve to explain the features of the various embodiments.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIGS. 7A and 7B","FIG. 7A","FIG. 7B"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
