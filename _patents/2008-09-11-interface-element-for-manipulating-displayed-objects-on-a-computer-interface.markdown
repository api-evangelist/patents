---
title: Interface element for manipulating displayed objects on a computer interface
abstract: The present invention provides method of manipulating a displayed object capable of interacting with an interface element of a computing interface. The computing interface has a display module for displaying the displayed object in a display area, and which causes the displayed object to interact with the interface element and manipulating the displayed object according to the nature of the input received. The manipulation includes varying the size of the displayed object when the received input results in movement of the displayed object, into, out-of, or through a region of the display area designated as belonging to the interface element.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09047004&OS=09047004&RS=09047004
owner: Smart Internet Technology CRC PTY LTD
number: 09047004
owner_city: Eveleigh NSW
owner_country: AU
publication_date: 20080911
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","EXAMPLE"],"p":["The present invention relates generally to interfaces for computing systems and more particularly, but not exclusively, to a system, method and interface for manipulating objects on a computer interface.","Interactive desktop interfaces are known as part of current computer operating systems. In some computing applications it is desirable to have an interactive tabletop interface. An interactive tabletop interface allows for interaction with one or more users on a tabletop display. An interactive tabletop interface facilitates collaborative sharing of objects such as digital photographs by a number of users. Such an interface comprises an image which is projected onto the tabletop display. The image may be projected, for example, by use of an embedded screen or a data projector. One or more users may interact with the displayed image via an input of the interface in order to, for example, manipulate objects in the displayed image. Input to the interface is provided by, for example, a touch sensitive surface, of the tabletop onto which the image is projected. This form of computer interface facilitates so-called \u201cpervasive\u201d computing.","However, when many objects are displayed on a tabletop computer interface, the interface can become cluttered. This can prevent the user from readily interacting with the displayed objects and detract from the user's productivity.","According to a first aspect of the present invention there is provided a method of manipulating a displayed object capable of interacting with an interface element of a computing interface, the computing interface having a display module for displaying the displayed object in a display area, and an input module for receiving a user input, said method comprising:","receiving a user input which causes the displayed object to interact with the interface element;","manipulating the displayed object according to the nature of the input received, wherein the manipulation comprises varying the of the displayed object with the interface element.","In one embodiment size of the displayed object when the received input results in movement of the displayed object into, out-of, or through a region of the display area designated as belonging to the interface element.","In one embodiment the user input results in movement of the displayed object within the display area in a manner that results in interaction the user input directly moves the displayed object.","In one embodiment the user input causes the displayed object to move into, out-of, or through the region of the interface element.","In one embodiment the user input indirectly results in movement of the displayed object.","In one embodiment the user input causes the region of the interface element to be redefined within the display area which results in interaction of the interface element with the displayed object.","In one embodiment redefining the region of the interface element is in the form of moving the region within the display area.","In one embodiment redefining the region of the interface element is in the form of resizing the region within the display area.","In one embodiment the user input signifies activation of a manipulation property of the interface element which results in interaction of the interface element with the displayed object.","In one embodiment the size of the object is varied according to the direction of movement through the region. Preferably the direction is a radial direction.","In one embodiment the size of the object is reduced as the object is moved towards the centre of the region.","In one embodiment the size of the object is increased as the object is moved away from the centre of the region.","In one embodiment the method comprises manipulating a plurality of displayed objects according to the nature of the input received.","In one embodiment the influence further comprises varying the size of all displayed objects which move into, out-of, or through the region.","In one embodiment the influence further comprises moving all display objects located within the region along with the region when the region is moved.","In one embodiment the influence further comprises moving all display objects located within the region along with the region when the region is moved, unless the region encounters a prohibited zone of the display area, in which case the region is prevented from entering the prohibited zone and the display objects continue to move according to the received input.","In one embodiment the manipulation further comprises causing all displayed objects in the region to move towards the centre of the region when the user input signifies activation of an manipulation property of the interface element.","In one embodiment the manipulation further comprises causing all displayed objects in the display area to move towards the centre of the region when the user input signifies activation of a manipulation property of the interface element.","In one embodiment the manipulation further comprises causing displayed objects having a selected property to move towards the centre of the region when the user input signifies activation of an manipulation property of the interface element.","In one embodiment the manipulation further comprises causing displayed objects that reach the centre of the region to be hidden.","In one embodiment the manipulation is to cause all displayed objects in the region to move away from the centre of the region when the received input signifies activation of a manipulation property of the interface element.","In one embodiment the manipulation is to cause all displayed objects in the display area to move away from the centre of the region when the received input signifies activation of a manipulation property of the interface element.","In one embodiment the manipulation further comprises causing displayed objects having a selected property to move away from the centre of the region when the received input signifies activation of a manipulation property of the interface element.","In one embodiment the manipulation further comprises causing displayed objects within the region to be deleted when the received input signifies activation of a manipulation property of the interface element.","In one embodiment the influence further comprises causing displayed objects within the region to be resized when the received input signifies resizing of the interface element. Preferably the resizing of the objects is of the same type and\/or proportion as the resizing of the interface element. In an embodiment the resizing of the object is in proportion to the size of the region of the interface element.","In one embodiment the manipulation further comprises causing hidden displayed objects within the region to be shown when the received input signifies activation of a manipulation property of the interface element.","In one embodiment a representation of the interface element is displayed within the region. In one embodiment the representation is of a black hole.","According to a second aspect of the present invention there is provided a computer readable storage medium storing a computer program for manipulation a displayed object in a display area that interacts with an interface element of a computing interface, said computer program comprising instructions that when executed by a computer cause the computer to:\n\n","manipulating the displayed object according to the nature of the input received, wherein the manipulation comprises varying the size of the displayed object when the received input results in movement of the displayed object into, out-of, or through a region of the display area designated as belonging to the interface element.","According to a third aspect of the present invention there is provided an apparatus for manipulation a displayed object that interacts with an interface element of a computing interface, said apparatus comprising:","a display having a display area;","an user input;","a processor configured to:\n\n","manipulating the displayed object according to the nature of the input received, wherein the manipulation comprises varying the size of the displayed object when the received input results in movement of the displayed object into, out-of, or through a region of the display area designated as belonging to the interface element.","According to a fourth aspect of the present invention there is provided an apparatus for manipulating displayed objects that interacts with an interface element of a computing interface, said apparatus comprising:","a display having a display area;","an user input;","means for receiving a user input which causes the displayed object to interact with the interface element;","means for manipulating the displayed object according to the nature of the input received, wherein the manipulation comprises varying the size of the displayed object when the received input results in movement of the displayed object into, out-of, or through a region of the display area designated as belonging to the interface element.","According to a fifth aspect of the present invention there is provided an interface element for a computing interface having a display module for creating a display covering a display area and an input module for receiving a user input, said element comprising:","an interface element interaction module for designating certain user input that causes the displayed object to interact with the interface element as interface element input;","an object manipulation module for manipulating objects in the display according to the nature of the input received when an interface element input is received, wherein the manipulation module is configured to vary the size of displayed objects that the input signifies as moving a displayed object into, out-of or through the region.","An aspect of the present invention provides a new interface element for reducing screen clutter on a computer interface. In the embodiment described herein, the computer interface is displayed on a surface-mount display provided by a tabletop computing system. The interface element operates to manipulate or influence objects displayed on the interface based on a user input. In an embodiment, manipulating the object comprises varying the size of the displayed object when the received input results in the object being moved into, out of, or through a region of the display associated with the interface element. For example, where a user of the tabletop computer wants to focus their attention on one of ten objects (e.g. a digital photograph) presently displayed on the user interface, they may drag any one or more of the other nine objects towards the interface element to effectively minimize their size.","To carry out the aforementioned functionality and with reference to , the tabletop computer  comprises computer hardware including a motherboard , central processing unit , random access memory , hard disk  and networking hardware . The tabletop computer  also includes a display  in the form of a projector which projects an image (i.e. the user interface) onto a tabletop surface. The tabletop computer  also includes an input module for receiving a user input from an input device. Using the input device, users of the tabletop computer manipulate objects displayed on the user interface.","In addition to the hardware, the tabletop computer  includes an operating system (such as the Microsoft Windows\u2122 XP operating system, which is produced and licensed by Microsoft Corporation) that resides on the hard disk and which co-operates with the hardware to provide an environment in which the software applications can be executed. In this regard, the hard disk  of the tabletop computer  is loaded with a display module for controlling a video output device which displays the user interface.","In the embodiment described herein, the objects are in the form of digital photographs, but it will be appreciated that other objects, such as text files, or computer generated graphical images could equally be displayed and manipulated. In an embodiment, input to the interface is provided by a touch sensitive surface of the tabletop onto which the image is projected.","In the embodiment described herein, the objects are in the form of digital images displayable on the tabletop. The images may colloquially be referred to as \u201cphotographs\u201d. The photographs are displayed as rectangular objects within the display area. Photographs can be moved across the tabletop by mimicking a \u201cdragging\u201d motion with a pointer, such as a finger, pen, stylus or cursor. The touch of the pointer is received by the input device and interpreted as an input. The photographs can be manipulated in other ways, such as, for example, moving, rotating and resizing, depending on the input.","If many photographs are displayed, the display area can become cluttered. This can detract from the productivity of the user. The embodiment therefore provides an interface element which can \u2018hold\u2019 objects not currently required by the user. The held objects are resized to assist in reducing clutter. Furthermore one embodiment of the invention allows the interface element to temporarily remove photographs from the display area. In a further embodiment they can be permanently deleted.","Referring to , there is shown a screen shot of a tabletop computer user interface  displaying the interface element , pictorially represented and hereafter referred to as a black hole. The black hole is typically circular in shape, as such a shape is instantly recognisable to a user. However, it will be understood that the black hole may take any suitable form. The black hole  forms part of the interface. The black hole  has a region of influence, which is part of the user interface . Objects  (such as the photographs) that enter into the region of influence or move within the region are affected by influence characteristics of the black hole . The black hole  comprises a centre portion  and a periphery , which divide up the region of influence. In one embodiment the centre portion has one type of influence and the periphery has another type of influence on objects in the region, depending on whether the object is in (or touches) the centre portion or is in (or touches) the periphery (without touching the centre portion).","Objects  moving in the periphery  automatically have their size changed according to whether the user input moves them towards or away from the centre of the black hole. The resizing is immediate and in proportion to the movement in order to give real-time feedback to the user input which cause the object to be moved. In particular when the object moves towards the centre it is reduced in size and when it moves away from the centre it is enlarged. This continuous feedback gives the appearance of the photograph being \u201csucked into\u201d the black hole, or \u201cspat out\u201d of the black hole, depending on the direction of movement.","In an embodiment the centre portion hides objects moved within it. In another embodiment, objects that touch the centre portion are deleted from the display. The centre portion may be the geometric centre point of the black hole, or it may be a (small) central area.",{"@attributes":{"id":"p-0061","num":"0062"},"figref":"FIG. 2","b":["212","214","216","212","210"]},"The interface displays objects by maintaining in memory the position of the objects, their scale and their orientation within the display. The display is repeatedly redrawn using a graphics API, such as OpenGL. Each time the display is redrawn, OpenGL draws a texture for that object, as well as decorations, at the correct position and orientation. When interaction occurs, the interface determines which object was selected, and where on the object the selection occurred.","The interface then determines in what way the input manipulates the selected object. This includes determining whether and how the input causes the selected object to be moved. The interface element determines whether the movement of the object causes it to be affected by the black hole. See Appendix A as an example of instructions (in the form of C++ code) for implementing this. Alternatively if the black hole is selected the interface element determines whether the manipulation of the black hole affects other objects.","In  it can be seen that the user has touched the tabletop or screen (or used a cursor directed by a mouse, track ball or other input device) over the object  and has dragged the object into the region of influence of the black hole. The finger pointer  moves closer to the centre of the black hole, rather than the centre of the object moving closer. The centre of the object just travels with the movement of the pointer. The black hole has recognised that the input has caused the object to move within this region of influence and has caused the object to be diminished in size as it moves. If it reaches the centre portion the photograph becomes hidden. See for example Appendix B below.","Photographs that are placed in the periphery of the black hole can be recovered by simply selecting them and dragging them out. This will cause them to be enlarged back to the size before they were influenced by the black hole.","If the back hole is resized the photographs within the region of influence change their size inverse proportionally. In one embodiment this is due to the scaled size of the object in the region of influence being shrunk in proportion to the size of the black hole, thus as the black hole is reduced in size its shrinking effect on the object diminishes. Thus another method to remove photographs from the black hole is to reduce the black hole size, such that photographs within the black hole grow in size and can be selected and dragged out from the region of influence of the black hole.","Objects that are placed in the region of influence of the black hole become attached. In other words, if the black hole is moved, then the objects move with the black hole.","Algorithms are employed to determine layering of photographs around the black hole. One algorithm keeps objects in the black hole as it is moved and another algorithm determines the size of objects within the region of influence based on the size of the image, the size of the black hole and the Euclidean distance between the centres of the each image and the black hole.","Another way of removing objects from the black hole is for the user to attempt to move the black hole into a zone of the display area in which the black hole is prohibited from entering, such as a personal space. Even though the black hole cannot be moved into the personal space, the objects stuck to the black hole can enter the space and will be dragged out as the user continues to move the pen\/stylus etc. Thus the black hole gets stuck on the border of personal space, while the photographs are moved into the personal space.","When the user holds a selected position on the black hole, this can activate one or more manipulations of black hole. In one embodiment the manipulation characteristic causes all the objects in the region of influence to be permanently deleted. In a further embodiment, the manipulation characteristic may also cause other images on the tabletop to move continuously towards black hole providing an appearance of \u201cgravity\u201d. One such other manipulation characteristic is to have images within a black hole move radially and other images on the tabletop to move away from the black hole, providing an appearance of \u201canti-gravity\u201d. Another is for the gravity to only affect objects with specifics characteristics.","Various other manipulation characteristics will be readily apparent to the person skilled in the field invention. Such manipulation characteristics provide the user with intuitive feedback.","In some embodiments the continuous movement occurs at a constant velocity. In another embodiment the continuous movement accelerates, while the input is active. The objects may then be given \u201cvirtual momentum\u201d and subjected to \u201cvirtual friction\u201d as described below in relation to \u201cflicking\u201d. In an embodiment the continuous movement is along a tangent to the central region of the black hole. In an embodiment the velocity of the movement for each object is proportional to the inverse of the distance between the centre points of the black hole and the object.","Objects on the tabletop may be subjected to \u201cflicking\u201d. Flicking provides an object with an associated momentum, which is counteracted by a virtual frictional force. (Flicking is described in: Margaret R. Minsky. Manipulating simulated objects with real-world gestures using a force and position sensitive screen. 18 (3): 195-203, 1984. ISSN 0097-8930. doi: http:\/\/doi.acm.org\/10.1145\/964965.808598 which is incorporated herein by reference).","When an image is flicked in the direction of a black hole and it encounters the region of influence, a virtual gravitational force can be simulated, which causes the object to accelerate towards the centre portion of the black hole. The algorithm employed maintains the momentum of the object and applies acceleration towards the centre of the black hole. The algorithm can closely model the physics of gravity to maintain a realistic feedback to the actions of the user. Thus, the object does not simply disappear, but rather, as the object hits the black hole, it will spiral inwards towards the centre of the black hole.","It is possible for the object to remain in an ongoing orbit. However, the algorithm can have a term included, such that when the component-wise change in velocity is in the opposite direction to the velocity, the acceleration towards the centre is increased. This causes the path of objects to favour spiralling in towards the centre of the black hole, even where the object was not intently aimed directly towards the centre. As an object encounters the centre portion it is captured and hidden. Thus an image can be flicked generally towards the black hole, and it will be sucked into the black hole even if the aim is not entirely accurate. In other words, the object need not be directed to the central region as long as it encounters the region of influence it will be drawn in. This can allow a user to delete an object even if the back hole is not within reach. See for example Appendix C & D.","If the flick of the object is too hard and the object has sufficient momentum, the object will pass the black hole without being drawn into the black hole. This can result in a gravitational slingshot effect. However, further modifications can be made to the algorithm to prevent sling-shotting.","In one embodiment black holes are prevented from being flicked. That is, they will not gain momentum, even though the object can be moved across the tabletop. Once the black hole is released, it will simply stop where it was released. However, objects within the black hole can maintain momentum. Therefore, when the black hole stops, objects within it can keep moving by virtue of their momentum and with thus fall out of the black hole. Alternatively objects within the black hole can maintain stationary inertia and thus when the black hole is moved too quickly the objects tend to move less quickly and will fall out of the black hole.","For each on-screen object (including the black hole object) the following is maintained:\n\n","For objects other than the black hole, the following is calculated on each screen redraw:\n\n",{"@attributes":{"id":"p-0080","num":"0087"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"bhd","mo":"=","mfrac":{"mrow":{"mi":"d","mo":"\u2062","msqrt":{"mn":"2"}},"mi":"s"}},"mo":","}}},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":{"@attributes":{"id":"ul0010-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":"where d is the square of the Euclidean distance between the centre of the black hole and the object and s is the current scale of the black hole;\n        \n        "}}}},"For objects other than the black hole, the following calculations are made:\n\n","When an object is in central portion of the black hole, the displayed scale is altered (after processing the desired scale) as follows:\n\n","There is a transformation from world coordinates to screen coordinates in order to display an object.","Two notions of layering are used to determine the final draw order of objects\u2014z-coordinate and layer. Objects drawn last will be shown occluding any objects below it, unless parts of the object are partially or wholly transparent. The black hole, for example, is transparent around its edges, opaque in the centre, with a transparency gradient between. The z coordinate of the object determines the final draw order (objects are drawn in order of decreasing z coordinate).","Whenever an object is selected, it is given the lowest z coordinate of any object in the same layer, thus it appears on top of those objects. Special objects, such as the black hole, are given a higher layer. Thus, the black hole is always shown on top of other objects and it is never obscured.","Objects can be flipped over; as if they were physical photographs placed on the table. In the touch interface, this was accomplished by for example placing two fingers on the image, one each in adjacent photo corners, and then dragging the fingers across the image to flip it. Alternative flipping techniques can also be employed, such as selecting a \u201chot spot\u201d (for example triangles superimposed on the corner of each object) and dragging it over the rest of the image.","The technique for flipping an object is shown in Appendix E to H. They take as arguments the (x, y) pixel coordinate on screen that is the current \u201ccontrol point\u201d used for the flip, e.g. the location of the stylus or finger. The first step is to convert this to object coordinates using the cached inverse transformation matrices used to position the object being flipped in the virtual environment (but before any flipping rotation transformation took place in the draw procedure). The x coordinate is normalised to make it comparable with the y coordinate (i.e. they are given equal weighting to determine the initial direction to flip).","If the flip has not already begun, the direction (xflip) is determined as the direction with the larger component (i.e. most distant from the centre of the image). And it is a \u201creverse\u201d flip if we are to the left of centre for a horizontal flip, or below centre for a vertical flip. The distance to flip (dist) is twice the position component (as points initially extend from \u02dc0.5 to 0.5), so dist lies in the range [\u02dc1.0, 1.0]. The angle to flip is the arccosine of the dist. We maintain state to continue a flip in the \u201csame\u201d direction once initiated, and to determine whether we are flipping to the reverse side, or back to the \u201cfront\u201d side. The flipping of the image itself occurs in the draw procedure.","If the object flipped is the black hole the hidden contents of the black hole can be displayed. This allows the user to select and drag objects out of the black hole.","The flipping technique described above is the subject of a related Australian provisional patent application entitled \u201cA System and Method for Manipulating Digital Images on a Computer Display\u201d filed in the name of Smart Internet Technology CRC Pty Ltd, and accorded provisional filing number AU2007 904927, which is incorporated herein by reference.","Consider the following scenario: a user plugs their digital camera into a computer loaded with an interface in accordance with an embodiment of the present invention. It holds a large number of photos taken from a recent holiday, so an object containing thumbnails for the photos is loaded. Sometimes, the thumbnail is insufficient quality to judge whether an image is the one desired to discuss, or to decide between two closely related photos. Dragging a thumbnail off the object causes a higher-quality copy of the thumbnail to be created. However, the user decides that they no longer need this copy, so they wish to delete it.","On a traditional computing interface, the user might drag the icon to a \u201cTrash Can\u201d or \u201cRecycle Bin\u201d, but in a virtual environment, this has a number of problems. The \u201ctrash\u201d is usually located at a fixed position on the display. On a physically large virtual interface, a user might not be able to reach the location of the object, and so they may wish to flick the object in the direction of the trash; alternatively they may wish to move the trash object around the environment. There may be multiple users and the \u201ctrash\u201d may only be oriented or easily accessible by a single user. Opening the trash to retrieve something is impractical on a tabletop computing system, particularly where an interface is designed to be intuitive to users not familiar with standard computer conventions. Offering a confirmation dialogue to confirm deletion, or a context menu to move an item to trash is also impractical. The trash may be obscured and an inexperienced user may inadvertently move an item over the trash, accidentally deleting it. An object may be displayed on a screen much larger than the \u201ctrash\u201d object, and without a mouse cursor, it might not be clear how to indicate that something should be moved to the trash. The user may also wish to partially hide the image without deleting the image.","To delete a photograph\/image (i.e. an object) using the black hole, the user drags the object (e.g. with a finger or stylus) towards the black hole. Once the user's finger (i.e. not the centre of the image; regardless of where it was touched) is within the influence of the black hole (bhd<1.0) the object begins to reduce in size. As the user's finger gets closer to the centre of the black hole, the object gets smaller, until it can no longer be seen at the centre of the black hole. Alternatively, if the user notices the reduction in size, and decides they do not actually want to delete\/hide the object, they can take it back out immediately.","The user may also wish to move the black hole. They do this simply by dragging it\u2014the black hole and all its contents (including items on its periphery or fringes, which may still be visible) are moved to the new location, maintaining their relative positions. As the black hole moves, objects which come near the black hole are affected, if their centres enter the fringe. If the black hole is then released, the objects influenced by the black hole are \u201ccaptured\u201d by the black hole, allowing the black hole to be used in a manner akin to a vacuum cleaner on the virtual environment.","After being released into the black hole, objects can be retrieved. Techniques for this vary, depending on the distance \u201cinto\u201d the Black hole the image is placed. If the object is on the fringe of the black hole, the object may be able to be moved out, provided some of the object \u201cpokes out\u201d from underneath the black hole. If no part of the object sticks out, the black hole may be made smaller, decreasing its effect on the object (i.e. as the black hole scale, s, is reduced, bhd becomes larger). When the object on the fringe becomes larger, and can then be moved away. However, a limit may be imposed on how small the black hole can be made. If an object is very near the black hole centre, it can be retrieved by moving the black hole to a \u201cdumping ground\u201d such as a personal space, where the black hole is not allowed to travel. Alternatively, repeatedly flicking the black hole can cause the images within the black hole to be left behind.","Although not required, the embodiments described with reference to the Figures can be implemented via an application programming interface (API) or as a series of libraries, for use by a developer, and can be included within another software application, such as a terminal or personal computer operating system or a portable computing device operating system. Generally, as program modules include routines, programs, objects, components, and data files that perform or assist in the performance of particular functions, it will be understood that the functionality of the software application may be distributed across a number of routines, objects and components to achieve the same functionality as the embodiment and the broader invention claimed herein. Such variations and modifications are within the purview of those skilled in the art.","It will be understood to persons skilled in the art of the invention that many modifications may be made without departing from the spirit and scope of the invention.",{"@attributes":{"id":"p-0098","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"[language={C++}]"},{"entry":"EFFECT 1 - Procedure on each screen redraw to determine"},{"entry":"whether each object is affected by the black hole"},{"entry":"bool Resource::blackHoled( ) {"},{"entry":"\u2003\u2003double dx = env->blackhole->position.x;"},{"entry":"\u2003\u2003double dy = env->blackhole->position.y;"},{"entry":"\u2003\u2003if (bh_moving"},{"entry":"\u2003\u2003\u2003\u2003\u2002|| (worldMPos.x == 0.0 && worldMPos.y == 0.0)"},{"entry":"\u2003\u2003\u2003\u2003\u2002|| userLock == NO_USER) {"},{"entry":"\u2003\u2003\u2003\u2003dx \u2212= position.x;"},{"entry":"\u2003\u2003\u2003\u2003dy \u2212= position.y;"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003dx \u2212= worldMPos.x;"},{"entry":"\u2003\u2003\u2003\u2003dy \u2212= worldMPos.y;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003double old_bhd = blackhole_distsq;"},{"entry":"\u2003\u2003bool oldinBH = inBlackhole;"},{"entry":"\u2003\u2003blackhole_distsq = M_SQRT2*(dx*dx + dy*dy) \/"},{"entry":"\u2003\u2003env->blackhole->scale;"},{"entry":"\u2003\u2003inBlackhole = blackhole_distsq < 1.0;"},{"entry":"\u2003\u2003wasInBlackhole = wasInBlackhole || inBlackhole;"},{"entry":"\u2003\u2003if ((inBlackhole && old_bhd != blackhole_distsq) ||"},{"entry":"\u2003\u2003\u2003\u2003\u2002inBlackhole != oldinBH) {"},{"entry":"\u2003\u2003\u2003\u2003pc.makeDirty( ); \/\/if it's not already dirty BH probably moved"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003if (residual) {"},{"entry":"\u2003\u2003\u2003\u2003\/\/we don't actually want the effective blackhole_distsq to"},{"entry":"\u2003\u2003\u2003\u2003change"},{"entry":"\u2003\u2003\u2003\u2003residual_bh_distsq = old_bhd \/ blackhole_distsq;"},{"entry":"\u2003\u2003\u2003\u2003residual = false;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003if (!inBlackhole) {"},{"entry":"\u2003\u2003\u2003\u2003\/\/we reset this as soon as we get taken out of the blackhole"},{"entry":"\u2003\u2003\u2003\u2003residual_bh_distsq = 1.0;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return"},{"entry":"\u2003\u2003\u2003\u2003(bh_trapped && blackhole_distsq <"},{"entry":"\u2003\u2003\u2003\u2003RConfig::MIN_SCALE_FOR_DRAW)\u2003||"},{"entry":"\u2003\u2003\u2003\u2003(link && link->getParent( )->isInBlackhole( ));"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0099","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX B"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Procedure to determine what size to display an"},{"entry":"object affected by the black hole"},{"entry":"void Resource::wormHole( ) {"},{"entry":"\u2003\u2003inBlackhole = blackhole_distsq < 1.0;"},{"entry":"\u2003\u2003if (inBlackhole) {"},{"entry":"\u2003\u2003\u2003\u2003if (!bh_moving && (userLock != NO_USER || bh_trapped)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/scale at the mouse cursor to keep its reltive position"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003glTranslatef(currMPos.x, currMPos.y, 0);"},{"entry":"\u2003\u2003\u2003\u2003}"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003glScalef(blackhole_distsq*residual_bh_distsq,","\/\/ x-scale"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003blackhole_distsq*residual_bh_distsq,","\/\/ y-scale"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20031.0);","\/\/ z-scale"]},{"entry":"\u2003\u2003\u2003\u2003if (!bh_moving && (userLock != NO_USER ||"},{"entry":"\u2003\u2003\u2003\u2003bh_trapped)) {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003glTranslatef(\u2212currMPos.x, \u2212currMPos.y, 0);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003if (!inBlackhole && bh_trapped) {"},{"entry":"\u2003\u2003\u2003\u2003bh_trapped = false;"},{"entry":"\u2003\u2003\u2003\u2003userLock = NO_USER;"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0100","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX C"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Position update procedure for momentum when near"},{"entry":"the black hole"},{"entry":"\/**"},{"entry":"\u2009*"},{"entry":"\u2009*\\return true if the Animation has finished"},{"entry":"\u2009*\/"},{"entry":"bool Momentum::rel_update(unsigned ms)"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ use \\f$ s = ut + \\frac{1}{2}at{circumflex over (\u2009)}2 \\f$ -- classic physics formula for"},{"entry":"\u2003\u2003\/\/ displacement given initial velocity and acceleration over time"},{"entry":"\u2003\u2003float dt = 0.001*(ms \u2212 lastms);"},{"entry":"\u2003\u2003lastms = ms;"},{"entry":"\u2003\u2003if (r->selectedBy( ) != user) {"},{"entry":"\u2003\u2003\u2003\u2003\/\/ if someone else touched it, we stop"},{"entry":"\u2003\u2003\u2003\u2003if (r->selectedBy( ) >= 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\u2003\u2003\/\/ if we were just deselected, we still want border colour"},{"entry":"\u2003\u2003\u2003\u2003\/\/ and access restrictions, and a deselect when we stop"},{"entry":"\u2003\u2003\u2003\u2003killselect = true;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ see if we've been touched again by the same user, if so, stop"},{"entry":"\u2003\u2003if (r->clickPos != clickPos)"},{"entry":"\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\/\/ DEcelleration due to friction\/drag is directed against the x\/y"},{"entry":"\u2003\u2003\/\/ components of _velocity_. Magnitude is just decel --"},{"entry":"\u2003\u2003\/\/ the (constant) decelleration due to friction\/drag"},{"entry":"\u2003\u2003float vtheta = xv == 0.0 ? M_PI\/2.0 : atanf(fabs(yv \/ xv));"},{"entry":"\u2003\u2003float accel_x = (xv < 0 ? 1.0 : \u22121.0) * cosf(vtheta) * decel;"},{"entry":"\u2003\u2003float accel_y = (yv < 0 ? 1.0 : \u22121.0) * sinf(vtheta) * decel;"},{"entry":"\u2003\u2003\/\/ change the accelleration vector if we're near the black hole"},{"entry":"\u2003\u2003\/\/ by adding a component directed towards the centre of the blackhole"},{"entry":"\u2003\u2003\/\/ of magnitude BLACKHOLE_ACCEL"},{"entry":"\u2003\u2003if (r->blackholeDist( ) < 1.0) {"},{"entry":"\u2003\u2003\u2003\u2003\/* note we use screen positions before the blackhole warping *\/"},{"entry":"\u2003\u2003\u2003\u2003float dx = r->env->blackhole->getPC( ).getScreen( ).x"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2212 r->getPC( ).getScreen( ).x;"},{"entry":"\u2003\u2003\u2003\u2003float dy = r->env->blackhole->getPC( ).getScreen( ).y"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2212 r->getPC( ).getScreen( ).y;"},{"entry":"\u2003\u2003\u2003\u2003float theta = dx == 0.0 ? M_PI\/2.0 : atanf(fabs(dy \/ dx));"},{"entry":"\u2003\u2003\u2003\u2003accel_x += (dx < 0 ? \u22121.0 : 1.0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003* RConfig::BLACKHOLE_ACCEL"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003* cosf(theta)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003* (dx * xv < 0.0 ? 1.5 : 1.0);"},{"entry":"\u2003\u2003\u2003\u2003accel_y += (dy < 0 ? 1.0 : \u22121.0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003* RConfig::BLACKHOLE_ACCEL"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003* sinf(theta)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003* (dy * yv > 0.0 ? 1.5 : 1.0);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ update velocity and displacement from the acceleration vector"},{"entry":"\u2003\u2003float xvdiff = accel_x * dt;"},{"entry":"\u2003\u2003float yvdiff = accel_y * dt;"},{"entry":"\u2003\u2003float xdiff = xv * dt + 0.5 * accel_x * dt * dt;"},{"entry":"\u2003\u2003float ydiff = yv * dt + 0.5 * accel_y * dt * dt;"},{"entry":"\u2003\u2003xv = (fabs(xvdiff) >= fabs(xv) && r->blackholeDist( ) >= 1.0) ?"},{"entry":"\u2003\u2003\u2003\u20030 :"},{"entry":"\u2003\u2003\u2003\u2003xv + xvdiff;"},{"entry":"\u2003\u2003yv = (fabs(yvdiff) >= fabs(yv) && r->blackholeDist( ) >= 1.0) ?"},{"entry":"\u2003\u2003\u2003\u20030 :"},{"entry":"\u2003\u2003\u2003\u2003yv + yvdiff;"},{"entry":"\u2003\u2003if (!finite(xv) || !finite(yv)) {"},{"entry":"\u2003\u2003\u2003\u2002xv = yv = 0.0f;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ stop when less than 10 pixels \/ second -- why 10? => ~frame"},{"entry":"\u2003\u2003\/\/ redraw also stop when we're \u201ctrapped\u201d by the centre of the"},{"entry":"\u2003\u2003Blackhole"},{"entry":"\u2003\u2003if (r->blackholeDist( ) < RConfig::BLACKHOLE_TRAPDIST ||"},{"entry":"\u2003\u2003\u2003\u2003\u2002(r->blackholeDist( ) >= 1.0 && fabs(xv) <= 20 &&"},{"entry":"\u2003\u2003\u2003\u2003\u2002fabs(yv) <= 20)) {"},{"entry":"\u2003\u2003\u2003\u2003if (killselect)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003r->unSelect(user);"},{"entry":"\u2003\u2003\u2003\u2003if (r->blackholeDist( ) >= 1.0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003r->settle( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ remember our desired position"},{"entry":"\u2003\u2003x0 = x0 + xdiff;"},{"entry":"\u2003\u2003y0 = y0 + ydiff;"},{"entry":"\u2003\u2003\/\/ then move to the closest screen\/pixel location, restricting to bounds"},{"entry":"\u2003\u2003r->moveto(static_cast < int >(roundf(x0)),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003static_cast < int >(roundf(y0)));"},{"entry":"\u2003\u2003if (r->getPC( ).getRealScreen( ).x + 3 >= r->env->getSurface( )->w"},{"entry":"\u2003\u2003\u2003\u2003\u2002&& RConfig::DATAWALL_SEND && !sent) {"},{"entry":"\u2003\u2003\u2003\u2003\/\/ trigger send at right side of screen"},{"entry":"\u2003\u2003\u2003\u2003sent = true;"},{"entry":"\u2003\u2003\u2003\u2003datawall_send(r);"},{"entry":"\u2003\u2003} else if (r->getPC( ).getRealScreen( ).x <= 3"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&& RConfig::MAGICMIRROR_SEND && !sent) {"},{"entry":"\u2003\u2003\u2003\u2003\/\/ trigger send at left side of screen"},{"entry":"\u2003\u2003\u2003\u2003sent = true;"},{"entry":"\u2003\u2003\u2003\u2003datawall_send(r, true);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return false;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0101","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX D"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Procedures controlling the triggering"},{"entry":"of a momentum animation"},{"entry":"void Mover::updatePositions( ) {"},{"entry":"\u2003\u2003if (positions.size( ) == RConfig::VELOCITY_WINDOW)"},{"entry":"\u2003\u2003\u2003\u2003positions.pop_back( );"},{"entry":"\u2003\u2003positions.push_front(std::make_pair(current_time,"},{"entry":"\u2003\u2003current_xy_position));"},{"entry":"}"},{"entry":"MoveTracker* Mover::release( ) {"},{"entry":"\u2003\u2003if\u2003(!RConfig::DO_MOMENTUM"},{"entry":"\u2003\u2003\u2003\u2003\u2002|| positions.size( ) < RConfig::VELOCITY_WINDOW"},{"entry":"\u2003\u2003\u2003\u2003\u2002|| r->hasLink( ))"},{"entry":"\u2003\u2003\u2003\u2003return ResourceGesture::release( );"},{"entry":"\u2003\u2003float dx = positions.front( ).second.x \u2212 positions.back( ).second.x;"},{"entry":"\u2003\u2003float dy = positions.front( ).second.y \u2212 positions.back( ).second.y;"},{"entry":"\u2003\u2003float dt = (positions.front( ).first \u2212 positions.back( ).first) \/ 1000.0f;"},{"entry":"\u2003\u2003float vel_sq = (dx * dx + dy * dy) \/ (dt * dt);"},{"entry":"\u2003\u2003if (vel_sq > RConfig::ESCAPE_VELOCITY && r"},{"entry":"\u2003\u2003!= r->env->blackhole) {"},{"entry":"\u2003\u2003\u2003\u2003r->env->addAnimation(new Momentum(r,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"dx \/ dt, dy \/ dt,"]},{"entry":[{},"positions.front( ).second.x,"]},{"entry":[{},"positions.front( ).second.y));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return ResourceGesture::release( );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0102","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"APPENDIX E"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Procedure for deciding whether to initiate"]},{"entry":[{},"a flip"]},{"entry":[{},"bool Image::flipSelected( ) {"]},{"entry":[{},"\u2003\u2003GLfloat x = fabsf(currMPos.x), y = fabsf(currMPos.y);"]},{"entry":[{},"\u2003\u2003return !inBlackhole &&"]},{"entry":[{},"\u2003\u2003\u2003\u2003(y \u2212 x > RConfig::CORNER_PROP ||"]},{"entry":[{},"\u2003\u2003\u2003\u2003x \u2212 y > 0.5*aspect \u2212 0.5 + RConfig::CORNER_PROP);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0103","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX F"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Procedures for flipping an object, given the current"},{"entry":"contact position on the screen"},{"entry":"bool Image::flipto(int screen_x, int screen_y) {"},{"entry":"\u2003\u2003P3<GLfloat> avgPos;"},{"entry":"\u2003\u2003\/\/determine in texture coords where the control point is"},{"entry":"\u2003\u2003setObject(avgPos, screen_x, screen_y, true);"},{"entry":"\u2003\u2003avgPos.x \/= aspect; \/\/normalise between 0 and 1"},{"entry":"\u2003\u2003\/\/(we always flip along the bigger direction)"},{"entry":"\u2003\u2003float cosval, dist;"},{"entry":"\u2003\u2003if (!flipping) { \/\/not already flipping"},{"entry":"\u2003\u2003\u2003\u2003xflip = fabs(avgPos.y) > fabs(avgPos.x);"},{"entry":"\u2003\u2003\u2003\u2003dist = xflip ? avgPos.y*2.0 : avgPos.x*2.0;"},{"entry":"\u2003\u2003\u2003\u2003backflip = dist < 0;"},{"entry":"\u2003\u2003\u2003\u2003wasflipped = flipped;"},{"entry":"\u2003\u2003\u2003\u2003flipping = true;"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003dist = xflip ? avgPos.y*2.0 : avgPos.x*2.0;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/\/now the flipping state toggles if the distance has changed in sign"},{"entry":"\u2003\u2003flipped = wasflipped != (backflip != dist < 0);"},{"entry":"\u2003\u2003\/\/determine the angle to rotate the image"},{"entry":"\u2003\u2003cosval = fabs(dist);"},{"entry":"\u2003\u2003if (cosval < 1.0) {"},{"entry":"\u2003\u2003\u2003\u2003flipangle = acosf(cosval); \/\/between 0 and 90"},{"entry":"\u2003\u2003\u2003\u2003\/\/now, if we started on the \u201cwrong\u201d side, we rotate the other way"},{"entry":"\u2003\u2003\u2003\u2003\/\/we also do a magical flip at the centre if flipped"},{"entry":"\u2003\u2003\u2003\u2003if (xflip == backflip)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003flipangle *= \u22121.0;"},{"entry":"\u2003\u2003\u2003\u2003\/\/now we are here, whenever we have a change from"},{"entry":"\u2003\u2003\u2003\u2003\/\/ the start, we want to subtract from 180 degrees"},{"entry":"\u2003\u2003\u2003\u2003if (flipped != wasflipped)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003flipangle = \u2212flipangle;"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003\/\/dist is > 1.0, so touch point moved away -- don't flip"},{"entry":"\u2003\u2003\u2003\u2003flipangle = 0.0;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003pc.makeDirty( );"},{"entry":"\u2003\u2003return true;"},{"entry":"}"},{"entry":"void Image::drawPartialFlip( ) {"},{"entry":"\u2003\u2003glPushMatrix( );"},{"entry":"\u2003\u2003glRotatef(flipangle*RAD2DEG,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003xflip ? 1.0 : 0.0,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003xflip ? 0.0 : 1.0,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u20030.0);"},{"entry":"\u2003\u2003if (flipped) {"},{"entry":"\u2003\u2003\u2003\u2003drawReverse( );"},{"entry":"\u2003\u2003\u2003\u2003\/\/also draw the back if we are flipping"},{"entry":"\u2003\u2003\u2003\u2003if (flipping) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003glRotatef(180,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003xflip ? 1.0 : 0.0,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003xflip ? 0.0 : 1.0,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u20030.0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003glCallList(*model);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003drawTexture( );"},{"entry":"\u2003\u2003\u2003\u2003if (flipping) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003glRotatef(180,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003xflip ? 1.0 : 0.0,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003xflip ? 0.0 : 1.0,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20030.0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003drawReverse( ); \/* if rendering ?? *\/"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003glPopMatrix( );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0104","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX G"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Procedure for changing the aspect ratio"},{"entry":"of the Frame, using the flip widgets"},{"entry":"bool SmartFrame::flipto(int x, int y) {"},{"entry":"\u2003\u2003GLint realy = flip(y);"},{"entry":"\u2003\u2003P3<GLfloat> avgPos;"},{"entry":"\u2003\u2003setWorld(avgPos, x, realy, true);"},{"entry":"\u2003\u2003\/\/find out which way the aspect should be changed"},{"entry":"\u2003\u2003if (!flipping) {"},{"entry":"\u2003\u2003\u2003\u2003xflip = fabs(avgPos.y) > fabs(avgPos.x);"},{"entry":"\u2003\u2003\u2003\u2003wasflipped = flipped;"},{"entry":"\u2003\u2003\u2003\u2003flipping = true;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003double dx = pc.getScreen( ).x \u2212 x;"},{"entry":"\u2003\u2003double dy = pc.getScreen( ).y \u2212 realy;"},{"entry":"\u2003\u2003if (fabs(dx) <= 1 && fabs(dy) <= 1)"},{"entry":"\u2003\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003double delta = sqrt(dx*dx + dy*dy);"},{"entry":"\u2003\u2003if (xflip) {"},{"entry":"\u2003\u2003\u2003\u2003\/\/if xflip, aspect in centre is inf, and we need to change the scale"},{"entry":"\u2003\u2003\u2003\u2003changeAspect(1.0 \/ (delta \/ (clickPosLine \/ (1.0 \/ clickAspect))));"},{"entry":"\u2003\u2003\u2003\u2003setScale(delta \/ (clickPosLine \/ clickScale), false, false);"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003changeAspect(delta \/ (clickPosLine \/ clickAspect));"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003pc.makeDirty( );"},{"entry":"\u2003\u2003return true;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0105","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX H"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Procedure for performing a \u201cflow\u201d layout"},{"entry":"of attachments on the back of a flipped object"},{"entry":"void FlowLayout::doFlowLayout(Layout::COLL &col) {"},{"entry":"\u2003\u2003const double pad = padding * parent->getScale( );"},{"entry":"\u2003\u2003const double mar = margin * parent->getScale( ) \u2212 pad; \/\/can go"},{"entry":"\u2003\u2003negative"},{"entry":"\u2003\u2003const double maxw = parent->estWidth( ) \u2212 2*mar;"},{"entry":"\u2003\u2003const double maxh = parent->estHeight( ) \u2212 2*mar;"},{"entry":"\u2003\u2003double y = \u2212(maxh * \u22120.5 + pad + mar);"},{"entry":"\u2003\u2003COLL::iterator it = col.begin( );"},{"entry":"\u2003\u2003const COLL::iterator end = col.end( );"},{"entry":"\u2003\u2003const double rads = parent->getRads( );"},{"entry":"\u2003\u2003while (it != end) {"},{"entry":"\u2003\u2003\u2003\u2003COLL row;"},{"entry":"\u2003\u2003\u2003\u2003double h = (*it)->estHeight( );"},{"entry":"\u2003\u2003\u2003\u2003double w = (*it)->estWidth( ) + pad;"},{"entry":"\u2003\u2003\u2003\u2003row.push_back(*it++); \/\/ put at least one element in the row"},{"entry":"\u2003\u2003\u2003\u2003for (; it != end; ++it) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ fill the row"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (w + pad + (*it)->estWidth( ) > maxw)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003w += pad + (*it)->estWidth( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ check if the row height must be increased"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if ((*it)->estHeight( ) > h)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003h = (*it)->estHeight( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003row.push_back(*it);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003COLL::iterator rit = row.begin( );"},{"entry":"\u2003\u2003\u2003\u2003const COLL::iterator rend = row.end( );"},{"entry":"\u2003\u2003\u2003\u2003double x = maxw * \u22120.5 + pad + mar;"},{"entry":"\u2003\u2003\u2003\u2003y += \u2212(h * 0.5);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ now adjust the positions of the objects"},{"entry":"\u2003\u2003\u2003\u2003for (; rit != rend; ++rit) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003x += (*rit)->estWidth( ) * 0.5;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (!(*rit)->isManip( )) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ only move things not being manipulated"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003P3<GLfloat> oldPosition((*rit)->getPosition( ));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003GLfloat oldRot = (*rit)->getRads( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(*rit)->rotaterad(rads);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(*rit)->stealPosition( ).set(x*cos(\u2212rads) \u2212"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"y*sin(\u2212rads), x*sin(\u2212rads) + y*cos(\u2212rads),"]},{"entry":[{},"(parent->isFlipped( ) ?"]},{"entry":[{},"0.0001f :"]},{"entry":[{},"\u22120.0001f));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(*rit)->stealPosition( ) += parent->getPosition( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (lastSettled == rit->addr( )) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ if we were the last thing added,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003animate the movement"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(*rit)->env->addAnimation(new LinearPath(*rit,"},{"entry":"oldPosition, (*rit) ->getPosition( ), 200), Animation::REPLACE);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(*rit)->env-"},{"entry":">addAnimation(new LinearSpin(*rit, oldRot, rads, 200),"},{"entry":"Animation::REPLACE);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003lastSettled = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003x += (*rit)->estWidth( ) * 0.5 + pad;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003y += \u2212(h * 0.5 + pad);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003lastAdded = 0;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order to provide a better understanding of the present invention, preferred embodiments will now be described, by way of example only, with reference to the accompanying drawings, in which:",{"@attributes":{"id":"p-0050","num":"0051"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0051","num":"0052"},"figref":"FIG. 2"}]},"DETDESC":[{},{}]}
