---
title: Method for upgrading embedded configuration databases
abstract: The present invention provides a method for upgrading embedded configuration databases while a network device is operating and with minimal disruption to network device operation. While a network device is operating and using an embedded primary configuration database, an embedded backup configuration database stops performing as a backup database and is upgraded. The upgraded configuration database is then switched over to become the primary configuration database. The original primary configuration database may immediately become the backup configuration database, or the original primary configuration database may remain unchanged until the upgrade is committed. If the upgrade is not committed, for example, due to errors, then the original primary configuration database may be quickly switched over to again become the primary configuration database. As a result, embedded configuration databases may be upgraded while a network device is operating and with minimal disruption to network device operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07130870&OS=07130870&RS=07130870
owner: Ciena Corporation
number: 07130870
owner_city: Linthicum
owner_country: US
publication_date: 20000804
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation-in-part of application Ser. No. 09\/625,101 filed Jul. 24, 2000 now abandoned which is a C-I-P of Ser. No. 09\/616,477 filed Jul. 14, 2000 which is a C-I-P of Ser. No 09\/613,940 filed Jul. 11, 2000 which is a C-I-P of Ser. No. 09\/596,055 filed Jun. 16, 2000 which is a C-I-P of Ser. No. 09\/593,034 filed Jun. 13, 2000 which is a C-I-P of Ser. NO. 09\/574,440 filed May 20, 2000 and Ser. No. 09\/591,193 filed Jun. 9, 2000 which is a C-I-P of Ser. No. 09\/588,398 filed Jun. 6, 2000 which is a C-I-P of Ser. No. 09\/574,341 filed May 20, 2000; and Ser. No. 09\/574,343 filed May 20, 2000.","In general, element management systems (EMS) are designed to configure and manage a particular type of network device (e.g., switch, router, hybrid switch-router), and network management systems (NMSs) are used to configure and manage multiple heterogeneous and\/or homogeneous network devices. Both an NMS and an EMS may interpret data gathered by programs running on a network device relevant to network configuration, security, accounting, statistics, and fault logging and present the interpretation of this data to a network administrator. To configure and manage a network device, therefore, the EMS and\/or NMS must be synchronized with all programs running on each network device. That is, the EMS and\/or NMS and all programs running on the network device must use the same data in the same way and must perform in expected ways. Hereinafter, the term \u201cNMS\u201d is used for both element and network management systems.","The most common approach to represent network attributes and configuration data within an NMS is to use the Simple Network Management Protocol (SNMP) and Management Information Bases (MIBs). One of the inherent shortcomings of SNMP and MIBs is the inability to represent all necessary relationships between tables and attributes. MIBs provide a straightforward way to define tables with attributes but offer an inadequate solution for representing relationships between tables or attributes within tables. Since networking builds off many complex hierarchical models, relationships are fundamental to designing and building networking software. To accommodate this SNMP shortcoming, relationships are often hard-coded within the network device and NMS programs. This makes it very difficult to understand the actual ramifications of subsequent enhancements to the software. Often, relationships are \u201cdiscovered\u201d during implementation; sometimes these discoveries limit or invalidate the actual implementation.","Moreover, the hard-coded relationships (i.e., integration interfaces) may be disbursed through out the programs at non-standardized, de-centralized locations. If a program executing on a network device (i.e., embedded program) or the NMS is modified to fix a problem or upgraded to add a new feature, integration interfaces in multiple other programs typically also need to be changed. For example, an integration interface may require new parameters and\/or additional or different shared data. These interdependencies must be manually modified to address the changes and ensure that the programs and NMS continue to work together properly.","Complex implementations of distributed system software have many integration interfaces that must be properly synchronized in order for the system to work properly, and manual synchronization of integration interfaces is extremely error-prone. If one or more interdependency is not completely addressed, errors may occur and\/or the network device may crash. Moreover, some time may pass before the integration interface mis-match causes a problem making error diagnosis more difficult. Often a network device crash may bring down an entire network. More concerning is the fact that many interdependencies go undocumented by the programmers, and because the interdependencies are de-centralized, synchronization of all integration interfaces is difficult if not impossible, especially given the size and complexity of today's networks. In addition, over time, as programmers come and go, interdependency tracking becomes even more difficult.","The difficulties attendant to synchronizing all integration interfaces in a complex networking environment result in considerable development time to get a program and\/or an NMS program ready for release, and even extensive testing may not detect all errors. Consequently, initial release of these programs as well as future modifications and upgrades are delayed while the programs are repeatedly modified and retested. New software releases to customers are often limited to a few times a year at best. In some cases, only a single release per year is feasible. Moreover, these interdependencies often prevent modular releases of one program since many or all programs may need to be modified to reflect a change in the one program and simultaneously released.","Unfortunately, limiting the number of software releases also delays the release of new hardware. New hardware modules, usually ready to ship between major software releases, cannot be shipped more than a few times a year since the release of the hardware must be coordinated with the release of the new software designed to run the new hardware.","Aside from program interdependencies, the network device programs and NMS program also have data dependencies. A classic problem with most network management systems is lack of data synchronization between the NMS and the actual network device. Typically a network device's embedded software and NMS have independent views of the configuration data, and generate considerable network traffic to keep these views \u201capproximately\u201d synchronized. Data synchronization issues can result in service outage, the need to re-provision \u201clost\u201d configuration data, and worst yet entire network outages. For example, in current systems, the NMS stores configuration data in an NMS repository. The NMS then uses SNMP to issue a series of \u201csets\u201d to the network device. Errors may occur during these multiple sets such that the data used by the NMS in the NMS repository is different from the data used by the programs executing on the network device. For example, errors may occur during the multiple SNMP \u201csets\u201d. In addition, because SNMP typically runs over UDP (an unreliable protocol), an attribute may or may not be \u201cset\u201d during a series of sets since any \u201cset\u201d may or may not get to the designated network device.","In addition, network devices typically have console interfaces, and network administrators may change the run time data by changing the device configuration directly through the console using command line interface (CLI) commands. Until the new configuration data is accurately and quickly sent to the NMS and stored in the NMS repository, the NMS and the programs running on the network device will use different data, which may result in errors. Synchronization with CLI changes is often the responsibility of the NMS which must re-read large portions of information to ensure that it is properly synchronized. Further CLI changes may be made during this time, and again, the synchronization procedure can become out of date, leaving the NMS data out-of-sync even after it performs its synchronization procedure.","More troublesome, is the situation where the NMS periodically synchronizes the NMS data with the data used by the network device by overwriting the data used in by the network device with the NMS data from the NMS repository. If the repository was not updated with the changes made by the network administrator, then the changes will be lost. This may cause errors, may cause customers to lose service if provisioning records are lost, and\/or may cause a network device crash or network crash.","The present invention provides a method for upgrading embedded configuration databases while a network device is operating and with minimal disruption to network device operation. While a network device is operating and using an embedded primary configuration database, an embedded backup configuration database stops performing as a backup database and is upgraded. The upgraded configuration database is then switched over to become the primary configuration database. The original primary configuration database may immediately become the backup configuration database, or the original primary configuration database may remain unchanged until the upgrade is committed. If the upgrade is not committed, for example, due to errors, then the original primary configuration database may be quickly switched over to again become the primary configuration database. As a result, embedded configuration databases may be upgraded while a network device is operating and with minimal disruption to network device operation.","In one aspect, the present invention provides a method of operating a network device including an embedded first configuration database and an embedded second configuration database, including operating the network device with the first configuration database as a primary configuration database, operating the network device with the second configuration database as a backup configuration database, replicating modifications made to the first configuration database to the second configuration database, detecting a configuration database upgrade operation, stopping replication of data from the first configuration database to the second configuration database, upgrading the second configuration database without disrupting operation of the network device and the first configuration database, and switching over to use the second configuration database as the primary configuration database. The method may include detecting commitment of configuration database upgrade, operating the network device with the first configuration database as a backup configuration database, and replicating modifications made to the second configuration database to the first configuration database. The method may include detecting errors with the configuration database upgrade, and switching over to use the first configuration database as the primary configuration database.","Upgrading the second configuration database may include receiving a configuration control file from a network management server and executing the configuration control file and may further include receiving a data definition language (DDL) file including structured query language (SQL) commands, where executing the configuration control file comprises executing the SQL commands to construct an upgraded database schema in the second configuration database. Detecting a configuration database upgrade operation may include receiving an upgrade notification from a network management system server, which may include receiving SQL commands from the network management server and executing the SQL commands. Executing the SQL commands may include writing a software load record indicating a configuration database upgrade in a table within the first configuration database, and the table may be a software management system table. The SQL commands may be received within a DDL file. Detecting a configuration database upgrade operation may further include detecting the software load record indicating the configuration database upgrade through a master system resiliency manager (SRM) and notifying a first slave SRM associated with the second configuration database to perform a configuration database upgrade. Stopping replication of data from the first configuration database to the second configuration database may include causing the second configuration database to cease replicating data changes made to the first configuration database. Before detecting a configuration database upgrade operation the method may further include receiving upgraded applications from a network management server and\/or receiving new applications from a network management server. Detecting commitment of configuration database upgrade may include saving the upgraded second configuration database to persistent memory.","The network device may include a first printed circuit board including a first processor component and operating the network device with the first configuration database as a primary configuration database may include maintaining the first configuration database through the first processor component and operating the network device with the first printed circuit board as a primary printed circuit board and the first processor component as a primary processor component. The network device may further include a second printed circuit board including a second processor component and operating the network device with the second configuration database as a backup configuration database may include maintaining the second configuration database through the second processor component and operating the network device with the second printed circuit board as a backup printed circuit board and the second processor component as a backup processor component. Switching over to use the second configuration database as the primary configuration database may include switching over to use the second printed circuit board and second processor component as the primary printed circuit board and the primary processor.","In another aspect, the present invention provides a method of managing a telecommunications network including operating a network device with a first configuration database as a primary configuration database, operating the network device with a second configuration database as a backup configuration database, replicating modifications made to the first configuration database to the second configuration database, sending SQL commands from network management server to the network device, executing the SQL commands to write a software load record indicating a configuration database upgrade in a table within the first configuration database, replicating the changes to the first configuration database to the second configuration database, stopping replication of data from the first configuration database to the second configuration database, upgrading the second configuration database without disrupting operation of the network device and the first configuration database, and switching over to use the second configuration database as the primary configuration database.","A modular software architecture solves some of the more common scenarios seen in existing architectures when software is upgraded or new features are deployed. Software modularity involves functionally dividing a software system into individual modules or processes, which are then designed and implemented independently. Inter-process communication (IPC) between the processes is carried out through message passing in accordance with well-defined application programming interfaces (APIs) generated from the same logical system model using the same code generation system. A database process is used to maintain a primary data repository within the computer system\/network device, and APIs for the database process are also generated from the same logical system model and using the same code generation system ensuring that all the processes access the same data in the same way. Another database process is used to maintain a secondary data repository external to the computer system\/network device; this database receives all of its data by exact database replication from the primary database.","A protected memory feature also helps enforce the separation of modules. Modules are compiled and linked as separate programs, and each program runs in its own protected memory space. In addition, each program is addressed with an abstract communication handle, or logical name. The logical name is location-independent; it can live on any card in the system. The logical name is resolved to a physical card\/process during communication. If, for example, a backup process takes over for a failed primary process, it assumes ownership of the logical name and registers its name to allow other processes to re-resolve the logical name to the new physical card\/process. Once complete, the processes continue to communicate with the same logical name, unaware of the fact that a switchover just occurred.","Like certain existing architectures, the modular software architecture dynamically loads applications as needed. Beyond prior architectures, however, the modular software architecture removes significant application dependent data from the kernel and minimizes the link between software and hardware. Instead, under the modular software architecture, the applications themselves gather necessary information (i.e., metadata and instance data) from a variety of sources, for example, text files, JAVA class files and database views, which may be provided at run time or through the logical system model.","Metadata facilitates customization of the execution behavior of software processes without modifying the operating system software image. A modular software architecture makes writing applications\u2014especially distributed applications\u2014more difficult, but metadata provides seamless extensibility allowing new software processes to be added and existing software processes to be upgraded or downgraded while the operating system is running. In one embodiment, the kernel includes operating system software, standard system services software and modular system services software. Even portions of the kernel may be hot upgraded under certain circumstances. Examples of metadata include, customization text files used by software device drivers; JAVA class files that are dynamically instantiated using reflection; registration and deregistration protocols that enable the addition and deletion of software services without system disruption; and database view definitions that provide many varied views of the logical system model. Each of these and other examples are described below.","The embodiment described below includes a network computer system with a loosely coupled distributed processing system. It should be understood, however, that the computer system could also be a central processing system or a combination of distributed and central processing and either loosely or tightly coupled. In addition, the computer system described below is a network switch for use in, for example, the Internet, wide area networks (WAN) or local area networks (LAN). It should be understood, however, that the modular software architecture can be implemented on any network device (including routers) or other types of computer systems and is not restricted to a network switch.","A distributed processing system is a collection of independent computers that appear to the user of the system as a single computer. Referring to , computer system  includes a centralized processor  with a control processor subsystem  that executes an instance of the kernel  including master control programs and server programs to actively control system operation by performing a major portion of the control functions (e.g., booting and system management) for the system. In addition, computer system  includes multiple line cards \u2013. Each line card includes a control processor subsystem \u2013, which runs an instance of the kernel \u2013including slave and client programs as well as line card specific software applications. Each control processor subsystem , \u2013operates in an autonomous fashion but the software presents computer system  to the user as a single computer.","Each control processor subsystem includes a processor integrated circuit (chip) , \u2013, for example, a Motorola 8260 or an Intel Pentium processor. The control processor subsystem also includes a memory subsystem , \u2013including a combination of non-volatile or persistent (e.g., PROM and flash memory) and volatile (e.g., SRAM and DRAM) memory components. Computer system  also includes an internal communication bus  connected to each processor , \u2013. In one embodiment, the communication bus is a switched Fast Ethernet providing 100 Mb of dedicated bandwidth to each processor allowing the distributed processors to exchange control information at high frequencies. A backup or redundant Ethernet switch may also be connected to each board such that if the primary Ethernet switch fails, the boards can fail-over to the backup Ethernet switch.","In this example, Ethernet  provides an out-of-band control path, meaning that control information passes over Ethernet  but the network data being switched by computer system  passes to and from external network connections \u2013over a separate data path . External network control data is passed from the line cards to the central processor over Ethernet . This external network control data is also assigned a high priority when passed over the Ethernet to ensure that it is not dropped during periods of heavy traffic on the Ethernet.","In addition, another bus  is provided for low level system service operations, including, for example, the detection of newly installed (or removed) hardware, reset and interrupt control and real time clock (RTC) synchronization across the system. In one embodiment, this is an Inter-IC communications (I2C) bus.","Alternatively, the control and data may be passed over one common path (in-band).","Network\/Element Management System (NMS):","Exponential network growth combined with continuously changing network requirements dictates a need for well thought out network management solutions that can grow and adapt quickly. The present invention provides a massively scalable, highly reliable comprehensive network management system, intended to scale up (and down) to meet varied customer needs.","Within a telecommunications network, element management systems (EMSs) are designed to configure and manage a particular type of network device (e.g., switch, router, hybrid switch-router), and network management systems (NMSs) are used to configure and manage multiple heterogeneous and\/or homogeneous network devices. Hereinafter, the term \u201cNMS\u201d will be used for both element and network management systems. To configure a network device, the network administrator uses the NMS to provision services. For example, the administrator may connect a cable to a port of a network device and then use the NMS to enable the port. If the network device supports multiple protocols and services, then the administrator uses the NMS to provision these as well. To manage a network device, the NMS interprets data gathered by programs running on each network device relevant to network configuration, security, accounting, statistics, and fault logging and presents the interpretation of this data to the network administrator. The network administrator may use this data to, for example, determine when to add new hardware and\/or services to the network device, to determine when new network devices should be added to the network, and to determine the cause of errors.","Preferably, NMS programs and programs executing on network devices perform in expected ways (i.e., synchronously) and use the same data in the same way. To avoid having to manually synchronize all integration interfaces between the various programs, a logical system model and associated code generation system are used to generate application programming interfaces (APIs)\u2014that is integration interfaces\/integration points\u2014for programs running on the network device and programs running within the NMS. In addition, the APIs for the programs managing the data repositories (e.g., database programs) used by the network device and NMS programs are also generated from the same logical system model and associated code generation system to ensure that the programs use the data in the same way. Further, to ensure that the NMS and network device programs for managing and operating the network device use the same data, the programs, including the NMS programs, access a single data repository for configuration information, for example, a configuration database within the network device.","Referring to , in the present invention, the NMS  includes one or more NMS client programs \u2013and one or more NMS server programs \u2013. The NMS client programs provide interfaces for network administrators. Through the NMS clients, the administrator may configure multiple network devices (e.g., computer system , ; network device , ). The NMS clients communicate with the NMS servers to provide the NMS servers with configuration requirements from the administrator. In addition, the NMS server provides the NMS client with network device management information, which the client then makes available to the administrator. \u201cPushing\u201d data from a server to multiple clients synchronizes the clients with minimal polling. Reduced polling means less management traffic on the network and more device CPU cycles available for other management task. Communication between the NMS client and server is done via Remote Method Invocation (RMI) over Transmission Control Protocol (TCP), a reliable protocol that ensures no data loss.","The NMS client and server relationship prevents the network administrator from directly accessing the network device. Since several network administrators may be managing the network, this mitigates errors that may result if two administrators attempt to configure the same network device at the same time.","The present invention also includes a configuration relational database  within each network device and an NMS relational database  external to the network device. The configuration database program may be executed by a centralized processor card or a processor on another card (e.g., , ; , ) within the network device and maintained in memory on the centralized processor card or in memory on the other card, and the NMS database program may be executed by a processor within a separate computer system (e.g., , ). The NMS server stores data directly in the configuration database via JAVA Database Connectivity (JDBC) over TCP, and using JDBC over TCP, the configuration database, through active queries, automatically replicates any changes to NMS database . By using JDBC and a relational database, the NMS server is able to leverage database transactions, database views, database journaling and database backup technologies that help provide unprecedented system availability. Relational database technology also scales well as it has matured over many years. An active query is a mechanism that enables a client to post a blocked SQL query for asynchronous notification by the database when data changes are made after the blocked SQL query was made.","Similarly, any configuration changes made by the network administrator directly through console interface  are made to the configuration database and, through active queries, automatically replicated to the NMS database. Maintaining a primary or master repository of data within each network device ensures that the NMS and network device are always synchronized with respect to the state of the configuration. Replicating changes made to the primary database within the network device to any secondary data repositories, for example, NMS database , ensures that all secondary data sources are quickly updated and remain in lockstep synchronization.","Instead of automatically replicating changes to the NMS database through active queries, only certain data, as configured by the network administrator, may be replicated. Similarly, instead of immediate replication, the network administrator may configure periodic replication. For example, data from the master embedded database (i.e., the configuration database) can be uploaded daily or hourly. In addition to the periodic, scheduled uploads, backup may be done anytime at the request of the network administrator.","Referring again to , for increased availability, the network device may include a backup configuration database \u2032 maintained by a separate, backup centralized processor card (e.g., , ; , ) in memory on the backup centralized processor card. Any changes to configuration database  are replicated to backup configuration database \u2032. If the primary centralized processor card experiences a failure or error, the backup centralized processor card may be switched over to become the primary processor and configuration database \u2032 may be used to keep the network device operational. In addition, any changes to configuration database  may be written immediately to flash persistent memory  which may also be located on the primary centralized processor card or on another card, and similarly, any changes to backup configuration database \u2032 may be written immediately to flash persistent memory \u2032 which may also be located on the backup centralized processor card or another card. These flash-based configuration files protect against loss of data during power failures. In the unlikely event that all copies of the database within the network device are unusable, the data stored in the NMS database may be downloaded to the network device.","Instead of having a single central processor card (e.g., , ; , ), the external control functions and the internal control functions may be separated onto different cards as described in U.S. patent application Ser. No. 09\/574,343, filed May 20, 2000 and entitled \u201cFunctional Separation of Internal and External Controls in Network Devices\u201d, which is hereby incorporated herein by reference. As shown in , the chassis may support internal control (IC) processor cards and and external control (EC) processor cards and . In this embodiment, configuration database  may be maintained in memory by a processor on internal control processor card and configuration database \u2032 may be maintained in memory by a processor on internal control processor card , and persistent memory  may be located on external control processor card and persistent memory \u2032 may be located on external control processor card . This increases inter-card communication but also provides increased fault tolerance.","The file transfer protocol (FTP) may provide an efficient, reliable transport out of the network device for data intensive operations. Bulk data applications include accounting, historical statistics and logging. An FTP push (to reduce polling) may be used to send accounting, historical statistics and logging data to a data collector server , which may be a UNIX server. The data collector server may then generate network device and\/or network status reports \u2013in, for example, American Standard Code for Information Interchange (ASCII) format and store the data into a database or generate Automatic Message Accounting Format (AMA\/BAF) outputs.","Selected data stored within NMS database  may also be replicated to one or more remote\/central NMS databases \u2013, as described below. NMS servers may also access network device statistics and status information stored within the network device using SNMP (multiple versions) traps and standard Management Information Bases (MIBs and MIB-2). The NMS server augments SNMP traps by providing them over the conventional User Datagram Protocol (UDP) as well as over Transmission Control Protocol (TCP), which provides reliable traps. Each event is generated with a sequence number and logged by the data collector server in a system log database for in place context with system log data. These measures significantly improve the likelihood of responding to all events in a timely manner reducing the chance of service disruption.","The various NMS programs\u2014clients, servers, NMS databases, data collector servers and remote NMS databases\u2014are distributed programs and may be executed on the same computer or different computers. The computers may be within the same LAN or WAN or accessible through the Internet. Distribution and hierarchy are fundamental to making any software system scale to meet larger needs over time. Distribution reduces resource locality constraints and facilitates flexible deployment. Since day-to-day management is done in a distributed fashion, it makes sense that the management software should be distributed. Hierarchy provides natural boundaries of management responsibility and minimizes the number of entities that a management tool must be aware of. Both distribution and hierarchy are fundamental to any long-term management solution. The client server model allows for increased scalability as servers and clients may be added as the number of network managers increase and as the network grows.","The various NMS programs may be written in the JAVA programming language to enable the programs to run on both Windows\/NT and UNIX platforms, such as Sun Solaris. In fact the code for both platforms may be the same allowing consistent graphical interfaces to be displayed to the network administrator. In addition to being native to JAVA, RMI is attractive as the RMI architecture includes (RMI) over Internet Inter-Orb Protocol (IIOP) which delivers Common Object Request Broker Architecture (CORBA) compliant distributed computing capabilities to JAVA. Like CORBA, RMI over IIOP uses IIOP as its communication protocol. IIOP eases legacy application and platform integration by allowing application components written in C++, SmallTalk, and other CORBA supported languages to communicate with components running on the JAVA platform. For \u201cmanage anywhere\u201d purposes and web technology integration, the various NMS programs may also run within a web browser. In addition, the NMS programs may integrate with Hewlett Packard's (HP's) Network Node Manager (NNM\u2122) to provide the convenience of a network map, event aggregation\/filtering, and integration with other vendor's networking. From HP NNM a context-sensitive launch into an NMS server may be executed.","The NMS server also keeps track of important statistics including average client\/server response times and response times to each network device. By looking at these statistics over time, it is possible for network administrators to determine when it is time to grow the management system by adding another server. In addition, each NMS server gathers the name, IP address and status of other NMS servers in the telecommunication network, determines the number of NMS clients and network devices to which it is connected, tracks its own operation time, the number of transactions it has handled since initialization, determines the \u201ctop talkers\u201d (i.e., network devices associated with high numbers of transactions with the server), and the number of communications errors it has experienced. These statistics help the network administrator tune the NMS to provide better overall management service.","NMS database  may be remote or local with respect to the network device(s) that it is managing. For example, the NMS database may be maintained on a computer system outside the domain of the network device (i.e., remote) and communications between the network device and the computer system may occur over a wide area network (WAN) or the Internet. Preferably, the NMS database is maintained on a computer system within the same domain as the network device (i.e., local) and communications between the network device and the computer system may occur over a local area network (LAN). This reduces network management traffic over a WAN or the Internet.","Many telecommunications networks include domains in various geographical locations, and network managers often need to see data combined from these different domains to determine how the overall network is performing. To assist with the management of wide spread networks and still minimize the network management traffic sent over WANs and the Internet, each domain may include an NMS database  and particular\/selected data from each NMS database may be replicated (or \u201crolled up\u201d) to remote NMS databases \u2013that are in particular centralized locations. Referring to , for example, a telecommunications network may include at least three LAN domains \u2013where each domain includes multiple network devices  and an NMS database . Domain may be located in the Boston, Mass. area, domain may be located in the Chicago, Ill. area and domain may be located in the San Francisco, Calif. area. NMS servers \u2013may be located within each domain or in a separate domain. Similarly, one or more NMS clients may be coupled to each NMS server and located in the same domain as the NMS server or in different domains. In addition, one NMS client may be coupled with multiple NMS servers. For example, NMS servers \u2013and NMS clients \u2013may be located in domain (e.g., Dallas, Tex.) while NMS servers \u2013and NMS clients \u2013may be located in domain (e.g., New York, N.Y.). Each NMS server may be used to manage each domain \u2013or, preferably, one NMS server in each server domain \u2013is used to manage all of the network devices within one network device domain \u2013. A single domain may include network devices and NMS clients and servers.","Network administrators use the NMS clients to configure network devices in each of the domains through the NMS servers. The network devices replicate changes made to their internal configuration databases (, ) to a local NMS database . In addition, the data collector server copies all logging data into NMS database  or a separate logging database (not shown). Each local NMS database may also replicate selected data to central NMS database(s) \u2013in accordance with instructions from the network administrator. Other programs may then access the central database to retrieve and combine data from multiple network devices in multiple domains and then present this data to the network administrator. Importantly, network management traffic over WANs and the Internet are minimized since all data is not copied to the central NMS database. For example, local logging data may only be stored in the local NMS databases  (or local logging database) and not replicated to one of the central NMS database.","Logical System Model:","As previously mentioned, to avoid having to manually synchronize all integration interfaces between the various programs, the APIs for both NMS and network device programs are generated using a code generation system from the same logical system model. In addition, the APIs for the data repository software used by the programs are also generated from the same logical system model to ensure that the programs use the data in the same way. Each model within the logical system model contains metadata defining an object\/entity, attributes for the object and the object's relationships with other objects. Upgrading\/modifying an object is, therefore, much simpler than in current systems, since the relationship between objects, including both hardware and software, and attributes required for each object are clearly defined in one location. When changes are made, the logical system model clearly shows what other programs are affected and, therefore, may also need to be changed. Modeling the hardware and software provides a clean separation of function and form and enables sophisticated dynamic software modularity.","A code generation system uses the attributes and metadata within each model to generate the APIs for each program and ensure lockstep synchronization. The logical model and code generation system may also be used to create test code to test the network device programs and NMS programs. Use of the logical model and code generation system saves development, test and integration time and ensures that all relationships between programs are in lockstep synchronization. In addition, use of the logical model and code generation system facilitates hardware portability, seamless extensibility and unprecedented availability and modularity.","Referring to , a logical system model  is created using the object modeling notation and a model generation tool, for example, Rational Rose 2000. Modeler Edition available from Rational Software Corporation in Lexington, Mass. A managed device  represents the top level system connected to models representing both hardware  and data objects used by software applications . Hardware model  includes models representing specific pieces of hardware, for example, chassis , shelf , slot  and printed circuit board . The logical model is capable of showing containment, that is, typically, there are many shelves per chassis (1:N), many slots per shelf (1:N) and one board per slot (1:1). Shelf  is a parent class generalizing multiple shelf models, including various functional shelves \u2013as well as one or more system shelves, for example, for fans  and power . Board  is also a parent class having multiple board models, including various functional boards without external physical ports \u2013(e.g., central processor , ; \u2013, ; and switch fabric cards, ) and various functional boards \u2013(e.g., cross connection cards \u2013and forwarding cards \u2013, ) that connect to boards  with external physical ports (e.g., universal port cards \u2013, ). Hardware model  also includes an external physical port model . Port model  is coupled to one or more specific port models, for example, synchronous optical network (SONET) protocol port , and a physical service endpoint model .","Hardware model  includes models for all hardware that may be available on computer system  (FIG. )\/network device  () whether a particular computer system\/network device uses all the available hardware or not. The model defines the metadata for the system whereas the presence of hardware in an actual network device is represented in instance data. All shelves and slots may not be populated. In addition, there may be multiple chasses. It should be understood that SONET port  is an example of one type of port that may be supported by computer system . A model is created for each type of port available on computer system , including, for example, Ethernet, Dense Wavelength Division Multiplexing (DWDM) or Digital Signal, Level 3 (DS3). The NMS (described below) uses the hardware model and instance data to display a graphical picture of computer system \/network device  to a user.","Service endpoint model  spans the software and hardware models within logical model . It is a parent class including a physical service endpoint model  and a logical service endpoint model . Since the links between the software model and hardware model are minimal, either may be changed (e.g., upgraded or modified) and easily integrated with the other. In addition, multiple models (e.g., ) may be created for many different types of managed devices (e.g., ). The software model may be the same or similar for each different type of managed device even if the hardware\u2014and hardware models\u2014corresponding to the different managed devices are very different. Similarly, the hardware model may be the same or similar for different managed devices but the software models may be different for each. The different software models may reflect different customer needs.","Software model  includes models of data objects used by each of the software processes (e.g., applications, device drivers, system services) available on computer system \/network device . All applications and device drivers may not be used in each computer system\/network device. As one example, ATM model  is shown. It should be understood that software model  may also include models for other applications, for example, Internet Protocol (IP) applications, Frame Relay and Multi-Protocol Label Switching (MPLS) applications. Models of other processes (e.g., device drivers and system services) are not shown for convenience.","For each process, models of configurable objects managed by those processes are also created. For example, models of ATM configurable objects are coupled to ATM model , including models for a soft permanent virtual path (SPVP) , a soft permanent virtual circuit (SPVC) , a switch address , a cross-connection , a permanent virtual path (PVP) cross-connection , a permanent virtual circuit (PVC) cross-connection , a virtual ATM interface , a virtual path link , a virtual circuit link , logging , an ILMI reference , PNNI , a traffic descriptor , an ATM interface  and logical service endpoint . As described above, logical service endpoint model  is coupled to service endpoint model . It is also coupled to ATM interface model .","The logical model is layered on the physical computer system to add a layer of abstraction between the physical system and the software applications. Adding or removing known (i.e., not new) hardware from the computer system will not require changes to the logical model or the software applications. However, changes to the physical system, for example, adding a new type of board, will require changes to the logical model. In addition, the logical model is modified when new or upgraded processes are created. Changes to an object model within the logical model may require changes to other object models within the logical model. It is possible for the logical model to simultaneously support multiple versions of the same software processes (e.g., upgraded and older). In essence, the logical model insulates software applications from changes to the hardware models and vice-versa.","To further decouple software processes from the logical model\u2014as well as the physical system\u2014another layer of abstraction is added in the form of version-stamped views. A view is a logical slice of the logical model and defines a particular set of data within the logical model to which an associated process has access. Version stamped views allow multiple versions of the same process to be supported by the same logical model since each version-stamped view limits the data that a corresponding process \u201cviews\u201d or has access to, to the data relevant to the version of that process. Similarly, views allow multiple different processes to use the same logical model.","Code Generation System:","Referring to , logical model  is used as input to a code generation system . The code generation system creates a view identification (id) and an application programming interface (API)  for each process that requires configuration data. For example, a view id and an API may be created for each ATM application \u2013, each SONET application \u2013, each MPLS application \u2013and each IP application \u2013. In addition, a view id and API is also created for each device driver process, for example, device drivers \u2013, and for modular system services (MSS) \u2013(described below), for example, a Master Control Driver (MCD), a System Resiliency Manager (SRM), and a Software Management System (SMS). The code generation system provides data consistency across processes, centralized tuning and an abstraction of embedded configuration and NMS databases (described below) ensuring that changes to their database schema (i.e., configuration tables and relationships) do not affect existing processes.","The code generation system also creates a data definition language (DDL) file  including structured query language (SQL) commands used to construct the database schema, that is, the various tables and views within a configuration database , and a DDL file  including SQL commands used to construct various tables and SQL views within a network management (NMS) database  (described below). This is also referred to as converting the logical model into a database schema and various SQL views look at particular portions of that schema within the database. If the same database software is used for both the configuration and NMS databases, then one DDL file may be used for both.","The databases do not have to be generated from a logical model for views to work. Instead, database files can be supplied directly without having to generate them using the code generation system. Similarly, instead of using a logical model as an input to the code generation system, a MIB \u201cmodel\u201d may be used. For example, relationships between various MIBs and MIB objects may be written (i.e., coded) and then this \u201cmodel\u201d may be used as input to the code generation system.","Referring to , applications \u2013(e.g., SONET driver , SONET application , MSS , etc.) each have an associated view \u2013of configuration database . The views may be similar allowing each application to view similar data within configuration database . For example, each application may be ATM version 1.0 and each view may be ATM view version 1.3. Instead, the applications and views may be different versions. For example, application may be ATM version 1.0 and view may be ATM view version 1.3 while application is ATM version 1.7 and view is ATM view version 1.5. A later version, for example, ATM version 1.7, of the same application may represent an upgrade of that application and its corresponding view allows the upgraded application access only to data relevant to the upgraded version and not data relevant to the older version. If the upgraded version of the application uses the same configuration data as an older version, then the view version may be the same for both applications. In addition, application may represent a completely different type of application, for example, MPLS, and view allows it to have access to data relevant to MPLS and not ATM or any other application. Consequently, through the use of database views, different versions of the same software applications and different types of software applications may be executed on computer system  simultaneously.","Views also allow the logical model and physical system to be changed, evolved and grown to support new applications and hardware without having to change existing applications. In addition, software applications may be upgraded and downgraded independent of each other and without having to re-boot computer system \/network device . For example, after computer system  is shipped to a customer, changes may be made to hardware or software. For instance, a new version of an application, for example, ATM version 2.0, may be created or new hardware may be released requiring a new or upgraded device driver process. To make this a new process and\/or hardware available to the user of computer system , first the software image including the new process must be re-built.","Referring again to , logical model  may be changed (\u2032) to include models representing the new software and\/or hardware. Code generation system  then uses new logical model \u2032 to re-generate view ids and APIs \u2032 for each application, including, for example, ATM version two  and device driver , and DDL files \u2032 and \u2032. The new application(s) and\/or device driver(s) processes then bind to the new view ids and APIs. A copy of the new application(s) and\/or device driver process as well as the new DDL files and any new hardware are sent to the user of computer system . The user can then download the new software and plug the new hardware into computer system . The upgrade process is described in more detail below. Similarly, if models are upgraded\/modified to reflect upgrades\/modifications to software or hardware, then the new logical model is provided to the code generation system which re-generates view ids and APIs for each process\/program\/application. Again, the new applications are linked with the new view ids and APIs and the new applications and\/or hardware are provided to the user.","Again referring to , the code generation system also creates NMS JAVA interfaces  and persistent layer metadata . The JAVA interfaces are JAVA class files including get and put methods corresponding to attributes within the logical model, and as described below, the NMS servers use the NMS JAVA interfaces to construct models of each particular network device to which they are connected. Also described below, the NMS servers use the persistent layer metadata as well as run time configuration data to generate SQL configuration commands for use by the configuration database.","Prior to shipping computer system  to customers, a software build process is initiated to establish the software architecture and processes. The code generation system is the first part of this process. Following the execution of the code generation system, each process when pulled into the build process links the associated view id and API into its image. For example, referring to , to build a SONET application, source files, for example, a main application file , a performance monitoring file and an alarm monitoring file , written in, for example, the C programming language (.c) are compiled into object code files (.o) \u2032, \u2032 and \u2032. Alternatively, the source files may be written in other programming languages, for example, JAVA (java) or C++ (.cpp). The object files are then linked along with view ids and APIs from the code generation system corresponding to the SONET application, for example, SONET API . The SONET API may be a library (.a) of many object files. Linking these files generates the SONET Application executable file (.exe) .","Referring to , each of the executable files for use by the network device\/computer system are then provided to a kit builder . For example, several SONET executable files (e.g., , ), ATM executable files (e.g., \u2013), MPLS executable files (e.g., \u2013), MSS executable files \u2013and a DDL configuration database executable file  may be provided to kit builder . Alternatively, the DDL configuration database executable file may be executed and some data placed in the database prior to supplying the DDL file to the kit builder. The kit builder creates a computer system\/network device installation kit  that is shipped to the customer with the computer system\/network device or, later, alone after modifications and upgrades are made.","Referring to , similarly, each of the executable files for the NMS is provided separately to the kit builder. For example, a DDL NMS database executable file , an NMS JAVA interfaces executable file , a persistent layer metadata executable file , an NMS server  and an NMS client  may be provided to kit builder . The kit builder creates an NMS installation kit  that is shipped to the customer for installation on a separate computer  (). In addition, new versions of the NMS installation kit may be sent to customers later after upgrades\/modifications are made. When installing the NMS, the customer\/network administrator may choose to distribute the various NMS processes as described above. Alternatively, one or more of the NMS programs, for example, the NMS JAVA interfaces and Persistent layer metadata executable files may be part of the network device installation kit and later passed from the network device to the NMS server, or part of both the network device installation kit and the NMS installation kit.","When the computer system is powered-up for the first time, as described below, configuration database software uses DDL file  to create a configuration database  with the necessary configuration tables and active queries. The NMS database software uses DDL file  to create NMS database  with corresponding configuration tables. Memory and storage space within network devices is typically very limited. The configuration database software is robust and takes a considerable amount of these limited resources but provides many advantages as described below.","As described above, logical model  () may be provided as an input to code generation system  in order to generate database views and APIs for NMS programs and network device programs to synchronize the integration interfaces between those programs. Where a telecommunications network includes multiple similar network devices, the same installation kit may be used to install software on each network device to provide synchronization across the network. Typically, however, networks include multiple different network devices as well as multiple similar network devices. A logical model may be created for each different type of network device and a different installation kit may be implemented on each different type of network device.","Instead, of providing a logical model (e.g., , ) that represents a single network device, a logical model may be provided that represents multiple different managed devices\u2014that is, multiple network devices and the relationship between the network devices. Alternatively, multiple logical models  and \u2013-representing multiple network devices\u2014may be provided, including relationships with other logical models. In either case, providing multiple logical models or one logical model representing multiple network devices and their relationships as an input(s) to the code generation system allows for synchronization of NMS programs and network device programs (e.g., \u2013) across an entire network. The code generation system in combination with one or more logical models provides a powerful tool for synchronizing distributed telecommunication network applications.","The logical model or models may also be used for simulation of a network device and\/or a network of many network devices, which may be useful for scalability testing.","In addition to providing view ids and APIs, the code generation system may also provide code used to push data directly into a third party code API. For example, where an API of a third party program expects particular data, the code generation system may provide this data by retrieving the data from the central repository and calling the third-party programs API. In this situation, the code generation system is performing as a \u201cdata pump\u201d.","Configuration:","Referring to , once the network device programs have been installed on network device  (), and the NMS programs have been installed on one or more computers (e.g., 62), the network administrator may configure the network device. Since each NMS client may be coupled with many network devices, the administrator begins by using the NMS client to select (step ) a particular network device to configure. The NMS client then informs (step ) an NMS server of the particular network device to be configured, and the NMS server using JDBC then connects to the network device and reads the data\/table structure from the configuration database within the network device and uses that information with the JAVA interfaces to construct (step ) a model of the network device. The server provides (step ) this information to the client, which displays (step ) a graphical user interface (GUI) to the administrator indicating the hardware and services available in the selected network device and the current configuration and currently provisioned services.","Referring to , a GUI  may include a graphical depiction of components within a network device. For example, graphic  is shown displaying a front view of the components of network device  (). A back view and other views may also be shown. The views are used to provide management context; for example, to configure or view statistics about a particular port, the user would select the port from the view and use the left mouse button to bring up the appropriate action on the port. The GUI may also include a configuration\/service status window  for displaying current configuration and service provisioning details, and a menu  for selecting various information to be displayed. The network administrator may configure the network device and provision services through the GUI as well as check logged statistical information.","Fault, Configuration, Accounting, Performance and Security (FCAPS) management are the five functional areas of network management as defined by the International Organization for Standardization (ISO). Fault management is for detecting and resolving network faults, configuration management is for configuring and upgrading the network, accounting management is for accounting and billing for network usage, performance management is for overseeing and tuning network performance, and security management is for ensuring network security. GUI  provides a status button \u2013for each of the five FCAPS. By clicking on one of the status buttons, a status window appears and displays the status associated with the selected FCAPS button to the network administrator. For example, if the network administrator clicks on the F status button , a fault event summary window  () appears and displays the status of any faults.","Each FCAP button may be colored according to a hierarchical color code where, for example, green means normal operation, red indicates a serious error and yellow indicates a warning status. Today there are many NMSs that indicate faults through color coded icons or other graphics. However, current NMSs do not categorize the errors or warnings into the ISO five functional areas of network management\u2014that is, FCAPS. The color-coding and order of the FCAPS buttons provide a \u201cstatus bar code\u201d allowing a network administrator to quickly determine the category of error or warning and quickly take action to address the error or warning.","As with current NMSs, a network administrator may actively monitor the FCAPS buttons by sitting in front of the computer screen displaying the GUI. Unfortunately, network administrators do not have time to actively monitor the status of each network device\u2014passive monitoring is required. To assist passive monitoring, the FCAPS buttons may be enlarged or \u201cstretched\u201d to fill a large portion of the screen, as shown in . The FCAPS buttons may be stretched in a variety of ways, for example, a stretch option in a pull down menu may be selected or a mouse may be used to drag and drop the boarders of the FCAPS buttons. Stretching the FCAPS buttons allows a network administrator to view the status of each FCAP button from a distance of 40 feet or more. Once stretched, each of the five OSI management areas can be easily monitored at a distance by looking at the bar-encoded FCAPS strip. The \u201cstretchy FCAPS\u201d provide instant status recognition at a distance.","The network administrator may set the FCAPS buttons to represent a single network device or multiple network devices or all the network devices in a particular network. Alternatively, the network administrator may have the GUI display two or more FCAPS status bars each of which represents one or more network devices.","Although the FCAPS buttons have been described as a string of multiple stretched bars, many different types of graphics may be used to display FCAPS status. For example, different colors may be used to represent normal operation, warnings and errors, and additional colors may be added to represent particular warnings and\/or errors. Instead of a bar, each letter (e.g., F) may be stretched and color-coded. Instead of a solid color, each FCAPS button may repeatedly flash or strobe a color. For example, green FCAPS buttons may remain solid (i.e., not flashing) while red errors and yellow warnings are displayed as a flashing FCAPS button to quickly catch a network administrator's attention. As another example, green\/normal operation FCAPS buttons may be a different size relative to yellow\/warnings and red\/errors FCAPS buttons. For example, an FCAPS button may be automatically enlarged if status changes from good operation to a warning status or an error status. In addition, the FCAPS buttons may be different sizes to allow the network administrator to distinguish between each FCAPS button from a further distance. For example, the buttons may have a graduated scale where the F button is the largest and each button is smaller down to the S button, which is the smallest. Alternatively, the F button may be the smallest while the S button is the largest, or the A button in the middle is the largest, the C and P buttons are smaller and the F and S buttons are smallest. Many variations are possible for quickly alerting a network administrator of the status of each functional area.","Referring again to , through the GUI the user then makes (step ) configuration selections, and the client passes (step ) this run time\/instance configuration data to the server. Persistent layer software within the server then uses this data to generate (step ) SQL commands, which the server sends to the configuration database software executing on the network device. This is referred to as \u201cpersisting\u201d the configuration change. The configuration database software then executes (step ) the SQL commands to fill in or change the appropriate configuration tables. The configuration database software then sends (step ) active query notices to appropriate applications executing within the network device to complete the administrator's configuration request. Active query notices may also be used to update the NMS database with the changes made to the configuration database.","Even a simple configuration request from a network administrator may require several changes to one or more tables. Under certain circumstances, all the changes may not be able to be completed. For example, the connection between the computer system executing the NMS and the network device may go down or the NMS or the network device may crash in the middle of configuring the network device. Current network management systems make configuration changes in a central data repository and pass these changes to network devices using SNMP \u201csets\u201d. Since changes made through SNMP are committed immediately (i.e., written to the data repository), an uncompleted configuration (series of related \u201csets\u201d) will leave the network device in a partially configured state (e.g., \u201cdangling\u201d partial configuration records) that is different from the configuration state in the central data repository being used by the NMS. This may cause errors or a network device and\/or network failure. To avoid this situation, the configuration database executes groups of SQL commands representing one configuration change as a relational database transaction, such that none of the changes are committed to the configuration database until all commands are successfully executed. The configuration database then notifies the server as to the success or failure of the configuration change. If the server receives a failure notification, then the server re-sends the SQL commands to re-start the configuration changes.","Profiles:","Profiles may be used by the NMS client to provide individual users (e.g., network managers and customers) with customized graphical user interfaces (GUIs) or views of their network and with defined management capabilities. For example, some network managers are only responsible for a certain set of devices in the network. Displaying all network devices makes their management tasks more difficult and may inadvertently provide them with management capabilities over network devices for which they are not responsible or authorized to perform. With respect to customers, profiles limit access to only those network devices in a particular customer's network. This is crucial to protecting the proprietary nature of each customer's network. Profiles also allow each network manager and customer to customize the GUI into a presentation format that is most efficient or easy for them to use. For example, even two users with access to the same network devices and having the same management capabilities may have different GUI customizations through their profiles. In addition, profiles may be used to provide other important information, for example, SNMP community strings to allow an NMS server to communicate with a network device over SNMP, SNMP retry and timeout values, and which NMS servers to use, for example, primary and secondary servers may be identified.","A network administrator is typically someone who powers up a network device for the first time, installs necessary software on the new network device as well as installs any NMS software on an NMS computer system, and adds any additional hardware and\/or software to a network device. The network administrator is also the person that attaches physical network cables to network device ports. The first time GUI  is displayed to a network administrator, an NMS client uses a profile including a set of default values. Referring again to , the administrator may change the default values in his profile by selecting (e.g., clicking on) a profile selection  in a navigation tree\/menu . This causes the NMS client to display a profiles tab  () on the screen. The profile tab displays any existing profiles . The first time the profile tab appears only the network administrator's profile is displayed as no other profiles yet exist.","To save a network manager's time, the profiles tab may also include a copy button . By selecting a profile  and clicking on the copy button, an existing profile is copied. The network manager may then change the parameters within the copied profile. This is helpful where two user profiles are to include the same or similar parameters.","To change the parameters in the network administrator's profile or any other existing profile, including a copied profile, the user clicks on one of the profiles . To add a new profile, the user clicks on an Add button . In either case, the NMS client displays a profile dialog box  () on the screen. Through the profile dialog box, a user's user name , password and confirmed password may be added. The confirm password field is used to assure that the password was entered properly in the password field. The password and confirmed password may be encrypted strings used for user authentication. These fields will be displayed as asterisks on the screen. Once added, a user simply logs on to an NMS client with this user name and password and the NMS client displays the GUI in accordance with the other parameters of this profile.","A group level access field enables\/disables various management capabilities (i.e., functionality available through the NMS client). Clicking on the group level access field may provide a list of available access levels. In one embodiment, access levels may include administrator, provisioner and customer, with administrator having the highest level of management capabilities and customer having the lowest level of management capabilities (described in more detail below). In one embodiment, users can create profiles for other users at or below their own group access level. For example, a user at the provisioner access level can create user profiles for users at either the provisioner or customer level but cannot create an administrator user profile.","A description may be added in a description field , including a description of the user, phone number, fax number and\/or e-mail address. A group name may be added to group field , and a list of network device IP addresses may be provided in a device list field . Alternatively, a domain name server (DNS) name may be provided and a host look up may be used to access the IP address of the corresponding device. Where a group name is provided, the list of network devices is associated with the group such that if the same group name is assigned to multiple user profiles, the users will be presented with the same view\u2014that is, the same list of network devices in device list field . For example, users from the same customer may share a group name corresponding to that customer. A wildcard feature is available for the group field. For example, perhaps an * or ALL may be used as a wildcard to indicate that a particular user is authorized to see all network devices. In most instances, the wildcard feature will only be used for a high-level network administrator. The list of devices indicates which network devices the user may manage or view, for example, configuration status and statistics data may be viewed.","Within a profile certain policy flags may also be set. For example, a flag may be set to indicate that the user is not allowed to change his\/her password, and an account disable flag may be set to disable a particular profile\/account. In addition, a flag may be set to allow the user to add network device IP addresses to device list field , and a number may be added to a timeout field to specify a number of minutes after which a user will be automatically logged out due to inactivity. A zero in this field or no value in this field may be used to indicate unlimited activity, that is, the user will never be automatically logged out.","The profile may also be used to indicate which NMS servers the NMS client should communicate with. An IP address may be added to a primary server field and a secondary server field . If the primary server fails, the client will access the secondary server. A port number is added to primary server port field and to secondary server port field to indicate the particular ports that should be used for RMI connectivity to the primary and secondary NMS servers.","Additional fields may be added to the device list to provide more information. For example, a read field may be used to indicate the SNMP community string to be used to allow the NMS server to communicate with the network device over SNMP. The SNMP connection may be used to retrieve statistical data from the network device. In addition, a read\/write field may be used to indicate an SNMP community string to allow the NMS server to configure the network device and\/or provision services. The profile may also include a retry field and a timeout field to provide SNMP retry and timeout values. Many different fields may be provided in a profile.","Instead of providing all the parameters and fields in a single profile dialog box, they may be separated into a variety of a tabbed dialog boxes (\u2013). The tabbed dialog boxes may provide better scalability and flexibility for future needs.","In one embodiment, an administrator level user has both read and write access to the physical and logical objects of the NMS client. Thus, all screens and functionality are available to an administrator level user, and an administrator after physically attaching an external network attachment to a particular network device port may then enable that port and provision SONET paths on that port. All screens are available to a provisioner level user, however, they do not have access to all functionality as they are limited to read-only access of physical objects. For example, a provisioner can see SONET ports available on a device and can provision SONET paths on a port, but the provisioner cannot enable\/disable a SONET port. In other words, a provisioner's power begins at the start of logical objects (not physical objects), for example, SONET paths, ATM interfaces, virtual ATM interfaces, and PVCs, and continues through all the configuration aspects of any object or entity that can be stacked on top of either a SONET path or ATM interface. A customer level user has read-only access to logical entities and only those logical entities corresponding to their group name or listed in the device list field. A customer may or may not have access to Fault, Configuration, Accounting, and Security categories of FCAPS relative to their devices.","A customer may install an NMS client at a customer site or, preferably, the customer will use a web browser to access the NMS client. To use the web browser, a service provider gives the customer an IP address corresponding to the service provider's site. The customer supplies the IP address to their web browser and while at the service provider site, the customer logs in with their username and password. The NMS client then displays the customer level GUI corresponding to that username and password.","Referring to , a user preference dialog box  may be used to customize the GUI into a presentation format that is most efficient or easy for a user to work with. For example, show flags may be used to add tool tips (flag ), add horizontal grid lines on tables (flag ), add vertical grid lines on tables (flag ) and add bookmarks\/short cuts (e.g., create a short cut to a PVC dialog box). Look and feel flags may also be used to make the GUI appear as a JAVA GUI would appear (flag ) or as a native application, for example, Windows, Windows\/NT or Motif, GUI would appear (flag ).","Power-Up:","Referring again to , on power-up, reset or reboot, the processor on each board (central processor and each line card) downloads and executes boot-strap code (i.e., minimal instances of the kernel software) and power-up diagnostic test code from its local memory subsystem. After passing the power-up tests, processor  on central processor  then downloads kernel software  from persistent storage  into non-persistent memory in memory subsystem . Kernel software  includes operating system (OS), system services (SS) and modular system services (MSS).","In one embodiment, the operating system software and system services software are the OSE operating system and system services from Enea OSE Systems, Inc. in Dallas, Tex. The OSE operating system is a pre-emptive multi-tasking operating system that provides a set of services that together support the development of distributed applications (i.e., dynamic loading). The OSE approach uses a layered architecture that builds a high level set of services around kernel primitives. The operating system, system services, and modular system services provide support for the creation and management of processes; inter-process communication (IPC) through a process-to-process messaging model; standard semaphore creation and manipulation services; the ability to locate and communicate with a process regardless of its location in the system; the ability to determine when another process has terminated; and the ability to locate the provider of a service by name.","These services support the construction of a distributed system wherein applications can be located by name and processes can use a single form of communication regardless of their location. By using these services, distributed applications may be designed to allow services to transparently move from one location to another such as during a fail over.","The OSE operating system and system services provide a single inter-process communications mechanism that allows processes to communicate regardless of their location in the system. OSE IPC differs from the traditional IPC model in that there are no explicit IPC queues to be managed by the application. Instead each process is assigned a unique process identification that all IPC messages use. Because OSE IPC supports inter-board communication the process identification includes a path component. Processes locate each other by performing an OSE Hunt call on the process identification. The Hunt call will return the Process ID of the process that maps to the specified path\/name. Inter-board communication is carried over some number of communication links. Each link interface is assigned to an OSE Link Handler. The path component of a process path\/name is the concatenation of the Link Handler names that one must transverse in order to reach the process.","In addition, the OSE operating system includes memory management that supports a \u201cprotected memory model\u201d. The protected memory model dedicates a memory block (i.e., defined memory space) to each process and erects \u201cwalls\u201d around each memory block to prevent access by processes outside the \u201cwall\u201d. This prevents one process from corrupting the memory space used by another process. For example, a corrupt software memory pointer in a first process may incorrectly point to the memory space of a second processor and cause the first process to corrupt the second processor's memory space. The protected memory model prevents the first process with the corrupted memory pointer from corrupting the memory space or block assigned to the second process. As a result, if a process fails, only the memory block assigned to that process is assumed corrupted while the remaining memory space is considered uncorrupted.","The modular software architecture takes advantage of the isolation provided to each process (e.g., device driver or application) by the protected memory model. Because each process is assigned a unique or separate protected memory block, processes may be started, upgraded or restarted independently of other processes.","Referring to , the main modular system service that controls the operation of computer system  is a System Resiliency Manager (SRM). Also within modular system services is a Master Control Driver (MCD) that learns the physical characteristics of the particular computer system on which it is running, in this instance, computer system . The MCD and the SRM are distributed applications. A master SRM  and a master MCD  are executed by central processor  while slave SRMs \u2013and slave MCDs \u2013are executed on each board (central processor  and each line card \u2013). The SRM and MCD work together and use their assigned view ids and APIs to load the appropriate software drivers on each board and to configure computer system .","Also within the modular system services is a configuration service program  that downloads a configuration database program  and its corresponding DDL file from persistent storage into non-persistent memory  on central processor . In one embodiment, configuration database  is a Polyhedra database from Polyhedra, Inc. in the United Kingdom.","Hardware Inventory and Set-Up:","Master MCD  begins by taking a physical inventory of computer system  (over the IC bus) and assigning a unique physical identification number (PID) to each item.","Despite the name, the PID is a logical number unrelated to any physical aspect of the component being numbered. In one embodiment, pull-down\/pull-up resistors on the chassis mid-plane provide the number space of Slot Identifiers. The master MCD may read a register for each slot that allows it to get the bit pattern produced by these resistors. MCD  assigns a unique PID to the chassis, each shelf in the chassis, each slot in each shelf, each line card \u2013inserted in each slot, and each port on each line card. (Other items or components may also be inventoried.)","Typically, the number of line cards and ports on each line card in a computer system is variable but the number of chasses, shelves and slots is fixed. Consequently, a PID could be permanently assigned to the chassis, shelves and slots and stored in a file. To add flexibility, however, MCD  assigns a PID even to the chassis, shelves and slots to allow the modular software architecture to be ported to another computer system with a different physical construction (i.e., multiple chasses and\/or a different number of shelves and slots) without having to change the PID numbering scheme.","Referring to , for each line card \u2013in computer system , MCD  communicates with a diagnostic program (DP) \u2013being executed by the line card's processor to learn each card's type and version. The diagnostic program reads a line card type and version number out of persistent storage, for example, EPROM \u2013, and passes this information to the MCD. For example, line cards and could be cards that implement Asynchronous Transfer Mode (ATM) protocol over Synchronous Optical Network (SONET) protocol as indicated by a particular card type, e.g., 0XF002, and line card could be a card that implements Internet Protocol (IP) over SONET as indicated by a different card type, e.g., 0XE002. In addition, line card could be a version three ATM over SONET card meaning that it includes four SONET ports \u2013each of which may be connected to an external SONET optical fiber that carries an OC-48 stream, as indicated by a particular port type 00620, while line card may be a version four ATM over SONET card meaning that it includes sixteen SONET ports \u2013each of which carries an OC-3 stream as indicated by a particular port type, e.g., 00820. Other information is also passed to the MCD by the DP, for example, diagnostic test pass\/fail status. With this information, MCD  creates card table (CT)  and port table (PT)  in configuration database . As described below, the configuration database copies all changes to an NMS database. If the MCD cannot communicate with the diagnostic program to learn the card type and version number, then the MCD assumes the slot is empty.","Even after initial power-up, master MCD  will continue to take physical inventories to determine if hardware has been added or removed from computer system . For example, line cards may be added to empty slots or removed from slots. When changes are detected, master MCD  will update CT  and PT  accordingly.","For each line card \u2013, master MCD  searches a physical module description (PMD) file  in memory  for a record that matches the card type and version number retrieved from that line card. The PMD file may include multiple files. The PMD file includes a table that corresponds card type and version number with name of the mission kernel image executable file (MKI.exe) that needs to be loaded on that line card. Once determined, master MCD  passes the name of each MKI executable file to master SRM . Master SRM  requests a bootserver (not shown) to download the MKI executable files \u2013from persistent storage  into memory  (i.e., dynamic loading) and passes each MKI executable file \u2013to a bootloader (not shown) running on each board (central processor and each line card). The bootloaders execute the received MKI executable file.","Once all the line cards are executing the appropriate MKI, slave MCDs \u2013and slave SRMs \u2013on each line card need to download device driver software corresponding to the particular devices on each card. Referring to , slave MCDs \u2013search PMD file  in memory  on central processor  for a match with their line card type and version number. Just as the master MCD  found the name of the MKI executable file for each line card in the PMD file, each slave MCD \u2013reads the PMD file to learn the names of all the device driver executable files associated with each line card type and version. The slave MCDs provide these names to the slave SRMs on their boards. Slave SRMs \u2013then download and execute the device driver executable files (DD.exe) \u2013from memory . As one example, one port device driver \u2013may be started for each port \u2013on line card . The port driver and port are linked together through the assigned port PID number.","In order to understand the significance of the PMD file (i.e., metadata), note that the MCD software does not have knowledge of board types built into it. Instead, the MCD parameterizes its operations on a particular board by looking up the card type and version number in the PMD file and acting accordingly. Consequently, the MCD software does not need to be modified, rebuilt, tested and distributed with new hardware. The changes required in the software system infrastructure to support new hardware are simpler modify logical model  () to include: a new entry in the PMD file (or a new PMD file) and, where necessary, new device drivers and applications. Because the MCD software, which resides in the kernel, will not need to be modified, the new applications and device drivers and the new DDL files (reflecting the new PMD file) for the configuration database and NMS database are downloaded and upgraded (as described below) without re-booting the computer system.","Network Management System (NMS):","Referring to , as described above, a user\/network administrator of computer system  works with network management system (NMS) software  to configure computer system . In the embodiment described below, NMS  runs on a personal computer or workstation  and communicates with central processor  over Ethernet network  (out-of-band). Instead, the NMS may communicate with central processor  over data path  (, in-band). Alternatively (or in addition as a back-up communication port), a user may communicate with computer system  through a console interface\/terminal (, ) connected to a serial line  connecting to the data or control path using a command line interface (CLI) protocol. Instead, NMS  could run directly on computer system  provided computer system  has an input mechanism for the user.","During installation, an NMS database  is established on, for example, work-station  using a DDL executable file corresponding to the NMS database. The DDL file may be downloaded from persistent storage  in computer system  or supplied separately with other NMS programs as part of an NMS installation kit. The NMS database mirrors the configuration database through an active query feature (described below). In one embodiment, the NMS database is an Oracle database from Oracle Corporation in Boston, Mass.","The NMS and central processor  pass control and data over Ethernet  using, for example, the Java Database Connectivity (JDBC) protocol. Use of the JDBC protocol allows the NMS to communicate with the configuration database in the same manner that it communicates with its own internal storage mechanisms, including the NMS database. Changes made to the configuration database are passed to the NMS database to ensure that both databases store the same data. This synchronization process is much more efficient, less error-prone and timely than older methods that require the NMS to periodically poll the network device to determine whether configuration changes have been made. In these systems, NMS polling is unnecessary and wasteful if the configuration has not been changed. Additionally, if a configuration change is made through some other means, for example, a command line interface, and not through the NMS, the NMS will not be updated until the next poll, and if the network device crashes prior to the NMS poll, then the configuration change will be lost. In computer system , however, command line interface changes made to configuration database  are passed immediately to the NMS database through the active query feature ensuring that the NMS, through both the configuration database and NMS database, is immediately aware of any configuration changes.","Typically, work-station  is coupled to many network computer systems, and NMS  is used to configure and manage each of these systems. In addition to configuring each system, the NMS also interprets data gathered by each system relevant to each system's network accounting data, statistics, and fault logging and presents this to the user. Instead of having the NMS interpret each system's data in the same fashion, flexibility is added by having each system send the NMS (e.g., data collector server , ) a JAVA class file  indicating how its network data should be interpreted. Through the File Transfer Protocol (ftp), an accounting subsystem process  running on central processor  pushes a data summary file  and a binary data file  to the NMS. The data summary file indicates the name of the JAVA Class file the NMS should use to interpret the binary data file. If the computer system has not already done so, it pushes the class file to the NMS. JAVA Reflection is used to dynamically load the application class file and process the data in the binary data file. As a result, a new class file can be added or updated on a computer system without having to reboot the computer system or update the NMS. The computer system simply pushes the new class file to the NMS. In addition, the NMS can use different class files for each computer system such that the data gathered on each system can be particularized to each system.","Configuration:","As described above, unlike a monolithic software architecture which is directly linked to the hardware of the computer system on which it runs, a modular software architecture includes independent applications that are significantly decoupled from the hardware through the use of a logical model of the computer system. Using the logical model and a code generation system, a view id and API are generated for each application to define each application's access to particular data in a configuration database and programming interfaces between the different applications. The configuration database is established using a data definition language (DDL) file also generated by the code generation system from the logical model. As a result, there is only a limited connection between the computer system's software and hardware, which allows for multiple versions of the same application to run on the computer system simultaneously and different types of applications to run simultaneously on the computer system. In addition, while the computer system is running, application upgrades and downgrades may be executed without affecting other applications and new hardware and software may be added to the system also without affecting other applications.","Referring again to , initially, NMS  reads card table  and port table  to determine what hardware is available in computer system . The NMS assigns a logical identification number (LID)  (and ) to each card and port and inserts these numbers in an LID to PID Card table (LPCT)  and an LID to PID Port table (LPPT)  in configuration database . Alternatively, the NMS could use the PID previously assigned to each board by the MCD. However, to allow for hardware redundancy, the NMS assigns an LID and may associate the LID with at least two PIDs, a primary PID  and a backup PID . (LPCT  may include multiple backup PID fields to allow more than one backup PID to be assigned to each primary PID.)","The user chooses the desired redundancy structure and instructs the NMS as to which boards are primary boards and which boards are backup boards. For example, the NMS may assign LID  to line card \u2014previously assigned PID  by the MCD\u2014as a user defined primary card, and the NMS may assign LID  to line card \u2014previously assigned PID  by the MCD\u2014as a user defined back-up card (see row , ). The NMS may also assign LID  to port \u2014previously assigned PID  by the MCD\u2014as a primary port, and the NMS may assign LID  to port \u2014previously assigned PID  by the MCD\u2014as a back-up port (see row , ).","In a 1:1 redundant system, each backup line card backs-up only one other line card and the NMS assigns a unique primary PID and a unique backup PID to each LID (no LIDs share the same PIDs). In a 1:N redundant system, each backup line card backs-up at least two other line cards and the NMS assigns a different primary PID to each LID and the same backup PID to at least two LIDs. For example, if computer system  is a 1:N redundant system, then one line card, for example, line card , serves as the hardware backup card for at least two other line cards, for example, line cards and . If the NMS assigns an LID of  to line card , then in logical to physical card table  (see row , ), the NMS associates LID  with primary PID  (line card ) and backup PID  (line card ). As a result, backup PID  (line card ) is associated with both LID  and .","The logical to physical card table provides the user with maximum flexibility in choosing a redundancy structure. In the same computer system, the user may provide full redundancy (1:1), partial redundancy (1:N), no redundancy or a combination of these redundancy structures. For example, a network manager (user) may have certain customers that are willing to pay more to ensure their network availability, and the user may provide a backup line card for each of that customer's primary line cards (1:1).","Other customers may be willing to pay for some redundancy but not full redundancy, and the user may provide one backup line card for all of that customer's primary line cards (1:N). Still other customers may not need any redundancy, and the user will not provide any backup line cards for that customer's primary line cards. For no redundancy, the NMS would leave the backup PID field in the logical to physical table blank. Each of these customers may be serviced by separate computer systems or the same computer system. Redundancy is discussed in more detail below.","The NMS and MCD use the same numbering space for LIDs, PIDs and other assigned numbers to ensure that the numbers are different (no collisions).","The configuration database, for example, a Polyhedra relational database, supports an \u201cactive query\u201d feature. Through the active query feature, other software applications can be notified of changes to configuration database records in which they are interested. The NMS database establishes an active query for all configuration database records to insure it is updated with all changes. The master SRM establishes an active query with configuration database  for LPCT  and LPPT . Consequently, when the NMS adds to or changes these tables, configuration database  sends a notification to the master SRM and includes the change. In this example, configuration database  notifies master SRM  that LID  has been assigned to PID  and  and LID  has been assigned to PID  and . The master SRM then uses card table  to determine the physical location of boards associated with new or changed LIDs and then tells the corresponding slave SRM of its assigned LID(s). In the continuing example, master SRM reads CT  to learn that PID  is line card , PID  is line card and PID  is line card . The master SRM then notifies slave SRM on line card that it has been assigned LID  and is a primary line card, SRM on line card that it has been assigned LID  and is a primary line card and SRM on line card that it has been assigned LIDs  and  and is a backup line card. All three slave SRMs , and then set up active queries with configuration database  to insure that they are notified of any software load records (SLRs) created for their LIDs. A similar process is followed for the LIDs assigned to each port.","The NMS informs the user of the hardware available in computer system . This information may be provided as a text list, as a logical picture in a graphical user interface (GUI), or in a variety of other formats. The user then uses the GUI to tell the NMS (e.g., NMS client , ) how they want the system configured.","The user will select which ports (e.g., \u2013, \u2013, \u2013) the NMS should enable. There may be instances where some ports are not currently needed and, therefore, not enabled. The user also needs to provide the NMS with information about the type of network connection (e.g., connection \u2013, \u2013, \u2013). For example, the user may want all ports \u2013on line card enabled to run ATM over SONET. The NMS may start one ATM application to control all four ports, or, for resiliency, the NMS may start one ATM application for each port. Alternatively, each port may be enabled to run a different protocol (e.g., MPLS, IP, Frame Relay).","In the example given above, the user must also indicate the type of SONET fiber they have connected to each port and what paths to expect. For example, the user may indicate that each port \u2013is connected to a SONET optical fiber carrying an OC-48 stream. A channelized OC-48 stream is capable of carrying forty-eight STS-1 paths, sixteen STS-3c paths, four STS-12c paths or a combination of STS-1, STS-3c and STS-12c paths. A clear channel OC-48c stream carries one concatenated STS-48 path. In the example, the user may indicate that the network connection to port is a clear channel OC-48 SONET stream having one STS-48 path, the network connection to port is a channelized OC-48 SONET stream having three STS-12c paths (i.e., the SONET fiber is not at full capacity\u2014more paths may be added later), the network connection to port is a channelized OC-48 SONET stream having two STS-3c paths (not at full capacity) and the network connection to port is a channelized OC-48 SONET stream having three STS-12c paths (not at full capacity). In the current example, all paths within each stream carry data transmitted according to the ATM protocol. Alternatively, each path within a stream may carry data transmitted according to a different protocol.","The NMS (e.g., NMS server \u2013) uses the information received from the user (through the GUI\/NMS client) to create records in several tables in the configuration database, which are then copied to the NMS database. These tables are accessed by other applications to configure computer system . One table, the service endpoint table (SET)  (see also ), is created when the NMS assigns a unique service endpoint number (SE) to each path on each enabled port and corresponds each service endpoint number with the physical identification number (PID) previously assigned to each port by the MCD. Through the use of the logical to physical port table (LPPT), the service endpoint number also corresponds to the logical identification number (LID) of the port. For example, since the user indicated that port (PID ) has a single STS-48 path, the NMS assigns one service endpoint number (e.g. SE , see row , ). Similarly, the NMS assigns three service endpoint numbers (e.g., SE , , , see rows \u2013) to port (PID ), two service endpoint numbers (e.g., SE , , see rows , ) to port (PID ) and three service endpoint numbers (e.g., SE , , , see rows , , ) to port ","Service endpoint managers (SEMs) within the modular system services of the kernel software running on each line card use the service endpoint numbers assigned by the NMS to enable ports and to link instances of applications, for example, ATM, running on the line cards with the correct port. The kernel may start one SEM to handle all ports on one line card, or, for resiliency, the kernel may start one SEM for each particular port. For example, SEMs \u2013are spawned to independently control ports \u2013","The service endpoint managers (SEMs) running on each board establish active queries with the configuration database for SET . Thus, when the NMS changes or adds to the service endpoint table (SET), the configuration database sends the service endpoint manager associated with the port PID in the SET a change notification including information on the change that was made. In the continuing example, configuration database  notifies SEM that SET  has been changed and that SE  was assigned to port (PID ). Configuration database  notifies SEM that SE , , and  were assigned to port (PID ), SEM that SE  and  were assigned to port (PID ) and SEM that SE , , and  were assigned to port (PID ). When a service endpoint is assigned to a port, the SEM associated with that port passes the assigned SE number to the port driver for that port using the port PID number associated with the SE number.","To load instances of software applications on the correct boards, the NMS creates software load records (SLR) \u2013in configuration database . The SLR includes the name  () of a control shim executable file and an LID  for cards on which the application must be spawned. In the continuing example, NMS  creates SLR including the executable name atm_cntrl.exe and card LID  (row ). The configuration database detects LID  in SLR and sends slave SRMs (line card ) and (line card ) a change notification including the name of the executable file (e.g., atm_cntrl.exe) to be loaded. The primary slave SRMs then download and execute a copy of atm_cntrl.exe  from memory  to spawn the ATM controllers (e.g., ATM controller  on line card ). Since slave SRM is on backup line card , it may or may not spawn an ATM controller in backup mode. Software backup is described in more detail below. Instead of downloading a copy of atm_cntrl.exe  from memory , a slave SRM may download it from another line card that already downloaded a copy from memory . There may be instances when downloading from a line card is quicker than downloading from central processor . Through software load records and the tables in configuration database , applications are downloaded and executed without the need for the system services, including the SRM, or any other software in the kernel to have information as to how the applications should be configured. The control shims (e.g., atm_cntrl.exe ) interpret the next layer of the application (e.g., ATM) configuration.","For each application that needs to be spawned, for example, an ATM application and a SONET application, the NMS creates an application group table. Referring to , ATM group table  indicates that four instances of ATM (i.e., group number , , , )\u2014corresponding to four enabled ports \u2013\u2014are to be started on line card (LID ). If other instances of ATM are started on other line cards, they would also be listed in ATM group table  but associated with the appropriate line card LID. ATM group table  may also include additional information needed to execute ATM applications on each particular line card. (See description of software backup below.)","In the above example, one instance of ATM was started for each port on the line card. This provides resiliency and fault isolation should one instance of ATM fail or should one port suffer a failure. An even more resilient scheme would include multiple instances of ATM for each port. For example, one instance of ATM may be started for each path received by a port.","The application controllers on each board now need to know how many instances of the corresponding application they need to spawn. This information is in the application group table in the configuration database. Through the active query feature, the configuration database notifies the application controller of records associated with the board's LID from corresponding application group tables. In the continuing example, configuration database  sends ATM controller  records from ATM group table  that correspond to LID  (line card ). With these records, ATM controller  learns that there are four ATM groups associated with LID  meaning ATM must be instantiated four times on line card . ATM controller  asks slave SRM to download and execute four instances (ATM \u2013, ) of atm.exe .","Once spawned, each instantiation of ATM \u2013 sends an active database query to search ATM interface table  for its corresponding group number and to retrieve associated records. The data in the records indicates how many ATM interfaces each instantiation of ATM needs to spawn. Alternatively, a master ATM application (not shown) running on central processor  may perform active queries of the configuration database and pass information to each slave ATM application running on the various line cards regarding the number of ATM interfaces each slave ATM application needs to spawn.","Referring to , for each instance of ATM \u2013 there may be one or more ATM interfaces. To configure these ATM interfaces, the NMS creates an ATM interface table . There may be one ATM interface \u2013 per path\/service endpoint or multiple virtual ATM interfaces \u2013 per path. This flexibility is left up to the user and NMS, and the ATM interface table allows the NMS to communicate this configuration information to each instance of each application running on the different line cards. For example, ATM interface table  indicates that for ATM group , service endpoint , there are three virtual ATM interfaces (ATM-IF \u2013) and for ATM group , there is one ATM interface for each service endpoint: ATM-IF  and SE ; ATM-IF  and SE ; and ATM-IF  and SE .","Computer system  is now ready to operate as a network switch using line card and ports \u2013. The user will likely provide the NMS with further instructions to configure more of computer system . For example, instances of other software applications, such as an IP application, and additional instances of ATM may be spawned (as described above) on line cards or other boards in computer system .","As shown above, all application dependent data resides in memory  and not in kernel software. Consequently, changes may be made to applications and configuration data in memory  to allow hot (while computer system  is running) upgrades of software and hardware and configuration changes. Although the above described power-up and configuration of computer system  is complex, it provides massive flexibility as described in more detail below.","Instead of using the GUI to interactively provision services in real time, a user may use a \u201ccommand line\u201d interactive interpreter and one or more templates to provision services within one or more network devices in batch, non-interactive mode. Referring to , using the interactive interpreter, a network administrator may provision services by selecting (step ) and copying and renaming (step ) a particular template corresponding to a particular provisioning task and either accepting default parameter values provided by the template or changing (step ) those default values to meet the administrator's needs. Templates may be generated for many various provisioning tasks, for example, setting up a permanent virtual circuit (PVC), a switched virtual circuit (SVC), a SONET path, a traffic descriptor (TD) or a virtual ATM interface (VAIF).","The modified provisioning templates are sent to or loaded into (step ) an OSS client, which interprets the template and issues the appropriate calls (step ) to the NMS server to satisfy the provisioning need. The OSS client may be written in JAVA and employ script technology. In accordance with instructions within the template from the network administrator, the NMS server may execute (step ) the provisioning requests defined by a template immediately or in a \u201cbatch-mode\u201d (step ), perhaps with other templates, at a time when network transactions are typically low (e.g., late at night). Database view ids and APIs for the OSS client may be generated using the logical model and code generation system () to synchronize the integration interfaces between the OSS client and the NMS server.","Through the provisioning templates an NMS is integrated with the telecommunication network carrier's Operations Support Services (OSS). At the heart of any carrier's network is the OSS, which provides the overall network management infrastructure. The OSS is responsible for consolidating a diverse set of element\/network management systems and third-party applications into a single system that is used to detect and resolve network faults (Fault Management), configure and upgrade the network (Configuration Management), account and bill for network usage (Accounting Management), oversee and tune network performance (Performance Management, and ensure ironclad network security (Security Management). FCAPS are the five functional areas of network management as defined by the International Organization for Standardization (ISO).","The templates, interactive interpreter and OSS client may be loaded and executed on a central OSS computer system(s) and used to provision services in one or more network devices in one or more network domains. The network administrator does need to know details of the network device being provisioned as the parameters required and available for modification are listed in the various templates. Consequently, the interactive interpreter and templates allow for multifaceted integration into existing OSS infrastructures.","Inter-Process Communication:","As described above, the operating system assigns a unique process identification number (proc_id) to each spawned process. Each process has a name, and each process knows the names of other processes with which it needs to communicate. The operating system keeps a list of process names and the assigned process identification numbers. Processes send messages to other processes using the assigned process identification numbers without regard to what board is executing each process (i.e., process location). Application Programming Interfaces (APIs) define the format and type of information included in the messages.","The modular software architecture configuration model requires a single software process to support multiple configurable objects. For example, as described above, an ATM application may support configurations requiring multiple ATM interfaces and thousands of permanent virtual connections per ATM interface. The number of processes and configurable objects in a modular software architecture can quickly grow especially in a distributed processing system. If the operating system assigns a new process for each configurable object, the operating system's capabilities may be quickly exceeded. For example, the operating system may be unable to assign a process for each ATM interface, each service endpoint, each permanent virtual circuit, etc. In some instances, the process identification numbering scheme itself may not be large enough. Where protected memory is supported, the system may have insufficient memory to assign each process and configurable object a separate memory block. In addition, supporting a large number of independent processes may reduce the operating system's efficiency and slow the operation of the entire computer system.","One alternative is to assign a unique process identification number to only certain high level processes. Referring to , for example, process identification numbers may only be assigned to each ATM process (e.g., ATMs , ) and not to each ATM interface (e.g., ATM IFs \u2013) and process identification numbers may only be assigned to each port device driver (e.g., device drivers , , ) and not to each service endpoint (e.g., SE \u2013). A disadvantage to this approach is that objects within one high level process will likely need to communicate with objects within other high level processes. For example, ATM interface  within ATM  may need to communicate with SE  within device driver . ATM IF  needs to know if SE  is active and perhaps certain other information about SE . Since SE  was not assigned a process identification number, however, neither ATM  nor ATM IF  knows if it exists. Similarly, ATM IF  knows it needs to communicate with SE  but does not know that device driver  controls SE .","One possible solution is to hard code the name of device driver  into ATM . ATM  then knows it must communicate with device driver  to learn about the existence of any service endpoints within device driver  that may be needed by ATM IF ,  or . Unfortunately, this can lead to scalability issues. For instance, each instantiation of ATM (e.g., ATM , ) needs to know the name of all device drivers (e.g., device drivers , , ) and must query each device driver to locate each needed service endpoint. An ATM query to a device driver that does not include a necessary service endpoint is a waste of time and resources. In addition, each high level process must periodically poll other high level processes to determine whether objects within them are still active (i.e., not terminated) and whether new objects have been started. If the object status has not changed between polls, then the poll wasted resources. If the status did change, then communications have been stalled for the length of time between polls. In addition, if a new device driver is added (e.g., device driver ), then ATM  and  cannot communicate with it or any of the service endpoints within it until they have been upgraded to include the new device driver's name.","Preferably, computer system  implements a name server process and a flexible naming procedure. The name server process allows high level processes to register information about the objects within them and to subscribe for information about the objects with which they need to communicate. The flexible naming procedure is used instead of hard coding names in processes. Each process, for example, applications and device drivers, use tables in the configuration database to derive the names of other configurable objects with which they need to communicate. For example, both an ATM application and a device driver process may use an assigned service endpoint number from the service endpoint table (SET) to derive the name of the service endpoint that is registered by the device driver and subscribed for by the ATM application. Since the service endpoint numbers are assigned by the NMS during configuration, stored in SET  and passed to local SEMs, they will not be changed if device drivers or applications are upgraded or restarted.","Referring to , for example, when device drivers ,  and  are started they each register with name server (NS) . Each device driver provides a name, a process identification number and the name of each of its service endpoints. Each device driver also updates the name server as service endpoints are started, terminated or restarted. Similarly, each instantiation of ATM ,  subscribes with name server  and provides its name, process identification number and the name of each of the service endpoints in which it is interested. The name server then notifies ATM  and  as to the process identification of the device driver with which they should communicate to reach a desired service endpoint. The name server updates ATM  and  in accordance with updates from the device drivers. As a result, updates are provided only when necessary (i.e., no wasted resources), and the computer system is highly scalable. For example, if a new device driver  is started, it simply registers with name server , and name server  notifies either ATM  or  if a service endpoint in which they are interested is within the new device driver. The same is true if a new instantiation of ATM\u2014perhaps an upgraded version\u2014is started or if either an ATM application or a device driver fails and is restarted.","Referring to , when the SEM, for example, SEM , notifies a device driver, for example, device driver (DD) , of its assigned SE number, DD  uses the SE number to generate a device driver name. In the continuing example from above, where the ATM over SONET protocol is to be delivered to port and DD , the device driver name may be for example, atm.sel. DD  publishes this name to NS along with the process identification assigned by the operating system and the name of its service endpoints.","Applications, for example, ATM , also use SE numbers to generate the names of device drivers with which they need to communicate and subscribe to NS for those device driver names, for example, atm.sel. If the device driver has published its name and process identification with NS , then NS notifies ATM  of the process identification number associated with atm.sel and the name of its service endpoints. ATM  can then use the process identification to communicate with DD  and, hence, any objects within DD . If device driver  is restarted or upgraded, SEM will again notify DD  that its associated service endpoint is SE  which will cause DD  to generate the same name of atm.sel. DD  will then re-publish with NS and include the newly assigned process identification number. NS will provide the new process identification number to ATM  to allow the processes to continue to communicate. Similarly, if ATM  is restarted or upgraded, it will use the service endpoint numbers from ATM interface table  and, as a result, derive the same name of atm.sel for DD . ATM  will then re-subscribe with NS ","Computer system  includes a distributed name server (NS) application including a name server process \u2013on each board (central processor and line card). Each name server process handles the registration and subscription for the processes on its corresponding board. For distributed applications, after each application (e.g., ATM \u2013) registers with its local name server (e.g., \u2013), the name server registers the application with each of the other name servers. In this way, only distributed applications are registered\/subscribed system wide which avoids wasting system resources by registering local processes system wide.","The operating system, through the use of assigned process identification numbers, allows for inter-process communication (IPC) regardless of the location of the processes within the computer system. The flexible naming process allows applications to use data in the configuration database to determine the names of other applications and configurable objects, thus, alleviating the need for hard coded process names. The name server notifies individual processes of the existence of the processes and objects with which they need to communicate and the process identification numbers needed for that communication. The termination, re-start or upgrade of an object or process is, therefore, transparent to other processes, with the exception of being notified of new process identification numbers. For example, due to a configuration change initiated by the user of the computer system, service endpoint  (), may be terminated within device driver  and started instead within device driver . This movement of the location of object  is transparent to both ATM  and . Name server  simply notifies whichever processes have subscribed for SE  of the newly assigned process identification number corresponding to device driver .","The name server or a separate binding object manager (BOM) process may allow processes and configurable objects to pass additional information adding further flexibility to inter-process communications. For example, flexibility may be added to the application programming interfaces (APIs) used between processes. As discussed above, once a process is given a process identification number by the name server corresponding to an object with which it needs to communicate, the process can then send messages to the other process in accordance with a predefined application programming interface (API). Instead of having a predefined API, the API could have variables defined by data passed through the name server or BOM, and instead of having a single API, multiple APIs may be available and the selection of the API may be dependent upon information passed by the name server or BOM to the subscribed application.","Referring to , a typical API will have a predefined message format  including, for example, a message type  and a value  of a fixed number of bits (e.g., 32). Processes that use this API must use the predefined message format. If a process is upgraded, it will be forced to use the same message format or change the API\/message format which would require that all processes that use this API also be similarly upgraded to use the new API. Instead, the message format can be made more flexible by passing information through the name server or BOM. For example, instead of having the value field  be a fixed number of bits, when an application registers a name and process identification number it may also register the number of bits it plans on using for the value field (or any other field). Perhaps a zero indicates a value field of 32 bits and a one indicates a value filed of 64 bits. Thus, both processes know the message format but some flexibility has been added.","In addition to adding flexibility to the size of fields in a message format, flexibility may be added to the overall message format including the type of fields included in the message. When a process registers its name and process identification number, it may also register a version number indicating which API version should be used by other processes wishing to communicate with it. For example, device driver  () may register SE  with NS  and provide the name of SE , device driver 's process identification number and a version number one, and device driver  may register SE  with NS  and provide the name of SE , device driver 's process identification number and a version number (e.g., version number two). If ATM  has subscribed for either SE  or SE , then NS  notifies ATM  that SE  and SE  exist and provides the process identification numbers and version numbers. The version number tells ATM  what message format and information SE  and SE  expect. The different message formats for each version may be hard coded into ATM  or ATM  may access system memory or the configuration database for the message formats corresponding to service endpoint version one and version two. As a result, the same application may communicate with different versions of the same configurable object using a different API.","This also allows an application, for example, ATM, to be upgraded to support new configurable objects, for example, new ATM interfaces, while still being backward compatible by supporting older configurable objects, for example, old ATM interfaces. Backward compatibility has been provided in the past through revision numbers, however, initial communication between processes involved polling to determine version numbers and where multiple applications need to communicate, each would need to poll the other. The name server\/BOM eliminates the need for polling.","As described above, the name server notifies subscriber applications each time a subscribed for process is terminated. Instead, the name server\/BOM may not send such a notification unless the System Resiliency Manager (SRM) tells the name server\/BOM to send such a notification. For example, depending upon the fault policy\/resiliency of the system, a particular software fault may simply require that a process be restarted. In such a situation, the name server\/BOM may not notify subscriber applications of the termination of the failed process and instead simply notify the subscriber applications of the newly assigned process identification number after the failed process has been restarted. Data that is sent by the subscriber processes after the termination of the failed process and prior to the notification of the new process identification number may be lost but the recovery of this data (if any) may be less problematic than notifying the subscriber processes of the failure and having them hold all transmissions. For other faults, or after a particular software fault occurs a predetermined number of times, the SRM may then require the name server\/BOM to notify all subscriber processes of the termination of the failed process. Alternatively, if a terminated process does not re-register within a predetermined amount of time, the name server\/BOM may then notify all subscriber processes of the termination of the failed process.","Configuration Change:","Over time the user will likely make hardware changes to the computer system that require configuration changes. For example, the user may plug a fiber or cable (i.e., network connection) into an as yet unused port, in which case, the port must be enabled and, if not already enabled, then the port's line card must also be enabled. As other examples, the user may add another path to an already enabled port that was not fully utilized, and the user may add another line card to the computer system. Many types of configuration changes are possible, and the modular software architecture allows them to be made while the computer system is running (hot changes). Configuration changes may be automatically copied to persistent storage as they are made so that if the computer system is shut down and rebooted, the memory and configuration database will reflect the last known state of the hardware.","To make a configuration change, the user informs the NMS (e.g., NMS client , ) of the particular change, and similar to the process for initial configuration, the NMS (e.g., NMS server , ) changes the appropriate tables in the configuration database (copied to the NMS database) to implement the change.","Referring to , in one example of a configuration change, the user notifies the NMS that an additional path will be carried by SONET fiber connected to port . A new service endpoint (SE)  and a new ATM interface  are needed to handle the new path. The NMS adds a new record (row , ) to service endpoint table (SET)  to include service endpoint  corresponding to port physical identification number (PID)  (port ). The NMS also adds a new record (row , ) to ATM instance table  to include ATM interface (IF)  corresponding to ATM group  and SE . Configuration database  may automatically copy the changes made to SET  and ATM instance table  to persistent storage  such that if the computer system is shut down and rebooted, the changes to the configuration database will be maintained.","Configuration database  also notifies (through the active query process) SEM that a new service endpoint (SE ) was added to the SET corresponding to its port (PID ), and configuration database  also notifies ATM instantiation  that a new ATM interface (ATM-IF ) was added to the ATM interface table corresponding to ATM group . ATM  establishes ATM interface  and SEM notifies port driver  that it has been assigned SE. A communication link is established through NS . Device driver  generates a service endpoint name using the assigned SE number and publishes this name and its process identification number with NS . ATM interface  generates the same service endpoint name and subscribes to NS for that service endpoint name. NS provides ATM interface  with the process identification assigned to DD  allowing ATM interface  to communicate with device driver .","Certain board changes to computer system  are also configuration changes. After power-up and configuration, a user may plug another board into an empty computer system slot or remove an enabled board and replace it with a different board. In the case where applications and drivers for a line card added to computer system  are already loaded, the configuration change is similar to initial configuration. The additional line card may be identical to an already enabled line card, for example, line card or if the additional line card requires different drivers (for different components) or different applications (e.g., IP), the different drivers and applications are already loaded because computer system  expects such cards to be inserted.","Referring to , while computer system  is running, when another line card  is inserted, master MCD  detects the insertion and communicates with a diagnostic program  being executed by the line card's processor  to learn the card's type and version number. MCD  uses the information it retrieves to update card table  and port table . MCD  then searches physical module description (PMD) file  in memory  for a record that matches the retrieved card type and version number and retrieves the name of the mission kernel image executable file (MKI.exe) that needs to be loaded on line card . Once determined, master MCD  passes the name of the MKI executable file to master SRM . SRM  downloads MKI executable file  from persistent storage  and passes it to a slave SRM  running on line card . The slave SRM executes the received MKI executable file.","Referring to , slave MCD  then searches PMD file  in memory  on central processor  for a match with its line card's type and version number to find the names of all the device driver executable files associated needed by its line card. Slave MCD  provides these names to slave SRM  which then downloads and executes the device driver executable files (DD.exe)  from memory .","When master MCD  updates card table , configuration database  updated NMS database  which sends NMS  (e.g., NMS Server , ) a notification of the change including card type and version number, the slot number into which the card was inserted and the physical identification (PID) assigned to the card by the master MCD. The NMS is updated, assigns an LID and updates the logical to physical table and notifies the user of the new hardware. The user then tells the NMS how to configure the new hardware, and the NMS implements the configuration change as described above for initial configuration.","Logical Model Change:","Where applications and device drivers for a new line card are not already loaded and where changes or upgrades to already loaded applications and device drivers are needed, logical model  (\u2013) must be changed and new view ids and APIs, NMS JAVA interface files, persistent layer metadata files and new DDL files must be re-generated. Software model  is changed to include models of the new or upgraded software, and hardware model  is changed to include models of any new hardware. New logical model \u2032 is then used by code generation system  to re-generate view ids and APIs for each application, including any new applications, for example, ATM version two , or device drivers, for example, device driver , and to re-generate DDL files \u2032 and \u2032 including new SQL commands and data relevant to the new hardware and\/or software. The new logical model is also used to generate new NMS JAVA interface files \u2032 and new persistent layer metadata files \u2032. Each application, including any new applications or drivers, is then pulled into the build process and links in a corresponding view id and API. The new applications and\/or device drivers, NMS JAVA interface files, new persistent layer metadata files and the new DDL files as well as any new hardware are then sent to the user of computer system .","New and upgraded applications and device drivers are being used by way of an example, and it should be understood that other processes, for example, modular system services and new Mission Kernel Images (MKIs), may be changed or upgraded in the same fashion.","Referring to , the user instructs the NMS to download the new applications and\/or device drivers, for example, ATM version two  and device driver , as well as the new DDL files, for example, DDL files \u2032 and \u2032, into memory on work station . The NMS uses new NMS database DDL file \u2032 to upgrade NMS database  into new NMS database \u2032. Alternatively, a new NMS database may be created using DDL file \u2032 and both databases temporarily maintained.","Application Upgrade:","For new applications and application upgrades, the NMS works with a software management system (SMS) service to implement the change while the computer system is running (hot upgrades or additions). The SMS is one of the modular system services, and like the MCD and the SRM, the SMS is a distributed application. Referring to , a master SMS  is executed by central processor  while slave SMSs \u2013are executed on each board.","Upgrading a distributed application that is running on multiple boards is more complicated than upgrading an application running on only one board. As an example of a distributed application upgrade, the user may want to upgrade all ATM applications running on various boards in the system using new ATM version two . This is by way of example, and it should be understood, that only one ATM application may be upgraded so long as it is compatible with the other versions of ATM running on other boards. ATM version two  may include many sub-processes, for example, an upgraded ATM application executable file (ATMv2.exe ), an upgraded ATM control executable file (ATMv2_cntrl.exe ) and an ATM configuration control file (ATMv2_cnfg_cntrl.exe). The NMS downloads ATMv2.exe , ATMv2_cntrl.exe and ATMv2_cnfg_cntrl.exe to memory  on central processor .","The NMS then writes a new record into SMS table  indicating the scope of the configuration update. The scope of an upgrade may be indicated in a variety of ways. In one embodiment, the SMS table includes a field for the name of the application to be changed and other fields indicating the changes to be made. In another embodiment, the SMS table includes a revision number field  () through which the NMS can indicate the scope of the change. Referring to , the right most position in the revision number may indicate, for example, the simplest configuration update (e.g., a bug fix), in this case, termed a \u201cservice update level\u201d . Any software revisions that differ by only the service update level can be directly applied without making changes in the configuration database or API changes between the new and current revision. The next position may indicate a slightly more complex update, in this case, termed a \u201csubsystem compatibility level\u201d . These changes include changes to the configuration database and\/or an API. The next position may indicate a \u201cminor revision level\u201d  update indicating more comprehensive changes in both the configuration database and one or more APIs. The last position may indicate a \u201cmajor revision level\u201d  update indicative of wholesale changes in multiple areas and may require a reboot of the computer system to implement. For a major revision level change, the NMS will download a complete image including a kernel image.","During initial configuration, the SMS establishes an active query on SMS table . Consequently, when the NMS changes the SMS table, the configuration database sends a notification to master SMS  including the change. In some instances, the change to an application may require changes to configuration database . The SMS determines the need for configuration conversion based on the scope of the release or update. If the configuration database needs to be changed, then the software, for example, ATM version two , provided by the user and downloaded by the NMS also includes a configuration control executable file, for example, ATMv2_cnfig_cntrl.exe , and the name of this file will be in the SMS table record. The master SMS then directs slave SRM on central processor  to execute the configuration control file which uses DDL file \u2032 to upgrade old configuration database  into new configuration database \u2032 by creating new tables, for example, ATM group table \u2032 and ATM interface table \u2032.","Existing processes using their view ids and APIs to access new configuration database \u2032 in the same manner as they accessed old configuration database . However, when new processes (e.g., ATM version two  and device driver ) access new configuration database \u2032, their view ids and APIs allow them to access new tables and data within new configuration database \u2032.","The master SMS also reads ATM group table \u2032 to determine that instances of ATM are being executed on line cards \u2013. In order to upgrade a distributed application, in this instance, ATM, the Master SMS will use a lock step procedure. Master SMS  tells each slave SMS \u2013to stall the current versions of ATM. When each slave responds, Master SMS  then tells slave SMSs \u2013to download and execute ATMv2_cntrl.exe  from memory . Upon instructions from the slave SMSs, slave SRMs \u2013download and execute copies of ATMv2_cntrl.exe \u2013. The slave SMSs also pass data to the ATMv2cntrl.exe file through the SRM. The data instructs the control shim to start in upgrade mode and passes required configuration information. The upgraded ATMv2 controllers \u2013then use ATM group table \u2032 and ATM interface table \u2032 as described above to implement ATMv2 \u2013on each of the line cards. In this example, each ATM controller is shown implementing one instance of ATM on each line card, but as explained below, the ATM controller may implement multiple instances of ATM on each line card.","As part of the upgrade mode, the updated versions of ATMv2 \u2013retrieve active state from the current versions of ATM \u2013. The retrieval of active state can be accomplished in the same manner that a redundant or backup instantiation of ATM retrieves active state from the primary instantiation of ATM. When the upgraded instances of ATMv2 are executing and updated with active state, the ATMv2 controllers notify the slave SMSs \u2013on their board and each slave SMS \u2013notifies master SMS . When all boards have notified the master SMS, the master SMS tells the slave SMSs to switchover to ATMv2 \u2013. The slave SMSs tell the slave SRMs running on their board, and the slave SRMs transition the new ATMv2 processes to the primary role. This is termed \u201clock step upgrade\u201d because each of the line cards is switched over to the new ATMv2 processes simultaneously.","There may be upgrades that require changes to multiple applications and to the APIs for those applications. For example, a new feature may be added to ATM that also requires additional functionality to be added to the Multi-Protocol Label Switching (MPLS) application. The additionally functionality may change the peer-to-peer API for ATM, the peer-to-peer API for MPLS and the API between ATM and MPLS. In this scenario, the upgrade operation must avoid allowing the \u201cnew\u201d version of ATM to communicate with itself or the \u201cold\u201d version of MPLS and vice versa. The master SMS will use the release number scheme to determine the requirements for the individual upgrade. For example, the upgrade may be from release 1.0.0.0 to 1.0.1.3 where the release differs by the subsystem compatibility level. The SMS implements the upgrade in a lock step fashion. All instances of ATM and MPLS are upgraded first. The slave SMS on each line card then directs the slave SRM on its board to terminate all \u201cold\u201d instances of ATM and MPLS and switchover to the new instances of MPLS and ATM. The simultaneous switchover to new versions of both MPLS and ATM eliminate any API compatibility errors.","Referring to , instead of directly upgrading configuration database  on central processor , a backup configuration database  on a backup central processor  may be upgraded first. As described above, computer system  includes central processor . Computer system  may also include a redundant or backup central processor  that mirrors or replicates the active state of central processor . Backup central processor  is generally in stand-by mode unless central processor  fails at which point a fail-over to backup central processor  is initiated to allow the backup central processor to be substituted for central processor . In addition to failures, backup central processor  may be used for software and hardware upgrades that require changes to the configuration database. Through backup central processor , upgrades can be made to backup configuration database  instead of to configuration database .","The upgrade is begun as discussed above with the NMS downloading ATM version two \u2014including ATMv2.exe , ATMv2_cntrl.exe and ATMv2_cnfg_cntrl.exe\u2014and DDL file \u2032 to memory on central processor . Simultaneously, because central processor  is in backup mode, the application and DDL file are also copied to memory on central processor . The NMS also creates a software load record in SMS table , \u2032 indicating the upgrade. In this embodiment, when the SMS determines that the scope of the upgrade requires an upgrade to the configuration database, the master SMS instructs slave SMS on central processor  to perform the upgrade. Slave SMS works with slave SRM to cause backup processor  to change from backup mode to upgrade mode.","In upgrade mode, backup processor  stops replicating the active state of central processor . Any changes made to new configuration database  are copied to new NMS database \u2032. Slave SMS then directs slave SRM to execute the configuration control file which uses DDL file \u2032 to upgrade configuration database .","Once configuration database  is upgraded, a fail-over or switch-over from central processor  to backup central processor  is initiated. Central processor  then begins acting as the primary central processor and applications running on central processor  and other boards throughout computer system  begin using upgraded configuration database .","Central processor  may not become the backup central processor right away. Instead, central processor  with its older copy of configuration database  stays dormant in case an automatic downgrade is necessary (described below). If the upgrade goes smoothly and is committed (described below), then central processor  will begin operating in backup mode and replace old configuration database  with new configuration database .","Device Driver Upgrade:","Device driver software may also be upgraded and the implementation of device driver upgrades is similar to the implementation of application upgrades. The user informs the NMS of the device driver change and provides a copy of the new software (e.g., DDA^.exe , ). The NMS downloads the new device driver to memory  on central processor , and the NMS writes a new record in SMS table  indicating the device driver upgrade. Configuration database  sends a notification to master SMS  including the name of the driver to be upgraded. To determine where the original device driver is currently running in computer system , the master SMS searches PMD file  for a match of the device driver name (existing device driver, not upgraded device driver) to learn with which module type and version number the device driver is associated. The device driver may be running on one or more boards in computer system . As described above, the PMD file corresponds the module type and version number of a board with the mission kernel image for that board as well as the device drivers for that board. The SMS then searches card table  for a match with the module type and version number found in the PMD file. Card table  includes records corresponding module type and version number with the physical identification (PID) and slot number of that board. The master SMS now knows the board or boards within computer system  on which to load the upgraded device driver. If the device driver is for a particular port, then the SMS must also search the port table to learn the PID for that port.","The master SMS notifies each slave SMS running on boards to be upgraded of the name of the device driver executable file to download and execute. In the example, master SMS  sends slave SMS the name of the upgraded device driver (DDA^.exe ) to download. Slave SMS tells slave SRM to download and execute DDA^.exe  in upgrade mode. Once downloaded, DDA^.exe  (copy of DDA^.exe ) gathers active state information from the currently running DD.exe  in a similar fashion as a redundant or backup device driver would gather active state. DDA^.exe  then notifies slave SRM that active state has been gathered, and slave SRM stops the current DD.exe  process and transitions the upgraded DDA^.exe  process to the primary role.","Automatic Downgrade:","Often, implementation of an upgrade, can cause unexpected errors in the upgraded software, in other applications or in hardware. As described above, a new configuration database \u2032 () is generated and changes to the new configuration database are made in new tables (e.g., ATM interface table \u2032 and ATM group table \u2032, ) and new executable files (e.g., ATMv2.exe , ATMv2_cntrl.exe  and ATMv2_cnfg_cntrl.exe ) are downloaded to memory . Importantly, the old configuration database records and the original application files are not deleted or altered. In the embodiment where changes are made directly to configuration database  on central processor , they are made only in non-persistent memory until committed (described below). In the embodiment where changes are made to backup configuration database  on backup central processor , original configuration database  remains unchanged.","Because the operating system provides a protected memory model that assigns different process blocks to different processes, including upgraded applications, the original applications will not share memory space with the upgraded applications and, therefore, cannot corrupt or change the memory used by the original application. Similarly, memory  is capable of simultaneously maintaining the original and upgraded versions of the configuration database records and executable files as well as the original and upgraded versions of the applications (e.g., ATM \u2013). As a result, the SMS is capable of an automatic downgrade on the detection of an error. To allow for automatic downgrade, the SRMs pass error information to the SMS. The SMS may cause the system to revert to the old configuration and application (i.e., automatic downgrade) on any error or only for particular errors.","As mentioned, often upgrades to one application may cause unexpected faults or errors in other software. If the problem causes a system shut down and the configuration upgrade was stored in persistent storage, then the system, when powered back up, will experience the error again and shut down again. Since, the upgrade changes to the configuration database are not copied to persistent storage  until the upgrade is committed, if the computer system is shut down, when it is powered back up, it will use the original version of the configuration database and the original executable files, that is, the computer system will experience an automatic downgrade.","Additionally, a fault induced by an upgrade may cause the system to hang, that is, the computer system will not shut down but will also become inaccessible by the NMS and inoperable. To address this concern, in one embodiment, the NMS and the master SMS periodically send messages to each other indicating they are executing appropriately. If the SMS does not receive one of these messages in a predetermined period of time, then the SMS knows the system has hung. The master SMS may then tell the slave SMSs to revert to the old configuration (i.e., previously executing copies of ATM \u2013) and if that does not work, the master SMS may re-start\/re-boot computer system . Again, because the configuration changes were not saved in persistent storage, when the computer system powers back up, the old configuration will be the one implemented.","Evaluation Mode:","Instead of implementing a change to a distributed application across the entire computer system, an evaluation mode allows the SMS to implement the change in only a portion of the computer system. If the evaluation mode is successful, then the SMS may fully implement the change system wide. If the evaluation mode is unsuccessful, then service interruption is limited to only that portion of the computer system on which the upgrade was deployed. In the above example, instead of executing the upgraded ATMv2  on each of the line cards, the ATMv2 configuration convert file  will create an ATMv2 group table \u2032 indicating an upgrade only to one line card, for example, line card . Moreover, if multiple instantiations of ATM are running on line card (e.g., one instantiation per port), the ATMv2 configuration convert file may indicate through ATMv2 interface table \u2032 that the upgrade is for only one instantiation (e.g., one port) on line card . Consequently, a failure is likely to only disrupt service on that one port, and again, the SMS can further minimize the disruption by automatically downgrading the configuration of that port on the detection of an error. If no error is detected during the evaluation mode, then the upgrade can be implemented over the entire computer system.","Upgrade Commitment:","Upgrades are made permanent by saving the new application software and new configuration database and DDL file in persistent storage and removing the old configuration data from memory  as well as persistent storage. As mentioned above, changes may be automatically saved in persistent storage as they are made in non-persistent memory (no automatic downgrade), or the user may choose to automatically commit an upgrade after a successful time interval lapses (evaluation mode). The time interval from upgrade to commitment may be significant. During this time, configuration changes may be made to the system. Since these changes are typically made in non-persistent memory, they will be lost if the system is rebooted prior to upgrade commitment. Instead, to maintain the changes, the user may request that certain configuration changes made prior to upgrade commitment be copied into the old configuration database in persistent memory. Alternatively, the user may choose to manually commit the upgrade at his or her leisure. In the manual mode, the user would ask the NMS to commit the upgrade and the NMS would inform the master SMS, for example, through a record in the SMS table.","Independent Process Failure and Restart:","Depending upon the fault policy managed by the slave SRMs on each board, the failure of an application or device driver may not immediately cause an automatic downgrade during an upgrade process. Similarly, the failure of an application or device driver during normal operation may not immediately cause the fail over to a backup or redundant board. Instead, the slave SRM running on the board may simply restart the failing process. After multiple failures by the same process, the fault policy may cause the SRM to take more aggressive measures such as automatic downgrade or fail-over.","Referring to , if an application, for example, ATM application  fails, the slave SRM on the same board as ATM  may simply restart it without having to reboot the entire system. As described above, under the protected memory model, a failing process cannot corrupt the memory blocks used by other processes. Typically, an application and its corresponding device drivers would be part of the same memory block or even part of the same software program, such that if the application failed, both the application and device drivers would need to be restarted. Under the modular software architecture, however, applications, for example ATM application , are independent of the device drivers, for example, ATM driver  and Device Drivers (DD) \u2013. This separation of the data plane (device drivers) and control plane (applications) results in the device drivers being peers of the applications. Hence, while the ATM application is terminated and restarted, the device drivers continue to function.","For network devices, this separation of the control plane and data plane means that the connections previously established by the ATM application are not lost when ATM fails and hardware controlled by the device drivers continue to pass data through connections previously established by the ATM application. Until the ATM application is restarted and re-synchronized (e.g., through an audit process, described below) with the active state of the device drivers, no new network connections may be established but the device drivers continue to pass data through the previously established connections to allow the network device to minimize disruption and maintain high availability.","Local Backup:","If a device driver, for example, device driver , fails instead of an application, for example, ATM , then data cannot be passed. For a network device, it is critical to continue to pass data and not lose network connections. Hence, the failed device driver must be brought back up (i.e., recovered) as soon as possible. In addition, the failing device driver may have corrupted the hardware it controls, therefore, that hardware must be reset and reinitialized. The hardware may be reset as soon as the device driver terminates or the hardware may be reset later when the device driver is restarted. Resetting the hardware stops data flow. In some instances, therefore, resetting the hardware will be delayed until the device driver is restarted to minimize the time period during which data is not flowing. Alternatively, the failing device driver may have corrupted the hardware, thus, resetting the hardware as soon as the device driver is terminated may be important to prevent data corruption. In either case, the device driver re-initializes the hardware during its recovery.","Again, because applications and device drivers are assigned independent memory blocks, a failed device driver can be restarted without having to restart associated applications and device drivers. Independent recovery may save significant time as described above for applications. In addition, restoring the data plane (i.e., device drivers) can be simpler and faster than restoring the control plane (i.e., applications). While it may be just as challenging in terms of raw data size, device driver recovery may simply require that critical state data be copied into place in a few large blocks, as opposed to application recovery which requires the successive application of individual configuration elements and considerable parsing, checking and analyzing. In addition, the application may require data stored in the configuration database on the central processor or data stored in the memory of other boards. The configuration database may be slow to access especially since many other applications also access this database. The application may also need time to access a management information base (MIB) interface.","To increase the speed with which a device driver is brought back up, the restarted device driver program accesses local backup . In one example, local backup is a simple storage\/retrieval process that maintains the data in simple lists in physical memory (e.g., random access memory, RAM) for quick access. Alternatively, local backup may be a database process, for example, a Polyhedra database, similar to the configuration database.","Local backup  stores the last snap shot of critical state information used by the original device driver before it failed. The data in local backup  is in the format required by the device driver. In the case of a network device, local back up data may include path information, for example, service endpoint, path width and path location. Local back up data may also include virtual interface information, for example, which virtual interfaces were configured on which paths and virtual circuit (VC) information, for example, whether each VC is switched or passed through segmentation and reassembly (SAR), whether each VC is a virtual channel or virtual path and whether each VC is multicast or merge. The data may also include traffic parameters for each VC, for example, service class, bandwidth and\/or delay requirements.","Using the data in the local backup allows the device driver to quickly recover. An Audit process resynchronizes the restarted device driver with associated applications and other device drivers such that the data plane can again transfer network data. Having the backup be local reduces recovery time. Alternatively, the backup could be stored remotely on another board but the recovery time would be increased by the amount of time required to download the information from the remote location.","Audit Process:","It is virtually impossible to ensure that a failed process is synchronized with other processes when it restarts, even when backup data is available. For example, an ATM application may have set up or torn down a connection with a device driver but the device driver failed before it updated corresponding backup data. When the device driver is restarted, it will have a different list of established connections than the corresponding ATM application (i.e., out of synchronization). The audit process allows processes like device drivers and ATM applications to compare information, for example, connection tables, and resolve differences. For instance, connections included in the driver's connection table and not in the ATM connection table were likely torn down by ATM prior to the device driver crash and are, therefore, deleted from the device driver connection table. Connections that exist in the ATM connection table and not in the device driver connection table were likely set up prior to the device driver failure and may be copied into the device driver connection table or deleted from the ATM connection table and re-set up later. If an ATM application fails and is restarted, it must execute an audit procedure with its corresponding device driver or drivers as well as with other ATM applications since this is a distributed application.","Vertical Fault Isolation:","Typically, a single instance of an application executes on a single card or in a system. Fault isolation, therefore, occurs at the card level or the system level, and if a fault occurs, an entire card\u2014and all the ports on that card\u2014or the entire system\u2014and all the ports in the system\u2014is affected. In a large communications platform, thousands of customers may experience service outages due to a single process failure.","For resiliency and fault isolation one or more instances of an application and\/or device driver may be started per port on each line card. Multiple instances of applications and device drivers are more difficult to manage and require more processor cycles than a single instance of each but if an application or device driver fails, only the port those processes are associated with is affected. Other applications and associated ports\u2014as well as the customers serviced by those ports\u2014will not experience service outages. Similarly, a hardware failure associated with only one port will only affect the processes associated with that port. This is referred to as vertical fault isolation.","Referring to , as one example, line card is shown to include four vertical stacks , , , and . Vertical stack  includes one instance of ATM  and one device driver and is associated with port . Similarly, vertical stacks ,  and  include one instance of ATM , ,  and one device driver , , , respectively and each vertical stack is associated with a separate port , , , respectively. If ATM  fails, then only vertical stack  and its associated port are affected. Service is not disrupted on the other ports (ports , , ) since vertical stacks , , and  are unaffected and the applications and drivers within those stacks continue to execute and transmit data. Similarly, if device driver fails, then only vertical stack  and its associated port are affected.","Vertical fault isolation allows processes to be deployed in a fashion supportive of the underlying hardware architecture and allows processes associated with particular hardware (e.g., a port) to be isolated from processes associated with other hardware (e.g., other ports) on the same or a different line card. Any single hardware or software failure will affect only those customers serviced by the same vertical stack. Vertical fault isolation provides a fine grain of fault isolation and containment. In addition, recovery time is reduced to only the time required to re-start a particular application or driver instead of the time required to re-start all the processes associated with a line card or the entire system.","Fault\/Event Detection:","Traditionally, fault detection and monitoring does not receive a great deal of attention from network equipment designers. Hardware components are subjected to a suite of diagnostic tests when the system powers up. After that, the only way to detect a hardware failure is to watch for a red light on a board or wait for a software component to fail when it attempts to use the faulty hardware. Software monitoring is also reactive. When a program fails, the operating system usually detects the failure and records minimal debug information.","Current methods provide only sporadic coverage for a narrow set of hard faults. Many subtler failures and events often go undetected. For example, hardware components sometimes suffer a minor deterioration in functionality, and changing network conditions stress the software in ways that were never expected by the designers. At times, the software may be equipped with the appropriate instrumentation to detect these problems before they become hard failures, but even then, network operators are responsible for manually detecting and repairing the conditions.","Systems with high availability goals must adopt a more proactive approach to fault and event monitoring. In order to provide comprehensive fault and event detection, different hierarchical levels of fault\/event management software are provided that intelligently monitor hardware and software and proactively take action in accordance with a defined fault policy. A fault policy based on hierarchical scopes ensures that for each particular type of failure the most appropriate action is taken. This is important because over-reacting to a failure, for example, re-booting an entire computer system or re-starting an entire line card, may severely and unnecessarily impact service to customers not affected by the failure, and under-reacting to failures, for example, restarting only one process, may not completely resolve the fault and lead to additional, larger failures. Monitoring and proactively responding to events may also allow the computer system and network operators to address issues before they become failures. For example, additional memory may be assigned to programs or added to the computer system before a lack of memory causes a failure.","Hierarchical Scopes and Escalation:","Referring to , in one embodiment, master SRM  serves as the top hierarchical level fault\/event manager, each slave SRM \u2013serves as the next hierarchical level fault\/event manager, and software applications resident on each board, for example, ATM \u2013 and device drivers \u2013on line card include sub-processes that serve as the lowest hierarchical level fault\/event managers (i.e., local resiliency managers, LRM).","Master SRM  downloads default fault policy (DFP) files (metadata) \u2013from persistent storage to memory . Master SRM  reads a master default fault policy file (e.g., DFP ) to understand its fault policy, and each slave SRM \u2013downloads a default fault policy file (e.g., DFP \u2013) corresponding to the board on which the slave SRM is running. Each slave SRM then passes to each LRM a fault policy specific to each local process.","A master logging entity  also runs on central processor  and slave logging entities \u2013run on each board. Notifications of failures and other events are sent by the master SRM, slave SRMs and LRMs to their local logging entity which then notifies the master logging entity. The master logging entity enters the event in a master event log file . Each local logging entity may also log local events in a local event log file \u2013","In addition, a fault policy table  may be created in configuration database  by the NMS when the user wishes to over-ride some or all of the default fault policy (see configurable fault policy below), and the master and slave SRMs are notified of the fault policies through the active query process.","Referring to , as one example, ATM application  includes many sub-processes including, for example, an LRM program , a Private Network-to-Network Interface (PNNI) program , an Interim Link Management Interface (ILMI) program , a Service Specific Connection Oriented Protocol (SSCOP) program , and an ATM signaling (SIG) program . ATM application  may include many other sub-programs only a few have been shown for convenience. Each sub-process may also include sub-processes, for example, ILMI sub-processes \u2013. In general, the upper level application (e.g., ATM ) is assigned a process memory block that is shared by all its sub-processes.","If, for example, SSCOP  detects a fault, it notifies LRM . LRM  passes the fault to local slave SRM , which catalogs the fault in the ATM application's fault history and sends a notice to local slave logging entity . The slave logging entity sends a notice to master logging entity , which may log the event in master log event file . The local logging entity may also log the failure in local event log . LRM  also determines, based on the type of failure, whether it can fully resolve the error and do so without affecting other processes outside its scope, for example, ATM \u2013, device drivers \u2013and their sub-processes and processes running on other boards. If yes, then the LRM takes corrective action in accordance with its fault policy. Corrective action may include restarting SSCOP  or resetting it to a known state.","Since all sub-processes within an application, including the LRM sub-process, share the same memory space, it may be insufficient to restart or reset a failing sub-process (e.g., SSCOP ). Hence, for most failures, the fault policy will cause the LRM to escalate the failure to the local slave SRM. In addition, many failures will not be presented to the LRM but will, instead, be presented directly to the local slave SRM. These failures are likely to have been detected by either processor exceptions, OS errors or low-level system service errors. Instead of failures, however, the sub-processes may notify the LRM of events that may require action. For example, the LRM may be notified that the PNNI message queue is growing quickly. The LRM's fault policy may direct it to request more memory from the operating system. The LRM will also pass the event to the local slave SRM as a non-fatal fault. The local slave SRM will catalog the event and log it with the local logging entity, which may also log it with the master logging entity. The local slave SRM may take more severe action to recover from an excessive number of these non-fatal faults that result in memory requests.","If the event or fault (or the actions required to handle either) will affect processes outside the LRM's scope, then the LRM notifies slave SRM of the event or failure. In addition, if the LRM detects and logs the same failure or event multiple times and in excess of a predetermined threshold set within the fault policy, the LRM may escalate the failure or event to the next hierarchical scope by notifying slave SRM . Alternatively or in addition, the slave SRM may use the fault history for the application instance to determine when a threshold is exceeded and automatically execute its fault policy.","When slave SRM detects or is notified of a failure or event, it notifies slave logging entity . The slave logging entity notifies master logging entity , which may log the failure or event in master event log , and the slave logging entity may also log the failure or event in local event log . Slave SRM also determines, based on the type of failure or event, whether it can handle the error without affecting other processes outside its scope, for example, processes running on other boards. If yes, then slave SRM takes corrective action in accordance with its fault policy and logs the fault. Corrective action may include re-starting one or more applications on line card ","If the fault or recovery actions will affect processes outside the slave SRM's scope, then the slave SRM notifies master SRM . In addition, if the slave SRM has detected and logged the same failure multiple times and in excess of a predetermined threshold, then the slave SRM may escalate the failure to the next hierarchical scope by notifying master SRM  of the failure. Alternatively, the master SRM may use its fault history for a particular line card to determine when a threshold is exceeded and automatically execute its fault policy.","When master SRM  detects or receives notice of a failure or event, it notifies slave logging entity , which notifies master logging entity . The master logging entity  may log the failure or event in master log file  and the slave logging entity may log the failure or event in local event log . Master SRM  also determines the appropriate corrective action based on the type of failure or event and its fault policy. Corrective action may require failing-over one or more line cards \u2013or other boards, including central processor , to redundant backup boards or, where backup boards are not available, simply shutting particular boards down. Some failures may require the master SRM to re-boot the entire computer system.","An example of a common error is a memory access error. As described above, when the slave SRM starts a newinstance of an application, it requests a protected memory block from the local operating system. The local operating systems assign each instance of an application one block of local memory and then program the local memory management unit (MMU) hardware with which processes have access (read and\/or write) to each block of memory. An MMU detects a memory access error when a process attempts to access a memory block not assigned to that process. This type of error may result when the process generates an invalid memory pointer. The MMU prevents the failing process from corrupting memory blocks used by other processes (i.e., protected memory model) and sends a hardware exception to the local processor. A local operating system fault handler detects the hardware exception and determines which process attempted the invalid memory access. The fault handler then notifies the local slave SRM of the hardware exception and the process that caused it. The slave SRM determines the application instance within which the fault occurred and then goes through the process described above to determine whether to take corrective action, such as restarting the application, or escalate the fault to the master SRM.","As another example, a device driver, for example, device driver may determine that the hardware associated with its port, for example, port , is in a bad state. Since the failure may require the hardware to be swapped out or failed-over to redundant hardware or the device driver itself to be re-started, the device driver notifies slave SRM . The slave SRM then goes through the process described above to determine whether to take corrective action or escalate the fault to the master SRM.","As a third example, if a particular application instance repeatedly experiences the same software error but other similar application instances running on different ports do not experience the same error, the slave SRM may determine that it is likely a hardware error. The slave SRM would then notify the master SRM which may initiate a fail-over to a backup board or, if no backup board exists, simply shut down that board or only the failing port on that board. Similarly, if the master SRM receives failure reports from multiple boards indicating Ethernet failures, the master SRM may determine that the Ethernet hardware is the problem and initiate a fail-over to backup Ethernet hardware.","Consequently, the failure type and the failure policy determine at what scope recovery action will be taken. The higher the scope of the recovery action, the larger the temporary loss of services. Speed of recovery is one of the primary considerations when establishing a fault policy. Restarting a single software process is much faster than switching over an entire board to a redundant board or re-booting the entire computer system. When a single process is restarted, only a fraction of a card's services are affected. Allowing failures to be handled at appropriate hierarchical levels avoids unnecessary recovery actions while ensuring that sufficient recovery actions are taken, both of which minimize service disruption to customers.","Hierarchical Descriptors:","Hierarchical descriptors may be used to provide information specific to each failure or event. The hierarchical descriptors provide granularity with which to report faults, take action based on fault history and apply fault recovery policies. The descriptors can be stored in master event log file  or local event log files \u2013through which faults and events may be tracked and displayed to the user and allow for fault detection at a fine granular level and proactive response to events. In addition, the descriptors can be matched with descriptors in the fault policy to determine the recovery action to be taken.","Referring to , in one embodiment, a descriptor  includes a top hierarchical class field , a next hierarchical level sub-class field , a lower hierarchical level type field  and a lowest level instance field . The class field indicates whether the failure or event is related (or suspected to relate) to hardware or software. The subclass field categorizes events and failures into particular hardware or software groups. For example, under the hardware class, subclass indications may include whether the fault or event is related to memory, Ethernet, switch fabric or network data transfer hardware. Under the software class, subclass indications may include whether the fault or event is a system fault, an exception or related to a specific application, for example, ATM.","The type field more specifically defines the subclass failure or event. For example, if a hardware class, Ethernet subclass failure has occurred, the type field may indicate a more specific type of Ethernet failure, for instance, a cyclic redundancy check (CRC) error or a runt packet error. Similarly, if a software class, ATM failure or event has occurred, the type field may indicate a more specific type of ATM failure or event, for instance, a private network-to-network interface (PNNI) error or a growing message queue event. The instance field identifies the actual hardware or software that failed or generated the event. For example, with regard to a hardware class, Ethernet subclass, CRC type failure, the instance indicates the actual Ethernet port that experienced the failure. Similarly, with regard to a software class, ATM subclass, PNNI type, the instance indicates the actual PNNI sub-program that experienced the failure or generated the event.","When a fault or event occurs, the hierarchical scope that first detects the failure or event creates a descriptor by filling in the fields described above. In some cases, however, the Instance field is not applicable. The descriptor is sent to the local logging entity, which may log it in the local event log file before notifying the master logging entity, which may log it in the master event log file . The descriptor may also be sent to the local slave SRM, which tracks fault history based on the descriptor contents per application instance. If the fault or event is escalated, then the descriptor is passed to the next higher hierarchical scope.","When slave SRM receives the fault\/event notification and the descriptor, it compares it to descriptors in the fault policy for the particular scope in which the fault occurred looking for a match or a best case match which will indicate the recovery procedure to follow. Fault descriptors within the fault policy can either be complete descriptors or have wildcards in one or more fields. Since the descriptors are hierarchical from left to right, wildcards in descriptor fields only make sense from right to left. The fewer the fields with wildcards, the more specific the descriptor. For example, a particular fault policy may apply to all software faults and would, therefore, include a fault descriptor having the class field set to \u201csoftware\u201d and the remaining fields\u2014subclass, type, and instance\u2014set to wildcard or \u201cmatch all.\u201d The slave SRM searches the fault policy for the best match (i.e., the most fields matched) with the descriptor to determine the recovery action to be taken.","Configurable Fault Policy:","In actual use, a computer system is likely to encounter scenarios that differ from those in which the system was designed and tested. Consequently, it is nearly impossible to determine all the ways in which a computer system might fail, and in the face of an unexpected error, the default fault policy that was shipped with the computer system may cause the hierarchical scope (master SRM, slave SRM or LRM) to under-react or over-react. Even for expected errors, after a computer system ships, certain recovery actions in the default fault policy may be determined to be over aggressive or too lenient. Similar issues may arise as new software and hardware is released and\/or upgraded.","A configurable fault policy allows the default fault policy to be modified to address behavior specific to a particular upgrade or release or to address behavior that was learned after the implementation was released. In addition, a configurable fault policy allows users to perform manual overrides to suit their specific requirements and to tailor their policies based on the individual failure scenarios that they are experiencing. The modification may cause the hierarchical scope to react more or less aggressively to particular known faults or events, and the modification may add recovery actions to handle newly learned faults or events. The modification may also provide a temporary patch while a software or hardware upgrade is developed to fix a particular error.","If an application runs out of memory space, it notifies the operating system and asks for more memory. For certain applications, this is standard operating procedure. As an example, an ATM application may have set up a large number of virtual circuits and to continue setting up more, additional memory is needed. For other applications, a request for more memory indicates a memory leak error. The fault policy may require that the application be re-started causing some service disruption. It may be that re-starting the application eventually leads to the same error due to a bug in the software. In this instance, while a software upgrade to fix the bug is developed, a temporary patch to the fault policy may be necessary to allow the memory leak to continue and prevent repeated application re-starts that may escalate to line card re-start or fail-over and eventually to a re-boot of the entire computer system. A temporary patch to the default fault policy may simply allow the hierarchical scope, for example, the local resiliency manager or the slave SRM, to assign additional memory to the application. Of course, an eventual re-start of the application is likely to be required if the application's leak consumes too much memory.","A temporary patch may also be needed while a hardware upgrade or fix is developed for a particular hardware fault. For instance, under the default fault policy, when a particular hardware fault occurs, the recovery policy may be to fail-over to a backup board. If the backup board includes the same hardware with the same hardware bug, for example, a particular semiconductor chip, then the same error will occur on the backup board. To prevent a repetitive fail-over while a hardware fix is developed, the temporary patch to the default fault policy may be to restart the device driver associated with the particular hardware instead of failing-over to the backup board.","In addition to the above needs, a configurable fault policy also allows purchasers of computer system  (e.g., network service providers) to define their own policies. For example, a network service provider may have a high priority customer on a particular port and may want all errors and events (even minor ones) to be reported to the NMS and displayed to the network manager. Watching all errors and events might give the network manager early notice of growing resource consumption and the need to plan to dedicate additional resources to this customer.","As another example, a user of computer system  may want to be notified when any process requests more memory. This may give the user early notice of the need to add more memory to their system or to move some customers to different line cards.","Referring again to , to change the default fault policy as defined by default fault policy (DFP) files \u2013, a configuration fault policy file  is created by the NMS in the configuration database. An active query notification is sent by the configuration database to the master SRM indicating the changes to the default fault policy. The master SRM notifies any slave SRMs of any changes to the default fault policies specific to the boards on which they are executing, and the slave SRMs notify any LRMs of any changes to the default fault policies specific to their process. Going forward, the default fault policies\u2014as modified by the configuration fault policy\u2014are used to detect, track and respond to events or failures.","Alternatively, active queries may be established with the configuration database for configuration fault policies specific to each board type such that the slave SRMs are notified directly of changes to their default fault policies.","A fault policy (whether default or configured) is specific to a particular scope and descriptor and indicates a particular recovery action to take. As one example, a temporary patch may be required to handle hardware faults specific to a known bug in an integrated circuit chip. The configured fault policy, therefore, may indicate a scope of all line cards, if the component is on all line cards, or only a specific type of line card that includes that component. The configured fault policy may also indicate that it is to be applied to all hardware faults with that scope, for example, the class will indicate hardware (HW) and all other fields will include wildcards (e.g., HW.*.*.*). Instead, the configured fault policy may only indicate a particular type of hardware failure, for example, CRC errors on transmitted Ethernet packets (e.g., HW.Ethernet.TxCRC.*).","Redundancy:","As previously mentioned, a major concern for service providers is network downtime. In pursuit of \u201cfive 9's availability\u201d or 99.999% network up time, service providers must minimize network outages due to equipment (i.e., hardware) and all too common software failures. Developers of computer systems often use redundancy measures to minimize downtime and enhance system resiliency. Redundant designs rely on alternate or backup resources to overcome hardware and\/or software faults. Ideally, the redundancy architecture allows the computer system to continue operating in the face of a fault with minimal service disruption, for example, in a manner transparent to the service provider's customer.","Generally, redundancy designs come in two forms: 1:1 and 1:N. In a so-called \u201c1:1 redundancy\u201d design, a backup element exists for every active or primary element (i.e., hardware backup). In the event that a fault affects a primary element, a corresponding backup element is substituted for the primary element. If the backup element has not been in a \u201chot\u201d state (i.e., software backup), then the backup element must be booted, configured to operate as a substitute for the failing element, and also provided with the \u201cactive state\u201d of the failing element to allow the backup element to take over where the failed primary element left off. The time required to bring the software on the backup element to an \u201cactive state\u201d is referred to as synchronization time. A long synchronization time can significantly disrupt system service, and in the case of a computer network device, if synchronization is not done quickly enough, then hundreds or thousands of network connections may be lost which directly impacts the service provider's availability statistics and angers network customers.","To minimize synchronization time, many 1:1 redundancy schemes support hot backup of software, which means that the software on the backup elements mirror the software on the primary elements at some level. The \u201chotter\u201d the backup element\u2014that is, the closer the backup mirrors the primary\u2014the faster a failed primary can be switched over or failed over to the backup. The \u201chottest\u201d backup element is one that runs hardware and software simultaneously with a primary element conducting all operations in parallel with the primary element. This is referred to as a \u201c1+1 redundancy\u201d design and provides the fastest synchronization.","Significant costs are associated with 1:1 and 1+1 redundancy. For example, additional hardware costs may include duplicate memory components and printed circuit boards including all the components on those boards. The additional hardware may also require a larger supporting chassis. Space is often limited, especially in the case of network service providers who may maintain hundreds of network devices. Although 1:1 redundancy improves system reliability, it decreases service density and decreases the mean time between failures. Service density refers to the proportionality between the net output of a particular device and its gross hardware capability. Net output, in the case of a network device (e.g., switch or router), might include, for example, the number of calls handled per second. Redundancy adds to gross hardware capability but not to the net output and, thus, decreases service density. Adding hardware increases the likelihood of a failure and, thus, decreases the mean time between failures. Likewise, hot backup comes at the expense of system power. Each active element consumes some amount of the limited power available to the system. In general, the 1+1 or 1:1 redundancy designs provide the highest reliability but at a relatively high cost. Due to the importance of network availability, most network service providers prefer the 1+1 redundancy design to minimize network downtime.","In a 1:N redundancy design, instead of having one backup element per primary element, a single backup element or spare is used to backup multiple (N) primary elements. As a result, the 1:N design is generally less expensive to manufacture, offers greater service density and better mean time between failures than the 1:1 design and requires a smaller chassis\/less space than a 1:1 design. One disadvantage of such a system, however, is that once a primary element fails over to the backup element, the system is no longer redundant (i.e., no available backup element for any primary element). Another disadvantage relates to hot state backup. Because one backup element must support multiple primary elements, the typical 1:N design provides no hot state on the backup element leading to long synchronization times and, for network devices, the likelihood that connections will be dropped and availability reduced.","Even where the backup element provides some level of hot state backup it generally lacks the processing power and memory to provide a full hot state backup (i.e., 1+N) for all primary elements. To enable some level of hot state backup for each primary element, the backup element is generally a \u201cmega spare\u201d equipped with a more powerful processor and additional memory. This requires customers to stock more hardware than in a design with identical backup and primary elements. For instance, users typically maintain extra hardware in the case of a failure. If a primary fails over to the backup, the failed primary may be replaced with a new primary. If the primary and backup elements are identical, then users need only stock that one type of board, that is, a failed backup is also replaced with the same hardware used to replace the failed primary. If they are different, then the user must stock each type of board, thereby increasing the user's cost.","Distributed Redundancy:","A distributed redundancy architecture spreads software backup (hot state) across multiple elements. Each element may provide software backup for one or more other elements. For software backup alone, therefore, the distributed redundancy architecture eliminates the need for hardware backup elements (i.e., spare hardware). Where hardware backup is also provided, spreading resource demands across multiple elements makes it possible to have significant (perhaps full) hot state backup without the need for a mega spare. Identical backup (spare) and primary hardware provides manufacturing advantages and customer inventory advantages. A distributed redundancy design is less expensive than many 1:1 designs and a distributed redundancy architecture also permits the location of the hardware backup element to float, that is, if a primary element fails over to the backup element, when the failed primary element is replaced, that new hardware may serve as the hardware backup.","Software Redundancy:","In its simplest form, a distributed redundancy system provides software redundancy (i.e., backup) with or without redundant (i.e., backup) hardware, for example, with or without using backup line card as discussed earlier with reference to the logical to physical card table (). Referring to , computer system  includes primary line cards , and . Computer system  will likely include additional primary line cards; only three are discussed herein (and shown in ) for convenience. As described above, to load instances of software applications, the NMS creates software load records (SLR) \u2013in configuration database . The SLR includes the name of a control shim executable file and a logical identification (LID) associated with a primary line card on which the application is to be spawned. In the current example, there either are no hardware backup line cards or, if there are, the slave SRM executing on that line card does not download and execute backup applications.","As one example, NMS  creates SLR including the executable name atm_cntrl.exe and card LID  (line card ), SLR including atm_cntrl.exe and LID  (line card ) and SLR including atm_cntrl.exe and LID  (line card ). The configuration database detects LID ,  and  in SLRs , and , respectively, and sends slave SRMs , and (line cards , , and ) notifications including the name of the executable file (e.g., atm_cntrl.exe) to be loaded. The slave SRMs then download and execute a copy of atm_cntrl.exe  from memory  to spawn ATM controllers , and ","Through the active query feature, the ATM controllers are sent records from group table (GT) \u2032 () indicating how many instances of ATM each must start on their associated line cards. Group table \u2032 includes a primary line card LID field  and a backup line card LID field  such that, in addition to starting primary instances of ATM, each primary line card also executes backup instances of ATM. For example, ATM controller receives records \u2013 and \u2013 from group table \u2032 including LID  (line card ). Records \u2013 indicate that ATM controller is to start four primary instantiations of ATM \u2013 (), and records \u2013 indicate that ATM controller is to start four backup instantiations of ATM \u2013 as backup for four primary instantiations on LID  (line card ). Similarly, ATM controller receives records \u2013 from group table \u2032 including LID  (line card ). Records \u2013 indicate that ATM controller is to start four primary instantiations of ATM \u2013, and records \u2013 indicate that ATM controller is to start four backup instantiations of ATM \u2013 as backup for four primary instantiations on LID  (line card ). ATM controller receives records \u2013 from group table \u2032 including LID  (line card ). Records \u2013 indicate that ATM controller is to start four primary instantiations of ATM \u2013, and records \u2013 indicate that ATM controller is to start four backup instantiations of ATM \u2013 as backup for four primary instantiations on LID  (line card ). ATM controllers , and then download atm.exe  and generate the appropriate number of ATM instantiations and also indicate to each instantiation whether it is a primary or backup instantiation. Alternatively, the ATM controllers may download atm.exe and generate the appropriate number of primary ATM instantiations and download a separate backup_atm.exe and generate the appropriate number of backup ATM instantiations.","Each primary instantiation registers with its local name server \u2013, as described above, and each backup instantiation subscribes to its local name server \u2013for information about its corresponding primary instantiation. The name server passes each backup instantiation at least the process identification number assigned to its corresponding primary instantiation, and with this, the backup instantiation sends a message to the primary instantiation to set up a dynamic state check-pointing procedure. Periodically or asynchronously as state changes, the primary instantiation passes dynamic state information to the backup instantiation (i.e., check-pointing). In one embodiment, a Redundancy Manager Service available from Harris and Jefferies of Dedham, Mass. may be used to allow backup and primary instantiations to pass dynamic state information. If the primary instantiation fails, it can be re-started, retrieve its last known dynamic state from the backup instantiation and then initiate an audit procedure (as described above) to resynchronize with other processes. The retrieval and audit process will normally be completed very quickly, resulting in no discernable service disruption.","Although each line card in the example above is instructed by the group table to start four instantiations of ATM, this is by way of example only. The user could instruct the NMS to set up the group table to have each line card start one or more instantiations and to have each line card start a different number of instantiations.","Referring to \u2013, if one or more of the primary processes on element (ATM \u2013) experiences a software fault (), the processor on line card may terminate and restart the failing process or processes. Once the process or processes are restarted (ATM \u2032\u2013\u2032, ), they retrieve a copy of the last known dynamic state (i.e., backup state) from corresponding backup processes (ATM \u2013) executing on line card and initiate an audit process to synchronize retrieved state with the dynamic state of associated other processes. The backup state represents the last known active or dynamic state of the process or processes prior to termination, and retrieving this state from line card allows the restarted processes on line card to quickly resynchronize and continue operating. The retrieval and audit process will normally be completed very quickly, and in the case of a network device, quick resynchronization may avoid losing network connections, resulting in no discernable service disruption.","If, instead of restarting a particular application, the software fault experienced by line card requires the entire element to be shut down and rebooted, then all of the processes executing on line card will be terminated including backup processes ATM \u2013. When the primary processes are restarted, backup state information is retrieved from backup processes executing on line card as explained above. Simultaneously, the restarted backup processes on line card again initiate the check-pointing procedure with primary ATM processes \u2013 executing on line card to again serve as backup processes for these primary processes. Referring to \u2013, the primary processes executing on one line card may be backed-up by backup processes running on one or more other line cards. In addition, each primary process may be backed-up by one or more backup processes executing on one or more of the other line cards.","Since the operating system assigns each process its own memory block, each primary process may be backed-up by a backup process running on the same line card. This would minimize the time required to retrieve backup state and resynchronize if a primary process fails and is restarted. In a computer system that includes a spare or backup line card (described below), the backup state is best saved on another line card such that in the event of a hardware fault, the backup state is not lost and can be copied from the other line card. If memory and processor limitations permit, backup processes may run simultaneously on the same line card as the primary process and on another line card such that software faults are recovered from using local backup state and hardware faults are recovered from using remote backup state.","Where limitations on processing power or memory make full hot state backup impossible or impractical, only certain hot state data will be stored as backup. The level of hot state backup is inversely proportional to the resynchronization time, that is, as the level of hot state backup increases, resynchronization time decreases. For a network device, backup state may include critical information that allows the primary process to quickly re-synchronize.","Critical information for a network device may include connection data relevant to established network connections (e.g., call set up information and virtual circuit information). For example, after primary ATM applications \u2013, executing on line card , establish network connections, those applications send critical state information relevant to those connections to backup ATM applications \u2013 executing on line card . Retrieving connection data allows the hardware (i.e., line card ) to send and receive network data over the previously established network connections preventing these connections from being terminated\/dropped.","Although ATM applications were used in the examples above, this is by way of example only. Any application (e.g., IP or MPLS), process (e.g., MCD or NS) or device driver (e.g., port driver) may have a backup process started on another line card to store backup state through a check-pointing procedure.","Hardware and Software Backup:","By adding one or more hardware backup elements (e.g., line card ) to the computer system, the distributed redundancy architecture provides both hardware and software backup. Software backup may be spread across all of the line cards or only some of the line cards. For example, software backup may be spread only across the primary line cards, only on one or more backup line cards or on a combination of both primary and backup line cards.","Referring to , in the continuing example, line cards , and are primary hardware elements and line card is a spare or backup hardware element. In this example, software backup is spread across only the primary line cards. Alternatively, backup line card may also execute backup processes to provide software backup. Backup line card may execute all backup processes such that the primary elements need not execute any backup processes or line card may execute only some of the backup processes. Regardless of whether backup line card executes any backup processes, it is preferred that line card be at least partially operational and ready to use the backup processes to quickly begin performing as if it was a failed primary line card.","There are many levels at which a backup line card may be partially operational. For example, the backup line card's hardware may be configured and device driver processes  loaded and ready to execute. In addition, the active state of the device drivers , , and  on each of the primary line cards may be stored as backup device driver state (DDS) , ,  on backup line card such that after a primary line card fails, the backup device driver state corresponding to that primary element is used by device driver processes  to quickly synchronize the hardware on backup line card ","In addition, data reflecting the network connections established by each primary process may be stored within each of the backup processes or independently on backup line card , for example, connection data (CD) , , . Having a copy of the connection data on the backup line card allows the hardware to quickly begin transmitting network data over previously established connections to avoid the loss of these connections and minimize service disruption. The more operational (i.e., hotter) backup line card is the faster it will be able to transfer data over network connections previously established by the failed primary line card and resynchronize with the rest of the system.","In the case of a primary line card hardware fault, the backup or spare line card takes the place of the failed primary line card. The backup line card starts new primary processes that register with the name server on the backup line card and begin retrieving active state from backup processes associated with the original primary processes. As described above, the same may also be true for software faults. Referring to , if, for example, line card in computer system  is affected by a fault, the slave SRM executing on backup line card may start new primary processes \u2032\u2013\u2032 corresponding to the original primary processes \u2013. The new primary processes register with the name server process executing on line card and begin retrieving active state from backup processes \u2013 on line card . This is referred to as a \u201cfail-over\u201d from failed primary line card to backup line card ","As discussed above, preferably, backup line card is partially operational. While active state is being retrieved from backup processes on line card , device driver processes  use device driver state  and connection data  corresponding to failed primary line card to quickly continue passing network data over previously established connections. Once the active state is retrieved then the ATM applications resynchronize and may begin establishing new connections and tearing down old connections.","Floating Backup Element:","Referring to , when the fault is detected on line card , diagnostic tests may be run to determine if the error was caused by software or hardware. If the fault is a software error, then line card may again be used as a primary line card. If the fault is a hardware error, then line card is replaced with a new line card \u2032 that is booted and configured and again ready to be used as a primary element. In one embodiment, once line card or \u2032 is ready to serve as a primary element, a fail-over is initiated from line card to line card or \u2032 as described above, including starting new primary processes \u2033\u2013\u2033 and retrieving active state from primary processes \u2032\u2013\u2032 on line card (or backup processes \u2013 on line card ). Backup processes \u2033\u2013\u2033 are also started, and those backup processes initiate a check-pointing procedure with primary processes \u2013 on line card . This fail-over may cause the same level of service interruption as an actual failure.","Instead of failing-over from line card back to line card or \u2032 and risking further service disruption, line card or \u2032 may serve as the new backup line card with line card serving as the primary line card. If line cards , or experience a fault, a fail-over to line card is initiated as discussed above and the primary line card that failed (or a replacement of that line card) serves as the new backup line card. This is referred to as a \u201cfloating\u201d backup element. Referring to , if, for example, line card experiences a fault, primary processes \u2032\u2013\u2032 are started on backup line card and active state is retrieved from backup processes \u2032\u2013\u2032 on line card . After line card is rebooted or replaced and rebooted, it serves as the new backup line card for primary line cards , and ","Alternatively, computer system  may be physically configured to only allow a line card in a particular chassis slot, for example, line card , to serve as the backup line card. This may be the case where physically, the slot line card is inserted within is wired to provide the necessary connections to allow line card to communicate with each of the other line cards but no other slot provides these connections. In addition, even where the computer system is capable of allowing line cards in other chassis slots to act as the backup line card, the person acting as network manager, may prefer to have the backup line card in each of his computer systems in the same slot. In either case, where only line card serves as the backup line card, once line card (or any other failed primary line card) is ready to act as a primary line card again, a fail-over, as described above, is initiated from line card to the primary line card to allow line card to again serve as a backup line card to each of the primary line cards.","Balancing Resources:","Typically, multiple processes or applications are executed on each primary line card. Referring to , in one embodiment, each primary line card , , executes four applications. Due to physical limitations (e.g., memory space, processor power), each primary line card may not be capable of fully backing up four applications executing on another primary line card. The distributed redundancy architecture allows backup processes to be spread across multiple line cards, including any backup line cards, to more efficiently use all system resources.","For instance, primary line card executes backup processes  and  corresponding to primary processes  and  executing on primary line card . Primary line card executes backup processes  and  corresponding to primary processes  and  executing on primary line card , and primary line card executes backup processes  and  corresponding to primary processes  and  executing on primary line card . Backup line card executes backup processes , , , ,  and  corresponding to primary processes , , , ,  and  executing on each of the primary line cards. Having each primary line card execute backup processes for only two primary processes executing on another primary line card reduces the primary line card resources required for backup. Since backup line card is not executing primary processes, more resources are available for backup. Hence, backup line card executes six backup processes corresponding to six primary processes executing on primary line cards. In addition, backup line card is partially operational and is executing device driver processes  and storing device driver backup state ,  and  corresponding to the device drivers on each of the primary elements and network connection data ,  and  corresponding to the network connections established by each of the primary line cards.","Alternatively, each primary line card could execute more or less than two backup processes. Similarly, each primary line card could execute no backup processes and backup line card could execute all backup processes. Many alternatives are possible and backup processes need not be spread evenly across all primary line cards or all primary line cards and the backup line card.","Referring to , if primary line card experiences a failure, device drivers  on backup line card begins using the device driver state, for example, DDS , corresponding to the device drivers on primary line card and the network connection data, for example, CD , corresponding to the connections established by primary line card to continue transferring network data. Simultaneously, backup line card starts substitute primary processes \u2032 and \u2032 corresponding to the primary processes  and  on failed primary line card . Substitute primary processes \u2032 and \u2032 retrieve active state from backup processes  and  executing on primary line card . In addition, the slave SRM on backup line card informs backup processes  and  corresponding to primary processes  and  on failed primary line card that they are now primary processes. The new primary applications then synchronize with the rest of the system such that new network connections may be established and old network connections torn down. That is, backup line card begins operating as if it were primary line card ","Multiple Backup Elements:","In the examples given above, one backup line card is shown. Alternatively, multiple backup line cards may be provided in a computer system. In one embodiment, a computer system includes multiple different primary line cards. For example, some primary line cards may support the Asynchronous Transfer Mode (ATM) protocol while others support the Multi-Protocol Label Switching (MPLS) protocol, and one backup line card may be provided for the ATM primary line cards and another backup line card may be provided for the MPLS primary line cards. As another example, some primary line cards may support four ports while others support eight ports and one backup line card may be provided for the four port primaries and another backup line card may be provided for the eight port primaries. One or more backup line cards may be provided for each different type of primary line card.","Data Plane:","Referring to , a network device  includes a central processor , a redundant central processor  and a Fast Ethernet control bus  similar to central processors  and  and Ethernet  discussed above with respect to computer system . In addition, network device  includes forwarding cards (FC) \u2013, \u2013, \u2013and \u2013that are similar to line cards \u2013discussed above with respect to computer system . Network device  also includes (and computer system  may also include) universal port (UP) cards \u2013, \u2013, \u2013, and \u2013, cross-connection (XC) cards \u2013, \u2013, \u2013, and \u2013, and switch fabric (SF) cards \u2013. In one embodiment, network device  includes four quadrants where each quadrant includes five forwarding cards (e.g., \u2013), two cross connection cards (e.g., \u2013) and eight universal port cards (e.g., \u2013). Network device  is a distributed processing system. Each of the cards includes a processor and is connected to the Ethernet control bus. In addition, each of the cards are configured as described above with respect to line cards.","In one embodiment, the forwarding cards have a 1:4 hardware redundancy structure and distributed software redundancy as described above. For example, forwarding card is the hardware backup for primary forwarding cards \u2013and each of the forwarding cards provide software backup. The cross-connection cards are 1:1 redundant. For example, cross-connection card provides both hardware and software backup for cross-connection card . Each port on the universal port cards may be 1:1, 1+1, 1:N redundant or not redundant at all depending upon the quality of service paid for by the customer associated with that port. For example, port cards \u2013may be the hardware and software backup cards for port cards \u2013in which case the port cards are 1:1 or 1+1 redundant. As another example, one or more ports on port card may be backed-up by separate ports on one or more port cards (e.g., port cards and ) such that each port is 1:1 or 1+1 redundant, one or more ports on port card may not be backed-up at all (i.e., not redundant) and two or more ports on may be backed-up by one port on another port card (e.g., port card ) such that those ports are 1:N redundant. Many redundancy structures are possible using the LID to PID Card table (LPCT)  () and LID to PID Port table (LPPT) as described above.","Each port card includes one or more ports for connecting to external network connections. One type of network connection is an optical fiber carrying an OC-48 SONET stream, and as described above, an OC-48 SONET stream may include connections to one or more end points using one or more paths. A SONET fiber carries a time division multiplexed (TDM) byte stream of aggregated time slots (TS). A time slot has a bandwidth of 51 Mbps and is the fundamental unit of bandwidth for SONET. An STS-1 path has one time slot within the byte stream dedicated to it, while an STS-3c path (i.e., three concatenated STS-1s) has three time slots within the byte stream dedicated to it. The same or different protocols may be carried over different paths within the same TDM byte stream. In other words, ATM over SONET may be carried on an STS-1 path within a TDM byte stream that also includes IP over SONET on another STS-1 path or on an STS-3c path.","Through network management system  on workstation , after a user connects an external network connection to a port, the user may enable that port and one or more paths within that port (described below). Data received on a port card path is passed to the cross-connection card in the same quadrant as the port card, and the cross-connection card passes the path data to one of the five forwarding cards or eight port cards also within the same quadrant. The forwarding card determines whether the payload (e.g., packets, frames or cells) it is receiving includes user payload data or network control information. The forwarding card itself processes certain network control information and sends certain other network control information to the central processor over the Fast Ethernet control bus. The forwarding card also generates network control payloads and receives network control payloads from the central processor. The forwarding card sends any user data payloads from the cross-connection card or control information from itself or the central processor as path data to the switch fabric card. The switch fabric card then passes the path data to one of the forwarding cards in any quadrant, including the forwarding card that just sent the data to the switch fabric card. That forwarding card then sends the path data to the cross-connection card within its quadrant, which passes the path data to one of the port cards within its quadrant.","Referring to , in one embodiment, a universal port card includes one or more ports \u2013connected to one or more transceivers \u2013. The user may connect an external network connection to each port. As one example, port is connected to an ingress optical fiber carrying an OC-48 SONET stream and an egress optical fiber carrying an OC-48 SONET stream. Port passes optical data from the SONET stream on fiber to transceiver . Transceiver converts the optical data into electrical signals that it sends to a SONET framer . The SONET framer organizes the data it receives from the transceiver into SONET frames. SONET framer sends data over a telecommunications bus to a serializer-deserializer (SERDES) that serializes the data into four serial lines with twelve STS-1 time slots each and transmits the four serial lines to cross-connect card ","Each cross-connection card is a switch that provides connections between port cards and forwarding cards within its quadrant. Each cross-connection card is programmed to transfer each serial line on each port card within its quadrant to a forwarding card within its quadrant or to serial line on a port card, including the port card that transmitted the data to the cross-connection card. The programming of the cross-connect card is discussed in more detail below under Policy Based Provisioning.","Each forwarding card (e.g., forwarding card ) receives SONET frames over serial lines from the cross-connection card in its quadrant through a payload extractor chip (e.g., payload extractor ). In one embodiment, each forwarding card includes four payload extractor chips where each payload extractor chip represents a \u201cslice\u201d and each serial line input represents a forwarding card \u201cport\u201d. Each payload extractor chip receives four serial line inputs, and since each serial line includes twelve STS-1 time slots, the payload extractor chips combine and separate time slots where necessary to output data paths with the appropriate number of time slots. Each STS-1 time slot may represent a separate data path, or multiple STS-1 time slots may need to be combined to form a data path. For example, an STS-3c path requires the combination of three STS-1 time slots to form a data path while an STS-48c path requires the combination of all forty-eight STS-1 time slots. Each path represents a separate network connection, for example, an ATM cell stream.","The payload extractor chip also strips off all vestigial SONET frame information and transfers the data path to an ingress interface chip. The ingress interface chip will be specific to the protocol of the data within the path. As one example, the data may be formatted in accordance with the ATM protocol and the ingress interface chip is an ATM interface chip (e.g., ATM IF ). Other protocols can also be implemented including, for example, Internet Protocol (IP), Multi-Protocol Label Switching (MPLS) protocol or Frame Relay.","The ingress ATM IF chip performs many functions including determining connection information (e.g., virtual circuit or virtual path information) from the ATM header in the payload. The ATM IF chip uses the connection information as well as a forwarding table to perform an address translation from the external address to an internal address. The ATM IF chip passes ATM cells to an ingress bridge chip (e.g., BG \u2013) which serves as an interface to an ingress traffic management chip or chip set (e.g., TM \u2013).","The traffic management chips ensure that high priority traffic, for example, voice data, is passed to switch fabric card faster than lower priority traffic, for example, e-mail data. The traffic management chips may buffer lower priority traffic while higher priority traffic is transmitted, and in times of traffic congestion, the traffic management chips will ensure that low priority traffic is dropped prior to any high priority traffic. The traffic management chips also perform an address translation to add the address of the traffic management chip to which the data is going to be sent by the switch fabric card. The address corresponds to internal virtual circuits set up between forwarding cards by the software and available to the traffic management chips in tables.","The traffic management chips send the modified ATM cells to switch fabric interface chips (SFIF) \u2013that then transfer the ATM cells to switch fabric card . The switch fabric card uses the address provided by the ingress traffic management chips to pass ATM cells to the appropriate egress traffic management chips (e.g., TM \u2013) on the various forwarding cards. In one embodiment, the switch fabric card is a 320 Gbps, non-blocking fabric. Since each forwarding card serves as both an ingress and egress, the switching fabric card provides a high degree of flexibility in directing the data between any of the forwarding cards, including the forwarding card that sent the data to the switch fabric card.","When a forwarding card (e.g., forwarding card ) receives ATM cells from switch fabric card , the egress traffic management chips re-translate the address of each cell and pass the cells to egress bridge chips (e.g., BG \u2013). The bridge chips pass the cells to egress ATM interface chips (e.g., ATM IF \u2013), and the ATM interface chips add a re-translated address to the payload representing an ATM virtual circuit. The ATM interface chips then send the data to the payload extractor chips (e.g., payload extractor \u2013) that separate, where necessary, the path data into STS-1 time slots and combine twelve STS-1 time slots into four serial lines and send the serial lines back through the cross-connection card to the appropriate port card.","The port card SERDES chips receive the serial lines from the cross-connection card and de-serialize the data and send it to SONET framer chips \u2013. The Framers properly format the SONET overhead and send the data back through the transceivers that change the data from electrical to optical before sending it to the appropriate port and SONET fiber.","Although the port card ports above were described as connected to a SONET fiber carrying an OC-48 stream, other SONET fibers carrying other streams (e.g., OC-12) and other types of fibers and cables, for example, Ethernet, may be used instead. The transceivers are standard parts available from many companies, including Hewlett Packard Company and Sumitomo Corporation. The SONET framer may be a Spectra chip available from PMC-Sierra, Inc. in British Columbia. A Spectra 2488 has a maximum bandwidth of 2488 Mbps and may be coupled with a 1xOC48 transceiver coupled with a port connected to a SONET optical fiber carrying an OC-48 stream also having a maximum bandwidth of 2488 Mbps. Instead, four SONET optical fibers carrying OC-12 streams each having a maximum bandwidth of 622 Mbps may be connected to four 1xOC12 transceivers and coupled with one Spectra 2488. Alternatively, a Spectra 4\u00d7155 may be coupled with four OC-3 transceivers that are coupled with ports connected to four SONET fibers carrying OC-3 streams each having a maximum bandwidth of 155 Mbps. Many variables are possible.","The SERDES chip may be a Telecommunications Bus Serializer (TBS) chip from PMC-Sierra, and each cross-connection card may include a Time Switch Element (TSE) from PMC-Sierra, Inc. Similarly, the payload extractor chips may be MACH 48 chips and the ATM interface chips may be ATLAS chips both of which are available from PMC-Sierra. Several chips are available from Extreme Packet Devices (EPD), a subsidiary of PMC-Sierra, including PP3 bridge chips and Data Path Element (DPE) traffic management chips. The switch fabric interface chips may include a Switch Fabric Interface (SIF) chip also from EPD. Other switch fabric interface chips are available from Abrizio, also a subsidiary of PMC-Sierra, including a data slice chip and an enhanced port processor (EPP) chip. The switch fabric card may also include chips from Abrizio, including a cross-bar chip and a scheduler chip.","Although the port cards, cross-connection cards and forwarding cards have been shown as separate cards, this is by way of example only and they may be combined into one or more different cards.","Multiple Redundancy Schemes:","Coupling universal port cards to forwarding cards through a cross-connection card provides flexibility in data transmission by allowing data to be transmitted from any path on any port to any port on any forwarding card. In addition, decoupling the universal port cards and the forwarding cards enables redundancy schemes (e.g., 1:1, 1+1, 1:N, no redundancy) to be set up separately for the forwarding cards and universal port cards. The same redundancy scheme may be set up for both or they may be different. As described above, the LID to PID card and port tables are used to setup the various redundancy schemes for the line cards (forwarding or universal port cards) and ports. Network devices often implement industry standard redundancy schemes, such as those defined by the Automatic Protection Switching (APS) standard. In network device  (), an APS standard redundancy scheme may be implemented for the universal port cards while another redundancy scheme is implemented for the forwarding cards.","Referring again to , further data transmission flexibility may be provided by connecting (i.e., connections ) each cross-connection card \u2013, \u2013, \u2013and \u2013to each of the other cross-connection cards. Through connections , a cross-connection card (e.g., cross-connection card ) may transmit data between any port or any path on any port on a universal port card (e.g., universal port cards \u2013) in its quadrant to a cross-connection card (e.g., cross-connection card ) in any other quadrant, and that cross-connection card (e.g., cross-connection card ) may transmit the data to any forwarding card (e.g., forwarding cards \u2013) or universal port card (e.g., universal port cards \u2013) in its quadrant. Similarly, any cross-connection card may transmit data received from any forwarding card in its quadrant to any other cross-connection card and that cross-connection card may transmit the data to any universal port card port in its quadrant.","Alternatively, the cross-connection cards in each quadrant may be coupled only with cross-connection cards in one other quadrant. For example, cross-connection cards in quadrants  and  may be connected and cross-connection cards in quadrants  and  may be connected. Similarly, the cross-connection cards in each quadrant may be coupled with cross-connection cards in only two other quadrants, or only the cross-connection cards in one quadrant (e.g., quadrant ) may be connected to cross-connection cards in another quadrant (e.g., quadrant ) while the cross-connection cards in the other quadrants (e.g., quadrants  and ) are not connected to other cross-connection cards or are connected only to cross-connection cards in one quadrant (e.g., quadrant ). Many variations are possible. Although these connections do not provide the flexibility of having all cross-connection cards inter-connected, these connections require less routing resources and still provide some increase in the data transmission flexibility of the network device.","The additional flexibility provided by inter-connecting one or more cross-connection cards may be used to optimize the efficiency of network device . For instance, a redundant forwarding card in one quadrant may be used as a backup for primary forwarding cards in other quadrants thereby reducing the number of backup modules and increasing the network device's service density. Similarly, a redundant universal port card or a redundant port on a universal port card in one quadrant may be used as a backup for primary universal port cards or ports in other quadrants. As previously mentioned, each primary forwarding card may support a different protocol (e.g., ATM, MPLS, IP, Frame Relay). Similarly, each universal port card may support a different protocol (e.g., SONET, Ethernet). A backup or spare forwarding card or universal port card must support the same protocol as the primary card or cards. If forwarding or universal port cards in one quadrant support multiple protocols and the cross-connection cards are not interconnected, then each quadrant may need multiple backup forwarding and universal port cards (i.e., one for each protocol supported). If each of the quadrants includes forwarding and universal port cards that support different protocols then each quadrant may include multiple backup forwarding and universal port cards further decreasing the network device's service density.","By inter-connecting the cross-connection cards, a forwarding card in one quadrant may serve as a backup for primary forwarding cards in its own quadrant and in other quadrants. Similarly, a universal port card or port in one quadrant may serve as a backup for a primary universal port card or port in its own quadrant and in other quadrants. For example, forwarding card in quadrant  that supports a particular protocol (e.g., the ATM protocol) may serve as the backup forwarding card for primary forwarding cards supporting ATM in its own quadrant (e.g., forwarding cards \u2013) as well as for primary forwarding cards supporting ATM in quadrant  (e.g., forwarding cards \u2013) or all quadrants (e.g., forwarding card in quadrant  and forwarding cards \u2013in quadrant ). Similarly, forwarding card in quadrant  that supports a different protocol (e.g., the MPLS protocol) may serve as the backup forwarding card for primary forwarding cards supporting MPLS in its own quadrant (e.g., forwarding cards and ) as well as for primary forwarding cards supporting MPLS in quadrant  (e.g., forwarding card ) or all quadrants (e.g., forwarding card in quadrant  and forwarding card in quadrant ). Even with this flexibility, to provide sufficient redundancy, multiple backup modules supporting the same protocol may be used, especially where a large number of primary modules support one protocol.","As previously discussed, each port on a universal port card may be connected to an external network connection, for example, an optical fiber transmitting data according to the SONET protocol. Each external network connection may provide multiple streams or paths and each stream or path may include data being transmitted according to a different protocol over SONET. For example, one path may include data being transmitted according to ATM over SONET while another path may include data being transmitted according to MPLS over SONET. The cross-connection cards may be programmed (as described below) to transmit protocol specific data (e.g., ATM, MPLS, IP, Frame Relay) from ports on universal port cards within their quadrants to forwarding cards within any quadrant that support the specific protocol. Because the traffic management chips on the forwarding cards provide protocol-independent addresses to be used by switch fabric cards \u2013, the switch fabric cards may transmit data between any of the forwarding cards regardless of the underlying protocol.","Alternatively, the network manager may dedicate each quadrant to a specific protocol by putting forwarding cards in each quadrant according to the protocol they support. Within each quadrant then, one forwarding card may be a backup card for each of the other forwarding cards (1:N, for network device , 1:4). Protocol specific data received from ports or paths on ports on universal port cards within any quadrant may then be forwarded by one or more cross-connection cards to forwarding cards within the protocol specific quadrant. For instance, quadrant  may include forwarding cards for processing data transmissions using the ATM protocol, quadrant  may include forwarding cards for processing data transmissions using the IP protocol, quadrant  may include forwarding cards for processing data transmissions using the MPLS protocol and quadrant  may be used for processing data transmissions using the Frame Relay protocol. ATM data received on a port path is then transmitted by one or more cross-connection cards to a forwarding card in quadrant , while MPLS data received on another path on that same port or on a path in another port is transmitted by one or more cross-connection cards to a forwarding card in quadrant .","Policy Based Provisioning:","Unlike the switch fabric card, the cross-connection card does not examine header information in a payload to determine where to send the data. Instead, the cross-connection card is programmed to transmit payloads, for example, SONET frames, between a particular serial line on a universal port card port and a particular serial line on a forwarding card port regardless of the information in the payload. As a result, one port card serial line and one forwarding card serial line will transmit data to each other through the cross-connection card until that programmed connection is changed.","In one embodiment, connections established through a path table and service endpoint table (SET) in a configuration database are passed to path managers on port cards and service endpoint managers (SEMs) on forwarding cards, respectively. The path managers and service endpoint managers then communicate with a cross-connect manager (CCM) on the cross-connection card in their quadrant to provide connection information. The CCM uses the connection information to generate a connection program table that is used by one or more components (e.g., a TSE chip ) to program internal connection paths through the cross-connection card.","Typically, connections are fixed or are generated according to a predetermined map with a fixed set of rules. Unfortunately, a fixed set of rules may not provide flexibility for future network device changes or the different needs of different users\/customers. Instead, within network device , each time a user wishes to enable\/configure a path on a port on a universal port card, a Policy Provisioning Manager (PPM)  () executing on central processor  selects the forwarding card port to which the port card port will be connected based on a configurable provisioning policy (PP)  in configuration database . The configurable provisioning policy may take into consideration many factors such as available system resources, balancing those resources and quality of service. Similar to other programs and files stored within the configuration database of computer system  described above, the provisioning policy may be modified while network device  is running to allow to policy to be changed according to a user's changing needs or changing network device system requirements.","When a user connects an external network connection to a particular port on a universal port card, the user notifies the NMS as to which port on which universal port card should be enabled, which path or paths should be enabled, and the number of time slots in each path. The user may also notify the NMS as to a new path and its number of time slots on an already enabled port that was not fully utilized or the user may notify the NMS of a modification to one or more paths on already enabled ports and the number of time slots required for that path or paths. With this information, the NMS fills in a Path table  () and partially fills in a Service Endpoint Table (SET) \u2032 ().","When a record in the path table is filled in, the configuration database sends an active query notification to a path manager (e.g., path manager ) executing on a universal port card (e.g., port card ) corresponding to the universal port card port LID (e.g., port , ) in the path table record (e.g., record ).","Leaving some fields in the SET blank or assigning a particular value (e.g., zero), causes the configuration database to send an active query notification to Policy Provisioning Manager (PPM) . The PPM then determines\u2014using provisioning policy \u2014which forwarding card (FC) port or ports to assign to the new path or paths. For example, the PPM may first compare the new path's requirements, including its protocol (e.g., ATM over SONET), the number of time slots, the number of virtual circuits and virtual circuit scheduling restrictions, to the available forwarding card resources in the quadrant containing the universal port card port and path. The PPM also takes other factors into consideration including quality of service, for example, redundancy requirements or dedicated resource requirements, and balancing resource usage (i.e., load balancing) evenly within a quadrant.","As an example, a user connects SONET optical fiber () to port on universal port card and wants to enable a path with three time slots (i.e., STS-3c). The NMS assigns a path LID number (e.g., path LID ) and fills in a record (e.g., row ) in Path Table  to include path LID , a universal port card port LID (e.g., UP port LID ) previously assigned by the NMS and retrieved from the Logical to Physical Port Table, the first time slot (e.g., time slot ) in the SONET stream corresponding with the path and the total number of time slots\u2014in this example, 3\u2014in the path. Other information may also be filled into Path Table .","The NMS also partially fills in a record (e.g., row ) in SET \u2032 by filling in the quadrant number\u2014in this example, 1\u2014and the assigned path LID  and by assigning a service endpoint number . The SET table also includes other fields, for example, a forwarding card LID field , a forwarding card slice  (i.e., port) and a forwarding card serial line . In one embodiment, the NMS fills in these fields with a particular value (e.g., zero), and in another embodiment, the NMS leaves these fields blank.","In either case, the particular value or a blank field causes the configuration database to send an active query notice to the PPM indicating a new path LID, quadrant number and service endpoint number. It is up to the PPM to decide which forwarding card, slice (i.e., payload extractor chip) and time slot (i.e., port) to assign to the new universal port card path. Once decided, the PPM fills in the SET Table fields. Since the user and NMS do not completely fill in the SET record, this may be referred to as a \u201cself-completing configuration record.\u201d Self-completing configuration records reduce the administrative workload of provisioning a network.","The SET and path table records may be automatically copied to persistent storage  to insure that if network device  is re-booted these configuration records are maintained. If the network device shuts down prior to the PPM filling in the SET record fields and having those fields saved in persistent storage, when the network device is rebooted, the SET will still include blank fields or fields with particular values which will cause the configuration database to again send an active query to the PPM.","When the forwarding card LID (e.g., ) corresponding, for example, to forwarding card , is filled into the SET table, the configuration database sends an active query notification to an SEM (e.g., SEM ) executing on that forwarding card and corresponding to the assigned slice and\/or time slots. The active query notifies the SEM of the newly assigned service endpoint number (e.g., SE ) and the forwarding card slice (e.g., payload extractor ) and time slots (i.e., 3 time slots from one of the serial line inputs to payload extractor ) dedicated to the new path.","Path manager  and SEM both send connection information to a cross-connection manager  executing on cross-connection card \u2014the cross-connection card within their quadrant. The CCM uses the connection information to generate a connection program table  and uses this table to program internal connections through one or more components (e.g., a TSE chip ) on the cross-connection card. Once programmed, cross-connection card transmits data between new path LID  on SONET fiber connected to port on universal port card and the serial line input to payload extractor on forwarding card ","An active query notification is also sent to NMS database , and the NMS then displays the new system configuration to the user.","Alternatively, the user may choose which forwarding card to assign to the new path and notify the NMS. The NMS would then fill in the forwarding card LID in the SET, and the PPM would only determine which time slots and slice within the forwarding card to assign.","In the description above, when the PPM is notified of a new path, it compares the requirements of the new path to the available\/unused forwarding card resources. If the necessary resources are not available, the PPM may signal an error. Alternatively, the PPM could move existing forwarding card resources to make the necessary forwarding card resources available for the new path. For example, if no payload extractor chip is completely available in the entire quadrant, one path requiring only one time slot is assigned to payload extractor chip and a new path requires forty-eight time slots, the one path assigned to payload extractor chip may be moved to another payload extractor chip, for example, payload extractor chip that has at least one time slot available and the new path may be assigned all of the time slots on payload extractor chip . Moving the existing path is accomplished by having the PPM modify an existing SET record. The new path is configured as described above.","Moving existing paths may result in some service disruption. To avoid this, the provisioning policy may include certain guidelines to hypothesize about future growth. For example, the policy may require small paths\u2014for example, three or less time slots\u2014to be assigned to payload extractor chips that already have some paths assigned instead of to completely unassigned payload extractor chips to provide a higher likelihood that forwarding card resources will be available for large paths\u2014for example, sixteen or more time slots\u2014added in the future.","Multi-Layer Network Device in One Telco Rack:","Referring again to , in one embodiment, each universal port card includes four ports, each of which is capable of being connected to an OC-48 SONET fiber. Since an OC-48 SONET fiber is capable of transferring data at 2.5 Giga bits per second (Gbps), each universal port card is capable of transferring data at 10 Gbps (4\u00d72.5=10). With eight port cards per quadrant, the cross-connection card must be capable of transferring data at 80 Gbps. Typically, however, the eight port cards will be 1:1 redundant and only transfer 40 Gbps. In one embodiment, each forwarding card is capable of transferring 10 Gbps, and with five forwarding cards per quadrant, the switch fabric cards must be capable of transferring data at 200 Gbps. Typically, however, the five forwarding cards will be 1:N redundant and only transfer data at 40 Gbps. With four quadrants and full redundancy (1:1 for port cards and 1:N for forwarding cards), network device  is capable of transferring data at 160 Gbps.","In other embodiments, each port card includes one port capable of being connected to an OC-192 SONET fiber. Since OC-192 SONET fibers are capable of transferring data at 10 Gbps, a fully redundant network device  is again capable of transferring 160 Gbps. In the embodiment employing one OC-192 connection per port card, each port card may include one hundred and ninety-two logical DS3 connections using sub-rate data multiplexing (SDRM). In addition, each port card may differ in its number and type of ports to provide more or less data through put. As previously mentioned, ports other than SONET ports may be provided, for example, Ethernet ports, Plesiochronous Digital Hierarchy ports (i.e., DS0, DS1, DS3, E0, E1, E3, J0, J1, J3) and Synchronous Digital Hierarchy (SDH) ports (i.e., STM1, STM4, STM16, STM64).","The universal port cards and cross-connect cards in each quadrant are in effect a physical layer switch, and the forwarding cards and switch fabric cards are effectively an upper layer switch. Prior systems have packaged these two switches into separate network devices. One reason for this is the large number of signals that need to be routed. Taken separately, each cross-connect card \u2013, \u2013, \u2013and \u2013is essentially a switch fabric or mesh allowing switching between any path on any universal port card to any serial input line on any forwarding card in its quadrant and each switch fabric card \u2013allows switching between any paths on any forwarding cards. Approximately six thousand, seven hundred and twenty etches are required to support a 200 Gbps switch fabric, and about eight hundred and thirty-two etches are required to support an 80 Gbps cross-connect. Combining such high capacity multi-layer switches into one network device in a single telco rack (seven feet by nineteen inches by 24 inches) has not been thought possible by those skilled in the art of telecommunications network devices.","To fit network device  into a single telco rack, dual mid-planes are used. All of the functional printed circuit boards connect to at least one of the mid-planes, and the switch fabric cards and certain control cards connect to both mid-planes thereby providing connections between the two mid-planes. In addition, to efficiently utilize routing resources, instead of providing a single cross-connection card, the cross-connection functionality is separated into four cross-connection cards\u2014one for each quadrant\u2014(as shown in ). Further, routing through the lower mid-plane is improved by flipping the forwarding cards and cross-connection cards in the bottom half of the front of the chassis upside down to be the mirror image of the forwarding cards and cross-connection cards in the top of the front half of the chassis.","Referring to , a network device  is packaged in a box  conforming to the telco standard rack of seven feet in height, nineteen inches in width and 24 inches in depth. Referring also to \u2013, a chassis  within box  provides support for forwarding cards \u2013, \u2013, \u2013and \u2013, universal port cards \u2013, \u2013, \u2013and \u2013, and cross-connection cards \u2013, \u2013, \u2013and \u2013. As is typical of telco network devices, the forwarding cards (FC) are located in the front portion of the chassis where network administrators may easily add and remove these cards from the box, and the universal port cards (UP) are located in the back portion of the chassis where external network attachments\/cables may be easily connected.","The chassis also supports switch fabric cards and . As shown, each switch fabric card may include multiple switch fabric (SF) cards and a switch scheduler (SS) card. In addition, the chassis supports multiple central processor cards ( and , ). Instead of having a single central processor card, the external control functions and the internal control functions may be separated onto different cards as described in U.S. patent application Ser. No. 09\/574,343, filed May 20, 2000 and entitled \u201cFunctional Separation of Internal and External Controls in Network Devices\u201d, which is hereby incorporated herein by reference. As shown, the chassis may support internal control (IC) processor cards and and external control (EC) processor cards and . Auxiliary processor (AP) cards and are provided for future expansion to allow more external control cards to be added, for example, to handle new upper layer protocols. In addition, a management interface (MI) card  for connecting to an external network management system (, ) is also provided.","The chassis also support two mid-plane printed circuit boards and () located toward the middle of chassis . Mid-plane is located in the top portion of chassis  and is connected to quadrant  and  forwarding cards \u2013and \u2013, universal port cards \u2013and \u2013, and cross-connection cards \u2013and \u2013. Similarly, mid-plane is located in the bottom portion of chassis  and is connected to quadrant  and  forwarding cards \u2013and \u2013, universal port cards \u2013and \u2013, and cross-connection cards \u2013and \u2013. Through each mid-plane, the cross-connection card in each quadrant may transfer network packets between any of the universal port cards in its quadrant and any of the forwarding cards in its quadrant. In addition, through mid-plane the cross-connection cards in quadrants  and  may be connected to allow for transfer of network packets between any forwarding cards and port cards in quadrants  and , and through mid-plane the cross-connection cards in quadrants  and  may be connected to allow for transfer of network packets between any forwarding cards and port cards in quadrants  and .","Mid-plane is also connected to external control processor cards and and management interface card . Mid-plane is also connected to auxiliary processor cards and ","Switch fabric cards and are located in the back portion of chassis , approximately mid-way between the top and bottom of the chassis. The switch fabric cards are connected to both mid-planes and to allow the switch fabric cards to transfer signals between any of the forwarding cards in any quadrant. In addition, the cross-connection cards in quadrants  and  may be connected through the mid-planes and switch fabric cards to the cross-connection cards in quadrants  and  to enable network packets to be transferred between any universal port card and any forwarding card.","To provide for better routing efficiency through mid-plane , forwarding cards \u2013and \u2013and cross-connection cards \u2013and \u2013in quadrants  and , located in the bottom portion of the chassis, are flipped over when plugged into mid-plane . This permits the switch fabric interface \u2013on each of the lower forwarding cards to be oriented nearest the switch fabric cards and the cross-connection interface \u2013on each of the lower forwarding cards to be oriented nearest the cross-connection cards in quadrants  and . This orientation avoids having to cross switch fabric and cross-connection etches in mid-plane ","Typically, airflow for cooling a network device is brought in at the bottom of the device and released at the top of the device. For example, in the back portion of chassis , a fan tray (FT)  pulls air into the device from the bottom portion of the device and a fan tray  blows air out of the top portion of the device. When the lower forwarding cards are flipped over, the airflow\/cooling pattern is reversed. To accommodate this reversal, fan trays  and  pull air into the middle portion of the device and then fan trays  and  pull the air upwards and downwards, respectively, and blow the heated air out the top and bottom of the device, respectively.","The quadrant  and  universal port cards \u2013and \u2013may also be flipped over to orient the port card's cross-connection interface nearest the cross-connection cards and more efficiently use the routing resources. It is preferred, however, not to flip the universal port cards for serviceability reasons and airflow issues. The network managers at the telco site expect network attachments\/cables to be in a certain pattern. Reversing this pattern could cause confusion in a large telco site with many different types of network devices. Also, flipping the port cards will change the airflow and cooling pattern and require a similar airflow pattern and fan tray configuration as implemented in the front of the chassis. However, with the switch fabric and internal control processor cards in the middle of the back portion of the chassis, it may be impossible to implement this fan tray configuration.","Referring to , mid-plane includes connectors  mounted on the back side of the mid-plane (\u201cback mounted\u201d) for the management interface card, connectors \u2013mounted on the front side of the mid-plane (\u201cfront mounted\u201d) for the quadrant  and  cross-connection cards, and front mounted connectors \u2013for the external control processor cards. Multiple connectors may be used for each card. Mid-plane also includes back mounted connectors \u2013for the quadrant  and  universal port cards and front mounted connectors \u2013for the quadrant  and  forwarding cards.","Both mid-planes and include back mounted connectors \u2013for the switch fabric cards and back mounted connectors \u2013for the internal control cards. Mid-plane further includes front, reverse mounted connectors \u2013for the quadrant  and  forwarding cards and back mounted connectors \u2013for the quadrant  and  universal port cards. In addition, mid-plane also includes front, reverse mounted connectors \u2013for the quadrant  and  cross-connection cards and front mounted connectors \u2013for the auxiliary processor cards.","Combining both physical layer switch\/router subsystems and upper layer switch\/router subsystems in one network device allows for intelligent layer  switching. For example, the network device may be used to establish dynamic network connections on the layer  network to better utilize resources as service subscriptions change. In addition, network management is greatly simplified since the layer  and multiple upper layer networks may be managed by the same network management system and grooming fees are eliminated. Combining the physical layer switch\/router and upper layer switch\/routers into a network device that fits into one telco rack provides a less expensive network device and saves valuable telco site space.","Splitting the cross-connection function into four separate cards\/quadrants enables the cross-connection routing requirements to be spread between the two mid-planes and alleviates the need to route cross-connection signals through the center of the device where the switch fabric is routed. In addition, segmenting the cross-connection function into multiple, independent subsystems allows customers\/network managers to add functionality to network device  in pieces and in accordance with network service subscriptions. When a network device is first installed, a network manager may need only a few port cards and forwarding cards to service network customers. The modularity of network device  allows the network manager to purchase and install only one cross-connection card and the required number of port and forwarding cards. As the network becomes more subscribed, the network manager may add forwarding cards and port cards and eventually additional cross-connection cards. Since network devices are often very expensive, this modularity allows network managers to spread the cost of the system out in accordance with new service requests. The fees paid by customers to the network manager for the new services can then be applied to the cost of the new cards.","Although the embodiment describes the use of two mid-planes, it should be understood that more than two mid-planes may be used. Similarly, although the embodiment described flipped\/reversed the forwarding cards and cross-connection cards in the lower half of the chassis, alternatively, the forwarding cards and cross-connection cards in the upper half of the chassis could be flipped.","Distributed Switch Fabric:","A network device having a distributed switch fabric locates a portion of the switch fabric functionality on cards separate from the remaining\/central switch fabric functionality. For example, a portion of the switch fabric may be distributed on each forwarding card. There are a number of difficulties associated with distributing a portion of the switch fabric. For instance, distributing the switch fabric makes mid-plane\/back-plane routing more difficult which further increases the difficulty of fitting the network device into one telco rack, switch fabric redundancy and timing are also made more difficult, valuable forwarding card space must be allocated for switch fabric components and the cost of each forwarding card is increased. However, since the entire switch fabric need not be included in a minimally configured network device, the cost of the minimal configuration is reduced allowing network service providers to more quickly recover the initial cost of the device. As new services are requested, additional functionality, including both forwarding cards (with additional switch fabric functionality) and universal port cards may be added to the network device to handle the new requests, and the fees for the new services may be applied to the cost of the additional functionality. Consequently, the cost of the network device more closely tracks the service fees received by network providers.","Referring again to , as described above, each forwarding card (e.g., ) includes traffic management chips (e.g., \u2013and \u2013) that ensure high priority network data\/traffic (e.g., voice) is transferred faster than lower priority traffic (e.g., e-mail). Each forwarding card also includes switch fabric interface (SFIF) chips (e.g., \u2013) that transfer network data between the traffic management chips and the switch fabric cards \u2013","Referring also to , forwarding card includes traffic management (TM) chips and and SFIF chips , and forwarding card includes traffic management chips and and SFIF chips . ( includes only two forwarding cards for convenience but it is to be understood that many forwarding cards may be included in a network device as shown in .) SFIF chips  and  on both boards include a switch fabric interface (SIF) chip , data slice chips \u2013, an enhanced port processor (EPP) chip  and a local timing subsystem (LTS) . The SFIF chips receive data from ingress TM chips and and forward it to the switch fabric cards \u2013(). Similarly, the SFIF chips receive data from the switch fabric cards and forward it to the egress TM chips and ","Due to the size and complexity of the switch fabric, each switch fabric card \u2013may include multiple separate cards. In one embodiment, each switch fabric card \u2013includes a control card  and four data cards \u2013. A scheduler chip  on control card  works with the EPP chips on each of the forwarding cards to transfer network data between the data slice chips on the forwarding cards through cross-bar chips \u2013(only chips \u2013are shown) on data cards \u2013. Each of the data slice chips on each of the forwarding cards is connected to two of the cross-bar chips on the data cards. Switch fabric control card  and each of the switch fabric data cards \u2013also include a switch fabric local timing subsystem (LTS) , and a switch fabric central timing subsystem (CTS)  on control card  provides a start of segment (SOS) reference signal to each LTS  on each of the forwarding cards and switch fabric cards.","The traffic management chips perform upper level network traffic management within the network device while scheduler chip  on control card  performs the lower level data transfer between forwarding cards. The traffic management chips determine the priority of received network data and then forward the highest priority data to SIF chips . The traffic management chips include large buffers to store lower priority data until higher priority data has been transferred. The traffic management chips also store data in these buffers when the local EPP chip indicates that data transfers are to be stopped (i.e., back pressure). The scheduler chip works with the EPP chips to stop or hold-off data transfers when necessary, for example, when buffers on one forwarding card are close to full, the local EPP chip sends notice to each of the other EPP chips and the scheduler to hold off sending more data. Back pressure may be applied to all forwarding cards when a new switch fabric control card is added to the network device, as described below.","The traffic management chips forward network data in predefined segments to the SIF chips. In the case of ATM data, each ATM cell is a segment. In the case of IP and MPLS, where the amount of network data in each packet may vary, the data is first arranged into appropriately sized segments before being sent to the SIF chips. This may be accomplished through segmentation and reassembly (SAR) chips (not shown).","When the SIF chip receives a segment of network data, it organizes the data into a segment consistent with that expected by the switch fabric components, including any required header information. The SIF chip may be a PMC9324-TC chip available from Extreme Packet Devices (EPD), a subsidiary of PMC-Sierra, and the data slice chips may be PM9313-HC chips and the EPP chip may be a PM9315-HC chip available from Abrizio, also a subsidiary of PMC-Sierra. In this case, the SIF chip organizes each segment of data\u2014including header information\u2014in accordance with a line-card-to-switch two (LCS-2) protocol. The SIF chip then divides each data segment into twelve slices and sends two slices to each data slice chip \u2013. Two slices are sent because each data slice chip includes the functionality of two data slices.","When the data slice chips receive the LCS segments, the data slice chips strip off the header information, including both a destination address and quality of service (QoS) information, and send the header information to the local EPP chip. Alternatively, the SIF chip may send the header information directly to the EPP chip and send only data to the data slice chips. However, the manufacturer teaches that the SIF chip should be on the forwarding card and the EPP and data slice chips should be on a separate switch fabric card within the network device or in a separate box connected to the network device. Minimizing connections between cards is important, and where the EPP and data slice chips are not on the same card as the SIF chips, the header information is sent with the data by the SIF chip to reduce the required inter-card connections, and the data slice chips then strip off this information and send it to the EPP chip.","The EPP chips on all of the forwarding cards communicate and synchronize through cross-bar chips \u2013on control card . For each time interval (e.g., every 40 nanoseconds, \u201cns\u201d), the EPP chips inform the scheduler chip as to which data segment they would like to send and the data slice chips send a segment of data previously set up by the scheduler and EPP chips. The EPP chips and the scheduler use the destination addresses to determine if there are any conflicts, for example, to determine if two or more forwarding cards are trying to send data to the same forwarding card. If a conflict is found, then the quality of service information is used to determine which forwarding card is trying to send the higher priority data. The highest priority data will likely be sent first. However, the scheduler chips include an algorithm that takes into account both the quality of service and a need to keep the switch fabric data cards \u2013full (maximum data through put). Where a conflict exists, the scheduler chip may inform the EPP chip to send a different, for example, lower priority, data segment from the data slice chip buffers or to send an empty data segment during the time interval.","Scheduler chip  informs each of the EPP chips which data segment is to be sent and received in each time interval. The EPP chips then inform their local data slice chips as to which data segments are to be sent in each interval and which data segments will be received in each interval. As previously mentioned, the forwarding cards each send and receive data. The data slice chips include small buffers to hold certain data (e.g., lower priority) while other data (e.g., higher priority) data is sent and small buffers to store received data. The data slice chips also include header information with each segment of data sent to the switch fabric cards. The header information is used by cross-bar chips \u2013(only cross-bar chips \u2013are shown) to switch the data to the correct forwarding card. The cross-bar chips may be PM9312-UC chips and the scheduler chip may be a PM9311-UC chip both of which are available from Abrizio.","Specifications for the EPD, Abrizio and PMC-Sierra chips may be found at www.pmc-sierra.com and are hereby incorporated herein by reference.","Distributed Switch Fabric Timing:","As previously mentioned, a segment of data (e.g., an ATM cell) is transferred between the data slice chips through the cross-bar chips every predetermined time interval. In one embodiment, this time interval is 40 ns and is established by a 25 MHz start of segment (SOS) signal. A higher frequency clock (e.g., 200 MHz, having a 5 ns time interval) is used by the data slice and cross-bar chips to transfer the bits of data within each segment such that all the bits of data in a segment are transferred within one 40 ns interval. More specifically, in one embodiment, each switch fabric component multiplies the 200 MHz clock signal by four to provide an 800 MHz internal clock signal allowing data to be transferred through the data slice and cross-bar components at 320 Gbps. As a result, every 40 ns one segment of data (e.g., an ATM cell) is transferred. It is crucial that the EPP, scheduler, data slice and cross-bar chips transfer data according to the same\/synchronized timing signals (e.g., clock and SOS), including both frequency and phase. Transferring data at different times, even slightly different times, may lead to data corruption, the wrong data being sent and\/or a network device crash.","When distributed signals (e.g., reference SOS or clock signals) are used to synchronize actions across multiple components (e.g., the transmission of data through a switch fabric), any time-difference in events (e.g., clock pulse) on the distributed signals is generally termed \u201cskew\u201d. Skew between distributed signals may result in the actions not occurring at the same time, and in the case of transmission of data through a switch fabric, skew can cause data corruption and other errors. Many variables can introduce skew into these signals. For example, components used to distribute the clock signal introduce skew, and etches on the mid-plane(s) introduce skew in proportion to the differences in their length (e.g., about 180 picoseconds per inch of etch in FR 4 printed circuit board material).","To minimize skew, one manufacturer teaches that all switch fabric components (i.e., scheduler, EPP, data slice and cross-bar chips) should be located on centralized switch fabric cards. That manufacturer also suggests distributing a central clock reference signal (e.g., 200 MHz) and a separate SOS signal (e.g., 25 MHz) to the switch fabric components on the switch fabric cards. Such a timing distribution scheme is difficult but possible where all the components are on one switch fabric card or on a limited number of switch fabric cards that are located near each other within the network device or in a separate box connected to the network device. Locating the boards near each other within the network device or in a separate box allows etch lengths on the mid-plane for the reference timing signals to be more easily matched and, thus, introduce less skew.","When the switch fabric components are distributed, maintaining a very tight skew becomes difficult due to the long lengths of etches required to reach some of the distributed cards and the routing difficulties that arise in trying to match the lengths of all the etches across the mid-plane(s). Because the clock signal needs to be distributed not only to the five switch fabric cards but also the forwarding cards (e.g., twenty), it becomes a significant routing problem to distribute all clocks to all loads with a fixed etch length.","Since timing is so critical to network device operation, typical network devices include redundant central timing subsystems. Certainly, the additional reference timing signals from a redundant central timing subsystem to each of the forwarding cards and switch fabric cards create further routing difficulties. In addition, if the two central timing subsystems (i.e., sources) are not synchronous with matched distribution etches, then all of the loads (i.e., LTSs) must use the same reference clock source to avoid introducing clock skew\u2014that is, unless both sources are synchronous and have matched distribution networks, the reference timing signals from both sources are likely to be skewed with respect to each other and, thus, all loads must use the same source\/reference timing signal or be skewed with respect to each other.","A redundant, distributed switch fabric greatly increases the number of reference timing signals that must be routed over the mid-planes and yet remain accurately synchronized. In addition, since the timing signals must be sent to each card having a distributed switch fabric, the distance between the cards may vary greatly and, thus, make matching the lengths of timing signal etches on the mid-planes difficult. Further, the lengths of the etches for the reference timing signals from both the primary and redundant central timing subsystems must be matched. Compounding this with a fast clock signal and low skew component requirements makes distributing the timing very difficult.","The network device of the present invention, though difficult, includes two synchronized central timing subsystems (CTS)  (one is shown in ). The etch lengths of reference timing signals from both central timing subsystems are matched to within, for example, +\/\u221250 mils, and both central timing subsystems distribute only reference start of segment (SOS) signals to a local timing subsystem (LTS)  on each forwarding card and switch fabric card. The LTSs use the SOS reference signals to generate both an SOS signal and a higher frequency clock signal. This adds components and complexity to the LTSs, however, distributing only the SOS reference signals and not both the SOS and clock reference signals significantly reduces the number of reference timing signals that must be routed across the mid-plane on matched etch lengths.","Both electromagnetic radiation and electro-physical limitations prevent the 200 MHz reference clock signal from being widely distributed as required in a network device implementing distributed switch fabric subsystems. Such a fast reference clock increases the overall noise level generated by the network device and wide distribution may cause the network device to exceed Electro-Magnetic Interference (EMI) limitations. Clock errors are often measured as a percentage of the clock period, the smaller the clock period (5 ns for a 200 MHz clock), the larger the percentage of error a small skew can cause. For example, a skew of 3 ns represents a 60% error for a 5 ns clock period but only a 7.5% error for a 40 ns clock period. Higher frequency clock signals (e.g., 200 MHz) are susceptible to noise error and clock skew. The SOS signal has a larger clock period than the reference clock signal (40 ns versus 5 ns) and, thus, is less susceptible to noise error and reduces the percentage of error resulting from clock skew.","As previously mentioned, the network device may include redundant switch fabric cards and () and as described above with reference to , each switch fabric card and may include a control card and four or more data cards.","Referring to , network device  may include switch fabric control card  (part of central switch fabric ) and redundant switch fabric control card  (part of redundant switch fabric ). Each control card  and  includes a central timing subsystem (CTS) . One CTS behaves as the master and the other CTS behaves as a slave and locks its output SOS signal to the master's output SOS signal. In one embodiment, upon power-up or system re-boot the CTS on the primary switch fabric control card  begins as the master and if a problem occurs with the CTS on the primary control card, then the CTS on redundant control card  takes over as master without requiring a switch over of the primary switch fabric control card.","Still referring to , each CTS sends a reference SOS signal to the LTSs on each forwarding card, switch fabric data cards \u2013and redundant switch fabric data cards \u2013. In addition, each CTS sends a reference SOS signal to the LTS on its own switch fabric control card and the LTS on the other switch fabric control card. As described in more detail below, each LTS then selects which reference SOS signal to use. Each CTS  also sends a reference SOS signal to the CTS on the other control card. The master CTS ignores the reference SOS signal from the slave CTS but the slave CTS locks its reference SOS signal to the reference SOS signal from the master, as described below. Locking the slave SOS signal to the master SOS signal synchronizes the slave signal to the master signal such that in the event that the master CTS fails and the LTSs switchover to the slave CTS reference SOS signal and the slave CTS becomes the master CTS, minimal phase change and no signal disruption is encountered between the master and slave reference SOS signals received by the LTSs.","Each of the CTS reference SOS signals sent to the LTSs and the other CTS over mid-plane etches are the same length (i.e., matched) to avoid introducing skew. The CTS may be on its own independent card or any other card in the system. Even when it is located on a switch fabric card, such as the control card, that has an LTS, the reference SOS signal is routed through the mid-plane with the same length etch as the other reference SOS signals to avoid adding skew.","Central Timing Subsystem (CTS):","Referring to , central timing subsystem (CTS)  includes a voltage controlled crystal oscillator (VCXO)  that generates a 25 MHz reference SOS signal . The SOS signal must be distributed to each of the local timing subsystems (LTSs) and is, thus, sent to a first level clock driver  and then to second level clock drivers \u2013that output reference SOS signals SFC_BENCH_FB and SFC_REF\u2013SFC_REFn.","SFC_BENCH_FB is a local feedback signal returned to the input of the CTS. One of SFC_REF\u2013SFC_REFn is sent to each LTS, the other CTS, which receives it on SFC_SYNC, and one is routed over a mid-plane and returned as a feedback signal SFC_FB to the input of the CTS that generated it. Additional levels of clock drivers may be added as the number of necessary reference SOS signals increases.","VCXO  may be a VF596ES50 25 MHz LVPECL available from Conner-Winfield. Positive Emitter Coupled Logic (PECL) is preferred over Transistor\u2014Transistor Logic (TTL) for its lower skew properties. In addition, though it requires two etches to transfer a single clock reference\u2014significantly increasing routing resources\u2014, differential PECL is preferred over PECL for its lower skew properties and high noise immunity. The clock drivers are also differential PECL and may be one to ten (1:10) MC100 LVEP111 clock drivers available from On Semiconductor. A test header  may be connected to clock driver  to allow a test clock to be input into the system.","Hardware control logic  determines (as described below) whether the CTS is the master or slave, and hardware control logic  is connected to a multiplexor (MUX)  to select between a predetermined voltage input (i.e., master voltage input) and a slave VCXO voltage input . When the CTS is the master, hardware control logic  selects predetermined voltage input from discrete bias circuit  and slave VCXO voltage input is ignored. The predetermined voltage input causes VCXO  to generate a constant 25 MHz SOS signal; that is, the VCXO operates as a simple oscillator.","Hardware control logic may be implemented in a field programmable gate array (FPGA) or a programmable logic device (PLD). MUX  may be a 74CBTLV3257 FET 2:1 MUX available from Texas Instruments.","When the CTS is the slave, hardware control logic  selects slave VCXO voltage signal . This provides a variable voltage level to the VCXO that causes the output of the VCXO to track or follow the SOS reference signal from the master CTS. Referring still to , the CTS receives the SOS reference signal from the other CTS on SFC_SYNC. Since this is a differential PECL signal, it is first passed through a differential PECL to TTL translator  before being sent to MUX within dual MUX . In addition, two feedback signals from the CTS itself are supplied as inputs to the CTS. The first feedback signal SFC_FB is an output signal (e.g., one of SFC_REF\u2014SFC_REFn) from the CTS itself which has been sent out to the mid-plane and routed back to the switch fabric control card. This is done so that the feedback signal used by the CTS experiences identical conditions as the reference SOS signal delivered to the LTSs and skew is minimized. The second feedback signal SFC_BENCH_FB is a local signal from the output of the CTS, for example, clock driver . SFC_BENCH_FB may be used as the feedback signal in a test mode, for example, when the control card is not plugged into the network device chassis and SFC_SB is unavailable. SFC_BENCH_FB and SFC_FB are also differential PECL signals and must be sent through translators  and , respectively, prior to being sent to MUX within dual MUX . Hardware control logic  selects which inputs are used by MUX  by asserting signals on REF_SEL(1:0) and FB_SEL(1:0). In regular use, inputs and from translator  are selected. In test modes, grounded inputs , test headers or local feedback signal  from translator  may be selected. Also in regular use (and in test modes where a clock signal is not inserted through the test headers), copies of the selected input signals are provided on the test headers.","The reference output and the feedback output are then sent from the MUX to phase detector circuit . The phase detector compares the rising edge of the two input signals to determine the magnitude of any phase shift between the two. The phase detector then generates variable voltage pulses on outputs and representing the magnitude of the phase shift. The phase detector outputs are used by discrete logic circuit  to generate a voltage on a slave VCXO voltage signal representing the magnitude of the phase shift. The voltage is used to speed up or slow down (i.e., change the phase of) the VCXO's output SOS signal to allow the output SOS signal to track any phase change in the reference SOS signal from the other CTS (i.e., SFC_SYNC). The discrete logic components implement filters that determine how quickly or slowly the VCXO's output will track the change in phase detected on the reference signal. The combination of the dual MUX, phase detector, discrete logic, VCXO, clock drivers and feedback signal forms a phase locked loop (PLL) circuit allowing the slave CTS to synchronize its reference SOS signal to the master CTS reference SOS signal. MUX  and discrete bias circuit  are not found in phase locked loop circuits.","The phase detector circuit may be implemented in a programmable logic device (PLD), for example a MACH4LV-32 available from Lattice\/Vantis Semiconductor. Dual MUX  may be implemented in the same PLD. Preferably, however, dual MUX  is an SN74CBTLV3253 available from Texas Instruments, which has better skew properties than the PLD. The differential PECL to TTL translators may be MC100EPT23 dual differential PECL\/TTL translators available from On Semiconductor.","Since quick, large phase shifts in the reference signal are likely to be the results of failures, the discrete logic implements a filter, and for any detected phase shift, only small incremental changes over time are made to the voltage provided on slave VCXO control signal . As one example, if the reference signal from the master CTS dies, the slave VCXO control signal only changes phase slowly over time meaning that the VCXO will continue to provide a reference SOS signal. If the reference signal from the master CTS is suddenly returned, the slave VCXO control signal again only changes phase slowly over time to cause the VCXO signal to re-synchronize with the reference signal from the master CTS. This is a significant improvement over distributing a clock signal directly to components that use the signal because, in the case of direct clock distribution, if one clock signal dies (e.g., broken wire), then the components connected to that signal stop functioning causing the entire switch fabric to fail.","Slow phase changes on the reference SOS signals from both the master and slave CTSs are also important when LTSs switch over from using the master CTS reference signal to using the slave CTS reference signal. For example, if the reference SOS signal from the master CTS dies or other problems are detected (e.g., a clock driver dies), then the slave CTS switches over to become the master CTS and each of the LTSs begin using the slave CTS' reference SOS signal. For these reasons, it is important that the slave CTS reference SOS signal be synchronized to the master reference signal but not quickly follow large phase shifts in the master reference signal.","It is not necessary for every LTS to use the reference SOS signals from the same CTS. In fact, some LTSs may use reference SOS signals from the master CTS while one or more are using the reference SOS signals from the slave CTS. In general, this is a transitional state prior to or during switch over. For example, one or more LTSs may start using the slave CTS's reference SOS signal prior to the slave CTS switching over to become the master CTS.","It is important for both the CTSs and the LTSs to monitor the activity of the reference SOS signals from both CTSs such that if there is a problem with one, the LTSs can begin using the other SOS signal immediately and\/or the slave CTS can quickly become master. Reference output signal \u2014the translated reference SOS signal sent from the other CTS and received on SFC_SYNC\u2014is sent to an activity detector circuit . The activity detector circuit determines whether the signal is active\u2014that is, whether the signal is \u201cstuck at\u201d logic 1 or logic 0. If the signal is not active (i.e., stuck at logic 1 or 0), the activity detector sends a signal to hardware control logic  indicating that the signal died. The hardware control logic may immediately select input to MUX  to change the CTS from slave to master. The hardware control logic also sends an interrupt to a local processor  and software being executed by the processor detects the interrupt. Hardware control allows the CTS switch over to happen very quickly before a bad clock signal can disrupt the system.","Similarly, an activity detector  monitors the output of the first level clock driver  regardless of whether the CTS is master or slave. Instead, the output of one the second level clock drivers could be monitored, however, a failure of a different second level clock will not be detected. SFC_REF_ACTIVITY is sent from the first level clock driver to differential PECL to TTL translator  and then as FABRIC_REF_ACTIVITY to activity detector . If activity detector  determines that the signal is not active, which may indicate that the clock driver, oscillator or other component(s) within the CTS have failed, then it sends a signal to the hardware control logic. The hardware control logic asserts KILL_CLKTREE to stop the clock drivers from sending any signals and notifies a processor chip  on the switch fabric control card through an interrupt. Software being executed by the processor chip detects the interrupt. The slave CTS activity detector  detects a dead signal from the master CTS either before or after the hardware control logic sends KILL_CLKTREE and asserts error signal to cause the hardware control logic to change the input selection on MUX  from to to become the master CTS. As described below, the LTSs also detect a dead signal from the master CTS either before or after the hardware control logic sends KILL_CLKTREE and switch over to the reference SOS signal from the slave CTS either before or after the slave CTS switches over to become the master.","As previously mentioned, in the past, a separate, common clock selection signal or etch was sent to each card in the network device to indicate whether to use the master or slave clock reference signal. This approach required significant routing resources, was under software control and resulted in every load selecting the same source at any given time. Hence, if a clock signal problem was detected, components had to wait for the software to change the separate clock selection signal before beginning to use the standby clock signal and all components (i.e., loads) were always locked to the same source. This delay can cause data corruption errors, switch fabric failure and a network device crash.","Forcing a constant logic one or zero (i.e., \u201ckilling\u201d) clock signals from a failed source and having hardware in each LTS and CTS detect inactive (i.e., \u201cdead\u201d or stuck at logic one or zero) signals allows the hardware to quickly begin using the standby clock without the need for software intervention. In addition, if only one clock driver (e.g., ) dies in the master CTS, LTSs receiving output signals from that clock driver may immediately begin using signals from the slave CTS clock driver while the other LTSs continue to use the master CTS. Interrupts to the processor from each of the LTSs connected to the failed master CTS clock driver allow software, specifically the SRM, to detect the failure and initiate a switch over of the slave CTS to the master CTS. The software may also override the hardware control and force the LTSs to use the slave or master reference SOS signal.","When the slave CTS switches over to become the master CTS, the remaining switch fabric control card functionality (e.g., scheduler and cross-bar components) continue operating. The SRM (described above) decides\u2014based on a failure policy\u2014whether to switch over from the primary switch fabric control card to the secondary switch fabric control card. There may be instances where the CTS on the secondary switch fabric control card operates as the master CTS for a period of time before the network device switches over from the primary to the secondary switch fabric control card, or instead, there may be instances where the CTS on the secondary switch fabric control card operates as the master CTS for a period of time and then the software directs the hardware control logic on both switch fabric control cards to switch back such that the CTS on the primary switch fabric control card is again master. Many variations are possible since the CTS is independent of the remaining functionality on the switch fabric control card.","Phase detector  also includes an out of lock detector that determines whether the magnitude of change between the reference signal and the feedback signal is larger than a predetermined threshold. When the CTS is the slave, this circuit detects errors that may not be detected by activity detector  such as where the reference SOS signal from the master CTS is failing but is not dead. If the magnitude of the phase change exceeds the predetermined threshold, then the phase detector asserts an OOL signal to the hardware control logic. The hardware control logic may immediately change the input to MUX  to cause the slave CTS to switch over to Master CTS and send an interrupt to the processor, or the hardware control logic may only send the interrupt and wait for software (e.g., the SRM) to determine whether the slave CTS should switch over to master.","Master\/Slave CTS Control:","In order to determine which CTS is the master and which is the slave, hardware control logic  implements a state machine. Each hardware control logic  sends an IM_THE_MASTER signal to the other hardware control logic  which is received as a YOU_THE_MASTER signal. If the IM_THE_MASTER signal\u2014and, hence, the received YOU_THE_MASTER signal\u2014is asserted then the CTS sending the signal is the master (and selects input to MUX , ) and the CTS receiving the signal is the slave (and selects input to MUX ). Each IM_THE_MASTER\/YOU_THE_MASTER etch is pulled down to ground on the mid-planes such that if one of the CTSs is missing, the YOU_THE_MASTER signal received by the other CTS will be a logic 0 causing the receiving CTS to become the master. This situation may arise, for example, if a redundant control card including the CTS is not inserted within the network device. In addition, each of the hardware control logics receive SLOT_ID signals from pull-down\/pull-up resistors on the chassis mid-plane indicating the slot in which the switch fabric control card is inserted.","Referring to , on power-up or after a system or card or CTS re-boot, the hardware control logic state machine begins in INIT\/RESET state  and does not assert IM_THE_MASTER. If the SLOT_ID signals indicate that the control card is inserted in a preferred slot (e.g., slot one), and the received YOU_THE_MASTER is not asserted (i.e., 0), then the state machine transitions to the ONLINE state  and the hardware control logic asserts IM_THE_MASTER indicating its master status to the other CTS and selects input to MUX . While in the ONLINE state , if a failure is detected or the software tells the hardware logic to switch over, the state machine enters the OFFLINE state  and the hardware control logic stops asserting IN_THE_MASTER and asserts KILL_CLKTREE. While in the OFFLINE state , the software may reset or re-boot the control card or just the CTS and force the state machine to enter the STANDBY state  as the slave CTS and the hardware control logic stops asserting KILL_CLKTREE and selects input to MUX .","While in INIT\/RESET state , if the SLOT_ID signals indicate that the control card is inserted in a non-preferred slot, (e.g., slot ), then the state machine will enter STANDBY state  as the slave CTS and the hardware control logic will not assert IM_THE_MASTER and will select input to MUX . While in INIT\/RESET state , even if the SLOT_ID signals indicate that the control card is inserted in the preferred slot, if YOU_THE_MASTER is asserted, indicating that the other CTS is master, then the state machine transfers to STANDBY state . This situation may arise after a failure and recovery of the CTS in the preferred slot (e.g., reboot, reset or new control card).","While in the STANDBY state , if the YOU_THE_MASTER signal becomes zero (i.e., not asserted), indicating that the master CTS is no longer master, the state machine will transition to ONLINE state  and the hardware control logic will assert IM_THE_MASTER and select input to MUX  to become master. While in ONLINE state , if the YOU_THE_MASTER signal is asserted and SLOT_ID indicating slot  the state machine enters STANDBY state  and the hardware control logic stops asserting IM_THE_MASTER and selects input to MUX . This is the situation where the original master CTS is back up and running. The software may reset the state machine at any time or set the state machine to a particular state at any time.","Local Timing Subsystem:","Referring to , each local timing subsystem (LTS)  receives a reference SOS signal from each CTS on SFC_REFA and SFC_REFB. Since these are differential PECL signals, each is passed through a differential PECL to TTL translator or , respectively. A feedback signal SFC_FB is also passed from the LTS output to both translators and . The reference signal outputs and are fed into a first MUX  within dual MUX , and the feedback signal outputs and are fed into a second MUX  within dual MUX . LTS hardware control logic  controls selector inputs REF_SEL (1:0) and FB_SEL (1:0) to dual MUX . With regard to the feedback signals, the LTS hardware control logic selects the feedback signal that went through the same translator as the reference signal that is selected to minimize the effects of any skew introduced by the two translators.","A phase detector  receives the feedback (FB) and reference (REF) signals from the dual MUX and, as explained above, generates an output in accordance with the magnitude of any phase shift detected between the two signals. Discrete logic circuit  is used to filter the output of the phase detector, in a manner similar to discrete logic  in the CTS, and provide a signal to VCXO  representing a smaller change in phase than that output from the phase detector. Within the LTSs, the VCXO is a 200 MHz oscillator as opposed to the 25 MHz oscillator used in the CTS. The output of the VCXO is the reference switch fabric clock. It is sent to clock driver , which fans the signal out to each of the local switch fabric components. For example, on the forwarding cards, the LTSs supply the 200 MHz reference clock signal to the EPP and data slice chips, and on the switch fabric data cards, the LTSs supply the 200 MHz reference clock signal to the cross-bar chips. On the switch fabric control card, the LTSs supply the 200 MHz clock signal to the scheduler and cross-bar components.","The 200 MHz reference clock signal from the VCXO is also sent to a divider circuit or component  that divides the clock by eight to produce a 25 MHz reference SOS signal . This signal is sent to clock driver , which fans the signal out to each of the same local switch fabric components that the 200 MHz reference clock signal was sent to. In addition, reference SOS signal  is provided as feedback signal SFC_FB to translator . The combination of the dual MUX, phase detector, discrete logic, VCXO, clock drivers and feedback signal forms a phase locked loop circuit allowing the 200 MHz and 25 MHz signals generated by the LTS to be synchronized to either of the reference SOS signals sent from the CTSs.","The divider component may be a SY100EL34L divider by Synergy Semiconductor Corporation.","Reference signals and from translator are also sent to activity detectors and , respectively. These activity detectors perform the same function as the activity detectors in the CTSs and assert error signals ref_a_los or ref_b_los to the LTS hardware control logic if reference signal or , respectively, die. On power-up, reset or reboot, a state machine () within the LTS hardware control logic starts in INIT\/RESET state . Arbitrarily, reference signal is the first signal considered. If activity detector is not sending an error signal (i.e., ref_a_los is 0), indicating that that reference signal is active, then the state machine changes to REF_A state  and sends signals over REF_SEL(1:0) to MUX  to select reference input and sends signals over FB_SEL(1:0) to MUX  to select feedback input . While in INIT\/RESET state , if ref_a los is asserted, indicating no signal on reference , and if ref_b_los is not asserted, indicating there is a signal on reference , then the state machine changes to REF_B state  and changes REF_SEL(1:0) and FB_SEL(1:0) to select reference input and feedback signal ","While in REF_A state , if activity detector detects a loss of reference signal and asserts ref_a_los, the state machine will change to REF_B state  and change REF_SEL(1:0) and FB_SEL(1:0) to select inputs and . Similarly, while in REF_B state , if activity detector detects a loss of signal and asserts ref_b_los, the state machine will change to REF_A state  and change REF_SEL(1:0) and FB_SEL(1:0) to select inputs and . While in either REF_A state  or REF_B state , if both ref_a_los and ref_b_los are asserted, indicating that both reference SOS signals have died, the state machine changes back to INIT\/RESET state  and change REF_SEL(1:0) and FB_SEL(1:0) to select no inputs or test inputs and or ground . For a period of time, the LTS will continue to supply a clock and SOS signal to the switch fabric components even though it is receiving no input reference signal.","When ref_a_los and\/or ref_b_los are asserted, the LTS hardware control logic notifies its local processor  through an interrupt. The SRM will decide, based on a failure policy, what actions to take, including whether to switch over from the master to slave CTS. Just as the phase detector in the CTS sends an out of lock signal to the CTS hardware control logic, the phase detector  also sends an out of lock signal OOL to the LTS hardware control logic if the magnitude of the phase difference between the reference and feedback signals exceeds a predetermined threshold. If the LTS hardware receives an asserted OOL signal, it notifies its local processor (e.g., ) through an interrupt. The SRM will decide based on a failure policy what actions to take.","Shared LTS Hardware:","In the embodiment described above, the switch fabric data cards are four independent cards. More data cards may also be used. Alternatively, all of the cross-bar components may be located on one card. As another alternative, half of the cross-bar components may be located on two separate cards and yet attached to the same network device faceplate and share certain components. A network device faceplate is something the network manager can unlatch and pull on to remove cards from the network device. Attaching two switch fabric data cards to the same faceplate effectively makes them one board since they are added to and removed from the network device together. Since they are effectively one board, they may share certain hardware as if all components were on one physical card. In one embodiment, they may share a processor, hardware control logic and activity detectors. This means that these components will be on one of the physical cards but not on the other and signals connected to the two cards allow activity detectors on the one card to monitor the reference and feedback signals on the other card and allow the hardware control logic on the one card to select the inputs for dual MUX  on the other card.","Scheduler:","Another difficulty with distributing a portion of the switch fabric functionality involves the scheduler component on the switch fabric control cards. In current systems, the entire switch fabric, including all EPP chips, are always present in a network device. Registers in the scheduler component are configured on power-up or re-boot to indicate how many EPP chips are present in the current network device, and in one embodiment, the scheduler component detects an error and switches over to the redundant switch fabric control card when one of those EPP chips is no longer active. When the EPP chips are distributed to different cards (e.g., forwarding cards) within the network device, an EPP chip may be removed from a running network device when the printed circuit board on which it is located is removed (\u201chot swap\u201d, \u201chot removal\u201d) from the network device. To prevent the scheduler chip from detecting the missing EPP chip as an error (e.g., a CRC error) and switching over to the redundant switch fabric control card, prior to the board being removed from the network device, software running on the switch fabric control card re-configures the scheduler chip to disable the scheduler chip's links to the EPP chip that is being removed.","To accomplish this, a latch  () on the faceplate of each of the printed circuit boards on which a distributed switch fabric is located is connected to a circuit  () also on the printed circuit board that detects when the latch is released. When the latch is released, indicating that the board is going to be removed from the network device, circuit  sends a signal to a circuit  on both switch fabric control cards indicating that the forwarding card is about to be removed. Circuit  sends an interrupt to the local processor (e.g., , ) on the switch fabric control card. Software (e.g., slave SRM) being executed by the local processor detects the interrupt and sends a notice to software (e.g., master SRM) being executed by the processor (e.g., , ) on the network device centralized processor card (e.g., , ,  or , ). The master SRM sends a notice to the slave SRMs being executed by the processors on the switch fabric data cards and forwarding cards to indicate the removal of the forwarding card. The redundant forwarding card switches over to become a replacement for the failed primary forwarding card. The master SRM also sends a notice to the slave SRM on the cross-connection card (e.g., \u2013, \u2013, \u2013, \u2013, ) to re-configure the connections between the port cards (e.g., \u2013, \u2013, \u2013, \u2013, ) and the redundant forwarding card. The slave SRM on the switch fabric control card re-configures the registers in the scheduler component to disable the scheduler's links to the EPP chip on the forwarding card that's being removed from the network device. As a result, when the forwarding card is removed, the scheduler will not detect an error due to a missing EPP chip.","Similarly, when a forwarding card is added to the network device, circuit  detects the closing of the latch and sends an interrupt to the processor. The slave SRM running on the local processor sends a notice to the Master SRM which then sends a notice to the slave SRMs being executed by the processors on the switch fabric control cards, data cards and forwarding cards indicating the presence of the new forwarding card. The slave SRM on the cross-connection cards may be re-configured, and the slave SRM on the switch fabric control card may re-configure the scheduler chip to establish links with the new EPP chip to allow data to be transferred to the newly added forwarding card.","Switch Fabric Control Card Switch-Over:","Typically, the primary and secondary scheduler components receive the same inputs, maintain the same state and generate the same outputs. The EPP chips are connected to both scheduler chips but only respond to the master\/primary scheduler chip. If the primary scheduler or control card experiences a failure a switch over is initiated to allow the secondary scheduler to become the primary. When the failed switch fabric control card is re-booted, re-initialized or replaced, it and its scheduler component serve as the secondary switch fabric control card and scheduler component.","In currently available systems, a complex sequence of steps is required to \u201crefresh\u201d or synchronize the state of the newly added scheduler component to the primary scheduler component and for many of these steps, network data transfer through the switch fabric is temporarily stopped (i.e., back pressure). Stopping network data transfer may affect the availability of the network device. When the switch fabric is centralized and all on one board or only a few boards or in its own box, the refresh steps are quickly completed by one or only a few processors limiting the amount of time that network data is not transferred. When the switch fabric includes distributed switch fabric subsystems, the processors that are local to each of the distributed switch fabric subsystems must take part in the series of steps. This may increase the amount of time that data transfer is stopped further affecting network device availability.","To limit the amount of time that data transfer is stopped in a network device including distributed switch fabric subsystems, the local processors each set up for a refresh while data is still being transferred. Communications between the processors take place over the Ethernet bus (e.g., , , , ) to avoid interrupting network data transfer. When all processors have indicated (over the Ethernet bus) that they are ready for the refresh, the processor on the master switch fabric control card stops data transfer and sends a refresh command to each of the processors on the forwarding cards and switch fabric cards. Since all processors are waiting to complete the refresh, it is quickly completed. Each processor notifies the processor on the master switch fabric control card that the refresh is complete, and when all processors have completed the refresh, the master switch fabric control card re-starts the data transfer.","During the time in which the data transfer is stopped, the buffers in the traffic management chips are used to store data coming from external network devices. It is important that the data transfer be complete quickly to avoid overrunning the traffic management chip buffers.","Since the switch over of the switch fabric control cards is very complex and requires that data transfer be stopped, even if briefly, it is important that the CTSs on each switch fabric control card be independent of the switch fabric functionality. This independence allows the master CTS to switch over to the slave CTS quickly and without interrupting the switch fabric functionality or data transmission.","As described above, locating the EPP chips and data slice chips of the switch fabric subsystem on the forwarding cards is difficult and against the teachings of a manufacturer of these components. However, locating these components on the forwarding cards allows the base network device\u2014that is, the minimal configuration\u2014to include only a necessary portion of the switching fabric reducing the cost of a minimally configured network device. As additional forwarding cards are added to the minimal configuration\u2014to track an increase in customer demand\u2014additional portions of the switch fabric are simultaneously added since a portion of the switch fabric is located on each forwarding card. Consequently, switch fabric growth tracks the growth in customer demands and fees. Also, typical network devices include 1:1 redundant switch fabric subsystems. However, as previously mentioned, the forwarding cards may be 1:N redundant and, thus, the distributed switch fabric on each forwarding card is also 1:N redundant further reducing the cost of a minimally configured network device.","External Network Data Transfer Timing:","In addition to internal switch fabric timing, a network device must also include external network data transfer timing to allow the network device to transfer network data synchronously with other network devices. Generally, multiple network devices in the same service provider site synchronize themselves to Building Integrated Timing Supply (BITS) lines provided by a network service provider. BITS lines are typically from highly accurate stratum two clock sources. In the United States, standard T1 BITS lines (2.048 MHz) are provided, and in Europe, standard E1 BITS lines (1.544 MHz) are provided. Typically, a network service provider provides two T1 lines or two E1 lines from different sources for redundancy. Alternatively, if there are no BITS lines or when network devices in different sites want to synchronously transfer data, one network device may extract a timing signal received on a port connected to the other network device and use that timing signal to synchronize its data transfers with the other network device.","Referring to , controller card and redundant controller card each include an external central timing subsystem (EX CTS) . Each EX CTS receives BITS lines  and provide BITS lines . In addition, each EX CTS receives a port timing signal  from each port card (\u2013, \u2013, \u2013, \u2013, ), and each EX CTS also receives an external timing reference signal  from itself and an external timing reference signal  from the other EX CTS.","One of the EX CTSs behaves as a master and the other EX CTS behaves as a slave. The master EX CTS may synchronize its output external reference timing signals to one of BITS lines  or one of the port timing signals , while the slave EX CTS synchronizes its output external reference timing signals to the received master external reference timing signal . Upon a master EX CTS failure, the slave EX CTS may automatically switch over to become the master EX CTS or software may upon an error or at any time force the slave EX CTS to switch over to become the master EX CTS.","An external reference timing signal from each EX CTS is sent to each external local timing subsystem (EX LTS)  on cards throughout the network device, and each EX LTS generates local external timing signals synchronized to one of the received external reference timing signals. Generally, external reference timing signals are sent only to cards including external data transfer functionality, for example, cross connection cards \u2013, \u2013, \u2013and \u2013() and universal port cards \u2013, \u2013, \u2013, \u2013","In network devices having multiple processor components, an additional central processor timing subsystem is needed to generate processor timing reference signals to allow the multiple processors to synchronize certain processes and functions. The addition of both external reference timing signals (primary and secondary) and processor timing reference signals (primary and secondary) require significant routing resources. In one embodiment of the invention, the EX CTSs embed a processor timing reference signal within each external timing reference signal to reduce the number of timing reference signals needed to be routed across the mid-plane(s). The external reference timing signals are then sent to EX LTSs on each card in the network device having a processor component, for example, cross connection cards \u2013, \u2013, \u2013, \u2013, universal port cards \u2013, \u2013, \u2013, \u2013, forwarding cards \u2013, \u2013, \u2013, \u2013, switch fabric cards , , \u2013, \u2013() and both the internal controller cards , () and external controller cards and ","All of the EX LTSs extract out the embedded processor reference timing signal and send it to their local processor component. Only the cross-connection cards and port cards use the external reference timing signal to synchronize external network data transfers. As a result, the EX LTSs include extra circuitry not necessary to the function of cards not including external data transfer functionality, for example, forwarding cards, switch fabric cards and internal controller cards. The benefit of reducing the necessary routing resources, however, out weighs any disadvantage related to the excess circuitry. In addition, for the cards including external data transfer functionality, having one EX LTS that provides both local signals actually saves resources on those cards, and separate processor central timing subsystems are not necessary. Moreover, embedding the processor timing reference signal within the highly accurate, redundant external timing reference signal provides a highly accurate and redundant processor timing reference signal. Furthermore having a common EX LTS on each card allows access to the external timing signal for future modifications and having a common EX LTS, as opposed to different LTSs for each reference timing signal, results in less design time, less debug time, less risk, design re-use and simulation re-use.","Although the EX CTSs are described as being located on the external controllers and , similar to the switch fabric CTSs described above, the EX CTSs may be located on their own independent cards or on any other cards in the network device, for example, internal controllers and . In fact, one EX CTS could be located on an internal controller while the other is located on an external controller. Many variations are possible. In addition, just as the switch fabric CTSs may switch over from master to slave without affecting or requiring any other functionality on the local printed circuit board, the EX CTSs may also switch over from master to slave without affecting or requiring any other functionality on the local printed circuit board.","External Central Timing Subsystem (EX CTS):","Referring to , EX CTS  includes a T1\/E1 framer\/LIU  for receiving and terminating BITS signals  and for generating and sending BITS signals . Although T1\/E1 framer is shown in two separate boxes in , it is for convenience only and may be the same circuit or component. In one embodiment, two 5431 T1\/E1 Framer Line Interface Units (LIU) available from PMC-Sierra are used. The T1\/E1 framer supplies 8 KHz BITS_REF and BITS_REF signals and receives 8 KHz BITS_TXREF and BITS_TXREF signals. A network administrator notifies NMS  () as to whether the BITS signals are T1 or E1, and the NMS notifies software running on the network device. Through signals  from a local processor, hardware control logic  within the EX CTS is configured for T1 or E1 and sends an T1E1_MODE signal to the T1\/E1 framer indicating T1 or E1 mode. The T1\/E1 framer then forwards BITS_REF and BITS_REF to dual MUXs and ","Port timing signals  are also sent to dual MUXs and . The network administrator also notifies the NMS as to which timing reference signals should be used, the BITS lines or the port timing signals. The NMS again notifies software running on the network device and through signals , the local processor configures the hardware control logic. The hardware control logic then uses select signals and to select the appropriate output signals from the dual MUXs.","Activity detectors and provide status signals and to the hardware control logic indicating whether the PRI_REF signal and the SEC_REF signal are active or inactive (i.e., stuck at 1 or 0). The PRI_REF and SEC_REF signals are sent to a stratum  or stratum E timing module . Timing module  includes an internal MUX for selecting between the PRI_REF and SEC_REF signals, and the timing module receives control and status signals  from the hardware control logic indicating whether PRI_REF or SEC_REF should be used. If one of the activity detectors or indicates an inactive status to the hardware control logic, then the hardware control logic sends appropriate information over control and status signals  to cause the timing module to select the active one of PRI_REF or SEC_REF.","The timing module also includes an internal phase locked loop (PLL) circuit and an internal stratum  or E oscillator. The timing module synchronizes its output signal  to the selected input signal (PRI_REF or SEC_REF). The timing module may be an MSTM-S3 available from Conner-Winfield or an ATIMe-s or ATIMe-3E available from TF systems. The hardware control logic, activity detectors and dual MUXs may be implemented in an FPGA. The timing module also includes a Free-run mode and a Hold-Over mode. When there is no input signal to synchronize to, the timing module enter a free-run mode and uses the internal oscillator to generate a clock output signal. If the signal being synchronized to is lost, then the timing module enters a hold-over mode and maintains the frequency of the last known clock output signal for a period of time.","The EX CTS  also receives an external timing reference signal from the other EX CTS on STRAT_SYNC  (one of STRAT_REF\u2013STRAT_REFN from the other EX CTS). STRAT_SYNC and output  from the timing module are sent to a MUX . REF_SEL(1:0) selection signals are sent from the hardware control logic to MUX to select STRAT_SYNC when the EX CTS is the slave and output  when the EX CTS is the master. When in a test mode, the hardware control logic may also select a test input from a test header ","An activity detector monitors the status of output  from the timing module and provides a status signal to the hardware control logic. Similarly, an activity detector monitors the status of STRAT_SYNC and provides a status signal to the hardware control logic. When the EX CTS is master, if the hardware control logic receives an inactive status from activity detector , then the hardware control logic automatically changes the REF_SEL signals to select STRAT_SYNC forcing the EX CTS to switch over and become the slave. When the EX CTS is slave, if the hardware control logic receives an inactive status from activity detector , then the hardware control logic may automatically change the REF_SEL signals to select output  from the timing module forcing the EX CTS to switch over and become master.","A MUX receives feedback signals from the EX CTS itself. BENCH_FB is an external timing reference signal from the EX CTS that is routed back to the MUX on the local printed circuit board. STRAT_FB  is an external timing reference signal from the EX CTS (one of STRAT_REF\u2013STRAT_REFN) that is routed onto the mid-plane(s) and back onto the local printed circuit board such that is most closely resembles the external timing reference signals sent to the EX LTSs and the other EX CTS in order to minimize skew. The hardware control logic sends FB_SEL(1:0) signals to MUX to select STRAT_FB in regular use or BENCH_FB or an input from a test header in test mode.","The outputs of both MUX and are provided to a phase detector . The phase detector compares the rising edge of the two input signals to determine the magnitude of any phase shift between the two. The phase detector then generates variable voltage pulses on outputs and representing the magnitude of the phase shift. The phase detector outputs are used by discrete logic circuit  to generate a voltage on signal  representing the magnitude of the phase shift. The voltage is used to speed up or slow down (i.e., change the phase of) a VCXO  to allow the output signal  to track any phase change in the external timing reference signal received from the other EX CTS (i.e., STRAT_SYNC) or to allow the output signal  to track any phase change in the output signal  from the timing module. The discrete logic components implement a filter that determines how quickly or slowly the VCXO's output tracks the change in phase detected on the reference signal.","The phase detector circuit may be implemented in a programmable logic device (PLD).","The output  of the VCXO is sent to an External Reference Clock (ERC) circuit  which may also be implemented in a PLD. ERC_STRAT_SYNC is also sent to ERC  from the output of MUX . When the EX CTS is the master, the ERC circuit generates the external timing reference signal  with an embedded processor timing reference signal, as described below, based on the output signal  and synchronous with ERC_STRAT_SYNC (corresponding to timing module output ). When the EX CTS is the slave, the ERC generates the external timing reference signal  based on the output signal  and synchronous with ERC_STRAT_SYNC (corresponding to STRAT_SYNC  from the other EX CTS).","External reference signal  is then sent to a first level clock driver  and from there to second level clock drivers \u2013which provide external timing reference signals (STRAT_REF\u2013STRAT_REFN) that are distributed across the mid-plane(s) to EX LTSs on the other network device cards and the EX LTS on the same network device card, the other EX CTS and the EX CTS itself. The ERC circuit also generates BITS_TXREF and BITS_TXREF signals that are provided to BITS T1\/E1 framer .","The hardware control logic also includes an activity detector  that receives STRAT_REF_ACTIVITY from clock driver . Activity detector  sends a status signal to the hardware control logic, and if the status indicates that STRAT_REF_ACTIVITY is inactive, then the hardware control logic asserts KILL_CLKTREE. Whenever KILL_CLKTREE is asserted, the activity detector in the other EX CTS detects inactivity on STRAT_SYNC and may become the master by selecting the output of the timing module as the input to MUX ","Similar to hardware control logic  () within the switch fabric CTS, hardware control logic  within the EX CTS implements a state machine (similar to the state machine shown in ) based on IM_THE_MASTER and YOU_THE_MASTER signals sent between the two EX CTSs and also on slot identification signals (not shown).","In one embodiment, ports (e.g., \u2013, ) on network device  are connected to external optical fibers carrying signals in accordance with the synchronous optical network (SONET) protocol and the external timing reference signal is a 19.44 MHz signal that may be used as the SONET transmit reference clock. This signal may also be divided down to provide an 8 KHz SONET framing pulse (i.e., J0FP) or multiplied up to provide higher frequency signals. For example, four times 19.44 MHz is 77.76 MHz which is the base frequency for a SONET OC1 stream, two times 77.76 MHz provides the base frequency for an OC3 stream and eight times 77.76 MHz provides the base frequency for an OC12 stream.","In one embodiment, the embedded processor timing reference signal within the 19.44 MHz external timing reference signal is 8 KHz. Since the processor timing reference signal and the SONET framing pulse are both 8 KHz, the embedded processor timing reference signal may used to supply both. In addition, the embedded processor timing reference signal may also be used to supply BITS_TXREF and BITS_TXREF signals to BITS T\/E framer .","Referring to , the 19.44 MHz external reference timing signal with embedded 8 KHz processor timing reference signal from ERC  (i.e., output signal ) includes a duty-cycle distortion  every 125 microseconds (us) representing the embedded 8 KHz signal. In this embodiment, VCXO  is a 77.76 MHz VCXO providing a 77.76 MHz clock output signal . The ERC uses VCXO output signal  to generate output signal  as described in more detail below. Basically, every 125 us, the ERC holds the output signal  high for one extra 77.76 MHz clock cycle to create a 75%\/25% duty cycle in output signal . This duty cycle distortion is used by the EX LTSs and EX CTSs to extract the 8 KHz signal from output signal , and since the EX LTS's use only the rising edge of the 19.44 MHz signal to synchronize local external timing signals, the duty cycle distortion does not affect that synchronization.","External Reference Clock (ERC) Circuit:","Referring to , an embeddor circuit  within the ERC receives VCXO output signal  (77.76 MHz) at four embedding registers \u2013, a 9720-1 rollover counter  and three 8 KHz output registers \u2013. Each embedding register passes its value (logic 1 or 0) to the next embedding register, and embedding register provides ERC output signal  (19.44 MHz external timing reference signal with embedded 8 KHz processor timing reference signal). The output of embedding register is also inverted and provided as an input to embedding register . When running, therefore, the embedding registers maintain a repetitive output  of a high for two 77.76 MHz clock pulses and then low for two 77.76 MHz which provides a 19.44 MHz signal. Rollover counter  and a load circuit  are used to embed the 8 KHz signal.","The rollover counter increments on each 77.76 MHz clock tick and at 9720-1 (9720-1 times 77.76 MHz=8 KHz), the counter rolls over to zero. Load circuit  detects when the counter value is zero and loads a logic 1 into embedding registers , and and a logic zero into embedding register . As a result, the output of embedding register is held high for three 77.76 MHz clock pulses (since logic ones are loaded into three embedding registers) which forces the duty cycle distortion into the 19.44 MHz output signal .","BITS circuits and also monitor the value of the rollover counter. While the value is less than or equal to 4860-1 (half of 8 KHz), the BITS circuits provide a logic one to 8 KHz output registers and , respectively. When the value changes to 4860, the BITS circuits toggle from a logic one to a logic zero and continue to send a logic zero to 8 KHz output registers and , respectively, until the rollover counter rolls over. As a result, 8 KHz output registers and provide 8 KHz signals with a 50% duty cycle on BITS_TXREF and BITS_TXREF to the BITS T\/E framer.","As long as a clock signal is received over signal  (77.76 MHz), rollover counter  continues to count causing BITS circuits and to continue toggling 8 KHz registers and and causing load circuit  to continue to load logic  into the embedding registers every 8 KHz. As a result, the embedding registers will continue to provide a 19 MHz clock signal with an embedded 8 KHz signal on line . This is often referred to as \u201cfly wheeling.\u201d","Referring to , an extractor circuit  within the ERC is used to extract the embedded 8 KHz signal from ERC_STRAT_SYNC. When the EX CTS is the master, ERC_STRAT_SYNC corresponds to the output signal  from the timing module  (pure 19.44 MHz), and thus, no embedded 8 KHz signal is extracted. When the EX CTS is the slave, ERC_STRAT_SYNC corresponds to the external timing reference signal provided by the other EX CTS (i.e., STRAT_SYNC ; 19.44 MHz with embedded 8 KHz) and the embedded 8 KHz signal is extracted. The extractor circuit includes three extractor registers \u2013. Each extractor register is connected to the 77.76 MHz VCXO output signal , and on each clock pulse, extractor register receives a logic one input and passes its value to extractor register which passes its value to extractor register which provides an 8 KHz pulse . The extractor registers are also connected to ERC_SRAT_SYNC which provides an asynchronous reset to the extractor registers\u2014that is, when ERC_STRAT_SYNC is logic zero, the registers are reset to zero. Every two 77.76 MHz clock pulses, therefore, the extractor registers are reset and for most cycles, extractor register passes a logic zero to output signal . However, when the EX CTS is the slave, every 8 KHz ERC_STRAT_SYNC remains a logic one for three 77.76 MHz clock pulses allowing a logic one to be passed through each register and onto output signal  to provide an 8 KHz pulse.","8 KHz output signal  is passed to extractor circuit  and used to reset the rollover counter to synchronize the rollover counter to the embedded 8 KHz signal within ERC_STRAT_SYNC when the EX CTS is the slave. As a result, the 8 KHz embedded signal generated by both EX CTSs are synchronized.","External Local Timing Subsystem (EX LTS):","Referring to , EX LTS  receives STRAT_REF_B from one EX CTS and STRAT_REF_A from the other EX CTS. STRAT_REF_B and STRAT_REF_A correspond to one of STRAT_REF\u2013STRAT_REFN () output from each EX CTS. STRAT_REF_B and STRAT_REF_A are provided as inputs to a MUX and a hardware control logic  within the EX LTS selects the input to MUX using REF_SEL (1:0) signals. An activity detector monitors the activity of STRAT_REF_A and sends a signal to hardware control logic  if it detects an inactive signal (i.e., stuck at logic one or zero). Similarly, an activity detector monitors the activity of STRAT_REF_B and sends a signal to hardware control logic  if it detects an inactive signal (i.e., stuck at logic one or zero). If the hardware control logic receives a signal from either activity detector indicating that the monitored signal is inactive, the hardware control logic automatically changes the REF_SEL (1:0) signals to cause MUX to select the other input signal and send an interrupt to the local processor.","A second MUX receives a feed back signal  from the EX LTS itself. Hardware control logic  uses FB_SEL(1:0) to select either a feedback signal input to MUX or a test header input to MUX . The test header input is only used in a test mode. In regular use, feedback signal  is selected. Similarly, in a test mode, the hardware control logic may use REF_SEL(1:0) to select a test header input to MUX ","Output signals and from MUXs and , respectively, are provided to phase detector . The phase detector compares the rising edge of the two input signals to determine the magnitude of any phase shift between the two. The phase detector then generates variable voltage pulses on outputs and representing the magnitude of the phase shift. The phase detector outputs are used by discrete logic circuit  to generate a voltage on signal  representing the magnitude of the phase shift. The voltage is used to speed up or slow down (i.e., change the phase of) of an output  of a VCXO  to track any phase change in STRAT_REF_A or STRAT_REF_B. The discrete logic components implement filters that determine how quickly or slowly the VCXO's output will track the change in phase detected on the reference signal.","In one embodiment, the VCXO is a 155.51 MHz or a 622 MHz VCXO. This value is dependent upon the clock speeds required by components, outside the EX LTS but on the local card, that are responsible for transferring network data over the optical fibers in accordance with the SONET protocol. On at least the universal port card, the VCXO output  signal is sent to a clock driver  for providing local data transfer components with a 622 MHz or 155.52 MHz clock signal .","The VCXO output  is also sent to a divider chip  for dividing the signal down and outputting a 77.76 MHz output signal  to a clock driver chip . Clock driver chip  provides 77.76 MHz output signals for use by components on the local printed circuit board and provides 77.76 MHz output signal to ERC circuit . The ERC circuit also receives input signal  corresponding to the EX LTS selected input signal either STRAT_REF_B or STRAT_REF_A. As shown, the same ERC circuit that is used in the EX CTS may be used in the EX LTS to extract an 8 KHz J0FP pulse for use by data transfer components on the local printed circuit board. Alternatively, the ERC circuit could include only a portion of the logic in ERC circuit  on the EX CTS.","Similar to hardware control logic  () within the switch fabric LTS, hardware control logic  within the EX LTS implements a state machine (similar to the state machine shown in ) based on signals from activity detectors and ","External Reference Clock (ERC) Circuit:","Referring again to , when the ERC circuit is within an EX LTS circuit, the inputs to extractor circuit  are input signal  corresponding to the LTS selected input signal either STRAT_REF_B or STRAT_REF_A and 77.76 MHz clock input signal . The extracted 8 KHz pulse  is again provided to embeddor circuit  and used to reset rollover counter  in order to synchronize the counter with the embedded 8 KHz signal with STRAT_REF_A or STRAT_REF_B. Because the EX CTSs that provide STRAT_REF_A and STRAT_REF_B are synchronous, the embedded 8 KHz signals within both signals are also synchronous. Within the EX LTS, the embedding registers \u2013and BITS registers and are not used. Instead, a circuit  monitors the value of the rollover counter and when the rollover counter rolls over to a value of zero, circuit  sends a logic one to 8 KHz register which provides an 8 KHz pulse signal  that may be sent by the LTS to local data transfer components (i.e., J0FP) and processor components as a local processor timing signal.","Again, as long as a clock signal is received over signal (77.76 MHz), rollover counter  continues to count causing circuit  to continue pulsing 8 KHz register ","External Central Timing Subsystem (EX CTS) Alternate Embodiment:","Referring to , instead of using one of the STRAT_REF\u2013STRAT_REFN signals from the other EX CTS as an input to MUX , the output  (marked \u201cAlt. Output to other EX CTS\u201d) of timing module  may be provided to the other EX CTS and received as input  (marked \u201cAlt. Input from other EX CTS\u201d). The PLL circuit, including MUXs and , phase detector , discrete logic circuit  and VCXO , is necessary to synchronize the output of the VCXO with either output  of the timing module or a signal from the other EX CTS. However, PLL circuits may introduce jitter into their output signals (e.g., output ), and passing the PLL output signal  via one of the STRAT_REF 1-STRAT_REFN signals from one EX CTS into the PLL of the other EX CTS\u2014that is, PLL to PLL\u2014may introduce additional jitter into output signal . Since accurate timing signals are critical for proper data transfer with other network devices and SONET standards specifically set maximum allowable jitter transmission at interfaces (Bellcore GR-253-CORE and SONET Transport Systems Common Carrier Criteria), jitter should be minimized. Passing the output  of the timing module within the EX CTS to the input  of the other EX CTS avoids passing the output of one PLL to the input of the second PLL and thereby reduces the potential introduction of jitter.","It is still necessary to send one of the STRAT_REF-STRAT_REFN signals to the other EX CTS (received as STRAT_SYNC ) in order to provide ERC  with a . MHz signal with an embedded 8 KHz clock for use when the EX CTS is a slave.","The ERC circuit only uses ERC_STRAT_SYNC in this instance when the EX CTS is the slave.","Layer One Test Port:","The present invention provides programmable physical layer (i.e., layer one) test ports within an upper layer network device (e.g., network device , ). The test ports may be connected to external test equipment (e.g., an analyzer) to passively monitor data being received by and transmitted from the network device or to actively drive data to the network device. Importantly, data provided at a test port accurately reflects data received by or transmitted by the network device with minimal modification and no upper layer translation or processing. Moreover, data is supplied to the test ports without disrupting or slowing the service provided by the network device.","Referring to , network device  includes at least one cross-connection card \u2013, \u2013, \u2013, \u2013, at least one universal port card \u2013, \u2013, \u2013, \u2013, and at least one forwarding card \u2013, \u2013, \u2013, \u2013. Each port card includes at least one port \u2013for connecting to external physical network attachments \u2013, and each port card transfers data to a cross-connection card. The cross-connection card transfers data between port cards and forwarding cards and between port cards. In one embodiment, each forwarding card includes at least one port\/payload extractor \u2013for receiving data from the cross-connection cards.","Referring to , a port on a port card within network device  may be connected to another network device (not shown) through physical external network attachments and . As described above, components  on the port card transfer data between port and cross-connection card , and components  on the cross-connection card transfer data on particular paths between the port cards and the forwarding cards or between port cards. For convenience, only one port card, forwarding card and cross-connection card are shown.","For many reasons, including error diagnosis, a service administrator may wish to monitor the data received on a particular path or paths at a particular port, for example, port , and\/or the data transmitted on a particular path or paths from port . To accomplish this, the network administrator may connect test equipment, for example, an analyzer  (e.g., an Omniber analyzer available from Hewlett Packard Company), to the transmit connection of port to monitor data received at port and\/or to the transmit connection of port to monitor data transmitted from port . The network administrator then notifies the NMS (e.g., NMS  running on PC , ) as to which port or ports on which port card or port cards should be enabled and whether the transmitter and\/or receiver for each port should be enabled. The network administrator also notifies the NMS as to which path or paths are to be sent to each test port, and the time slot for each path. With this information, the NMS fills in test path table  () in configuration database .","Similar to the process of enabling a working port through path table  (), when a record in the test path table is filled in, the configuration database sends an active query notification to the path manager (e.g., path manager ) executing on the universal port card (e.g., port card ) corresponding to the universal port card port LID in the path table record. For example, port may have a port LID of  (record , ) and port may have a port LID of  (record ). An active query notification is also sent to NMS database , and once the NMS database is updated, the NMS displays the new system configuration, including the test ports, to the user.","Through the test path table, the path manager learns that the transmitters of ports and need to be enabled and which path or paths are to be transferred to each port. As shown in path table  (), path LID  corresponds to working port LID  (port ), and as shown in test path table  (), path LID  is also assigned to test port LIDs  and  (ports and , respectively). Record  indicates that the receive portion of path  (i.e., \u201cingress\u201d in Monitor column ) is to be sent to port LID  (i.e., port ) and then transmitted (i.e., \u201cno\u201d in Enable Port Receiver column ) from port LID , and similarly, record  indicates that the transmit portion of path  (i.e., \u201cegress\u201d in Monitor column ) is to be sent to port LID  (i.e., port ) and then transmitted (i.e., \u201cno\u201d in Enable Port Receiver column ) from port LID .","The path manager passes the path connection information to cross-connection manager  executing on the cross-connection card . The CCM uses the connection information to generate a new connection program table  and uses this table to program internal connections through one or more components (e.g., a TSE chip ) on the cross-connection card. After re-programming, cross-connection card continues to transmit data corresponding to path LID  between port on universal port card and the serial line input to payload extractor on forwarding card . However, after reprogramming, cross-connection card also multicasts the data corresponding to path LID  and received on port to port and data corresponding to path LID  and transmitted to port by forwarding card to port ","Analyzer  may then be used to monitor both the network data received on port and the network data being transmitted from port . Alternatively, analyzer  may only be connected to one test port to monitor either the data received on port or the data transmitted from port . The data received on port may be altered by the components on the port card(s) and the cross-connection cards before the data reaches the test port but any modification is minimal. For example, where the external network attachment is a SONET optical fiber, the port card components may convert the optical signals into electrical signals that are passed to the cross-connection card and then back to the test ports, which reconvert the electrical signals into optical signals before the signals are passed to analyzer . Since the data received at port has not been processed or translated by the upper layer processing components on the forwarding card, the data accurately reflects the data received at the port. For example, the physical layer (e.g., SONET) information and format is accurately reflected in the data received.","To passively monitor both the data received and transmitted by a particular port, two transmitters are necessary and, thus, two ports are consumed for testing and cannot be used for normal data transfer. Because the test ports are programmable through the cross-connection card, however, the test ports may be re-programmed at any time to be used for normal data transfer. In addition, redundant ports may be used as test ports to avoid consuming ports needed for normal data transfer. Current network devices often have a dedicated test port that can provide both the data received and transmitted by a working port. The dedicated test port, however, contains specialized hardware that is different from the working ports and, thus, cannot be used as a working port. Hence, although two ports may be consumed for monitoring the input and output of one working port, they are only temporarily consumed and may be re-programmed at any time. Similarly, if the port card on which a test port is located fails, the test port(s) may be quickly and easily reprogrammed to another port on another port card that has not failed. Instead of passively monitoring the data received at port , test equipment  may be connected to the receiver of a test port and used to drive data to network device . For example, the network administrator may connect test equipment  to the receiver of test port and then notify the NMS to enable the receiver on port to receive path . With this information, the NMS modifies test path table . For example, record  () indicates that the receive portion of path  (i.e., \u201cingress\u201d in Monitor column ) is to be driven (i.e., \u201cyes\u201d in Enable Port Receiver column ) externally with data from port LID  (i.e., port ). Again, an active query notification is sent to path manager . Path manager  then disables the receiver corresponding to port LID  (i.e., port ) and enables the receiver corresponding to port LID  (i.e., port ) and passes the path connection information to cross-connection manager  indicating that port LID  will supply the receive portion of path . The cross-connection manager uses the connection information to generate a new connection program table  to re-program the internal connections through the cross-connection card. In addition, the network administrator may also indicate that the transmitter of port should be disabled, and path manager  would disable the transmitter of port and pass the connection information to the cross connection manager.","After re-programming, cross-connection card data is sent from test equipment  to test port and then through the cross-connection card to forwarding card . The cross-connection card may multicast the data from forwarding card to both working port and to test port , or just to test port or just working port ","Instead of having test equipment  drive data to the network device over a test port, internal components on a port card, cross-connection card or forwarding card within the network device may drive data to the other cards and to other network devices over external physical attachments connected to working ports and\/or test ports. For example, the internal components may be capable of generating a pseudo-random bit sequence (PRBS). Test equipment  connected to one or more test ports may then be used to passively monitor the data sent from and\/or received by the working port, and the internal components may be capable of detecting a PRBS over the working port and\/or test port(s).","Although the test ports have been shown on the same port card as the working port being tested, it should be understood, that the test ports may be on any port card in the same quadrant as the working port. Where cross-connection cards are interconnected, the test ports may be on any port card in a different quadrant so long as the cross-connection card in the different quadrant is connected to the cross-connection card in same quadrant as the working port. Similarly, the test ports may be located on different port cards with respect to each other. A different working port may be tested by re-programming the cross-connection card to multicast data corresponding to the different working port to the test port(s). In addition, multiple working ports may be tested simultaneously by re-programming the cross-connection card to multicast data from different paths on different working ports to the same test port(s) or to multiple different test ports. A network administrator may choose to dedicate certain ports as test ports prior to any testing needing to be done or the network administrator may choose certain ports as test ports when problems arise.","The programmable physical layer test port or ports allow a network administrator to test data received at or transmitted from any working port or ports and also to drive data to any upper layer card (i.e., forwarding card) within the network device. Only the port card(s) and cross-connection card need be working properly to passively monitor data received at and sent from a working port. Testing and re-programming test ports may take place during normal operation without disrupting data transfer through the network device to allow for diagnosis without network device disruption.","It will be understood that variations and modifications of the above described methods and apparatuses will be apparent to those of ordinary skill in the art and may be made without departing from the inventive concepts described herein. Accordingly, the"],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 2","i":["a","b "],"b":"2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3","i":"a "},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 3","i":["b ","d","f "],"b":["3","3"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3","i":"c "},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3","i":"g "},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3","i":"h "},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 4","i":["a","j "],"b":"4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 5 and 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 6","b":["7","10","11","11","12","13","14"],"i":["a","b"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 16","i":["a","b "],"b":"16"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 16","i":"c "},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16","i":"d "},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 17\u201319"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIGS. 31","i":["a","c","a","c","a","d ","a","b "],"b":["31","32","32","33","33","34","34"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 38 and 39"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIGS. 41","FIG. 40"],"i":["a","c "],"b":"41"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 55"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 56"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 57"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 58"}]},"DETDESC":[{},{}]}
