---
title: Shader cache using a coherency protocol
abstract: Methods and systems for caching graphics data using dedicated level one caches and a shared level two cache are described. Furthermore, each method includes a protocol for maintaining coherency between the level one caches and between the level one caches and the level two cache. The level one caches may store different versions of the graphics data, permitting simultaneous processing of execution threads, each thread accessing a different version of the graphics data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07103720&OS=07103720&RS=07103720
owner: NVIDIA Corporation
number: 07103720
owner_city: Santa Clara
owner_country: US
publication_date: 20031029
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention generally relates to data processing and, more particularly, to caching data in a multi-threaded streaming processor.","Current graphics data processing includes systems and methods developed to perform a specific operation on graphics data. Operations such as geometric transformations are applied to a plurality of graphics primitives and constants used during those operations are conventionally stored in a local memory such as a register file or random access memory (RAM).",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1","b":["100","105","110","130","110","120","120","125","120","130"]},"Prior to writing a constant to Constant Storage , Controller  must obtain exclusive write access to Constant Storage  to ensure that a constant is not inadvertently modified before being read by either Processing Unit . Therefore, Controller  determines that each Processing Unit  is idle before writing a constant to Constant Storage , blocking a unit providing Input  if needed until the constant is modified. Blocking Input  reduces the throughput of Graphics Processing System . Furthermore, when Processing Units  are many pipeline stages deep, one Processing Unit  may be idle for many clock cycles before the other Processing Unit  completes processing and becomes idle.","Accordingly, it would be desirable to provide improved approaches to updating constants accessed by one or more graphics processing units.","Various embodiments of a method of the invention include storing a first version of graphics data in a first level 1 cache, storing a second version of graphics data in a second level 1 cache, and storing the first version of graphics data in a level 2 cache.","Various embodiments of the invention include a graphics processing array. The graphics processing array includes a first execution unit configured to process graphics data and including a first level 1 cache, a second execution unit configured to process graphics data and including a second level 1 cache, and a level 2 cache coupled to both the first execution unit and the second execution unit.","The current invention involves new systems and methods for storing and accessing graphics data using dedicated level one caches and a shared level two cache.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the present invention. However, it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the present invention.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2","b":["200","235","240","240","240","260","200","240"]},"A Controller  writes constants to one or more Level 1 (L1) Caches , each L1 Cache  within an execution unit, Streaming Multiprocessor (SM) . Controller  tracks which SMs  are active (processing data) and inactive (available to process data). Controller  also tracks the state of each L1 Cache , including optionally tracking which locations, e.g., cache lines, entries, or the like, within each L1 Cache  have been updated via Controller  writing a constant to L1 Cache .","Unlike Processing Units  shown in , each SM  may be processing graphics data using a different value for a constant because each SM  has a dedicated L1 Cache . Consequently, each L1 Cache  may store a different \u201cversion\u201d of constants. A graphics program made up of a sequence of commands (vertex program or shader program) is executed within one or more SMs  as a plurality of threads where each vertex or fragment to be processed by the program is assigned to a thread. Although threads share an L1 Cache  and processing resources within an SM , the execution of each thread proceeds independent of any other threads. In one embodiment each SM  processes one thread. In other embodiments each SM  processes several or more threads.","A Level 2 (L2) Cache  includes the version of constants used by the oldest active thread. Therefore, L2 Cache  is coherent with L1 Caches  (and corresponding SM ) using the same version of constants. When a read request received by L2 Cache  from an L1 Cache  results in a cache miss, L2 Cache  reads the data from a Memory  and stores the data. The L1 Cache also stores the data. Memory  may include system memory, local memory, or the like. When all SMs  using the same version of constants become inactive, L2 Cache  is updated to a different, more recent version of constants if a more recent version exists, as described further herein. Similarly, prior to outputting graphics data to an SM  for processing, Controller  determines if an L1 Cache  within an inactive SM  needs to be updated to contain a current version of constants. The current version of constants has updated each constant specified by each received constant command.","When a constant is written to a location within an L1 Cache  the location is \u201clocked\u201d, preventing the location from being overwritten prior to either invalidation of the L1 Cache  or moving the constant to L2 Cache . If all locations within an L1 Cache  are locked and a constant should be replaced in the L1 Cache  due to an cache miss in the L1 Cache , the SM  containing the L1 Cache  stalls until the L1 Cache  (or another L1 Cache ) can write the constant to L2 Cache , thereby becoming coherent with L2 Cache .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3A","b":["220","210","200","240","0","1","2","3","301","230","0","240","0","0","303","230","0","220","1","2","3","0","240","0","0","210","220","0","220","1","2","3","220","1","2","3"],"i":["s","s "]},"In step  Controller  outputs vertex to an inactive SM , SM for processing and SM becomes active. In step  Controller  outputs vertex to an inactive SM , SM for processing and SM becomes active. In step  Controller  outputs vertex to an inactive SM , SM for processing and SM becomes active. SM, SM, and SM are each using the same version of constants, the current version of constants. In step  SM completes processing of vertex and becomes inactive. In step  Controller  determines SM is inactive. Controller  instructs SM to copy a portion of graphics data, e.g. one or more constants, stored in the L1 Cache  in SM from the L1 Cache  in SM to the L1 Cache  in SM. In one embodiment Controller  determines which constants to copy by maintaining dirty bits for each L1 Cache . The dirty bits are asserted when a constant is written and cleared when a constant is copied. A dirty bit may correspond to a specific constant, cache entry, cache line, or the like.","In step  Controller  determines none of the SMs  are using the version of constants stored in L2 Cache , the old version of constants. Controller  instructs SM to copy one or more constants from the L1 Cache  in SM to L2 Cache  and all of the SMs  are coherent with L2 Cache . In this embodiment two versions of constants are simultaneously used within SPA  to process graphics data. All of the SMs  do not need to be inactive prior to updating a constant stored in an L1 Cache , therefore performance is improved compared with an embodiment of SPA  with a single shared constant storage.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 3B","FIG. 3A"],"b":["220","210","301","303","305","220","0","210","220","1","2","3","0","1","2","3"]},"In step  Controller  outputs constant to L1 Caches  in SM and SM. L1 Caches  in SM and SM store a third version of constants. In step  Controller  outputs vertex to SM for processing and SM becomes active. In step  SM completes processing of vertex and becomes inactive. In step  Controller  determines SM is inactive and the other SMs  are not using the first version of constants. Controller  instructs SM to copy one or more constants from the L1 Cache  in SM to the L1 Cache  in SM. In step  Controller  determines none of the SMs  are using the version of constants stored in L2 Cache , the first version of constants. Controller  instructs SM to copy one or more constants from the L1 Cache  in SM to L2 Cache  and SM and SM are coherent with L2 Cache , each storing the second version of constants.","In step  Controller  determines SM is not using the current version of constants, the third version of constants stored in L1 Caches  in SM and SM. Controller  instructs SM to copy one or more constants from the L1 Cache  in SM to the L1 Cache  in SM and SM, SM, and SM each store the third version of constants. Only the L1 Cache  in SM is coherent with L2 Cache , each storing the oldest version of constants in use, the second version of constants.","In step  SM completes processing of vertex and becomes inactive. In step  Controller  determines SM is inactive and the other SMs  are not using the second version of constants. Controller  instructs SM to copy one or more constants from the L1 Cache  in SM to the L1 Cache  in SM. In step  Controller  determines none of the SMs  are using the version of constants stored in L2 Cache , the second version of constants. Controller  instructs SM to copy one or more constants from the L1 Cache  in SM to L2 Cache  and all of the L1 Caches  are coherent with L2 Cache . In this embodiment more than two versions of constants are simultaneously used within SPA  to process graphics data. The number of versions of constants may be equal to the number of SMs  within SPA . The size of L1 Cache  is determined by a typical working set of constants and may be specified by an application programming interface. The size of L2 Cache  is larger than the size of L1 Cache , however L2 Cache  stores the \u201coldest\u201d version of constants used by at least one SM . Consequently, cache misses of L2 Cache  result when other versions of constants are requested. As previously mentioned in relation to , performance is improved compared with an embodiment of SPA  with a single shared constant storage.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 4","FIG. 2"],"b":["200","240","210","405","230","410","230","240","230","410","410","230","240","415","230","405","420","230","220","240","220"]},"If, in step  Controller  determines at least one L1 Cache  within an inactive SM  stores an old version of constants, in step  Controller updates the at least one L1 Cache  to store the current version of constants. For example, Controller  copies the current version of constants stored in an L1 Cache  within an active SM  to each L1 Cache  within an inactive SM . In step  Controller  also marks the at least one updated L1 Cache  as invalid because the at least one updated L1 Cache  is not coherent with L2 Cache  and Controller  proceeds to step . If, in step  Controller  determines at least one L1 Cache  within an inactive SM  does not store an old version of constants, then Controller  proceeds to step .","In step  Controller  determines if L2 Cache  stores an old and unused version of constants, and, if not, Controller  proceeds to step . A version of constants is unused if an active SM  is not using the version of constants stored in L2 Cache . If, in step  Controller  determines L2 Cache  stores an old and unused version of constants, then in step  Controller  updates L2 Cache  to the oldest used version of constants. Sometimes the oldest used version of constants is the current version of constants. In one embodiment L2 Cache  is updated by copying the oldest used version of constants from an L1 Cache  to L2 Cache . In some embodiments Controller  copies a portion of the oldest used version of constants, determining which constants to copy by maintaining dirty bits for each L1 Cache . In step  Controller  marks each SM  including an L1 Cache  that stores the same version of constants that is stored in L2 Cache  as valid and proceeds to step . Marking an L1 Cache  within an SM  as valid indicates the L1 Cache  is coherent with L2 Cache . In step  Controller  outputs the command received in step  to an inactive SM  for processing and the inactive SM  becomes active.","If, in step  Controller  determines the command received in step  is a constant command, then in step  Controller  marks all inactive SMs  as invalid because each L1 Cache  within an inactive SM  will receive the constant command. Therefore, each L1 Cache  within an inactive SM  will not be coherent with L2 Cache . In step  Controller  writes the constant included in the constant command to each L1 Cache  within an inactive SM . In step  Controller  determines if another command is available at Input , and, if not, Controller repeats step . If, in step  Controller  determines another command is available at Input , then in step  Controller  determines if the command is a constant command. If, in step  Controller  determines the command is a constant command, then Controller  returns to step . Otherwise, Controller  returns to step .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 5","b":["200","200","510","240","210","230","230","210","510","240","240","510","230","210","510","230","510"]},"In this embodiment when an SM  becomes inactive the L1 Cache  within the SM  is invalidated unless the constants in L1 Cache  are the same version as L2 Cache . Therefore, L1 Caches  are not updated by copying constants from one L1 Cache  to another L1 Cache . Because L2 Cache  always contains the most recent version of constants L2 Cache  is not updated from an L1 Cache . L1 Caches  only read L2 Cache  and L1 Caches  are updated to the current version of constants by copying one or more constants from L2 Cache . Consequently, the interfaces and interactions between SMs  and L2 Cache  and between SMs  and Controller  are less complex than the embodiment of SPA  shown in . However, each read request from an L1 Cache  to L1 Cache  includes a version tag, specifying the version of constants used in the SM  and stored in the L1 Cache  within the SM .","In some embodiments each SM  includes a version tag that is initialized to zero. L2 Cache  also includes a version tag that is initialized to zero and L2 Backup Cache  includes one or more version tags that are initialized to zero. When a sequence of constant load commands is received each version tag in an active SM  is incremented and each version tag in an inactive SM  remains unchanged. Each L1 Cache  within an inactive SM  is loaded with the constants in the sequence of constant commands.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 6","b":["220","210","51","200","240","0","1","2","3","301","230","0","240","0","0","303","230","0","220","1","2","3","0","240","0","0","603","0","230","510","210","510","230","510"],"i":["b ","s"]},"In step  Controller  outputs constant to L2 Cache . L2 Cache  is coherent with the L1 Caches  in SM, SM, and SM, but is not coherent with the L1 Cache  in SM. In step  Controller  outputs vertex to an inactive SM , SM for processing and SM becomes active. In step  Controller  outputs constant to L1 Caches  in SM and SM. L1 Caches  in SM and SM store a third version of constants. In step  Controller  outputs vertex to SM for processing and SM becomes active. In step  SM completes processing of vertex and becomes inactive. In step  the version tags in SM and SM are updated and Controller  copies the second version of constants to L2 Cache Backup . The version tag stored in L2 Cache  is updated and copied with the second version of constants to L2 Cache Backup . In step  Controller  outputs constant to L2 Cache . L2 Cache  is coherent with the L1 Caches  in SM, and SM, but is not coherent with the L1 Caches  in SM and SM.","In step  Controller  outputs vertex to SM for processing and SM becomes active. In step  SM completes processing of vertex and becomes inactive. In step  Controller  determines SM is inactive and the other SMs  are not using the first version of constants and Controller  invalidates the L1 Cache  in SM and clears the version tag in SM to zero, corresponding to the version tag of the third version of constants. In step  Controller  retires any locations in L2 Cache Backup  containing a portion of the first version of constants. In step  SM completes processing of vertex and becomes inactive. In step  SM completes processing of vertex and becomes inactive. In step  Controller  determines SM is inactive and the other SMs  are not using the second version of constants and Controller  invalidates the L1 Cache  in SM and clears the version tag in SM to zero, corresponding to version tag of the third version of constants. In step  Controller  retires any locations in L2 Cache Backup  containing a portion of the second version of constants.","For embodiments of SPA  as shown in , the number of versions of constants may be as great as the number of SMs  within SPA . The size of L1 Cache  is determined by a typical working set of constants and may be specified by an application programming interface. The size of L2 Cache  may be large enough to hold additional number of constants beyond the number of constants in a typical working set, however, unlike the L2 Cache  shown in , the L2 Cache  shown in  stores the current version of constants. L2 Cache Backup  stores any other version of constants used by at least one SM . L2 Cache Backup  may be sized to minimize cache misses when non-current versions of constants are requested by an SM .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 7","FIG. 5"],"b":["220","210","510","240","705","230","710","230","240","230","710"]},"If, in step  Controller  determines all SMs  are not active, then in step  Controller  determines if the command received in step  is a constant command, and, if not, then in step  Controller  outputs the command to an inactive SM  for processing and the SM  becomes active. If, in step  Controller  determines the command received in step  is a constant command, then in step  version tags of active SMs  are updated. The active SMs  will proceed using one or more older versions of the constants and inactive SMs  and L2 Cache  will receive at least one constant command.","In step  Controller  determines if L2 Cache Backup  is storing any unused versions of constants. An unused version of constants is not used by any active SM , therefore the version tag corresponding to the unused version of constants does not match the version tag of constants used by any active SM . If, in step  Controlller  determines L2 Cache Backup  is storing at least one unused version of constants, then in step  the at least one unused version of constants is retired and at least one cache location is available for allocation to another constant and Controller  proceeds to step . If, in step  Controller  determines L2 Cache Backup  is not storing at least one unused version of constants, then in step  Controller  invalidates each L1 Cache  within an inactive SM  and clears the version tag associated with each inactive SM  to zero.","In step  Controller  copies (or moves) the constant stored the location in L2 Cache  to be written by the constant command received in step  from the location in L2 Cache  to a location in L2 Cache Backup . The version tag stored in L2 Cache  is updated and copied with the constant to L2 Cache Backup . Controller  associated the location in L2 Cache Backup  with the version of the constant. In step  Controller  outputs the constant command received in step  to all inactive SMs . In step  Controller  outputs the constant command to L2 Cache . In step  Controller  determines if another command is available, and, if not, Controller  repeats step . If, in step  Controller  determines another command is available, then in step  Controller  determines if the command is a constant command, and, if not, Controller  returns to step . Otherwise Controller  returns to step .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 8","b":["800","200","800","810","807","800","810","814","812","812","815","815","812"]},"Host Computer  communicates with Graphics Subsystem  via System Interface  and a Graphics Interface  within a Graphics Processor . Data received at Graphics Interface  can be passed to a Front End  within a Graphics Processing Pipeline  or written to a Local Memory  through Memory Controller . Front End  also receives commands from Host Computer  via Graphics Interface . Front End  interprets and formats the commands and outputs the formatted commands and graphics data to an Index Processor . Some of the formatted commands, e.g., constant commands, vertex commands, and the like, are used by SPA  to initiate processing of graphics data. Commands may provide the location of program instructions or graphics data stored in graphics memory. Index Processor , SPA  and Raster Operations Unit  each include an interface to Memory Controller  through which program instructions or graphics data may be read from graphics memory. Graphics memory may include portions of Host Memory , Local Memory  directly within Graphics Subsystem , register files coupled to the computation units within Programmable Graphics Processor , and the like.","Index Processor  optionally reads processed data, e.g., data written by Raster Operations Unit , from graphics memory and outputs the graphics data, processed graphics data and formatted commands to SPA . SPA  contains one or more execution units, such as SM , to perform a variety of specialized functions. Some of these functions are table lookup, scalar and vector addition, multiplication, division, coordinate-system mapping, calculation of vector normals, tessellation, calculation of derivatives, interpolation, and the like.","Processed graphics data output by SPA  are passed to Raster Operations Unit , which performs near and far plane clipping and raster operations, such as stencil, z test, and the like, and saves the results in graphics memory. When the graphics data received by Graphics Subsystem  has been completely processed by Graphics Processor , an Output  of Graphics Subsystem  is provided using an Output Controller . Output Controller  is optionally configured to deliver processed graphics data to a display device, network, electronic control system, other Computing System , other Graphics Subsystem , or the like. In alternate embodiments Graphics Processing Pipeline  includes additional computation units coupled in parallel or in series with the computation units shown in . For example, an additional SPA  may be included in parallel or in series with SPA . Alternatively, a rasterization unit may be coupled to SPA  to scan convert primitives output by SPA  and produce fragments as input to SPA .","The invention has been described above with reference to specific embodiments. Persons skilled in the art will recognize, however, that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. Specifically, the methods and systems described may be used for caching data other than graphics data where the data is used by a streaming multiprocessor capable of processing several execution threads. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The listing of steps in method claims do not imply performing the steps in any particular order, unless explicitly stated in the claim. Within the claims, element lettering (e.g., \u201ca)\u201d, \u201cb)\u201d, \u201ci)\u201d, \u201cii)\u201d, etc.) does not indicate any specific order for carrying out steps or other operations; the lettering is included to simplify referring to those elements.","All trademarks are the respective property of their owners."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Accompanying drawing(s) show exemplary embodiment(s) in accordance with one or more aspects of the present invention; however, the accompanying drawing(s) should not be taken to limit the present invention to the embodiment(s) shown, but are for explanation and understanding only.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
