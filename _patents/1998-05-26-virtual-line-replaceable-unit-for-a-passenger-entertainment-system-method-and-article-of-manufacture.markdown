---
title: Virtual line replaceable unit for a passenger entertainment system, method and article of manufacture
abstract: A system server is used to manage communication over a network between the system server and a plurality of physical devices of a passenger entertainment system. The system is configured and operated using software to provide passenger entertainment. The system server comprises software for instantiating a dispatch object to open a framework network addressable unit objects, for instantiating one or more virtual line replaceable unit objects to manage communication between a network address unit and physical devices, and for communicating network messages through the dispatch object to the physical devices. The dispatch object tracks messages to the physical devices utilizing a queue and tracks messages from the physical devices utilizing a queue. The dispatch object maintains the status of related devices. The dispatch object also adds and removes one or more of the virtual line replaceable units. The network addressable unit objects move data from one storage location to another.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07028304&OS=07028304&RS=07028304
owner: Rockwell Collins
number: 07028304
owner_city: Cedar Rapids
owner_country: US
publication_date: 19980526
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTIFICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","DETAILED SYSTEM DESCRIPTION"],"p":["Portions of this patent application contain materials that are subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document, or the patent disclosure, as it appears in the Patent and Trademark Office.","The present invention relates to providing entertainment to passengers in a vehicle, and more specifically, to systems, methods and articles of manufacture that provide for a networked passenger entertainment system that integrates audio, video, passenger information, product ordering and service processing, communications, and maintainability features, and permits passengers to selectively order or request products and services, receive video, audio and game data for entertainment purposes, and communicate with other passengers and computers on- and off-board the aircraft, and which thereby provides for passenger selected delivery of content over a communication network.","The assignee of the present invention manufactures in-flight aircraft passenger entertainment systems. Such systems distribute audio and video material to passengers derived from a variety of sources. For example, such systems provide passengers with audio generated from audio tape players, movies derived from video tape players, and interactive services such as games, shopping and telecommunications. A variety of inventions have been patented by the assignee of the present invention and others relating to in-flight aircraft entertainment systems and their components. Certain of these prior art systems and components are summarized below.","U.S. Pat. No. 3,795,771 entitled \u201cPassenger Entertainment\/Passenger Service and Self-Test System\u201d discloses a time multiplexed passenger entertainment and service combined system suitable for distribution throughout compartments of super aircraft. Common power supplies, cabling, and boxes, and hybrid microelectronics and\/or medium or large scale MOSFET integrated circuit chips are employed. A main multiplexer receives passenger address or tape deck analog signals and converts them to a pulse code modulated digital bit stream which is time shared between channels. A coaxial cable transmits the bit stream to compartment submultiplexers. Each submultiplexer receives the digital bit stream, optionally inserts into the bit stream bits representing analog-to-digital converted movie audio or compartment introduced passenger address and distributes the data stream along four columns of seat group units on individual column coaxial cables. At each seat group unit a demultiplexer of a seat group demultiplexer\/encoder converts the bit stream into the original analog signals, amplifiers the analog signals and drives individual seat transducers for passenger listening.","A passenger control unit provides channel and volume level selection. The passenger service system provides control functions comprising reading light, stewardess call (aisle and control panel lights and chimes). The service system comprises a section timer\/decoder to generate binary logic pulses which are transmitted by cable sequentially down and up the seat columns from seat group unit to seat group unit. A similar cable connects the corresponding overhead unit containing the reading lights, etc. to the section timer\/decoder. The seat encoder of each seat group demultiplexer\/encoder receives digital interrogating signals, processes them relative to switch positions determined by the passenger and sends out results to the section timer\/decoder. The overhead decoder of each seat group receives the retransmitted digital signals from the section timer\/decoder and performs switching functions conforming to seat encoder commands. The system incorporates a self-test subsystem comprising a test signal generator and circuits operating in conjunction with the entertainment and service system circuits.","U.S. Pat. No. 5,289,272 entitled \u201cCombined Data, Audio and Video Distribution System in Passenger Aircraft\u201d discloses a passenger aircraft video distribution system that distributes modulated RF carrier signals from a central signal source to be used at each passenger seat. The carriers are modulated to contain audio, video also other digital data, such as graphics, and slide shows and the like. Analog video signals from the video source are modulated on individually discrete carriers in the range of 54 to 300 megahertz. Audio information, including audio sound channels and the video audio, are digitized and combined with digital data in a combined serial bit stream that is multiplexed, and then modulated on an RF carrier having a frequency sufficiently above the frequency band of the video signals so that the resulting spectrum of the modulated audio RF carrier does not interfere with the modulated video carriers. The RF carrier signals are combined and distributed to individual seats. The modulated audio carrier is separated from the video carriers at each seat or each group of seats and then demodulated and demultiplexed for selection at each individual seat of a chosen audio channel.","U.S. Pat. No. 4,866,515 entitled \u201cPassenger Service and Entertainment System for Supplying Frequency-Multiplexed Video, Audio, and Television Game Software Signals to Passenger Seat Terminals\u201d discloses a service and entertainment system for transmitting video signals, audio signals and television game software signals from a central transmitting apparatus to each of a plurality of terminals mounted at respective passenger seats in an aircraft, or at respective seats in a stadium, or theater, or the like. The video signals, audio signals and television game software signals are frequency-multiplexed and then transmitted to the terminals, so that desired ones of the frequency-multiplexed signals can be selected at each terminal unit.","U.S. Pat. No. 4,647,980 entitled \u201cAircraft Passenger Television System\u201d discloses a television system that provides for individualized program selection and viewing by aircraft passengers. The system comprises a plurality of compact television receivers mounted in front of each airline passenger in a rearwardly facing position within the passenger seat immediately in front of each passenger. Each television receiver is provided as a lightweight module adapted for rapid, removable installation into a mounting bracket opening rearwardly on the rear side of a passenger seat, with a viewing screen set at a tilt angle accommodating an average reclined position of the seat. Exposed controls permit channel and volume selection by the individual passenger, and an audio headset is provided for plug-in connection to the module. A broadcast station on the aircraft provides prerecorded and\/or locally received programs on different channels to each television module for individual passenger selection.","U.S. Pat. No. 4,630,821 entitled \u201cVideo Game Apparatus Integral with Aircraft Passenger Seat Tray\u201d discloses a video game apparatus employed by a passenger of an aircraft. The apparatus includes a tray that is mounted on the rear of an aircraft seat. The tray has an internal hollow with a rectangular aperture on a top surface which surface faces the passenger when the tray is placed in a usable position. Located in the rectangular aperture is a TV display screen. Located in the internal hollow of the tray is a video game apparatus that operates to provide a video game display on the surface of said TV display screen. The surface of the tray containing the TV display screen also includes a plurality of control elements that are coupled to the video game apparatus to enable the passenger to operate the game. To energize the game, the tray contains a cable coupling assembly whereby when a cable is inserted into the assembly, the video game is energized to provide a display of a game selected by means of a selector switch also mounted on the top surface of the tray.","U.S. Pat. No. 4,352,200 entitled \u201cWireless Aircraft Passenger Audio Entertainment System\u201d discloses that audio information in several audio channels is supplied via head sets to passengers seated aboard an aircraft in rows of seats including armrests and being distributed along an elongate passenger section inside a metallic fuselage. An antenna is run along the elongate passenger section of the aircraft for radio transmission inside such elongate passenger section. Individual antennas are provided for the passenger seats for receiving the latter radio transmission. These receiving antennas are distributed among predetermined armrests of the passenger seats. The audio information to be transmitted is provided in radio frequency channels in a band between 72 and 73 MHz. The distributed receiving antennas are coupled via seated passengers to the transmitting antenna. The radio frequency channels are transmitted in the mentioned band via the transmitting antenna, seated passengers and distributed receiving antennas to the predetermined armrests. Audio information is derived in the audio channels from the transmitted radio frequency channels also in the predetermined armrests. Passengers are individually enabled to select audio information from among the derived audio information in the audio channels. The selected audio information is applied individually to the headsets.","U.S. Pat. Nos. 5,965,647 and 5,617,331 entitled \u201cIntegrated Video and Audio Signal Distribution System and Method for use on Commercial Aircraft and Other Vehicles\u201d disclose passenger entertainment systems employing an improved digital audio signal distribution system and method for use on commercial aircraft and other vehicles. A plurality of digital audio signal sources are provided for generating a plurality of compressed digital audio signals. The compressed digital audio signals are provided to a multiplexer that domain multiplexes the signals to produce a single composite digital audio data signal. The composite digital audio data signal is provided to a demultiplexer which is capable of selecting a desired channel from the composite digital audio data signal. The selected channel is provided to a decompression circuit, where it is expanded to produce a decompressed digital output signal. The decompressed digital output signal is then provided to a digital-to-analog converter and converted to an analog audio signal. The analog audio signal is provided to an audio transducer.","While the above patents disclose various aspects of passenger entertainment systems and components used therein, none of these prior art references disclose a fully integrated networked passenger entertainment system that integrates audio, video, product ordering and service processing, networked communications, and maintainability features. Accordingly, it is an objective of the present invention to provide for systems and methods that implement an integrated networked passenger entertainment and communication system that provides for passenger selected delivery of content over a communication network. It is a further objective of the present invention to provide for systems and methods that permit passengers to selectively order or request products or services, receive audio, video and game data, that permits communication of information to passengers from aircraft personnel, and that permits passengers to communicate with other passengers and computers located on- and off-board an aircraft.","The foregoing problems are overcome in an illustrative embodiment of the invention in which a computer manages communication over a network between one or more network addressable units and a plurality of physical devices of a passenger entertainment system on a vehicle. The passenger entertainment system is configured and operated using software to provide passenger entertainment services including audio and video on-demand, information dissemination, product and service order processing, video teleconferencing and data communication services between passengers on-board the vehicle using a local networks, and between passengers and people and computers off-board the vehicle using a communications link.","The passenger entertainment system includes a system server and a network for supporting a plurality of computer processors that are each coupled to a video camera, a microphone, a video display, an audio reproducing device, and an input device located proximal to a plurality of seats. The computer processors and the system server comprise application software that selectively controls telephony applications and network services. The system server has a plurality of interfaces that interface to components (physical devices) of the passenger entertainment system.","In carrying out the present invention, the system server is coupled by way of the network to a plurality of physical devices. The system server comprises software for instantiating a dispatch object to open a framework for one or more network addressable unit objects. The system server comprises software for instantiating one or more virtual line replaceable unit objects to manage communication between a network address unit and one or more physical devices. The system server comprises software for communicating network messages through the dispatch object to the one or more network addressable unit objects to the one or more physical devices to control one or more aspects of the passenger entertainment system.","The dispatch object contains logic that tracks messages to the one or more physical devices utilizing a queue, logic that tracks messages from the one or more physical devices utilizing a queue, and logic that converts messages from a first format to a second format. The dispatch object maintains the status of related devices. The dispatch object also contains logic for adding and removing one or more of the network addressable unit objects. The network addressable unit objects include logic for moving data from one storage location to another.","System Overview",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 1","FIG. 1"],"b":["100","111","100","100","100","111","117","111","113"]},"The system  is comprised of four main functional areas including head end equipment , area distribution equipment , seat group equipment , and overhead equipment . The head end equipment  provides an interface to external hardware and operators. The area distribution equipment  routes signals to and\/or from the head end equipment , the seat group equipment , and the overhead equipment , depending upon the type of service provided to or requested by the passengers. The seat group equipment  contains passenger control units (PCU)  and screen displays  for use by the passengers . The overhead equipment  includes video monitors and\/or projectors and bulkhead screens or displays for displaying movies and other information. The system  thus routes or otherwise displays information to the passengers either under control of the flight attendants or passengers .","Video conferencing data and computer data derived from ground based computers  connected to the Internet  are transferred over the Internet  to a satellite ground station  and are uplinked to a communications satellite  orbiting the Earth. The communications satellite  downlinks the video conferencing and\/or computer data to the aircraft  which is received by way of an antenna  that is part of a satellite communications system employed in the head end equipment  of the system . In a similar manner, video conferencing data and\/or computer data derived from passengers  on-board the aircraft  is uplinked to the satellite  by way of the satellite communications system and antenna  to the satellite , and from there is downlinked by way of the satellite ground station  and Internet  to the ground based computer .","One or more satellites , which may be the same as or different from the satellites  used for Internet communication, transmit television signals to the aircraft . One currently deployed satellite television broadcast system is the DIRECTV system that has orbiting satellites  that may be used to transmit television programs to the aircraft , in a manner similar to ground-based systems used in homes and businesses. In the present system , however, a steerable antenna  is used to track the position of the satellite  that transmits the signals so that the antenna  remains locked onto the transmitted signal.","Handheld or fixed passenger control units  and seatback screen displays  (seat displays ) are provided at each passenger seat  that permit the passengers  to interface to the system . The passenger control units  are used to control downloading of movies for viewing, select audio channels for listening, initiate service calls to flight attendants, order products and services, and control lighting. The passenger control units  are also used to control game programs that are downloaded and played at the passenger seat . In addition, the passenger control units  are also used to initiate video conferencing and computer data transfer sessions either within the aircraft or with ground based computers .","The present system  thus provides for an integrated and networked passenger entertainment and communication system  that in essence functions as an airborne intranet that provides a level of passenger selected and controlled entertainment and communications services, passenger services and product ordering services that has heretofore not been provided to aircraft passengers.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 2","FIG. 3","FIG. 4"],"b":["100","111","100","100","200","210","220","230","200","220","111","111","100","100"]},"An embodiment of the system  is practiced in the context of a personal computer such as the IBM PS\/2, APPLE MACINTOSH computer or UNIX based workstation. A representative hardware environment is depicted in , which illustrates a typical hardware configuration of a workstation in accordance with a preferred embodiment having a central processing unit , such as a microprocessor, and a number of other units interconnected via a system bus . The workstation shown in  includes a random access memory (RAM) , read only memory (ROM) , an I\/O adapter  for connecting peripheral devices such as disk storage units  to the bus , a user interface adapter  for connecting a keyboard , a mouse , a speaker , a microphone , and\/or other user interface devices such as a touch screen (not shown) to the bus , communication adapter  for connecting the workstation to a communication network (e.g., a data processing network) and a display adapter  for connecting the bus  to a display device . The workstation typically has resident thereon an operating system such as the MICROSOFT WINDOWS NT or WINDOWS\/95 operating system (OS), the IBM OS\/2 operating system, the MAC OS, or UNIX operating system. Those skilled in the art will appreciate that the present invention may also be implemented on platforms and operating systems other than those mentioned.","The in-flight entertainment system  in accordance with a preferred embodiment is a complex system with many components and that forms a total entertainment system (TES) . To assist the reader in making and utilizing the invention without undue experimentation, the following is a detailed description that discusses some of the components and a typical system configuration. The system  in accordance with a preferred embodiment is a configurable and scaleable in-flight entertainment system  that provides a wide range of passenger entertainment, communications, passenger service, and cabin management services. A fully capable system  provides passengers with audio entertainment, video entertainment, video games, and other interactive and communications services.","The system  shown in  has four main functional areas comprising: 1) head end equipment , 2) area distribution equipment , 3) seat group equipment , and 4) overhead equipment .  shows the four functional areas and the line replaceable units (LRU) that comprise a typical passenger entertainment system . An overview of the LRUs in each of the functional areas is described in the following paragraphs.","The head end equipment  is the prime interface between external hardware and operators (purser and flight attendants). The head end equipment  includes an operator interface, an aircraft interface, a maintenance interface, and an interface for downloading configuration data to the system  and for downloading reports from the system.","The head end equipment  shown in  comprises a primary access terminal (PAT)  and a cabin file server (CFS)  that are used to control the system . The cabin file server  is a system controller that controls many of the system functions, such as interactive functions, and stores the system configuration database and the application software. The cabin file server  communicates with other components within the head end equipment  via an ARCNET interface . The cabin file server may be a computer terminal as shown in  that includes a hard disk drive and a database that stores the system  configuration and other system  information.","The cabin file server  is coupled to the primary access terminal  and to a printer  by way of an Ethernet network , such as a 100 Base-T Ethernet network, for example. Flight attendant workstations are also coupled to the cabin file server  by way of the Ethernet network . A media file server  is controlled from the cabin file server  by way of an ARINC  (RS-485) network  coupled therebetween. The cabin file server  is optionally coupled to a BIT\/BITE tester  that is used to perform built in testing operations on the system .","The cabin file server  provides the following functions: processes and stores transaction information from passengers; stores passenger usage statistics for movies, games, and shopping; stores passenger survey responses; stores flight attendant usage statistics for login\/logout; provides flight attendant access control; controls the video reproducers; controls the landscape camera; controls the PVIS line replaceable unit; stores seat application software and game software; distributes seat application and game software via the RF distribution system; provides power backup sufficient to allow orderly automatic shutdown of the cabin file server  operating system when primary power is removed; provides indicators representing power, operational status, and communication status; downloads databases via the RF distribution system; provides the ability to print reports; and provides connectors for a keyboard, monitor, and mouse.","The primary access terminal  shown in  provides an operator interface to the system , enabling an operator to centrally control a video reproducer  and the media server , start BITE, control the landscape cameras , and other functions provided in the system . The primary access terminal  may also be a computer terminal as shown in  that may include a hard disk drive and a display  for graphical user interface (GUI) by a flight attendant to the system . The display may be a touch screen display to access the system . A keyboard (not shown) may also be provided to access the system . The primary access terminal  is used to configure the system  to set up the entertainment options that are available to passengers . The flight attendant workstations are distributed throughout the aircraft  and allow flight attendants to respond to passenger service requests and to process orders and monetary transactions.","The primary access terminal  provides the following functions: a flight attendant interface to the cabin sales capability, a flight attendant interface to the video entertainment capability, a flight attendant interface to the report and receipt printing capability, monitoring of video and audio output from the video reproducer, maintenance personnel interface to system diagnostics and status reports, power backup sufficient to allow an orderly shutdown of the primary access terminal operating system when primary power is removed, indicators representing power, operational status, and communication status, single and dual plug stereo audio jack, magnetic card reader, and floppy disk drive.","The head end equipment  comprises the media server  that is coupled to a first video modulator . The media server  may be one manufactured by Formation, for example. The media server  supplies  independent streams of video, and stores about 54 hour of video. The first video modulator may be one manufactured by Olsen Technologies, for example. The video reproducer  (or video cassette player ), such as a triple deck player manufactured by TEAC, for example, is also coupled to the first video modulator . The video cassette player  may be three 8-mm Hi-8 video cassette players that output three video programs on three video channels under control of a flight attendant.","The video reproducer  (or video cassette player ) outputs an NTSC video (and audio) streams corresponding to a first plurality of prerecorded video channels. The media server  stores and outputs a plurality of quadrature amplitude modulated MPEG-compressed video transport streams corresponding to a second plurality of prerecorded video channels. The first video modulator modulates both the NTSC video streams from the video reproducer  and the quadrature amplitude modulated MPEG-compressed video streams from the media server  to produce modulated RF signals that are distributed to passenger seats  of the aircraft .","The head end equipment  also comprises one or more landscape cameras  and a passenger video information system (PVIS)  that are coupled to a second video modulator . The landscape cameras  may be cameras manufactured by Sexton, or Puritan Bennett, for example. The second video modulator may also be one manufactured by Olsen Technologies, for example. The passenger video information system  may be a unit manufactured by AIRSHOW, for example.","The head end equipment  comprises first and second passenger entertainment system controllers (PESC-A, PESC-V) , , that comprise video, audio and telephone processors. Although only one unit is shown in , in certain configurations, primary and secondary PESC-A controllers may be used. The second video modulator routes RF signals through the first video modulator , and the outputs of both video modulators , are routed through the second passenger entertainment system controller (PESC-V) to the first passenger entertainment system controller (PESC-A) . The first passenger entertainment system controller (PESC-A) is used to distribute video and data by way of an RF cable  and an ARCNET network , to area distribution equipment  that routes the video and data to the passenger seats . The ARCNET network  is used to send control signals between components of the head end equipment and the components of the seat group equipment . The PESC-A also provides an interface to the overhead equipment .","The first passenger entertainment system controller (PESC-A) is coupled to the cabin file server  by way of the ARCNET network , and is coupled to the primary access terminal (PAT)  and the second passenger entertainment system controller (PESC-V) by way of the ARCNET network . The first passenger entertainment system controller (PESC-A) is also coupled to a public address (PA) system , to an audio tape reproducer (ATR) , and to a cabin telephone system (CTS) . The audio tape reproducer  may be one manufactured by Sony or Matsushita, for example. The cabin telephone system  may be systems manufactured by AT&T or GTE, for example. Signals associated with the cabin telephone system  are routed through the system  by means of a CEPT-E1 network .","The passenger entertainment system audio controller (PESC-A) and the passenger entertainment system video controller (PESC-V) are similarly designed and have similar capabilities. However, some features are implemented only in the PESC-A or only in the PESC-V . The passenger entertainment system controller software implements specific features particular to the PESC-A or PESC-V ","The passenger entertainment system controller performs the following functions: digitizes up to 32 audio inputs from entertainment and video audio sources, RF modulates the digital data, mixes the RF digital audio data with the RF input from a VMOD or another passenger entertainment system controller, outputs the combined RF video carrier and RF digital audio information to the RF distribution system, inputs up to five analog inputs, and multiplex in any combination to a maximum of five analog outputs, provides programmable volume control of the five analog outputs, provides RS-232, RS-485, ARINC-429, and ARCNET communications interfaces, provides input discretes for the control and distribution of PA audio to the seats, provides input and output discretes for the control and distribution of video announcement audio to the overhead PA system of the aircraft , provides input discretes for passenger entertainment system controller type and address information, provides input discrete for aircraft status (in air\/on ground), amplifies output RF, software monitorable and controllable, provides an external test\/diagnostic communication port, provides indicators representing power, operation status, and communication status, provides telephone control and distribution (PESC-A only), and provides a fault depository for BIT data (PESC-A primary only).","Referring now to , it shows a simplified diagram of the system  and illustrates distribution of video signals from the video cassette player  and media server  to the seat displays . To implement video on demand in accordance with a preferred embodiment, the media server  outputs  digital MPEG-compressed video transport streams on three video channels (ten streams each), while the video cassette player  outputs three video streams on three video channels.","To gain extra throughput, the 30 digital MPEG compressed video streams output by the media server  are 64-value quadrature amplitude modulated (QAM). However, it is to be understood, however, that by using 256-value QAM encoding, for example, the number of video programs delivered in each video channel may be further increased. Consequently, the present system  is not limited to any specific QAM encoding value.","The video streams from the video cassette player  and the quadrature amplitude modulated MPEG compressed video transport streams from the media server  are then modulated by the first video modulator for transmission over the RF cable  to an audio-video distribution unit  at each of the passenger seats . To provide first class passengers , for example, with true video on demand, the streams are controlled by the passengers , with one stream assigned to each passenger that requests video services.","The simultaneous transfer of video streams derived from both the video cassette player  and the media server  in an aircraft entertainment system is considered unique. In particular, conventional systems either process analog (NTSC) video signals or digital video signals, but do not process both simultaneously. However, in the present system , NTSC and quadrature amplitude modulated MPEG-compressed digital video signals are processed simultaneously through the first video modulator and distributed to passenger seats  for display.","The first passenger entertainment system controller (PESC-A) is coupled to a plurality of area distribution boxes  by way of the RF cable  and the ARCNET network . The area distribution boxes  are used to distribute digital and analog video streams to the audio-video distribution units  at the passenger seats .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 5","i":["a ","a ","a "],"b":["224","231","123","111","224","351","223","222","275","352","353","355","354","354","355"]},"The output of the multiplexer  is input to a first-in first-out (FIFO) buffer  and output signals therefrom are quadrature amplitude modulated using a quadrature amplitude modulator (QAM) . The format of the output signals from the FIFO buffer  is shown and includes a start frame set of bits (header) followed by each of the respective audio channels (CH  . . . CHn). The output of the quadrature amplitude modulator  is modulated onto a carrier by an RF modulator  that transmits the QAM and RF modulated signal over the RF cable  to the audio-video units  at each of the passenger seats .","The audio-video units  each comprise a RF tuner  that demodulates the RF modulated signal transmitted over the RF cable  that is coupled to a QAM demodulator  that demodulates the quadrature amplitude modulated signals. The output of the QAM demodulator  is converted to an analog signal by a digital to analog converter (D\/A)  and sent to the headphones . Selection of a particular channel to be listened to by a passenger  is made using the tuner  that demodulates the signal associated with the selected channel.","The improved quadrature amplitude modulated (QAM) digital audio distribution provided by this aspect of the present invention provides for a greater number of audio channels to be communicated over the RF cable . This is similar to the quadrature amplitude modulation of the video streams discussed above with reference to . The quadrature amplitude modulation provides for a plurality of states (not compression) that increases the usage of the bandwidth of the RF cable . Any type of analog input signal may be processed, including signals from the audio tape reproducers , passenger address system , passenger service system  or other analog audio source.","The area distribution equipment  distributes information from the head end equipment  to the seat group equipment . The area distribution equipment  also provides power to the seat group equipment .  is a block diagram showing the area distribution equipment  in accordance with a preferred embodiment.","The area distribution equipment  distributes data throughout the communications network formed between the head end equipment  and the seat group equipment . The area distribution equipment  comprises the plurality of area distribution boxes  that are each coupled to a plurality of floor junction boxes  that are individually coupled to respective audio-video seat distribution units  in the seat group equipment  of respective columns of passenger seats .","In a basic system, the area distribution box (ADB)  provides for interfacing the first passenger entertainment system controller (PESC-A) to audio-video units  either directly or via floor unction boxes . The area distribution boxes  interface to the audio-video seat distribution units  by way of the junction boxes  using full-duplex RS-485 interfaces  and RF cables . The RS-485 interfaces  provide control and data links between the seat group equipment  and the head end equipment . The RF cables  couple audio and video data to headphones  and seat displays  for listening and viewing by the passengers . The area distribution box  acts as a connection box to facilitate the distribution of system power, combined audio\/video signals and service data for up to five columns of audio-video units , and relay of service data and combined audio\/video signals to the next area distribution box . The area distribution box  has an RS-232 serial diagnostic port to allow verification of functionality.","The area distribution box  removes power from a seat column in which either a short circuit or ground fault condition is identified. The area distribution box  restores power to a seat column from which power had been removed without requiring physical access to the area distribution box . When power is reapplied to such a column, the short circuit protection circuit functions normally and removes power from the column if the short circuit condition persists. An area distribution box  processor monitors the status of the AC power output to each individual AVU column for BIT\/BITE purposes.","The area distribution box  provides the means to adjust the RF level in order to ensure that the proper RF levels for the video and modulated audio signals are supplied to the AVU tuners and demodulators in the presence of changing system configurations and operational conditions. This RF leveling is accomplished by the local processor\/s in the area distribution box  by controlling a variable attenuator.","The area distribution box  provides for interfacing voice data, originating at passenger telephones , to the first passenger entertainment system controller . The telephone interface provides for input data from each AVU column to be combined with input data from another area distribution box  and retransmitted to the first passenger entertainment system controller or the next area distribution box .",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 7","b":["220","220","117","100","111"]},"The seat group equipment  includes a passenger control unit , a seat display , headphones , interface for a personal video player  (in certain zones), an audio-video unit  with a plurality of seat controller cards (SCC)  one for each seat  in a row to interface with the area distribution equipment , a video camera  and a microphone  for use in video conferencing, and a telephone card  that interfaces to the passenger control unit  when it includes the telephone and\/or credit card reader . One audio-video unit  is provided for each seat  and controls distribution of video, audio and data to the headset or headphones , the seat display , and the passenger control unit .","Referring to , in certain zones of the aircraft , a personal computer interface is provided which allows the passenger  to power a personal computer (not shown) and to interface to the system  through the audio-video unit . Alternatively, a keyboard may be provided that allows the passenger  to interface to the system . The use of the personal computer or keyboard provides a means for uploading and downloading data by way of the satellite communications system  and the Internet.","The major functional requirements of the audio-video unit  are that it drives one to three seat display units  with or without touch screens, provides touch screen and display controls, provides two audio jacks per seat, provides two passenger control unit interfaces per seat , interfaces to a parallel telephone system, provides discrete signal interface, a parallel laptop power supply system, demodulates and tunes NTSC and QAM from the RF signal, provides PC type video games, provides an RS-485 interface for ADB-AVU or AVU\u2014AVU communications, provides an interface for personal video players, and provides a PSS interface to an external parallel passenger service system (PSS), provides hardware and software interfaces that provide for video teleconferencing and Internet communications.","Referring to , one seat controller card- is dedicated to a passenger seat. Therefore, three seat controller cards  are required for a three-wide audio-video unit. Two seat controller cards  are required for a two-wide audio-video unit . A power supply module (PSM)  supplies power for the three seat controller cards , an audio card , the displays , and PCUs . The audio card  electrical circuits comprise RF demodulators to supply audio outputs. An interconnect card (not shown) connects the three seat controller cards , the audio card , the power supply module , and external connectors within the AVU .","The seat controller card (SCC)  provides many functions for a single passenger . Some of the functions that the seat controller card  provides include analog video and audio demodulation, graphics overlay capability, and Motion Picture Experts Group (MPEG) video and audio decompression. The seat controller card  provides the ability to demodulate the existing analog video signals as well as MPEG encoded signals delivered by the media server  that comprises a video-on-demand (VOD) server.","The seat controller cards  in in each audio-video seat distribution unit  contain a tuner  that downconverts the modulated RF signals to produce intermediate frequency signals containing the NTSC video streams and the quadrature amplitude modulated (QAM) MPEG compressed video streams. A QAM demodulator  and an MPEG decoder  are used to demodulate and decompress the quadrature amplitude modulated and compressed MPEG compressed video streams to produce MPEG NTSC video and audio signals for display.","An analog (video) demodulator  demodulates the NTSC video signals that are then passed to a video multiplexer where an external NTSC video signal may be added. The NTSC signals are then digitized in a video A\/D converter and are passed to the MPEG decoder . The format of the digital channels after QAM demodulation is MPEG-2 transport streams. The MPEG-2 transport streams may contain many streams of video, audio and data information. The MPEG decoder  (demultiplexer) may also receive data information to be sent to the SCC processor group . In the MPEG transport group, the capability exists to add text overlay with the digital video data. The digital data is converted to analog NTSC format using an NTSC encoder for the display .","Each of the seat controller cards  includes a microprocessor (mP)  that controls the tuner. The microprocessor  is used to address the seat controller card  as a node on the network. A database is set up in the cabin file server  that includes entries for each of the microprocessors (i.e., each seat ). The addressability feature permits programming of each seat to receive certain types of data. Thus, each audio-video unit  may be programmed to selectively receive certain videos or groups of video selections, or audio selections from selected audio reproducers. The addressability aspect of the present system  allows the airline to put together entertainment \u201cpackages\u201d for distribution to different zones or groups of seats. Also, each seat (or seats in different zones) may be programmed to be able to play games, use the telephones and credit card reader , use a personal video player or computer, have the ability to engage in video teleconferencing and computer data interchange, or gain access to the Internet. Furthermore, the addressability associated with each seat permits order processing and tracking, and control over menus that are available to passengers at respective seats, for example. The addressability feature also permits dynamic reconfiguration of the total entertainment system .","To provide control from passenger seats , the microprocessor  in the audio-video unit  includes software that performs substantially the same functions as those in the primary access terminal . This may be achieved by selectively downloading a software module to the microprocessor  in the audio-video unit  when the passenger  requests this service. The downloaded software module operates in the same manner as the software on the primary access terminal . However, the RS-485 interface is used to send commands to the cabin file server  that control the ARINC-485 driver. Alternatively, and preferably, use of an Ethernet network  to interconnect the audio-video units  provides a readily implemented control path directly to the primary access terminal  and cabin file server , since they are normally connected by way of the Ethernet network .","The audio-card  in  provides several functions. It demodulates the RF signal to provide audio. It has a multiplexer with audio inputs from the seat controller card , demodulated RF signal audio, and external audio. It routes the 115 VAC power to the power supply module and routes the DC power from the power supply module  to the interconnect card.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 7","i":"b ","b":["121","121","100","231","381","382","121","231"]},"The passenger control unit  may be either side mounted or top mounted onto a seat  arm rest. The passenger control unit  has a four character alphanumeric display . Brightness of the LED display  is controllable, as a minimum, to two levels of brightness. The passenger control unit display  is controlled by the audio-video unit  to inform the passenger of current mode status and video functions.","The passenger control unit  also comprises depressible buttons that permit selection of items displayed on the seat display  and turn on call lights and overhead lights, and electronics. In designated sections or seats, the passengers also control selection of movies and games that are to be played, control the landscape cameras, and activate video conferencing and data communications. In selected sections (business and first class) of the aircraft , the telephone and credit card reader are integrated into the passenger control unit , while in other sections (such as coach class) these components are not provided.","A reading light on\/off function key turns on\/off an overhead reading light. Call light on and call cancel function keys , permit calling a flight attendant. A volume control (increase\/decrease volume) key  is provided. A select function key  allows the passenger to make a selection. Screen navigation function keys  provide a means for a passenger  to navigate through menus displayed on the display  or seat display unit (SDU) . A channel up\/down function key  provides for channel control (increase\/decrease channel selection). A TV\/OFF function key  turns the seat display unit backlight on. Pressing a mode function key  allows the passenger to have picture adjustment control of the seat video display through menus displayed on the seat display unit ","The passenger control unit  interfaces to the credit card reader . The credit card reader reads three magnetically encoded tracks from credit cards that are encoded in accordance with ISO standards  and . Data content is read in accordance with the VisaNet Standards Manual and contain at least: major industry identifier, issuer identifier, primary account number, surname, first name, middle initial, expiration date, service code, and PIN verification data.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 8","b":["230","230","261","263","262","230","200","230","261","261","235","263","262","230","264","224","218","224","261","268"],"i":["a","a "]},"In order to efficiently implement video teleconferencing, the use of a higher speed, larger bandwidth communication network may be provided to permit many simultaneous uses. This is achieved using a high speed network, such as the 100 Base-T Ethernet network  that is currently employed in the head end equipment . Interconnection of each of the audio-video seat distribution units  by way of a 100 Base-T Ethernet network  in addition to, or which replaces the lower bandwidth RS-485 network , provides substantial bandwidth to implement video teleconferencing.","Interconnection of the audio-video seat distribution units  using the 100 Base-T Ethernet network  also permits data communications between personal computers located at the seats  and remote computers . This is achieved by interfacing the 100 Base-T Ethernet network  to the satellite communications system . Inter-computer telecommunications may be readily achieved using a Web browser running on portable computers connected to the audio-video seat distribution units , or by integrating a Web browser into the audio-video seat distribution units . This is readily achieved by running the Web browser on the microprocessor  used in each audio-video seat distribution unit . Messages may be drafted using a keyboard connected to the audio-video seat distribution units . Touchscreen seat displays  may be also readily programmed to initiate actions necessary to initiate videoconferencing, initiate communications, transfer messages, and other required actions.","Certain line replaceable unit types require the assignment of a unique address within the system . This is referred to as line replaceable unit addressing. Line replaceable units that require unique addresses are the PESC-A primary\/secondary , PESC-V , video reproducers , area distribution box , tapping unit , and primary access terminal . Each of these line replaceable unit types is assigned a unique address during system installation.","Referring again to , it depicts the architecture of the system , and its operation will now be described with reference to this figure. The architecture of the system  is centered on RF signal distribution of video, audio, and data from the head end equipment  to the seat group equipment . Video and audio information is modulated onto an RF carrier in the head end equipment  via the video modulator and passenger entertainment system controllers , respectively prior to distribution throughout the aircraft . Referring again to , it shows a functional block diagram of the signal flow to and from the head end equipment .","The source of video may be from video cassette players , landscape cameras , and the TV video output by the media server , or the passenger video information system . The source of audio information may be from audio reproducers , audio from video cassette players , or audio from the passenger address system .","The system  uses the RF network  to distribute all audio and video programming from the head end equipment  to the seats . The RF network  is also used to support downloading of video games and other applications to the seats .","The RF network  operates over a nominal frequency range from 44 to 550 MHz. The system  provides up to 48 6-MHz wide channels for distribution of video information. One of these channels may be used for the distribution of video games and other application software to the seats . The video channels are allocated to a bandwidth from 61.25 through 242.6 MHz (nominal). The frequency range from 108 to 137 MHz (nominal) remains unused.","The frequency range from 300 to 550 MHz is used for distribution of audio information to the seats . One embodiment of the system  uses pulse code modulation to transmit the audio data over the allocated frequency range. This supports a maximum of  mono audio channels ( entertainment and five PA). The allocation of these channels to audio reproducers  (entertainment audio), video reproducers  (movie audio tracks) and to passenger address lines (PA audio) is database configurable and may be defined by the user. It is also possible to read and set RF levels for the passenger entertainment system controllers , and area distribution box  by means of an off-line maintenance program.","The system  uses the ARCNET network  as the major data communications path between major components. The ARCNET network  interconnects the following components: cabin file server , primary access terminal , PESC-A (primary) , PESC-A (secondary) , PESC-V , and all the area distribution boxes .","The ARCNET network  is implemented as two physical networks, with the primary PESC-A serving as a bridge\/router between the two. Any device on ARCNET   is addressable by any device on ARCNET   and vice versa. In addition to the primary PESC-A , ARCNET   connects the following components: cabin file server , and a maximum of eight area distribution boxes . In addition to the primary PESC-A , ARCNET  connects the following components: a maximum of one PESC-V , primary access terminal , and the secondary PESC-A . Both ARCNET subnetworks (ARCNET , ARCNET )  operate at a data transmission speed of 1.25 Mbps.","System Operation","A preferred embodiment of the in-flight entertainment system  operates in three possible states. These states include 1) a configuration state, 2) a ground maintenance state, and 3) an entertainment state. In the configuration state, aircraft-installation\u2014unique parameters are initialized and modified. The configuration state is initiated by an operator. The configuration state is entered and exited without the use of additional or modified system hardware. In the ground maintenance state, the system  performs self-diagnostics to determine system failures. The ground maintenance state is initiated by an operator. The ground maintenance state is entered and exited without the use of additional or modified system hardware. The entertainment state is the primary state of the system  and is initiated by the operator. The system  provides several entertainment modes as defined below. The system  is modular in design so any one or all modes may exist simultaneously depending on the configuration of the system . The system  is configurable so that each zone (first class, business class, coach class, for example) of the aircraft  can operate in a different entertainment mode. In the entertainment state, the passenger address functions and passenger service functions are independent of the mode of operation.","The entertainment modes include an overhead video mode, a distributed video mode, and an interactive video mode. In the overhead video mode, video is displayed in the aircraft  on the overhead monitors . Different video entertainment is possible for different sections of the aircraft. In the distributed video mode, multiple video programs are distributed to the individual passengers of the aircraft at their seat. The passenger selects the video program to view. The quantity of programs available depends upon system configuration. In the interactive video mode, the system  provides a selection of features in a graphical user interface (GUI) presentation to the passenger. Depending on the system configuration, the features may include language selection, audio selection, movie selection, video game selection, surveys, and display settings.","The system  provides audio programming to the passengers. When in the interactive audio mode of operation, the system  displays a list of audio programs available to the passenger on the seat display . This list is configurable via an off-line database. The system  may be configured to allow selection of an audio program using either the seat display  or controls on the passenger control unit  depending on the system  requirements. The selected audio program is routed to the corresponding passenger headphone .","The system  provides video programming to all passengers . When in the interactive video mode of operation, the system  displays a list of video programs available to the passenger on the screen of the seat display unit . This list is specified via an off-line database. The system  may be configured to allow selection of a video program using either the seat display  or controls on the passenger control unit  depending on the system requirements. The selected video program is routed to the corresponding seat display unit .","When in the interactive mode of operation, the system  provides video games to the passengers . The system  displays a list of up to 10 video games available to the passenger on the seat display . This list is specified via an off-line database. The system  may be configured to allow selection of a video game using either the seat display unit or controls on the passenger control unit  depending on the system requirements. The selected video game is downloaded to the corresponding passenger seat  for viewing on the seat display .","The system  supports entertainment packaging. An entertainment package is a predetermined set of one or more movie titles and\/or game titles with a predetermined amount of game play time. The content of each entertainment package is specified via an off-line database. The system  requires payment for entertainment packages according to a unit price and a price policy. The system  displays a list of available packages on the screen the seat display unit . Each package in this list must have an associated date range that specifies when the package is available. Up to four packages per date range are specified via an off-line database. The displayed list only contains those packages where the date of the current flight falls within the date range specified for that particular package.","As is shown in , for example, if configured with a personal video player  that interfaces to the audio-video unit  by way of a personal video player interface , the system  controls the personal video player  via controls at the seat display . The system  provides commands to the personal video player  to play, rewind, fast forward, pause, stop and eject a tape.","The system  provides the ability to place telephone calls from each passenger seat . In certain configurations, the telephone handset is integrated into the passenger control unit . The handset includes a telephone button pad, a microphone, and a speaker. The system  prompts for payment when using the telephone service. Payment must be made via a credit card. The system  provides the capability to enter the phone number via controls on the passenger control unit . The system  also displays phone call status on the screen of the seat display .","The system  provides the ability for passengers  to select items from an electronic catalog displayed on the screen of the seat display . The catalog may be divided into categories. The system  provides the capability to configure the categories and the items via an off-line database tool.","The system  provides the capability to display on the screen of the seat display  a running tabulation of all expenses, excluding telephone charges, incurred at a seat during the current flight.","The system  is configured to allow the flight attendants to display flight information at the primary access terminal  from the off-line database or retrieved from other equipment on-board the aircraft . If this information is not available, the system  is configured to allow information to be entered manually at the operator console as detailed below. Flight information may include the following: aircraft registration number, flight number, departure airport, arrival airport, flight duration, and route type.","System Software","The system  employs a software architecture that integrates processing performed by each of the subsystems. The software and firmware comprising the software architecture controls the system, manages the flow of analog and digital audio and video data to passenger consoles and displays, manages the flow of communications data, and manages service and order processing. Various subsystems also have their own software architectures that are integrated into the overall system software architecture.","The system software is designed in a layered fashion, and an application programming interface (API) layer is defined and documented for the primary access terminal  and seat display . These application programming interfaces are used as the foundation upon which to implement the graphical user interfaces (GUIs). The GUIs are thus implemented in a manner that facilitates rapid prototyping and GUI modification within the constraints of the services provided by the application programming interfaces. The system  has a flight attendant GUI at the primary access terminal  and passenger GUIs at the seat  (seat display unit ). Each of these GUIs have the following properties: graphic orientation, clear and directly selectable functions (no \u201chidden\u201d functions), consistency in screen layout and flow (look and feel), and \u201clexical\u201d feedback (i.e., visible change on the display) for every user action.","Many of the line replaceable units in the system  are software loadable in that the contents of the line replaceable unit's memory can be overwritten from a source external to the line replaceable unit. The system  provides a facility for loading software into all line replaceable units. The software loading facility ensures that any attempt to load software into a line replaceable unit is appropriate for that type of line replaceable unit. The software loading function indicates when a line replaceable unit can and can not be loaded, the status of software load attempts as either successful or unsuccessful, and an estimate of the time required to load the software into the line replaceable unit. The software load facility employs a high speed download link to the line replaceable units, when appropriate, in order to minimize the time required to load software into a line replaceable unit. The software loading facility precludes load attempts when the aircraft  is in flight.","Software and firmware employed in the present invention permits credit card processing, data collection processing, Internet processing for each passenger, gambling for each passenger, duty free ordering, intra-cabin audio communication between passengers, and display of flight information. The system software includes parallel telephone system software, landscape camera management software, PESC system software, passenger address override software, passenger address emergency software, monetary transaction processing software, language support software, built-in-test software, user request processing software, database management software using a distributed configuration database, software for implementing interactive access, software for processing passenger orders, software for updating inventories, application software, media file encryption software, area distribution box software, audio-video unit programming software, telephone operation software, gatelink node and software, product service pricing software, passenger survey software, transaction reporting software, automatic seat availability reporting software, and video conferencing and data communications software.","Object oriented programming (OOP) is employed in the software and firmware used in the system . A preferred embodiment of the software used in the system  is written using JAVA, C, or the C++ language and utilizes object oriented programming methodology. Object oriented programming (OOP) has become increasingly used to develop complex applications. As OOP moves toward the mainstream of software design and development, various software solutions require adaptation to make use of the benefits of OOP. A need exists for these principles of OOP to be applied to a passenger entertainment system such that a set of OOP classes and objects for the messaging interface can be provided.","The system  is constructed in a modular framework, and is designed to expand to support various aircraft  configurations. System configuration information is defined in an off-line configurable database. System configuration support tools provide the capability to generate database information, which is downloaded to the appropriate system line replaceable units. The line replaceable units store database information in non-volatile memory, and revert to default database information when they detect newly downloaded data inconsistent with the physical aircraft configuration, or when a database download is unsuccessful.","Aircraft configuration data requires modification only when the aircraft configuration changes, or when the line replaceable unit in which it resides has been replaced or corrupted. Aircraft configuration data at a minimum includes the following fields: Aircraft type, ACS database configuration ID, Overhead system type, Seat configuration, tapping unit and Overhead monitor assignments, Reading\/Call light assignment, Master call lamps\/attendant chimes data, RF level gain values, Internal ARCNET termination, PA\/VA headphone, APAX-140-to-TES interface assignments, PESC audio channel assignments, VMOD video channel assignments, ADB phone capability, ADB discretes, PA zone, display controller, configuration of passenger entertainment system controllers , interactive\/distributed video only (DVO), PAT\/CFS options, and movie preview.","The entertainment system data define specific parameters for the available system features. It is necessary to reload the database whenever it is determined the associated features are to be changed. Entertainment system data, at a minimum, includes the following fields: Entertainment system data configuration ID, Video games, Movies, Pay\/Free entertainment per zone, Passenger surveys per zone, General service\/Duty free zones, seat display unit entertainment titles per route type, Currency exchange rates, primary access terminal display currency, Airline name, flight number, arrival\/departure city, flight duration, and route type, Movie cycle attributes, Video announcements, video reproducer entertainment assignments, Product data, Credit card data, and Entertainment package details.",{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 9","b":["101","225"]},"The ACS tool provides the following user interfaces. In general, the graphical user interface includes a series of screens with buttons and other controls and indicators. Screens, buttons, other controls, and indicators follow the general conventions for WINDOWS screens as described in The Windows Interface Guidelines for Software Design. The GUI provides user access to the ACS tool's functions via keyboard and mouse inputs.","The ACS tool provides the functionality to maintain multiple configurations for all the aircraft types the TES 100 and APAX-150 systems support. The ACS tool is a single executable, regardless of aircraft type. This single executable utilizes a configuration file for pre-initialization of aircraft configuration data (.CFG). It also utilizes a WINDOWS.INI file for ACS tool-specific parameter definition.","The ACS tool generates configuration data files that can be distributed to the TES line replaceable units. The applicable data files may be downloaded upon operator request via the MAINT Utility.","The ACS tool provides the ability to create and change an aircraft configuration by the use of menus, list boxes, data entry screens, utilities, error messages and help functions. An aircraft configuration defines what TES devices are installed on the aircraft, where those devices are located and what functions those devices perform. The PESC-A-, PESC-V , area distribution box , ADB local area controller (ALAC) (not shown), AVU\/SEB , and overhead electronic box (not shown) line replaceable units, as well as the primary access terminal  and cabin file server , the MAINT and Config\/Status utilities all require knowledge of the aircraft configuration. The database created by the ACS tool that can be downloaded into the PESC-A and contains the configuration data needed by the PESC-A , PESC-V , area distribution boxes , ALACs, AVUs\/SEBs , tapping units , and overhead electronics boxes. The ACS tool has the capability to create separate configuration data files for the primary access terminal  and cabin file server  and the MAINT and Config\/Status Utilities.","The ACS tool also has the capability to create downloadable data files that can be loaded directly into the area distribution boxes . The data files that the ACS tool creates for the primary access terminal  and cabin file server  are able to be imported by the primary access terminal  and cabin file server  into its database. These files provide information about the aircraft  so that interactive services can be provided to the passengers.","The ACS tool creates a downloadable data file (.INT File) that is able to be used by the MAINT and Config\/Status Utilities to determine system-wide LRU status, software configuration, and diagnostic information. These utilities require system configuration definition data.","The ACS tool provides a configuration editor function that allows the user to modify an existing aircraft configuration or generate a new aircraft configuration by entering values into displayed data fields or by selecting values from drop-down menus, if applicable. The configuration editor allows the user to import, or copy, selected aircraft configuration data from one configuration to another. \u201ccut\u201d and \u201cpaste\u201d operations are provided so that similar or identical configuration entries may be copied from one configuration to another. The configuration editor validates the value entered for each data field. The ACS tool generates error messages when the user enters invalid data in dialog boxes. The configuration editor provides the capability to save a configuration to disk. The ACS tool provides the capability to initiate a configuration validation test. If the validation test finds errors with the data, a detailed error report is displayed. The ACS tool allows a configuration that is INVALID to be saved to disk (.CFG), but the ACS tool does not allow a downloadable database to be built from a configuration that is INVALID.","A configuration data builder function of the ACS tool System provides the capability to generate downloadable configuration data files for use with the system  and peripherals. When the user attempts to create the downloadable data files, the ACS tool performs a validation check and tests for limits.","A reports generator function of the ACS tool provides the capability to generate, for a specified configuration, a validation report and a configuration report. A validation report contains information defining the validity of a specified configuration, including appropriate messages for entries in the configuration which are currently invalid. A validation report may be generated upon user request or upon request to generate download files. The configuration report provides a detailed report which describes the current configuration. The configuration report is generated only when a request to generate download files is made and the current configuration is determined to be valid.","A create floppy disk function of the ACS tool provides the capability to generate a disk that contains all files generated by the ACS tool. These downloadable configuration files are loaded to the various line replaceable units in the system. The diskette also contains a setup utility that can be run from the primary access terminal  to reinitialize the database on the cabin file server  with a new configuration.","Each line replaceable unit that uses the database contains electrically erasable programmable read-only memory (EEPROM) which are \u201cdownloaded\u201d with the database. This means that the database which contains information about the airplane configuration can be passed to each controller (i.e., downloaded). These controllers include the PESC-A , PESC-V , area distribution boxes , ALACs, SEBs (AVUs) and overhead electronic boxes.","Many different configurations can be stored for an aircraft . Each contains slightly different options, such as the seating configuration. The ACS tool enables the different configurations, after established, to be recalled season after season by allowing the user to select an existing configuration to edit when a change is made to the aircraft  during re-configuration. The ACS tool allows the user to create a new configuration that can subsequently be saved.","Presented below is software design information for a set of programs common to the cabin file server  and primary access terminal  LRUs of the system . The software forms the fundamental mechanism of moving application information through the system . The following description will be readily understood to those familiar with C++ and the WINDOWS NT development environment. Reference is made to , which illustrates a block diagram of the software architecture in accordance with a preferred embodiment. The architecture facilitates a control center runtime that is implemented in C++ for the primary access terminal  and the cabin file server  of an in-flight entertainment system .","As for the primary access terminal , an uninterruptable power supply  is used to provide power to the primary access terminal  and is in communication with the programs in the software architecture using a serial NT driver . A PI board  provides a communication port for the magnetic card reader and video tuner and interfaces to the serial NT driver . The tuner  in the audio-video unit  also interfaces to the serial NT driver . The video camera  coupled to the audio-video unit  is also coupled to the serial NT driver . The serial NT driver  also interfaces with the PESC-V . An ARCNET driver  interfaces to the ARCNET network .","The serial NT driver  and ARCNET driver  interface to an I\/O handler  to provide selective communications between a message processor  and the various communications devices (, , , and ). The message processor  is responsible for processing messages and putting them into a common format for use by a transaction dispatcher . A pipe processor  is utilized to move common format messages from the message processor  through a primary access terminal network addressing unit (NAU) program  and through another pipe processor  into the transaction dispatcher . The message processor  also interfaces to a system monitor  that is coupled to a watch dog driver  that is used to automatically reset the primary access terminal  if no activity is detected in a given time interval, and a power down module  that performs graceful power down of the primary access terminal . The transaction dispatcher  interfaces with a cabin application programming interface (CAPI) library DLL  by means of a CAPI message service handler .","A touch panel NT driver  interfaces with runtime utilities  and a graphical user interface (GUI)  to provide operator control over the software. The runtime utilities  and graphical user interface  interface to the CAPI library DLL , a Reports DLL  and a video driver DLL and system (SYS) .","The Ethernet network  is used for messaging between the primary access terminal  and the cabin file server . The Ethernet network  interfaces to the primary access terminal network addressing unit , the transaction dispatcher , the CAPI Library DLL , and the Reports DLL .","As for the cabin file server , an uninterruptible power supply  is used to provide power to the cabin file server  and is in communication with the programs in the software architecture using a serial NT driver . The serial NT driver  is also coupled to an auxiliary port  and the video reproducers . An ARINC- NT driver  is coupled to the satellite broadcast receiver  and the satellite communication system . An ARCNET driver  interfaces to the ARCNET network . A high-speed data link (HSDL) NT driver  interfaces to the video modulator ","The serial NT driver , ARCNET driver  and ARINC- NT driver  interface to an I\/O handler  to provide selective communications between a message processor  and the various communications devices (, , , , ). The message processor  is responsible for processing messages and putting them into a common format for use by a transaction dispatcher . A pipe processor  is utilized to move common format messages from the message processor  through various network addressing units \u2013 and through another pipe processor  into the transaction dispatcher . The network addressing units \u2013 include a test port NAU program , a VCP NAU program , a backbone NAU program , an ARINC- NAU program  and a seat NAU program .","The message processor  also interfaces to a system monitor  that is coupled to a watch dog driver  that is used to automatically reset the cabin file server  if no activity is detected in a given time interval, and a power down module  that performs graceful power down of the cabin file server . Each of the network addressing units \u2013 is coupled to the system monitor . The system monitor  is also coupled to the transaction dispatcher . The transaction dispatcher  interfaces with CAPI services  that are called from the CAPI message service handler  in the primary access terminal . The transaction dispatcher  also interfaces to the primary access terminal  by way of the Ethernet network .","Cabin Application Programming Interface (CAPI) calls  are used to communicate information (as shown by arrow ) between various cabin services  and the primary access terminal  via the Ethernet network  and various service interfaces. The separate communication link for the crystal reports DLL  is enabled through object oriented data base calls  to the Standard Query Language (SQL) server . The cabin services  include CAPI calls  with predefined formats for various services. The services include in-flight entertainment (IFE) control , movie cycle ,video services , video announcement , game rental , movie sales , catalog sales , drink sales , duty-free sales , landscape camera , media server , Internet  and teleconferencing . Each of these services are controlled by way of the SQL server  which is coupled to a relational database  and are configured by means of runtime database utilities . The various services \u2013 are routed by way of the pipe processor  to the transaction dispatcher , through the associated NAU program \u2013, the message processor , and the relevant driver , , , , to the appropriate device , , , , , , ","More specifically, the cabin file server  and primary access terminal  software comprises a control center common executive that includes the message processors  and , transaction dispatchers  and , and network addressable unit (NAU) programs , \u2013 that together manage communications flow among line replaceable units and applications, and record or log system irregularities for subsequent analysis. The control center common executive efficiently moves information from source to destination with a minimum of system resources, provides real-time expense or over-handling, provides a means to allow communications to originate at any source, including periodic status messages such as those to the primary access terminal  from the video players , and provides a consistent method of handling existing line replaceable units while allowing for additional line replaceable units. In addition, the common executive stores drivers that are not already part of the operating system. The system monitors  and  are provided to launch all application programs and shut them down as needed.","Each line replaceable unit type that communicates with the control center common executive has a corresponding network addressable unit (NAU) program \u2013. For example, any seat  that must communicate routes to the seat NAU program , any video cassette player  routes to the VCP NAU program , etc. Each time a line replaceable unit communicates with an NAU program \u2013, a virtual LRU is used to maintain cohesion between the application (service) and the device (driver). The virtual LRU is a state machine, one for each physical device associated to this NAU type. For example, if two seats \u201c001A\u201d and \u201c021J\u201d are communicating with the control center common executive, two virtual seat LRUs exist within the seat NAU program . It is within this state machine that the actual conversion between IFE-message and native messages takes place. Status and other information regarding each line replaceable unit are maintained in the VLRU.","In addition to the device-initiated VLRUs, several VLRUs are provided whose function is to maintain the status of related devices. For example, the primary access terminal  must constantly monitor the status of the printer, so a VLRU for the printer is used in primary access terminal NAU program . Similarly, the seats must be kept apprised of changes to the states of the system, so a VLRU for broadcasting this information is created in the seat NAU program .","Primary Access Terminal","The primary access terminal executive extension set of routines that, together with the common executive software, form the generic application for the primary access terminal .","The message processor  is shown in , which illustrates the message processor function and data paths. The message processor  interfaces a plurality of device drivers , including an ARCNET driver and a serial NT driver . The device drivers  are coupled to a plurality of device handlers . The device handlers  include MessageFromDrivers( ) and MessageToDrivers( ) . The MessageToDrivers( ) associated with the serial NT driver is coupled to a ToDriverQueue , and the MessageToDrivers( ) associated with the serial NT driver is coupled to an ArcnetHandler FIFO ","A NAU server  is provided that includes two named pipes (or communication lines) having a plurality of InPipeProcessors( ) and OutPipeProcessors( ) . The InPipeProcessors( ) and OutPipeProcessors( ) are coupled by way of a plurality of pipes to NAU clients . The respective InPipeProcessors( ) are coupled to a corresponding plurality of NAU out FIFO queues .","A plurality of routers  coupled the device handlers  to the NAU server . The plurality of routers  include the AddMessageToPipeProcessor( ) , an AddMessageToOutQueue( ) , and a MessageToHander( ) . The MessageFromDrivers( ) of the device handlers  are coupled to the MessageToPipeProcessor( ) . The InPipeProcessors( ) are coupled to the MessageToHander( ) . The AddMessageToPipeProcessor( )  and the MessageToHander( ) are coupled to the LRU table .","The primary duty of the message processor  is to move communications between various I\/O devices and their appropriate logical devices, the network addressable unit (NAU) . This duty is assigned to the message processor  instead of residing with the NAUs  because there is no one-to-one correspondence between the NAUs  and the device drivers . For example, several devices' communications may arrive via an ARCNET driver (i.e., passenger entertainment system controller , seat , area distribution box , and AVU\/SEB ).","To support this duty, the message processor  includes the following sub-functions. Using an I\/O handler , the message processor  receives messages from the device drivers . Each message, regardless of original format must contain a destination or network address for routing purposes. Using this network address coupled with the device type (i.e., ARCNET, RS-232, etc.) the network address determines the appropriate NAU via a look-up table  and routes the message to that NAU. Since communications from the devices employ a variety of protocols, they are bundled into an IFE-message upon receipt from the physical device, and unbundled after receipt from the application services (via the NAUs). In this way, the message processor  acts as a system translator. Using named pipes and , the message processor  receives messages from the NAUs. The message processor  determines the appropriate device driver  and network address and routes the message to the device. As NAUs demand, the message processor  creates two named pipes (input) and (output) for each NAU, maintaining the table  of pipe names (or handles) and their corresponding NAU IDs. The message processor  logs invalid destination address errors. The message processor  registers with the system monitor  for coordinated system operation.","The detailed design of the Message Processor  will now be discussed. MP.EXE is the Message Processor and comprises the following files:",{"@attributes":{"id":"p-0159","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ARCNTCLS.CPP","The ARCNET interface Class"]},{"entry":[{},"ARCSMCLS.CPP","The ARCNET Simulator Class for testing"]},{"entry":[{},"DVCHNDLR.CPP","The Device Handler Class"]},{"entry":[{},"MSSGPRCS.CPP","The Message Processor Class and Main( )"]},{"entry":[{},"PPPRCSSR.CPP","The Pipe Processor Class"]},{"entry":[{},"SRLCLASS.CPP","The Serial Driver Class"]},{"entry":[{},"WNRTTLCL.CPP","The WinRTUtil Class"]},{"entry":[{},"ARCNTDRV.RT","The ARCNET User-side Driver"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A Main( ) function used in the message processor  initializes its processing threads using StartHandlers( ) and PipeProcessorClass::StartNAUThread( ) functions. These threads operate continuously to move data from source to destination. Main( ) also registers its existence with the system monitor  program (using MessageProcessorClass:Register( )) and waits for a shutdown signal from the system monitor , after which it performs an orderly shutdown of all its threads.","For each device driver , a Device Handler Class member is created. ArcnetClass defines Device Handler routines for the ARCNET driver . The ARCNET driver is a user side driver that performs the actual I\/O with the ARCNET hardware. Because it is loaded along with the rest of the message processor , its interface is via Queue::Put( ) and Queue::Get( ) functions. SerialIOClass defines the Device Handler routines  for a serial device driver . The serial driver is a standard WINDOWS NT Serial Device Driver. ReadFile( ) and WRiteFile( ) are the functions used to communicate with it. All Device Handlers  in the Message Processor  provide the following capability. Two Input-Driven threads are provided to control I\/O. The names vary from handler to handler, but these functions launch the infinitely looping threads that constantly wait for data to move between the device (or queue) and the Message Processor .",{"@attributes":{"id":"p-0162","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Handler","Launch Function Name","Thread Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Serial","SerialInputInterface( )","MessageFromDriver( )"]},{"entry":["Device","SerialOutputInterface( )","MessageToDriver( )"]},{"entry":["ARCNET","MessageToHandlerThreadProc( )","MessageFromDriver( )"]},{"entry":["Device","MessageFromHandlerThreadProc( )","MessageToDriver( )"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"To receive data from the device drivers , MessageFromDriver( ) reads a message from its associated driver or using Get( ) or ReadFile( ) functions. It converts the input to a valid IFE Message using functions from the IFE_Message Class or ARCNET_Message Classes. It then calls MessageProcessorClass::MessageToPipeProcessor( ) to add the message to the NAU Output Queue .","To put data to an Output Queue , PutToHandler( ) puts a valid message at the end of the output queue  of its associated driver. It does not perform any data conversion.","To output queued qata to a device driver , MessageToDriver( ) reads the output FIFO queue  and issues the appropriate driver output command. It does not perform any data conversion.","To start the handler to open communications to I\/O ports, StartHandler( ) performs the necessary initialization to get queues, pointers and driver connections ready. It then starts-up the two I\/O threads (InPipeProcessor( ) and OutPipeProcessor( ) ).","The term NAU Server means the set of routines that comprise a \u201cserver\u201d for the Network Addressable Unit processes. They are kept in the PipeProcessorClass. Two threads, NAUInThread( ) and NAUOutThread( ) are used to launch the set of I\/O threads (InPipeProcessor( ) and OutPipeProcessor( ) ) for an as yet unknown NAU process. The first message received from any NAU registers it to this set of threads, causing NAUInThread( ) and NAUOutThread( ) to launch another set, getting ready for the next NAU to speak. In this way, the Message Processor  is dynamic and can support different numbers of NAUs as needed.","As for incoming messages, NAUInThread( ) launches the InPipeProcessor( ) thread which continuously receives a message from its input pipe . If the message is meant to be routed to a driver , it gets sent to MessageToHandler( ) which places it on the appropriate driver's output queue . If the message is meant to be routed back to an NAU, it is sent instead to AddMessageToOutQueue( ) which performs this routing.","As for outgoing messages, NAUOutThread( ) launches the OutPipeProcessor( ) thread which continuously reads a message from the NAU Out Queue  and sends it to its associated NAU process via its named pipe ","Routers  are routines that use the LRU table  to determine which processing thread needs to process the message. One router  is a From-NAU Router. Upon demand, MessageProcessorClass::MessageToHandler( ) moves the message to the appropriate handler. If necessary, it converts the message to the appropriate \u2018native\u2019 syntax using functions from IFE_Message Class or ARCNET_Message Class. It calls appropriate PutToHandler( ) function to move the converted message to the handler's output queue . Another router  is a From-Device Router. Upon demand, PipeProcessorClass::AddMessageToOutQueue( ) calls the appropriate PutData( ) function to move the message to the NAU's output queue .","The LRU table  is an internal memory structure which contains an entry for each device in the system . It contains sufficient information to translate message addresses from NAU-to-Driver and Driver-to-NAU. Specifically, it contains a physical name, which is the name of each device (e.g., 001A for seat A); NAU Type, which is the NAU that processes message (e.g., 7 corresponds to SeatNAU); Network Address (e.g., 4F040552 for seat A's seat display unit ); and Device Handler that indicates which device driver  to use (e.g., 0 for ARCNET). This information is kept in a SQL database table which is read during the Message Processor Main( ) initialization via CreateLRUTable( ).","As NAU processes register with the Message Processor , their identities are updated in this table via PipeProcessorClass::AddQueueInfoToLookUpTable( ), PipeProcessorClass::AddThreadPointerToLookUpTable( ) and PipeProcessorClass::AddPipeHandleToLookUpTable( ) functions, which include Pipe Handle, Thread Class, Registeree, Queue Class, and Queue Semaphore.","ARCNET is the token-passing network that provides the primary communication link between the Control Center and the backbone of the system . The ARCNET driver  and  is software that provides the interface between the message processor  and  and the physical ARCNET device interface in the cabin file server  or the primary access terminal . The description below is for the primary access terminal .","For development efficiency, the ARCNET driver  has been attached to the message processor . The ARCNET driver  performs the following. The ARCNET driver  obtains a network address of this line replaceable unit. The ARCNET driver  understands network addresses for up to 8 cabin file servers  and up to 8 primary access terminals , to provide for future growth. The ARCNET driver  initializes the ARCNET device to proper configuration. The ARCNET driver  signs-on to the network. The ARCNET driver  handles network reconfigurations and builds up network map to obtain information for routing messages across multiple ARCNET networks. The ARCNET driver  deals with transmit handshaking exceptions that may occur.","The ARCNET device is an SMC COM20020 Universal Local Area Network Controller, the same device as used in all backbone line replaceable units. The network speed is 1.25 Mbps. The 256-byte ARCNET packet (short packet format) is employed. A 2 KB internal device RAM is divided into two 256-byte pages: 1 receive buffer and 1 transmit buffer. The rest is currently not used. The line replaceable units are arranged in 2 ARCNET networks , one each supported by the primary access terminal  and the cabin file servers . The ARCNET driver  supports this variability.",{"@attributes":{"id":"p-0176","num":"0175"},"figref":"FIG. 12","b":["408","408"]},"To use the ARCNET driver , a user first calls ArcnetDriverClass::StartDriver( )  to initialize this driver and its device and establish queues ,  to be used to transmit and receive data.",{"@attributes":{"id":"p-0178","num":"0177"},"figref":"FIG. 12","b":["408","601","604","605","603","602"]},"A discussion follows regarding the Network Addressable Units (NAU) that reside on the primary access terminal . The primary access terminal  Network Addressable Unit program  function and data paths are shown in . The primary access terminal NAU  provides the interface between the PAT GUI  or the Application Services and the unique devices attached to the Primary Access Terminal . Each of these devices is controlled via its own Virtual LRU (VLRU) set of functions. In addition, most of these devices communicate via the same I\/O channel, the PI Mux . The VLRUs are listed below.",{"@attributes":{"id":"p-0180","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Audio Tuner","The Audio Tuner VLRU allows control of audio channel"]},{"entry":["VLRU","selections for flight attendant previewing via the PAT GUI."]},{"entry":["Card Reader","The Card Reader VLRU collects and forwards data from"]},{"entry":["VLRU","the card reader, to be used by the Access Functions and"]},{"entry":[{},"Sales Services' Functions."]},{"entry":["GUI Monitor","No LRU is actually associated with this VLRU. The GUI"]},{"entry":["VLRU","Monitor VLRU's duty is to start the GUI and end the GUI"]},{"entry":[{},"as appropriate."]},{"entry":["PAT VLRU","The PAT VLRU responds to loopback messages from the"]},{"entry":[{},"CFS TestPort NAU via Ethernet for BIT functionality. It"]},{"entry":[{},"logs communication failures between the PAT and the CFS."]},{"entry":[{},"It controls the BITE and COMM LEDs on the front of the"]},{"entry":[{},"PAT, lighting them to indicate failures."]},{"entry":["Printer","The Printer VLRU periodically queries the Control Center"]},{"entry":["VLRU","Printer for its status and provide this status as an"]},{"entry":[{},"unsolicited message to the PAT GUI."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"PAT.EXE contains the primary access terminal NAU program . In general, a network addressable unit program must first construct a NAUDispatch object and then construct one or more NAU objects, one for each virtual LRU (VLRU) that it supports. Certain VLRU-specific functions (such as NAU::StartItUp( )) must be created for each VLRU type. The primary access terminal NAU program  includes the following primary components:",{"@attributes":{"id":"p-0182","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PAT.CPP","The Main( ) Program"]},{"entry":[{},"PDSPATCH.CPP","The NAU Dispatcher"]},{"entry":[{},"GUMNITOR.CPP","The GUI Monitor VLRU Class"]},{"entry":[{},"CRDRDRVL.CPP","The Card Reader VLRU Class"]},{"entry":[{},"TUNRVLRU.CPP","The Audio Tuner VLRU Class"]},{"entry":[{},"PATVLRU.CPP","The PAT main VLRU Class"]},{"entry":[{},"PRNTRVLR.CPP","The Printer VLRU Class"]},{"entry":[{},"PRNTRSTT.CPP","The Printer VLRU's Status Sub-Class"]},{"entry":[{},"PIMUX.CPP","The PI MUX VLRU Class"]},{"entry":[{},"PINTRFCE.CPP","The base class for the Tuner VLRU, Card"]},{"entry":[{},{},"Reader VLRU and PAT VLRUs"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Main( ) registers with the System Monitor  and launches a PIDispatch object to open up communications between the message processor  and the transaction dispatcher . It calls PIDispatch:startItUp( )  to initialize the VLRUs, one each. It also launches the Session( ) threads . Main( ) waits to die, either by receiving a ProcessStop command from System Monitor , or else it sleeps forever until interrupted. It calls shutItDown( ) to close all the VLRUs down with a SubProcessStop command and exit gracefully.","Referring to , the message processor (MP)  and the transaction dispatcher (TD)  communicate by way of a Network Addressable Unit (NAU) dispatcher  that comprises NAUDispatch. NAUDispatch is a base class that contains the code necessary to open a framework for a new Network Addressable Unit. It contains the following global objects:",{"@attributes":{"id":"p-0185","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Qpair MP_Fifos","Qpair MP_Fifos keep track of traffic between the"]},{"entry":[{},"NAU and the Message Processor. The NAU Object"]},{"entry":[{},"Ids are stored in these two queues."]},{"entry":["Qpair TD_Fifos","Qpair TD_Fifos keep track of traffic between the"]},{"entry":[{},"NAU and the Transaction Dispatcher. The NAU"]},{"entry":[{},"Object Ids are stored in these two queues."]},{"entry":["Queue","The Queue RunImmediateFifo keeps track of"]},{"entry":["RunImmediateFifo","NAUs which require immediate attention,"]},{"entry":[{},"regardless of outside messages."]},{"entry":["Queue","The Queue TimedOutFifo allows an NAU VLRU to"]},{"entry":["TimedOutFifo","time out, thus giving processing over to others"]},{"entry":[{},"until the time out occurs."]},{"entry":["Queue DestructFifo","The Queue DestructFifo is used by shutItDown( ) to"]},{"entry":[{},"cause each VLRU to shut down."]},{"entry":["Queue AuxFifo","The Queue AuxFifo is used in Session.cpp of"]},{"entry":[{},"Seat.exe only."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Only the first constructor call per program uses InitNAUDispatch( ) to start all session threads  (one for each VLRU plus 2 up to a maximum of 14) for the NAU. It opens Named Pipes and between the message processor  and the transaction dispatcher  Fifos ,  and the session threads  to manage I\/O between them. It then initiates threads \u2013 that manage input and output between the message processor  and the transaction dispatcher  (MPLeft( ) , MPRight( ) ,TDLeft( )  and TDRight( ) ). Once these initialization steps have been accomplished, the main program constructs NAU state machine objects  (also called VLRUs).","In addition, this class contains the following utility functions:",{"@attributes":{"id":"p-0188","num":"0187"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["AddNAU( )","This routine adds a VLRU object ID to an array for"]},{"entry":[{},"later lookup (to send it a message or shut it down,"]},{"entry":[{},"for example)."]},{"entry":["AddNAUMap( )","This routine adds a VLRU object ID and its text"]},{"entry":[{},"name to an array for later lookup."]},{"entry":["FindNAU( )","Returns the VLRU object ID based on the text name"]},{"entry":[{},"passed to it."]},{"entry":["GetNthNAU( )","Returns the VLRU object ID in the \u2018nth\u2019 position in"]},{"entry":[{},"the array."]},{"entry":["GetNumber","Returns the number of VLRU object Ids in the"]},{"entry":["OfNAUs( )","array."]},{"entry":["RemoveNAU","This routine removes a VLRU object ID and its text"]},{"entry":["FromMap( )","name from the array."]},{"entry":["SendToAllVLRUs( )","This routine sends the same message to all VLRUs"]},{"entry":[{},"via their MPRight.queue, as if it was sent via the"]},{"entry":[{},"MP. It uses MP logic as a short-cut, rather than"]},{"entry":[{},"developing more routines for intra-process"]},{"entry":[{},"communication."]},{"entry":["SendToOneVLRU( )","This routine sends a message to a single VLRU via"]},{"entry":[{},"its MPRight.queue, as if it was sent via the MP. It"]},{"entry":[{},"uses MP logic as a short-cut, rather than developing"]},{"entry":[{},"more routines for intra-process communication."]},{"entry":["shutItDown( )","This routine is used to turn off all VLRUs, typically"]},{"entry":[{},"called because a message was sent by the System"]},{"entry":[{},"Monitor to the main( ) routine to do so."]},{"entry":["startItUp( )","The startItUp( ) routine is used to start up all"]},{"entry":[{},"VLRUs."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The MPRight( ) Thread routine  continuously waits for incoming messages from the Message Processor  via the Named Pipe . The term \u2018right\u2019 indicates that the data moves from left-to-right in .","The MPRight( ) Thread  uses the IFE Message Class routines to deal with the data received. Once a message is received using IFE_Message::GetData( ), it looks up the appropriate VLRU name (IEF_Message::GetAddress( ) ) and uses it to look up the appropriate NAU object ID (FindNAU( )). Then it stores the incoming message in that NAU's MPQueue.Right queue and places the NAU's ID into the Dispatcher's MP_Fifos.Right queue (MPPutNAU( )) . This ID is then used by the Session threads  that are constantly running to decide which VLRU needs to be processed.","A \u201chook\u201d function pointer is provided with this thread to allow applications to pre-process the message prior to MPRight( )'s storage. If no hook function is defined, this is ignored.","The MPLeft( ) Thread routine  continuously waits for outgoing messages for the Message Processor . The term \u201cleft\u201d indicates that the data moves from right-to-left in . It uses the IFE Message Class routines to deal with received data.","Using Queue::Get( ) it reads the NAU ID from the MP_Fifos.Left queue  then uses that NAU's MPGetNAU( ) function to read the data from its MPQueue.Left , and uses IFE_message::PutData( ) to output the message via the Named Pipe ","The TDLeft( ) Thread  behaves like MPRight( ) , except that the input comes from the transaction dispatcher . The TDRight( ) Thread  behaves like MPLeft( ) , except that the output goes to the transaction dispatcher .","It is sometimes impractical for all VLRUs to be running at once (for example, the seat NAU can contain more than 500 VLRUs), so a maximum number of processing threads has been established as 14. These threads \u2013 each execute a Session( ) function  which waits for an event such as input from any source (message processor , transaction dispatcher , TimeOut, etc.), then determines which VLRU state machine needs to be run to process the message and executes it via the VLRU's StartItUp( ) function  called by NAU::EntryPt( ). When EntryPt( ) returns, the message is fully processed, and Session( )  loops to get another one.","The NAU class contains foundation routines and data for any VLRU. It is derived from the timed Callback class and Cobject class (from a C++ Foundation Class Library). The NAU constructor makes an object that has TDQueue and MPQueue, two Qpair objects. These queues are used to store the actual data or IFE_Message needed by the VLRU state machine. The NAU constructor also creates three Event Semaphores, including a RunImmediateEvent semaphore, a TimeOutEvent semaphore and an AuxEvent semaphore, which allow it to control processing via the related Queues in the NAU dispatcher . Finally, the NAU constructor creates one mutex, DispatchMutex which coordinates which Session thread can access the data for a given VLRU (in case two threads try to handle messages for the same VLRU).","The StartItUp( ) function  (not the same as NAUDispatch::startItUp( ) ) is called by NAUDispatch::Session( ) when a message is ready to be processed by the VLRU. The StartItUp( ) function  typically varies per VLRU, but it's job is to fully process one message received from any source. That may simply mean passing the message on, say from message processor  to transaction dispatcher  or vice-versa.","Data Movement Functions will now be discussed. The NAU class contains the following members used to move data to and from the message processor  and the transaction dispatcher :",{"@attributes":{"id":"p-0199","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MPGetNAU( )","Moves data from MPQueue.Left for output to the MP."]},{"entry":["MPPutNAU( )","Moves data from input from MP to MPQueue.Right."]},{"entry":["NAUGetMP( )","Moves data from MPQueue.Right into StartItUp( ) for"]},{"entry":[{},"processing."]},{"entry":["NAUGetTD( )","Moves data from TDQueue.Left into StartItUp( ) for"]},{"entry":[{},"processing."]},{"entry":["NAUPutMP( )","Moves data from StartItUp( ) into MPQueue.Left for later"]},{"entry":[{},"output."]},{"entry":["NAUPutTD( )","Moves data from StartItUp( ) into TDQueue.Right for"]},{"entry":[{},"later output."]},{"entry":["TDGetNAU( )","Moves data from TDQueue.Right for output to the TD."]},{"entry":["TDPutNAU( )","Moves data from input from the TD to TDQueue.Left."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Other generic NAU functions include:",{"@attributes":{"id":"p-0201","num":"0200"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bOKToRun( )","Reports to NAU Dispatch whether a VLRU is ready"]},{"entry":[{},"to run. The base version of this always returns"]},{"entry":[{},"TRUE."]},{"entry":["EntryPt( )","This launches the VLRU's own StartItUp( )"]},{"entry":[{},"function."]},{"entry":["get","Returns the value of the Time Out Event handle."]},{"entry":"hTimeOutEvent( )"},{"entry":["get","Returns a pointer to all the Event Handles used"]},{"entry":["hVLRUEvents( )","by this session to get Input."]},{"entry":["get_NAUState( )","Returns the current state of the VLRU. If \u201cActive\u201d,"]},{"entry":[{},"the VLRU is capable of processing information. If"]},{"entry":[{},"\u201cInactive\u201d, it can't take any messages. For"]},{"entry":[{},"example, if the system is not currently allowing"]},{"entry":[{},"game play, the HSDL VLRU would be \u201cInactive\u201d."]},{"entry":["GetBITEStatus( )","This function varies from VLRU to VLRU and is"]},{"entry":[{},"only a placeholder in the base class."]},{"entry":["GetMPQPair( )","Returns a pointer to the MP Queues-lets the"]},{"entry":[{},"user bypass the entire message traffic philosophy."]},{"entry":["GetName( )","Returns the text name of the current NAU VLRU."]},{"entry":["GetTDQPair( )","Returns a pointer to the TD Queues-lets the user"]},{"entry":[{},"bypass the entire message traffic philosophy."]},{"entry":["GetUseMessage","Retrieves a flag set with SetUseMessageCounter( )."]},{"entry":"Counter( )"},{"entry":["set_NAUState( )","Used to control the state of the VLRU state"]},{"entry":[{},"machine. Currently, the two states used are"]},{"entry":[{},"\u201cActive\u201d and \u201cInactive\u201d."]},{"entry":["SetUseMessage","Sets a flag used by NAUDispatch::Session( ). If"]},{"entry":["Counter( )","TRUE, Session( )counts messages for the VLRU."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"As discussed above, each of the devices (, , , ) attached to the primary access terminal  is controlled via its own virtual LRU (VLRU) or NAU state machine objects  functions discussed in conjunction with . Most of these devices communicate via the same I\/O channel, a PI Mux.","The tuner VLRU allows control of audio channel selections for flight attendant previewing via the PAT GUI . The TunerVLRU class is also a PIInterface class child. Its StartItUp( ) routine handles the SubProcessStart and SubProcessStop commands the same as the others, and then waits for I\/O from either the PI Mux or the transaction dispatcher . If a message is received from the PI Mux, it forwards it to the transaction dispatcher  using NAU: NAUPutTD( ). If a message is received from the message processor , it forwards it to the PI Mux using ToMuxPut( ).","The card reader VLRU collects and forwards data from the card reader , to be used by the access functions and sales services' functions. Based on the PIInterface class, the CardReaderVLRU class is the first actual VLRU created for this NAU. It creates an event called StartEvent which is used by PIMux to coordinate all the other PIInterface VLRUs. Its StartItUp( )  routine loops forever retaining its Session( ) thread. It looks for a SubProcessStart command from the message processor  (which is issued by NAUDispatch:startItUp( )) and then waits for StartEvent to trigger before processing any other messages. Once StartEvent has occurred, it can continue processing. If it receives a SubProcessStop message, it terminates. It reads and ignores all other messages from the message processor  and the transaction dispatcher . Instead, it looks for input via its FromMux semaphore event, which tells when it has received data from the PI Mux. If the PI Mux sends a CardRead command, this VLRU calls MagCardData( ) to process this message. All other messages are returned to the Mux via the ToMux queue. MagCardData( ) converts the data into ASCII and forwards it to the primary access terminal application via the transaction dispatcher . Optionally for testing, the Register can be set with the value \u201cDisplayMagCardData\u201d to cause all the card data to be printed to a window at the primary access terminal  via stdout.","The GUI Monitor VLRU starts the GUI and ends the GUI as appropriate. No LRU is actually associated with this VLRU. When the GUI_Monitor object is created, it creates an extra event called ServiceAlive. This event is set via ServiceMonitor( ) and tested in StartItUp( )  to know whether Cabin Service is communicating to this NAU. The StartItUp( ) routine is called as soon as all the VLRUs are created via the PIDispatch:startItUp( ) it launches another thread called ServiceMonitor( ) which continuously tries to receive messages from the Cabin Services program via a mail slot. It then uses this as a \u2018heart beat\u2019 to know if the application is still alive. If this heart beat fails to occur after having been established, the GUI Monitor terminates the GUI process. If this heart beat is never established, ServiceMonitor( ) simulates one, for test purposes. StartItUp( )  continuously loops and waits for the SubProcessStart command from the message processor  (from the PIDispatch::startItUp( ) routine), and then it waits for PIDispatch( ) to tell whether it connected to the database successfully by triggering the ConnectedToService event. Then it attempts to start the CGUI.EXE program. If StartItUp( ) detects that the GUI terminated, it attempts to restart it. StartItUp( ) ignores messages from the transaction dispatcher , and only processes the SubProcessStart and Stop commands from the message processor .","The Card Reader, Tuner, PI Mux, primary access terminal and Printer VLRUs are all based on the PIInterface class. Essentially, this provides support for one more source of I\/O, from the PI Mux (or multiplexed I\/O port) via the PIMux VLRU. The PIMux VLRU provides the following member routines:",{"@attributes":{"id":"p-0207","num":"0206"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ToMuxPut( )","Converts a PAT_Message into appropriate"]},{"entry":[{},"syntax for either Audio Tuner or PI \u2018Board\u2019"]},{"entry":[{},"message and sends the data to the ToMux"]},{"entry":[{},"queue."]},{"entry":["FromMuxPut( )","Places a message on the FromMux queue."]},{"entry":["FromMuxGet( )","Reads a PI_Message from the FromMux queue"]},{"entry":[{},"and converts it to a PAT_Message."]},{"entry":["ToMuxGet( )","Reads and encodes for transmission a"]},{"entry":[{},"PI_Message from the ToMux queue."]},{"entry":["FromMuxSemaphore","Returns the handle for this queue"]},{"entry":"Handle( )"},{"entry":["FromMuxSemaphore","Returns the handle for this queue."]},{"entry":"Handle( )"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The PIMux class is the VLRU which communicates via the message processor  and the transaction dispatcher  for all I\/O with the PI Board, for card reader, tuning, etc. The PIMux class points to each of these VLRU classes for data transfers through their FromMux and ToMux queues. A StartItUp( ) routine loops forever retaining its Session( ) thread. It looks for a SubProcessStart command from the message processor  (which is issued by the NAUDispatch::startItUp( ) routine) and triggers the StartEvent to activate its associated VLRUs (Card Reader, etc.).","Once StartEvent has occurred, it proceeds to receive I\/O from the message processor  and the transaction dispatcher . It determines which sub-VLRU should process the message and forwards it to their FromMux queue for handling, and then it responds an Ack or Nak to the PI board, as applicable to satisfy its communications protocol needs.","Messages from the VLRUs intended for the PI Mux are sent to this VLRU as well via their ToMux queues. It encodes the messages as needed, forwards them and handles the Ack\/Nak protocol. It has its own version of NAUGetMP( ) in order to use the PI_Message data handling routines.","The primary access terminal VLRU responds to loopback messages from the CFS TestPort NAU via Ethernet for BIT functionality. It logs communication failures between the primary access terminal (PAT)  and the cabin file server (CFS) . It controls the BITE and COMM LEDs on the front of the PAT, lighting them to indicate failures. The PatVLRU class is also a PIInterface class child only so it can synchronize operation via the StartEvent trigger. Its constructor reads the registry \u201cVerbosePATVLRU\u201d settings (for test purposes) and the \u201cBITTestInterval\u201d value for BIT testing timeouts. StartItUp( ) launches a thread called BitTestMonitor( ) and then loops continuously to process messages. First, it waits to receive a SubProcessStart message, then it waits for the StartEvent to know that PIMux is alive and ready to go. SubProcessStop causes it to kill the BitTestMonitor( ) thread and then die. All other messages from the message processor  are ignored. If an Ethernet Loopback message is received from Test Port NAU via the transaction dispatcher , it uses EthernetLoopback( ) to return a message via NAU::NAUPutTD( ) and then tell the BitTestMonitor that the loopback occurred. All messages from the PIMux are returned to it via PIInterface::ToMuxPut( ) and otherwise ignored as an error. The BitTestMonitor( ) turns both BITE and COMM LEDs on at the primary access terminal  to show that they are both working. Then it turns off the BITE light and waits. If it receives notification from StartItUp( ) that a loopback occurred, it turns off the BITE LED. If it times out waiting for a loopback, it turns the LED back on. If it gets several successive failures (timeouts) it logs it to the event log. If it gets told to exit by StartItUp( ), it turns the BITE LED on and dies.","The Printer VLRU periodically queries the control center printer for its status and provides this status as an unsolicited message to the PAT GUI . The PrinterVLRU object is a PIInterface class child only so that it can sync up with PI Mux to start processing. Its constructor retrieves \u201cPrinterPollInterval\u201d and \u201cPrinterStatusTimeout\u201d from the Registry and then creates hEventPrinterStatusChange and hEventStop to communicate to the monitor thread that is created in StartItUp( ). This class also has a PrinterStatus class object called Printer which does all the actual communication with the printer over the Ethernet network . StartItUp( ) launches the PrinterSatusMonitor( ) thread, and then loops forever. The only message processor messages it processes are:",{"@attributes":{"id":"p-0213","num":"0212"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SubProcessStart","After receipt it waits for the StartEvent signal to"]},{"entry":[{},"continue"]},{"entry":["SubProcessStop","Kills the Monitor thread and dies"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"StartItUp( ) ignores all messages from the transaction dispatcher . It echoes any messages back to the PI Mux and otherwise ignores them. If StartItUp( ) receives a PrinterStatus event (from the monitor), it calls Sendprinterstatus( ) to build the status message and then sends it to the CAPI Message Service via NAU::NAUPutTD( ). PrinterStatusMonitor( ) uses the PrinterStatus object of this VLRU to talk to the printer. If it cannot talk to the printer via PrinterStatus::InitializePrinterSNMP( ), it logs the error to the event log. If changes in the printer status occur, it tells StartItUp( ) via hEventPrinterStatusChange. It logs the following other events to the event log: Out of Paper, Has Paper Again, any other errors, and 1st Status after any error.","SendPrinterStatus( ) uses PAT_Message routines to convert the PrinterStatus info to ASCII. It then sends it on to the CAPI Message Service via NAU::NAUPutTD( ). The PrinterStatus class constructor connects to the Printer via the Ethernet network  using InitializePrinterSNMP( ), requests the status via RequestRawPrinterStatus( ), Interprets (with StatusDescription( ) ) and displays the printer status info using DisplayPrinterStatus( ), among other private routines.","Transaction Dispatcher","The transaction dispatcher  will now be discussed with reference to . The transaction dispatcher  comprises NAU Clients , a NAU Server , a Router and Mail Slots , a Services Server , and Service Clients . The NAU Server  comprises a plurality of OutPipeProcessors( ) , a plurality of InPipeProcessors( ) , and a plurality of NAU Out FIFO Queues . A plurality of Name Pipes  couple the NAU Clients  to the InPipeProcessors( ) and OutPipeProcessors( ) and InPipeProcessors( ) . The NAU Out FIFO Queues are respectively coupled to the OutPipeProcessors( ) . The Services Server  comprises a plurality of OutPipeProcessors( ) , a plurality of InPipeProcessors( ) , and a plurality of Service Out FIFO Queues . The Service Out FIFO Queues are respectively coupled to the to the OutPipeProcessors( ) . A plurality of Name Pipes  couple the Service Clients  to the OutPipeProcessors( ) and InPipeProcessors( ) ","The Router and Mail Slots  comprises the LRU table , which is coupled to an AddMessageToOutQueue( ) . The InPipeProcessors( ) of the NAU Server  are coupled to the AddMessageToOutQueue( ) . Also, the InPipeProcessors( ) of the Services Server  are coupled to the AddMessageToOutQueue( ) . The AddMessageToOutQueue( )  is coupled by way of a IntraNodal Output Queue to an IntraNodalOutThreadProcessor( ) . The IntraNodalOutThreadProcessor( ) is coupled to any process on any NT line replaceable unit connected by way of the Ethernet network . Similarly any process on any NT line replaceable unit connected by way of the Ethernet network  to an IntraNodalInThreadProcessor( ) is coupled to the AddMessageToOutQueue( ) .","The primary duty of the Transaction Dispatcher  is to move information between the logical devices (or NAU clients ) and the Application Services(or service clients ). By using a Transaction Dispatcher , the NAUs and the Services do not have to control I\/O traffic. In addition, the number of Named Pipes (or communication lines) between processes is greatly reduced because each Service and NAU need only communicate with one process, rather than each other. This simplifies the software design and efficiently uses a finite number of available Named Pipes.","To support this, the transaction dispatcher  includes the following sub-functions. Upon demand, the transaction dispatcher  creates two Named Pipes (input and output) for each NAU and Service, maintaining the lookup table of pipe names (or handles) and their corresponding NAU or Service IDs. The transaction dispatcher  uses Blocking I\/O to await a message from any incoming Named Pipe. Once it receives an IFE-structured Message, it examines only the message destination (NAU or Service ID) portion of the message to identify the appropriate Named Pipe to use by cross-referencing the lookup table . It then routes the complete message to an output queue and for that Named Pipe.","The transaction dispatcher  uses Mail Slots to send and receive messages from processes that are resident on remote WINDOWS NT line replaceable units, routing them to the appropriate destination. Using this technique, any Service or NAU can communicate with any other Service, NAU or program on this line replaceable unit or any line replaceable unit that also runs a transaction dispatcher .","The detailed design of the transaction dispatcher  will now be discussed.  illustrates the transaction dispatcher function and data paths. TD.EXE is the transaction dispatcher  and is comprised of the following file:",{"@attributes":{"id":"p-0222","num":"0221"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TRNSCTND.CPP","the Main Program and TransactionDispatcherClass"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Main( ) function of the transaction dispatcher  is responsible for initializing all its processing threads using CreateMainServiceThreads( ), CreateMainNAUThreads( ) and CreateMainIntraNodalThreads( ) functions. These threads operate continuously to move data from source to destination.","Main( ) also registers its existence with the system monitor program  (using Register( )) and waits for a shutdown signal from the system monitor , after which it performs an orderly shutdown of all its threads via its destructor. The relationships of the transaction dispatcher functions are shown in .","The term NAU Server means a set of routines that comprise a \u201cServer\u201d for the Network Addressable Unit processes. Two threads, NAUInThreadProcessor( ) and NAUOutThreadProcessor( ) are used to launch a set of I\/O threads (InPipeProcessor( ) and OutPipeProcessor( ) ) for an as yet unknown NAU process. The first message received from any NAU registers it to this set of threads, causing NAUInThreadProcessor( ) and NAUOutThreadProcessor( ) to launch another set, getting ready for the next NAU to speak. In this way, the transaction dispatcher  is dynamic and can support different NAUs as needed.","With regard to Incoming Messages, InPipeProcessor( ) continuously receives an IFE Message from its Input Pipe and sends it to AddMessageToOutQueue( )  which routes it to the appropriate output queue. With regard to Outgoing Messages, OutPipeProcessor( ) continuously reads an IFE Message from the NAU Out Queue and sends it to its associated NAU process via its named pipe .","The term Services Server  means the set of routines that comprise a \u201cServer\u201d for Cabin and Sales Services. Two threads, ServiceInThread( ) and ServiceOutThread( ) are used to launch a set of I\/O threads (InPipeProcessor( ) and OutPipeProcessor( ) ) for an as yet unknown Service process. The first message received from any Service registers it to this set of threads, causing ServiceInThread( ) and ServiceOutThread( ) to launch another set, getting ready for the next Service to speak. In this way, the transaction dispatcher  is dynamic and can support different Services as needed.","With regard to Incoming Messages, InPipeProcessor( ) continuously receives a message from its Input Pipe and sends it to AddMessageToOutQueue( )  which routes it to the desired output queue. As for Outgoing Messages, OutPipeProcessor( ) continuously reads a message from the Service Out Queue and sends it to its associated Service process via its named pipe.","The router  comprises routines that use the lookup table to determine which processing thread needs to process the message. With regard to the From Any Source Router, upon demand, AddMessageToOutQueue( )  calls the appropriate PutData( ) function to move the message to the NAU or Service output queue.","The LRU Lookup Table is an internal memory structure that contains an entry for each device in the system . It contains sufficient information to translate message addresses for any piped destination. Specifically, it contains: Pipe Handle, Registeree, Queue Pointer, Queue Semaphore, and Thread Pointer. This information is kept in an SQL database table which is read during the Main( ) initialization via CreateLRUTable( ). Then as piped processes register with the transaction dispatcher , their identities are updated in this table via AddQueueInfoToLookUpTable( ), AddThreadPointerToLookUpTable( ) and AddPipeHandleToLookUpTable( ) functions.","The term Intra Nodal Server means the set of routines that permit communications between two WINDOWS NT line replaceable units connected via the Ethernet network . This differs from the Named Pipe communications in that a set of communication pipes is not created and maintained for each process. Instead, a single mail slot is maintained for incoming messages, and an appropriate outgoing mail slot is created for each outgoing message as needed.","With regard to Incoming Messages, IntraNodalInThreadProcessor( ) continuously receives a message from its Mail Slot and sends it to AddMessageToOutQueue( ) , which routes the message to the appropriate destination. The destination may be an NAU, a Service or even back out to another process via a mail slot. With regard to Outgoing Messages, IntraNodalOutThreadProcessor( ) continuously reads a message from its Out Queue and sends it to its associated process via the Mail Slot. This mail slot is created for just this message, and then is closed after the message is sent.","The System Monitor program  is automatically invoked by the operating system when the line replaceable unit boots. The system monitor function and data paths are shown in . The System Monitor program  comprises a service_main( )  that is coupled to a StopServices( ) . The System Monitor program  is coupled to console services  by way of a ConsoleInput( ) . Other outside testing processes are coupled to a service_cntrl( ) . A WatchDogDrive  along with the servicecntrl( )  and the ConsoleInput( ) are coupled to a MainQueue .","A Process\/Event Lookup table  is coupled to a GetSystemFullActionItem( )  that interact with a serv_server_main( ) and server_main( ) . The MainQueue  is coupled to the server_main( ) . The MainQueue  is coupled to a ProcessEventList( ) . The ProcessEventList( )  is driven by a plurality of Sysmon Class and Process Class State Machine Functions , . Output of the Process Class State Machine Functions are coupled to OutputQueues  of various Process and Process I\/O functions , . The Process and Process I\/O functions , are coupled by way of OutputLoop( )  and Name Pipes  to the transaction dispatcher  and message processor . The transaction dispatcher  and message processor  are coupled by way of Name Pipes  to respective InputLoop( ) . The respective InputLoop( )  are coupled to the MainQueue .","Sorted functions of the Process Class State Machine Functions are coupled by way of a QueueSorted Queue  and a StatPutQueueThread( )  to the MainQueue . Additional runtime processes  are also coupled by way of Name Pipes  to SysmonConnectThreads( ) . The SysmonConnectThreads( )  are coupled by way of a Register::RegisterInput( )  to the Process functions .","A WatchDogDrive  is provided that comprises a WatchStaticThread , a DogQueue  and a StatQueueThread . The WatchStaticThread  outputs to the DogQueue  and a PExternalKillProcess( ) from the Process Class State Machine Functions are coupled to the DogQueue . The DogQueue  outputs to the StatQueueThread  which in turn drives the WatchDog Driver .","The System Monitor program  operates in the background during the life of the control center applications and has the following four basic duties:",{"@attributes":{"id":"p-0238","num":"0237"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Start-Up","The Start-up function starts the Executive and Application"]},{"entry":[{},"programs after any system boot."]},{"entry":["Shutdown","The Shutdown function provides an orderly shutdown,"]},{"entry":[{},"flushing working data from memory to hard disk as"]},{"entry":[{},"appropriate. Then it terminates the execution of the"]},{"entry":[{},"Executive and Application programs."]},{"entry":["Power Down","This function works in conjunction with the Uninterruptable"]},{"entry":[{},"Power Supply (UPS) 400 which is connected via one of the"]},{"entry":[{},"serial ports on each of the Control Center LRUs. The"]},{"entry":[{},"operating system is notified by the UPS when power has"]},{"entry":[{},"been lost, causing it to start this function (POWERDWN."]},{"entry":[{},"EXE, POWERDWN.CPP). The Power Down program"]},{"entry":[{},"notifies the System Monitor that power has been lost to"]},{"entry":[{},"invoke an orderly shutdown using a \u2018ProcessStop\u2019 IFE"]},{"entry":[{},"Message. POWERDWN.EXE is listed in the NT Register"]},{"entry":[{},"as the program to start when power failure is detected."]},{"entry":["Restart","The Restart function scans for failed Executive and"]},{"entry":[{},"Application programs, and restarts them."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The detailed design of The System Monitor  will now be discussed. SYSMON.EXE includes the following primary components:",{"@attributes":{"id":"p-0240","num":"0239"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SYSMON.CPP","The Main( ) Program and Sysmon Class"]},{"entry":["DLYSCHDL.CPP","The DelayScheduler Class"]},{"entry":["PROCESS.CPP","The Process Class to manage the external programs"]},{"entry":["QUEESORT.CPP","The QueueSort Class-Used to manage sorted queues"]},{"entry":["RGSTRBJC.CPP","The Register Class used to register external"]},{"entry":[{},"processes"]},{"entry":["SMSCRIPT.CPP","The SysmonScript Class to manage the state tables"]},{"entry":["SYSGLOBA.CPP","Global routines to map to state-machine functions"]},{"entry":["SYSMNCNN.CPP","The SysmonConnect Class used to communicate"]},{"entry":[{},"externally"]},{"entry":["SYSMNSPC.CPP","SysmonSpecial Class"]},{"entry":["UTL150.CPP","RandomPack and Liner Classes plus other utilities"]},{"entry":["WTCHDGDR.CPP","The WatchDogDrive Class"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Referring to , the System Monitor  is a Windows NT Service Process, which means it runs in the background and is controlled by the following functions in the Win32 SDK Library: StartServiceCtrlDispatcher( ), ControlService( ), Handler( ), RegisterSreviceCtrLHandler( ), and ServiceMain( ).","The System Monitor  was designed as a state machine, but, it's actual code is more of an in-line design with state flags used to keep track of processing. For example, a single function calls another function which calls yet another function, and all three are only used once. For clarity, these are grouped together herein.","The main( ) function updates its revision history information in the WINDOWS NT Register, determines where to find the other programs to be started, launches itself as a WINDOWS Service by connecting to the WINDOWS Service Control Manager via StartServiceCtrlDispatcher( ), identifying service_main( )  as the main function for this service. The main( ) function is identified in advance of runtime during software installation, which calls the NT CreateService( ) to set up the System Monitor  as a WINDOWS NT Service. Main( )also alters its behavior depending on whether a console service  (i.e., a display monitor) is available for testing. Main( )uses SetConsoleCtrlHandler( ) to allow someone to abort the programs by pressing Ctrl-C at any time.","Service_main( )  is the main program that continually runs when the system monitor service is running. It calls RegisterServiceCtrlHandler( ) to identify service_ctrl( )  to NT as the function to execute when other outside programs want to alter the execution of this service. It maintains a combination state-checkpoint to identify to the outside world (i.e., test programs) what it is doing:",{"@attributes":{"id":"p-0245","num":"0244"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"Check-","Service Control Code to get"]},{"entry":["State","point(s)","there"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SERVICE_START_PENDING","1,2","(none)"]},{"entry":["SERVICE_RUNNING","0","Service_Control_Continue"]},{"entry":["SERVICE_PAUSED","0","Service_Control_Pause"]},{"entry":["SERVICE_STOP_PENDING","0,1","Service_Control_Stop"]},{"entry":["SERVICE_STOPPED","0","(none)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"When service_main( )  starts, it is in SERVICE_START_PENDING state, checkpoint #1. If it successfully creates all its event handles, it moves to checkpoint #2. It then sets up a Security Descriptor and launches a serv_server main( ) thread, moving its state to SERVICE_RUNNING.","The outside world can alter its state by calling service_ctrl( )  and providing a Service Control Code. The table above shows which state service_main( )  moves to based on the control code received. If the SERVICE_STOPPED state is reached, a hServDoneEvent is triggered, causing this function to exit, terminating the System Monitor .","The service-ctrl( )  routine is called via an NT Service utility ControlService( ) by any outside program that wishes to control the System Monitor service in some way. Service_ctrl( )  uses a MainQueue  to issue commands to various Process Class objects that are running.","The server_main( )  routine creates the Sysmon object MainSysmon and executes its Sysmon::StartHandler( ) to get the other processes running. If running in test mode, server_main( )  is called directly by main( ). If running in runtime mode, server_main( ) is called by ser_server_main( )  which is a thread launched by servicemain( )  (the main program initiated by the WINDOWS NT Service Manager). Finally, server_main( )  calls Sysmon::MainQueueProcessing( ) which loops until it is time to shutdown. Once MainQueueProcessing( ) returns, this thread ends.","The stopservice( ) function  can be used by any thread to report an error and stop the Sysmon Service. It logs the reason that it was called via ReportEvent( ), and tells service_main( ) to abort via hServDoneEvent. Derived from Process, the Sysmon Class contains all the software needed to drive all the Process Class state machines. It uses MainQueue  as its primary input.","Sysmon::StartHandler( ) is responsible for launching all the external programs and providing a means to monitor them. First, it compiles the file SYSMON.ASC. Then, it queries the NT Registry to determine which type of line replaceable unit it is running on (PAT, CFS or test unit) to know which processes to initiate. It creates a SmScript object to establish system-level state machine tables using SmScript::InitiateTables( ). It sets up communications with the UPS  via a communication port, and determines whether the UPS  is working, whether the line replaceable unit has power and whether it should continue processing as a result. Finally, it creates the following objects and runs a starter function for each of them:",{"@attributes":{"id":"p-0252","num":"0251"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Class","Starter Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ConnectTask","SysmonConnects","StartHandlerConn( )"]},{"entry":["MyWatchDog","WatchDogDriver","StartHandler( )"]},{"entry":["ProcessItem[i]","Process","Initialize( )"]},{"entry":["(one for each",{},"(StartHandler( ) is called later,"]},{"entry":["process",{},"after Process Registration)"]},{"entry":"for this LRU)"},{"entry":["SelfHeartBeatTask","SysmonSpecial","StartHandlerSpecial( )"]},{"entry":["SelfMonitorTask","SysmonSpecial","StartHandlerSpecial( )"]},{"entry":["DelayTask","DelayScheduler","StartHandlerDelay( )"]},{"entry":["QueueSorted","QueueSort","None, used to schedule events"]},{"entry":[{},{},"(i.e., Process::PPostExternalKill"]},{"entry":[{},{},"Process( ))"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"It creates an EventOnQueue object with an UpSystem event in it and places it in the MainQueue queue  to start the external processes (beginning with the Transaction Dispatcher ). Finally, it calls Sysmon::MainQueueProcessing( ) which loops forever, using Sysmon::MainProcess( ) to handle all processing requests which get placed on the MainQueue queue by this and the other classes' threads.","The basic flow of startup events is:",{"@attributes":{"id":"p-0255","num":"0254"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["UpSystem Event from Sysmon::StartHandler","start Transaction"]},{"entry":[{},"Dispatcher"]},{"entry":["Registration received from Transaction Dispatcher","start Message"]},{"entry":[{},"Processor"]},{"entry":["Registration received from Message Processor","start Service"]},{"entry":["Registration received from Service","start NAUs"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In this way, the system comes up in a sequential, orderly fashion.","MainQueueProcessing( ) loops forever waiting for Events to appear on the MainQueue queue. Once found, it calls MainProcess( ) which uses the information from the EventOnQueue object to lookup the \u2018real\u2019 action(s) to perform using the SmScript::GetystemFullActionItem( ) and Process::GetTotalMatrix( ) functions. It processes these actions using Sysmon::ProcessEventList( ) .","ProcessEventList( )  is only called by MainProcess( ) to look up and process the desired actions from a table of actions, which are maintained in the SmScript Class.","The above processes loosely form a state machine. In fact, a series of flags denoting the state of the Sysmon system is used to decide what to do next. The following routines are used to support this state machine. There is only one system level Action List to do: UpSystem[ ] or UpPAT[ ]. They each have several Actions which point to SYSGLOBAL functions. These functions in turn determine whether they should call a Process class function or a Sysmon class function. The Sysmon Class functions are:",{"@attributes":{"id":"p-0260","num":"0259"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PSysSoftReboot(\u2009)","Calls softboot(\u2009) which uses the"]},{"entry":[{},"ExitWindowsEx(\u2009) command to reboot the LRU."]},{"entry":[{},"Called via the global PSoftReboot(\u2009) function."]},{"entry":["PSysHardReboot(\u2009)","Reboot via WatchDogDriver::Watch_Reboot(\u2009)"]},{"entry":[{},"which causes the hardware to reset."]},{"entry":[{},"Called via the global PHardReboot(\u2009) function."]},{"entry":["PSysGetState(\u2009)","Retrieves the state of the system state machine."]},{"entry":[{},"Called via the global PGetProcessState(\u2009)"]},{"entry":[{},"function. This is not used: The variable"]},{"entry":[{},"\u2018selfstate\u2019 is used directly."]},{"entry":["PSetSysState(\u2009)","Sets the state of the system state machine,"]},{"entry":[{},"which is used in GetSystemFullActionItem(\u2009)"]},{"entry":[{},"along with the current event to know what action"]},{"entry":[{},"to do to the system. Generally called via the"]},{"entry":[{},"global PSetState(\u2009) function."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The SysmonConnects class contains code necessary to communicate to the other processes in the line replaceable unit, for example the Transaction Dispatcher . It establishes a Named Pipe set to communicate with each of them. It works very closely with the RegisterObject Class to provide pipes to each of the Process Class handlers. This method of creating a generic Named Pipe set and assigning it to the first process to register was taken from the Transaction Dispatcher , however, because this program directs which external process is executed, and therefore which one is registered.","The StartHandlerConn( ) routine simply launches two threads, one for Named Pipe Input and one for Named Pipe Output.","InputConnectThread( ) is launched by StartHandlerConn( ). It calls DynInput( ) which loops forever, opening a Named Pipe for input, then waiting for an outside process to connect to it. It then creates a temporary RegisterObject class object to tie this Named Pipe to the connecting outside process, and loops to create another named pipe.","OutputConnectThread( ) is launched by StartHandlerConn( ). It calls DynOutput( ) which loops forever, opening a Named Pipe  for output, then waiting for an outside process to connect to it. It then creates a temporary RegisterObject class object to tie this Named Pipe to the connecting outside process, and loops to create another named pipe.","When the DynInput( ) and DynOutput( ) routines of SysmonConnect receive input from an outside process to claim a Named Pipe, they create a temporary RegisterObject class object to receive Registration information from the calling process and tie the current Named Pipe to the Sysmon Process object associated with that process. In this way, each Process object has its own set of I\/O to its corresponding external process.","This launches RegisterInput( ) as a new thread. It is called by both SysmonConnects::DynInput( ) and DynOutput( ). The RegisterInput( ) code calls DynRegisterInput( ) and kills itself and its SELF (its own object) when DynRegisterInput( ) is done. The DynRegisterInput( ) routine tries to read from the Named Pipe to get a Registration message from the outside process. It attempts this 100 times before it gives up and exits. If successful, it calls Process::StartHandler( ) to get its Input or Output thread started with this Named Pipe.","The SmScript Class contains the tables of events and actions that are used to move each Process object state machine from one state to the next. FullActionItem arrays read like pseudo code, each entry containing the following set of information: Function-Name, Process ID, Additional Data for the named Function. Thus, for example, \u201c{PHardReboot,systemflag,150}\u201d means to run global function PHardReboot(150), which in turn runs the system function Sysmon::PSysHardReboot(150).","The InitiateTables( ) routine is called once per power-up to prepare the event\/action table SysMatrix as appropriate for the runtime LRU system monitor. It fills this array with a pointer to the UpSystem or UpPAT FullActionList array.","The InitProcess( ) routine is called by Process::Initialize( ) for each process object created to complete the tables for the Process to use. It moves the appropriate event\/actions into this Process object's TotalMatrix array. This permits the use only one System Monitor executable program, even though its specific duties vary from line replaceable unit to line replaceable unit. For example, the primary access terminal LRU does not have the Service process and the File Server LRU does not have the primary access terminal NAU process.","The GetSystemFullActionItem( ) routine returns the appropriate value from the SysMatrix table. The is used only in Sysmon::MainProcess( ).","The Process Class Initialize( ) initializes the TotalMatrix table via SmScript::InitProcess( ).","The Process Class StartHandler( ) is called by RegisterObject::DynRegisterInput( ) after an external process has successfully registered with Sysmon. It calls StartInputThread( ) or StartOutputThread( ) depending on the Named Pipe which was registered.","StartInputThread( ) is called by StartHandler( ) and simply launches a new thread, InputLoop( ). InputLoop( ) in turn simply calls DynInputLoop( ) for this process. DynInputLoop( ) continuously loops, collecting any IFE Message from its Named Pipe (using the IFE_Message::GetData( ) function), and processing it using ProcessIncoming( ). Errors are reported using ProblemReport( ) and the MainQueue is updated to control either a shutdown or retry, depending on the severity of the error. If it's error is severe enough, it exits the loop and the thread dies.","StartOutputThread( ) is called by StartHandler( ) and simply launches a new thread, OutputLoop( ). OutputLoop( ) in turn calls DynOutputLoop( ) for this process. DynOutputLoop( ) continuously loops, collecting any IFE Message from its OutputQueue and sending it out its Named Pipe (using the IFE_Message::PutData( ) function). Errors are reported using ProblerrLReport( ) and the MainQueue is updated to control either a shutdown or retry, depending on the severity of the error. If it's error is severe enough, it exits the loop and the thread dies.","GetTotalMatrix( )returns the corresponding Action List from TotalMatrix for the current event and state of this process. It is called only by Sysmon::MainProcess( ).","The following State Machine routines are stored in the SmScript State Machine Tables (called FullActionItems) and are activated as a result of certain event\/state combinations via ProcessEventList( ):",{"@attributes":{"id":"p-0277","num":"0276"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PExternalKillProcess(\u2009)","Kills its associated external process with the"]},{"entry":[{},"TerminateProcess(\u2009) function. Called from"]},{"entry":[{},"the global PExternalKillProcess(\u2009) function."]},{"entry":["PGetProcessState(\u2009)","Returns the current state of this"]},{"entry":[{},"state-machine. Called from global"]},{"entry":[{},"PGetProcessState(\u2009)."]},{"entry":["PKillProcess(\u2009)","Issues IFE message to external process to"]},{"entry":[{},"commit suicide. Currently not supported by"]},{"entry":[{},"most external processes."]},{"entry":[{},"Called from global PKillProcess(\u2009)."]},{"entry":["PPostExternalKillProcess(\u2009)","Uses the QueueSorted::PutSorted(\u2009) function"]},{"entry":[{},"to schedule a Kill command to go into the"]},{"entry":[{},"MainQueue later. Called from global"]},{"entry":[{},"PPostExternalKillProcess(\u2009)."]},{"entry":["PSetState(\u2009)","Updates the current state of this"]},{"entry":[{},"state-machine. Called from global"]},{"entry":[{},"PSetState(\u2009)."]},{"entry":["PStartProcess(\u2009)","Gets the full pathname of the associated"]},{"entry":[{},"external process and starts executing it."]},{"entry":[{},"Called from global PStartProcess(\u2009)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The WatchDogDriver class contains code necessary to manage watchdog driver messages. The watchdog is a hardware component that is responsible for re-starting the line replaceable unit if it fails to receive input in regular intervals. Using this class ensures that the watchdog receives that input from the System Monitor  regularly, unless some system or software error prevents it. Commands available for use by Sysmon and Process objects are: Watch_Enable( ), Watch_Disable( ), Watch_Maintain( ) and Watch_Reboot( ). These functions all put the corresponding watchdog action command onto a DogQueue  for processing by DynQueueThread( ), which is the only function allowed to actually talk to the driver directly.","The Watchdog Driver  controls a watchdog device supplied by Octagon (called the Octagon PC-450) which, when activated by the System Monitor , reboots the system unless it is accessed no less than every 1.6 seconds by the watchdog driver . The driver  can receive a command to force a reboot of the system, which stops it from updating the watchdog driver . The watchdog driver  then times-out and a reboot occurs. Use of the watchdog driver  helps improve system availability in the event of a software or hardware anomaly that causes unpredictable results in system operation.","Sysmon::StartHandler( ) creates the WatchDogDriver object and calls its StartHandler( ) routine, which is responsible for launching two threads. One thread manages the I\/O with the watchdog hardware, and the other thread maintains the regular output commands to it.","WatchStaticThread( ) calls WatchDynamicThread( ) which places a request for a \u2018strobe\u2019 to the watchdog onto the DogQueue  (viaWatch Maintain( )). It then sleeps for 1,000 seconds and loops again.","StatQueueThread( ) calls DynQueueThread( ) which performs the actual output to the watchdog hardware, \u201c\\wdog\u201d. It reads a command request from the DogQueue queue  and calls either Watch_Enable_DO( ), Watch_Disable_DO( ), Watch_Maintain DO( ) or Watch_Reboot_DO( ) to perform the requested command using the WINDOWS DeviceIoControl( ) function.","The QueueSorted Class coordinates activity in the MainQueue . For example, it is sometimes necessary to schedule tasks to occur in the future (such as shutdown due to loss of power). To do this, QueueSorted provides the following functions. The QueueSorted( ) constructor creates its own queue and launches a thread, StatPutQueueThread( ) to monitor the queue periodically. The PutSorted( ) function allows users to add elements to the queue along with a timestamp indicating the time at which this element should be dealt with. The PutSorted( ) function puts them on the queue sorted by the timestamp so that they are dealt with in the proper order.","StatPutQueueThread( ) calls DynPutQueueThread( ) which loops forever, trying to process the elements on its queue. If the current time is less than or equal to the time of the element's timestamp, the element is moved to the MainQueue for processing by Sysmon::MainQueueProcessing( ). Even though it is scheduled, it is only placed at the end of MainQueue , not at the front. Therefore, it does not supercede any existing MainQueue elements.","The following common software libraries of functions and utilities are used throughout the primary access terminal  and cabin file server  applications.","The CAPI (RPC Client) Library , or RPCLIENT.DLL , provides a means of communication between the graphical user interface  and the rest of the system  through the primary access terminal NAU . The RPC Client Library  is shown in . The RPC Client Library , or RPCLIENT.DLL , comprises a ToExec Queue , a FromExec Queue , a FromGUI Queue , and an APIINT::CMSToGui Queue . The ToExec Queue  and FromExec Queue  are coupled to transmit and receive CGUIService::ProcessRequest( ) threads . The FromGUI Queue  is coupled to transmit various APIINT.CCP calls  to the CGUIService::ProcessRequest( ) threads . The APIINT.CCP calls  are derived from CAPI_C.C Calls  that are routed by way of the Ethernet network  from CAPI_S.C calls  in the Services.exe program  running in the cabin file server . The CGUIService::ProcessRequest( ) threads  route messages to and from a local transaction dispatcher . The APIINT::CMSToGui Queue  receives messages from the local transaction dispatcher and from a remote transaction dispatcher . Messages sent from the transaction dispatchers , , are forwarded to an APIINT::CAPIMessageInThreadProcedure( ):  which routes the messages to the CAPI Message Service Window .","The PAT GUI  cannot be communicated to via Named Pipes because it is a WINDOWS application, and must therefore communicate using standard WINDOWS messages. The CAPI Message Handler is a set of routines within the CAPI Library  which provides a bridge between the IFE messages and the GUI WINDOWS application. Instead of communicating via Named Pipes directly with the GUI, Unsolicited Messages  utilize Named Pipes into a Message Service Window . In order for the GUI  to be able to receive them, it must have already opened or started a Window capable of receiving this type of message in the background using the appropriate CAPI Library calls.","Any WINDOWS User Interface that needs to communicate with the transaction dispatcher(s)  of the primary access terminal  and\/or cabin file server , or who needs to access the CAPI calls in the SERVICE.EXE program of the cabin file server  needs to link in and use the RPCLIENT.DLL library  which contains the following files:",{"@attributes":{"id":"p-0289","num":"0288"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["APIINT.CPP","Dllmain(\u2009) and Visual Basic Application Interface"]},{"entry":[{},"Routines"]},{"entry":["CAPI_C.C","The CAPI's RPC Client Support Routines"]},{"entry":["HOOKSDLL.C","\u2018Canned\u2019 Dynamic Link Library \u2018glue\u2019 from"]},{"entry":[{},"MICROSOFT"]},{"entry":["CGUSRVCE.CPP","Core Gui (CGUIService) Class (connects to TD)"]},{"entry":["CPMSSGSR.CPP","CAPI_Message_Service Class"]},{"entry":["UNSLCTDM.CPP","Unsolicited_Message Class"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"APPIINT.CPP is the interface between the graphical user interface  (GUI or Main Application) and the rest of the system . In order to connect to the rest of the system , InitializeInterfaceVB( ) must be called to establish communications with the transaction dispatcher(s)  and start CAPI_Message_Service::GetTDInessage( ) threads, which receive all unsolicited messages from the transaction dispatcher(s) . A call to StartMessageSeruiceVB( ) launches a thread, CAPIMessageInThreadProcedure( ) to continuously read and process unsolicited messages obtained from the CMSToGui Queue, supported by the CAPI_Message Service class object.","The cabin file server  and the primary access terminal  have many similar functions such as message processors  and , transaction dispatchers  and , system monitors  and , and ARCNET drivers  and . The discussion of these functions in conjunction with the primary access terminal  presented above also applies to the cabin file server  with differences as noted. The cabin file server executive extension is discussed with reference to .","The cabin file server Executive Extension set of routines together with the Common Executive Software forms the generic application for the cabin file server . It includes the following components: Backbone NAU , Seat NAU , VCP NAU , Test Port NAU , High-Speed Download Driver , Services  including Cabin Services \u2013, \u2013 and Sales Services \u2013, CAPI calls , and the database , as shown in . The function and data paths of the many of the NAUs \u2013 have a structure substantially identical to the primary access terminal  structure shown and described with reference to  regarding the basic network addressable units function and data paths. The changes generally relate to the structure of the state machine objects that are used in the respective NAUs \u2013.","The detailed design of the cabin file server executive extension will now be discussed. The BACKBONE.EXE routine contains the backbone NAU program .  illustrates the backbone NAU program  function and data paths. The backbone NAU  is responsible for receiving and processing messages that originate from the audio-video units , area distribution boxes , passenger entertainment system controllers PESC-A and the PESC-V , and any other communications backbone line replaceable unit. The structure of the backbone NAU  is substantially the same as the network addressable unit  function in the primary access terminal  and data paths discussed with reference to . The backbone NAU  comprises a PESC-V NAU dispatcher and PESC-V and PESC-AP VLRU state machine objects shown in . The backbone NAU program  includes the following primary components:",{"@attributes":{"id":"p-0294","num":"0293"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BACKBONE.CPP","The Main(\u2009) Program"]},{"entry":[{},"PSCPDSPT.CPP","The NAU Dispatcher for the PESC-A"]},{"entry":[{},"PSCVDSPT.CPP","The NAU Dispatcher for the PESC-V"]},{"entry":[{},"PSCPVLRU.CPP","The VLRU Class for the PESC-A"]},{"entry":[{},"PSCVVLRU.CPP","The VLRU Class for the PESC-V"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The Main( ) program is a standard NAU starter that registers the Backbone NAU  with the system monitor  using a SysMonInterfaceClass::Register( ) routine.","The Main( ) program launches a PescV_Dispatch object to open up PESC-V VLRU communications between the message processor  and the transaction dispatcher , and a PescAp_Dispatch object as well to launch the PESC-A . It calls PescV_Dispatch::startItUp( ) to initialize both of the VLRUs.","The Main( ) program launches 14 Session( ) threads, although only three are actually in use. It sends a SubProcessStart command to the VLRUs which causes the first Session( ) threads in to connect to each VLRU permanently. Only the PescV_Dispatch object maintains a set of MPRight( ), MPLeft( ), TDRight( ) and TDLeft( ) threads.","Finally, the Main( ) program sleeps forever until interrupted. It does not call shutItDown( ) to close all the VLRUs down and exit gracefully. Instead, it simply deletes the PescV_Dispatch object and dies.","The VLRUs in this NAU contain their own set of NAUPutTD( ), NAUPutMP( ), NAUGetTD( ) and NAUGetMP( ) routines because they use I\/O routines from the PESCA_Message class and PESCV_Message class instead of the IFE_Message class.","The PescAp_VLRU object attaches directly to the first Session( ) possible via its StartItUp( ) function. Then it continuously loops waiting for data to appear in its message processor and transaction dispatcher input queues. It processes the following commands:","FlightInfoRequest IFE Function from the PESC-A . This VLRU creates its own IFE message to the IFE Control Service asking for Flight Information.","FlightInfoUpdate IFE Function from the IFE Control Service, after the PESC-A issues it a FlightInfoRequest. This VLRU creates its own IFE message to forward this to the PESC-A via the message processor .","PES_CONTROL command from the PESC-A . This VLRU examines the state of the WeightOnWheels using PESCA_Message::IsGearCompressed( ). If the state of the wheels has changed, it forwards this new information to the database using NotifyNewFlightState( ), and to the CAPI Message Service via its own NAUPutTD( ). All other messages are ignored.","The PescV_VLRU object attaches directly to the first Session( ) possible via its StartItUp( ) function. Then, it continuously loops waiting for data to appear in its message processor  and transaction dispatcher  input queues. It processes the following commands:","VideoControl command from IFE Control Services is formatted and forwarded to PESC-V . Any other message from PESC-V is routed directly to the IFE Control Services.","The Seat NAU program  function and data paths are depicted in . The Seat NAU  controls communication with the seats in the aircraft . It maintains three kinds of VLRUs: one that controls high speed download of games and programs to the seats ; one that periodically broadcasts status messages to the seats , and one for each seat  to communicate during the flight for sales and other requests.","The structure of the Seat NAU  is substantially the same as the Network Addressable Units function and data paths discussed with reference to . However, the Seat NAU  also includes VLRU state machine objects comprising an HSDLInterface VLRU , a SeatInterface VLRU , and a SeatBroadcast VLRU .","The HSDLInterface VLRU  comprises a ProcessFileChanges( ) , ProcessDownloads( ) , and a RefreshThread( ) . The SeatInterface VLRU  comprises a Crank( ) , a SessionQueueLeft , and a SessionQueueRight . The SeatBroadcast VLRU  comprises a PendingSessionMonitor( ) and a WheelStatusMonitor( ) ","SEAT.EXE contains the Seat NAU program . This program includes the following primary components:",{"@attributes":{"id":"p-0310","num":"0309"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["NAUMAIN.CPP","The Main(\u2009) Program"]},{"entry":["HSDLDSPT.CPP","The High Speed Download NAU Dispatcher"]},{"entry":["STDSPTCH.CPP","The Seat NAU Dispatcher"]},{"entry":["STNTRFCE.CPP","The Seat VLRU Class"]},{"entry":["SESSION.CPP","The Service Session Class"]},{"entry":["STBRDCST.CPP","The Seat Broadcast VLRU Class"]},{"entry":["HSDLNTRF.CPP","The HSDL VLRU Class"]},{"entry":["DWNLDFLN.CPP","For HSDL, the DownLoadFileInfo Class"]},{"entry":["FILEMAP.CPP","For HSDL, The FileMap Class"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A VLRU Session is characterized by the NAU::Session( ) threads, one for each VLRU that may be active concurrently. A Service Session is characterized by the Session class that controls a stream of communications between a single seat and a Service (such as a Sales Service). This stream may include several messages back and forth before a Service Session is complete.","The Main Program is a standard NAU starter.Main( ) registers this program with the System Monitor  using the SysMonlnterfaceClass::Register( ) routine. For test purposes only, if any parameter is passed to this program, it bypasses this step.","The Main Program creates a HDSLDispatch object to open up communications between the message processor  and the transaction dispatcher  and create the High Speed Download VLRU . Then the Main Program creates the SeatDispatch object to create all the SeatInterface VLRUs  and the SeatBroadcaster VLRU . The Main Program launches 14 Session( ) threads  that are shared by all the VLRUs. A typical number of Sessions is 14 including 10 seats' Service Sessions, plus HSDL, plus Broadcast, plus two more to control seats that are waiting for a Service Session to free up (pending seats). The Main Program calls NAUDispatch::startItUp( )  to initialize the VLRUs with a SubProcessStart command.","The HSDLDispatch file defines a MPRightHook( ) function to be called within the NAUDispatch::MPRight( ) thread prior to processing the incoming message from the message processor . It uses this hook function to intercept the High Speed Download Request messages and route them to the HSDL VLRU  instead of to the Seat VLRU , where its LRU address would normally send it. This reduces traffic to the 10 Sessions( )  reserved for the seats.","Finally, Main( ) sleeps forever until interrupted. It does not call shutItDown( ) to close all the VLRUs down and exit gracefully. Instead, it simply deletes the NAU Dispatch and dies.","The SeatInterface VLRU  is responsible for processing requests from the seats  such as ordering a movie or a game. It routes these requests to the applicable Service via the Transaction Dispatcher . One VLRU for each seat  in the system exists; however, only 10 VLRUs at a time may actively be engaged in a communication session between seat  and Service.","Each SeatInterface VLRU  has a Session object that it uses as its state machine. Its StartItUp( ) function loops continuously as long as it is actively engaged within a session (that is, the session state is not idle), looking for one of the following events: Data from the message processor , Data from the transaction dispatcher , an NAU TIMEOUT, an NAU RUN IMMEDIATE, a NAU AUX, a SessionQueue.Right or SessionQueue. Left events. It passes any TD messages on to the seat display unit  provided they do not affect the State of the VLRU. StartItUp( ) then calls Session::Crank( ) to process one event from the SessionQueue.Right queue. Once it has been processed, StartItUp( ) forwards any message that may be waiting in SessionQueue.Left (sending it out to the message processor  or transaction dispatcher ), then determines what to do with the input event that got it going (from the message processor , transaction dispatcher , Timeout etc.). Usually, it simply puts it in SessionQueue.Right, which re-triggers StartItUp( ) to again call Session::Crank( ) until all events and\/or messages are processed. Once the processing is \u2018complete for this VLRU\u2019s Session, StartItUp( ) exits, to give the session thread to another seat. It uses MessageToEvent( ) to convert a Seat_Message into its corresponding Event value, and it uses EventToMessage( ) to develop an appropriate outgoing message based on the current VLRU Event.","StartItUp( ) also processes the following control messages:",{"@attributes":{"id":"p-0319","num":"0318"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["IFE Message","Action"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["StartStatisticsCapture","Sent by the SeatBroadcast thread when"]},{"entry":[{},"WeightOnWheels is detected, uses"]},{"entry":[{},"timedCallback::queue(\u2009) to set a timer to a"]},{"entry":[{},"random value to cause the Statistics request"]},{"entry":[{},"to go to the seat after the timeout."]},{"entry":[{},"This prevents all seats from processing"]},{"entry":[{},"the request at the same time (as it would from a"]},{"entry":[{},"broadcast), to keep the traffic on the network"]},{"entry":[{},"less congested."]},{"entry":["SubProcessReinit","Re-Initializes tables via Initialize(\u2009)."]},{"entry":["SubProcessStart","Starts the State Machine for this VLRU,"]},{"entry":[{},"putting it into the  state."]},{"entry":["SubProcessStop","Exits."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"At a minimum, a seat transaction requires sending a message to a service  and receiving an answer back. However, if it is a complex transaction (for example, a multiple-product merchandise order), several messages are routed before the entire transaction is complete. Because  seats  may be all communicating at the same time, the basic design of communications flow from the seat  to the services  and back can get highly fragmented when these complex transactions are involved. To minimize this fragmentation (and thus create the appearance of faster response at the seats), the Service Session protocol has been developed.","Supported by the Session class and the SDU interface, this protocol requires a seat  to open a session (or tap dibs) with the Seat NAU  before a transaction can take place. Only 10 Sessions  are supported simultaneously (controlled in the Session constructor by hSessionSemaphore), so if they are all busy, a Pending message is returned to the seat  to tell it to wait, and the seat's ID is kept on the SeatInterface::PendingSeats queue. Once a seat has a Session  assigned to it, it can communicate freely with the Service  via the NAU  until it closes or releases the Session.","The following table illustrates a Sample Session Communication Flow.",{"@attributes":{"id":"p-0323","num":"0322"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Seat","Seat NAU","Sales Service"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Session Control -",{},{}]},{"entry":"OPEN>"},{"entry":[{},"<Session Status -"]},{"entry":[{},"Pending"]},{"entry":"Session Control -"},{"entry":"SDU Pending>"},{"entry":[{},"<Session Status -"]},{"entry":[{},"Opened"]},{"entry":"Transaction"},{"entry":"Command -"},{"entry":"Order>"},{"entry":[{},"Transaction Command -"]},{"entry":[{},"Order>"]},{"entry":[{},{},"<Transaction Status -"]},{"entry":[{},{},"Ordered"]},{"entry":[{},"<Transaction Status -"]},{"entry":[{},"Paid"]},{"entry":"Transaction"},{"entry":"Command -"},{"entry":"Order>"},{"entry":[{},"Transaction Command -"]},{"entry":[{},"Order>"]},{"entry":[{},{},"<Transaction Status -"]},{"entry":[{},{},"Ordered"]},{"entry":[{},"<Transaction Status -"]},{"entry":[{},"Paid"]},{"entry":"Session Control -"},{"entry":"Close>"},{"entry":[{},"<Session Status -"]},{"entry":[{},"Closed"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Each SeatInterface VLRU  has a Session class, called the_Session to support this which uses an EventStateTable that keeps track of the action to perform for any given Event and\/or State. Each action is maintained as a separate function whose name begins \u201cAc\u201d (e.g., AcTerminateSelf( )). These Action functions are all static BOOL functions that need the current Session and Event pointers passed to them to operate. They are called by the function Crank( ) after it looks them up in the EventStateTable.","The following state table, called \u201cAction\u201d in the software, shows the relationship between the States, Events, Actions and changed or new states, sorted by From-State. Using this table, one can see how a Seat's Session moves from one state to another, which events can trigger the change and what actions are performed to cause the change. In the software, the events are prefixed with \u201cEv\u201d (such as \u201cEvSelfBackOut\u201d), actions with \u201cAc\u201d (such as \u201cAcBackOut\u201d) and states with \u201cSt\u201d (such as \u201cStBackOut\u201d). These prefixes are omitted from the table below for easier reading.",{"@attributes":{"id":"p-0326","num":"0325"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["From-State","Event Trigger","Action Function","To-State"]},{"entry":["(St. . .)","(Ev. . .)","(Ac. . .)","(St. . .)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BackOut","SelfBackOut","BackOut","BackOut"]},{"entry":["BackOut","ServiceBackedOut","BackOut","BackOut"]},{"entry":["BackOut","SelfBackOutDone","BackOutDone","Opened"]},{"entry":["CancelPending","ServiceCanceled","ServiceGeneralAction","Opened"]},{"entry":["CancelPending","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["Closed","SelfClosed","SessionNormal-Terminate","Terminated"]},{"entry":["Closed","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["CompleteUpdate","SDUGetNext-","SendTransaction-","Complete-"]},{"entry":["ByCommand","Transaction","Update","UpdatePending"]},{"entry":["Complete-UpdatePending","SDUGetNext-Transaction","SendTransaction-Update","CompleteUpdate-Pending"]},{"entry":["Complete-UpdatePending","SelfUpdateDone","TransactionUpdate-Complete","Opened"]},{"entry":["Complete-UpdatePending","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["DeliveryPending","ServiceDelivered","ServiceGeneralAction","Opened"]},{"entry":["DeliveryPending","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["End","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["Foo","SDUPending","SessionNotAvailable","Paused"]},{"entry":["Incremental-Update","SDUGetNext-Transaction","SendTransaction-Update","Incremental-UpdatePending"]},{"entry":"ByCommand"},{"entry":["Incremental-UpdatePending","SDUGetNext-Transaction","SendTransaction-Update","Incremental-UpdatePending"]},{"entry":["Incremental-UpdatePending","SelfUpdateDone","Transaction-UpdateComplete","Opened"]},{"entry":["Incremental-UpdatePending","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["Opened","SDUCancel","SDUGeneralAction","CancelPending"]},{"entry":["Opened","SDUClose","SessionClose","Closed"]},{"entry":["Opened","SDUDeliver","SDUGeneralAction","DeliveryPending"]},{"entry":["Opened","SDUOpen","DoNothing","Opened"]},{"entry":["Opened","SDUStatisticsData","Statistics","Opened"]},{"entry":["Opened","SDUSurveyData","Survey","Opened"]},{"entry":["Opened","SDUOrder","SDUOrder","OrderPending"]},{"entry":["Opened","SDURefund","SDUGeneralAction","RefundPending"]},{"entry":["Opened","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["Opened","SDUCompleteUpdate","DetermineUpdate-TypeNeeded","UpdateType-Pending"]},{"entry":["Opened","SDUIncremental-Update","DetermineUpdate-TypeNeeded","UpdateType-Pending"]},{"entry":["Opened","SDUUpdateRequest","DetermineUpdate-TypeNeeded","UpdateType-Pending"]},{"entry":["Ordered","SelfDeliverOnOrder","ServicePaid","Opened"]},{"entry":["Ordered","SDUPayment","SDUPayment","PaidPending"]},{"entry":["Ordered","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["OrderPending","ServiceOrdered","ServiceOrdered","Ordered"]},{"entry":["OrderPending","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["PaidPending","ServiceNotPaid-ForReason","ServiceNotPaid","BackOut"]},{"entry":["PaidPending","ServicePaid","ServicePaid","Opened"]},{"entry":["PaidPending","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["Paused","SDUOpen","SessionOpenNow","Waiting"]},{"entry":["Pending","SelfSystem-NotAvailable","SystemNotAvailable","Closed"]},{"entry":["Pending","SelfSession-NotAvailable","SessionNotAvailable","Foo"]},{"entry":["Pending","SelfSession-Available","SessionAvailable","Opened"]},{"entry":["Pending","SDUOpen","SessionTryToOpen","Pending"]},{"entry":["Pending","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["RefundPending","ServiceRefunded","ServiceGeneralAction","Opened"]},{"entry":["RefundPending","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["SessionInit","SDUClose","SessionNormal-Terminate","Closed"]},{"entry":["SessionInit","SDUOpen","SessionTryToOpen","Pending"]},{"entry":["SessionInit","Terminate-Immediatly","SessionInit","SessionInit"]},{"entry":["SessionInit","SDUTerminate","SessionAbnormal-Terminate","Terminating"]},{"entry":["SessionInit","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["SessionInit","SelfStatisticsNotify","SendUpdate-NotifyToSDU","UpdateNotify-AckPending"]},{"entry":["SessionInit","ServiceComplete-UpdateNotify","SendUpdate-NotifyToSDU","UpdateNotify-AckPending"]},{"entry":["SessionInit","ServiceInc-UpdateNotify","SendUpdate-NotifyToSDU","UpdateNotify-AckPending"]},{"entry":["SessionInit","ServiceIncUpdate-NotifyWithRevoke","SendUpdate-NotifyToSDU","UpdateNotify-WithRevoke-"]},{"entry":[{},{},{},"AckPending"]},{"entry":["Start","Start","SessionInit","SessionInit"]},{"entry":["Start","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["Terminated","SelfReinitialize","SessionInit","SessionInit"]},{"entry":["Terminated","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["Terminating","SelfTerminated","Terminated","Terminated"]},{"entry":["Terminating","SelfTimeOut","GeneralTimeOut","Terminating"]},{"entry":["TVOffAck-Pending","SelfTimeOut","UpdateNotifyTimeOut","DontChangeState"]},{"entry":["TVOffAck-Pending","SDUTVOffAck","ServiceUpdate-NotifyComplete","SessionInit"]},{"entry":["TVOffAck-Pending","SelfCancel-UpdateNotify","DoNothing","SessionInit"]},{"entry":["UpdateNotify-AckPending","SelfTimeOut","UpdateNotifyTimeOut","DontChangeState"]},{"entry":["UpdateNotify-AckPending","SDUUpdateNotify-AckFromSDU","ServiceUpdate-NotifyComplete","SessionInit"]},{"entry":["UpdateNotify-AckPending","SDUUpdateNotify-AckFromSI","ServiceUpdate-NotifyComplete","SessionInit"]},{"entry":["UpdateNotify-AckPending","SelfCancel-UpdateNotify","DoNothing","SessionInit"]},{"entry":["UpdateNotify-","SelfTimeOut","UpdateNotifyTimeOut","DontChangeState"]},{"entry":"WithRevoke-AckPending"},{"entry":["UpdateNotify-","SDUUpdateNotify-AckFromSI","SendTVOff","TVOffAckPending"]},{"entry":"WithRevoke-AckPending"},{"entry":["Update-TypePending","SelfCompleteType","SendUpdateType","CompleteUpdate-ByCommand"]},{"entry":["UpdateType-Pending","SelfIncrementalType","SendUpdateType","Incremental-UpdateBy-"]},{"entry":[{},{},{},"Command"]},{"entry":["Waiting","SelfSessionAvailable","SessionAvailable","Opened"]},{"entry":["Waiting","SelfSession-NotAvailable","SessionNotAvailable","Waiting"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"All possible From-State\/Event Trigger combinations are not represented in the Action table. Many do-nothing or illogical combinations need to default. For that reason, the Action table is used to fill in a larger, more comprehensive table called the EventStateTable. This two-dimensioned table uses the values of From-State and Event Trigger as indexes, and defaults the illogical values to either do nothing or to terminate.","A typical session flow (with no errors) to place an order would start and end in the SessionInit state as shown below:",{"@attributes":{"id":"p-0329","num":"0328"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["From-State","Event Trigger","Action Function","To-State"]},{"entry":["(St. . .)","(Ev. . .)","(Ac. . .)","(St. . .)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Start","Start","SessionInit","SessionInit"]},{"entry":["SessionInit","SDUOpen","SessionTryToOpen","Pending"]},{"entry":["Pending","SelfSessionAvailable","SessionAvailable","Opened"]},{"entry":["Opened","SDUOrder","SDUOrder","OrderPending"]},{"entry":["OrderPending","ServiceOrdered","ServiceOrdered","Ordered"]},{"entry":["Ordered","SDUPayment","SDUPayment","PaidPending"]},{"entry":["PaidPending","ServicePaid","ServicePaid","Opened"]},{"entry":["Opened","SDUClose","SessionClose","Closed"]},{"entry":["Closed","SelfClosed","SessionNormalTerminate","Terminated"]},{"entry":["Terminating","SelfTerminated","Terminated","Terminated"]},{"entry":["Terminated","SelfReinitialize","SessionInit","SessionInit"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Each Session  has a SessionQueue queue pair that is used to store the Events to perform for this Session's State Machine. The SessionQueue's Right queue stores incoming message\/event pointers for Session::Crank( ) to process, while its Left queue stores outgoing event\/message pointers for SeatInterface::StartItUp( )  to forward to either the message processor  or the transaction dispatcher  or timeouts as appropriate.","The SeatBroadcast VLRU  is a child of the SeatInterface class so that it can help monitor the seat communication traffic for the other SeatInterface objects. It is responsible for sending messages to more than one seat or more than one SeatInterface VLRU . Only one message is actually sent in a broadcast to the seats with the destination set to \u201cAllSeats\u201d. It uses the CalledTimeOut utilities to create a TimeOut Thread called SeatBroadcastTimeout( ) to force periodic, unsolicited broadcasts. It also launches the PendingSessionMonitor( ) and WheelStatusMonitor( ) threads ","It's StartItUp( )  function loops forever, retaining possession of one of the Session( )  threads. It continuously monitors messages and processes the following events or messages:",{"@attributes":{"id":"p-0333","num":"0332"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Message or Event","Action"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CPMS Message","Tells all SDU-SI boards the current status"]},{"entry":[{},"of the HSDL Queue. Retriggers the"]},{"entry":[{},"HSDLInterface::ProcessDownLoadQ(\u2009)"]},{"entry":[{},"event."]},{"entry":["MovieTimes Message","Tells the MP what the Movie Run Times are"]},{"entry":["NAU_TIMEOUT Event","Triggers every tenth of a second using the"]},{"entry":[{},"timedCallback::queue(\u2009) function. When"]},{"entry":[{},"received, this broadcasts a"]},{"entry":[{},"\u201cSession Complete\u201d message to all seats if"]},{"entry":[{},"a Service Session has just completed, so"]},{"entry":[{},"they can retry communications, if needed."]},{"entry":["ProcessRemit Message","Tells all VLRUs to \u201cSubProcessReinit\u201d."]},{"entry":["SeatTransfer Message","Uses ProcessSeatTransfer(\u2009) to parse and"]},{"entry":[{},"forward this message to the two"]},{"entry":[{},"SeatInterface VLRUs that are involved"]},{"entry":[{},"in the transfer."]},{"entry":["SubProcessStart Message","Tells all VLRUs to \u201cSubProcessReinit\u201d."]},{"entry":["SubProcessStop Message","Stops the Timeout thread and ends the"]},{"entry":[{},"program."]},{"entry":["Weight_On_Wheels Event","Tells all VLRUs to Start Statistics Capture,"]},{"entry":[{},"now that the aircraft has landed"]},{"entry":[{},"(ending flight)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The PendingSessionMonitor( ) has nothing to do with Seat Broadcasting: It is a supplement to the normal SeatInterface processing. This monitor continuously waits for a Seat  to be put onto the static SeatInterface::PendingSeats queue (by any of the other SeatInterface::StartItUp( ) threads), and then waits until one of the Seat Sessions is available for processing. Then it puts this Seat ID onto the AuxFifo queue to be taken by the next available Session( ) thread .","The WheelStatusMonitor( ) is a High Priority thread that waits for a signal from the PESC-A VLRU in the Backbone NAU, which pulses the Weight On Wheels or the Weight Off Wheels events when their status changes. This monitor forwards this event information to the StartItUp( )  to process when it next loops.","The HSDLInterface VLRU  is a standard NAU child dedicated to servicing all download requests for games or application programs by the seats. Its constructor connects to the driver, \u201cHSDL1\u201d to transmit data to the seats via the Digitized Video Multiplexer system. The constructor also prefills a CRC Table used for deriving the CRC values during downloads. It creates a Mutex to control access to the HSDL directory to ensure that the routines in COPYDNL.CPP and SDU_BLDR.CPP don't interfere with the download process by modifying the files in the download directory at the wrong time.","The StartItUp( )  routine launches the following threads:",{"@attributes":{"id":"p-0338","num":"0337"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Thread","Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ProcessFileChanges(\u2009)","Reacts to changes in the NT Registry as well as"]},{"entry":[{},"changes in the Download Files Directory."]},{"entry":[{},"It then calls ProcessEntireDirectory(\u2009) to"]},{"entry":[{},"read the directory that contains the files that"]},{"entry":[{},"can be downloaded, creating a"]},{"entry":[{},"DownLoadFileInfo object for each, and placing"]},{"entry":[{},"all download files in the ConvertQ for"]},{"entry":[{},"RefreshThread(\u2009) to handle. This thread places"]},{"entry":[{},"all programs and database files ahead of"]},{"entry":[{},"games in the ConvertQ so that the Seats"]},{"entry":[{},"can be ready for use as soon as possible."]},{"entry":["RefreshThread(\u2009)","Looks for files in the ConvertQ queue to"]},{"entry":[{},"prepare for later downloading. Calls"]},{"entry":[{},"DownLoadFileInfo::Refresh(\u2009) to block"]},{"entry":[{},"the data and add checksums and CRCs for Seat"]},{"entry":[{},"verification. It also saves the identity of the"]},{"entry":[{},"requesting seat for communication during the"]},{"entry":[{},"actual download."]},{"entry":["ProcessDownLoads(\u2009)","This thread is launched at a low priority, so that"]},{"entry":[{},"the others can prepare all the files beforehand."]},{"entry":[{},"It calls ProcessDownloadQ(\u2009) to use"]},{"entry":[{},"SeatInterface::GetDownLoadInstruction(\u2009) to"]},{"entry":[{},"handle this file properly. Calls"]},{"entry":[{},"DownLoadFileInfo::Download(\u2009) for"]},{"entry":[{},"each file in the DownLoadQ to actually send"]},{"entry":[{},"them to the output driver. During the"]},{"entry":[{},"download, it redirects message handling away"]},{"entry":[{},"from the seats SEB and toward its SDU"]},{"entry":[{},"I\/F board because the seat display unit 122a"]},{"entry":[{},"can't receive messages without its application"]},{"entry":[{},"running, which is true whenever it is receiving"]},{"entry":[{},"a download."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Then StartItUp( ) calls ProcessIOQueues( ) to continuously sample the message processor and transaction dispatcher input queues. It processes the following message processor messages:",{"@attributes":{"id":"p-0340","num":"0339"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["IFE Message","Action"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["HighSpeedDownload","Puts the download request onto the DownLoadQ."]},{"entry":[{},"It moves a request to the top of the queue if the"]},{"entry":[{},"request is for a program (high priority)."]},{"entry":["SubProcessStart","Simply recognizes this command, no further"]},{"entry":[{},"processing."]},{"entry":["SubProcessStop","Flushes its MP and TD Input queues and tells the"]},{"entry":[{},"DestructFifo queue (one of the few VLRUs to"]},{"entry":[{},"use this) that it can be shut down."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The VCP NAU controls communications with the video players and other video sources. It maintains one VLRU for each video source, and constantly polls the players for their status. The VCP Network Addressable Unit program  function and data paths are shown in . The structure of the VCP NAU  is substantially the same as the Network Addressable Units function and data paths discussed with reference to .","VCP.EXE contains the VCP NAU program. This program includes the following primary components:",{"@attributes":{"id":"p-0343","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VNUMAIN.CPP","The Main(\u2009) Program"]},{"entry":[{},"VCPDSPTCH.CPP","The NAU Dispatcher"]},{"entry":[{},"VCPNTRFC.CPP","The VCP VLRU Interface Class"]},{"entry":[{},"VCPSTSVL.CPP","The VCP Status VLRU Class"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Main( ) issues a call to GetLruInfo( ) to read the database  for all the VCP names (e.g., \u201cVCP01\u201d). It then launches a VCPDispatch object to open up communications between the message processor  and the transaction dispatcher . It calls VCPDispatch::startItUp( ) to initialize the VLRUs, one for each video cassette player  plus one for periodic statusing of all video cassette players . It also launches the Session( ) threads .","Main( ) then calls. ConsoleCmd( ) to process all console characters that may be in the input buffer. If \u201cS\u201d is encountered, a STOP command is issued to VCP01. If \u201cP\u201d is encountered, a PLAY command is issued to VCP01. This is for testing purposes only.","Finally, Main( ) sleeps forever until interrupted. It calls shutItdown( ) to close all the VLRUs down and exit gracefully.","A VCP VLRU is created for each video cassette player  in the database  using the VCPInterface Class. This class is derived from the Generic NAU Class; however, due to the communications protocol employed by the players, many of the generic functions are overcast or not used at all.","The VCPInterface( ) constructor creates two unique controllers: Static hIOSemaphore and bHasSemaphore. These are used to enforce single-threaded communications between a video cassette player  and the transaction dispatcher . Using these controllers, only one VLRU can be processing communications at a time. hIOSemaphore is a handle that acts as \u2018dibs\u2019: When this handle is owned by a thread, that thread can process communications. bHasSemaphore is a local flag that tells the thread whether it currently is the owner of the semaphore.","VCPInterface::StartItUp( ) is called immediately for each Session( ) to process a \u2018dummy\u2019 message from the message processor  for each of the video cassette players . This \u2018dummy\u2019 message was invoked at their creation to glue each video cassette player  to its own Session.","This function then loops forever to continuously process messages. The basic loop does the following:","If this session does not have dibs, it waits for input from the transaction dispatcher  and waits for the hIOSemaphore. Then it flushes all possible input from the message processor , reads the transaction dispatcher message and transmits it to the message processor . It retains ownership of the I\/O handle, and loops again.","If this session already has dibs (from the previous paragraph), it waits for input from the message processor . Once received, it processes it and sends an acknowledgement back to the video cassette player  via the message processor . It then releases dibs for use by the other VLRUs.","A single VLRU of class VCPSts_VLRU is created to periodically poll the players for their status. Two lists of information are used to organize this: MessageMap, that contains a list of each video cassette player  and its network address; PendingStatus, that contains a list of video cassette players  that have just completed a communications event. MessageMap is maintained via AddVLRU( ) as each VCP VLRU is created by the dispatcher. PendingStatus is maintained by XmitResponse( ) each time the VCP VLRU completes a communications event.","VCPSts_VLRU contains a timeout function that is invoked approximately 10 times per second. The StartItUp( )  function is immediately invoked and tied permanently to a Session( )  thread. It then loops forever waiting for both a timeout to occur and the hIOSemaphore to be available. Once both events have occurred, it examines the contents of the PendingStatus string list and prompts the topmost video cassette player  on this list for its status. If none are on this list, it prompts the next video cassette player  in the MessageMap list. This is performed via SendStatus( ). These status responses are formatted and forwarded to the Video Control Service via the transaction dispatcher . The I\/O semaphore is released and the process cycle repeats.","The Test Port NAU program  function and data paths is shown in . The Test Port NAU  controls communications to the serial test port for BIT\/BITE and MAINT system access. The structure of the Test Port NAU  is substantially the same as the Network Addressable Units function and data paths discussed with reference to . However, the Test Port NAU  includes NAU VLRU state machine objects comprising a LoopbackThread( ) , a EthernetThread( ) , a VCPStatusThread( ) , and a Loopback Timout( )  that are initiated by StartItUp( ) .","The Test Port NAU program  has two exclusive behaviors: BIT test mode and BITE test mode. The Test Port NAU program  starts out in BIT mode, and upon receipt of a GO_BITE command (presumably from the PESC-A ), it attempts to switch to BITE mode. BITE test mode is only available while the aircraft  is on the ground (as indicated by weight-on-wheels).","A BITE test is a three-pass \u2018loopback\u2019 in which data is sent to one of the I\/O devices (the primary access terminal  to test the Ethernet network , a PESC-A to test the ARCNET , and VCP Status Service to test video cassette players ) and an answer is expected back.","BIT tests are continuously occurring \u2018loopback\u2019 tests, however  consecutive failed communications are needed before a fault is recorded for any I\/O device. A BIT test failure is only reported once per device per flight.","All BIT\/BITE information is forwarded to a \u2018depository\u2019 or line replaceable unit that stores the information. In addition, BITE tests are initiated by an outside source or BITE Host. The default value for both of these is the primary PESC-A , however, a SET_DEPOSITORY command executes SetBITEDepository( ) to alter these values.","TESTPORT.EXE contains the Test Port NAU program . The Test Port NAU program  includes the following primary components:",{"@attributes":{"id":"p-0361","num":"0360"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TESTPORT.CPP","The Main(\u2009) Program"]},{"entry":[{},"TSTPRTDS.CPP","The NAU Dispatcher"]},{"entry":[{},"TSTPRTVL.CPP","The VLRU Class"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The Main Program is a standard NAU starter. Main( ) registers the program with the System Monitor  using the SysMorLInterfaceClass::Register( ) routine. Main( ) launches a TestPortDispatch object to open communication between the message processor  and the transaction dispatcher  and calls TestPortDispatch::startItUp( ) to initialize the VLRU. Main( )launches twoSession( ) threads , although only one is actually busy. Main( ) sends a SubProcessStart command to the TestPort VLRU which causes the first Session( ) thread to connect to the VLRU permanently. Finally, Main( ) sleeps forever until interrupted. Main( ) does not call shutItDown( ) to close all the VLRUs down and exit gracefully, it deletes the VLRU and dies.","A single Test Port VLRU is created using the TestPortVLRU Class. This class is derived from the Generic NAU Class, however it overcast the communications routines to support the TestPort_Message Class data routines. This constructor reads the database to develop a table of all Test Port LRUs, PESC LRUs, Process LRUs, ADB LRUs and ALAC LRUs. This table of LRU addresses is passed to the TestPort VLRU for reference in GetSourceAddress( ) and SetBITEDepository( ).","TestPortVlru::StartItUp( ) is called immediately for the first Session( ) to process a \u2018dummy\u2019 message from message processor . This \u2018dummy\u2019 message is invoked at their creation to glue the VLRU to a Session (a SubProcessStart message).","The VLRU then creates a set of 6 events used to communicate to 3 new threads:",{"@attributes":{"id":"p-0366","num":"0365"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Thread Name","Event 1","Event 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ARCNET LoopbackThread","Message","Abort"]},{"entry":[{},"EthernetThread","Message","Abort"]},{"entry":[{},"VCPThread","Message","Abort"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"This function loops forever to continuously process messages to-and-from the message processor . As a message is received, it is tested for validity, and then passed to the appropriate thread via a Message Event. Typically, the Message Events are used to determine what to do next, however to end BITE mode testing, the Abort Event is triggered for each thread to stop BITE testing, making BIT testing possible again.","StartItUp( )  uses the TimedCallback Utility Class to periodically launch LoopbackTimeout( ) which is responsible for issuing a command to the ARCNET network , the primary access terminal  and the VCP Service to initiate a \u2018loopback\u2019 test, in that it causes these devices to respond. Failure to respond within a specified timeframe causes the associated thread to log that device as FAILED. The initiation is accomplished by calling PerformLoopback( ). It uses its own versions of NAUPutMP( ) and NAUPutTD( ) to communicate because it needs to use the TestPort_Message class instead of IFE_Message class routines to process the data.","When an event is received, the LoopbackThread( ) Thread process calls ProcessLoopback( ) to fully process the event. It tests ARCNET by communicating with the PESC-A . If the PESC-A fails to respond within a given timeframe, it times out, causing a failure to be noted. In order to efficiently load programs, data and video games in the seats , the high-speed download driver  in  provides the ability to convert this information into a synchronous data link control (SDLC) data stream. This data stream is forwarded to the video modulator (VMOD) to broadcast to all seats  via the RF distribution system. Any seat  that requires the download can then tune to the download channel and retrieve the information. HSDL.SYS is the high speed down load driver, written in C as a standard WINDOWS NT driver.","HSDL.SYS is the High Speed DownLoad driver, written in C as a standard WINDOWS NT driver, and includes the following files:",{"@attributes":{"id":"p-0371","num":"0370"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CONFIG.C","Code for the initialization phase of the HSDL device"]},{"entry":[{},"driver."]},{"entry":["DISPATCH.C","Code for the function dispatcher."]},{"entry":["DMA.C","Code for input and output which is non-hardware"]},{"entry":[{},"specific."]},{"entry":["HARDWARE.C","Code for communicating with the Zilog 85230"]},{"entry":[{},"processor on the HSDL card."]},{"entry":["HSDLLIB.C","Common code for HSDL Kernel mode device drivers."]},{"entry":["INIT.C","Code for an initialization phase of the HSDL device"]},{"entry":[{},"driver."]},{"entry":["ISR.C","Code for an Interrupt Service Routine for the"]},{"entry":[{},"HSDLBlaster device driver."]},{"entry":["REGISTRY.C","Common code for Sound Kernel mode device drivers"]},{"entry":[{},"for accessing the registry."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The HSDL device is a Zilog 85230 Enhanced Serial Communications Controller (ESCC), which is an industry-standard serial controller. HSDL is a Synchronous Data Link Control (SDLC) data stream running at 409.6 Kbps with 514-byte frames using FM0 (biphase space) data encoding. To move the data as quickly as possible, DMA transfers are employed.","The driver is registered as \u201c\\\\HSDL1\u201d and the following NT driver commands are supported: CreateFile( ), WriteFile( ), DeviceIoControl( ) and CloseFile( ). The calling program writes to the device in 514-byte blocks. Currently, only CreateFile( ) and WriteFile( ) are used in the system .","The application functions are divided into Services  that are responsible for carrying out the requests that come from the various devices (Seats 123, PAT GUI , etc.). Requests come in two forms: IFE_Messages from the transaction dispatcher  and CAPI calls from the GUI . Service functions are the primary functions that interact with the database  during runtime. Each Service is connected to the transaction dispatcher  via its own Named Pipes, and as needed, it connects to the SQL Server  for database access.","SERVICE.EXE is organized into 4 basic components: Main, CAPI Calls , Cabin Services \u2013, \u2013 and Sales Services \u2013. The Cabin Services \u2013, \u2013 and Sales Services \u2013 are sets of Service classes whose objects each connect to the transaction dispatcher  via named pipes. They also each have a thread and subroutines to process all IFE messages received, and they all have sets of functions that are used by CAPI.CPP routines of the same name.","SERVICE.EXE is comprised of the following source files:",{"@attributes":{"id":"p-0377","num":"0376"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SRVCPRCS.CPP","The Main Program and Service Class"]},{"entry":["CAPI_S.C","The RPC Server Functions (See CAPI_C for its"]},{"entry":[{},"client companion functions)"]},{"entry":["CAPI.CPP","The actual CAPI Application Functions, called by"]},{"entry":[{},"CAPI_S.C, APIINT.CPP, and the Services."]},{"entry":["CBNSRVCC.CPP","The CabinService Base Class"]},{"entry":["CRDTCRDP.CPP","The CreditCardProcessor Class"]},{"entry":["DTYFRSRV.CPP","The DutyFreeService Class"]},{"entry":["GMSRVCCL.CPP","The GamesService Class"]},{"entry":["IFCNTRLS.CPP","The IFEControlService Class"]},{"entry":["MVCYCLCL.CPP","The MovieCycle Class"]},{"entry":["MVSRVCCL.CPP","The MovieService Class"]},{"entry":["OFFLOADR.CPP","Database Offloader Functions"]},{"entry":["PCKGSRVC.CPP","The PackageService Class"]},{"entry":["PLYRCNFG.CPP","The PlayerConfiguration Class"]},{"entry":["SET.CPP","The Set Class (to support the _Set table)"]},{"entry":["SLSSRVCE.CPP","The SalesService Base Class"]},{"entry":["VCPMSSGE.CPP","The VCP_Message Class (see MESSAGES.LIB for"]},{"entry":[{},"details)"]},{"entry":["VDNNNCMN.CPP","The VideoAnnouncement Class"]},{"entry":["VDSRVCCL.CPP","The VideoService Class"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Services NAU program  function and data paths are shown in . Located in SRVCPRCS.CPP file, the main( ) program is responsible for launching each of the services. Once launched, they are each connected to the named pipes that communicate with the transaction dispatcher .","The services include CAPI.CPP calls  which access CAPI_S.C. calls  that access CAPI_C.C programs . The services include an IFEControlService Class , MovieCycle, VideoService and VideoAnnouncement Classes , and SalesService, MovieService and GameService Classes . The Services NAU program  includes a ServiceProcessor  that employs a GetContextHandle( )  a ContextHandleSessionQueue , and a PutcontextHandle( ) .","The IFEControlService Class  employs a CabinService::Get Message( ) thread  and a CabinService::Put Message( ) thread  that are coupled to the transaction dispatcher  by way of name pipes . The CabinService::Get Message( ) thread  is routed to an InQueue  to a ProcessRequest( )  which accesses IFE Message Support Functions . The ProcessRequest( )  is coupled by way of an OutQueue  to a CabinService::Put Message( ) thread  which is coupled to the transaction dispatcher  by way of the name pipe . A TimeSynchronizationThread( )  is also routed through the OutQueue  and CabinService::Put Message( ) thread . CAPI Support functions  are routed to the CAPI.CPP calls  and to the SQL server . The IFE Message Support Functions  access the SQL server .","The MovieCycle, VideoService and VideoAnnouncement Classes  employs a CabinService::Get Message( ) thread  and a CabinService::Put Message( ) thread  that are coupled to the transaction dispatcher  by way of name pipes . The CabinService::Get Message( ) thread  is routed to an InQueue  to a ProcessRequest( )  which accesses IFE Message Support Functions . The ProcessRequest( )  is coupled by way of an OutQueue  to a CabinService::Put Message( ) thread  which is coupled to the transaction dispatcher  by way of the name pipe. CAPI Support functions  are routed to the CAPI.CPP calls  and to the SQL server . The IFE Message Support Functions  access the SQL server .","The SalesService, MovieService and GameService Classes  employs GetMessage( )  and PutMessage( ) threads  that interface to the transaction dispatcher  by way of name pipes . The GetMessage( ) thread  is routed by way of an InQueue  to a ProcessRequest( )  which accesses IFE Message Support Functions . ProcessRequest( )  are routed by way of an OutQueue  to the Put Message( ) thread  which is coupled to the transaction dispatcher  by way of the name pipe . CAPI Support functions  are routed to the CAPI.CPP calls  and to the SQL server . The IFE Message Support Functions  access the SQL server .","The main( ) program establishes a logon to the SQL Server  for database access using the standard SQL library commands in NTWDBLIB.LIB library. The main( ) program establishes 10 SQL Sessions, for example, with Context Handles to be used by the Services  to talk to the database . The main( ) program establishes multiple handles to the database  for all the services and CAPI functions to use, then starts Pipe Threads and Process Threads for each service to run independently.","The main( ) program establishes itself as an RPC Server to communicate with the PAT GUI  and any other RPC Clients with the NT RPC utilities. Any program that has CAPI_C.C linked into it is an RPC Client in the system . The main( ) program registers itself with the system monitor  for subsequent Shutdown support with SystemMonitor::Register( ). The main( ) program issues a call to ServiceProcessor:: SartActivityMailSlotThread( ) to hook up to the primary access terminal NAU's GUI Monitor process, periodically sending it a message to let it know that Service is alive and well. Finally, the main( ) program waits forever listening to the RPC Server that it set up (via RpcServerListen( ) until System Monitor'sShutdown( ) kills the process.","The ServiceProcessor class is used by main( ) and the Services  to control the access to the database  using the finite number of Context Handles available. This program has more Service SQL functions than Context Handles. It is conceivable that as many as 25 SQL requests may be present at one time (10 games, 10 movies, 1 CAPI, 1 IFE Control, 1 Movie Cycle, 1 Video Service and 1 Video Announcement). As a result, this code provides for optimum processing efficiency by queueing up the available Context Handles and issuing them on a first-come first served basis.",{"@attributes":{"id":"p-0386","num":"0385"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ServiceProcessor",{}]},{"entry":["Public Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CONTEXTHANDLESTRUCT*","Returns the handle to the next available"]},{"entry":["GetContextHandle()","context structure for access to the"]},{"entry":[{},"database."]},{"entry":["int","Returns the number of available Context"]},{"entry":["GetContextHandleCount()","Handles."]},{"entry":["HANDLE","Returns the semaphore for the context"]},{"entry":["GetContextHandleSemaphore()","handle Queue."]},{"entry":["DWORD","Retrieves the error code associated with"]},{"entry":["GetLastError","the specified context handle (phContext)"]},{"entry":["(PCONTEXT_HANDLE","that was most recently set by the"]},{"entry":["TYPE phContext)","SetLastError() member function."]},{"entry":["void","Adds the DPROCESS handle to the"]},{"entry":["PutContextDB","context handle structure."]},{"entry":"(int dContextLocation,"},{"entry":"DBPROCESS*pDBProc)"},{"entry":["void","Replaces the context structure into the"]},{"entry":["PutContextHandle","context structure queue. Service Classes"]},{"entry":["(CONTEXTHANDLE","use this one."]},{"entry":"STRUCT* pContextHandle)"},{"entry":["void","Adds the context structure to the context"]},{"entry":["PutContextHandle","structure queue. The main() program"]},{"entry":["(int dContextLocation)","uses this one to initialize the queue."]},{"entry":["void","Associates the error code in"]},{"entry":["SetLastError","dwErrorCord with the context handle"]},{"entry":["(PCONTEXT_HANDLE","pointer (phContext) storing them in the"]},{"entry":["TYPE phContext, DWORD","LastErrorMap structure. Values are"]},{"entry":["dwErrorCode)","retrieved from the structure via the"]},{"entry":[{},"GetLastError() member. This makes the"]},{"entry":[{},"errors available to all RPC Clients"]},{"entry":[{},"outside the Services."]},{"entry":["bool","Starts the Mail Slot Thread used for"]},{"entry":["StartActivityMailSlotThread()","transmitting an \u201cI'm alive\u201d signal to the"]},{"entry":[{},"PAT NAU GuiMonitor."]},{"entry":[{},"Returns FALSE if fails to start the"]},{"entry":[{},"thread."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Based on the DBAccess class, the Service class is a template for all the Services  to follow for proper operation. As a result, all its functions are virtual, and are defined in its children classes.",{"@attributes":{"id":"p-0388","num":"0387"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Service",{}]},{"entry":["Class Virtual",{}]},{"entry":["Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["virtual bool","Abstract definition to interface supports Service-to-TD"]},{"entry":["ConnectToTD()","named pipe connections."]},{"entry":["virtual void","Abstract definition to define the interface to launch a"]},{"entry":["GenerateReport","report."]},{"entry":["(ReportType","(All of them are stubs for now, and not called by"]},{"entry":["nReport)","anyone.)"]},{"entry":["virtual void","Abstract definition to receive data into the Service."]},{"entry":"GetMessage()"},{"entry":["virtual","Abstract definition to retrieve the access policy for the"]},{"entry":["PolicyType","Service."]},{"entry":["GetPolicy()","(All of them are stubs for now, and not called by"]},{"entry":[{},"anyone.)"]},{"entry":["virtual bool","Abstract definition that defines an interface to evaluate"]},{"entry":["IsAvailable()","whether a Service is available and ready to process"]},{"entry":[{},"requests or commands."]},{"entry":[{},"(All of them are stubs for now, and not called by"]},{"entry":[{},"anyone.)"]},{"entry":["virtual void","Abstract definition that defines an interface to make a"]},{"entry":["MakeAvailable","Service available."]},{"entry":["(SERVICE","(All of them are stubs for now, and not called by"]},{"entry":["STATE","anyone.)"]},{"entry":"ServiceAction)"},{"entry":["virtual void","Abstract definition for an interface that handles"]},{"entry":["ProcessRequest()","IFE_Messages for the Service. In addition to specific"]},{"entry":[{},"messages designed for each Service, all"]},{"entry":[{},"ProcessRequest() functions should handle the"]},{"entry":[{},"SubProcessStart, SubProcessStop and"]},{"entry":[{},"SubProcessReinit messages to get themselves going"]},{"entry":[{},"and synchronized as needed by the rest of the system."]},{"entry":["virtual void","Abstract definition to send data out of the Service to"]},{"entry":["PutMessage()","TD and beyond."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Cabin Services  control all the functions of In-Flight Service except those in which individual passengers  are involved. Cabin Services  are divided into the following Services: IFE Control Service , Movie Cycle Service, Video Service and the Video Announcement Service . In addition to its overcast versions of the Service class functions, CabinServiceClass includes:",{"@attributes":{"id":"p-0390","num":"0389"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["CabinServiceClass Public",{}]},{"entry":["Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TIME","Retrieves the remaining flight time using the"]},{"entry":["GetRemainingFlightTime","CalcRemainingFlightTime stored procedure."]},{"entry":"(PCONTEXT_HANDLE"},{"entry":"TYPE phContext)"},{"entry":["bool","Registers this named pipe with the"]},{"entry":["RegisterPipe","Transaction Dispatcher to make I\/O"]},{"entry":[{},"possible."]},{"entry":"(HANDLE hPipeHandle)"},{"entry":["bool","Transfers the data contained in pszData into"]},{"entry":["SetStatus","the status message field identified by"]},{"entry":[{},"nStatusType."]},{"entry":"(STATUS_TYPE"},{"entry":"nStatusType, char"},{"entry":"*pszData)"},{"entry":["bool","Called by main() to get a pair of named pipes"]},{"entry":["StartPipeThreads","to TD for this Service."]},{"entry":"(ServiceProcessor"},{"entry":"*pServiceProcessor)"},{"entry":["bool","Called by main() to get the child's"]},{"entry":["StartProcessThreads","ProcessRequest() loop going by invoking"]},{"entry":["(ServiceProcessor","ProcessRequestInterface()."]},{"entry":"*pServiceProcessor)"},{"entry":["static UINT","Shared by all the CabinServiceClass"]},{"entry":["GetMessageThreadInterface","children, this launches the child's"]},{"entry":["(LPVOID IpParam)","GetMessage() function to handle its input"]},{"entry":[{},"from TD."]},{"entry":["static UINT","Shared by all the CabinServiceClass"]},{"entry":["ProcessRequestInterface","children, this launches the local"]},{"entry":["(LPVOID IpParam)","ProcessRequest() function that loops forever"]},{"entry":[{},"handling the messages that it receives."]},{"entry":["static UINT","Shared by all the CabinServiceClass"]},{"entry":["PutMessageThreadInterface","children, this launches the child's"]},{"entry":["(LPVOID IpParam)","PutMessage() function to handle its output"]},{"entry":[{},"to TD."]},{"entry":["void","Initiates a delay for the number of seconds"]},{"entry":["Wait(","specified by the input parameter dwSeconds."]},{"entry":"DWORD dwSeconds)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The IFEControlService  class is derived from the CabinService class and contains several additional sets of functions that are used sporadically throughout the flight including:",{"@attributes":{"id":"p-0392","num":"0391"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Function Set","Tables Used"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IFE State Changes","Aircraft, Order"]},{"entry":"Flight Duration"},{"entry":"Management"},{"entry":["Statistics","Member, PassengerMap, PassengerStatistics,"]},{"entry":[{},"Set"]},{"entry":["Surveys","SurveyAnswer"]},{"entry":"Seat Transfers"},{"entry":["Database Backup","All Database Tables"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"CAPI support  includes the following public functions accessed by CAPI.CPP  calls (having the same name):",{"@attributes":{"id":"p-0394","num":"0393"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["IFEControlService",{}]},{"entry":["Class Public",{}]},{"entry":["Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bool","Formats an IFE Message as specified by"]},{"entry":["CommandSeat","nCommand and transmits the message to"]},{"entry":[{},"the seat specified by pszSeatName."]},{"entry":"(PCONTEXT_HANDLE"},{"entry":"TYPE phContext, SEAT"},{"entry":"COMMAND nCommand,"},{"entry":"PGENERIC_TEXT"},{"entry":"pszSeatName)"},{"entry":["bool","Due to a CAPI call, Formats and sends an"]},{"entry":["SeatTransferInit","IFE_Message to the Seat NAU, which is"]},{"entry":["(PGENERIC_TEXT","where the actual transfer takes place. The"]},{"entry":["pszSeat1, PGENERIC","data in the message reflects the two seats"]},{"entry":["TEXT pszSeat2)","that are to be transferred."]},{"entry":["void","Formats and transmits an unsolicited"]},{"entry":["SendStatusMessage","Status Window Message to the GUI."]},{"entry":"(PCONTEXT_HANDLE"},{"entry":"TYPE phContext)"},{"entry":["bool","Calls the local SetState() to update the"]},{"entry":["SetIFEState","system state information. IFE State is a"]},{"entry":["(PCONTEXT_HANDLE","term that describes whether the IFE System"]},{"entry":["TYPE phContext,","is IDLE, STARTED, PAUSED, and more."]},{"entry":["IFESTATE IFEStateValue)","This allows CAPI to alter these states to"]},{"entry":[{},"either free up services or disable them as"]},{"entry":[{},"appropriate for the current runtime state of"]},{"entry":[{},"the system. For example, when the system"]},{"entry":[{},"is IDLE or PAUSED, movies cannot be"]},{"entry":[{},"viewed which affects the Movie Cycle"]},{"entry":[{},"Service as well as the Movie Rental Service."]},{"entry":["void","Called to refresh the value contained in the"]},{"entry":["SetRemaining","tmRemainingFlightDuration which is"]},{"entry":["FlightDuration","defined statically in the CabinService class."]},{"entry":["(PCONTEXT_HANDLE","This function is called periodically from the"]},{"entry":["TYPE phContext)","IFEControlService::TimeSynchronization"]},{"entry":[{},"Thread() thread to update the value as the"]},{"entry":[{},"flight progresses, and directly from the CAPI"]},{"entry":[{},"when a change to the flight duration occurs."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In addition to the CAPI support functions , the IFE Message Support  also handles incoming IFE Messages using its overcast ProcessRequest( ) thread . In addition to the standard messages, this class handles the following messages: Statistics, Survey, SeatFault, FlightInfoRequest and DatabaseBackup.",{"@attributes":{"id":"p-0396","num":"0395"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},{},"Tables"]},{"entry":["IFE Message","Function Called","Purpose","Affected"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DatabaseBackup","ProcessDatabase","Generates a","All database"]},{"entry":[{},"Backup()","backup of the","tables"]},{"entry":[{},{},"entire CFS"]},{"entry":[{},{},"database to"]},{"entry":[{},{},"recover after a"]},{"entry":[{},{},"possible CFS"]},{"entry":[{},{},"hard disk failure."]},{"entry":["FlightInfoRequest","ProcessFlight","Gathers flight","Aircraft"]},{"entry":[{},"Info()","information from","FlightV"]},{"entry":[{},{},"the CFS database"]},{"entry":[{},{},"and uses the"]},{"entry":[{},{},"information to"]},{"entry":[{},{},"populate an"]},{"entry":[{},{},"IFE_Message."]},{"entry":[{},{},"The IFE_Message"]},{"entry":[{},{},"is then returned"]},{"entry":[{},{},"to the requesting"]},{"entry":[{},{},"program"]},{"entry":["SeatFault","ProcessSeat","Updates the","Passenger"]},{"entry":[{},"Fault()","database,","Map"]},{"entry":[{},{},"clearing or setting"]},{"entry":[{},{},"a fault indication"]},{"entry":[{},{},"for the seat or"]},{"entry":[{},{},"range of seats in"]},{"entry":[{},{},"the IFE message"]},{"entry":["Statistics","Process","Stores statistical","Member"]},{"entry":[{},"Statistics()","information from","Set"]},{"entry":[{},{},"the seats to the","Passenger"]},{"entry":[{},{},"database and","Map"]},{"entry":[{},{},"prepares them for","Passenger"]},{"entry":[{},{},"output to a text","Statistics"]},{"entry":[{},{},"file. Statistics"]},{"entry":[{},{},"include"]},{"entry":[{},{},"information such"]},{"entry":[{},{},"as how many"]},{"entry":[{},{},"hours of which"]},{"entry":[{},{},"movie was"]},{"entry":[{},{},"viewed, which"]},{"entry":[{},{},"games were"]},{"entry":[{},{},"played and more."]},{"entry":["SubProcessStart","InitService()","Establish IFE","Aircraft"]},{"entry":[{},{},"State and tell it to"]},{"entry":[{},{},"all affected"]},{"entry":[{},{},"programs via IFE"]},{"entry":[{},{},"Messages. Calls"]},{"entry":[{},{},"StartTimeSynchro-"]},{"entry":[{},{},"nizationThread()"]},{"entry":[{},{},"to launch"]},{"entry":[{},{},"Time"]},{"entry":[{},{},"Synchronization"]},{"entry":[{},{},"Thread()"]},{"entry":["Survey","ProcessSurvey()","Stores the","Survey"]},{"entry":[{},{},"answers given by","Survey"]},{"entry":[{},{},"passengers to","Answer"]},{"entry":[{},{},"survey questions","Survey"]},{"entry":[{},{},"available through","AnswerKey"]},{"entry":[{},{},"the IFE system.","Survey"]},{"entry":[{},{},"These answers","Question"]},{"entry":[{},{},"are stored in the"]},{"entry":[{},{},"database, as well"]},{"entry":[{},{},"as prepared for"]},{"entry":[{},{},"output to a text"]},{"entry":[{},{},"file"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The TimeSynchronizationThread( ) thread  in the IFEControlService class  is responsible for managing flight duration information, which changes all the time. It uses SetRemainingFlightDuration( ) to update values, and calls AutoEndRevenue( ) to send a Stop Revenue Unsolicited Message to the GUI  once there is no time for further revenue purchases.","The PlayerConfiguration class supports any Service that uses video players, such as the MovieCycle, VideoAnnouncement and Video Services . The PlayerConfiguration class contains all pertinent information necessary to describe information specific to a Movie Cycle or Video Announcement. The PlayerConfiguration class also contains the methods needed to issue all appropriate messages to start a specific Movie Cycle or Video Announcement.",{"@attributes":{"id":"p-0399","num":"0398"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["PlayerConfiguration",{}]},{"entry":["Class Public",{}]},{"entry":["Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PlayerConfiguration","Creates a PlayerConfiguration object of"]},{"entry":["(Queue *pParentQueue,","specified Name, Intermission Time and Start"]},{"entry":["CString csName,","time. In addition, a reference to the parent"]},{"entry":["CString csAddress,","object's queue is stored in order for this"]},{"entry":["TIME tmIntermission,","PlayerConfiguration object to communicate"]},{"entry":["TIME tmStart)","with the parent object."]},{"entry":["PlayerConfiguration","Same as above, except default values for"]},{"entry":["(Queue *pParentQueue,","Intermission Time and Start Time are"]},{"entry":["CString csName,","assigned as Zero."]},{"entry":"CString csAddress)"},{"entry":["void AddPlayer","Adds the specified player to this Player"]},{"entry":["(CString csPlayerName,","Configuration. If the program to be played"]},{"entry":["BYTE bySegment,","is a Video Segment, then a segment number"]},{"entry":["BYTE byRepeat,","is provided, otherwise a value of zero is"]},{"entry":["DWORD dwMediaId)","passed in the bySegment argument. If the"]},{"entry":[{},"repeat flag is set TRUE then the associated"]},{"entry":[{},"player is placed into it's REPEAT state."]},{"entry":["bool","Updates internal data structures for this"]},{"entry":["ChangeCabinAudioLevel","PlayerConfiguration object with the audio"]},{"entry":["(BYTE byAudioLevel,","level specified in the byAudioLevel"]},{"entry":["BYTE byZone)","argument."]},{"entry":["void","Transmits the necessary messages to the"]},{"entry":["CommandCabinAudio","Backbone NAU which command the PESC-V"]},{"entry":["(bool bAudioOn)","to make the necessary cabin audio"]},{"entry":[{},"connections for the zones associated with"]},{"entry":[{},"this Player Configuration object. If the input"]},{"entry":[{},"argument bAudioOn is TRUE, the"]},{"entry":[{},"connections are enabled, if bAudioOn is"]},{"entry":[{},"FALSE, the connections are disabled."]},{"entry":["void","Sends messages to the PESC-V to activate or"]},{"entry":["CommandCabinVideo","de-activate the Overhead Monitors and"]},{"entry":["(bool bVideoOn)","override the in-seat video displays"]},{"entry":[{},"associated with this Player Configuration"]},{"entry":[{},"object. A value of TRUE for the input"]},{"entry":[{},"argument bVideoOn causes cabin video"]},{"entry":[{},"connections to be enabled, a value of FALSE"]},{"entry":[{},"for bVideoOn causes cabin video"]},{"entry":[{},"connections to be disabled."]},{"entry":["bool CommandPlayer","Transmits the player command specified by"]},{"entry":["(CString csPlayerName,","nCommand to the player specified by"]},{"entry":["PLAYERCOMMANDS","csPlayerName. Any additional data needed"]},{"entry":["nCommand,","for the command must be passed in"]},{"entry":["PGENERIC_TEXT","pszExtra."]},{"entry":"pszExtra)"},{"entry":["bool CommandPlayers","Issues the commands to start, stop or"]},{"entry":["(PlayerCommands","rewind the player."]},{"entry":"nPlayerCommand)"},{"entry":["bool","Populates the static data structure"]},{"entry":["CreateAssignmentMap","AssignMap with a status record for each"]},{"entry":["(PCONTEXT","LRU of type VCP residing in the LRU table."]},{"entry":"HANDLE_TYPE"},{"entry":"phContext)"},{"entry":["BYTE GetCabinAudio","Returns the Cabin Audio Zone BitMap."]},{"entry":"ZoneMap()"},{"entry":["BYTE GetCabinVideo","Returns the Cabin Video Zone BitMap."]},{"entry":"ZoneMap()"},{"entry":["CString","Returns the Configuration Address."]},{"entry":"GetConfigAddress()"},{"entry":["PLAYERSTATE","Returns the cumulative state of all players"]},{"entry":["GetConfigState()","currently assigned in this"]},{"entry":[{},"PlayerConfiguration object."]},{"entry":["PLAYERSTATE","Returns the state of the Player's"]},{"entry":["GetConfigState()","Configuration."]},{"entry":["void GetConfigStatus","Returns information pertinent to this"]},{"entry":["(ULONG","PlayerConfiguration object. The information"]},{"entry":["*ulCurrentViewing,","returned is:"]},{"entry":["long *tmElapsed,","Number of configurations started"]},{"entry":["long *tmRemaining,","Elapsed time current configuration has"]},{"entry":["long *tmNextShow)","been playing"]},{"entry":[{},"Remaining play time for current"]},{"entry":[{},"configuration"]},{"entry":[{},"Number of minutes until the next"]},{"entry":[{},"Configuration starts."]},{"entry":["ConfigState","Returns the current configuration state."]},{"entry":"GetCurrState()"},{"entry":["TIME GetCycleTime()","Returns the sum of the Longest Program"]},{"entry":[{},"Time and the Intermission."]},{"entry":["int GetCycleTimes","Computes a list of start times for all movie"]},{"entry":["(TIME","cycles contained in this PlayerConfiguration"]},{"entry":["tmFlightRemaining,","object. Cycle time values are store in"]},{"entry":["CDWordArray","dwCycleTimeList and the number of"]},{"entry":["*dwCycleTimeList)","elements added to the array is returned to"]},{"entry":[{},"the calling function."]},{"entry":["long Get","Returns the Longest Program duration in"]},{"entry":["LongestProgramTime()","minutes."]},{"entry":["CString GetLongest","Returns the value of the Longest VCP"]},{"entry":["ProgramVcp()","Program name."]},{"entry":["DWORD GetMediaId","Returns the MediaId associated with the"]},{"entry":["(CString csPlayerName)","Video Player specified in csPlayerName. A"]},{"entry":[{},"value of \u22121 is returned if an invalid player"]},{"entry":[{},"name is specified."]},{"entry":["CString GetName()","Returns the configuration name."]},{"entry":["int GetPlayerList","Populates a CStringArray with a list of the"]},{"entry":["(CStringArray &csList)","VCP Player Names currently associated with"]},{"entry":[{},"this PlayerConfigurationObject."]},{"entry":["WORD","Returns the number of players in this"]},{"entry":["GetPlayerStateCount","PlayerConfiguration object that are currently"]},{"entry":["(PLAYERSTATE","in the state specified by nPlayerState."]},{"entry":"nPlayerState)"},{"entry":["ConfigState","Returns the previous configuration state."]},{"entry":"GetPrevState()"},{"entry":["BYTE","Returns the Seat Video Zone BitMap."]},{"entry":"GetSeatVideoZoneMap()"},{"entry":["TIME GetStartTime()","Returns the Start Time."]},{"entry":["bool GetTimeoutFlag()","Returns the value of the Timeout Flag."]},{"entry":["PLAYERSTATE","Returns the state currently stored in the"]},{"entry":["GetVCPState (CString","assignment map for the player specified by"]},{"entry":["csVCPName)","csVCPName."]},{"entry":["bool","Returns a value of TRUE to the calling"]},{"entry":["IsCabinAudioActive()","function if cabin audio is being used by any"]},{"entry":[{},"of the currently active assignments. A value"]},{"entry":[{},"of FALSE is returned otherwise."]},{"entry":["bool IsLastViewing","Determines whether or not the cycle being"]},{"entry":["(TIME","played is the final cycle based on the"]},{"entry":["tmFlightRemaining)","remaining time in the flight. It returns a"]},{"entry":[{},"value of TRUE if the last cycle has started"]},{"entry":[{},"and returns a value of FALSE otherwise."]},{"entry":["bool IsRunning()","Returns TRUE if the current state is IDLE."]},{"entry":["bool IsTransitionActive()","Returns TRUE if Transition is marked as"]},{"entry":[{},"active."]},{"entry":["bool IsValidVCP","Returns a value of TRUE to the calling"]},{"entry":["(CString csVCPName)","function if the player name specified by the"]},{"entry":[{},"csVCPName argument is found in the"]},{"entry":[{},"Assignment map. Otherwise a value of"]},{"entry":[{},"FALSE is returned."]},{"entry":["void Purge()","Removes references to all video player"]},{"entry":[{},"names and configuration data associated"]},{"entry":[{},"with this PlayerConfiguration Object."]},{"entry":["void RecoverCycle","Extracts recovery information from the"]},{"entry":["(IFE_Message","IFE_Message object referenced by"]},{"entry":["*msgRecoveryInfo)","msgRecoveryInfo, converts the data into"]},{"entry":[{},"Binary and uses the converted data to"]},{"entry":[{},"initialize timing information for this"]},{"entry":[{},"PlayerConfiguration object."]},{"entry":["bool ReplacePlayer","Removes the player identified by csOld from"]},{"entry":["(CString &csOld,","this PlayerConfiguration object and adds the"]},{"entry":["CString &csNew)","player identified by csNew to this"]},{"entry":[{},"PlayerConfiguration object."]},{"entry":["void","Sets Transition to InActive."]},{"entry":"ResetTransitionActive()"},{"entry":["void","Stores the Audio distribution information for"]},{"entry":["SetAudioDistributionInfo","this Player Configuration."]},{"entry":"(BYTE byAudioMap,"},{"entry":"BYTE byMapType,"},{"entry":"CByteArray"},{"entry":"*pbyVolume)"},{"entry":["bool SetConfigState","Sets the state of this PlayerConfiguration"]},{"entry":["(ConfigState nState)","object to the value specified by nState."]},{"entry":[{},"Performs all initialization necessary to make"]},{"entry":[{},"the transition into the new state. Returns"]},{"entry":[{},"TRUE if the state was successfully entered,"]},{"entry":[{},"returns FALSE otherwise."]},{"entry":["void SetIntermission","Sets the Intermission Duration for this"]},{"entry":["(TIME tmIntermission)","Player Configuration."]},{"entry":["void SetLongestProgram","Identifies a VCP Name and Program"]},{"entry":["(int nPlayTime,","Duration as the longest program in this"]},{"entry":["CString csPlayerName)","PlayerConfiguration."]},{"entry":["void SetStartTime","Sets the player start time."]},{"entry":"(TIME tmStartTime)"},{"entry":["void","Sets Transition to Active."]},{"entry":"SetTransitionActive()"},{"entry":["int SetVCPAssignment","Updates the pConfig entry in the PlayerMap"]},{"entry":["(int nLockState)","data structure associated the player"]},{"entry":[{},"identified by csVCPName. If the value of"]},{"entry":[{},"nLockState is LOCK the pointer to this"]},{"entry":[{},"PlayerConfiguration object is written. If the"]},{"entry":[{},"value of nLockState is AVAILABLE and the"]},{"entry":[{},"player is currently assigned to this player"]},{"entry":[{},"configuration object, the pConfig field is set"]},{"entry":[{},"to NULL."]},{"entry":[{},"Returns the number of players which were"]},{"entry":[{},"successfully assigned."]},{"entry":["bool SetVCPState","Updates the entry in the PlayerMap data"]},{"entry":["(CString csVCPName,","structure associated the player identified by"]},{"entry":["PLAYERSTATE","csVCPName with the value contained in the"]},{"entry":["nVCPState, DWORD","nVCPState argument."]},{"entry":"dwVCPTime)"},{"entry":["void","Stores the video distribution information for"]},{"entry":["SetVideoDistributionInfo","this Player Configuration."]},{"entry":"(BYTE byRFChannel,"},{"entry":"BYTE bySeatMap,"},{"entry":"BYTE byOHMap,"},{"entry":"BYTE byMapType)"},{"entry":["void UpdateConfigState","Updates the state of this"]},{"entry":["(VCP_Message","PlayerConfiguration object based. The state"]},{"entry":["*pMessage)","may be changed based on the content of the"]},{"entry":[{},"input message or based on a timeout applied"]},{"entry":[{},"to the current state."]},{"entry":["void","Sets the state of the bConfigTimeoutFlag"]},{"entry":["UpdateConfigTimeout()","variable TRUE if the elapsed time for the"]},{"entry":[{},"current state has been exceeded. Otherwise,"]},{"entry":[{},"the bConfigTimeoutFlag variable is set False."]},{"entry":["void UpdateCycleStatus","Used periodically to transmit the Movie"]},{"entry":["(TIME","Cycle Times (based on RemainingCycleTime)"]},{"entry":["tmStatusUpdateRate,","message to the Seat NAU. Also periodically"]},{"entry":["TIME","transmits a RecoveryInfo message to the"]},{"entry":["tmRemainingCycleTime)","IFEControlService."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Throughout the In-Flight operation, one or more movies continuously play, all starting together as a set, providing maximum viewing possibilities for the passengers . This is known as Movie Cycling. The Movie Cycle Service controls the synchronization of these cycles.","Derived from the CabinService class, MovieCycleClass is responsible for keeping track of the remaining time of the flight, as well as the longest movie duration. It starts a cycle, stops a cycle, pauses a cycle, and recovers a cycle. The following database tables are used to support the MovieCycle Class: Member, MovieCycle, Set_, VideoMedium, VideoPlayer, VideoSegment, and VideoUse.","The following table shows those functions that are used by CAPI.CPP calls :",{"@attributes":{"id":"p-0403","num":"0402"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["MovieCycle Class",{}]},{"entry":["Public Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bool","Adds a player to a movie cycle."]},{"entry":"AddPlayerToMovieCycle"},{"entry":"(PCONTEXT_HANDLE"},{"entry":"TYPE phContext,"},{"entry":"PGENERIC_TEXT"},{"entry":"MovieCycleName,"},{"entry":"PGENERIC_TEXT"},{"entry":"PlayerName)"},{"entry":["bool","Modifies the movie cycle intermission"]},{"entry":["ChangeMovieCycle","time."]},{"entry":"IntermissionTime"},{"entry":"(PCONTEXT_HANDLE"},{"entry":"TYPE phContext,"},{"entry":"PGENERIC_TEXT"},{"entry":"MovieCycleName, TIME"},{"entry":"Intermission)"},{"entry":["bool","Update the start delay time for the"]},{"entry":["ChangeMovieCycleStartTime","PlayerConfiguration object specified"]},{"entry":["(PCONTEXT_HANDLE","by MovieCycleName. Updates the"]},{"entry":["TYPE phContext, PGENERIC","start delay locally: The value is"]},{"entry":["TEXT MovieCycleName, TIME","written to the database as part of the"]},{"entry":["StartDelay)","StartMovieCycle processing."]},{"entry":["APIResult","Calculates the number of minutes"]},{"entry":["GetFirstMovieCycleTime","until each of the remaining movie"]},{"entry":["(PCONTEXT_HANDLE","cycles starts. Returns the first start"]},{"entry":["TYPE phContext, PGENERIC","time in tmMinUntilStart. The return"]},{"entry":["TEXT pszMovieCycleName,","value is APIOK if there are 2 or more"]},{"entry":["TIME *tmMinUntilStart)","entries in the list and APIEndOfList if"]},{"entry":[{},"there is only 1 entry in the list."]},{"entry":["bool","Returns TRUE if the movie cycle"]},{"entry":["GetMovieConfigurationState","specified by pszMovieCycleName is"]},{"entry":["(PCONTEXT_HANDLE","running."]},{"entry":"TYPE phContext, PGENERIC"},{"entry":"TEXT pszMovieCycleName)"},{"entry":["bool","Returns the duration, in minutes, of"]},{"entry":["GetMovieCycleDuration","the Movie Cycle specified by"]},{"entry":["(PCONTEXT_HANDLE","pszMovieCycleName. A return value"]},{"entry":["TYPE phContext, PGENERIC","of TRUE indicates that the specified"]},{"entry":["TEXT pszMovieCycleName,","movie cycle was found and the time"]},{"entry":["TIME *tmDuration)","is valid."]},{"entry":["APIResult","After GetFirstMovieCycleTime() has"]},{"entry":["GetNextMovieCycleTime","been called to calculate movie cycle"]},{"entry":["(PCONTEXT_HANDLE","times and return the first one, this"]},{"entry":["TYPE phContext, TIME","can be called iteratively to retrieve"]},{"entry":["*tmMinUntilStart)","the remaining movie cycle start"]},{"entry":[{},"times."]},{"entry":[{},"Returns APIEndOfList for the last"]},{"entry":[{},"entry in the list."]},{"entry":[{},"Returns APIOK for all other entries."]},{"entry":["bool","Removes the PlayerName player from"]},{"entry":["RemovePlayerFromMovieCycle","the movie cycle MovieCycleName."]},{"entry":"(PCONTEXT_HANDLE"},{"entry":"TYPE phContext, PGENERIC"},{"entry":"TEXT MovieCycleName,"},{"entry":"PGENERIC_TEXT"},{"entry":"PlayerName)"},{"entry":["bool","Swaps players (usually because of a"]},{"entry":["ReplaceMovieCyclePlayer","hardware failure, and movies must"]},{"entry":["(PCONTEXT_HANDLE","be moved to new devices)."]},{"entry":"TYPE phContext, PGENERIC"},{"entry":"TEXT pszMovieCycleName,"},{"entry":"PGENERIC_TEXT"},{"entry":"pszPlayerToRemove,"},{"entry":"PGENERIC_TEXT"},{"entry":"pszPlayerToAdd)"},{"entry":["bool","Sets the movie cycle update rate."]},{"entry":["SetMovieCycleUpdateRate","The movie cycle update rate is the"]},{"entry":["(PCONTEXT_HANDLE","rate at which the system transmits"]},{"entry":["TYPE phContext, long","movie cycle update information to"]},{"entry":["lSeconds)","the seats in seconds."]},{"entry":["bool","Starts the specified MovieCycleName"]},{"entry":["StartMovieCycle","at the given tmStartTime."]},{"entry":"(PCONTEXT_HANDLE"},{"entry":"TYPE phContext, PGENERIC"},{"entry":"TEXT MovieCycleName, TIME"},{"entry":"tmStartTime)"},{"entry":["bool","Stops the specified Movie Cycle."]},{"entry":"StopMovieCycle"},{"entry":"(PCONTEXT_HANDLE"},{"entry":"TYPE phContext, PGENERIC"},{"entry":"TEXT MovieCycleName)"},{"entry":["void","Notifies MovieCycleService that a"]},{"entry":["UpdateSystemState","change to the system state has"]},{"entry":["(PCONTEXT_HANDLE","occurred. The Service retrieves the"]},{"entry":["TYPE phContext)","system state from the database and"]},{"entry":[{},"updates the state of the active"]},{"entry":[{},"cycle(s) accordingly."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"IFE Message Support  handles incoming IFE Messages using its overcast ProcessRequest( ) thread . In addition to the standard IFE messages, this class handles the following messages: MovieTimes and MovieCycle.",{"@attributes":{"id":"p-0405","num":"0404"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["IFE Message","Function Called","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MovieCycle","StopMovieCycle() or","Starts or Stops the movie cycle as"]},{"entry":[{},"StartMovieCycle()","needed."]},{"entry":["MovieTimes","UpdateMovieTimes()","Updates the duration of the movies"]},{"entry":[{},{},"that are playing or scheduled to"]},{"entry":[{},{},"play."]},{"entry":["SubProcess","InitService()","Creates a PlayerConfiguration"]},{"entry":["Start",{},"object, determines what the players"]},{"entry":[{},{},"are doing using"]},{"entry":[{},{},"UpdateSystemState()"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Flight Attendants often need the ability to view and listen to videos to verify quality and accuracy (for example, to determine if the expected movie is installed in the proper player ). The Video Service functions support this capability. Derived from the CabinService class, the VideoServiceClass is responsible for connecting the GUI  to the individual players  for preview and overhead control. The following database tables are affected by the Video Service Class: VideoMedium, VideoPlayer, and VideoUse.","The following table shows those functions that are used by CAPI.CPP calls :",{"@attributes":{"id":"p-0408","num":"0407"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["VideoServiceClass Public",{}]},{"entry":["Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PLAYERSTATE","Uses PlayerConfiguration class functions to"]},{"entry":["CommandPlayer","tell VCP pszPlayerName to perform"]},{"entry":["(PGENERIC_TEXT","nCommand (e.g., start, stop, play . . . etc)."]},{"entry":"pszPlayerName,"},{"entry":"PLAYERCOMMANDS"},{"entry":"nCommand, PGENERIC"},{"entry":"TEXT pszExtra)"},{"entry":["void","Returns the state and channel # of the"]},{"entry":["GetOverhead","currently selected Overhead Video source."]},{"entry":"(OVERHEADSTATE"},{"entry":"TYPE *pOHState,"},{"entry":"long *pChannel)"},{"entry":["PLAYERSTATE","Uses CommandPlayer() to prompt the VCP"]},{"entry":["GetPlayerState","to supply its current state."]},{"entry":["(PGENERIC_TEXT","Returns this state to caller."]},{"entry":"pszPlayerName)"},{"entry":["long","Uses CommandPlayer() to prompt the VCP"]},{"entry":["GetRemainingPlayerTime","to supply its remaining play time."]},{"entry":["(PGENERIC_TEXT","Currently, this always returns ZERO."]},{"entry":"pszPlayerName)"},{"entry":["bool","Sets the Cabin Audio volume level."]},{"entry":["SetAnnouncementAudio","A value of \u22121 for dwZone specifies that PA"]},{"entry":["Level (PCONTEXT","volume for all zones is to be set to the"]},{"entry":["HANDLE_TYPE","specified audio level. If Persist is set TRUE,"]},{"entry":["phContext, long","this updates the database as well, making"]},{"entry":["lAudioLevel, DWORD","this a permanent setting."]},{"entry":"dwZone, bool Persist)"},{"entry":["void","Transmits a message to the PESC-V via the"]},{"entry":["SetOverhead","Backbone NAU to identify which channel"]},{"entry":["(OVERHEADSTATE","represents the overhead video source. All"]},{"entry":["TYPE OHState, long","parameters are Input Parameters."]},{"entry":"Channel, PGENERIC"},{"entry":"TEXT pszPlayerName)"},{"entry":["bool","Tells the VCP NAU to set the given"]},{"entry":["SetPlayerSegment","pszPlayerName VCP to the selected"]},{"entry":["(PGENERIC_TEXT","lSegment. Returns FALSE if Segment value"]},{"entry":["pszPlayerName, long","is invalid (>0\u00d7ff)."]},{"entry":"lSegment)"},{"entry":["void","Notifies this Service that a change to the"]},{"entry":["UpdateSystemState","system state has occurred."]},{"entry":"(PCONTEXT_HANDLE"},{"entry":"TYPE phContext)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"IFE Message Support  handles incoming IFE Messages using its overcast ProcessRequest( ) thread . In addition to the standard IFE messages, this class handles the following messages: FailedPlayer, VCPStatus, and VideoControl.",{"@attributes":{"id":"p-0410","num":"0409"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"Function",{}]},{"entry":["IFE Message","Called","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FailedPlayer","ProcessFailed","Returns to the caller the number of"]},{"entry":[{},"Player()","players and which ones are flagged as"]},{"entry":[{},{},"failed."]},{"entry":["SubProcessStart","InitService()","Creates a PlayerConfiguration object"]},{"entry":[{},{},"and initialize its variables."]},{"entry":["VCPStatus","ProcessVCP","Updates the VCPState (via"]},{"entry":[{},"Status()","PlayerConfiguration::SetVCPState()),"]},{"entry":[{},{},"updates the database and tell the"]},{"entry":[{},{},"MovieCycle Service of the changed"]},{"entry":[{},{},"status via an IFE_Message."]},{"entry":["VideoControl","ProcessVideo","Updates the named player's status as"]},{"entry":[{},"Control()","given in the message, and outputs it"]},{"entry":[{},{},"to the Status Window."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The VideoAnnouncementService class is derived from the CabinService class and contains several additional sets of functions that are used sporadically throughout the flight to support the playing of video clips, such as a safety video that must be broadcast to all passengers  at specific times during the flight. It provides the following functionality: creates a message for cabin configuration (cabin audio\/video), works with MovieCycleService to pause the movie cycle, starts an announcement tape, and talks to PESC-V to control PA. The database tables affected by the VideoAnnouncementService Class are: Aircraft, PA_Volume, VA_Distribution, VideoMedium, and VideoSegment.","The following table shows those functions that are used by CAPI.CPP calls :",{"@attributes":{"id":"p-0413","num":"0412"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["VideoAnnouncementService Public",{}]},{"entry":["Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["APIRESULT",{}]},{"entry":"GetFirstVideoAnnouncementPlayList"},{"entry":"(PCONTEXT_HANDLE_TYPE phContext,"},{"entry":"PGENERIC_TEXT"},{"entry":"pszVideoAnnouncementName,"},{"entry":"PGENERIC_TEXT pszPlayerName,"},{"entry":"VIDEOANNOUNCEMENTSTATUSTYPE"},{"entry":"*nState)"},{"entry":"APIRESULT"},{"entry":"GetNextVideoAnnouncementPlayList"},{"entry":"(PCONTEXT_HANDLE_TYPE phContext,"},{"entry":"PGENERIC_TEXT"},{"entry":"pszVideoAnnouncementName,"},{"entry":"PGENERIC_TEXT pszPlayerName,"},{"entry":"VIDEOANNOUNCEMENTSTATUSTYPE"},{"entry":"*nState)"},{"entry":"bool"},{"entry":"ReplaceVideoAnnouncementPlayer"},{"entry":"(PCONTEXT_HANDLE_TYPE phContext,"},{"entry":"PGENERIC_TEXT pszAnnouncementName,"},{"entry":"PGENERIC_TEXT pszReplacementPlayer)"},{"entry":["bool","Starts the"]},{"entry":["ResumeVideoAnnouncement","PlayerConfiguration"]},{"entry":["(PCONTEXT_HANDLE_TYPE phContext)","Object associated with"]},{"entry":[{},"the next Video"]},{"entry":[{},"Announcement to be"]},{"entry":[{},"played."]},{"entry":["bool","Starts the specified video"]},{"entry":["StartVideoAnnouncement","announcement."]},{"entry":"(PCONTEXT_HANDLE_TYPE phContext,"},{"entry":"PGENERIC_TEXT pszAnnouncementName)"},{"entry":["bool","Stops the specified video"]},{"entry":["StopVideoAnnouncement","announcement."]},{"entry":"(PCONTEXT_HANDLE_TYPE phContext,"},{"entry":"PGENERIC_TEXT pszAnnouncementName)"},{"entry":["void","Notifies this Service that"]},{"entry":["UpdateSystemState","a change to the system"]},{"entry":["(PCONTEXT_HANDLE_TYPE phContext)","state has occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In addition to the CAPI support functions , IFE Message Support  also handles incoming IFE Messages using its overcast ProcessRequest( ) thread . In addition to the standard IFE messages, this class handles the following messages:",{"@attributes":{"id":"p-0415","num":"0414"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["IFE Message","Function Called","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Ack or Nak","SetNextState(\u2009)","Sets the next state for"]},{"entry":[{},{},"the video announcement"]},{"entry":[{},{},"associated with the"]},{"entry":[{},{},"Player Configuration"]},{"entry":[{},{},"Object pPlayerConfig."]},{"entry":["PlayNextVA","PlayNextAnnouncement(\u2009)","First, determines if the"]},{"entry":[{},{},"next announcement in"]},{"entry":[{},{},"the Video Announcement"]},{"entry":[{},{},"Play list requires"]},{"entry":[{},{},"installation of a new"]},{"entry":[{},{},"tape (i.e., Media ID)."]},{"entry":[{},{},"If so, then an"]},{"entry":[{},{},"Unsolicited message is"]},{"entry":[{},{},"transmitted to the GUI"]},{"entry":[{},{},"and the video announce-"]},{"entry":[{},{},"ment cycle is suspended."]},{"entry":[{},{},"Once paused, the cycle"]},{"entry":[{},{},"must be restarted via"]},{"entry":[{},{},"either Start-"]},{"entry":[{},{},"VideoAnnouncement(\u2009)"]},{"entry":[{},{},"or ResumeVideo-"]},{"entry":[{},{},"Announcement(\u2009)."]},{"entry":["SubProcessStart","InitService(\u2009)","Performs the necessary"]},{"entry":[{},{},"Inits to get this Service"]},{"entry":[{},{},"going, including: Set-"]},{"entry":[{},{},"AudioDistributionInfo(\u2009)"]},{"entry":[{},{},"SetVideoDistribution-"]},{"entry":[{},{},"Info(\u2009)"]},{"entry":[{},{},"SetPlayerInfo(\u2009)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Sales Services control all the functions of In-Flight Service in which goods and entertainment are made available to passengers . Sales Services \u2013 are divided into the following Services: GamesService , MovieSaleService , CatalogService , DutyFreeService , and DrinkService .","The design structure of the Sales Service classes are similar to the Cabin Service classes, except that sales services \u2013 launch many more ProcessRequest( ) threads  to be able to service as many passengers  as possible. This is not necessary for the Cabin Services because they do not service individual passengers ; they service the system as a whole.","In addition to its overcast versions of the Service class virtual functions, SalesService Class includes its own virtual definitions within its children classes. This keeps the CAPI consistent in its calls:",{"@attributes":{"id":"p-0419","num":"0418"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["SalesService Virtual Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["virtual bool","Abstract to cancel an open order."]},{"entry":"CancelOrder"},{"entry":"(ID OrderID)"},{"entry":["virtual ID","Abstract to Create an order."]},{"entry":"CreateOrder"},{"entry":"(unsigned char *ProductCode,"},{"entry":"long Quantity,"},{"entry":"LRU_NAME Seat,"},{"entry":"unsigned char"},{"entry":"*EmployeeNumber"},{"entry":"long lProductMap,"},{"entry":"MONEY AmountDue)"},{"entry":["virtual bool","Abstract to schedule an Order for"]},{"entry":["DeliverOrder","Delivery."]},{"entry":"(ID OrderID,"},{"entry":"GENERIC_TEXT"},{"entry":"EmployeeNumber)"},{"entry":["virtual bool","Abstract to record the payment for"]},{"entry":["PayForOrder","an order."]},{"entry":"(ID OrderID,"},{"entry":"MONEY AmountCash,"},{"entry":"MONEY AmountCredit,"},{"entry":"GENERIC_TEXT CurrencyCode,"},{"entry":"GENERIC_TEXT"},{"entry":"EmployeeNumber,"},{"entry":"GENERIC_TEXT"},{"entry":"AccountNumber,"},{"entry":"GENERIC_TEXT ExpirationDate,"},{"entry":"GENERIC_TEXT CardName,"},{"entry":"CREDITCARDS CardType)"},{"entry":["virtual bool","Abstract to Refund an order."]},{"entry":"RefundOrder"},{"entry":"(ID OrderID,"},{"entry":"GENERIC_TEXT"},{"entry":"EmployeeNumber,"},{"entry":"bool RevokeProduct)"},{"entry":["virtual bool","Abstract to start the I\/O with"]},{"entry":["StartPipeThreads(\u2009)","Transaction Dispatcher."]},{"entry":["virtual bool","Abstract to start ProcessRequest(\u2009)"]},{"entry":["StartUpProcessThreads(\u2009)","threads."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"SalesService also provides several \u2018generic\u2019 sales functions, as shown in the sub-sections that follow.","The following functions are called by CAPI functions. In the Sales Services \u2013, all CAPI calls cause an update message to be built and sent to the applicable seat , so that it knows the status of its sales.",{"@attributes":{"id":"p-0422","num":"0421"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["SalesServiceClass Public Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bool","Removes the any OrderId records"]},{"entry":["BackOrderOut","from the database."]},{"entry":"(CONTEXTHANDLESTRUCT"},{"entry":"*pContexHandle,"},{"entry":"ID OrderID)"},{"entry":["bool","Sets the status of the store to"]},{"entry":["CloseSalesStore","Closed."]},{"entry":"(ID StoreID)"},{"entry":["SERVICESTATUSTYPE","Verifies the type of card,"]},{"entry":["IsValidCreditCard","expiration date and checksum"]},{"entry":["(char *CardNumber","according to the policy of this"]},{"entry":["char *ExpirationDate","card type."]},{"entry":"double CreditAmount,"},{"entry":"CONTEXTHANDLESTRUCT"},{"entry":"ContextHandle)"},{"entry":["bool","Sets the status of the store to"]},{"entry":["OpenSalesStore","Open."]},{"entry":"(ID StoreID)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following functions are provided to support these IFE Messages for all Sales:",{"@attributes":{"id":"p-0424","num":"0423"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["IFE Message","SalesService Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BackOut","bool","Removes the order from"]},{"entry":[{},"BackOrderOut","the database. This is"]},{"entry":[{},"(CONTEXTHANDLESTRUCT","usually due to an error"]},{"entry":[{},"*pContextHandle,","during processing,"]},{"entry":[{},"ID OrderID)","rather than a customer"]},{"entry":[{},{},"request."]},{"entry":["Cancel","bool","Cancels an open order"]},{"entry":[{},"PrepareCancel","upon customer request."]},{"entry":[{},"(CONTEXTHANDLESTRUCT"]},{"entry":[{},"*pContextHandle,"]},{"entry":[{},"Seat_Message"]},{"entry":[{},"*pSeatMessage)"]},{"entry":["Complete-","void","Collects revenue and"]},{"entry":["Update","ProcessUpdateRequest","movie or game lock"]},{"entry":[{},"(Seat_Message *pMsg,","information for a"]},{"entry":[{},"IfeIdType nProcessID,","specified seat and"]},{"entry":[{},"Queue *pTransmitQueue)","returns the data to the"]},{"entry":[{},{},"SeatNAU."]},{"entry":["Delivery","bool","Prepares an order for"]},{"entry":[{},"PrepareDelivery","delivery."]},{"entry":[{},"(CONTEXTHANDLESTRUCT"]},{"entry":[{},"*pContextHandle,"]},{"entry":[{},"Seat_Message"]},{"entry":[{},"*pSeatMessage)"]},{"entry":["Incremental-","void","See CompleteUpdate"]},{"entry":["Update","ProcessUpdateRequest(\u2009)","message above."]},{"entry":["Payment","bool","Applies the provided"]},{"entry":[{},"PreparePayment","payment information to"]},{"entry":[{},"(CONTEXTHANDLESTRUCT","the specified order."]},{"entry":[{},"*pContextHandle,"]},{"entry":[{},"Seat_Message"]},{"entry":[{},"*pSeatMessage,"]},{"entry":[{},"ID *OrderID)"]},{"entry":["Refund","bool","Processes a refund"]},{"entry":[{},"PrepareRefund","request to return"]},{"entry":[{},"(CONTEXTHANDLESTRUCT","payment(s) to a"]},{"entry":[{},"*pContextHandle,","customer and update"]},{"entry":[{},"Seat_Message","inventory (if needed)."]},{"entry":[{},"*pSeatMessage)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Movie Viewing is a highly variable feature of the system. At the discretion of the airline, and subject to change from time to time, different video offerings are free to certain classes of passengers , while others are chargeable. The Movies Sales Service  controls this feature. The database tables affected by the VideoAnnouncementService Class are: Policy, Price, VideoMedium, VideoSegment, and VideoUse.","Derived from SalesService class, the MovieServiceClass provides the functions needed to process the sales of movies onboard. Like CabinService class, it provides its own ProcessRequest( ), GetMessage( ), PutMessage( ), etc. functions.","The following overcast functions are called by their corresponding CAPI calls : CancelOrder( ), CreateOrder( ), DeliverOrder( ), PayForOrder( ), and RefundOrder( ).","In addition to the CAPI support functions, IFE Message Support  also handles incoming IFE Messages using its overcast ProcessRequest( ) thread . Currently, all of the supported messages are supported using inline code that includes functions from the generic SalesService class along with the following:",{"@attributes":{"id":"p-0429","num":"0428"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"IFE Message","Function","Purpose"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Order","CreateOrder(\u2009)","See CAPI Support"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Nintendo Video Games are available for passengers to enjoy. To play them, a request must be made and often a payment is required. The Games Rental Service  uses the database tables GameDetail, Policy, and Price.","Derived from SalesService class, the GameServiceClass provides the functions needed to process the sales of movies onboard. Like CabinService class, it provides its own ProcessRequest( ) , GetMessage( ) , PutMessage( ) , etc. functions.","The following overcast functions are called by their corresponding CAPI calls: CancelOrder( ), CreateOrder( ), DeliverOrder( ), PayForOrder( ), and RefundOrder( ). See SalesService class for details.","In addition to the CAPI support functions , IFE Message Support  also handles incoming IFE Messages using its overcast ProcessRequest( ) thread . Currently, all of the supported messages are supported using inline code that includes functions from the generic SalesService class along with the following:",{"@attributes":{"id":"p-0434","num":"0433"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"IFE Message","Function","Purpose"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Order","CreateOrder(\u2009)","See CAPI Support"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Package Entertainment is a hybrid of Games and Movies Sales and is maintained within the MoviesSales class. It involves a one-time purchase to all entertainment services onboard. The Package Entertainment Functions may be used to control this capability, but currently the SEAT NAU and CAPI.CPP calls  route Package products to either the Game Service or the Movie Service, based on the product code that is used. The PackageDetail table is used to identify the components of a \u201cPackage\u201d.","Purchasing goods through an electronic catalog is an enhancement provided by the system . All functions that control it are kept in the Catalog Sales Service . The following tables support the feature: Address, Order_, and ShippingRate.","Ordering drinks through the In-Flight Entertainment system  is provided. All functions that control it are kept in the Drinks Sales Service . The following table supports the feature: Product.","Purchasing onboard duty-free goods through the In-Flight Entertainment system  is provided. All functions that control it are kept in the Duty Free Sales Service . The following tables support the feature: Cart, CartInventory, Commitment, and InventoryLog.","All the application-level database functions are directly accessible via calls to the CAPI functions. These calls are available directly, or via the RPC server. Thus, any service as well as any RPC client can access the CAPI calls.","CAPI.CPP  contains the actual commands that interface to the database  and perform the application duties (such as CreateOrder( ), GetOrder( ), etc.). CAPI_S.C  is the RPC server whose functions are made available to RPC clients (via CAPI_C.C). The server functions use the CAPI.CPP  calls to perform application duties. They are used together to make up this set of routines. In addition, the PAT GUI  can also access CAPI.CPP via APIINT.CPP and CAPI_S.C in the RPCCLNT.DLL.","The cabin file server database  stores the following types of information. This information is utilized by both the cabin file server application and the PAT GUI  and is described in greater detail below.","The cabin file server database  stores other line replaceable units in the IFE system , the products and services available to the passengers , revenue due to the sales of products and services, system usage due to the flight attendants and passengers , surveys offered to passengers , the state of the cabin file server application, video announcements, and global attributes of the IFE system .","The cabin file server database  provides storage for line replaceable unit information. This enables the cabin file server application to communicate with and\/or control these other devices. Some line replaceable unit information is provided by the two data files that are generated by the ACS tool. Line replaceable unit information is stored in the following tables: LRU, Member, PA_Volume, PassengerMap, Set_, and VideoPlayer.","All purchased goods and services, purchase summary information, complimentary service assignments, and movie lockout information is stored on a per passenger basis. This information may be swapped from one seat  to another seat to accommodate the occasion when a passenger  must be moved during a flight. Each passenger  is represented in a PassengerMap table by a single record. This record contains the following pertinent information:",{"@attributes":{"id":"p-0445","num":"0444"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field Name","Purpose"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SeatNumber","Passenger seat number"]},{"entry":[{},"PassengerID","Passenger Identifier"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"When a passenger  changes seats, the SeatNumber fields of the two records involved are swapped. Thus, all the information associated with the passenger  is not with the seat , but with their PassengerID.","The viewing of any movie and\/or the playing of any game can be locked out at any seat, usually at the request of a parent to prevent a child from seeing a certain movie or excessive game play. Each passenger  is represented in the PassengerMap table by a single record. This record contains the following pertinent information:",{"@attributes":{"id":"p-0448","num":"0447"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field Name","Purpose"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SeatNumber","Passenger seat number"]},{"entry":[{},"MovieLockoutMap","Movie lockout bit map"]},{"entry":[{},"GameLockoutMap","Game lockout bit map"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The MovieLockoutMap and GameLockoutMap fields are bit map fields whose bits correspond to individual movie and game titles, respectively. A movie or game is locked out when it's corresponding bit in this field is set to one.","Loss of communication with a seat display unit is also recorded in the PassengerMap table.",{"@attributes":{"id":"p-0451","num":"0450"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field Name","Purpose"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SeatNumber","Passenger seat number"]},{"entry":[{},"SeatCommSuccessCount","# Successful communications"]},{"entry":[{},"SeatCommFailCount","# Unsuccessful communications"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At the beginning of each flight, the SeatCommFailCount and SeatCommSuccessCount fields for each seat are initialized to zero. The SeatCommFailCount field is incremented for each first-time-failure encountered for the corresponding seat  (i.e., increment if fail <=success). The SeatCommSuccessCount field is incremented for each first-time-success encountered for the corresponding seat (i.e., increment if success<fail). These rules are enforced through triggers on these database fields. The seat  is considered bad if the SeatCommSuccessCount is less than the SeatCommFailCount.","The cabin file server database  provides storage for product and service information (e.g., movie titles, viewing times, movie audio languages, game titles, audio entertainment titles, audio channels, etc.). This information is sent by the cabin file server application to the Seat Display Unit for each flight. This enables up-to-date information to be presented to the passengers  so they can know which products and services are available to them and at what cost on a per flight basis. Product and Service information is stored in the follow MovieCycle ing tables: AudioDetail, Cart, CartInventory, GameDetail, IFE_Service, InventoryLog, MovieCycleDetail, PackageDetail, Price, Product, ProductEffectivity, Route, ShippingRate, Store, VideoMedium, VideoPlayer, VideoSegment, and VideoUse.","Video Game information is maintained in the GameDetail table, one record per Title\/EffectivityDate combination:",{"@attributes":{"id":"p-0455","num":"0454"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Field Name","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Title","The Game Title that is displayed on the seat display unit"]},{"entry":[{},"122a"]},{"entry":["EffectivityDate","The date on or after which this game information is"]},{"entry":[{},"effective."]},{"entry":["RouteType","The flight route type during which this game is"]},{"entry":[{},"available."]},{"entry":["ProductCode","Corresponds to a product code in the Price table for"]},{"entry":[{},"price lookups."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Video Game information is maintained in the VideoMedium table, one record per video program, one record per MediaTitle:",{"@attributes":{"id":"p-0457","num":"0456"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Field Name","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MediaTitle","The Game Title that is displayed on the seat display"]},{"entry":[{},"unit 122"]},{"entry":["ProductCode","Corresponds to a product code in the Price table for"]},{"entry":[{},"price lookups."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The IFE system  can inhibit the selectability of these video programs based on the date stored in the EffectivityDate of the VideoSegment table. Movie titles are associated with a specific flight route through the RouteType field of the VideoUse table. Prices are controlled via these fields in the Price table, one per ProductCode\/RouteType combination:",{"@attributes":{"id":"p-0459","num":"0458"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Field Name","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ProductCode","Corresponds to Game or Movie Products for sale"]},{"entry":["RouteType","The flight route type during which this price applies"]},{"entry":["FreeMap","Identifies which zones (identified in bitmap) offer this"]},{"entry":[{},"product free of charge"]},{"entry":["Pricing1","Pricing structure for zone 1 during this flight route"]},{"entry":["Pricing2","Pricing structure for zone 2 during this flight route"]},{"entry":["Pricing3","Pricing structure for zone 3 during this flight route"]},{"entry":["Pricing4","Pricing structure for zone 4 during this flight route"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The database tables used in Movie Cycle are: Member, MovieCycle, Set_, Videomedium, VideoPlayer, VideoSegemnt, and VideoUse.","Video sources such as video cassette player  or video reproducers (VR)  are assigned to a movie cycle through the Member and Set_tables. Each VCP or VR  is stored in the Member field of the Member table. Each movie cycle is stored in the SetName field of the Set_table. The following movie cycle information is stored in the database.","A movie cycle type is a predefined grouping of video reproducers  and movie titles. Movie titles are assigned to video reproducers  through the VideoMedium and VideoUse tables. The database  can store up to eight different movie cycle types. Information about each movie cycle type is stored in the MovieCycle table. A movie cycle can include from one to fifteen video reproducers  (i.e., one to fifteen records of the Member table can be associated with a single movie cycle in the Set_table).","The start time for a movie cycle is stored in the RelativeStartTime field of the MovieCycle table. It is stored in minutes relative to the time since movie cycle initiation at the primary access terminal . A between-cycle intermission time is stored in the IntermissionLength field of the MovieCycle table. It is stored in minutes and must exceed the time required to prepare the video reproducer  containing the longest playing tape for the next cycle (e.g., tape rewind).","The end time of a movie cycle is the time in which the final viewing of a particular movie cycle ends. The number of viewings that can be scheduled for each movie cycle depends upon the length of a single viewing of the movie cycle and the flight duration. The length of a single viewing of the specific movie cycle can be calculated by adding the IntermissionLength field of the MovieCycle table to the SegmentRunTime field of the VideoSegment table for the movie with the longest run time in the specific movie cycle. The expected flight duration is stored in the FlightDuration field of the Flight table.","Information about the state of a particular Video Reproducer  is stored in the State field of the VideoPlayer table. This information includes whether or not the video reproducer  is operational, whether or not the video reproducer  contains a tape, etc.","The number of minutes before the start of each cycle can be calculated using the RelativeStartTime field of the MovieCycle table, the calculated length of the single viewing of the movie cycle, and the IntermissionLength field of the MovieCycle table. The number of minutes before intermission for the current cycle is stored in the RemainingViewingTime of the MovieCycle table.","The number of minutes until the next viewing of a specific movie cycle is stored in the NextViewingTime of the MovieCycle table. The number of minutes remaining on the current viewing of the specific movie cycle is stored in the RemainingViewingTime of the MovieCycle table. The number of minutes elapsed into the current viewing of the specific movie cycle is stored in the Elapsed ViewingTime of the MovieCycle table.","A predetermined set of movies and\/or games can be assigned to an airline-defined package. Package information is stored in the PackageDetail table.","Audio programming (entertainment) can be distributed on a maximum of 83 mono audio channels, controlled by the AudioDetail table, one record per program. The title of each audio program is stored in the AudioTitle field. The channel of each Audio program is stored in the AudioChannel field.","The VideoMedium table stores up to four different languages for a particular video tape (e.g., movies). These languages are displayed on the display screen  for passenger selection. The languages are stored in the LanguageCode1, LanguageCode2, LanguageCode3, and LanguageCode4 fields of the VideoMedium table. Each video tape must have one language designated as the default primary language (i.e., LanguageCode1 must not be empty) but it can have up to three other languages. The relationship of the output configuration of the video players and available language configuration is stored in the VideoPlayer table.","Information about each video reproducer  is stored in the VideoPlayer table. In order to \u201cpreview\u201d the output of a particular video player on the primary access terminal screen, both primary access terminal tuners (audio and video) must be tuned to the proper channels. Video channel information for each video reproducer  is stored in the VideoRF_Channel field. Audio time-slot information is stored in the various time slot fields (i.e., LeftTimeSlot1, RightTimeSlot1, LeftTimeSlot2, etc.).","A video reproducer  can be reassigned for use during a video announcement. The MediaType field in the VideoMedium table distinguishes a video announcement from a movie. The VideoUse table tracks which movie or video announcement is assigned to which video reproducer . When a video reproducer  is reassigned, the PlayerName field in the VideoUse table is modified. The playing status of each video reproducer  is stored in the State field of the VideoPlayer table.","Overhead monitors  can be assigned to a video source (i.e., video player ) for movies. This information is stored in the OverheadAudioMap and OverheadVideoMap fields of the MovieCycleDetail table.","The cabin file server database  provides storage for revenue information (e.g., credit card data, cash collection data, etc.) concerning the sales of products (e.g., duty free) and services (e.g., movies and games). When a passenger  uses a credit card to pay for movies or games, this information must be stored in the database so that it can be transferred to the credit card company. Likewise, when a passenger  uses cash to pay for movies or games, this information must be stored in the database  so that the IFE system  has a record of how much cash should be collected by the flight attendant.","Revenue information is stored in the following tables: Address, BadCreditCards, Commitment, CreditCard, Currency_, Exchange, Flight, Order_, OrderHistory, PassengerMap, PAT_History, Policy, Price, Product, ProductEffectivity, ShippingRate, and ValidCardData.","The purpose of transaction processing is to maintain a record of monetary transactions for service and products. When a flight attendant is involved with an order placed by a passenger  (e.g., order refunded, order placed at the PAT, etc.), then the flight attendant ID is stored in the FlightAttendant field of the Order_table.","Information about each product and service is stored in the Product table. Information about each package of goods or services is stored in the PackageDetail table. The pricing information for each product, service, and package is stored in the Price table. Prices can be altered according to the policy stored in the PolicyDescription field of the Policy table. For example, the policy may specify different service price data for movies and games offered in each seat class zone (e.g., first class) in the aircraft .","Services and products may be paid by cash, credit card, or a combination of the two. Cash and credit card payments are respectively stored in the CashTotal and CreditTotal fields of the Order_table. Orders are comprised of sets of products or services of the same type. If the passenger  uses a credit card, the credit card information (e.g., passenger name, account number, etc.) is stored in the CreditCard table.","Cash transactions may be represented in up to 30 different currency types. Information about each currency type is stored in the Currency_table. Each aircraft  has associated with it a base currency that is stored in the BaseCurrencyCode field of the Aircraft table.","Passengers  may pay for products and services using any single card from the credit card types accepted by the airline. Information about each valid credit card type is stored in the ValidCardData table. The credit card payment made on a given order is stored in the CreditTotal field of the Order_table. This payment is recorded in the base currency type as specified in the BaseCurrencyCode field of the Aircraft table.","Credit card numbers are validated against the standard number format and range for that particular credit card type. This standard number format is stored in the ValidationPattern field of the ValidCardData table. Also, credit card transactions are validated against the credit limit specified by the passenger  for that particular credit card type. This credit limit is stored in the CreditLimit field of the ValidCardData table. In addition, each credit card is compared against the credit card numbers in the BadCreditCards table. This table may contain up to 10,000 records, for example.","All transactions (i.e., service orders, product orders) processed by the system are stored in the Order_table. The state of an order (open, paid, canceled, refunded) is stored in the State field of the Order_table. For refunded orders, a duplicate order record is created with the AmountDue field, the CashTotal field, the CreditTotal field, and the Quantity field all set to negative amounts. Orders that are placed at the primary access terminal  also have a corresponding entry in the PAT_History table. A new record is generated for the OrderHistory table for each change to the State field or the Delivered field.","The following information is maintained for each order:",{"@attributes":{"id":"p-0484","num":"0483"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Table","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PassengerMap","SeatNumber","seat number"]},{"entry":["Product","ProductDescription","service or product ordered"]},{"entry":["Order","Quantity","quantity of service or product"]},{"entry":[{},{},"ordered"]},{"entry":["CreditCard","all fields","credit card information for credit"]},{"entry":[{},{},"card orders"]},{"entry":["Price","UnitPrice","unit cost of service or product"]},{"entry":[{},{},"ordered"]},{"entry":["Order","AmountDue","total cost of service or product"]},{"entry":[{},{},"ordered"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Prior to shutdown of the IFE system , a message is displayed on the primary access terminal  if the database  contains any open transactions from the current flight. The number of open orders for the current flight is always displayed in the status window on the primary access terminal . This is calculated by counting each order in the Order_table (for the current flight) whose associated State field is set to \u201cOpen\u201d.","A running tabulation of all expenses incurred for each passenger during the current flight can be displayed on the seat display unit or seat display . Each order is associated with a specific passenger  via the PassengerID field of the Order_table. The total cost of each order is stored in the AmountDue field of the Order_table. Total expenses incurred for a particular passenger  is the sum of the total cost of each order placed by the specific passenger .","The following subsections describe selected database interactions that occur when the corresponding functions in the SalesServiceClass classes are executed.","Upon cancellation of any cash passenger product and\/or service order that has not been paid, the State field of the Order_table is changed from \u201cOpen\u201d to \u201cCancelled\u201d. If the service (i.e., video game or movie) is revoked from the passenger , then the ProductRevoked field in the Order_table is set to TRUE.","A list of orders can be generated for which cash collection is to be made in-flight. Information related to each order is as follows:",{"@attributes":{"id":"p-0490","num":"0489"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Table","Field","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PassengerMap","Seat Number","seat number"]},{"entry":[{},"Product","ProductDescription","product or service"]},{"entry":[{},{},{},"ordered"]},{"entry":[{},"Order","AmountDue","amount due"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Orders can be listed by service type and\/or by general service zone. The service type of an order (i.e., game, movie, package) is stored in the ServiceType field of the Product table. The general service zone of the passenger  that placed the order is stored in the SetName field of the Set_table.","A list of orders can be generated for which delivery is to be made in-flight. Information related to each order is as indicated above. Orders can be listed by service type and\/or by general service zone.","Complimentary service for movies, games, and\/or entertainment packages may be offered to individual passengers or to the entire aircraft . For individual passengers, an order is placed in the Order_table for each passenger  receiving a service that is complimentary, the PayCurrencyCode field is set to \u201cFree\u201d and the State field is set to \u201cPaid\u201d. The order is then associated with the record in the PassengerMap table where the SeatNumber corresponds to the specific passenger .","To provide complimentary service for the entire aircraft , all entertainment (movies, games, packages) must be complimentary. A single order is placed in the Order_table: The PayCurrencyCode field is set to \u201cFree\u201d and the State field is set to \u201cPaid\u201d. The order is then associated with the record in the PassengerMap table where the SeatNumber field is set to \u201cAllseats\u201d. The FreeServicesMode field of the Aircraft table is set to TRUE.","The system  can support up to thirty forms of currency. Currency information is stored in the Currency_table. Exchange rate information is stored in the Exchange table. Currency exchange rate calculations can be performed that support a display with up to four decimal places. The number of decimal places to display is stored in the DisplayPrecision field of the Currency_table.","Each currency is associated with a Policy table entry to specify how to convert from one currency to another. For example, the policy for converting to US dollars might be to round to the nearest penny, or nearest whole dollar if the airline does not wish to deal with change. The policy actually points to the applicable stored procedure to perform this function.","The cabin file server database  provides storage for system usage by both the flight attendants and passengers .","The cabin file server database  keeps track of each time the flight attendant logs on and off. Additionally, the flight attendants may also enter flight identification information (e.g., flight number, destination, etc.) which is stored in the cabin file server database . Flight attendant activity is stored in the following tables: Access, Flight, and Personnel.","Each time a user (i.e., employee) logs in to the IFE system , this login information is stored in the Access table. It is also added to the Personnel table (once for each user) if a predefined set of valid users does not already exist. If a predefined set of valid users is preloaded into the Personnel table, then each user that tries to login can be validated against this pre-defined set of valid users.","An access level for each user is stored in the AccessLevel field of the Personnel table. This access level can be used to direct the user's access throughout the system , effectively controlling what they can see or do. For example, a Service Person should not have access to Revenue Modification functions.","When users are required to insert a magnetically encoded card during the logon process, the card is encoded with the user ID (EmployeeNumber field), pin number (PIN field), and grade level (AccessLevel). This information is stored in the Access table for each login. This information is also added to the Personnel table (once for each user) if a pre-defined set of valid users does not already exist. If a predefined set of valid users is preloaded into the Personnel table, then each user that tries to login can be validated against this predefined set of valid users.","In the case where the card read is not successful, the user must manually enter the user ID, pin number, and grade level. This information is stored in the Access table for each login. This information is also added to the Personnel table (once for each user) if a predefined set of valid users does not already exist. If a predefined set of valid users is preloaded into the Personnel table, then each user that tries to login can be validated against this predefined set of valid users.","The cabin file server database  also logs system activity (i.e., passenger usage of the system  from the seat display unit standpoint). The database  stores how much time each seat spent on each movie, on each game, and on each audio selection. This allows the airline to see how passengers  are using the system .","Passenger activity is stored in the following tables: PassengerStatistics.","The following passenger statistic information is stored in the database :",{"@attributes":{"id":"p-0506","num":"0505"},"tables":{"@attributes":{"id":"TABLE-US-00060","num":"00060"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Table(s)","Field(s)","Definition or Comment."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PassengerMap","SeatNumber","Each passenger is associated with their"]},{"entry":[{},"PassengerID","seat number."]},{"entry":["Member Set","Member","Each seat number is associated with one"]},{"entry":[{},"SetName","class (e.g., first class, coach, etc.). The"]},{"entry":[{},{},"seat number is stored in the Member"]},{"entry":[{},{},"field of the Member table. The class is"]},{"entry":[{},{},"stored in the SetName field of the Set"]},{"entry":[{},{},"table."]},{"entry":["Passenger-","StatImage","Time spent viewing movies by title:"]},{"entry":["Statistics",{},"Each movie watched and length of"]},{"entry":[{},{},"time spent watching each movie is"]},{"entry":[{},{},"stored here as a Binary Large OBject"]},{"entry":[{},{},"(BLOB) which can hold up to 2GBytes"]},{"entry":[{},{},"of data if disk space allows."]},{"entry":["Passenger-","StatImage","Time spent listening to entertainment"]},{"entry":["Statistics",{},"audio by title: Each audio entertainment"]},{"entry":[{},{},"listened to and the length of time spent"]},{"entry":[{},{},"listening to each audio entertainment is"]},{"entry":[{},{},"additionally stored here (BLOB)."]},{"entry":["Passenger-","StatImage","Time spent playing games by title:"]},{"entry":["Statistics",{},"Each game played and length of"]},{"entry":[{},{},"time spent playing each game is"]},{"entry":[{},{},"additionally stored in the here (BLOB)."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The cabin file server database  provides storage of passenger survey information. Passengers  at each seat  can elect to participate in the survey. The database  records each result (i.e., passenger's answer) to each survey taken so that this information can be made available to the airline. Passenger survey information is stored in the following tables: Survey, SurveyAnswer, SurveyAnswerKey, and SurveyQuestion.","The results of each survey taken (or same survey taken multiple times) by each passenger are stored in the SurveyAnswer table. Survey results may be off-loaded using the Data Offload approach discussed above. The name of the survey is stored in the Survey table. The corresponding questions contained in the survey are stored in the SurveyQuestion table. All possible answers (i.e., six multiple choice answers) for each survey question are stored in the SurveyAnswerKey table.","The cabin file server database  provides storage for application state information. This is useful in cases where there is an interruption of aircraft power while the application is running. Storing this information in the database  allows the system to resume operation where it left off. There may be over 100 processes running at any given time. Each process can store as much information as needed in the Data field of the PowerRecovery table in order for the process to know where it should continue once power is resumed. The Data field is defined as a Binary Large OBject (BLOB).","The state (e.g., start, pause, stop, init) of the IFE system  is stored in the IFE_State field of the Aircraft table. Products and\/or services ordered by the passenger  are stored in the Order_table (as well as at the seat display unit for backup). This enables the IFE system  to start from where it left off once passenger entertainment and interactive services are resumed.","The cabin file server database  provides storage for Video Announcement information. This information may include attributes such as video announcement titles, overhead audio, overhead video, and whether in-seat displays  are overridden. Video Announcement information is stored in the following tables: VA_Distribution, VideoMedium, VideoSegment, VideoPlayer, and VideoUse.","Video Announcement information is stored in the VideoMedium table. Examples include boarding announcements, safety announcements, short subject programs, etc. Each Video Announcement has more specific information stored in the VideoSegment table.","Attributes for each Video Announcement are stored in the VA_Distribution table. Attributes include, but are not limited to: if the announcement is heard on the overhead audio and in which zone (OverheadAudioMap field, where each bit in the field represents a zone), if the announcement is viewed on the overhead video and in which zone (OverheadVideoMap field, where each bit in the field represents a zone), if the announcement (audio and video) overrides whatever is currently being viewed at the seat (InseatOverrideMap field, where each bit in the field represents a zone), or be available for in-seat viewing (default) and in which zone.","Video Announcements (audio and video) are available for in-seat viewing (default). This means that the passenger  has the option to select the video channel on which the video announcement is being played. Video Announcements can also be set to override in-seat viewing. In this case, the IFE system  causes the overridden in-seat displays in a specified zone to select the video channel on which the video announcement is being played, and the passenger  is unable to turn off the in-seat video display .","Each Video Announcement is assigned to a particular source (i.e., video player) through the VideoUse table. Attributes for each video player are stored in the VideoPlayer table. The default volume level for the PA speakers is stored in the DefaultPA_AudioLevel field of the Aircraft table. The volume level for the PA speakers can be different for each zone. This is stored in the AudioLevel field in the PA_Volume table.","Overhead monitors  can be assigned to a video source (i.e., video player ) for video announcements. This information is stored in the OverheadAudioMap and OverheadVideoMap fields of the VA_Distribution table.","The cabin file server database  provides storage for global attribute information (i.e., information that can be accessed by any service). Examples may include the current state of the IFE system , the base currency, and the default PA audio. IFE system global attribute information is stored in the following tables: Aircraft, Airline, Airport, Country, Flight, and Route.","The following flight information is pre-loaded and stored in the Route table, one record per known route:",{"@attributes":{"id":"p-0519","num":"0518"},"tables":{"@attributes":{"id":"TABLE-US-00061","num":"00061"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FlightNumber","flight number assigned to this flight leg"]},{"entry":[{},"FlightDuration","estimated flight duration in minutes"]},{"entry":[{},"DepartureAirport","departure airport code"]},{"entry":[{},"ArrivalAirport","arrival airport code"]},{"entry":[{},"RouteType","route type to determine which services are"]},{"entry":[{},{},"available on this route"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"When the flight attendant enters a FlightNumber and RouteType at the primary access terminal , the corresponding flight information (i.e., FlightDuration, ArrivalAirport, and DepartureAirport) is found in the Route table and presented at the primary access terminal  and stored in the current record of the Flight table. The DepartureDate and DepartureTime are determined based on when the weight-off-wheels signal is received. This date and time is then stored in the WeightOffWheelTime field of the Flight table to calculate movie cycle and other sales times.","The following IFE data is configurable in order to tailor the IFE functionality for a particular airline. This tailoring is done using the IFE Tools software.\n\n","The primary access terminal  must perform certain coordinating functions prior to being able to operate with the cabin file server  successfully. A System Initializer establishes the cabin file server hard drives as shared devices with the primary access terminal , synchronizes its system date and time with the date and time of the cabin file server , and turns on the LCD's backlight so the user can see what's going on. The System Initializer, INITSYS.EXE, performs these functions at boot time. This program includes the source file INITSYS.CPP.","Primary access terminal Stand Alone Utilities are PAT-resident utilities that are needed between runtimes (i.e., between flights). They are used by Service Personnel to manage data and system behavior.","A Data Offloader is provides so that specific data is offloaded from the aircraft  for the purpose of revenue collection and system performance evaluation. At the end of each flight, the NT event logs are archived on the cabin file server hard disk. Passenger Statistics information, passenger survey results, and Transaction records are stored in the cabin file server database  for later retrieval.","This database information is stored for up to forty flight legs. The number of flight legs is stored in the FlightID field of the Flight table. FlightID is simply a counter which is incremented after each flight. The Data Offload approach discussed previously describes the Data Archival, Data Offload and Disk Space Management processes.","The following paragraphs describe the additional functionality associated with the Data Offload process, in the utility OLUTIL.EXE.","The flight number for a test flight always begins with a \u201c9\u201d. This enables a custom trigger, FLIGHT_ITRIG.SQL, to purge just test flight data (i.e., flights beginning with a \u201c9\u201d) from the database at the beginning of a subsequent flight. The purge is automatically performed at the beginning of the next flight rather than at the end of the test flight so that the information can remain in the database long enough to offload the data for trouble-shooting purposes but not so long that credit card data may be compromised. However, if the Data Offload process is manually initiated at the end of the test flight, then the test flight data is purged at this time.","Archived data (i.e., previous flight leg) can be off-loaded on a per-flight basis. All credit card transaction data is encrypted using PKZIP.EXE (an industry-standard third-party file-compression utility). PKZIP was chosen because it provides excellent file compression ratios and allows for password encryption of the compressed data.","At the start of each flight, the Offload field in the Flight table for the specific flight is initialized to one. Once a particular flight has been off-loaded, the Offload field in the Flight table is set to zero (i.e., flight data is tagged). It is possible to automatically specify the off-load of all non-tagged data (i.e., all flights with Offload field set to one). It is also possible to manually specify the off-load of data for a specific flight.","An operator is able to disable the Watchdog driver . DISWDOG.EXE is used to disable the hardware Watchdog by issuing an IOCTL Disable command to the Watchdog Driver .","Cabin file server Runtime Utilities  are programs that are used once per flight, either at the beginning or at the end. As a result, they are part of the application and are maintained along with the cabin file server Executive Extensions.","SDU_BLDR.EXE, the seat display unit database builder, is used to develop a download file to be downloaded to all seats . The download file is comprised of product and entertainment information that is subject to change based on the contents of the cabin file server database .","When flight information is entered by the Flight Attendants at the primary access terminal , the SDU_BLDR on the cabin file server  is initiated. The GUI  calls SDU Builder via the CAPI to extract the information from the cabin file server database  that is pertinent to the current flight. This information is used to create the download file (sdu_data.dnl) that is sent to each seat  on the aircraft .","The purpose of sdu_data.dnl is to provide current information (i.e., entertainment, pricing, etc.) from the database  to the passenger seats . The creation of the download file triggers the Seat NAU to notify each seat that a new download file exists. Each seat then requests the file and applies the portion of the download file that is applicable to their programming (i.e., first class seats don't read the information in the download file applicable to coach seats ).","CFSLOGS.EXE is the main C++ executable associated with the archival of the event logs. It runs on the cabin file server  and is initiated during the data archive process. Cfslogs.exe is responsible for dumping the NT event logs of the cabin file server  to the hard disk using a unique archive file name. This file name is passed to cfslogs.exe as an input parameter.","DUMP_POS.EXE is the main C++ executable associated with offloading Point of Sales data. It runs on the cabin file server  and is initiated during the data offload process. Dump_pos.exe is responsible for writing the archived database information for a given flight to the various FLTSALES.CSV files on the hard disk. The flight ID is passed to dump_pos.exe as an input parameter.","PARCHIVE.EXE is the main C++ executable associated with the purging of archive data. It runs on the cabin file server  and is initiated as part of the effort to manage the disk space on the cabin file server . Parchive.exe is responsible for deleting both the Archive file and the Offload file from the hard drive. Both of these files are passed to parchive.exe as input parameters.","DUMPSTAT.EXE is the main C++ executable associated with offloading Passenger Statistic data. It runs on the cabin file server  and is initiated during the data offload process. Dumpstat.exe is responsible for writing the archived database information for a given flight to the paxstats.csv files on the hard disk. The flight ID is passed to dumpstat.exe as an input parameter.","Common Software Libraries","The following common software libraries of functions and utilities are used throughout the primary access terminal and cabin file server applications.","The Database Utilities, DBUTILS.CPP are commonly used by all database applications. They use the SQL commands (recognizable as starting with db . . . (j, such as dbexit( ), dbresults( ), etc.):",{"@attributes":{"id":"p-0541","num":"0558"},"tables":{"@attributes":{"id":"TABLE-US-00062","num":"00062"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CheckResults(\u2009)","Continuously loops calling dbresults(\u2009) to"]},{"entry":[{},"get the results of the prior SQL call for this"]},{"entry":[{},"process until they have all been obtained."]},{"entry":[{},"If there are errors, it displays function"]},{"entry":[{},"text for tracing."]},{"entry":["UpdateStats(\u2009)","Updates the statistics of the given table for"]},{"entry":[{},"the given process."]},{"entry":["FailureExit(\u2009)","Standard exit function, displays the error"]},{"entry":[{},"before calling dbexit(\u2009)."]},{"entry":"TransactionLogControl(\u2009)"},{"entry":"SelectIntoControl(\u2009)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The event logging functions, EVENTLOG.CPP, RETRYSYS.CPP, are used exclusively in SYSMON.EXE and POWERDWN.EXE. They each call EventLog's ProblemReport( ) subroutine (which is recursive!) which calls EventLog::WriteHAILog( ) which eventually uses NT's ReportEvent( ) to record the information.","The set SQL Error and Message Handlers, HANDLERS.CPP includes two routines used by functions such as ARCHIVE.CPP CREATEDB.CPP DUMP_POS.CPP, INITDB.CPP and SUD_BLDR.CPP to handle SQL informational and error messages: err_handler( ) and msg_handler( ). These functions are identified to the SQL code using dberrhandle(err_handler) and dbmsghandle(msg_handler) respectively.",{"@attributes":{"id":"p-0544","num":"0561"},"tables":{"@attributes":{"id":"TABLE-US-00063","num":"00063"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["int err_handler","Builds a DB-LIBRARY error message"]},{"entry":["(input DBPROCESS *dbproc,","containing both a database error (dberr"]},{"entry":["input int severity,","and dberrstr) and an operating system"]},{"entry":["input int dberr,","error (oserr and oserrstr), echoes"]},{"entry":["input int oserr,","it to stdout and (if oserr"]},{"entry":["input char *dberrstr,","is not DBNOERR) uses"]},{"entry":["input char *oserrstr)","UtilityClass::LogEvent(\u2009) to put"]},{"entry":[{},"this info into the event log. See"]},{"entry":[{},"UtilityClass::LogEvent(\u2009) for severity"]},{"entry":[{},"definition."]},{"entry":[{},"Returns INT_EXIT if the database"]},{"entry":[{},"process pointer dbproc is no good."]},{"entry":[{},"Otherwise, INT_CANCEL."]},{"entry":["int msg_handler","If the severity is greater than zero, it logs"]},{"entry":["(input DBPROCESS *dbproc","it to the event log, otherwise it simply"]},{"entry":["input DBINT msgno,","builds and displays the message."]},{"entry":["input int msgstate","It always returns ZERO."]},{"entry":"input int severity,"},{"entry":"input char *msgtext)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Queues include QUEUE.CPP and QPAIR.CPP. A Queue is a dynamic list of pointers to elements of any type which must wait for sequential processing such as an output queue. The actual elements are not stored in the Queue. A QPair is a set of two Queues used for related purposes, for example one for Input and one for Output associated with a named pipe pair or a serial port.","This class is used to create and maintain all Queues in the Control Center software to buffer message traffic. The first or top or head position of the queue is identified as element number zero (0).","Queues made with this class are considered to be \u201cthread safe\u201d. That is, multiple threads can access these queues concurrently. These queues generate a signal when data is written to them. One can choose whether the queue should signal with only an event handle or with a semaphore as well. This class allows one to create and control the size of (or number of elements in) your queue, move elements in and out of the queue, and allow multiple users or readers to manipulate a single queue.","The following member functions are used to create and control the size of (or number of elements in) the queues.",{"@attributes":{"id":"p-0549","num":"0566"},"tables":{"@attributes":{"id":"TABLE-US-00064","num":"00064"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Queue class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["The Constructors:","Initialize the queue. If no Size (or if Size = 0) is"]},{"entry":["Queue(\u2009),","given, then the Queue is not delimited and can"]},{"entry":["Queue (ULONG Size)","grow to the capacity of the system (defined by"]},{"entry":[{},"constant LONG_MAX). If Size is given,"]},{"entry":[{},"the queue is limited to contain no more than"]},{"entry":[{},"Size elements by having all Put functions"]},{"entry":[{},"display \u201cQueue Overflow\u201d to stdout and"]},{"entry":[{},"returning TRUE when an attempt is made to"]},{"entry":[{},"exceed the limit."]},{"entry":["short","Returns the number of elements currently in the"]},{"entry":["GetCount(\u2009)","queue."]},{"entry":["ULONG","Returns the preset maximum size of the queue. If"]},{"entry":["GetSize(\u2009)","the value returned is zero, the size is not"]},{"entry":[{},"delimited."]},{"entry":["bool","Allows one to increase the maximum size of the"]},{"entry":["SetSize","queue. Returns FALSE if Queue was already"]},{"entry":["(ULONG Size)","defined as undelimited or if the new size is less"]},{"entry":[{},"than the previous size."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Selective Style member functions are used when the priority of the queue elements is controlled.",{"@attributes":{"id":"p-0551","num":"0568"},"tables":{"@attributes":{"id":"TABLE-US-00065","num":"00065"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Queue class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void *","Removes and returns the Nth element from the"]},{"entry":["Get Nth","queue. Returns NULL if the Nth element does"]},{"entry":["(long N)","not exist. If the queue is already locked, it waits"]},{"entry":[{},"for permission to access the queue. Therefore,"]},{"entry":[{},"it is important to lock(\u2009) the queue prior to"]},{"entry":[{},"determining the Nth element (with PeekNth(\u2009),"]},{"entry":[{},"for example) and then retrieving it with"]},{"entry":[{},"GetNth(\u2009)."]},{"entry":["void *","Returns the contents of the Nth element of the"]},{"entry":["PeekNth","list but doesn't remove it from the queue."]},{"entry":["(long N)","If none, returns NULL."]},{"entry":["bool","Inserts the Element's pointer into the queue at"]},{"entry":["Put Nth","position N. If N+1 is greater than the current"]},{"entry":["(void *Element,","number of elements on the queue, then the"]},{"entry":["long N)","Element's pointer is placed at the end of the"]},{"entry":[{},"queue instead of at N. Returns FALSE if."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The FIFO Style member functions are used when a First-In-First-Out FIFO style queue is desired.",{"@attributes":{"id":"p-0553","num":"0570"},"tables":{"@attributes":{"id":"TABLE-US-00066","num":"00066"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Queue class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void *","Returns the element at the top of the list. If none,"]},{"entry":["Get(\u2009)","returns NULL. Same as GetNth(0)."]},{"entry":["void *","Returns the contents of the element at the top of"]},{"entry":["Peek(\u2009)","the list, but doesn't remove it from the queue."]},{"entry":[{},"If none, returns NULL. Same as PeekNth(0)."]},{"entry":["bool","Places the Element's pointer at the end of the"]},{"entry":["Put","queue. Same as PutNth(Element, \u22121)."]},{"entry":["(void *Element)","Returns FALSE if"]},{"entry":["bool","Places Element's pointer at the head or top of the"]},{"entry":["PutHead","queue. Same as PutNth(Element, 0)."]},{"entry":["(void *Element)","Returns FALSE if"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Allow multiple users or readers to manipulate a single queue.",{"@attributes":{"id":"p-0555","num":"0572"},"tables":{"@attributes":{"id":"TABLE-US-00067","num":"00067"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Queue class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Constructor:","Set useSemaphore = TRUE if the queue is"]},{"entry":[{},"going to be referenced by more than one"]},{"entry":[{},"\u2018reader\u2019 or thread."]},{"entry":["Queue","Otherwise, set it to FALSE or don't supply it."]},{"entry":["(ULONG Size,","When set to TRUE, the constructor calls"]},{"entry":["bool useSemaphore =","CreateSemaphore to establish the semaphore"]},{"entry":["TRUE)","handle, and assigns a Resource Count equal to"]},{"entry":[{},"the Size, which means that if you specify a"]},{"entry":[{},"queue of 10, at most 10 threads can"]},{"entry":[{},"access it at once."]},{"entry":["const HANDLE","Returns the signal handle for use primarily with"]},{"entry":["getEventHandle(\u2009)","WaitForSingleObject(\u2009) to halt a thread"]},{"entry":[{},"until something is placed in the queue."]},{"entry":["const HANDLE","Returns the semaphore handle for use primarily"]},{"entry":["getSema-","with WaitForSingleObject(\u2009) to halt a thread"]},{"entry":["phoreHandle(\u2009)","until something is placed in the queue. Use only"]},{"entry":[{},"when useSemaphore is TRUE in constructor."]},{"entry":["void","Locks the queue so other \u2018readers\u2019 can't alter its"]},{"entry":["Lock(\u2009)","contents. If the queue is already locked (in use),"]},{"entry":[{},"this call waits until it is no longer locked."]},{"entry":[{},"The Queue member functions each perform a"]},{"entry":[{},"lock and unlock when they update the queue,"]},{"entry":[{},"but there are times when you need to perform"]},{"entry":[{},"several queue functions while keeping total"]},{"entry":[{},"control of the queue. In this case, use the"]},{"entry":[{},"Lock(\u2009) function."]},{"entry":["void","Releases control of the queue so others can add"]},{"entry":["Unlock(\u2009)","or remove elements. Use only if you previously"]},{"entry":[{},"used Lock(\u2009) to isolate queue access."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The short class Queue Pairs maintains a set of two queues that are related. Typically one is used for Input and one is used for Output. Their names, however, are Lefty and Righty.",{"@attributes":{"id":"p-0557","num":"0574"},"tables":{"@attributes":{"id":"TABLE-US-00068","num":"00068"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Queue class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["The Constructors:","These constructors simply construct the two"]},{"entry":["Qpair","Queues, Lefty and Righty."]},{"entry":"(ULONG Size,"},{"entry":"bool bUseSemaphore),"},{"entry":"Qpair"},{"entry":"(ULONG Size)"},{"entry":["Queue& Left(\u2009)","Returns a pointer to Queue Lefty."]},{"entry":["Queue& Right(\u2009)","Returns a pointer to Queue Righty."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The RpcClientClass, RPCCLNTC.CPP contains all of the functionality needed for an application to communicate with the Fileserver RPC Server via the Cabin Application Programming Interface (CAPI). To use it, the Create( ) call should be executed. Then a call to GetContextHandle( ) provides the I\/O handle for communications.",{"@attributes":{"id":"p-0559","num":"0576"},"tables":{"@attributes":{"id":"TABLE-US-00069","num":"00069"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["RpcClientClass class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bool","Creates and initializes an RPC"]},{"entry":["Create(\u2009)","Interface channel between an"]},{"entry":[{},"application and the RPC Server"]},{"entry":[{},"process using"]},{"entry":[{},"RpcNsBindingImportBegin(\u2009)."]},{"entry":[{},"Returns TRUE if successful,"]},{"entry":[{},"FALSE otherwise."]},{"entry":["bool","Terminates the RPC Session with"]},{"entry":["Delete(\u2009)","the server process."]},{"entry":[{},"Returns TRUE if successful, FALSE"]},{"entry":[{},"otherwise."]},{"entry":["bool","Retrieves a database context handle"]},{"entry":["GetCant extHandle","from the server process via an RPC"]},{"entry":["(output","channel previously opened using"]},{"entry":["PPCONTEXT_HANDLE_TYPE","Create(\u2009). Calls the Capi_c.c"]},{"entry":["pphContext)","InitializeInterface(\u2009) function to"]},{"entry":[{},"connect to RPC. Returns FALSE"]},{"entry":[{},"if none."]},{"entry":["bool","Returns a database context handle"]},{"entry":["ReleaseContextHandle","which was previously obtained by a"]},{"entry":["(output","call to GetContextHandle(\u2009)."]},{"entry":["PCONTEXT_HANDLE_TYPE","Returns FALSE if none."]},{"entry":"phContext)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The System Monitor Interface, SYSMNNTR.CPP is a set of routines that is used by any process that is under the control of SYSMON.EXE for shutdown purposes. This Constructors class has three constructors available for use: SysmonInterfaceClass( ) is not used, SysmonInterfaceClass(ParentProcess_id, EventHandle), SysmonInterfaceClass(ParentProcess_id, MessageQueue) SysmonInterfaceClass(ParentProcess_id).","ParentProcess_id is used to identify the process in all communications with SysMon (see WriteToSysMon( )). The other parameters are used to control the method of shutdown for the given process. If the process prefers to hear about it using an event, it can pass the EventHandle to be used when shutdown is needed. If the process prefers to hear about it via a message queue, it can pass the Queue ID in.","Each Initialization process must first create a SysmonInterfaceClass object and then register communications with Sysmon using SysmonInterfaceClass::Register( ). This calls ConnectSystemMonitor( ) to create handles to two Named Pipes (input and output) to use to talk to the System Monitor. It then creates an IFE_Message and sends it to Sysmon via WriteToSysMon( ). Finally, Register( ) launches two threads to manage the named pipes with CreateSystemMonitorThreads( ).","CreateSystemMontorThreads( ) launches two communication threads who in turn call the actual I\/O function: InputThreadInterface( ) calls ReadFromSysMon( ), OutputThreadInterface( ) calls HeartBeatSysMono. ReadFromSysMon( ) continuously reads from Sysmon, calling ProcessRequest( ) when any message is received. HeartBeatSysMon( ) continuously issues a pulse message to Sysmon, to let it know that this process is alive.","WriteToSysMon( ) is used to send any message to the System Monitor via the output named pipe. It uses IFE_Message::PutData( ) to do it.","Anytime a message is received in ReadFromSysMon( ), ProcessRequest( ) is called. This simply parses out any ProcessStop message and calls Shutdown( ) to continue. All other messages are ignored.","Shutdown( ) cares about how this class was constructed. If an event handle was given, it sets this event to announce the shutdown to the host process. If a message queue was given, it forwards the ProcessStop message to the queue so the host can shutdown in a more orderly fashion. If neither of these was given, it halts the process with a ProcessExit( ).","A Timer Utilities file, TMDCLLBC.CPP, contains a class timedCallback that is used to schedule activity in regular intervals. The user first creates a function to be called when a \u2018timeout\u2019 occurs by declaring it as long (*timedCallbackFun) (timedCallback *Entry); This function must return the number of ticks to wait until the next call should be invoked, or Zero to stop the re-queueing.",{"@attributes":{"id":"p-0568","num":"0585"},"tables":{"@attributes":{"id":"TABLE-US-00070","num":"00070"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Public timedCallback Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["timedCallback(\u2009)","Constructs a callback using a default"]},{"entry":[{},"\u2018do-nothing\u2019 function. This allows"]},{"entry":[{},"one to create arrays of timedCallback"]},{"entry":[{},"objects and define the callback"]},{"entry":[{},"function later by use of member"]},{"entry":[{},"setFun(\u2009)."]},{"entry":["timedCallback","Constructs a real-time clock callback to"]},{"entry":["(input","be used for later calls to queue(\u2009) and"]},{"entry":["timedCallbackFun SomeFun)","cancel(\u2009). SomeFun is the user-defined"]},{"entry":[{},"function to call when a timeout occurs."]},{"entry":["~timedCallback(\u2009)","Cancels the callback before it goes out"]},{"entry":[{},"of scope."]},{"entry":["void","Cancels \u2018this\u2019 callback if it is queued,"]},{"entry":["cancel(\u2009)","but retains the object for subsequent"]},{"entry":[{},"queueing."]},{"entry":["int","Returns 1 if \u2018this\u2019 callback is queued, 0"]},{"entry":["isQueued(\u2009)","otherwise."]},{"entry":["void","Queues the callback to be called after"]},{"entry":["queue(input long Delta)","the specified number of invocations of"]},{"entry":[{},"tick(\u2009). Delta == 0 cancels the callback."]},{"entry":[{},"Queue(\u2009) is automatically called each"]},{"entry":[{},"time the user's timedCallbackFunction"]},{"entry":[{},"is invoked."]},{"entry":[{},"queue(\u2009) can be used to change the"]},{"entry":[{},"interval of an already queued callback."]},{"entry":["void","Redefines the callback function to be"]},{"entry":["setFun(input timedCallbackFun","used for \u2018this\u2019 callback as what's"]},{"entry":["SomeFun)","contained in SomeFun."]},{"entry":["static void","Advances the time by one tick."]},{"entry":["tick(\u2009)","As a result, queued callbacks may"]},{"entry":[{},"time-out and are then invoked from"]},{"entry":[{},"within tick(\u2009). Normally not used"]},{"entry":[{},"externally, this is maintained by"]},{"entry":[{},"the timer thread that was launched by"]},{"entry":[{},"the constructor."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The General Utilities include UTLTYCLS.CPP. The UtilityClass Class provides a general interface to the following generic utility functions. Many of these functions are declared as STATIC, which means that you can use them without creating an object of UtilityClass, just by calling them with the class name in front, such as UtilityClass::bin2Ascii(Ox2f, &Hi, &Lo).",{"@attributes":{"id":"p-0570","num":"0587"},"tables":{"@attributes":{"id":"TABLE-US-00071","num":"00071"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["UtilityClass Public Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["static void","Converts a binary hex value into a"]},{"entry":["bin2Ascii","two byte ASCII character"]},{"entry":["(input unsigned char Hex,","representation."]},{"entry":["output unsigned char*Hi,","e.g., Hex = 0x2F,"]},{"entry":["output unsigned char*Lo)","*Hi = \u20182\u2019 *Lo = = \u2018F\u2019."]},{"entry":["unsigned char","Receives a character buffer of input"]},{"entry":["BuildNetworkAddress","data and creates a network address,"]},{"entry":["(input unsigned char *cpBuffer,","returning it as an unsigned character."]},{"entry":["output unsigned char","DeviceHandler defines whether the"]},{"entry":["*cpNetworkAddress,","data is from ARCNET or RS-422."]},{"entry":["input","The length of the address is"]},{"entry":["DeviceHandlerType","returned."]},{"entry":["DeviceHandler)","If ZERO, no address was made."]},{"entry":["bool","Connects the WINDOWS NT"]},{"entry":["ConnectNetworkResource","Network Resource specified by"]},{"entry":["(input char *LocalName,","RemoteName to the drive specified"]},{"entry":["input char *RemoteName)","by LocalName."]},{"entry":[{},"Returns FALSE if any errors are"]},{"entry":[{},"encountered and connect fails."]},{"entry":["static unsigned short","Takes 2 ASCII characters and"]},{"entry":["ConvertAsciiToBin","returns them as unsigned binary."]},{"entry":["(input unsigned char*byAscii)","e.g., by ASCII = \u201c2F\u201d, returns 0x2F."]},{"entry":["static unsigned char","Takes a single ASCII char and"]},{"entry":["ConvertAsciiToBin","returns a single unsigned binary"]},{"entry":["(unsigned char AsciiChar)","char. e.g., AsciiChar = \u2018F\u2019,"]},{"entry":[{},"returns 0x0F."]},{"entry":["static bool","Initializes the IfeIdMap data"]},{"entry":["CreateIfeIdConversionMap(\u2009)","structure. For each entry in the"]},{"entry":[{},"IfeId Type definition, a"]},{"entry":[{},"corresponding text string is written"]},{"entry":[{},"to the map. This data structure"]},{"entry":[{},"is used in conversions between"]},{"entry":[{},"process enumeration values and"]},{"entry":[{},"text values."]},{"entry":[{},"Always returns TRUE."]},{"entry":["static bool","Initializes the IfeFuncMap data"]},{"entry":["CreateIfeFuncConversionMap(\u2009)","structure. For each entry in the"]},{"entry":[{},"IfeFunction Type definition, a"]},{"entry":[{},"corresponding text string is"]},{"entry":[{},"written to the map. This data"]},{"entry":[{},"structure is used in"]},{"entry":[{},"conversions between process"]},{"entry":[{},"enumeration values and text values."]},{"entry":[{},"Always returns TRUE."]},{"entry":["bool","Retrieves the name and data"]},{"entry":["GetFirstRegistryValue","associated with the first value"]},{"entry":["(input char *pszKeyName,","contained in the NT Registry that"]},{"entry":["output char *pszValueName,","matches the registry keyname."]},{"entry":["input LPDWORD","Returns FALSE if unsuccessful."]},{"entry":"dwValueNameLen,"},{"entry":"output LPDWORD lpdwType,"},{"entry":"output LPBYTE lpbData,"},{"entry":"output LPDWORD lpcbData)"},{"entry":["bool","After calling"]},{"entry":["GetNextRegistryValue","GetFirstRegistryValue(\u2009),"]},{"entry":["(output char *pszValueName,","this function can be called to retrieve"]},{"entry":["output LPDWORD","subsequent registry value names and"]},{"entry":["dwValueNameLen,","data."]},{"entry":["output LPDWORD lpdwType,","Returns FALSE if unsuccessful."]},{"entry":"output LPBYTE lpbData,"},{"entry":"output LPDWORD lpcbData)"},{"entry":["bool","Retrieves a DWORD value from the"]},{"entry":["GetRegistryDWord","Registry into lpdwValue."]},{"entry":["(input char *lpszKeyName,","Returns FALSE if unsuccessful."]},{"entry":"input char *lpszValueName,"},{"entry":"output DWORD *lpdwValue)"},{"entry":["bool","Retrieves all registry information by"]},{"entry":["GetRegistryInfo","iterating through the registry key"]},{"entry":["(output CStringArray","values, returning it in an array of"]},{"entry":["*RegValueArray)","strings."]},{"entry":[{},"Returns FALSE if unsuccessful."]},{"entry":["bool","Retrieves a string in lpbData"]},{"entry":["GetRegistryString","corresponding to the input parameter"]},{"entry":["(input char *lpszValueName","ValueName."]},{"entry":["output LPBYTE lpbData,","Returns FALSE if unsuccessful."]},{"entry":"output LPDWORD lpcbData)"},{"entry":["static bool","Converts the IFE Function Message"]},{"entry":["IfeFuncToText","identifier contained in the"]},{"entry":["(input IfeFunctionType","nIfeFunction input argument into a"]},{"entry":["nIfeFunction,","text string representing the same"]},{"entry":["output PGENERIC_TEXT","enumeration name."]},{"entry":["pszIfeFuncText)","Returns FALSE if unsuccessful."]},{"entry":["static bool","Converts the IFE Process\/Thread"]},{"entry":["IfeIdToText","identifier contained in the nIfeId"]},{"entry":["(input IfeIdType nIfeId,","input argument into a text string"]},{"entry":["output PGENERIC_TEXT","representing the same"]},{"entry":["pszIfeIdText)","enumeration name."]},{"entry":[{},"Returns FALSE if unsuccessful."]},{"entry":["static IfeFunctionType","Returns the corresponding"]},{"entry":["IfeTextToFunc","Enumeration value for the Text"]},{"entry":["(input PGENERIC_TEXT","String contained in pszIfeIdText"]},{"entry":["pszIfeFuncText)","from the IfeFunctionType Type"]},{"entry":[{},"definition."]},{"entry":[{},"If none, returns NoDestination."]},{"entry":["static IfeIdType","Returns the corresponding"]},{"entry":["IfeTextTold","Enumeration value for the Text"]},{"entry":["(input PGENERIC_TEXT","String contained in pszIfeIdText"]},{"entry":["pszIfeIdText)","from the IfeIdType Type definition."]},{"entry":[{},"If none, returns NoDestination."]},{"entry":["static void","This is the call-level interface to the"]},{"entry":["LogEvent","WINDOWS NT event log. This"]},{"entry":["(input IfeIdType nProcessId,","takes the passed variables and"]},{"entry":["input WORD wCategory,","develops a series of strings using"]},{"entry":["input DWORD dwErrorCode,","printf(pszFormat, arg, arg, arg)"]},{"entry":["input char *pszFormat input . . .)","style, then forwards the developed"]},{"entry":[{},"string to ReportEvent(\u2009)."]},{"entry":["bool","This function is used by a process to"]},{"entry":["SetRegistryConfigValue","register its Unit Id, Part Number,"]},{"entry":["(input char *ModuleName","and Revision number to the"]},{"entry":["input REGCONFIGINFO","WINDOWS NT Registry."]},{"entry":["*ConfigInfo)","Returns FALSE if any errors are"]},{"entry":[{},"encountered."]},{"entry":["bool","Writes specified value and string"]},{"entry":["SetRegistryString","data into specified registry key"]},{"entry":["(input char *1pszKeyName,","under"]},{"entry":["input char *1pszValueName,","HKEY_LOCAL_MACHINE."]},{"entry":["input char *szString)","Returns FALSE if any errors are"]},{"entry":[{},"encountered."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Discrete Library, DISCRETE.LIB, contains the UTILITY.LIB Library plus the following. The WinRUtilClass class contains simple utilities for use with WinRT drivers:",{"@attributes":{"id":"p-0572","num":"0589"},"tables":{"@attributes":{"id":"TABLE-US-00072","num":"00072"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["WinRTUtilClass Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","Returns the full WinRT"]},{"entry":["Build WinRTDeviceName","device name from a null-"]},{"entry":["(output LPSTR szDeviceName,","terminated device number."]},{"entry":"input LPSTR szDeviceNumber"},{"entry":["DWORD","Uses null-terminated"]},{"entry":["GetWinRTDeviceNumber","DriverName to look-up"]},{"entry":["(input LPSTR szDriverName,","WinRT device number string"]},{"entry":["output PUCHAR szDeviceNumber,","in the registry."]},{"entry":["input LPDWORD","Returns the value returned"]},{"entry":["lpdwDeviceNumberBufsize)","by its called"]},{"entry":[{},"RegQueryValueEx(\u2009) function."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"DSCRTDRV.RT replaces DSCRTDRV.CPP and is the name of the Discrete Driver code. It is fed into the WinRT Preprocessor to create DISCRETE.CPP, which is compiled into the DISCRETE.LIB library. The DiscreteDriverClass controls the system discretes, which are used to control peripherals such as LED indicators.",{"@attributes":{"id":"p-0574","num":"0591"},"tables":{"@attributes":{"id":"TABLE-US-00073","num":"00073"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["DiscreteDriverClass",{}]},{"entry":["Public Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","Closes the Discrete WinRT device if it is"]},{"entry":["CloseDiscretes(\u2009)","open."]},{"entry":["UCHAR","Returns the Enumerated LRU ID. If 0, LRU"]},{"entry":["GetId(\u2009)","ID has not yet been obtained. May be called"]},{"entry":[{},"after ReadId(\u2009)."]},{"entry":["bool","Returns the state of the LCD backlight"]},{"entry":["GetLCDbacklight(\u2009)","(on or off)."]},{"entry":["bool","Returns the state of the specified LED."]},{"entry":"GetLED"},{"entry":"(LED_TYPE LEDchoice)"},{"entry":["bool","Returns the state of the specified VTR"]},{"entry":["GetVTRDiscrete","discrete."]},{"entry":"(VTR_DISCRETE_TYPE"},{"entry":"VTRdiscreteChoice)"},{"entry":["bool","May be called after ReadId(\u2009)."]},{"entry":["IsPAT(\u2009)","Returns TRUE if this LRU is a PAT, FALSE"]},{"entry":[{},"if this LRU is a CFS."]},{"entry":["DWORD","Opens the Discrete WinRT device."]},{"entry":"OpenDiscretes(\u2009)"},{"entry":["DWORD","Reads discrete input I\/O port to obtain this"]},{"entry":["ReadId(\u2009)","LRU id and stores it in the form: 0110fijk"]},{"entry":[{},"where f = 1 if CFS, f = 0 if PAT;"]},{"entry":[{},"ijk is the LRU id 000\u2013111 (0\u20137)."]},{"entry":[{},"In this form the byte may be"]},{"entry":[{},"used as an ARCNET address."]},{"entry":[{},"If successful, ERROR_SUCCESS"]},{"entry":[{},"is returned."]},{"entry":["UCHAR","Returns a byte representing the state of the"]},{"entry":["ReadInputDiscretes(\u2009)","input discretes."]},{"entry":["UCHAR","Returns a byte representing the state of the"]},{"entry":["ReadOutputDiscretes(\u2009)","output discretes."]},{"entry":["bool","Turns the LCD backlight on or off. Returns"]},{"entry":["SetLCDbacklight","the state of the backlight prior to this"]},{"entry":["(bool bOnOff)","function call."]},{"entry":["bool","Turns the specified LED on or off. Returns"]},{"entry":["SetLED","the state of the LED prior to this function"]},{"entry":["(LED_TYPE LEDchoice,","call."]},{"entry":"bool bOnOff)"},{"entry":["bool","Asserts or de-asserts the specified VTR"]},{"entry":["Set VTRDiscrete","discrete. Returns the state of the discrete"]},{"entry":["(VTR_DISCRETE_TYPE","before this function call."]},{"entry":"VTRdiscreteChoice,"},{"entry":"bool bOnOff)"},{"entry":["UCHAR","Sets the output discretes according to the"]},{"entry":["WriteOutputDiscretes","specified mask. Returns the state of the"]},{"entry":["(UCHAR ucOutputMask)","output discretes before they were changed"]},{"entry":[{},"by this function."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A message library MESSAGE.LIB provides the means of moving data from one place and format to another without needing detailed understanding of the protocols involved. In general, all messages transmitted within the control center are of the type IFE_Message. Therefore, a class called IFE_Message is used to translate information into and out of this message type. Similarly, many messages enter the control center from the ARCNET devices, so to support them the ARCNET_Message Class is made. Instead of requiring the user to start with an ARCNET_Message and convert it to an IFE_Message, the ARCNET_Message is a superset of IFE Message. In this way, the ARCNET_Message contains the additional functions to manage the translations, and the migration from one form to another is nearly transparent.","For example, when raw data is read into MP.EXE from ARCNET, it is put into a new ARCNET_Message object and passed to MessageToPipeProcessor( ) that treats this message as an IFE_Message to send it to the appropriate NAU. The NAU uses its own flavor of IFE_Message (Seat_Message, for example) to read the data (via its own NAUGetMP( )) and from that point forward, the IFE_message is treated more specifically. No special handling is needed to affect this change. By the time the message finally reaches its ultimate destination process, the message class functions are used to deal with the actual bytes of the messages. These functions are described below.","The IFE_Message class IFMSSAGE.CPP is the base class for all IFE message processing. A hierarchy exists such that each derived class implements specifics for its data processing. This makes translating data formats transparent to application programmers.",{"@attributes":{"id":"p-0578","num":"0595"},"tables":{"@attributes":{"id":"TABLE-US-00074","num":"00074"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["IFE_Message Public Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IFE_Message","This constructor prefills the local"]},{"entry":["(IFE_MESSAGE_DATA","IfeMessageData with the raw"]},{"entry":["*pIfeMessageData)","pIfeMessageData."]},{"entry":["virtual void","Returns the Address data,"]},{"entry":["GetAddress","(e.g., \u201cSDU 001A\u201d),"]},{"entry":["(char *pAddress)","from the Address member found in the"]},{"entry":[{},"IfeMessageData."]},{"entry":["bool","Initializes the IfeMesageData structure"]},{"entry":["GetData","of an IFE_Message object with"]},{"entry":["(Queue *pInputQueue)","data from the Queue. The address of an"]},{"entry":[{},"IfeMessageData structure is read"]},{"entry":[{},"from the specified queue, the data is"]},{"entry":[{},"copied into the IFE_Message class. The"]},{"entry":[{},"IfeMessageData structure read from the"]},{"entry":[{},"input queue is then Deleted."]},{"entry":[{},"Returns FALSE if fails to get data."]},{"entry":["bool","Does a ReadFile(\u2009) on the specified"]},{"entry":["GetData","handle and uses the data read to"]},{"entry":["(HANDLE hInPipe,","populate the IfeMessageData structure"]},{"entry":["ULONG *pBytesRead)","contained in this instance of the"]},{"entry":[{},"IFE_Message class."]},{"entry":[{},"Returns FALSE if fails to get data"]},{"entry":[{},"from Pipe."]},{"entry":["virtual IfeIdType","Returns the Destination data found in"]},{"entry":["GetDestination(\u2009)","the IfeMessageData data member."]},{"entry":["IfeFunctionType","Returns the IfeFunction element of the"]},{"entry":["GetIfeFunction(\u2009)","IFE_MESSAGE_DATA structure"]},{"entry":[{},"associated with this IFE_Message."]},{"entry":["void","Returns the LRU information from the"]},{"entry":["GetLruInfo","IFE_Message."]},{"entry":"(char *pLruInfo)"},{"entry":["bool","Copies the data contained in the"]},{"entry":["GetLruType","LRUType field of the IfeMessageData"]},{"entry":["(char *pszLruType)","structure contained in this"]},{"entry":[{},"IFE_Message into the location"]},{"entry":[{},"specified by the input argument"]},{"entry":[{},"pszLruType."]},{"entry":[{},"Returns FALSE if pszLruType is a null"]},{"entry":[{},"pointer."]},{"entry":["void","Copies the data field of this"]},{"entry":["GetMessageData","IFE_Message object into the pData"]},{"entry":["(BYTE *pData,","argument. The number of bytes"]},{"entry":["WORD *wDataLen)","copied is written to the wDataLen"]},{"entry":[{},"argument."]},{"entry":["virtual long","Returns the MessageLength data"]},{"entry":["GetMessageLength(\u2009)","member value."]},{"entry":["CString","Retrieves the network address from"]},{"entry":["GetNetworkAddress(\u2009)","the raw data buffer of an IFE"]},{"entry":[{},"Message."]},{"entry":[{},"GetNetworkAddress determines the"]},{"entry":[{},"location of address information in"]},{"entry":[{},"the Raw Data buffer based on the"]},{"entry":[{},"destination ID. Address information"]},{"entry":[{},"is converted from Binary to ASCII"]},{"entry":[{},"if necessary then placed into a"]},{"entry":[{},"CString which is returned to the"]},{"entry":[{},"calling function."]},{"entry":["virtual IfeIdType","Returns the Source data found in the"]},{"entry":["GetSource(\u2009)","IfeMessageData data member."]},{"entry":["UnsolicitedMessageType","Returns the value contained in the"]},{"entry":["GetUnsolicitedMessage(\u2009)","UnsolicitedMessage field of this"]},{"entry":[{},"IFE_Message object."]},{"entry":["void","Formats a text string containing"]},{"entry":["Log(int nMessageDirection,","pertinent message information and"]},{"entry":["IfeIdType nProcessId,","writes it to standard output."]},{"entry":["char *pszDataFormat)","MessageDirection can be set to"]},{"entry":[{},"LogInpMsg or any other value to"]},{"entry":[{},"indicate whether the log should say"]},{"entry":[{},"\u2018Received\u2019 or \u2018Transmitted\u2019,"]},{"entry":[{},"respectively. ProcessId is simply"]},{"entry":[{},"added to the Log string along with"]},{"entry":[{},"the IFE_Message data. The"]},{"entry":[{},"DataFormat is used to determine"]},{"entry":[{},"which fields are used. If null, only"]},{"entry":[{},"the Process Id, Function, Destination"]},{"entry":[{},"Id, Source Id and Address are output"]},{"entry":[{},"to stdout. Otherwise the actual"]},{"entry":[{},"message data also prints."]},{"entry":["bool","Allocates sufficient memory to hold"]},{"entry":["PutData","a copy of the IfeMessageData"]},{"entry":["(Queue *pOutputQueue)","structure associated with a message."]},{"entry":[{},"The IfeMessageData is copied from"]},{"entry":[{},"the Class data area to the newly"]},{"entry":[{},"allocated memory. The pointer to the"]},{"entry":[{},"copied data is then placed on the"]},{"entry":[{},"specified queue."]},{"entry":[{},"Returns FALSE if fails to create"]},{"entry":[{},"a new IFE_Message object."]},{"entry":["bool","Copies the contents of the"]},{"entry":["PutData","IfeMessageData class variable to the"]},{"entry":["(HANDLE hOutPipe,","pipe specified by hOutPipe. The"]},{"entry":["ULONG *pBytesWritten)","number of bytes actually written to"]},{"entry":[{},"the pipe are returned in the"]},{"entry":[{},"pBytesWritten argument."]},{"entry":[{},"Returns FALSE if fails to output"]},{"entry":[{},"to the pipe."]},{"entry":["virtual void","Updates the IfeMessageData Address"]},{"entry":["SetAddress","data field with pAddress info."]},{"entry":"(char *pAddress)"},{"entry":["virtual void","Updates the Destination field in the"]},{"entry":["SetDestination","IfeMessageData data member."]},{"entry":"(IfeIdType DestinationId)"},{"entry":["void","Copies the IfeFunctionType input"]},{"entry":["SetIfeFunction","argument into the IfeFunction"]},{"entry":["(IfeFunctionType nIfeFunction)","element of the"]},{"entry":[{},"IFE_MESSAGE_DATA"]},{"entry":[{},"structure associated with this"]},{"entry":[{},"IFE_Message."]},{"entry":["void","Saves information about the host"]},{"entry":["SetLruInfo","LRU."]},{"entry":"(char *pLruInfo)"},{"entry":["bool","Fills the LRUType field in the"]},{"entry":["SetLruType","IfeMessageData structure for this"]},{"entry":["(char *pszLruType)","IFE_Message with the data"]},{"entry":[{},"contained in the input argument"]},{"entry":[{},"pszLruType."]},{"entry":[{},"Returns FALSE if input LruType is"]},{"entry":[{},"too big to store."]},{"entry":["void","Copies the specified data block"]},{"entry":["Set MessageData","to the MessageData field of this"]},{"entry":["(BYTE *pData,","IFE_Message object."]},{"entry":"WORD wDataLen)"},{"entry":["void","Sets the MessageLength local data"]},{"entry":["SetMessageLength","member to Length."]},{"entry":"(long Length)"},{"entry":["void","Converts the Network Address in"]},{"entry":["SetNetworkAddress","csNetworkAddress as necessary and"]},{"entry":["(CString csNetworkAddress)","writes the resulting data to the"]},{"entry":[{},"Raw Message Data buffer."]},{"entry":[{},"The type of conversion required as"]},{"entry":[{},"well as the location of data in the"]},{"entry":[{},"Raw Message data buffer is"]},{"entry":[{},"determined by the identifier of the"]},{"entry":[{},"process that sent the message"]},{"entry":[{},"(i.e., Message Source Id)."]},{"entry":["virtual void","Updates the Source field found in the"]},{"entry":["SetSource","IfeMessageData data member with"]},{"entry":["(IfeIdType SourceId)","SourceId."]},{"entry":["void","Sets the UnsolicitedMessage field for"]},{"entry":["Set UnsolicitedMessage","this IFE_Message object with the"]},{"entry":["(UnsolicitedMessageType","value contained in Message."]},{"entry":"Message)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The ARCNET_Message class ARCNTMSS.CPP is a derived class from IFE_Message. It is used to carry and process ARCNET data from the Message Processor to an appropriate Network Addressable Unit (e.g., Seat NAU, Backbone NAU). It is used as a base class to any ARCNET devices, such as the Seat_Message, PESCA_Message, and PESCV_Message classes.","Some of the virtual functions defined in IFE_Message have been overridden within ARCNET_Message.",{"@attributes":{"id":"p-0581","num":"0598"},"tables":{"@attributes":{"id":"TABLE-US-00075","num":"00075"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ARCNET_Message Class",{}]},{"entry":["Public Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ARCNET_Message","This constructor fills the"]},{"entry":["(IFE_MESSAGE_DATA","IfeMessageData data member with"]},{"entry":["*pIfeMessageData)","the message data structure."]},{"entry":["ARCNET_Message","This constructor takes what must be"]},{"entry":["(BYTE *pMessageData,","a valid message and parses it to"]},{"entry":["CMapStringToPtr& LookUpTable)","fill the local structure."]},{"entry":["bool","This method builds the MessageData"]},{"entry":["BuildArcnetMessage","into an ARCNET message."]},{"entry":["(CMapStringToPtr&","The first two bytes of the output"]},{"entry":["LookUpTable,","message buffer are set to the length"]},{"entry":["char *pLRUName","of the message (as read from the"]},{"entry":["BYTE *pOutBuf)","MessageLength field of the"]},{"entry":[{},"IfeMessageData structure. The"]},{"entry":[{},"remainder of the output buffer is"]},{"entry":[{},"populated with the raw ARCNET"]},{"entry":[{},"data from the MessageData field"]},{"entry":[{},"of the IfeMessageData structure."]},{"entry":[{},"Returns FALSE if failure."]},{"entry":["BYTE","Returns the value of the Command"]},{"entry":["GetCommand(\u2009)","Byte in the ARCNET MessageData."]},{"entry":["IfeIdType","Extracts the Destination bytes"]},{"entry":["GetDestination","from the ARCNET MessageData,"]},{"entry":["(CMapStringToPtr LookUpTable,","attempts to map the raw data and"]},{"entry":["char *pAddress)","returns the Enumerated IfeIdType"]},{"entry":[{},"and Mapping address."]},{"entry":[{},"Returns NoDestination if"]},{"entry":[{},"none found."]},{"entry":["IfeFunctionType","Returns the IfeFunction data"]},{"entry":["GetIfeFunction(\u2009)","member."]},{"entry":["long","Processes the raw ARCNET data to"]},{"entry":["GetMessageLength","determine the message length,"]},{"entry":["(BYTE *pMessageData)","update the local data member and"]},{"entry":[{},"return the value."]},{"entry":["bool","Determines whether or not this"]},{"entry":["IsTestPrimitive","IFE_Message is a test primitive by"]},{"entry":["(BYTE byTestPrimitive)","comparing the command byte with"]},{"entry":[{},"the constant TP_COMMAND."]},{"entry":[{},"A value of TRUE is returned if the"]},{"entry":[{},"command byte equals"]},{"entry":[{},"TP_COMMAND."]},{"entry":[{},"A value of FALSE is returned"]},{"entry":[{},"otherwise."]},{"entry":["bool","Overloaded ARCNET"]},{"entry":["PutData","PutData(\u2009) method."]},{"entry":["(HANDLE hOutPipe,","Completes the Message Header"]},{"entry":["ULONG *pByteswritten)","and calls the IFE_Message"]},{"entry":[{},"function."]},{"entry":[{},"Returns FALSE if write to"]},{"entry":[{},"OutPipe fails."]},{"entry":["bool","Overloaded ARCNET PutData(\u2009)"]},{"entry":["PutData","method."]},{"entry":["(Queue *pOutputQueue)","Completes the Message Header"]},{"entry":[{},"and calls the IFE_Message function."]},{"entry":[{},"Returns FALSe if no data was found"]},{"entry":[{},"to put into Queue."]},{"entry":["bool","This method is an override of the"]},{"entry":["SetAddress","IfeMessage SetAddress(\u2009). It takes"]},{"entry":["(CMapStringToPtr","in a mapping table and an Address."]},{"entry":["LookUpTable,","The address is looked-up in the"]},{"entry":["char *pAddress)","mapping table and if a match is"]},{"entry":[{},"found the Address data member"]},{"entry":[{},"is updated."]},{"entry":[{},"Returns FALSE if unsuccessful."]},{"entry":["void","This method takes a Command Byte"]},{"entry":["(SetCommand","and update the MessageData"]},{"entry":["BYTE Command)","member."]},{"entry":["void","Simply calls the same IFE_Message"]},{"entry":["SetDestination","function to set the Destination data"]},{"entry":["(IfeIdType DestinationId)","member."]},{"entry":["void","Parses the"]},{"entry":["SetDestination","DestinationNetworkAddress"]},{"entry":["(BYTE","for the IFE_Message Destination."]},{"entry":"*pDestinationNetworkAddress)"},{"entry":["bool","Looks up the pAddress in the"]},{"entry":["SetDestination","specified LookUpTable to determine"]},{"entry":["(CMapStringToPtr&","the corresponding Destination and"]},{"entry":["LookUpTable,","stores it in the"]},{"entry":["char *pAddress)","IFE_Message Destination member."]},{"entry":[{},"Returns FALSE if lookup fails."]},{"entry":["void","Updates the IFE Function with"]},{"entry":["SetIfeFunction","the given value."]},{"entry":"(IfeFunctionType Function)"},{"entry":["bool","Cross-references the Address,"]},{"entry":["SetSource","(e.g., \u2018SDU 01A\u2019) in the"]},{"entry":["(CMapStringToPtr LookUpTable,","LookUpTable. If a match, updates"]},{"entry":["char *pAddress)","the Source bytes of MessageData"]},{"entry":[{},"with corresponding value."]},{"entry":[{},"Returns FALSE if failure."]},{"entry":["void","This method takes the BYTE"]},{"entry":["SetSource","parameter and update the"]},{"entry":["(BYTE *pSourceNetworkAddress)","MessageData data member"]},{"entry":[{},"for source."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following are virtual functions that may be used in classes derived from this class:",{"@attributes":{"id":"p-0583","num":"0600"},"tables":{"@attributes":{"id":"TABLE-US-00076","num":"00076"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ARCNET_Message Class",{}]},{"entry":["Virtual Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["virtual void","To finish up the message for shipment. Base"]},{"entry":["CompleteMessageHeader( )","version simply calls SetMessageLength( )."]},{"entry":["virtual void","Base version simply calls the IFE_Message"]},{"entry":["GetAddress(","version."]},{"entry":"char *pAddress)"},{"entry":["virtual IfeIdType","Base version simply calls the IFE_Message"]},{"entry":["GetDestination( )","version."]},{"entry":["virtual IfeIdType","Base version simply calls the IFE_Message"]},{"entry":["GetSource( )","version."]},{"entry":["virtual void","Base version simply calls the IFE_Message"]},{"entry":["SetAddress(","version."]},{"entry":"char *pAddress)"},{"entry":["virtual void","Base version simply calls the IFE_Message"]},{"entry":["SetDestination(","version."]},{"entry":"IfeIdType DestinationId)"},{"entry":["virtual void","Handles ARCNET messages that do not have"]},{"entry":["SetMessageLength( )","sub-functions (i.e., 1F messages). Base"]},{"entry":[{},"version does nothing."]},{"entry":["virtual void","Base version simply calls the IFE_Message"]},{"entry":["SetSource(","version."]},{"entry":"IfeIdType SourceId)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"ARCNET Simulation class ARCSMCLS.CPP contains similar functions to the runtime ARCNET_Message class, except that instead of communicating with the actual ARCNET Driver, this simulates data I\/O for test purposes.","PESC-A_Message class PSCMSSGE.CPP is derived from the ARCNET_Message class to implement the functions needed to support the PESC-A devices.",{"@attributes":{"id":"p-0586","num":"0603"},"tables":{"@attributes":{"id":"TABLE-US-00077","num":"00077"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["PESC-A_Message Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bool","Returns indication of whether landing gear"]},{"entry":["IsGearDown( )","is down and locked."]},{"entry":["bool","Returns indication as to whether landing"]},{"entry":["IsGearCompressed( )","gear is compressed (weight on wheels)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"PESCV_Message class PSCVMSSG.CPP is derived from the ARCNET_Message class to implement the functions necessary to format and transmit interface messages between the Cabin Control Center and the PESC-V .",{"@attributes":{"id":"p-0588","num":"0605"},"tables":{"@attributes":{"id":"TABLE-US-00078","num":"00078"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["PESC-V_Message",{}]},{"entry":["Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","Initializes the data portion of this"]},{"entry":["Write VideoControlData","PESCV_Message with all information"]},{"entry":["(BYTE *byData)","necessary for a Video Control Message (0xE9)."]},{"entry":[{},"byData must contain the Video Control Data"]},{"entry":[{},"bytes."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Seat_Message class SETMSSGE.CPP is derived from the ARCNET_Message class to process Seat data between the Seat NAU and the Services. Methods and data relating to all seat sessioning and sales services, along with some cabin services, are provided.",{"@attributes":{"id":"p-0590","num":"0607"},"tables":{"@attributes":{"id":"TABLE-US-00079","num":"00079"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Seat_Message Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","Finishes up the message for shipment,"]},{"entry":["CompleteMessageHeader( )","adds message length, et. al."]},{"entry":["BYTE","Retrieves the Application ID from the"]},{"entry":["GetApplicationId( )","IFE_Message data."]},{"entry":["double","Retrieves the Cash Total from the"]},{"entry":["GetCashTotal( )","IFE_Message data."]},{"entry":["BYTE","Returns the Command ID found in the"]},{"entry":["GetCommandId( )","IFE_Message data."]},{"entry":["BYTE","Returns the Control Identifier found in"]},{"entry":["GetControlIdentifier( )","the IFE_Message data."]},{"entry":["void","Retrieves the Credit Card Data from the"]},{"entry":["GetCreditCardAccountNumber","IFE_Message data."]},{"entry":"(BYTE *pCreditCardAccount)"},{"entry":["void","Retrieves the Credit Card Customer"]},{"entry":["GetCreditCardCustomerName","Name from the IFE_Message data."]},{"entry":"(char *pCustomerName)"},{"entry":["void","Retrieves the Credit Card Expiration"]},{"entry":["GetCreditCardExpirationDate","Date from the IFE_Message data."]},{"entry":"(BYTE *pExpirationData)"},{"entry":["double","Retrieves the Credit Total from"]},{"entry":["GetCreditTotal( )","IFE_Message data and returns it as a"]},{"entry":[{},"floating point value."]},{"entry":["short","Retrieves the Flags from the"]},{"entry":["GetFlags( )","IFE_Message data."]},{"entry":["void","Retrieves the Flight Attendant Id from"]},{"entry":["GetFlightAttendantId","the IFE_Message data."]},{"entry":"(char *pAttendantId)"},{"entry":["BYTE","Returns the Message ID found in the"]},{"entry":["GetMessageId( )","IFE_Message data."]},{"entry":["ID","Returns the Order ID from the"]},{"entry":["GetOrderId( )","IFE_Message data."]},{"entry":["void","Returns the Product Code from the"]},{"entry":["GetProductCode","IFE_Message data."]},{"entry":"(char *pProductCode)"},{"entry":["long","Returns the Product Map from the"]},{"entry":["GetProductMap( )","IFE_Message data."]},{"entry":["BYTE","Returns the Quantity from the"]},{"entry":["GetQuantity( )","IFE_Message data."]},{"entry":["BYTE","Returns the Retry Count from the"]},{"entry":["GetRetryCount( )","IFE_Message data."]},{"entry":["void","Returns the Seat from the IFE_Message"]},{"entry":["GetSeat(","data."]},{"entry":"char *pSeat)"},{"entry":["void","Transfers the seat identifiers from the"]},{"entry":["GetSeatTransferData","data area of this IFE_Message object"]},{"entry":["(CString &csSeat1,","into the two output arguments."]},{"entry":"CString &csSeat2)"},{"entry":["WORD","Returns the value of the Sequence"]},{"entry":["GetSequenceNumber( )","Number data member."]},{"entry":["BYTE","Retrieves the session status from the"]},{"entry":["GetSessionStatus( )","message"]},{"entry":["BYTE","Retrieves the Transaction Status from"]},{"entry":["GetTransactionStatus( )","the IFE message."]},{"entry":["BYTE","Retrieves the Update Type from the IFE"]},{"entry":["GetUpdateType( )","message."]},{"entry":["void","Initializes the LengthMap array with"]},{"entry":["InitializeSeat( )","seat Ids once per flight."]},{"entry":["void","Copies the Address info into the"]},{"entry":["SetAddress(","IFE_Message data member."]},{"entry":"char *pAddress)"},{"entry":["void","Copies the Amount into the"]},{"entry":["SetCashTotal","IFE_Message data."]},{"entry":"(double Amount)"},{"entry":["void","Copies the ID info into the"]},{"entry":["SetControlIdentifier","IFE_Message data."]},{"entry":"(BYTE ID)"},{"entry":["void","Writes the value contained in byFlags to"]},{"entry":["SetCPMSFlags","the Flags location in the CPMS Status"]},{"entry":["(BYTE byFlags)","message."]},{"entry":["void","Copies the CreditCardAccount data into"]},{"entry":["SetCreditCardAccountNumber","the IFE_Message data."]},{"entry":"(BYTE *pCreditCardAccount)"},{"entry":["void","Copies the CustomerName data into the"]},{"entry":["SetCreditCardCustomerName","IFE_Message data."]},{"entry":"(char *pCustomerName)"},{"entry":["void","Copies the ExpirationDate data into the"]},{"entry":["SetCreditCardExpirationDate","IFE_Message data."]},{"entry":"(BYTE *pExpirationDate)"},{"entry":["void","Formats as a dollar amount and copies"]},{"entry":["SetCreditTotal","Amount into the IFE_Message data."]},{"entry":"(double Amount)"},{"entry":["void","Writes the value in wBuildId to the"]},{"entry":["SetDBBuildId(","Database Build ID field position in the"]},{"entry":["WORD wBuildId)","IFE_Message data."]},{"entry":["void","Formats elapsed time 0\u2013999 into"]},{"entry":["SetElapsed Time","IFE_Message data. Values greater than"]},{"entry":["(TIME tmElapsed)","999 are reduced to 999."]},{"entry":["void","Copies the High Speed Download"]},{"entry":["SetHSDLQueueStatus","Queue Status into the IFE_Message"]},{"entry":["(BYTE *pHSDLQueueStatus)","data."]},{"entry":["void","Copies the IFE State value into the"]},{"entry":["SetIfeState(","IFE_Message data."]},{"entry":"BYTE IfeState)"},{"entry":["void","Copies the Message Id into the"]},{"entry":["SetMessageId","IFE_Message data."]},{"entry":"(BYTE MessageId)"},{"entry":["void","Sets the length of the IFE_Message"]},{"entry":["SetMessageLength( )","data based on the raw data message"]},{"entry":[{},"length."]},{"entry":["void","Copies the MessagesProcessed into the"]},{"entry":["SetMessagesProcessed","IFE_Message data."]},{"entry":"(short MessagesProcessed)"},{"entry":["void","Copies the MovieCycleId into the"]},{"entry":["SetMovieCycleId","IFE_Message data."]},{"entry":"(BYTE MovieCycleId)"},{"entry":["void","Copies the MovieCycleStatus into the"]},{"entry":["SetMovieCycleStatus","IFE_Message data."]},{"entry":"(BYTE MovieCycleStatus)"},{"entry":["void","Copies the MovieNumber into the"]},{"entry":["SetMovieNumber","IFE_Message data."]},{"entry":"(BYTE MovieNumber)"},{"entry":["void","Copies the ChannelNumber into the"]},{"entry":["SetNewVideoChannelNumber","IFE_Message data."]},{"entry":"(BYTE ChannelNumber)"},{"entry":["void","Copies the RecordNumber into the"]},{"entry":["SetNewVideoRecordNumber","IFE_Message data using LanguageId to"]},{"entry":["(BYTE RecordNumber,","pad the text field appropriately."]},{"entry":"BYTE LanguageId)"},{"entry":["void","Copies the OrderId into the"]},{"entry":["SetOrderId","IFE_Message data."]},{"entry":"(ID OrderId)"},{"entry":["void","Copies the ProductCode into the"]},{"entry":["SetProductCode","IFE_Message data."]},{"entry":"(char *pProductCode)"},{"entry":["void","Copies the ProductMap into the"]},{"entry":["SetProductMap","IFE_Message data."]},{"entry":"(long ProductMap)"},{"entry":["void","Copies the Quantity into the"]},{"entry":["SetQuantity","IFE_Message data."]},{"entry":"(BYTE Quantity)"},{"entry":["void","Copies the QueuePosition into the"]},{"entry":["SetQueuePosition","IFE_Message data."]},{"entry":"(short QueuePosition)"},{"entry":["void","Copies the seats identified by the two"]},{"entry":["SetSeatTransferData","input arguments into the IFE_Message"]},{"entry":["(CString &csSeat1,","data."]},{"entry":"CString &csSeat2)"},{"entry":["void","Sets IFE_Message data to"]},{"entry":["SetSEBMessagingOff( )","SEB-Messaging Off."]},{"entry":["void","Sets IFE_Message data to"]},{"entry":["SetSEBMessagingOn( )","SEB-Messaging On."]},{"entry":["void","Copies SeatAddress into the"]},{"entry":["SetSEBMessageSeatAddress","IFE_Message data."]},{"entry":"(char *SeatAddress)"},{"entry":["void","Copies SequenceNumber into the"]},{"entry":["SetSequenceNumber","IFE_Message data."]},{"entry":"(WORD SequenceNumber)"},{"entry":["void","Copies the SessionStatus into the"]},{"entry":["SetSessionStatus","IFE_Message data."]},{"entry":"(BYTE SessionStatus)"},{"entry":["void","Sets the Message ID to"]},{"entry":["Set SIBacklightCmd","SI_BACKLIGHT_CTL and the first"]},{"entry":["(bool bBacklightOn)","data byte 1 (ON) or 0 (OFF) based on"]},{"entry":[{},"bBacklightOn."]},{"entry":["void","Copies StoreStatus into the"]},{"entry":["SetStoreStatus","IFE_Message data."]},{"entry":"(BYTE *StoreStatus)"},{"entry":["void","Copies tmRemaining into the"]},{"entry":["SetTimeLeftOnCurrentCycle","IFE_Message data."]},{"entry":"(TIME tmRemaining)"},{"entry":["void","Copies tmNextShow into the"]},{"entry":["Set Time UntilNextShowing","IFE_Message data."]},{"entry":"(TIME tmNextShow)"},{"entry":["void","Copies TransactionStatus into the"]},{"entry":["SetTransactionStatus","IFE_Message data."]},{"entry":"(BYTE TransactionStatus)"},{"entry":["void","Copies UpdateType into the"]},{"entry":["Set UpdateType","IFE_Message data."]},{"entry":"(BYTE UpdateType)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The TestPort_Message class TSTPRTMS.CPP is derived from ARCNET_Message to communicate with the test port of the file server.",{"@attributes":{"id":"p-0592","num":"0609"},"tables":{"@attributes":{"id":"TABLE-US-00080","num":"00080"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["TestPort_Message",{}]},{"entry":["Class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","Extracts data from an"]},{"entry":["GetBiteResults","BIT_BITE_STATUS (op_status) and"]},{"entry":["(DWORD *pdwErrorCode,","returns it to the calling function for"]},{"entry":["DWORD *pdwTestID,","inclusion in the Application event log."]},{"entry":"DWORD *pdwWitnessType,"},{"entry":"DWORD *pdwSuspectType,"},{"entry":"DWORD *pdwSuspectID,"},{"entry":"DWORD *pdwTSData,"},{"entry":"DWORD *pdwErrorClear)"},{"entry":["void","Extracts the source address field from the"]},{"entry":["GetRawSourceAddress","IFE_Message data and copies it into"]},{"entry":["(BYTE *pszSrcAddrs)","pszSrcAddrs."]},{"entry":["BYTE","Returns the SubCommand byte from the"]},{"entry":["GetSubCommand( )","IFE_Message data."]},{"entry":["bool","Parses the text contained in the"]},{"entry":["SetRevInfo","pszRevInfo string and formats the data"]},{"entry":["(BYTE *pbyRevInfo)","into the IFE_Message data."]},{"entry":["void","Sets the SubCommand byte in the"]},{"entry":["SetSubCommand","IFE_Message data with command."]},{"entry":"(BYTE command)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"StandardProtocol class STNDRDPR.CPP is derived from the IFE_Message class and is the base class that supports the Hughes standard start-stop protocol as described in the, which is used in communications with PATMessage class, PIMessage class, PATSEBMessage class.",{"@attributes":{"id":"p-0594","num":"0611"},"tables":{"@attributes":{"id":"TABLE-US-00081","num":"00081"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["StandardProtocol",{}]},{"entry":["Class Functions","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bool","Decode data from Hughes standard"]},{"entry":["Decode( )","start-stop data into just plain data."]},{"entry":[{},"Returns FALSE if decoding failed."]},{"entry":["void","Encodes the data into the Hughes"]},{"entry":["Encode( )","standard start-stop format."]},{"entry":["BYTE","Returns the Command Byte from the"]},{"entry":["GetCommand( )","IFE_Message data."]},{"entry":["bool GetData","Reads data from the hInPipe into the"]},{"entry":["(HANDLE hInPipe,","IFE_Message data. Returns the number"]},{"entry":["ULONG *pBytesRead)","of bytes read in pBytesRead."]},{"entry":[{},"Returns FALSE if read failed."]},{"entry":["bool","Reads and encodes the data from the"]},{"entry":["GetData","InputQueue into the IFE_Message data."]},{"entry":["(Queue *pInputQueue)","Returns FALSE if no data or if pointer is"]},{"entry":[{},"NULL."]},{"entry":["BYTE","Returns the Command Length from"]},{"entry":["GetLengthOfCommand( )","IFE_Message data."]},{"entry":["bool","Returns FALSE if Command in"]},{"entry":["IsValidCommand( )","IFE_Message is not recognized as one of"]},{"entry":[{},"the Standard Protocol commands."]},{"entry":["bool","Outputs encoded data from IFE_Message"]},{"entry":["PutData","data to the OutPipe, reporting the"]},{"entry":["(HANDLE hOutPipe,","number of BytesWritten."]},{"entry":["ULONG *pBytesWritten)","Returns FALSE if failed the written."]},{"entry":["bool","Decodes the data from the IFE_Message"]},{"entry":["PutData","data and puts it on the OutputQueue."]},{"entry":["(Queue *pOutputQueue)","Returns FALSE if message could not be"]},{"entry":[{},"decoded."]},{"entry":["void","Sets the Message Length and"]},{"entry":["SetLength( )","Destination Address of the IFE_Message."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The PATMessage PATMSSGE.CPP is derived from StandardProtocol to support communication with the primary access terminal's  PI board.",{"@attributes":{"id":"p-0596","num":"0613"},"tables":{"@attributes":{"id":"TABLE-US-00082","num":"00082"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["PATMessage Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","Converts binary format card data in"]},{"entry":["ConvertCardDataToASCIIFormat","pCardData to ASCII format in"]},{"entry":["(unsigned char *pCardData,","IFE_Message data. Requires"]},{"entry":["long 1CardDataLength)","CardDataLength to set the length of"]},{"entry":[{},"the IFE_Message data field."]},{"entry":["void","Converts PrinterStatus to ASCII"]},{"entry":["ConvertPrinterStatusToASCII","format and stores in IFE message"]},{"entry":["(long 1PrinterStatus)","data."]},{"entry":["void","Stub."]},{"entry":"DerivedDecode( )"},{"entry":["void","Stub."]},{"entry":"DerivedEncode( )"},{"entry":["void","Stub."]},{"entry":"GetAudioChannel"},{"entry":"(BYTE *LeftTimeSlot,"},{"entry":"BYTE *RightTimeSlot)"},{"entry":["long","Copies magcard data"]},{"entry":["GetCardDataBinaryFormat","(MagCardReadData Command is first"]},{"entry":["(unsigned char *pCardData)","byte) in the original binary format"]},{"entry":[{},"into pCardData. Size of user-supplied"]},{"entry":[{},"buffer should be"]},{"entry":[{},"MAXMESSAGEDATASIZE."]},{"entry":[{},"Returns adjusted message length."]},{"entry":[{},"Returns 0 if unable to copy data."]},{"entry":["BYTE","Returns the control byte from the"]},{"entry":["GetControlByte( )","IFE_Message data."]},{"entry":["BYTE","Returns address of destination device"]},{"entry":["GetDestinationDevice( )","from IFE_Message data."]},{"entry":["BYTE","Returns address of source device"]},{"entry":["GetSourceDevice( )","from IFE_Message data."]},{"entry":["void","Returns the Preview Channel info"]},{"entry":["GetVideoPreviewChannel","from the IFE_Message data into"]},{"entry":["(BYTE *Channel","Channel and AudioSel."]},{"entry":"BYTE *AudioSel)"},{"entry":["void","Stub."]},{"entry":"Get VideoPreviewSource"},{"entry":"(char *Source)"},{"entry":["void","Simply calls the IFE_Message"]},{"entry":["SetAddress","version."]},{"entry":"(char *Address)"},{"entry":["void","Develops the Audio Channel info in"]},{"entry":["SetAudioChannel","the IFE_Message data based on the"]},{"entry":["(BYTE LeftTimeSlot,","LeftTimeSlot and RightTimeSlot"]},{"entry":["BYTE RightTimeSlot)","values."]},{"entry":["void","Develops the Audio Volume info in"]},{"entry":["SetAudioVolume","the IFE_Message data based on the"]},{"entry":["(BYTE LeftVolume,","LeftVolume and RightVolume"]},{"entry":["BYTE RightVolume)","values."]},{"entry":["void","Sets up request to PI to dump the"]},{"entry":["SetCardData(","most recent magcard buffer into"]},{"entry":["unsigned char *pCardData)","CardData."]},{"entry":["void","Sets address of destination device in"]},{"entry":["SetDestinationDevice","IFE_Message data to"]},{"entry":["(BYTE byDstDeviceAddr)","byDstDeviceAddr."]},{"entry":["void","Set address of source device in"]},{"entry":["SetSourceDevice","IFE_Message data to"]},{"entry":["(BYTE bySrcDeviceAddr)","bySrcDeviceAddr."]},{"entry":["void","Copies the Channel and AudioSel"]},{"entry":["SetVideoPreviewChannel","data into IFE_Message data."]},{"entry":"(BYTE Channel,"},{"entry":"BYTE AudioSel)"},{"entry":["void","Stub."]},{"entry":"SetVideoPreviewSource"},{"entry":"(har *Source)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The PIMessage class PIMSSAGE.CPP is derived from the StandardProtocol class to handle the specifics of the primary access terminal's  PI board.",{"@attributes":{"id":"p-0598","num":"0615"},"tables":{"@attributes":{"id":"TABLE-US-00083","num":"00083"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["PIMessage Class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","Massages the data in IFE_Message data"]},{"entry":["DerivedDecode( )","for local usage."]},{"entry":["void","Massages the data in IFE_Message data"]},{"entry":["DerivedEncode( )","for output to the PI board."]},{"entry":["BYTE","For testing only."]},{"entry":"fooGetCommand( )"},{"entry":["BYTE","For testing only."]},{"entry":"fooGetLengthOfCommand( )"},{"entry":["bool","For testing only."]},{"entry":"fooIsValidCommand( )"},{"entry":["bool","Stub. Always returns FALSE. See"]},{"entry":["GetCardData","PATMessage for this functionality."]},{"entry":"(unsigned char *CardData)"},{"entry":["bool","If the current command was a Channel"]},{"entry":["GetCurrentChannelResponse","Request, this returns the Channel and"]},{"entry":["(BYTE *Channel,","AudioSel."]},{"entry":["BYTE *AudioSel)","Otherwise returns FALSE."]},{"entry":["BYTE","Returns the Command Byte from last"]},{"entry":["GetMsgCommandByte( )","PIMessage."]},{"entry":["bool","If current command was a Part&Revision"]},{"entry":["GetPartAndRevisionData","command, copies the data from"]},{"entry":["(BYTE *PartAndRevision)","IFE_Message data into PartAndRevision."]},{"entry":[{},"Otherwise returns FALSE."]},{"entry":["bool","If current command was a Status Request"]},{"entry":["Get StatusResponse","command, copies the data from"]},{"entry":["(BYTE *Response)","IFE_Message data into Response."]},{"entry":[{},"Otherwise returns FALSE."]},{"entry":["bool","If current command was a Video Preview"]},{"entry":["GetVideoPreviewVCP","VCP command, returns the current VCP"]},{"entry":["(char *VCPName)","assigned to Video Preview screen,"]},{"entry":[{},"persisted by PIInterface VLRU into"]},{"entry":[{},"VCPName."]},{"entry":[{},"Otherwise returns FALSE."]},{"entry":["bool","Returns TRUE only if the current"]},{"entry":["IsCardReaderCommand( )","Command is one from the card reader."]},{"entry":["bool","Returns TRUE only if the current"]},{"entry":["IsTunerCommand( )","Command is one from or for the Tuner."]},{"entry":["bool","Stub. Always returns FALSE."]},{"entry":"IsUnsolicated( )"},{"entry":["void","Builds a Part&Revision Request into the"]},{"entry":["PartAndRevisionRequest( )","IFE_Message data."]},{"entry":["void","Stub. See PATMessage for this"]},{"entry":["PutCardData","functionality."]},{"entry":"(unsigned char *CardData)"},{"entry":["void","Builds a Current Channel Request into the"]},{"entry":["RequestCurrentChannel( )","IFE_Message data."]},{"entry":["void","Builds an Ack-by-Current-Command into"]},{"entry":["SetAck(","the IFE_Message data."]},{"entry":"BYTE byCmdToBeAcked)"},{"entry":["void","Copies byMsgCmd into the Message"]},{"entry":["Set MsgCommandByte","Command Byte class member data."]},{"entry":"(BYTE byMsgCmd)"},{"entry":["void","Builds a NAK-by-Current-Command into"]},{"entry":["SetNak","the IFE_Message data."]},{"entry":"(BYTE byCmdToBeNaked)"},{"entry":["void","Stub."]},{"entry":"SetVideoPreviewToVCP("},{"entry":"char *VCPName)"},{"entry":["void","Builds a Software Reset Command into"]},{"entry":["SoftwareReset( )","the IFE_Message data."]},{"entry":["void","Builds a Status Request Command into the"]},{"entry":["StatusRequest( )","IFE_Message data."]},{"entry":["void","Builds a Switch Tuner Type Command"]},{"entry":["SwitchTunerType","into the IFE_Message data."]},{"entry":"(BYTE TunerType)"},{"entry":["void.","Builds a Tune Channel Command into the"]},{"entry":["TuneChannel","IFE_Message data using Channel and"]},{"entry":["(BYTE Channel,","AudioSel as part of the command."]},{"entry":"BYTE AudioSel)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The PATSEBMessage class PTSBMSSG.CPP is derived from StandardProtocol but currently none of its functions are implemented. Therefore, it behaves exactly like StandardProtocol.",{"@attributes":{"id":"p-0600","num":"0617"},"tables":{"@attributes":{"id":"TABLE-US-00084","num":"00084"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["PATSEBMessage Class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void DerivedDecode( )","Stub."]},{"entry":["void DerivedEncode( )","Stub."]},{"entry":["BYTE GetLengthOfCommand( )","Stub. Returns Zero."]},{"entry":["bool IsValidCommand( )","If Command is recognized by"]},{"entry":[{},"GetLengthOfCommand( ), returns"]},{"entry":[{},"TRUE."]},{"entry":[{},"Currently returns FALSE."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Serial_Message SRLMSSGE.CPP is derived from IFE_Message. It is used to carry and process Serial data from the Message Processor to any serial I\/O devices NAU. Currently, it is the base class for VCP_Message. The pure virtual functions defined in IFE Message is implemented within Serial Message.",{"@attributes":{"id":"p-0602","num":"0619"},"tables":{"@attributes":{"id":"TABLE-US-00085","num":"00085"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Serial_Message Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bool","Local version reads data into IFE_Message"]},{"entry":["GetData","data from InPipe, returning the number of"]},{"entry":["(HANDLE hInPipe,","BytesRead. Returns FALSE if no data read"]},{"entry":["ULONG *pBytesRead)","from InPipe."]},{"entry":["bool","Local version fills IFE_Message data"]},{"entry":["GetData","structures with data contained in input"]},{"entry":["(IfeIdType idSource,","arguments. Always returns TRUE."]},{"entry":"IfeIdType idDestination,"},{"entry":"BYTE *pData,"},{"entry":"DWORD dwDataLen)"},{"entry":["bool","Simply calls the IFE_Message version."]},{"entry":"GetData"},{"entry":"(Queue *pInputQueue)"},{"entry":["bool","Local version copies the data and length"]},{"entry":["PutData","elements from an IFE_Message to the"]},{"entry":["(BYTE *byData,","specified arguments. Always returns TRUE."]},{"entry":"DWORD *pDataLen)"},{"entry":["bool","Simply calls the IFE_Message version."]},{"entry":"PutData"},{"entry":"(HANDLE hOutPipe,"},{"entry":"ULONG *pBytesWritten)"},{"entry":["bool","Simply calls the IFE_Message version."]},{"entry":"PutData(Queue"},{"entry":"*pOutputQueue)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The VCP_Message class VCPMSSGE.CPP is derived from Serial_Message (which is derived from IFE_Message) to communicate with the Video Players. It is used between the Message Processor and the VCP NAU.",{"@attributes":{"id":"p-0604","num":"0621"},"tables":{"@attributes":{"id":"TABLE-US-00086","num":"00086"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["VCP_Message",{}]},{"entry":["Class Function","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","Stub."]},{"entry":"Format"},{"entry":"(VCPMessageFormat"},{"entry":"nMessageFormat)"},{"entry":["CString","Overrides the one in the IFE_Message"]},{"entry":["GetAddress( )","base class."]},{"entry":[{},"Returns the contents of the"]},{"entry":[{},"IFE_Message data Address field in a"]},{"entry":[{},"CString."]},{"entry":["void","If a valid VCP PlayerCommand, parses"]},{"entry":["GetCommandData","out the Command Bytes from the"]},{"entry":["(PLAYERCOMMANDS","IFE_Message data, returning it in"]},{"entry":["*pPlayerCommand,","byData."]},{"entry":["BYTE *byData,","Returns the number of bytes in"]},{"entry":["int *pDataLen)","DataLen, Zero if invalid command."]},{"entry":["CString","Overrides the one in the IFE_Message"]},{"entry":["GetLruInfo( )","class. This version creates a CString"]},{"entry":[{},"from the data contained in the LruInfo"]},{"entry":[{},"field of the IfeMessageData structure"]},{"entry":[{},"and returns it to the function."]},{"entry":["void","Stub"]},{"entry":"GetPlayerResponse"},{"entry":"(PlayerCommands"},{"entry":"*pPlayerCommand"},{"entry":"PLAYERSTATE"},{"entry":"*pPlayerState"},{"entry":"BYTE *pData,"},{"entry":"BYTE *pDataLen)"},{"entry":["void","Parses data from IFE_Message data into"]},{"entry":["GetResponseData","byData, returning the DataLen size of"]},{"entry":["IfeFunctionType","the data. Returns responses Ack or"]},{"entry":["*pResponseCommand,","Nak in ResponseCommand."]},{"entry":"BYTE *byData,"},{"entry":"int *pDataLen)"},{"entry":["PLAYERSTATE","Returns the enumerated state of the"]},{"entry":["GetState( )","VCP (e.g., Playing, FastForward, etc.)"]},{"entry":["void","Retrieves state information from this"]},{"entry":["GetStateInfo","IFE Message object. Assumes that"]},{"entry":["(PLAYERSTATE *pState,","state information was writing using the"]},{"entry":["DWORD *pTime)","SetStateInfo member function."]},{"entry":["bool","Returns FALSE if checksum test."]},{"entry":"IsValidChecksum( )"},{"entry":["void","Overrides SetAddress in IFE_Message"]},{"entry":["SetAddress","base class. Address field of the"]},{"entry":["(CString csAddress)","IfeMessageData structure for this"]},{"entry":[{},"message is populated using the CString"]},{"entry":[{},"input argument."]},{"entry":["void","Calculates and writes a checksum to"]},{"entry":["SetChecksum( )","the IFE Message. Then stores the full"]},{"entry":[{},"length of the message in the"]},{"entry":[{},"MessageLength field of the message."]},{"entry":["void","Overrides the function in the"]},{"entry":["SetLruInfo(","IFE_Message base class. This version"]},{"entry":["CString csLruInfo)","copies the csLruInfo data to the LruInfo"]},{"entry":[{},"field of IFE_Message data."]},{"entry":["void","Converts enumerated internal"]},{"entry":["SetPlayerCommand","PlayerCommand into the actual"]},{"entry":["(PlayerCommands","command byte to go to the VCP."]},{"entry":["nPlayerCommand,","Returns any associated data from"]},{"entry":["BYTE *byData,","IFE_Message data into byData and"]},{"entry":["BYTE byDataLen)","returns its length in DataLen."]},{"entry":["void","Writes VCP State and Time information"]},{"entry":["SetStateInfo","to the IFE Message data. State"]},{"entry":["(PLAYERSTATE nState,","information is retrieved using"]},{"entry":["DWORD dwTime)","GetStateInfo( )."]},{"entry":["void","Writes the UnitId into the IFE Message"]},{"entry":["Set UnitId","data."]},{"entry":"(PGENERIC_TEXT"},{"entry":"pszUnitId)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Thus, systems, methods and articles of manufacture have been disclosed that provide for a networked passenger entertainment system that integrates audio, video, passenger information, product ordering and service processing, communications, and maintainability features, and permits passengers to selectively order or request products and services, receive video, audio and game data for entertainment purposes, and communicate with other passengers and computers on- and off-board the aircraft, and which thereby provides for passenger selected delivery of content over a communication network. It is to be understood that the above-described embodiments are merely illustrative of some of the many specific embodiments that represent applications of the principles of the present invention. Clearly, numerous and other arrangements can be readily devised by those skilled in the art without departing from the scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The various features and advantages of the present invention may be more readily understood with reference to the following detailed description taken in conjunction with the accompanying drawings, and in which:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5","i":"a "},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7","i":"a "},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 7","i":"b "},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 21"}]},"DETDESC":[{},{}]}
