---
title: Measuring by the kernel the amount of time a monitored thread spends in a queue in order to monitor scheduler delays in a computing device
abstract: In general, techniques of this disclosure relate to measuring scheduling performance of monitored threads in an operating system with improved precision. In one example, a method includes inserting, by an operating system kernel, a monitored thread into a queue comprising one or more threads and recording an insertion time that the monitored thread is inserted into the run queue; receiving, by the kernel, an event to remove the monitored thread from the run queue; responsive to receiving the event, determining, by the kernel, an amount of time that the monitored thread is stored on the run queue based on the insertion time and a removal time at which the monitored thread was removed from the run queue; and when the amount of time the monitored thread is stored on the run queue is greater than or equal to a specified threshold, sending a notification to a notification listener.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954968&OS=08954968&RS=08954968
owner: Juniper Networks, Inc.
number: 08954968
owner_city: Sunnyvale
owner_country: US
publication_date: 20110803
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The invention relates to operating systems and, more particularly, to scheduling tasks within operating systems.","A computing device typically executes software, referred to as an \u201coperating system\u201d that is responsible for providing an interface between hardware of the computing device and application software. The operating system also generally provides common services for execution of the application software. The operating system may include a number of different components for providing the interface between the hardware and the application software, such as a kernel component, a networking component, a security component and a user interface component. The kernel component (which is often referred to as the \u201ckernel\u201d), may represent the core component that manages or otherwise controls the interface between application software and the hardware of the computing device. The kernel manages the execution of application software by the underlying hardware, instantiating or otherwise creating processes, allocating memory and other hardware resources for use by the processes, establishing priorities for the processes, loading program instructions into memory and scheduling execution of the loaded instructions associated with the process by the underlying hardware.","Processes executing on a computing device may represent executing instances of computer programs. A scheduler component of an operating system is responsible for scheduling the one or more processes for execution. Schedulers of some operating systems may also provide support for multithreading. Schedulers of multiprogramming operating systems may apply time-division multiplexing techniques that enable a processor to execute multiple different threads of a process such that a particular thread is executed for a specified period of time before the operating system selects a different thread for execution. Some operating system may further include data structures such as run queue to schedule and further prioritize different threads for execution. The operating system may also include a sleep queue to store inactive threads that are not presently scheduled for execution. As applications are executed by a processor, the operating system may switch threads between the run queue and sleep queue based on application and operating system instructions.","The performance of a computing device is dependent on, among other things, the number of executing processes and threads, the type of operations performed by each executing process or thread, and the implementation of operating system itself. In some examples, computing device performance problems may be difficult to detect and therefore solve when a large number of possible root causes may affect system performance. Failure to quickly and easily identify performance issues of a computing device may negatively affect debugging efforts and product development processes.","In general, techniques of this disclosure relate to measuring scheduling performance of monitored threads in an operating system with improved precision. The disclosure further includes techniques that enable a scheduler of an operating system to re-prioritize monitored threads when scheduling performance does not meet pre-defined performance thresholds. In one aspect of the disclosure, techniques are described by which the operating system allows maximum delay times to be assigned to individual threads. The maximum delay times may be assigned, for example, by user-level application software and that each delay time specifies an amount of time that a corresponding the thread of execution may remain on a run queue before being selected for execution. Furthermore, the operating system may include additional mechanisms for more precisely measuring and reporting delay times within the kernel on a per-thread basis as designed by the user-level application software. For example, a scheduler of the kernel includes monitoring logic that records an insertion time when the scheduler initially inserts into the run queue a thread that has be designated for performance monitoring. At a later time when the kernel removes the thread from the run queue for execution, the monitoring logic may further determine and record the amount of time the thread was stored on the run queue. If the amount of time that the thread has been stored on the run queue exceeds the maximum delay time, the monitoring logic may generate an event. The event may, in some examples, cause other components of the operating system to re-prioritize one or more monitored threads and trigger a reporting mechanism that indicates that a performance threshold, e.g., maximum delay time, has been exceeded.","The monitoring logic integrated within the kernel may allow quantities of time required for other system events, such as hanging interrupts or memory allocations, to more readily be accounted for when determining the measured time that a thread is stored on the run queue. This may provide more precise measurements of the actual time that a thread is stored on the run queue. Moreover, because the techniques may provide more accurate time measurements, the operating system may more efficiently re-prioritize threads and identify possible problems, when the time a thread is stored on the run queue exceeds a maximum delay time.","Techniques of the present disclosure may also be applied to a sleep queue that stores one or more inactive threads. In this way, techniques of the present disclosure may be used to identify and respond to excessive sleep times. Because aspects of the present disclosure are applied in kernel space, individual amounts of time that a thread spends on a run queue and a sleep queue can be measured separately thereby providing more granular measurements of system performance. More granular measurements of system performance may enable to the scheduler to provide improved and more reliable response times for monitored threads by re-prioritizing monitored threads as necessary. Techniques of the present disclosure may further be implemented with a smaller resource footprints thereby improving system performance.","In one embodiment, a method includes inserting, by an operating system kernel executing on the computing device, a monitored thread into a queue comprising one or more threads and recording an insertion time that the monitored thread is inserted into the queue; detecting, by the kernel of the operating system executing on the computing device, an event to remove the monitored thread from the queue; responsive to receiving the event, determining, by the kernel executing on the computing device, an amount of time that the monitored thread is stored on the queue based on the insertion time and a removal time at which the monitored thread was removed from the queue; and when the amount of time the monitored thread is stored on the queue is greater than or equal to a specified threshold, sending a notification to a notification listener.","In one embodiment, a computing device includes: a control unit having one or more hardware-based microprocessors; and an operating system executable by the microprocessors to provide an operating environment for a user software application, wherein the operating system comprises a scheduler module and a monitoring module executing within a kernel space of the operating system, wherein the scheduler module inserts a monitored thread of the user software application into a queue comprising one or more threads and records an insertion time that the monitored thread was inserted into the queue; wherein the scheduler module of the operating system detects an event to remove the monitored thread from the queue; wherein, responsive to the scheduler module receiving the event, the monitoring module of the operating system determines an amount of time that the monitored thread is stored on the queue based on the insertion time and a removal time at which the monitored thread was removed from the queue; and wherein when the amount of time the monitored thread is stored on the queue is greater than or equal to a specified threshold, the monitoring module send a notification to a notification listener.","In one embodiment, system includes: an operating system; a software resource; and a control unit configured to execute the operating system wherein: an application programming interface (API) of the operating system is configured to receive an event from the software resource that indicates the software resource includes a monitored thread; a monitoring module of the operating system is configured, responsive to receiving the event via the API, to modify a thread structure of the monitored thread, wherein modifying the thread structure causes the monitoring module to determine an amount of time that the monitored thread is stored on a queue based on an insertion time that the monitored thread is inserted into the queue and a removal time at which the monitored thread was removed from the queue; and wherein the monitoring module of the operating system is configured to send a notification to a notification listener when the amount of time the monitored thread is stored on the run queue is greater than or equal to a specified threshold.","The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the invention will be apparent from the description and drawings, and from the claims.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["10","10","10"]},"As shown in the example of , computing device  includes a control unit  and a plurality of hardware resources A-N (\u201chardware resources \u201d). Control unit  may generally represent hardware, which in some instances may execute software in the form of instructions stored to a computer readable medium. For example, control unit  may comprise any combination of one or more of processors, Application Specific Integrated Circuits (ASICs), integrated circuits or any other processing or control unit or element or combination thereof, and a memory or storage device. In some instances, the memory or storage device (e.g., generally, a computer-readable storage medium) may comprise the above described instruction that cause the programmable processor to perform the techniques described herein. These instructions may form a computer or software program or other executable module that the programmable processor executes to perform the functionality described herein, including the functionality attributed to the techniques of this disclosure.","In this respect, control unit  comprises a plurality of processing elements. The processing elements include one or more of a general purpose processor, a programmable processor and central processing unit (CPU), more dedicated processing elements, such as a network processing unit (NPU) and graphics processing unit (GPU), entirely dedicated processing elements, such as a field programmable gate array (FPGA) and an application specific integrated circuit (ASIC), or any combination of the above.","Control unit  provides an operating environment for a plurality of software resources , one or more Application Programming Interfaces (APIs) , an operating system , a scheduler , and a plurality of drivers A-N (\u201cdrivers \u201d). Operating system  may include one or more processes, threads, event handling processes, or any other task typically executed by the processing elements represented as control unit . Operating system  generally represents software executed by the processing elements represented as control unit  that provides an interface between hardware resources A-N and software resources . This interface, as presented by operating system , typically involves management and coordination of activities or tasks and the sharing of resources, such as software resources  and hardware resources .","In some examples, operating system  may provide one or more APIs  that expose and provide access to functionality provided to software resources  by operating system . For instance, APIs  may provide specifications of functions and expose data structures provided by operating system  to software resources . Software resources  may invoke such functions or modify the data structures in order to cause operating system  to perform various operations. In this way, APIs  enable software resources  to interact and interface with hardware, such as hardware resources . As shown in , software resources  may include any software program or module executable by control unit . For example, software resources  may include modules comprising instructions that cause computing device  to transfer, drop, encrypt or otherwise process network packets. In other examples, software resources  may be a web browser application, software library, or word processor application.","Each of hardware resources  generally represents a hardware component that performs one or more particular functions or operations. Hardware resources may be general resources such as physical memory or input\/output devices, or specialized hardware components. For example, hardware resource A may comprise dedicated SSL accelerator hardware that only performs SSL acceleration to accelerate forwarding of packets requiring SSL encryption or decryption, or the successor of SSL, TSL encryption and decryption (as SSL acceleration devices may be referred to as SSL acceleration devices despite implementing the successor to SSL, TSL). In any event, each of hardware resources  performs one or more particular functions or operations, including SSL acceleration, TSL acceleration, WAN acceleration (X) or WX, compression, intrusion detection, and intrusion detection and prevention (IDP). Other examples of hardware resources include a modem, memory, output device such as a monitor, or input device such as a mouse or keyboard.","Drivers  generally represent software modules that present an interface with which other software, such as software resources  or operating system  may send and receive information to hardware resources . Typically, each of drivers  correspond to a different one of hardware resources , where operating system  may load drivers  during boot-up or power-up so as to initialize and enable each of hardware resources  for use by software, such as software resources  and operating system .","As shown in , various software components executing on control unit  may be logically separated into user space  and kernel space . User space  and kernel space  represent logical divisions of virtual memory provided by operating system . In particular, virtual memory addresses of kernel space  are reserved for drivers , kernel extensions, and the execution of the kernel itself. Virtual memory addresses of user space  are used by software components that interact with the kernel such as libraries and software resources . In this way, user processes execute in a logically separate area of virtual memory from the kernel to provide, for example, security and performance advantages.","As further shown in the example of , operating system  includes a scheduler  that, in one example, implements aspects of the techniques described in this disclosure to promote more efficient scheduling of tasks within network device . In general, operating system  includes a kernel, which includes core components of the operating system such as scheduler . Scheduler  is a software component of operating system  that schedules execution of threads and processes of software resources  so as to avoid, and potentially eliminate, conflicts resulting from insufficient resources, such as hardware resources  and software resources . As will be later described in , scheduler  may include one or more data structures such as a run queue and a sleep queue that store data associated with threads of execution for software resources . Scheduler  of operating system  may also provide support for multiprogramming. In such examples, scheduler  may apply time-division multiplexing techniques that enable control unit  to execute multiple different threads such that a thread is executed for a specified period of time or until an event that causes operating system  to select a different thread for execution. Scheduler  may implement any number of scheduling techniques separately or in combination such as Round-Robin scheduling, priority scheduling, lottery scheduling, shortest thread next scheduling, or guaranteed schedule to schedule threads. The term thread is used herein to refer to any sequence of executable instruction managed by the operating system. For example, although techniques of the present disclosure are described using threads, the techniques of this disclosure are similarly applicable to processes or individual tasks.","In one example, a scheduler  may implement Round-Robin priority scheduling. In such an example, each thread may be assigned a priority and stored in a queue, e.g., a run queue as shown in , discussed below. Furthermore, two or more threads may each have the same priority thereby resulting in groups of threads that are assigned different priorities. Scheduler , in the current example, executes higher priority threads before lower priority threads. If multiple threads are each assigned the same priority, scheduler  will execute a first thread of the specified priority for a defined period of time or \u201ctime slice.\u201d After the first thread has executed for the duration of the time slice, scheduler  performs a \u201ccontext switch\u201d to select a second thread of the same priority from the run queue for execution and further places the first thread at the end of the run queue. Thus, scheduler  selects and executes threads stored in the run queue in a First-In, First-Out (FIFO) manner. In this way, each thread assigned a particular priority is provided a specified time period of execution thereby ensuring fairness by scheduler  while enabling the user and\/or operating system designer to prioritize groups of threads.","In some instances, threads may be assigned a \u201creal-time\u201d priority. Generally, threads that are not assigned a real-time priority are executed for a specified time-slice according to the previous example. In contrast, real-time threads run to completion. In other words, a real-time thread may run uninterrupted until the thread has no further operations to complete. While real-time threads may provide for improved performance, such threads may generate unintended or undesired side effects in the operation of operating system . For example, non-real-time threads may be starved of resources. System responsiveness may be negatively impacted.","Techniques of the present disclosure overcome such unintended or undesired side effects of real-time threads by enabling software resources  to direct operating system  to classify individual threads as \u201cmonitored threads.\u201d In some instances, aspects of the present disclosure enable a user and\/or application-level software module to classify a thread as a monitored thread. Although techniques of the present disclosure are described in some examples as using a subset of monitored threads, in other examples, all threads of a computing device may be monitored using techniques of the present disclosure. For instance, in some examples, all threads may record insertion times into and removal times from a queue. A monitored thread may be a thread that is sensitive to response times such adverse system performance may occur if the execution of the monitored thread is delayed. When a thread is classified as a monitored thread, scheduler  may, for example, precisely measure the amount of time that the monitored thread is stored on a run queue before being selected for execution by the processor. In such examples, the kernel may initially record an insertion time when the monitored thread is inserted into the run queue. When the kernel later removes the monitored thread from the run queue to execute the thread, the kernel may determine a removal time. If the time that the monitored thread has been stored on the run queue is greater than or equal to a threshold value, operating system  may generate an event. In some examples, the event may be a notification to a logging mechanism such as a listener.","In other examples, the event may cause operating system  to re-prioritize a monitored thread that has been stored on the run queue if the amount of time the monitored thread is stored on the queue is greater than or equal to a specified threshold. For instance, a group of four threads may each be assigned a priority level. One of the threads in the group of four threads may be a monitored thread such that the monitored thread's time stored on the run queue is measured by the kernel. If the amount of time the monitored thread is stored on the queue is greater than or equal to a specified threshold, scheduler  may re-schedule the monitored thread such that monitored thread is prioritized ahead of all other threads of the same priority level. In this way, the monitored thread will run (e.g., is selected from the run queue for execution by control unit ) sooner than other threads of the same priority level if the kernel determines the monitored thread has been stored on the run queued for a time that is greater than or equal to a threshold. This technique enables scheduler  to re-schedule the monitored thread within its priority level for improved performance without changing the assigned priority level of the monitored thread or assigning a real-time priority to the monitored thread. Consequently, unintended or undesired side effects of prioritizing a thread as real-time are avoided using techniques of the present disclosure while providing improved performance for threads that require enhanced performance. Thus, aspects of the present disclosure may provide for granular measurements of time that threads are stored on a run queue and may further enable scheduler  to re-schedule monitored thread for improved system performance. Techniques of the present disclosure are further described in the following figures.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 2","FIG. 1","FIG. 1","FIG. 2","FIG. 1"],"b":["10","28","32","36","38","40","10","12","14","12","14","20","22","22","28","32","24","26","28","30","30","30","32","34","34","34","24","36","38","40","22","26"]},"As shown in , operating system  may include run queue . Run queue  may be implemented as a priority queue that stores one or more active threads  waiting for execution by control unit . To execute an active thread, scheduling module  selects, e.g., active thread A from run queue , to run on control unit . Scheduling module  ensures each active thread  has a fair share of system resources of computing device  by running each active thread  for an equal period of time, e.g., a time slice. For example, active thread A, when selected for execution by scheduling module , is removed from run queue  and executed by control unit . In one example, an event such as an interrupt causes scheduling module  to remove active thread A from run queue  for execution by control unit . In such examples, the scheduling module  may detect the event. Detecting an event may include receiving an event from another hardware or software component, or determining the event has occurred within a hardware or software component. Once active thread A has been run by control unit  for an amount of time equal to the time slice, scheduling module  inserts the thread at the end of other threads of the same priority in run queue . Scheduling module  then removes the next thread from the front of run queue . In this way, active threads  are executed in a FIFO manner. Scheduling module  may select active threads  from run queue  from highest to lowest priority. For instance, scheduling module  may execute all active threads of higher priority before executing threads of lower priority. To ensure fairness, scheduling module  may in some examples, decay the priority of higher priority threads such that all threads are eventually executed by control unit .","Operating system  may further include a sleep queue . Sleep queue  may be implemented as a queue that stores one or more inactive threads A-D. In some examples, a thread may initially be stored on run queue  as an active thread. When the active thread is removed from run queue  and executed by control unit , an instruction included in the active thread may, when executed by control unit , cause scheduling module  to insert the active thread into sleep queue . When scheduling module  inserts the thread into sleep queue , the thread may be referred to an \u201cinactive thread.\u201d Inactive threads , for example, remain on sleep queue  until an event occurs that causes scheduling module  to remove an inactive thread from sleep queue . For instance, an active thread may include a \u201csleep\u201d instruction that, when executed by control unit , causes scheduling module  end execution of the thread and further insert the thread into sleep queue  for a specified period of time. The sleep command also causes scheduling module  to generate a timer object for the specified period of time. When the timer object expires after the specified period of time, the timer object sends a signal or event to scheduling module  which removes the thread from sleep queue  and inserts the thread into run queue  for execution.","As shown in , scheduler  of operating system  includes a scheduling module . Scheduling module  may implement techniques for inserting threads into and removing threads from run queue  as previously described with respect to run queue . Schedule module  may further implement techniques for inserting threads into and removing threads from sleep queue  as previously described with respect to sleep queue . For instance, scheduling module  may implement any number of scheduling techniques separately or in combination such as Round-Robin scheduling, priority scheduling, lottery scheduling, shortest thread next scheduling, or guaranteed schedule to schedule threads.","Scheduler  may also include prioritization module . Prioritization module  may change the priorities of threads stored in run queue  and sleep queue . For instance, scheduling module  may receive an event from monitoring module  that an active thread D has been stored on run queue  for a time that exceeds a specified threshold. In the current example, prioritization module may, for example, increase the priority of active thread D from 6 to 5. Prioritization module  may further decrease the priorities of one or more threads as well.","Scheduler  further includes monitoring module . Monitoring module  enables a user and\/or a software or hardware component to monitor one or more threads in run queue  and\/or sleep queue . For instance, a user may wish to designate active thread B as a \u201cmonitored thread\u201d because active thread B is sensitive to delays of scheduler . When a thread is sensitive to delays, techniques of the present disclosure enable a user to monitor the thread to detect delays and, in some examples, cause scheduler  to re-prioritize the thread when delays occur.","In the past, if a user wished to determine whether a scheduler was providing satisfactory scheduling performance, the user would typically implement the following example pseudocode in user space code of a thread:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20021","void do_work (int sleeptime) {"]},{"entry":[{},"\u20022","\u2003int start_time;"]},{"entry":[{},"\u20023","\u2003int end_time;"]},{"entry":[{},"\u20024","\u2003int TOLERANCE = 200;"]},{"entry":[{},"\u20025","\u2003"]},{"entry":[{},"\u20026","\u2003start_time = get_current_time( );"]},{"entry":[{},"\u20027","\u2003sleep(sleeptime);"]},{"entry":[{},"\u20028","\u2003end_time = get_current_time( );"]},{"entry":[{},"\u20029","\u2003"]},{"entry":[{},"10","\u2003if (end_time \u2212 start_time > (sleeptime \/ 1000) +"]},{"entry":[{},"11","\u2003\u2003TOLERANCE) {"]},{"entry":[{},"12","\u2003\u2003generate_event ( );"]},{"entry":[{},"13","\u2003}"]},{"entry":[{},"14","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"As shown in line 6, the user includes an instruction to store a timestamp of the current time prior to the sleep command. When the line 7 is executed, the thread is stored on a sleep queue for a number of time units specified by sleeptime. For instance, a number of time units specified by sleeptime may be 2 seconds. Additionally, the scheduler may generate a timer object that is initiated to expire after the specified number of time units. When the timer object expires, the scheduler removes the thread from the sleep queue and inserts the thread into the run queue. The instruction at line 8 then captures the current time after the thread has been removed from the sleep queue. At line 10, the scheduler then determines whether the amount of time the thread was stored on the sleep queue exceeded the specified sleeptime plus an acceptable TOLERANCE value that corresponds to an acceptable margin of error. In one example, an acceptable TOLERANCE value may be 200 millisends. For example, pseudocode at line 10 may determine whether the timer object was delayed due to a problem, thereby causing the thread to be moved from the sleep queue to the run in an amount of time that exceeds the specified sleeptime plus some acceptable margin of error.","Aspects of the present disclosure overcome numerous disadvantages of past techniques for monitoring scheduling performance. For instance, the previous example measures time in user space code and consequently may not be able to discriminate between delays in scheduling performance that are due to normal operation of the operating system and delays due to potential problems that require further identification and solutions. For instance, after the execution of line 7, i.e., the thread has been moved from the sleep queue to the run queue but prior to recording a current time for end_time, other system events may occur such as system interrupts or page faults. The time required for the operating system to perform, e.g., a memory allocation in response to a page fault, may therefore be included in the calculation performed at line 10 that is intended to determine if the timer object was delayed due to a problem. Because a memory allocation in response to a page fault constitutes a normal operation of the operating system, the implemented pseudocode may incorrectly include the additional required time to allocate the memory in the measurement at line 10 that is intended to measure if the timer object associated with the thread is delayed to an actual problem in the operating system. In other words, past techniques failed to discriminate between normal operating system delays and actual scheduling performance problems, thereby some reporting scheduling performance delays as problems even when the operating system was performing normally.","Techniques of the present disclosure overcome such measurement problems and may further provide techniques to re-prioritize threads that experience delays. According to techniques of the present disclosure, a thread may be initially designated as a \u201cmonitored thread\u201d by a user and\/or software or hardware component. Scheduler  may monitor the amount of time a monitored thread is stored on the sleep queue and\/or run queue. In some examples, scheduler  may further re-prioritize monitored threads in response to changes in system performance.","Techniques of the present disclosure enable the user and\/or software or hardware component to designate a thread as a monitored thread via API  provided by operating system . For instance, API  may include a function call of operating system  that may be invoked by a thread. In one example, the function call may further receive one or more parameters. The parameters may, for example, include data that indicates that a thread is a monitored thread and a threshold value that specifies a maximum amount of time that a thread may be stored on a run queue before execution. In other examples, a parameter may include a threshold value that specifies a maximum amount of time that a thread may be stored on a sleep queue before execution.","In one example, the setrlimit( ) function call of a POSIX-compliant operating system may be used to enable the user and\/or software or hardware component to designate a thread as a monitored thread. For instance, the function call setrlimit (RLIMIT_RQ, &limit), when called by a thread includes 2 parameters. The first parameter, RLIMIT_RQ, may include a value that instructs operating system  to monitor the thread. The second parameter, &limit, is a threshold value that specifies a maximum amount of time that the thread may be stored on the run queue. For instance, the threshold value may specify that a scheduler delay of 300 milliseconds is an acceptable time.","When a thread invokes the function that causes operating system  to monitor the thread, e.g., setrlimit (RLIMIT_RQ, &limit), operating system  executes one or more instructions that store the threshold value provided by, &limit, in the thread structure. A thread structure may be data that represents the thread and is stored by operating system . For instance, POSIX-compliant operating systems represent each thread as a thread structure called a task_struct. A task_struct is a data structure that represents a thread and further contains information about the thread. Techniques of the present disclosure store the threshold value provided by &limit in the thread structure. In addition, techniques of the present disclosure further store an indicator in the thread structure that causes operating system  to measure, e.g., the times that a thread is inserted into and removed from a run queue and\/or sleep queue. For instance, the indicator may be a Boolean value that, when set to a value of true, causes monitoring module  of operating system  to monitor the thread.","As shown in , operating system  includes monitoring module . Monitoring module  monitors monitored threads stored in run queue  and sleep queue  according to techniques of the present disclosure. For instance, run queue  as shown in  includes active threads A-D. Run queue  further includes monitored thread B. Monitored thread B may be a thread for which a user invoked a function, e.g., setrlimit(RLIMIT_RQ, &limit).","In the current example, when monitored thread B is inserted into run queue , monitoring module  records an insertion time into the thread structure, e.g., task_struct, that represents monitored thread B. For instance, the current time may be recorded in milliseconds. At a later point in time, control unit  may perform a context-switch that causes scheduling module  to insert a currently executing thread into run queue  and further select monitored thread B for execution. When scheduling module  selects monitored thread B for execution, monitoring module  determines whether the thread structure that represents monitored thread B includes data that indicates monitored thread B is a monitored thread. If the data indicates monitored thread B is a monitored thread, monitoring module  may record a removal time in the thread structure that represents monitored thread B. The removal time represents a time that scheduling module  removes the thread from run queue  for execution by control unit .","Monitoring module , in some examples, determines an amount of time that monitored thread B is stored on run queue  based on the insertion time and removal time stored in the thread structure that represents monitored thread B. For instance, monitoring module  determines the difference between the removal time and the start time. In some examples, monitoring module  determines if the amount of time the monitored thread is stored on the queue is greater than or equal to a specified threshold. The threshold may be the threshold value specified by &limit. In one example, when the difference between the removal time and the start time is greater than or equal to the threshold value stored in the thread structure that represents monitored thread B, this may indicate a scheduler delay or potential problem in operating system .","If the difference between the removal time and the start time is greater than or equal to the threshold value stored in the thread structure that represents monitored thread B, monitoring module  may generate a notification. The notification may include but is not limited to data that indicates if the amount of time the monitored thread is stored on the queue is greater than or equal to a specified threshold, the difference between the removal time and the start time, and data usable to identify the monitored thread. Because the difference between the removal time and the start time is determined by monitoring module , which is included in operating system , more granular time measurements are possible. More granular time measurements may improve monitoring accuracy. In addition, because monitoring module  performs the measurement of time in kernel space, system events such as interrupts or memory allocations are omitted from the measured time that a thread is stored on the run queue thereby improving monitoring accuracy.","In some examples, monitoring module  sends the notification to prioritization module . Prioritization module  may include a notification listener that receives the notification. In response to receiving the notification, prioritization module may increase the priority of monitored thread B. In this way, techniques of the present disclosure may automatically respond to scheduler delays or other possible problems to improve response times of monitored threads.","In other examples, monitoring module  sends the notification to a logging module (not shown) that is implemented in software resources  and\/or in operating system . The logging module may include a notification listener that receives the notification. Upon receiving the notification, the logging module may record data indicating that the notification was received, e.g., a log entry in a log. In this way, techniques of the present disclosure may notify a user of potential problems, e.g., scheduler delays, in scheduler  thereby allowing the user to respond to such problems.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3","FIG. 2"],"b":"24"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 3","FIG. 3","FIGS. 1 and 2","FIG. 3","FIG. 2","FIG. 2"],"b":["24","16","14","18","28","30","32","34","24","24","36","38","40"]},"In one example, a user may wish to use techniques of the present disclosure to monitor a thread and more specifically to separately monitor the amount of time the monitored thread is stored on run queue  and sleep queue . Active threads  are selected by scheduler  for execution and are inserted into run queue  to be later executed as described in . As shown in , a user may wish to monitor inactive thread A and more specifically measure the amount of time thread A is stored on run queue  and sleep queue .","Initially, the user invokes two functions, setrlimit (RLIMIT_RQ, &limit) and setrlimit (RLIMIT_SQ, &limit) to cause scheduler  to monitor thread A. The first function call, setrlimit (RLIMIT_RQ, &limit), causes monitoring module  to store the threshold value of & limit in a run_threshold variable . A thread structure  representing thread A may include run_threshold variable . Later, monitoring module  may select the threshold value stored in run_threshold variable  when monitoring the amount of time thread A is stored on run queue . In some examples, thread structure  further includes a run queue monitoring variable (not shown) to store a flag that when set indicates thread A is being monitored. Monitoring module  may check this monitoring variable at later points in time to determine whether thread A is monitored. In examples that do not include a monitoring variable, the run_threshold value  may be set to, e.g., a negative value when the thread is not monitored and positive values will be interpreted by monitoring module  as threshold values. In this way, monitoring module  may determine a thread is not monitored if the value of the run_threshold  is negative.","In still other examples, when a thread invokes a function that causes operating system  to monitor the thread, e.g., setrlimit (RLIMIT_RQ, &limit), monitoring module  may store a thread identifier of the of the monitored thread in a data structure that includes thread identifiers of all monitored threads. When scheduler  later performs a context switch to enable another thread to run, monitoring module  may check the data structure to determine whether the thread is a monitored thread and therefore apply techniques of the present disclosure.","The second function call, setrlimit (RLIMIT_SQ, &limit), causes monitoring module  to store a threshold value of & limit in a sleep_threshold variable . Thread structure  representing thread A may include sleep_threshold variable . Later, monitoring module  may select the threshold value stored in sleep_threshold variable  when monitoring the amount of time thread A is stored on sleep queue . Thread structure  may also optionally include a sleep queue monitoring variable (not shown) to store a flag that may be set to indicate thread A is being monitored.","Thread A may be inserted into run queue  when thread A is initially instantiated. Monitoring module  determines that run_threshold variable  is set to 200 milliseconds and therefore is a monitored thread. Consequently, monitoring module  records an insertion time of 1297327781715 in run_queue_entry variable . The time of 1297327781715 may be, e.g., a Unix timestamp that represents the time that thread A is inserted run queue .","Scheduler  may later remove thread A from run queue  for execution by a control unit such as control unit . For instance, when scheduling module  removes thread A for execution on a control unit, monitoring module  determines that thread A is a monitored thread because run_threshold variable  includes a positive value, e.g., 200 milliseconds. Consequently, monitoring module  records a removal time of 1297327781900 in run_queue_exit variable . Monitoring module  further determines whether the difference between the removal time and the start time is greater than or equal to the threshold value stored in run_threshold variable . Because the difference between the values in run_queue_entry variable  and run_queue_exit variable  is less than 200 milliseconds, i.e., the value of run_threshold variable , monitoring module  does not generate a notification that if the amount of time the monitored thread is stored on the queue is greater than or equal to a specified threshold. Control unit  then executes thread A for a period of time equal to a specified time-slice before scheduler  inserts thread A back into run queue  and a new insertion time is recorded in run_queue_entry variable . In this way, each of threads  may be selected from run queue  for execution by a control unit and various threads may be monitored according to techniques of this disclosure.","In some examples, thread A may include instructions that cause scheduler  to insert thread A into sleep queue . For instance, POSIX-compliant operating systems include a sleep( ) function that when executed, causes scheduling module  of scheduler  to suspend execution of a thread, e.g., thread A, for a specified period of time. For instance, when the sleep( ) function is executed, an event  indicating the sleep( ) function and a number of time units to sleep thread A may be sent to scheduler . In addition, scheduling module  inserts thread A into sleep queue . Scheduling module  also generates a timer object . Timer object  is a data structure created by the operating system to \u201cwake up\u201d a thread on sleep queue  upon expiration of a specified time period. To wake up thread A, scheduling monitor , upon expiration of timer object , selects the sleeping thread A from sleep queue  and inserts the thread back into run queue . In the current example, timer object  is set to a number of time units specified in a parameter of the sleep command included in thread A.","In accordance with aspects of the present disclosure, techniques are provided to monitor the amount of time a thread is stored on a sleep queue. Thus, in the current example, when a sleep instruction of thread A is executed, scheduling module  inserts thread A into sleep queue . Monitoring module  further determines whether thread A is a monitored thread. For instance, monitoring module  determines whether sleep_threshold variable  includes a positive value. Because sleep_threshold variable  includes a positive value, thread A is a monitored thread. Consequently, monitoring module  records the current time that thread A is inserted into sleep queue  in sleep_queue_entry . The time of 1297327783500 may be, e.g., a Unix timestamp that represents the time that thread A is inserted sleep queue .","At a later time, timer object  expires and scheduling module  selects thread A from sleep queue . Monitoring module  determines whether thread A is a monitored thread by determining that the sleep_threshold variable  includes a positive value. Because sleep_threshold variable  includes a positive value, thread A is a monitored thread. Consequently, monitoring module  records the current time that thread A is removed from sleep queue  in sleep_queue_exit .","Monitoring module , in some examples, further determines the difference between the values of sleep_queue_entry  and sleep_queue_exit . Monitoring module  also calculates the sum of the value in sleep_threshold variable  and the initially specified amount of time from the sleep( ) function that thread A was instructed to sleep. In the current example example, monitoring module  generates a notification  because monitoring module  determines that the difference between the values of sleep_queue_entry  and sleep_queue_exit  is greater than the sum of the sleep_threshold variable  value and the initially specified sleep time in the sleep( ) function.","Monitoring module  may generate a notification  because the amount of time that thread A was stored on sleep queue  exceeded the sum of the threshold value and the specified sleep time in timer object . In such examples, a problem may exist in the system that caused timer object  and\/or scheduling module  to be delayed in removing thread A from sleep queue  and inserting thread A into run queue . Monitoring module  may in some examples send notification  to a software resource in user space  such as a logging software resource. In other examples, monitoring module  may generate and send a notification to prioritization module . Prioritization module , in response, may increase the priority of thread A. In this way, techniques of the present disclosure may enable threads that are sensitive to delay to continue to perform responsively by changing the priorities of the threads.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 4","FIG. 4","FIG. 2","FIGS. 1-3"],"b":["24","14","34","12","34","36","24","34","34","34","34","34","28"]},"When scheduler  inserts thread A into run queue  (), monitoring module  determines whether thread A is monitored (). Monitoring module , in one example, determines whether a run queue monitoring variable or sleep queue monitoring variable includes data that indicates thread A is monitored. In other examples, monitoring module  alternatively determines whether a run threshold variable of the thread structure representing thread A is a positive or negative value. If the value is zero or positive, the thread is monitored and if the value is negative, the thread is not monitored.","If thread A is monitored (), monitoring module  records an insertion time of thread A into run queue  (). If thread A is not monitored (), no insertion time is recorded by monitoring module . At a later time, scheduling module  removes thread A from run queue  for execution by control unit  (), for example, during a context switch performed by scheduler . Upon removing thread A from run queue , monitoring module  determines whether thread A is monitored (). For instance, monitoring module  may perform this determination in the same manner as described with respect to element  of .","If thread A is monitored (), monitoring module  records a removal time of thread A from run queue  in the thread structure that represents thread A (). If thread A is not monitored (), monitoring module  does not record a removal time. In the current example, thread A is monitored and therefore monitoring module  determines an amount of time that thread A is stored on run queue . For instance, monitoring module  may calculate a difference between the insertion time and removal time of thread A from run queue .","Upon calculating the amount of time thread A is stored on run queue , monitoring module  determines if the amount of time the monitored thread is stored on the queue is greater than or equal to a specified threshold (). In some examples, a threshold may be threshold value specified by a user and\/or software or hardware component. If the amount of time thread A is stored on run queue  is greater than or equal to the threshold value, monitoring module  sends a notification to a notification listener (). The notification may include but is not limited to data that indicates the threshold was satisfied, the difference between the removal time and the start time, and data usable to identify the monitored thread ().","In some examples, the notification listener is a part of or includes a logging software resource. In such examples, the notification listener logs information based on the notification. In other examples, the notification listener is included in prioritization module . Upon receiving the notification, prioritization module  may modify the priority of thread A. For instance, prioritization module  may increase the priority of thread A to improve the responsiveness of thread A. Finally, if the amount of time the monitored thread is stored on the queue is greater than or equal to a specified threshold (), no notification is sent to the notification listener.","Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
