---
title: Method and system to provide access to factories in a naming system
abstract: A method and system to provide easy access to factories in a naming service. The system receives an indication that a factory is needed by a client. A plurality of resolvers are checked in turn to find the factory indicated. If a resolver that can provide the factory is found, the factory is returned to the client. In one embodiment, resolvers register with a resolver manager that performs the checking in response to a naming operation. Because the resolver manager can access all registered resolvers, access to the factories is independent of a class path of the user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07721256&OS=07721256&RS=07721256
owner: SAP AG
number: 07721256
owner_city: Walldorf
owner_country: DE
publication_date: 20040527
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","Embodiments of the invention relate to naming. More specifically, embodiments relate to accessing factories in the naming system.","2. Background","Naming service broadly refers to the mechanism by which an object is associated with a name and by which objects may be found given their names. Each name is generated by a set of syntactic rules called, \u201cnaming convention.\u201d An atomic name is an indivisible component of a name as defined by the naming convention. The association of the atomic name with an object is called, \u201cbinding.\u201d Some objects cannot be stored directly so they are put in the system as references. A \u201creference\u201d is an object, which contains one or some addresses of objects which themselves are not directly bound to the naming system. Every name is interpreted relative to some context, and every naming operation is performed in a context object. A \u201ccontext\u201d is a set of bindings in which names are relative to a certain naming convention. A client may obtain an initial context object that provides a starting point for resolution of names in the naming system. Every naming system consists of contexts of a certain type (one and the same naming convention) that provide the same identical set of operations. Every operation is relative to a certain namespace. A \u201cnamespace\u201d is the set of names in the naming system. The naming service organization of the namespace is a treelike structure of naming context objects that can be traversed to locate a particular name.","A directory service is a naming service that allows each bound object to be associated with attributes and provides a way to retrieve an object by looking up some of its attributes rather than its name (search). The \u201cattributes\u201d are object characteristics. Both the attributes and the object itself form a directory object. A \u201cdirectory\u201d is a linked set of directory objects.","In a Java context, basic support for the naming and directory service is provided by a Java Naming and Directory Interface (JNDI) such as specified in , Version 1.2, published by Sun Microsystems of Mountain View, Calif. and subsequent revisions thereof (the JNDI Specification). The JNDI Specification meets the system requirements of Java 2 Enterprise Edition (J2EE). These requirements are defined in the Java 2 Enterprise Edition Specification 1.3, published Jul. 27, 2001 or subsequent versions thereof (the J2EE Standard). JNDI is defined to be independent of any specific directory service implementation. This permits a variety of directories to be accessed in a common way.","Using standard JNDI it is difficult to customize implementations of initial context factories, object factories, uniform resource locator (URL) factories, and state factories. In some cases, it is desirable to permit a client to register and use its own implementations of such factories. Unfortunately, in existing systems, if such implementations are not available in the class path of a client, this is not possible. This issue arises in the context of classloading. A \u201cclass loader\u201d can create a new instance of a class from the class name. Each component in a typical system may have its own class loader that can load one or more classes. Unfortunately, if the class name of a given factory is not among those in a particular class loader, the loader cannot load a new instance of this factory class. Typically, the naming service provider provides several implementations of different factories so that the client's developer can read in the documentation the benefit of each factory and to choose which one to use. Then the client merely specifies the class name of the chosen factory in the environment properties and the role of the classloader is to load a new instance of this class by given class name. By default only a single InitialContextFactoryBuilder and ObjectFactoryBuilder implementation can be registered in javax.naming.spi.NamingManager object of a certain virtual machine (VM).","A method and system to provide access to factories in a naming service. The system receives an indication that a factory is needed by a client. A plurality of resolvers are checked in turn to find the factory indicated. If a resolver that can provide the factory is found, the factory is returned to the client. In one embodiment, resolvers register with a resolver manager that performs the checking in response to a naming operation.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","110","120","110","120","114","116","118","124","126","128","112","122","114","116","118","124","126","128","160","163","170","173","100","102","104","110","120","100","110","120"]},"Server nodes , ,  within instance  provide the business and\/or presentation logic for the network applications supported by the system. Each application server, for example  and , provides a set of services ,  to the business and\/or presentation logic. Among the services provided is naming service , . In one embodiment, the naming service ,  stores data and objects resulting from naming operations, referred to collectively as \u201cnaming data\u201d, in the memory implementation ,  of its respective virtual machine , . The memory implementation ,  by its nature is non-persistent; As a result, when a server goes down and reboots the naming data is not retained. Accordingly, on reboot, the server is assured of a clear name space. Moreover, because the naming operations are not reliant on a DBMS, efficiency and reliability of the naming service is improved.","Each of the server nodes , ,  within a particular instance  may be configured with a redundant set of application logic and associated data. In one embodiment, dispatcher  distributes service requests from clients to one or more of server nodes , ,  based on the load on each of the servers. For example, in one embodiment, a dispatcher implements a round-robin policy of distributing service requests (although various alternate load-balancing techniques may be employed). In one embodiment, the dispatcher performs load balancing on naming service requests from remote clients. However, once a remote client has received an initial context from a certain server node, the subsequent naming requests from that client are directed to the same server node.","In one embodiment of the invention, server nodes , ,  are Java 2 Platform, Enterprise Edition (\u201cJ2EE\u201d) server nodes which support Enterprise Java Bean (\u201cEJB\u201d) components and EJB containers (at the business layer) and Servlets and Java Server Pages (\u201cJSP\u201d) (at the presentation layer). A J2EE platform complies with the J2EE Standard. In one embodiment, the naming service is compliant with the JNDI Specification. In one embodiment, communication and synchronization between each of instances  and  is enabled via central services instance . As illustrated in , central services instance  includes messaging service  and locking service . Message service  allows each of the servers within each of the instances to communicate with one another via a message passing protocol. For example, messages from one server may be broadcast to all other servers within the cluster via messaging service . In addition, messages may be addressed directly to specific servers within the cluster (e.g., rather than being broadcast to all servers).","In one embodiment, locking service  disables access to (i.e., locks) certain specified portions of program code and\/or configuration data stored within a central database . Locking managers  and  employed within the server nodes lock data on behalf of various system components which need to synchronize access to specific types of data and program code (e.g., such as the configuration managers  and ). In one embodiment, messaging service  and locking service  are each implemented on dedicated servers. However, messaging service  and the locking service  may be implemented on a single server or across multiple servers while still complying with the underlying principles of embodiments of the invention.","As illustrated in , each server node (e.g., , ) includes a lock manager ,  for communicating with locking service ; a cluster manager ,  for communicating with messaging service ; and a configuration manager ,  for communicating with central database  (e.g., to store\/retrieve configuration data). Although lock managers  and , cluster managers  and , and configuration managers  and  are illustrated with respect to particular server nodes,  and , in , each of the server nodes , ,  and  and\/or on the dispatchers ,  may be equipped with equivalent lock managers, cluster managers, configuration managers, and services.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","200","202","200","202","200","200","202","202","204"]},"A plurality of resolvers  which includes resolver, resolver. . . resolverregister with the resolver manager . \u201cResolver\u201d as used herein, broadly means a provider of one or more factories. A resolver may provide any subset of the four supported factory types. In one embodiment, the resolver manager  retains a hash table  of registered resolvers against class names. In other embodiments, the resolver manager may maintain a listing of registered resolvers in another type of data structure. In response to a request, resolver manager  iterates serially through the resolvers  to find a resolver that can be a source for a factory capable of servicing the request. Each of the resolvers  may be able to be a source of one or more factory, such as factory , ,  and . In one embodiment, factory  may be an initial context factory. Factory  may be a uniform resource locator (URL) context factory, factory  may be a state factory and factory  may be an object factory. Of course it is within the scope and contemplation of various embodiments of the invention for multiple factories of each type to be provided. In some embodiments, some clients may have their own factory implementations. By registering the corresponding resolver with the resolver manager, access is assured even if the classes of such factories are not available in the class path of the client.","When looking for a factory, the resolver manager  iterates the resolvers  and may sequentially determine if a particular resolver can provide a desired factory. If the resolver  can return the desired factory, e.g. , it returns the factory  to the resolver manager . If the resolver cannot return the desired factory, it returns null to the resolver manager  and the resolver manager  proceeds to the next resolver  until either the factory is found or no resolvers  remain to iterate. If the factory is found, the resolver manager  then returns the context or object requested to the initial context factory builder  which returns context or object by the naming manager  to the requesting client.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3","b":"300"},"At start up of the naming service, an initial context factory builder is established as a default factory builder in the javax.naming.spi.NamingManager such that a JNDI Application Programming Interface (API)  will access the initial context factory builder implementation when an initial context is requested by a client . The initial context of factory builder will provide a proper initial context factory implementation  depending on the environment properties supplied by the client. The initial context factory implementation  will return either offset client context  or client context  depending on the properties of the environment. Client Context always returns the root context, which is an abstraction that forms a starting point for all subsequent naming operations. The returned context may then be organized under the root context or any subcontext within the naming tree dependent on the rights of the client. In one embodiment, only applications will be provided an instance of offset client context . Offset client context  is an extension of client context  and indicates that the context is other than the root context. This prevents application from accessing or creating objects higher up the naming tree. Applications are allowed to perform naming operations only in their own namespace, e.g. the context returned as initial context and the subcontexts created under it.","Client context  has an instance of server context interface which will be either server context implementation , if a client is local or a stub to the server context implementation if the client is remote. Remote clients may use Remote Method Innovation (RMI) to pass messages to the server context implementation. Local clients can communicate directly without using RMI. In one embodiment, the connection service provides the RMI. Local clients can obtain an initial context without using the connection service or RMI.","Server context implementation  is connected to the JNDI memory implementation , which functions as the naming repository in one embodiment of the invention. Also, in some embodiments of the invention, server context implementation  may be connected to a naming cache . Naming cache  may be used to increase the speed of lookup operations in the naming system. In one embodiment, the naming cache  holds object instances for application clients running on the server and byte arrays of the objects for all other clients.","In one embodiment, JNDIMemoryImpl  is the implementation of the non-persistent naming data management within the naming service. JNDIMemoryImpl  keeps the hash tables of the containers stored by name and by ID and a handle to the root container object, which keeps hash tables of all the objects and subcontexts that can be found in the root context of the naming system stored by name and ID. All other containers have the same structure as the root container but are available for direct access. Thus the whole hierarchical tree like structure of objects and contexts in a naming system may be organized in hash tables with only two levels of nesting.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4","b":["400","402","402","404","406","402","404","402","400"]},"Resolver manager  is initialized early in the start up process of the engine. Resolver manager  includes a number of methods including findObjectsFactory( ), findStateFactory( ), findInitialContextFactory( ), findURLContextFactory( ) and getStateToBind( ). These methods are used are used to iterate through the registered resolvers until an appropriate factory is found. In one embodiment, iterating involves inquiring of each resolver if it is capable of providing the requested factory. In one embodiment, the resolver returns either null if it cannot provide the factory or the factory if available. In one embodiment, if a resolver throws a naming exception, no further attempts to get the factory are tried.","When a new initial context is requested by a server side client, the naming\/directory manager ,  delegates the call to initial context factory builder . The initial context factory builder  may be called directly by naming manager . Initial context factory builder  provides a default initial factory  which creates a default initial context . Default initial context  is returned to the naming\/directory manager ,  and occupies a spot in the naming tree.","However, the default initial context is basically a null context until the first naming operation over that context, such as bind operation . In response to the first naming operation over the default initial context  depending on whether a scheme is identified in the name getURLContext( ) or getInitialContext( )  is invoked which uses resolver manager  to invoke either a find URL context factory or a find initial context factory method respectively. A scheme is generally indicated by the presence of a colon in the name. A scheme indicates that the name is a reference to the name of the object rather than the name of the object itself. If present, the scheme is resolved by a getURLContext( ) method . If no scheme is present or after the scheme is resolved, the environment properties of the initial context are checked. Resolver manager uses the find methods to iterate through the registered resolvers and return either URL context factory implementation  or initial context factory implementation  satisfying the environment properties responsive to the bind . Because the resolver manager can access any resolver that is registered with it, clients are able to access factories that are not present in the client's classpath. As a result, the factories available to a client are independent of its class loader.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 5","FIG. 4","FIG. 1"],"b":["500","500","502","502","504","506","506","184","506","504","502","502"]},"Using the object as the argument, a call is then made to a getObjectInstance( ) method of the naming manager . Naming manager  calls createObjectFactory( ) to instantiate an object factory implementation . Object factory builder implementation  if registered delegates the call to the resolver manager  which invokes its findObjectFactory( ) method to iterate through the registered resolvers and return of the appropriate object factory. An object factory implementation meeting the client's requirements is returned by the object factory builder implementation . The naming manager  delegates the getObjectInstance(object) with the object previously deserialized as the argument to the object factory implementation . Object factory implementation  then makes the necessary transformations over the object and returns the result to naming manager  which returns it back to the client as a result of the lookup operation.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 6","FIG. 5","FIG. 4"],"b":["600","602","404","404","404","404","604","404"]},"While the dispatcher state factory  is recognized by the naming manager  and perceived as being a state factory, it is not really a factory at all, rather it serves to redirect\/delegate factory requests to the resolver manager . The dispatcher state factory  delegates the call to the resolver manager . In one embodiment, the delegation involves the dispatcher state factory  invoking the getStateToBind method in the resolver manager . In one embodiment, all the factories are provided by the JNDI specification as interfaces. Each interface specifies the signature of the methods that an implementation of this interface should have. Accordingly, naming providers provide implementation of these factory interfaces, which means that if an object is an implementation of a certain interface this object implements all the methods described in the interface. For example, since ResolverManager implements the StateFactory interface, which means that it implements the getStateToBind method that is described in the StateFactory interface and is common for all state factory implementations. In this way all the state factory implementations can be accessed in a common way.","In one embodiment, the dispatcher state factory  can be loaded from a frame class loader, which is the parent of all other class loaders in the server. The resolver manager  checks the environment properties for extra state factories using the getStateToBind method with the object as its argument. This may take the form of checking the nonstandard environment property for a class name. If factories are found, the resolver manager  iterates the resolvers in the system until a resolver capable of providing the specified factory is found or all resolvers have returned null. If the factory implementation  is found, it changes the object and returns the result. If no factories are found, the resolver manager  returns the object.","Elements of embodiments may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium may include, but is not limited to, flash memory, optical disks, CD-ROMs, DVD ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards, or other type of machine-readable media suitable for storing electronic instructions.","It should be appreciated that reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore, it is emphasized and should be appreciated that two or more references to \u201can embodiment\u201d or \u201cone embodiment\u201d or \u201can alternative embodiment\u201d in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures or characteristics may be combined as suitable in one or more embodiments of the invention.","In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
