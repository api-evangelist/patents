---
title: Method and device to distribute code and data stores between volatile memory and non-volatile memory
abstract: A method, device, and system to distribute code and data stores between volatile and non-volatile memory are described. In one embodiment, the method includes storing one or more static code segments of a software application in a phase change memory with switch (PCMS) device, storing one or more static data segments of the software application in the PCMS device, and storing one or more volatile data segments of the software application in a volatile memory device. The method then allocates an address mapping table with at least a first address pointer to point to each of the one or more static code segments, at least a second address pointer to point to each of the one or more static data segments, and at least a third address pointer to point to each of the one or more volatile data segments.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582216&OS=09582216&RS=09582216
owner: Intel Corporation
number: 09582216
owner_city: Santa Clara
owner_country: US
publication_date: 20111228
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","DESCRIPTION OF THE RELATED ART","DETAILED DESCRIPTION"],"p":["The invention relates to allocating a combination of volatile memory and non-volatile memory for storage of code and data sections of a software application.","Memory performance and capacity requirements continue to increase across many aspects of the computing industry. In addition, memory power requirements and memory cost have become a significant component of the overall power and cost, respectively, of a given computing system ranging from a smart phone to a server. Memory and storage subsystems can increase or decrease the overall performance of a computing device depending on implementation specifics. Because it is generally desirable to have faster performing computing devices that utilize less power and cost less, a wide variety of designs of the memory and storage subsystems exist that attempt to maximize end user perceived performance while minimizing cost and power consumption.","Current operating systems provide an application programming interface (API) to allow for applications and drivers to request memory from paged and non-paged pools. Non-paged pools are typically used for data that must not be paged to a mass storage drive (e.g., pages that hardware is expected to access during execution of the application). Since currently all allocated pages are accessed when in DRAM so there is no additional information required at page allocation time whether the data that is going to be stored within an allocated buffer is expected to be for just reading versus read-and-write.","Many embodiments described below resolve code and data usage challenges introduced to the memory and storage subsystems of a computing device by subdividing the performance requirement and the capacity requirement between diverse memory technologies. The focus of this approach is on providing performance with a relatively small amount of a higher-speed memory such as dynamic random access memory (DRAM) while implementing the bulk of the system memory using a significantly cheaper and denser non-volatile memory. Several embodiments described below define platform configurations that enable hierarchical memory subsystem organizations for the use of a certain type of non-volatile memory, specifically referred to as non-volatile random access memory (NVRAM) to augment volatile memory, by one or more graphics processors in a computing device. The use of the NVRAM in the memory hierarchy additionally allows non-volatile memory mass storage implementations as a substitute for standard mass storage drives.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},"A central processing unit (CPU), a graphics processing unit (GPU), and an embedded processor may be provided access to both volatile and non-volatile forms of memory according to several embodiments. The CPU and GPU can also be referred to as \u201cprocessors\u201d throughout this document. These different nomenclatures are utilized.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 1","FIG. 1"]},"Turning now to the detailed elements of , a CPU  is present. This CPU includes one or more cores . Although not shown, each core may internally include one or more instruction\/data caches, execution units, prefetch buffers, instruction queues, branch address calculation units, instruction decoders, floating point units, retirement units, etc. In other embodiments that are not shown, the system may include multiple CPUs, each with its own set of logic units that are displayed in .","The CPU  includes at least one lower level cache, such as cache . This may be a general purpose cache that is capable of storing a significant amount of data retrieved from memory locations in volatile memory  and\/or an NVRAM . In different embodiments, cache  may be shared among all cores or each core may have its own lower level cache.","CPU  may also include additional logic that is not shown which coordinates and operates at least core(s) . In some embodiments, this additional logic may be referred to as a home agent. The home agent may include, for example, a power control unit (PCU). The PCU may include logic and components needed for regulating the power state of the core(s)  among other tasks.","According to several embodiments, the computer system in  additionally includes a GPU . The GPU  also may include one or more core(s) . Each core may include one or more execution units and one or more instruction and data caches utilized to feed the execution units with information to process. Additionally the GPU  may contain other graphics logic units that are not shown in , such as one or more vertex processing units, rasterization units, media processing units, and codecs among others. For sake of simplicity, the specific logic within the core(s)  as well as other graphics-related logic units within the GPU  are not shown.","There may be one or more lower level caches in GPU  as well, such as cache . This cache may be utilized as a general purpose cache or a cache specific to one or more particular types of graphics data (e.g., vertex data). Other lower level caches are not shown, though in some embodiments multiple caches like cache  exist within GPU .","According to many embodiments, a display controller  is communicatively coupled to the GPU . The display controller  receives information to be displayed upon a display device (e.g., a monitor, a television, a projector, etc.). In many embodiments, the display controller  specifically receives frame buffers. Each frame buffer consists of an image comprising pixels that is then interpreted by the display controller and the image is fed to the display device for viewing. Depending on the refresh frequency of the display device, frame buffers may be fed to the display controller  a certain number of times per second. For example, a 60 Hz refresh rate utilizes 60 images (frame buffers of image information) per second. Different display devices may utilize higher frequency refresh rates and simply re-sample the same frame buffer two or more times prior to utilizing anew frame buffer of information to display.","A memory subsystem  is also present in . There is a volatile memory controller , which may be utilized to provide access to volatile memory . Volatile memory controller , which is integrated into the CPU package or discrete from the CPU package in different embodiments, may receive a memory access request from a CPU core  or a GPU core  and route that request to volatile memory . Likewise, non-volatile (NV) memory controller  may receive a memory access request from a CPU core  or a GPU core  and route that request to NVRAM . In some embodiments, the volatile memory controller  and non-volatile memory controller  are integrated into one large memory controller. In other embodiments they are separate controllers.","In many embodiments, an input\/output (I\/O) subsystem  is present in the system in  to communicate with I\/O devices, such as I\/O device(s) . Within the I\/O subsystem , one or more I\/O adapter(s)  are present to translate a host communication protocol utilized within the CPU  to a protocol compatible with particular I\/O devices. Some of the protocols that adapters may be utilized for translation include Peripheral Component Interconnect (PCI)-Express (PCI-E), 3.0; Universal Serial Bus (USB), 3.0; Serial Advanced Technology Attachment (SATA), 3.0; Small Computer System Interface (SCSI), Ultra-640; and Institute of Electrical and Electronics Engineers (IEEE) 1394 \u201cFirewire;\u201d among others.","Additionally, there may be one or more wireless protocol I\/O adapters. Examples of wireless protocols, among others, are used in personal area networks, such as IEEE 802.15 and Bluetooth, 4.0; wireless local area networks, such as IEEE 802.11-based wireless protocols; and cellular protocols.","A Basic Input\/Output System (BIOS) flash  device may additionally be present in the system to provide a set of boot instructions when the system powers on or reboots. For BIOS flash  device, some of the protocols that I\/O adapters  may translate include Serial Peripheral Interface (SPI) and Microwire among others.","Returning to the NVRAM , an overview of the NVRAM is provided below.","1. Non-Volatile Random Access Memory Overview","There are many possible technology choices for NVRAM, including PCM, Phase Change Memory and Switch (PCMS) (the latter being a more specific implementation of the former), byte-addressable persistent memory (BPRAM), storage class memory (SCM), universal memory, Ge2Sb2Te5, programmable metallization cell (PMC), resistive memory (RRAM), RESET (amorphous cell, SET (crystalline) cell, PCME, Ovshinsky memory, ferroelectric memory (also known as polymer memory and poly(N-vinylcarbazole)), ferromagnetic memory (also known as Spintronics, SPRAM (spin-transfer torque RAM)), STRAM (spin tunneling RAM), magnetoresistive memory, magnetic memory, magnetic random access memory (MRAM), and Semiconductor-oxide-nitride-oxide-semiconductor (SONOS, also known as dielectric memory).","NVRAM has the following characteristics:","It maintains its content even if power is removed, similar to FLASH memory used in solid state disks (SSD), and different from SRAM and DRAM which are volatile;","it has lower overall power consumption than volatile memories such as SRAM and DRAM;","it has random access similar to SRAM and DRAM (also known as randomly addressable);","it is rewritable and erasable at a lower level of granularity (e.g., byte level) than FLASH found in SSDs (which can only be rewritten and erased a \u201cblock\u201d at a time\u2014minimally 64 Kbyte in size for NOR FLASH and 16 Kbyte for NAND FLASH);","it is used as a system memory and allocated all or a portion the system memory address space;","it is capable of being coupled to the CPU over a bus (also interchangeably referred to as an interconnect or link) using a transactional protocol (a protocol that supports transaction identifiers (IDs) to distinguish different transactions so that those transactions can complete out-of-order) and allowing access at a level of granularity small enough to support operation of the NVRAM as system memory (e.g., cache line size such as 64 or 128 byte). For example, the bus\/interconnect may be a memory bus (e.g., a double data rate (DDR) bus such as DDR3, DDR4, etc.) over which is run a transactional protocol as opposed to the non-transactional protocol that is normally used. As another example, the bus may one over which is normally run a transactional protocol (a native transactional protocol), such as a PCI express (PCIE) bus, desktop management interface (DMI) bus, or any other type of bus utilizing a transactional protocol and a small enough transaction payload size (e.g., cache line size such as 64 or 128 byte); and","it also has one or more of the following characteristics:","it has faster write speed than non-volatile memory\/storage technologies such as FLASH;","it has very high read speeds (faster than FLASH and near or equivalent to DRAM read speeds);","it is directly writable (rather than requiring erasing (overwriting with 1s) before writing data like FLASH memory used in SSDs); and\/or","it allows a greater number of writes before failure (more than boot ROM and FLASH used SSDs).","As mentioned above, in contrast to FLASH memory, which must be rewritten and erased a complete \u201cblock\u201d at a time, the level of granularity at which NVRAM is accessed in any given implementation may depend on the particular memory controller and the particular memory bus or other type of bus to which the NVRAM is coupled. For example, in some implementations where NVRAM is used as system memory, the NVRAM may be accessed at the granularity of a cache line (e.g., a 64-byte or 128-Byte cache line), notwithstanding an inherent ability to be accessed at the granularity of a byte, because cache line is the level at which the memory subsystem accesses memory. Thus, when NVRAM is deployed within a memory subsystem, it may be accessed at the same level of granularity as DRAM used in the same memory subsystem. Even so, the level of granularity of access to the NVRAM by the memory controller and memory bus or other type of bus is smaller than that of the block size used by Flash and the access size of the I\/O subsystem's controller and bus.","NVRAM may also incorporate wear leveling algorithms to account for the fact that the storage cells begin to wear out after a number of write accesses, especially where a significant number of writes may occur such as in a system memory implementation. Since high cycle count blocks are most likely to wear out in this manner, wear leveling spreads writes across the far memory cells by swapping addresses of high cycle count blocks with low cycle count blocks. Note that most address swapping is typically transparent to application programs because it is handled by hardware, lower-level software (e.g., a low level driver or operating system), or a combination of the two.","The NVRAM is distinguishable from other instruction and data memory\/storage technologies in terms of its characteristics and\/or its application in the memory\/storage hierarchy. For example, NVRAM is different from:","static random access memory (SRAM) which may be used for level 0 and level 1 internal processor caches dedicated to each core within a processor and lower level cache (LLC) shared by cores within a processor;","dynamic random access memory (DRAM) configured as a cache internal to a processor die (e.g., on the same die as the processor), configured as one or more caches external to a processor die (e.g., in the same or a different package than the processor die), or general system memory external to the processor package; and","FLASH memory\/magnetic disk\/optical disc applied as mass storage; and","memory such as FLASH memory or other read only memory (ROM) applied as firmware memory (which can refer to boot ROM, BIOS Flash, and\/or TPM Flash).","In , NVRAM  may be used as instruction and data storage that is directly addressable by a CPU  and is able to sufficiently keep pace with the CPU  in contrast to FLASH\/magnetic disk\/optical disc applied as mass storage. Direct addressability refers to a processor, such as a CPU or GPU, being able to send memory requests to the NVRAM as if it were standard DRAM (e.g., through standard memory store and load commands). Moreover, as discussed above and described in detail below, NVRAM  may be placed on a memory bus and may communicate directly with a memory controller that, in turn, communicates directly with the processor .","NVRAM  may be combined with other instruction and data storage technologies (e.g., DRAM) to form hybrid memories (also known as Co-locating PCM and DRAM; first level memory and second level memory; FLAM (FLASH and DRAM)). Note that at least some of the above technologies, including PCM\/PCMS may be used for mass storage instead of, or in addition to, system memory, and need not be random accessible, byte addressable or directly addressable by the processor when applied in this manner.","For convenience of explanation, most of the remainder of the application will refer to \u201cNVRAM\u201d or, more specifically, \u201cPCM,\u201d or \u201cPCMS\u201d as the technology selection for the non-volatile memory. As such, the terms NVRAM, PCM, and PCMS may be used interchangeably in the following discussion. However it should be realized, as discussed above, that different technologies may also be utilized.","2. Volatile Memory Overview","\u201cVolatile memory\u201d  is an intermediate level of memory configured in conjunction with NVRAM  that has lower read\/write access latency relative to NVRAM  and\/or more symmetric read\/write access latency (i.e., having read times which are roughly equivalent to write times). In some embodiments, the volatile memory  has significantly lower write latency than the NVRAM  but similar (e.g., slightly lower or equal) read latency; for instance the volatile memory  may be a volatile memory such as volatile random access memory (VRAM) and may comprise a DRAM or other high speed capacitor-based memory. Note, however, that the underlying principles of the invention are not limited to these specific memory types. Additionally, the volatile memory  may have a relative lower density and\/or may be more expensive to manufacture than the NVRAM .","In some embodiments, volatile memory  is configured between the NVRAM  and the internal processor caches. In some of the embodiments described below, volatile memory  is utilized to mask the performance and\/or usage limitations of the NVRAM  including, for example, read\/write latency limitations and memory degradation limitations. In these implementations, the combination of volatile memory  and NVRAM  operates at a performance level which approximates, is equivalent or exceeds a system which uses only DRAM as system memory.","In different embodiments, volatile memory  can be located on the processor die, located external to the processor die on a separate die located on the CPU package, located outside the CPU package with a high bandwidth link to the CPU package, for example, on a memory dual in-line memory module (DIMM), a riser\/mezzanine, or a computer motherboard). In , volatile memory  is shown being located external to the CPU package. The volatile memory  may be communicatively coupled with the CPU  using a single or multiple high bandwidth links, such as DDR or other transactional high bandwidth links. A communicative coupling of devices refers to being coupled through an electrical, optical, wireless, or other form of link or combination of links to allow information to be passed back and forth between the devices that are coupled to one another. In some embodiments, the coupling is direct and allows information to pass directly from the first device to the second and, potentially, vice versa. In other embodiments, the coupling is indirect and requires the information to pass through one or more additional devices that reside along the route the information takes while being transferred between the two communicatively coupled devices in question.","3. Hybrid Memory Code and Data Storage for Processors","According to many embodiments, a hybrid memory solution in a computer system combining DRAM and PCMS storage or another type of NVRAM may be utilized to access both the code and data sections of a software application being executed is disclosed. As mentioned above, although other forms of NVRAM may be applicable to these solutions, the technical specifications of PCMS make it a quality candidate technology for non-volatile memory\/storage. Thus, the examples shown will make use of PCMS memory, although in other embodiments, another form of NVRAM may be utilized.","In a computer system that includes an amount of PCMS memory\/storage. Software applications and an operating system running on the computer system may both take advantage of a PCMS device's fast read capability. The fast reads may allow software application and operating system to execute code directly from PCMS on the processor.","In many embodiments, the operating system running on the computer system may be aware of the PCMS storage and will execute the operating system binaries directly out of physical PCMS address space. This execution is different from other forms of non-volatile memory, such as mass storage solutions, which instead require loading code (binaries) into a volatile memory, such as DRAM, prior to executing the code.","The operating system will build an interface for the software application and any driver software running on the operating system. According to many embodiments, the application and\/or the driver will send requests to the operating system for buffers to store binary executable code that will not be modified during execution. The operating system then grants these buffers and provides pointers to them in the software application's and\/or driver's allocated memory address space. Because the binaries in these buffers are not modified, there is generally an explicit indication\/designation originated by the software, driver, and\/or the operating system to make the buffers unmodifiable.","The operating system running on the system may treat the PCMS storage as a physical DRAM and map portions of the files that make up the operating system and software application into a memory management unit (MMU). When in the MMU, these file locations can be translated and stored similar to translation lookaside buffer (TLB) entries and addressed as if they were standard DRAM memory locations. From an operating system's logical address space to a physical PCMS device address location there may be multiple page walks to first get from a logical address that the operating system utilizes, to a platform physical address (PPA) that the underlying general memory management hardware utilizes for main DRAM memory, and finally to a direct physical PCMS device address. There may be one or more address mapping tables  (also known as address indirection tables) to accomplish this. In many embodiments, the address mapping tables  are stored in DRAM (volatile memory ).","Apart from binary code storage in PCMS, there are other portions of software application, driver, and operating system information that may be stored adequately in physical PCMS space. Specifically, certain data (as opposed to code) sections of the software also may be storable in PCMS when that data is static or nearly static. Thus, in many embodiments there is at least a bit designation per data element that signifies whether the particular data element to be stored is or is not static. The static designated data elements may be stored in static (i.e., unmodifiable) buffers, whereas the non-static designated data elements may be stored in volatile (i.e. modifiable) buffers. This particular designation per buffer allows the OS to:\n\n",{"@attributes":{"id":"p-0058","num":"0061"},"figref":"FIG. 2"},"In  a DRAM memory space  (e.g., 4 GB of space) and an NVRAM memory space  (e.g., 64 GB of space) are present. There may be additional memory spaces, including a logical memory space in which the operating system controls, but those are not shown for sake of clarity. An operating system  is resident in DRAM memory space  and is being executed on the CPU . In many embodiments, driver software  is also resident in DRAM memory space  and is executing on the CPU  in conjunction with the operating system . At some point during operation, the operating system  loads a software application  into DRAM memory space . The load operation includes the operating system  reserving memory space for the software application . The reserved memory space includes space that is utilized to store the software application's binary executable code (\u201ccode\u201d) as well as space that is utilized to store any modifiable data (\u201cdata\u201d) the software application  uses to run.","As mentioned above, according to many embodiments, the code is generally static, as the binary files do not change during execution. On the other hand, data may change or it may not change, depending on a type of data. For example, static data (e.g., constants) will not change but volatile data (e.g., a stored variable that is recalculated based on continually changing input) does change. Thus, code and static data can be placed in a read-only section of memory, whereas volatile data would generally be placed in a read\/write section of memory. In many embodiments, the software application  may be given the opportunity to preset portions of data and code with a storage-type bit. For example, if a structure that is defined by the software application as volatile (meaning data in the structure is modifiable), the software application may expressly relay that by setting a \u201cvolatile\u201d bit for that structure. Then when the operating system  is allocating memory space to store the structure, it will see the \u201cvolatile\u201d bit as set and know to allocate the structure in the volatile data section of DRAM memory space. Alternatively, if a data variable is declared as a constant value, the software application may clear the \u201cvolatile\u201d bit to tell the operating system to allocate the data as static.","In a PCMS-based system, it is entirely plausible to store the code and static data in PCMS (i.e., NVRAM) memory space while still storing volatile data in DRAM memory. Thus, according to many embodiments, the operating system sets up an address mapping table  that stays resident in DRAM memory space . The operating system, while loading the software application , specifically stores the code (e.g., code 1 () and code 2 ()) and static data  into NVRAM memory space  while storing the volatile data  in DRAM memory space . Once loaded, the operating system creates a group of code pointers  in the address mapping table  to point to each block of code stored in the NVRAM memory space . The operating system  also creates a group of data pointers  in the address mapping table  to point to each block of data stored in the NVRAM memory space  as well as each block of data stored in the DRAM memory space .",{"@attributes":{"id":"p-0062","num":"0065"},"figref":"FIG. 3"},"The process begins with processing logic receiving a request to allocate memory for a portion of a software application (processing block ). The request may come in the form of an automated or user-initiated decision to execute the software application. Once it is requested to launch and execute the software application, processing logic receives code (such as a binary executable file) and data (such as a data file) elements of the software application to load into one or more forms of memory to have access during execution of the software application.","For a given portion of the software application to be allocated, processing logic then determines whether that portion comprises code or data (processing block ). If the portion comprises code, then processing logic allocates a segment of NVRAM memory space for storage of the code (processing block ). If the portion comprises data, then processing logic next determines whether the data is volatile (processing block ).","In many embodiments, there is a \u201cvolatile\u201d bit that may be set or cleared for any given portion of the data to inform the processing logic whether the data may change during execution of the software application. In other embodiments that are not shown, there is not a volatile bit available but instead processing logic loads all data originally into NVRAM memory space and whenever a portion of the data is re-written over, processing logic then determines that portion is volatile and moves that element of data from an NVRAM allocated storage location to a DRAM allocated storage location.","Returning to block , if the volatile bit is not set, then processing logic allocates a segment of NVRAM memory space for storage of the portion of the static data (processing block ). Alternatively, if the volatile bit is set, then processing logic allocates a segment of DRAM memory space for storage of the volatile data (processing block ).","In any event, once memory space is allocated (from any of processing blocks , , or ), then processing logic updates the address mapping table resident in DRAM with a pointer to the allocated memory segment in one of the three allocated sections of memory (i.e., the volatile data section, the static data section, or the code section).","Although application software is utilized as the example, this particular hybrid use of NVRAM and DRAM is not limited to application software. The operating system and driver binaries may also be similarly divided up and the static portions be placed in NVRAM while the volatile portions are placed in DRAM. This provides significant benefit in terms of reducing the amount of time required to resume from low power states\u2014portions of the operating system and\/or drivers would no longer need to be copied back into DRAM when resuming from a hibernate-to-disk state.","4. Hybrid Memory Code and Data Storage for Embedded Controllers","Many computing platforms have a number of embedded processors that are used for a wide range of applications. An embedded processor can also be referred to as a \u201cmicrocontroller.\u201d Examples of embedded processors include manageability engines (which manage a computer system's security and out-of-band communications) and graphics embedded controllers, among others. These embedded controllers use firmware during runtime as instructions to execute many of their core functionalities. This firmware is typically stored on the computer system's flash memory (e.g., BIOS) or mass storage drive (e.g., hard drive, solid state drive, etc.). At system boot, the firmware is generally loaded into an internal SRAM in the embedded controller for execution.","There are significant issues with storing the firmware externally on the system flash memory hard drive such as:\n\n","To address these limitations of embedded controllers, according to many embodiments, a PCMS-based storage is packaged with the embedded controller. The logic utilized to effectively replace system flash and\/or a hard drive with a localized portion of PCMS memory would include:\n\n",{"@attributes":{"id":"p-0072","num":"0084"},"figref":"FIG. 4"},"The computer system shown in  may be generally equivalent to the computer system described in , outside of changes in the I\/O subsystem . Thus, for detailed descriptions of other components, please refer to . Within the I\/O subsystem , there is an embedded controller  and an internal PCMS memory  present in . The internal PCMS  stores static information related to firmware that the embedded controller  executes. During boot, the embedded controller  may directly execute firmware code from a read only (R-O) code region  stored in the internal PCMS . Additionally, the internal PCMS  may also store other information , such as fixed (i.e., static) data, keys for security applications (e.g., digital rights management), as well as usage information to be saved for a later time (e.g., number of times a user watches a given movie on the computer system). This stored information  is data that is either entirely static or rarely updated and also may include data that requires non-volatility through power cycling the computer system.","Furthermore, in many embodiments, the embedded controller  has an internal SRAM  portion of memory for storage of local variables, a stack, and\/or other information that dynamically changes throughout the execution of the firmware. Thus, this information benefits from the fast write capabilities of the SRAM, as opposed to being limited to PCMS write speeds.","According to many embodiments, there is additionally a cryptographic verification (CV) hardware module  present in the I\/O subsystem . The CV module is able to utilize hardware security verification key technology to require any updates\/overwrites to any region of the stored firmware on the PCMS to be authenticated through any implemented form of security verification (e.g., public and private authentication modules using keys).",{"@attributes":{"id":"p-0076","num":"0088"},"figref":"FIG. 5"},"In , the embedded controller  has an internal SRAM memory space  that stores runtime data storage . The embedded controller  is additionally communicatively coupled to internal PCMS memory space , which stores a firmware code region  and other storage  that stores fixed\/static data, keys, and required non-volatile usage information.","In the following description, numerous specific details such as logic implementations, means to specify operands, resource partitioning\/sharing\/duplication implementations, types and interrelationships of system components, and logic partitioning\/integration choices are set forth in order to provide a more thorough understanding of the present invention. It will be appreciated, however, by one skilled in the art that the invention may be practiced without such specific details. In other instances, control structures, gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art, with the included descriptions, will be able to implement appropriate functionality without undue experimentation.","References in the specification to \u201cone embodiment,\u201d \u201can embodiment,\u201d \u201can example embodiment,\u201d etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to effect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.","In the following description and claims, the terms \u201ccoupled\u201d and \u201cconnected,\u201d along with their derivatives, may be used. It should be understood that these terms are not intended as synonyms for each other. \u201cCoupled\u201d is used to indicate that two or more elements, which may or may not be in direct physical or electrical contact with each other, co-operate or interact with each other. \u201cConnected\u201d is used to indicate the establishment of communication between two or more elements that are coupled with each other.","Embodiments of the invention may also be provided as a computer program product which may include a non-transitory machine-readable medium having stored thereon instructions which may be used to program a computer (or other electronic device) to perform a process. The non-transitory machine-readable medium may include, but is not limited to, floppy diskettes, optical disks, CD-ROMs, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, magnet or optical cards, propagation media or other type of media\/machine-readable medium suitable for storing electronic instructions. Embodiments of the invention may also be downloaded as a computer program product, wherein the program may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).","While the invention has been described in terms of several embodiments, those skilled in the art will recognize that the invention is not limited to the embodiments described, can be practiced with modification and alteration within the spirit and scope of the appended claims. The description is thus to be regarded as illustrative instead of limiting."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The following description and accompanying drawings are used to illustrate embodiments of the invention. In the drawings:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
