---
title: Multitier deduplication systems and methods
abstract: Multitier deduplication can reduce the amount of bandwidth and storage resources used during deduplication. In certain embodiments, the system can determine if a data block is stored in a first archive data storage. If so, the system can skip the data block. If not, the system can determine if the data block is stored or identified in a second archive data storage. In various implementations, the first archive data storage can be local to the system and the second archive data storage can be a global archive that may be remote from the system. The system can create a map of a plurality of backups stored at the first archive enabling the system to quickly check multiple archives. The multitier data deduplication can filter out inactive data blocks during or before performing the deduplication process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08898114&OS=08898114&RS=08898114
owner: Dell Software Inc.
number: 08898114
owner_city: Aliso Viejo
owner_country: US
publication_date: 20110825
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","I. Introduction","II. Example Backup System","III. Example Backup Process","IV. Example Block Mapping","V. Example Restore Process","VI. Example Deduplication System","VII. Example Deduplication Process","VIII. A Second Example Deduplication Process","IX. Terminology"],"p":["This application claims the benefit of priority under 35 U.S.C. \u00a7119(e) of U.S. Provisional Patent Application No. 61\/377,658, filed on Aug. 27, 2010, and entitled \u201cMULTITIER DEDUPLICATION SYSTEMS AND METHODS,\u201d the disclosure of which is hereby incorporated by reference in its entirety.","Many companies take advantage of virtualization solutions to consolidate several specialized physical servers and workstations into fewer servers running virtual machines. Each virtual machine can be configured with its own set of virtual hardware (e.g., processor, memory, ports, and the like) such that specialized services that each of the previous physical machines performed can be run in their native operating system. For example, a virtualization layer, or hypervisor, can allocate the computing resources of one or more host servers into one or more virtual machines and can further provide for isolation between such virtual machines. In such a manner, the virtual machine can be a representation of a physical machine by software.","In many virtual machine implementations, each virtual machine is associated with at least one virtual machine disk or image located in one or more files in a data store. The virtual machine image can include files associated with a file system of a guest operating system. The virtual machine image can be copied, moved, backed up, or the like, similar to a general data file.","This disclosure describes examples of systems and methods for deduplicating a backup archive. In certain embodiments, a system can access one or more backup block directories associated with one or more backup archives at an archive data store. The one or more block directories can include fingerprints of data blocks associated with the one more archives. Further, at least one of the one or more archives is associated with a data store. The system can create a composite block map based on the one or more block directories. This composite block map can include fingerprints of each data block stored at the archive data store. The system can access one or more data blocks from the data store. For each of the one or more data blocks, the system can create a fingerprint. Further, the system can determine whether the fingerprint exists in the composite block map. In response to determining that the fingerprint does not exist in the composite block map, the system can determine whether the fingerprint exists in a global deduplication data store. In response to determining that the fingerprint does not exist in the global deduplication data store, the system can back up the data block as part of a target archive at the archive data store. Further, the system can store the fingerprint associated with the data block storage at a target block directory associated with the target archive.","In certain embodiments, if the system determines that the fingerprint exists in the composite block map, the system can avoid backing up the data block associated with the fingerprint. As a result, in certain embodiments, the system can use less resources deduplicating a backup archive by reducing the number of queries to the global deduplication data store.","For purposes of summarizing the disclosure, certain aspects, advantages and novel features of the inventions have been described herein. It is to be understood that not necessarily all such advantages can be achieved in accordance with any particular embodiment of the inventions disclosed herein. Thus, the inventions disclosed herein can be embodied or carried out in a manner that achieves or optimizes one advantage or group of advantages as taught herein without necessarily achieving other advantages as can be taught or suggested herein.","Virtual machine images often contain a large percentage of white space, which includes empty blocks (zero blocks). A backup of an entire virtual machine image therefore stores the white space together with any active and deleted blocks, wasting storage space and backup time. Some solutions determine which blocks of a virtual machine image are zero blocks and then back up only the active and deleted blocks. This backup approach is called zero handling. A drawback of zero handling is that a full scan of the blocks is performed to determine which blocks are the zero blocks. The full scan can take a significant amount of time. Another drawback of this approach is that zero handling fails to account for blocks of a file system that are marked as deleted. Thus, even when accounting for zero blocks, a backup system can still back up a significant amount of irrelevant deleted data, which still results in wasted storage space and backup time.","This disclosure describes systems and methods for programmatically determining the status of blocks in a virtual machine image. In certain embodiments, the system can determine which blocks are active, deleted, zero, or a combination of the same. In certain embodiments, the system advantageously determines block status without scanning some or all the blocks in a virtual machine image. Instead, the system can access metadata in a file system of a virtual machine image to determine the block status. When backing up the virtual machine image, the system can back up active blocks while skipping inactive blocks, including deleted and\/or zero blocks. As a result, the system can take less time to back up a virtual machine image, and the resulting backup file or files can consume less storage space.","To prevent data loss in physical and virtual computing systems, organizations generally perform frequent backups. Backups can include full backups, differential backups, and incremental backups. When full backups are performed, all or substantially all of the data in a data store can be archived. A differential backup can be a cumulative backup of all or substantially all changes made since the last full backup. With incremental backups, a first full backup can be performed, followed by a series of one or more incremental backups. Incremental backups can include all or substantially all changes made since the last backup of any type.","Backing up data can consume significant storage resources as well as network bandwidth as data is transferred from a host to a backup server. To reduce the storage and network burdens of backup operations, deduplication is often performed on backup sets. In general, deduplication can include a process of detecting and\/or removing duplicate data. Deduplication can run before, during, or after backup operations are performed. The first time a deduplication system sees a file or a chunk of a file, that data element can be identified, for example, by hashing the data. The hashed data may then be stored in an index. As each new chunk of data gets hashed, it can be compared with the existing hashes in the index. If the hash is already in the index, this means that the chunk of data is a duplicate and does not need to be stored again. If the hash is not already in the index, the hash of the new data can be added to the index. In this manner, duplicate files or portions of files may not be backed up, thereby reducing backup storage and network bandwidth.","A problem with some existing deduplication systems is that the database used to maintain the hash index can be computationally costly to access. Frequent and large backups can result in many hash entries being added to the database, slowing down access speeds. Such a database may also often be accessible over a network link, and access time can therefore be limited by the network bandwidth. Further, some relational database management systems are not optimized for the tasks of frequent rapid lookups of the hash data.","This disclosure describes examples of systems and methods for multitier deduplication which can reduce the use of bandwidth and storage resources. In certain embodiments, the system can determine if a data block is backed up or stored in a first archive data storage. For example, the first archive data storage may be local to the system. If the data block is backed up or stored in the first archive data storage, the system can skip the data block. If the system determines that the data block is not backed up in the first archive data storage, the system can determine if the data block is stored or identified in a second archive data storage. In various implementations, the second archive data storage may be local or remote to the system, and the second archive data storage may be a global archive. By first checking the first (e.g., local) archive data storage, the system can reduce the frequency of accesses to the second (e.g., remote, global) archive, which can be slower and more resource intensive to access. In certain embodiments, the system can create a map of a plurality of incremental and full backups stored at the first archive data storage. This can enable the system to quickly check multiple archives located at the first archive data storage. In certain embodiments, the multitier data deduplication can filter out inactive data blocks before performing the deduplication process. Advantageously, in certain embodiments, filtering out inactive data blocks speeds up the deduplication process by reducing the number of data blocks to check.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","100","100"]},"As shown in , the backup system  includes a host server  in communication with a data store . In certain embodiments, the host server  includes one or more computing devices configured to host one or more virtual machines  executing on top of a hypervisor . In certain embodiments, the hypervisor  decouples the physical hardware of the host server  from the operating system(s) of the virtual machine(s) . Such abstraction allows, for example, for multiple virtual machines  with different operating systems and applications to run in isolation or substantially in isolation on the same physical machine.","The hypervisor  includes a virtualization platform that allows for multiple operating systems to run on a host computer at the same time. For instance, the hypervisor  can include a thin piece of software that runs directly on top of the hardware platform of the host server  and that virtualizes resources of the machine (e.g., a native or \u201cbare-metal\u201d hypervisor). In such embodiments, the virtual machine(s)  can run, with their respective operating systems, on the hypervisor  without the need for a host operating system. Examples of such bare-metal hypervisors can include, but are not limited to, ESX SERVER by VMware, Inc. (Palo Alto, Calif.), XEN and XENSERVER by Citrix Systems, Inc. (Fort Lauderdale, Fla.), ORACLE VM by Oracle Corporation (Redwood City, Calif.), HYPER-V by Microsoft Corporation (Redmond, Wash.), VIRTUOZZO by Parallels, Inc. (Switzerland), or the like.","In yet other embodiments, the host server  can include a hosted architecture in which the hypervisor  runs within a host operating system environment. In such embodiments, the hypervisor  can rely on the host operating system for device support and\/or physical resource management. Examples of such hosted hypervisors can include, but are not limited to, VMWARE WORKSTATION and VMWARE SERVER by VMware, Inc., VIRTUAL SERVER by Microsoft Corporation, PARALLELS WORKSTATION by Parallels, Inc., or the like.","In certain embodiments, each virtual machine  includes a guest operating system and associated applications. In such embodiments, the virtual machine  accesses the resources (e.g., privileged resources) of the host server  through the hypervisor . At least some of the machines can also include a backup service  in certain embodiments, which can assist with backup operations, as described below.","The host server  communicates with the data store  to access data stored in one or more virtual machine files. For instance, the data store  can include one or more virtual machine file systems  that maintain virtual disk files or virtual machine images for some or all of the virtual machines  on the host server . In certain embodiments, the virtual machine file system  includes a VMWARE VMFS cluster file system provided by VMware, Inc. In such embodiments, the VMFS cluster file system enables multiple host servers (e.g., with installations of ESX server) to have concurrent access to the same virtual machine storage and provides on-disk distributed locking to ensure that the same virtual machine is not powered on by multiple servers at the same time. In other embodiments, the virtual machine file system  is stored on the host server  instead of in a separate data store.","The data store  can include any physical or logical storage for holding virtual machine files. The data store  can exist on a physical storage resource, including one or more of the following: local disks (e.g., local small computer system interface (SCSI) disks of the host server ), a disk array, a storage area network (SAN) (e.g., fiber channel), an iSCSI disk area, network attached storage (NAS) arrays, network file system (NFS), or the like. In certain embodiments, the virtual machine(s)  uses a virtual disk file  or virtual machine image residing on the data store  to store its operating system, program files, and other data associated with its activities.","The backup system  further includes a management server  in communication with the host server  over a network . In certain embodiments, the management server  includes one or more computing devices. The management server  can coordinate the backup operations of the virtual machine disk files  through the host server . In one embodiment, the management server  causes the backup service  of the virtual machine  to perform certain backup operations. For example, the backup service  can perform shadow copy or snapshot operations, such as are described in U.S. application Ser. No. 12\/182,364, filed Jul. 30, 2008, titled \u201cSystems and Methods for Performing Backup Operations of a Virtual Machine,\u201d the disclosure of which is hereby incorporated by reference in its entirety. In addition, the backup system  can include additional features described in U.S. application Ser. No. 12\/502,052, filed Jul. 13, 2009, titled \u201cBackup Systems and Methods for a Virtual Computing Environment,\u201d the disclosure of which is hereby incorporated by reference in its entirety.","Advantageously, in certain embodiments, the management server  analyzes the virtual disk files  to identify the status of portions of the virtual disk files  to determine whether these portions include active, deleted, and\/or zero data. The management server  can identify the status of these disk file portions efficiently by accessing metadata within the virtual disk file . The management server  can then initiate a backup of the active portions of the virtual disk file .","The management server  analyzes the virtual disk file  in certain embodiments outside of the virtual machine , for example, outside of a guest operating system of the virtual machine . The management server  can therefore reduce the impact of backup operations on the virtual machine . Alternatively, in certain embodiments, a component operating within the virtual machine  can perform this analysis, such as an application executing in the virtual machine . For instance, the management server  can inject a lightweight binary file into the virtual machine  executing on the host. On WINDOWS systems, for example, the management server  can inject the binary using Windows Management Instrumentation (WMI) features. The binary file can then analyze the virtual disk file . Additional features of the management server  are described in greater detail below with respect to .","As further illustrated in , the backup system  includes a backup, or target, server  for storing backup files, such as a backup of one or more of the virtual disk files . As shown, the backup server  is coupled to the network  and can directly communicate with the management server . The management server  can cause backups of virtual disk files  to be stored in the backup server .","As shown, the network  provides a wired and\/or wireless communication medium between the host server , the management server  and\/or the backup server . In certain embodiments, the network  includes a local area network (LAN). In yet other embodiments, the network includes one or more of the following: internet, intranet, wide area network (WAN), public network, combinations of the same or the like.","Although the backup system  has been described with reference to particular arrangements, other embodiments can comprise more or fewer components. For example, in certain embodiments, the backup system  can function without the backup server , and backup files can be stored to the data store  or a local storage device directly coupled to the management server  or host system .","In yet other embodiments, the host server  can comprise a plurality of servers in a clustered arrangement such that the computing and memory resources of the clustered servers are shared by one or more virtual machines . Moreover, in certain embodiments, the backup tool maintained by the management server  can instead reside on the host server  and\/or the backup server .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","100","200"]},"In the depicted embodiment, the management server  includes a backup module , a mapping module , and a user interface module . Each of these modules can be implemented in hardware and\/or software. In certain embodiments, the backup module  coordinates backup operations of virtual disk files  stored in the data store . The backup module  can perform, for example, full backups, differential backups, incremental backups, or the like. The backup module  can coordinate with the backup service  within the virtual machine  to perform virtual disk snapshots in the manner described in U.S. application Ser. No. 12\/182,364, referred to above. However, in some embodiments, the backup module  performs backup operations without coordinating with a backup service inside the virtual machine .","The mapping module  can determine status information about a virtual disk file . In the context of VMWARE systems, for instance, the mapping module  can access a .VMDK virtual disk file . In one embodiment, the backup module  invokes the mapping module  prior to backing up the virtual disk file . Status information determined by the mapping module  can include information on which portions of the virtual disk file  include active or inactive data. Active data can include data that is currently used by the virtual machine . For example, active data can include non-deleted and non-zero data. In contrast, inactive data can include deleted data or zero (empty) data. Some guest operating systems merely mark data as deleted when a user deletes the data, rather than actually erasing the data from storage. Thus, the deleted data can include actual data that has been marked as deleted.","The mapping module  can determine the status information about the virtual disk file  by accessing a guest operating system file system  stored within the file . The file system  includes files , such as guest operating system files, application files, user documents, and so on. Metadata  in the file system  describes the logical structure of the files , including the locations of the files in a logical hierarchy such as a directory tree. In addition, the metadata  can specify the physical structure of the files , such as the locations of the files  in the virtual disk file , the size of the files , and so on.","Different guest operating systems can include different file systems. For example, many WINDOWS operating systems use the NTFS file system, whereas LINUX systems use a different file system. While file systems from different operating systems are implemented differently, most file systems share the common characteristic of using metadata to describe the structure of the files. In certain embodiments, the mapping module  can determine status information from many different types of files systems .","Advantageously, in certain embodiments, the mapping module  accesses the metadata  to determine the status information. Accessing the metadata  can be faster than scanning (or reading) some or all of the file system  to determine status information because the metadata  can include a summary or description of the status information. In one embodiment, the metadata  for a WINDOWS-based NTFS file system  can include a header file called a Master File Table (MFT). The MFT can be organized as a database table or tables, with each row in the table or tables representing one file. Data about the files  stored in the MFT can include information such as file permissions, ownership, size, location, and status of data blocks of the file. The mapping module  can therefore access the MFT to obtain the status information for portions of the file system. In contrast, the metadata  in many LINUX and UNIX-based systems include an inode or vnode for some or all of the files. The inodes (or vnodes) are data structures that can include file permissions, ownership, size, location, and status of data blocks of the file. Thus, in LINUX or UNIX-based systems, the mapping module  can access the inodes or vnodes to obtain status information for portions of the file system.","Different implementations of the mapping module  can analyze the metadata  at different levels of granularity. In one implementation, the mapping module  determines the status of storage blocks of the file system  from the metadata . In another embodiment, the mapping module  determines the status of the files  of the file system . In yet another embodiment, the mapping module  determines the status of directories of the file system . For ease of illustration, the remainder of this specification will refer to determining the status of blocks in the file system . However, it should be understood that the various features described herein can apply to any type of metadata mapped by the mapping module .","Advantageously, in certain embodiments, the mapping module  can store the status information about blocks (or other storage units) in a virtual disk map  on the backup server  or on another device (e.g., in a memory). The virtual disk map  can be a data structure or the like that includes some indication of the status of some or all of the blocks in the file system . The virtual disk map  can advantageously consume far less storage than the data in the virtual disk file  because the map  represents the data but does not include the actual data. For example, the virtual disk map  can be a bitmap, a bytemap, or some other data structure. Various features of the virtual disk map  will be described in greater detail below with respect to .","When backing up the virtual disk file , the backup module  can consult the virtual disk map  to determine which blocks of the file system  are active or inactive. The backup module  can then save the active blocks in a backup virtual disk file . An embodiment of a backup process used by the backup module  is described below with respect to .","The user interface module  of the management server  can provide functionality for users to control settings of the backup module  and\/or the mapping module . For instance, the user interface module  can provide a scheduling user interface that allows an administrator to schedule backups of the virtual disk file . In one embodiment, the user interface module  also provides an interface to enable or disable the functions of the mapping module . An administrator may wish to disable the mapping module  because in some embodiments undelete operations cannot be performed on the backup virtual disk file  when deleted blocks are not saved in the file . The user interface module  can also allow an administrator to enable some functionality of the mapping module  while disabling others. For example, a user interface might allow an administrator to enable zero block removal to reduce backup size while disabling deleted block removal to allow for undelete operations.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":["300","300","100","200","300","120","222","224","120","300"]},"At state , a map of active and\/or inactive blocks of a guest operating system file system are created. The map created can be the virtual disk map  described above with respect to  and can be created by the mapping module . The map can include an indication of which blocks are active, which blocks are inactive, or both. Further, inactive blocks can be broken down to include deleted blocks and zero blocks, which can be separately indicated in the map. The map is stored in computer storage at state , for example, by the mapping module . The mapping module  can persist the map or can store the map in memory (see, e.g., ).","For some or all of the blocks in the file system, at state , the map is accessed to determine whether the block or blocks are active or inactive. In one embodiment, state  is implemented by the backup module  at the start of a backup operation. At decision state , it is determined whether the block is active or inactive. The backup module  can access a value for the block stored in the map, for instance, which indicates whether the block is active or inactive. If the block is active, the block is backed up at state . Otherwise, the block is skipped (not backed up) at state . In another embodiment, the active blocks are backed up at one time, for example, as one backup operation, instead of backing up individual active blocks.","To illustrate the potential benefits of the backup process , an example virtual machine image might include 70 GB of zero blocks, 20 GB of active blocks, and 10 GB of deleted blocks. A traditional backup process without zero or deleted block handling would create a backup file of 70+20+10=100 GB (or somewhat smaller with file compression). With zero handling, the backup file would be 20+10=30 GB (or smaller with compression). However, applying the backup process , the backup file size would be 20 GB because both zeros and deleted blocks are skipped by the backup process . This file can also be compressed to further reduce storage consumption.","In addition, the backup process  can still provide benefits even if the example above were changed to include 70 GB of zero blocks, 20 GB of active blocks, and 0 GB of deleted blocks. While the size of the backup file would be the same or approximately the same whether using zero handling or the process , the speed of the backup process  can be greater than a zero handling process. The speed increase can be due to the process  determining which blocks are zeros more quickly than a traditional zero handling process, which scans all the blocks to determine where the zero blocks are. Techniques for rapidly detecting zeros, deleted blocks, and active blocks are described below with respect to .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 4","b":["400","400","100","200","400","120","224","120","224"]},"At state , a virtual disk file is accessed, and file system data is accessed from the virtual disk file at state . In one embodiment, the mapping module  directly accesses the metadata in the virtual disk file. For example, the mapping module  can access a Master Boot Record (MBR) in the virtual disk file, which is typically in the same location for most virtual disk files (such as within the first several bytes of the file). The mapping module  can determine the location of the file system data from the MBR. For NTFS file systems, for example, the MFT metadata file is at a certain offset in the MBR. Thus, once the mapping module  has located the file system, the mapping module  can access the MFT at the expected location.","In another embodiment, the mapping module  indirectly obtains access to the virtual disk file by calling an application programming interface (API) provided, for example, by a virtual machine vendor. For example, in VMWARE virtual machine environments, such an API exists for accessing virtual disk file data. The API can further include functionality for accessing the contents of the virtual disk file, including the file system metadata. This indirect approach to accessing metadata can be useful when the mapping module  is implemented in a different file system than the virtual disk file. For instance, if the mapping module  is implemented in a WINDOWS file system but the virtual disk file is formatted for the LINUX file system, an API can allow the mapping module  to read the LINUX-formatted virtual disk file.","At state , for a storage block in the metadata, it is determined what type of data is represented by the block. As described above, the mapping module  can determine whether a block contains active, deleted, or zero data. At decision state , it is determined whether the block is active. In one embodiment, an active block is any block that contains a portion of active data, however small. Many file systems use a standard block size for partitioning data storage, such as 4 kB. A file system might mark a 4 kB (or other size) block as active even if that active data in the block includes a tiny fraction of the full block size. Thus, even though the backup processes described herein can avoid backing up a substantial amount of deleted data, some deleted data may still be saved in a backup process.","In some embodiments, the mapping module  maps a plurality of file system blocks to a single status bit, byte, or the like. For instance, instead of mapping each 4 kB block in a file system to a single status bit (e.g., representing active or deleted), the mapping module  can map 256 file system blocks to a single status bit if any of the 256 blocks have active data. If each of the file system blocks is 4 kB large, the mapping module  can therefore equivalently map 1 MB of file system data (256\u00d74 kB) to a single status bit. In another embodiment, the mapping module  can map 64 file system blocks to a single status bit if any of the 64 blocks have active data. If each of the file system blocks is 4 kB large, the mapping module  can then equivalently map 256 kB of file system data (64\u00d74 kB) to a single status bit. Other mapping sizes can be chosen.","In one embodiment, the mapping size is chosen to optimize or otherwise improve the performance of compression algorithms employed by the backup module  when compressing the backup virtual disk file . Some compression algorithms, when used as an in-line process (e.g., in-line with a backup process) take less processing time when using smaller mapping sizes, whereas others take less time when using larger mapping sizes. Using a larger mapping size can result in storing more deleted data at the possible beneficial tradeoff of reducing compression processing time. The mapping module  can automatically adjust the mapping size used based at least partly on the compression algorithm selected.","If the block is not active, an entry is created in a map to indicate that the block is not active at state . Otherwise, it is further determined at decision state  whether the block is part of an active temporary file. If the block is part of an active temporary file, the block is active because it does not contain deleted data. However, to save backup storage space, in certain embodiments, an entry is created in a map to indicate that the temporary file block is not active at state . Examples of temporary files include virtual memory files (e.g., pagefile.sys in WINDOWS), system sleep or hibernate state files (such as hiberfile.sys in WINDOWS), temporary Internet files, and the like. An option to skip (e.g., mark as inactive) or to not skip temporary files can be provided by the user interface module  described above.","If the block is not part of a temporary file, an entry is created in the map indicating that the block is active at state . It is then determined whether additional blocks are left in the metadata to analyze at decision state . If so, the block mapping process  loops back to state . Otherwise, the block mapping process  ends.","The mapping process  can be used in conjunction with other systems that provide zero handling. For instance, the mapping process  can be applied as a filter to the output of a zero handling system. An example zero handling system provided by VMWARE is the Change Block Tracking (CBT) system. In one embodiment, the backup module  can use the CBT system to obtain information about zero blocks. The CBT can perform a full file system scan to identify and map the zero blocks. Thereafter, the mapping module  can apply the process  to identify deleted blocks in the machine image. The mapping module  can modify the map provided by the CBT system to indicate the locations of deleted blocks.","It should be noted that in certain embodiments, the mapping module  stores the map in memory instead of persisting the map to disk storage. In another embodiment, the mapping module  does not create a map data structure. Instead, the mapping module  can determine whether a block is active, deleted, and\/or zero and provide an indication of this determination to the backup module  (e.g., through memory). The backup module  can then back up the referenced block. The mapping module  can then examine the next block, followed by the backup module  backing up the next block, and so on. Thus, the determination of active, deleted, and\/or zero blocks can be performed in-line with backup operations.","Moreover, in certain embodiments, the mapping module  can map the virtual disk file  from outside of the virtual machine , for example, outside of a guest operating system of the virtual machine . The mapping module  can therefore reduce the impact of mapping operations on the virtual machine . The mapping module  and\/or the backup module  can also facilitate obtaining a more complete picture of the virtual disk file  because the mapping module  and\/or the backup module  can execute outside of the virtual machine. In addition, in some embodiments, the backup module  performs backup operations from outside of the virtual machine . In other embodiments, the mapping module  is a process running in the virtual machine and therefore maps the file system from within the virtual machine . In one such embodiment, the mapping module  can access an operating system API to determine the location of the metadata and access the metadata. The backup module  can also be a process running in the virtual machine  (e.g., as a volume shadow copy service). In another embodiment, the mapping module  can run inside of the virtual machine  while the backup module  runs outside, or vice versa.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 5","FIG. 4"],"b":["500","400","510","512","512"]},"Some or all of the blocks  can be mapped by the block mapping process  to a corresponding unit  of a map . In the depicted embodiment, the map  is a bitmap, and each unit  of the map represents one bit of storage. Thus, the block mapping process  can map the file system blocks  to bit units  (\u201cbits \u201d) in the map . As each unit  is one bit large in some embodiments, the map  can consume far less memory than the file system  and therefore can be an efficient way to store block status information. In certain embodiments, the map  can also be compressed to further reduce its storage impact.","In the depicted embodiment, the bits  in the map  include a \u20181\u2019 to represent active blocks  and a \u20180\u2019 to represent inactive blocks, including both deleted and zero blocks . Of course, the roles of the \u20181\u2019 and \u20180\u2019 characters can be reversed or other symbols can be used to represent active and inactive blocks. In another embodiment, a third symbol can be used to distinguish deleted and zero blocks . The bits  can be packed into bytes or octets so as to be addressable in most storage systems. In other embodiments, a single byte or other unit of storage can be used to represent each block .","Data structures other than maps can be used to store block  status information. For example, database tables, lists, arrays, or other structures can be used to store status information. Many other storage options will be apparent from this disclosure.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 6","b":["600","300","400","600","100","200","600","120","222","120","222","244","224","242"]},"At state , zeros are written to blocks in a restore file to provide a clean file when restoring a virtual machine image. Advantageously, in certain embodiments, these zeros can be written at disk subsystem speeds and can be faster than restoring zero blocks over a network.","A map of active and inactive blocks is accessed at state , for example, from the backup server . Active blocks are identified in the map at state . The active blocks are then restored by overwriting the zero blocks in the proper locations at state . In certain embodiments, state  can be omitted from the restore process .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 7","FIGS. 1 and 2"],"b":["700","700","700","700","100","200"]},"As shown in , the deduplication system  can include a host server  in communication with a data store . The host server  can be used for any purpose and might be, for example, a web server, an application server, a database server, or the like. The host server  can also implement one or more virtual machines. In some embodiments, the host server  can include the host server , and some or all of the previously described embodiments with respect to the host server  may apply to the host server .","The data store  can be the data store that is to be backed up in this example. In certain embodiments, the host server  may include the data store . Alternatively, the data store  may be separate from the host server . In some embodiments, the data store  may include the data store , and some or all of the previously described embodiments with respect to the data store  may apply to the data store .","A backup server  can communicate with the host server  over a network  to perform backups of the data store. In some embodiments, the backup server  can include any system for backing up the data store  of the host server . Further, the backup server  can include any system that can deduplicate data either as a separate process or as part of the backup process. In some embodiments, the backup server  may include the backup server , and some or all of the previously described embodiments with respect to the backup server  may apply to the backup server . Further, in certain embodiments, the backup server  may include a management server (not shown), such as the management server , and some or all of the previously described embodiments with respect to the management server  may apply to the backup server .","A backup module  on the backup server  can perform the actual backups of the data store, saving backup sets in data storage . While the backup module  may perform any type of backup, full and incremental backup sets are shown in the depicted embodiment. In particular, the example data storage  shown includes a full backup archive  and two incremental backup archives  and . Many more backup datasets or archives may be included in an actual implementation, and more than one data storage  may be used.","The data storage  can include any type of storage system for storing backups of a data store . In some embodiments, the backup server  includes the data storage . Alternatively, the data storage  may be part of a separate system. Generally, the data store  and the data storage  are separate. However, in certain embodiments, the data storage  and the data store  may be part of a single system. For example, the data store  and the data storage  may be separate partitions, or separate storage devices that are included in a single system.","In particular embodiments, when creating backup files, the backup module  can identify blocks associated with data that has changed by, for example, comparing data in the data store  with data in one or more previous incremental or full backups. As a second example, the backup module  may identify changed blocks by looking at metadata that identifies changed data associated with the blocks. The backup module  can save these changed blocks as a new incremental backup.","In certain embodiments, the backup module  creates a fingerprint of each of the blocks in the incremental backup. Alternatively, the deduplicator  may create the fingerprints. This fingerprint can include any identifier that uniquely identifies the blocks in the incremental backup. For example, the fingerprint can be a checksum or the output of a hash function, such as MD5, SHA-512, or the like. In some embodiments, the backup module  saves the fingerprints in a block directory or a hash map in the incremental backup archive. This block directory can be a single directory for the entire data storage  or may be a set of block directories. For example, there may be one block directory for each full archive and one block directory for each incremental archive. As a second example, there may be a single block directory for the incremental archives combined and a single one for each full archive. In the depicted embodiment of , the full archive  and the incremental archives  and  each include a block directory , , and  respectively.","The backup server  can also include a deduplicator  and a deduplication preprocessor . The deduplicator  can deduplicate files or blocks of data, or portions of files or blocks of data to save storage space at, for example, the data storage . In general, deduplication can include identifying unchanged files or blocks of data that are stored in a previous backup, or elsewhere in the backup system , such as in a global deduplication data store , and removing or not storing the files or blocks of data in a current incremental archive or full archive. In certain embodiments, because the system  may be used to backup multiple computing systems, it is possible for a data block to not exist in a full archive of data store , but to exist in the global deduplication data store . For example, a data block associated with a file received by the host server  at some time after the most recent archive may be unlikely to be in the data storage ; however, the data block may exist in the global deduplication data store . In certain embodiments, by not storing previously stored files or blocks of data, storage space is saved on the data storage  and\/or the global deduplication data store .","In certain embodiments, deduplication can be performed in-line with an incremental backup process to save processing resources. Alternatively, deduplication can be performed before (e.g., pre-process deduplication) or after incremental backups are created (e.g., post-process deduplication). When deduplicating, the deduplicator  can generate a fingerprint, such as a checksum or hash, of the files or file portions (such as, e.g., blocks) in the data store .","In a number of embodiments, the deduplicator  can query a global deduplication data store  to determine whether a fingerprint exists in the global deduplication data store . The global deduplication data store  can include any storage system capable of storing a set of blocks and a set of associated fingerprints for one or more computing systems (e.g. the computing systems  and the data store ), virtual machines, data stores, or the like. In certain embodiments, the global deduplication data store  stores a set of fingerprints for one or more data blocks that may be stored elsewhere. The global deduplication data store  may also include links to and\/or addresses for locating the stored data blocks. In some embodiments, the global deduplication data store  may store the data blocks and the deduplicator  can generate a fingerprint for the stored data blocks when determining whether a particular data block exists at the global deduplication data store. In certain implementations, the global deduplication data store  is remote from the backup server  and may be accessed via the network . In other implementations, the global deduplication data store  can be local to the backup server .","The computing systems  can include any number and any type of computing systems. For example, the computing systems  can include additional host servers configured similarly to the host server , or configured differently. As a second example, the computing systems  can include a number of networked client systems, additional backup servers, and file servers, to name a few. Further, each of the computing systems  may be associated with one or more data stores.","In certain embodiments, the computing systems , as well as the remaining systems illustrated in , are associated with a single organization. Alternatively, some or all of the computing systems  may be associated with a different organization than the remaining systems illustrated in . For example, the backup server , the data storage , and the global deduplication data store  may be part of a cloud storage service.","If the deduplicator  determines that a fingerprint associated with a specific block exists in the global deduplication data store , the deduplicator  can mark the block with a placeholder instead of replicating the block in the new incremental backup archive. If the fingerprint is not in the global deduplication data store , the deduplicator can store the fingerprint in the global deduplication data store  and store the block in the new incremental backup archive.","Accessing the global deduplication store  can, in certain embodiments, be a computationally expensive process. This can particularly be the case when the global deduplication store  is shared among a large number of computing systems. Advantageously, in certain embodiments, the deduplication preprocessor  can reduce the number of queries made by the deduplicator  to the global deduplication data store . In one embodiment, the deduplication preprocessor  accesses the block directory of the previous incremental backup before the deduplicator  accesses the global deduplication data store . Accessing the block directory first allows the deduplication preprocessor  to determine whether a fingerprint for a particular block exists locally in the incremental archive. If the fingerprint exists for a particular block, in certain embodiments the deduplicator  can avoid making a query to the global deduplication data store  for that block, which may be relatively expensive in terms of computational or network resources.","In some embodiments, the deduplicator  can include the deduplication preprocessor  and\/or the functionality of the deduplication preprocessor .","In some implementations, the backup server  can include a deduplication module (not shown) that can include the deduplication preprocessor  and\/or the deduplicator , and\/or the functionality of the deduplication preprocessor  and\/or the deduplicator .","In certain embodiments, the deduplication preprocessor  may load the one or more block directories from the data storage  in memory associated with the backup server . Accesses to the block directory may therefore be significantly faster than queries through the network  to the global deduplication data store . Further, by accessing the block directory in addition to querying the global deduplication data store  when fingerprints are not present in the block directory, the system  performs what may be termed multitier or hybrid deduplication in various cases.","In certain embodiments, a difference between block-level incremental backups and block-level deduplication, as performed by the multitier deduplication system, is the scope of the block comparison. With block-level incremental backups, the system may compare blocks from a single source. In contrast, with block-level deduplication, the system can compare blocks from some or all previously backed-up data from one or more data stores and\/or computing systems, storing unique blocks in the data storage  repository.","In a number of embodiments, the data blocks used in deduplication may differ in size from a file. Further, in certain embodiments, the size of a block used in deduplication may vary within a discrete range of block sizes. For example, the block sizes used by the deduplicator  may be selected from six, ten, or N available block sizes. The deduplicator  may select the block size to use based on any number of characteristics associated with a file or data to be backed up. These characteristics can include, for example, the size of the file, the frequency with which the file is modified, and\/or the frequency with which a portion of a file is modified. In certain embodiments, the deduplicator  can select a block size, based at least in part on the above characteristics, to increase the frequency that a block may be shared among multiple files thereby decreasing the amount of storage space required to backup computing systems and data stores associated with the system .","In certain embodiments, other techniques can be used to reduce the amount of data processed by the deduplicator . For instance, the deduplication preprocessor  can use Change Block Tracking technology, provided by VMWARE, to identify zero blocks in the data store. The deduplicator  can skip these blocks, avoiding sending queries to the global deduplication data store . Similarly, the deduplication preprocessor  can perform active block mapping as has been previously described above to identify inactive blocks in the data store . The deduplicator  can skip the inactive blocks to further reduce queries to the global deduplication data store . Examples of active block mapping usable with embodiments of the system  are described in U.S. application Ser. No. 12\/762,162, filed Apr. 16, 2010, titled \u201cBlock Status Mapping System for Reducing Virtual Machine Backup Storage,\u201d which is incorporated by reference in its entirety herein and forms a part of this specification.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 8","b":["800","800","800","800","800"]},"The process  can be implemented by the systems , , or  described above. For example, the process  can be implemented by the backup server , or more specifically, the deduplicator  and\/or the deduplication preprocessor  of the backup server . As a second example, the process  can be implemented by the management server . To simplify discussion, and not to limit the disclosure, the process  will be described as being performed by the backup server  with respect to the data store .","At state , the backup server , for example, can perform active block filtering on a data store  associated with the host server . The active block filtering can include identifying blocks that are active or inactive and skipping any blocks that are inactive during execution of the remainder of the process . Examples of the process of mapping active and inactive blocks and selecting blocks to process further are described above with respect to  and . In certain embodiments, state  is optional.","At state , the backup server  can perform change block filtering using, for example, Change Block Tracking technology to identify blocks that have changed since a previous backup. In certain embodiments, state  is optional. In a number of embodiments, any type of filtering that can reduce the number of data blocks to be examined for backup and\/or deduplication can be performed as part of state  or .","At state , the backup server  can create a composite block map for a backup archive, such as the data storage , associated with the data store . The composite block can include fingerprints of each data block stored at the data storage . As previously described, these fingerprints may include, for example, a checksum or a hash of the data block. The composite block map can be based at least in part on the block directories associated with one or more archives stored at the data storage . In certain embodiments, to create the composite block map, the backup server  accesses the block directory of the most recent archive (e.g. incremental archive ) and creates a map based on the block directory contents. The backup server  can access each previous archive to add the contents of the block directory associated with each archive to the map. Although described as a map, in certain embodiments, the composite block map can include any type of data structure that can store the relationship between fingerprints and data blocks.","At state , the backup server  can access a data block at the data store . In certain embodiments, the data block is one of a set of data blocks to be backed up. Alternatively, the data block may be smaller than a block to be backed up. For example, a block of size N may be selected for backup; however, the process  may be performed on a more granular level. Thus, the backup server  may divide the block of size N into two pieces and perform some or all of the process  on two blocks of size N\/2.","At state , the backup server  can compute a block fingerprint for the data block. At decision state , the backup server  determines if the block fingerprint matches an entry in the composite block map. If the block fingerprint does not exist in the composite block map, the backup server can determine at decision state  whether the block fingerprint matches an entry in the global deduplication data store .","If the backup server  determines that the block fingerprint exists in the composite block map (decision state ) or the global deduplication data store (decision state ), then the backup server  completes processing of the data block at state . In certain embodiments, state  may include skipping the data block. In some embodiments, state  may include updating one or more data maps to point to the storage location of the data block. In some embodiments, state  may include touching the data block to update a timestamp associated with the data block. In some embodiments, block  may include deleting the data block or replacing the data block with a pointer to the data block identified in the composite block map or the global deduplication data store .","If the backup server  determines that the block fingerprint does not exist in the composite block map (decision state ) or the global deduplication data store (decision state ), then, at state , the backup server  stores the data block at the backup archive (e.g. the data storage ). In certain embodiments, the backup server  may store the data block as part of a new incremental archive or a new full archive.","At decision state , the backup server  can determine if more data blocks exist. This may include determining if more data blocks identified for archival or backup storage exist. If more data blocks identified for processing do exist, process  accesses the next identified data block at state  and the process  continues executing as previously described.","In a number of embodiments, the backup server  stores the data blocks of the data store at the backup archive before performing deduplication. In some such embodiments, at state , the backup server  can remove the data block from the backup archive and at state  the backup server  can confirm storage of the data block at the backup archive.","In certain embodiments, the process  can be used with file-based backup systems. In some implementations, the process  can be used with image-based backup systems. The image-based backup systems can backup an image of a virtual machine file or of a portion of a virtual machine file (e.g. a differential copy storing changes relative to a previous snapshot of the virtual machine file). The backup server  can generate a searchable index or catalog for each virtual image being backed up by, for example, examining a MFT associated with each virtual image to obtain metadata associated with the virtual image. The searchable index can be stored as part of the backup archive. Advantageously in certain embodiments, storing the searchable index enables a user to search for files in an archive associated with a virtual image without loading a number of archived virtual images to locate the archive that includes the file sought by the user. Image-based backup and cataloging are described in greater detail in U.S. application Ser. No. 13\/156,199, filed Jun. 8, 2011, titled \u201cCataloging System for Image-Based Backup,\u201d which is incorporated by reference in its entirety herein and forms a part of this specification.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 9","b":["900","900","900","900","900"]},"The process  can be implemented by the systems , , or  described above. For example, the process  can be implemented by the backup server , or more specifically, the deduplicator  and the deduplication preprocessor  of the backup server . As a second example, the process  can be implemented by the management server . To simplify discussion, and not to limit the disclosure, the process  will be described as being performed by the backup server  with respect to the data store .","At state , the backup server , for example, can access a data block at a data store  associated with a host server . The data block, in certain embodiments, may be part of a file that is being backed up. The backup server , at state , creates a fingerprint, such as a hash, of the data block. At state , the backup server  accesses a block directory associated with a previous archive, such as the incremental archive  at a data storage , which may include archives of the data store . This previous archive can be an incremental archive or a full archive.","At decision state , the backup server  determines whether the fingerprint matches an entry in the block directory. In some embodiments, decision state  can include comparing the fingerprint to one or more fingerprints associated with the entries in the block directory. In other embodiments, decision state  can include identifying blocks stored in the incremental archive  based on the entries in the block directory, creating fingerprints for the identified blocks and comparing the fingerprint to the fingerprints associated with the entries in the block directory.","If the fingerprint matches an entry in the block directory, the backup server , at state , can store a reference to the entry in a block directory associated with a new archive, which can be an incremental archive or a full archive. Alternatively or in addition, the backup server  may store a reference to the storage location of the data block. In some embodiments, the reference is stored in the new archive in addition to or instead of in the block directory.","If the fingerprint does not match an entry in the block directory, the backup server determines if more archives exist at decision state . If so, the process  returns to state . In certain embodiments, the backup server  can access the archive in chronological or reverse chronological order of creation. In some embodiments, the access order of the archives can be based, at least in part, on whether the archive is an incremental archive or a full archive. If no more archives exist at the data storage , the backup server  accesses the global deduplication data store at state .","At decision state , the backup server  determines whether the fingerprint matches an entry in the global deduplication data store . If so, the backup server  stores a reference to the entry in the global deduplication data store  in a block directory associated with the new archive at state . If the fingerprint does not match an entry in the global deduplication data store , the backup server  can create a new entry for the fingerprint in a block directory associated with a new archive at state . In some embodiments, state  can include storing the data block in the new archive. In certain embodiments, state  can also include creating a pointer from the block directory entry associated with the data to the location of the data in the new archive.","For purposes of illustration, certain aspects, advantages and novel features of various embodiments of the inventions have been described herein. It is to be understood that not necessarily all such advantages may be achieved in accordance with any particular embodiment of the inventions disclosed herein. Thus, the inventions disclosed herein can be embodied or carried out in a manner that achieves or optimizes one advantage or group of advantages as taught herein without necessarily achieving other advantages as can be taught or suggested herein. Further, no element, feature, block, or step, or group of elements, features, blocks, or steps, are necessary or indispensable to each embodiment. Additionally, all possible combinations, subcombinations, and rearrangements of systems, methods, features, elements, modules, blocks, and so forth are within the scope of this disclosure.","Depending on the embodiment, certain acts, events, or functions of any of the algorithms, methods, or processes described herein can be performed in a different sequence, can be added, merged, or left out all together (e.g., not all described acts or events are necessary for the practice of the algorithm). Moreover, in certain embodiments, acts or events can be performed concurrently, e.g., through multi-threaded processing, interrupt processing, or multiple processors or processor cores or on other parallel architectures, rather than sequentially.","The various illustrative logical blocks, modules, processes, methods, and algorithms described in connection with the embodiments disclosed herein can be implemented as electronic hardware, computer software, or combinations of both. To clearly illustrate this interchangeability of hardware and software, various illustrative components, blocks, modules, operations, and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. The described functionality can be implemented in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the disclosure.","The various illustrative logical blocks and modules described in connection with the embodiments disclosed herein can be implemented or performed by a machine, such as a general purpose processor, a digital signal processor (DSP), an application specific integrated circuit (ASIC), a field programmable gate array (FPGA) or other programmable logic device, discrete gate or transistor logic, discrete hardware components, or any combination thereof designed to perform the functions described herein. A general purpose processor can be a microprocessor, but in the alternative, the processor can be a controller, microcontroller, or state machine, combinations of the same, or the like. A processor can also be implemented as a combination of computing devices, e.g., a combination of a DSP and a microprocessor, a plurality of microprocessors, one or more microprocessors in conjunction with a DSP core, or any other such configuration.","The blocks, operations, or steps of a method, process, or algorithm described in connection with the embodiments disclosed herein can be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module can reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other form of volatile or non-volatile computer-readable storage medium known in the art. A storage medium can be coupled to the processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium can be integral to the processor. The processor and the storage medium can reside in an ASIC. The ASIC can reside in a user terminal. In the alternative, the processor and the storage medium can reside as discrete components in a user terminal.","Conditional language used herein, such as, among others, \u201ccan,\u201d \u201cmight,\u201d \u201cmay,\u201d \u201ce.g.,\u201d and the like, unless specifically stated otherwise, or otherwise understood within the context as used, is generally intended to convey that certain embodiments include, while other embodiments do not include, certain features, elements and\/or states. Thus, such conditional language is not generally intended to imply that features, elements, blocks, and\/or states are in any way required for one or more embodiments or that one or more embodiments necessarily include logic for deciding, with or without author input or prompting, whether these features, elements and\/or states are included or are to be performed in any particular embodiment. The terms \u201ccomprising,\u201d \u201cincluding,\u201d \u201chaving,\u201d and the like are synonymous and are used inclusively, in an open-ended fashion, and do not exclude additional elements, features, acts, operations, and so forth. Also, the term \u201cor\u201d is used in its inclusive sense (and not in its exclusive sense) so that when used, for example, to connect a list of elements, the term \u201cor\u201d means one, some, or all of the elements in the list.","While the above detailed description has shown, described, and pointed out novel features as applied to various embodiments, it will be understood that various omissions, substitutions, and changes in the form and details of the devices or algorithms illustrated can be made without departing from the spirit of the disclosure. As will be recognized, certain embodiments of the inventions described herein can be embodied within a form that does not provide all of the features and benefits set forth herein, as some features can be used or practiced separately from others. The scope of certain inventions disclosed herein is indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Throughout the drawings, reference numbers are re-used to indicate correspondence between referenced elements. The drawings are provided to illustrate embodiments of the inventions described herein and not to limit the scope thereof.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
