---
title: Federated authentication of client computers in networked data communications services callable by applications
abstract: A data processing method providing improved and efficient authentication of client computers by server computers, the method comprising: using authentication logic of a server computer, establishing a secure socket connection with a client computer; receiving, from the client computer, a request to use a communications service that is implemented at the server computer, and in response to the request, determining that the client computer is unauthenticated; providing a nonce value to the client computer; receiving from the client computer an encrypted identity token that includes the nonce and a user identifier, wherein the identity token has been encrypted using a provider computer and an encryption key of the provider computer, wherein the encryption key is known at the server computer; validating the identity token and obtaining the user identifier therein; creating and storing a session token that is uniquely associated with the client computer and that includes a session identifier, the user identifier, and a binding to the secure socket connection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09426140&OS=09426140&RS=09426140
owner: LAYER, INC.
number: 09426140
owner_city: San Francisco
owner_country: US
publication_date: 20140909
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["BENEFIT CLAIM","FIELD OF THE DISCLOSURE","BACKGROUND","SUMMARY OF DISCLOSURE","DETAILED DESCRIPTION OF EXAMPLE EMBODIMENTS","API Example","API Example","API Example","APPENDIX 1","Android Example","Concepts"],"p":["This application claims the benefit under 35 U.S.C. \u00a7119(e) of provisional application 61\/875,562, filed Sep. 9, 2013, the entire contents of which are hereby incorporated by reference for all purposes as if fully set forth herein.","The present disclosure relates to improved data processing in the fields of electronic messaging services and computer program application development. The disclosure relates more specifically to networked data communications services on server computers that can be called by remote applications on mobile computing devices to invoke messaging or communications functions.","The approaches described in this section are approaches that could be pursued, but not necessarily approaches that have been previously conceived or pursued. Therefore, unless otherwise indicated, it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.","Computer program applications or \u201capps\u201d for mobile computing devices such as smartphones, tablet computers, and other devices have become ubiquitous. Many of these apps provide substantive functions that use, as foundation, various forms of electronic messaging including SMS text, e-mail messages, messages using proprietary messaging protocols, notifications and alerts, and\/or voice calls. Indeed, one main reason that the number and utilization of apps have skyrocketed is the social communication possibilities that portable computing devices permit.","However, in past approaches, developing apps with messaging and voice call capabilities has been time-consuming and difficult. For example, assume that a particular app permits a pair of users to indicate affinity for one another and then communicate after mutual indication of affinity. In the past, setting up a messaging capability for this type of app has required the app developer to re-implement foundation elements such as message buffers, message delivery protocols, failure handling, and other processes that are essential to having a reliable, useful, workable messaging function. Re-implementation of these functions typically requires a large, highly skilled team of software developers, considerable time to code, test, and debug the foundation functions, and significant computing resources to support the functions. When thousands of developers are working on thousands of different apps, this process is not scalable.","Past approaches have provided application programming interfaces that provide abstracted access to call processing functions of telephone service providers such as Verizon and AT&T; an example is TWILIO.","The appended claims may serve as a summary of the disclosure.","In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.","As one embodiment, the disclosure describes an open communications layer for the internet that operates cross-platform and free from an advertising supported business model. Developers who have tried to build rich, secure, scalable communications in their products know that it's extremely hard to do right. Solving authentication, security, sync, offline messages, push notifications and a plethora of other problems is a challenge by itself. Required infrastructure such as CPU and storage resources are immensely difficult to build and expensive to set up on a high-performance, global basis. While companies like Google, Facebook, Apple and Microsoft have spent millions of dollars and deployed huge teams to create global infrastructure, the cost is that their services are not open, are platform dependent, or rely on advertising for profitability.","In an embodiment, the disclosure provides computer-implemented services that can make rich, secure, scalable communications easier. In an embodiment, an open communications layer for the Internet enables the power of communications to be used in any mobile or web product. Designed for use by software developers, certain embodiments provide foundation communication services such as rich messaging, voice and video calls so that developers can focus on the core of their products.","In one embodiment, these communications services are implemented using a set of user interface services for direct use by developers and that are coupled to a software development kit (SDK) that interfaces to supporting services that are implemented using public data centers or cloud service providers. Thus, an embodiment can be implemented as a full-stack communications service for application developers. Each of the components of the software stack, such as the SDK, API, and cloud services, are configured to work together. In past approaches, for example, a signaling service might provide only a connection from a server to a client that allows real-time messaging, voice or video transfer, but a developer aiming to use this service to power communications in an app would be required to build the entire client-side stack, design a synchronization solution, build offline messaging support, and find a way to handle both authentication and push notifications. Once these elements have been created, the greater challenge is making them all work together. In sharp contrast, the disclosure herein provides a complete, end-to-end, turnkey communications solution for developers, or a \u201cfull-stack service,\u201d that allows for the addition of messaging, voice and video to any mobile or web application.","Embodiments are described herein according to the following outline:\n\n","1. Overview",{"@attributes":{"id":"p-0032","num":"0042"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["102","120","130","102","102","130"]},"In one embodiment, the techniques herein may be implemented in client-side logic and server-side logic that is associated with a set of services denoted \u201cLayer\u201d. The label \u201cLayer\u201d is used solely to indicate that certain elements of the system disclosed herein are unlike prior approaches and related to a full stack of communications services. However, the use of the label \u201cLayer\u201d is not required in an embodiment or implementation.","In an embodiment, mobile computing device  comprises an operating system , a software development kit (SDK) , a user interface (UI) kit , and an application or \u201capp\u201d . \u201cKit,\u201d in this context, refers to a collection of logic, programmed methods, routines, programs, or other software elements, or a combination with hardware or firmware logic elements. In an embodiment, the OS is configured to manage processes, applications, storage, and I\/O resources of the device . The mobile computing device  may host or execute any of the APPLE IOS, ANDROID, WINDOW MOBILE or web-oriented operating systems or platforms. In an embodiment, the SDK  comprises logic that is configured to perform the client-side functions that described further herein relating to messaging, voice, video, and similar infrastructure functions. In certain embodiments, the SDK  may be developed against or linked into any appropriate communications app as a foundation layer for accessing the communications-related functions that are provided in the server computer logic. In other embodiments, the SDK  may comprise a non-linked library that is accessible using well-known or published calls or method invocations as described in an application programming interface (API).","In an embodiment, the UI kit  comprises logic that is configured to implement user interface display widgets or other functions for purposes of presentation consistency across apps that use the SDK ; in some embodiments, the use of the UI kit is optional.","In an embodiment, app  comprises logic that is configured to implement any of a variety of substantive applications that may be useful or entertaining for a user of the device . Examples include social media apps, sports apps, reading or information retrieval apps, financial apps, or apps that relate to any other form of human interest or endeavor.","In an embodiment, network  broadly represents one or more local area networks, wide area networks, internetworks or internets, and includes connectivity apparatus such as wireless access points, aggregation routers, switches, and the like. Links between devices  and network  may be wired or wireless and may use terrestrial, satellite, microwave or other links.","In an embodiment, server computer  comprises server computer logic that is configured to perform the server-side functions described herein relating to messaging, voice, video, and similar infrastructure functions. In an embodiment, the server computer  may be implemented using any number of processors, computers, or virtual machine instances, in a data center or using a cloud computing center in which instances may be created and removed on demand and in response to processing needs. Thus, server computer  in  broadly represents one or more virtual machine instances and\/or one or more general purposes server computers hosting stored control programs and\/or special-purpose computers that are configured as described herein.","App  also may have a client-server relationship to a Provider , which comprises one or more computers typically associated with a developer of the app  and coupled to the network. As further described herein, Provider  may provide selected server-side authentication functions that enable establishing a trust relationship with the app  and delivering an identity token to the app that enables the app to prove its trustworthiness to the server computer .","In an embodiment, server computer  comprises a contact database , name resolution service , search query interface , communications logic , synchronization logic  and authentication logic . As indicated by the characters \u201c* * *\u201d in , the server computer  may comprise other functional units or different functional units in other embodiments, and the contact database , name resolution service , search query interface  and communications logic  shown in  merely represent examples of services that could be provided. For purposes of illustrating a clear example, in this description all such services may be termed collectively \u201cserver computer logic\u201d or \u201cserver communications logic\u201d. Server computer  may be coupled to an application programming interface (API)  that exposes callable methods or functions of the elements within the server computer, and coupled to an event repository  that is configured as a data store for events, messages, and records of other information to support functions of the system, as further described.","In an embodiment, the contact database  is configured to receive, store, and respond to queries relating to contact data records that comprise data relating to persons or other entities such as businesses. In an embodiment, the name resolution service  is configured to receive and respond to queries that provide a first kind of identifier of a person or entity, and request resolution into a second kind of identifier; the operation of an example name resolution service is described further herein in a separate section. In an embodiment, the search query interface  is configured to receive and respond to queries for message metadata relating to aspects of text messages, email messages, voice calls or video calls that are processed using the system.","In an embodiment, the communications logic  implements a variety of message and call processing functions that are callable by the SDK  according to one or more specified protocols. Example functions include: sending messages; receiving messages; making calls; receiving calls; importing contacts; adding contacts; updating a contact; receiving contact updates; and others as described herein.","In an embodiment, server computer  comprises an API  that provides programmatic access to the contact database , name resolution service , search query interface  and communications logic  for external computers, systems, services or applications that cannot or do not use SDK  to call functions of the server computer . Examples include external social networking services, email services, server computer-based applications, and others.","Synchronization logic  is configured to perform synchronization of information, such as messages, across a plurality of different computing devices that are associated with the same account or user. For example, the developer of the app  can include calls to synchronization services implemented in synchronization logic  to permit that particular app to synchronize its events, alerts, or other messages across multiple different end-user devices, without the developer having to write a synchronization service from scratch.","Authentication logic  is configured to perform authentication of users, devices or accounts to the server computer  and\/or to back-end server computers that are specifically associated with the app . For example, the developer of the app  can include calls to authentication services implemented in authentication logic  to permit that particular app to authenticate users to a back-end server, without the developer having to write an authorization service from scratch.","With the approach herein, app developers can integrate sophisticated and complex communications capabilities into their apps without having to re-implement functions such as messaging, call establishment, etc. Thus, an app developer may use relatively few lines of code to call functions of an API or SDK that logically call corresponding methods of the server computer logic, and thereby perform complex actions without re-implementation.","Example functions include: authentication; security; synchronization of data on an app of a mobile computing device to data managed by a corresponding application on an application server computer or virtual machine instance; message buffering, offline message delivery, assured message delivery, changing the state of messages as they flow through the network, and other functions relating to messaging infrastructure; and management of offline messages that are sent or received when a mobile computing device is temporarily disconnected from a network.","In various embodiments, these functions may be implemented for communications through text, voice, and video including any of such communications in a manner that is marked on the record or off the record. In this context, an off-the-record message means a message that is encrypted using credentials known only to the calling app so that the message content is not readable or capable of indexing by the server computer logic. Messaging functions may include: sending messages; receiving messages. Voice call functions may include: making calls; receiving calls. Contact management functions may include: importing contacts.","The approaches contemplated herein are highly scalable by using a cloud computing infrastructure, and permit app developers to focus on the distinguishing substantive functions of their apps rather than investing significant time in implementing messaging infrastructure. Instances of the first element of communications logic may be deployed on virtual machine instances that are located in any of multiple different geographically distributed regions.","In certain embodiments, the communications logic is configured to interoperate with network-connected services other than telephone communications services. Examples of such network-connected services include FACEBOOK, GMAIL, YAHOO! Mail, and other external services. The communications logic provides a separate set of infrastructure services that are particularly useful for mobile devices, for messaging, for peer to peer voice and video, and similar applications.","Example services include: Intra-app communication: app developers can add in-app communication between users of their app. Messaging, voice, video, media; Inter-app communication: users can communicate across apps; Address book cleanup: clean up a user's address book on import into an app; External messaging integration: send messages over external services such as Google and Facebook.","Examples of data collection sources include: Address books; Apps-devices-person associations (which apps using the SDK are installed on which devices for a specific person.); Intra-app communications; Inter-app communications; External messaging communications; VoIP call history; Media shared.","Examples of benefits that may be obtained using various embodiments include: Address book cleanup; Contact ranking: who's important to me?; fraud detection ranking\/service; Insight into media distribution: who's sharing, how does media spread?","In an embodiment, the publish data to topic streams. Current and future services will consume data by topic. These services can be real-time or batch oriented. With this approach, some embodiments can provide a consistent interface for producing and consuming data system-wide. New services that produce or consume data can be introduced with no impact to existing services.","In an embodiment, logic implementing the services is a self-contained unit, separated from the core messaging infrastructure. An embodiment may include a record keeping utility for storage of information about people, relevant to communication. Embodiments may include a global store across all applications. In some embodiments, there is no distinction between accounts and contacts. In some embodiments, original data is never changed to promote accountability. In some embodiments, the processed data is in a usable format for various use cases such as disambiguation or address resolution. In some embodiments, the data store holds all addresses for a person including all local addresses. Embodiments may be implemented as a distributed, highly available service.","2. Name Resolution Service","2.1 Overview",{"@attributes":{"id":"p-0058","num":"0068"},"figref":["FIG. 2","FIG. 1"],"b":["134","134","134"]},"In an embodiment, name resolution service  comprises a system that collects and disambiguates digital representations of people that use, or become known through use of, the other services described herein. It stores all available information typically associated with a person, such as their name, aliases (nickname), addresses (digital and physical), age, and\/or other values. The system is aware of relationships between persons. Essentially it is an interlinked global address book of the system. In an embodiment, name resolution service  supports a Global \u201cWhite Pages\u201d and \u201cYellow Pages\u201d services where a person can claim and manage their person identity\u2014choosing which elements to make globally visible and those that another person must already know in order to name resolve from that unique identifier. For example, a user could communicate to the system and configure records to provide, I would like to be known by my TWITTER handle, but someone would need to know my email address in order to associate it with me.","In an embodiment, name resolution service  is configured as a globally distributed recursive hierarchical cache that provides fast, secure name resolution with a policy framework such as OpenDNS. Referring again to , the name resolution service  principally operates on original data , which may be stored in key-value pairs in repository . Original data  may be obtained from a variety of sources including explicit user account enrollments, contact files in mobile devices, address books in e-mail client programs, and so forth. A persons table  is periodically configured from the original data and includes a high-level representation of individuals, stored in a secure table of repository ; records in the persons table serve as a first-level source of information about what person the original data represents. A deduplicator  is configured to remove duplicate records from the repository  as new records are received in requests or entered into the original data . After deduplication, records may be added to the repository  via a persistence layer  that is responsible for persistent data storage and retrieval.","A resolver  is coupled to the persistence layer  and receives input from the original data . In an embodiment, resolver  is configured to receive a resolution request from persistence layer  identifying one or more sets of data relating to a user, account or device, and to reply with resolved entity data that indicates an entity to which the data relates and a confidence score indicating a relative confidence level that the entity is truly indicative of the set of data that was received. In one embodiment, a remote procedure call (RPC) service  acts as an interface to other elements of the server computer  for the purpose of receiving requests from the client logic or other elements of the server logic and transferring requests and responses to the other elements shown in .","In one embodiment, name resolution service  implements the following system operations.","list<match> add(list<person> entries): Adds a list (at least 1) of people to the global persons store. Deduplicates entries within this list. Returns: Potential duplicates of supplied persons paired with probability of a match","list<match> deduplicate(list<person> existing, list<person> new): Deduplicates persons within to list \u2018new\u2019 and in the union of lists \u2018new\u2019 and \u2018existing\u2019 Entries in \u2018existing\u2019 take precedence before entries in \u2018new\u2019, meaning in the event of a match, the entry in \u2018existing\u2019 is kept and the one from \u2018new\u2019 is discarded. Returns: Potential duplicates of supplied persons paired with probability of a match","string resolve(string address): For a given address, return the global unique id.","As one example of use, assume that a user imports their list of contacts into the app local address book database. All contacts (new and existing or just new) are passed over to the name resolution service  for deduplication. All new contacts and returned matches are stored in the address book database. Ideally the app developer displays the results to the user to be merged or merges them behind the scenes based on a calculated probability that they are associated.","In one embodiment, the following data structures are implemented in the context of a multitiered data storage unit having three (3) tiers. Tier 1 comprises raw data that is considered immutable. Tier 2 comprises deduplicated records of persons that are computed in bulk from raw data. Tier 3 comprises a key-value store for address resolution.","PERSON: Represents a person known to the system. TABLE 1 presents code for an example definition of a person structure.",{"@attributes":{"id":"p-0069","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},{},"PERSON DATA"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"{"]},{"entry":[{},{},"\u2003\u2032id: \u2032UUID\u2032,"]},{"entry":[{},{},"\u2003\u2032first_name\u2032: \u2032String\u2032,"]},{"entry":[{},{},"\u2003\u2032fn_metaphone\u2032: \u2032String\u2032,"]},{"entry":[{},{},"\u2003\u2032last_name\u2032: \u2032String\u2032,"]},{"entry":[{},{},"\u2003\u2032ln_metaphone: \u2032String\u2032,"]},{"entry":[{},{},"\u2003\u2032addresses\u2032: ["]},{"entry":[{},{},"\u2003\u2003{"]},{"entry":[{},{},"\u2003\u2003\u2003\u2032type\u2032: \u2032layer\/email\/phone\/fb\/...\u2032,"]},{"entry":[{},{},"\u2003\u2003\u2003\u2032value\u2032: \u2032the address\u2032,"]},{"entry":[{},{},"\u2003\u2003\u2003\u2032verified\u2032: true\/false,"]},{"entry":[{},{},"} ],"]},{"entry":[{},{},"\u2003\u2032gender\u2032: \u2032m\/f\u2032,"]},{"entry":[{},{},"\u2003\u2032location\u2032: \u2032TBD\u2032,"]},{"entry":[{},{},"\u2003\u2032birthday\u2032: \u2032date\u2032,"]},{"entry":[{},{},"\u2003\u2032devices\u2032: [\u2032TBD - unique id, "]},{"entry":[{},{},"\u2003type, (list) Layer app ids\u2032],"]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Note: address may contain extra fields depending on the type. For example, a phone number type. Note: The idea behind storing devices globally for each person in to aid in security.","Queries: fetch persons where address in list of addresses; fetch person where last name like somename (like defined as required by the deduplication algorithm); fetch persons where id in list of identifiers.","ADDRESS: defines address type. Type can be: system, email, phone, physical. Value: The address itself. \u2212accountId+appId for system addresses\u2212E164 for phone\u2212email\u2212any string for physical address. Verified (optional): true if the address's ownership was verified somehow (by system or by a trusted third party).","RELATIONSHIPS: Relationships between persons stored in the datastore are represented and accessed using a graph. Relationships are e supplemented with edges based on communication patterns between persons, calculated periodically offline based on logs stored in various layer applications.","In an embodiment, the communications logic implements a comprehensive form of name resolution for username and handles that are registered in multiple different kinds of communications services. For example, a particular individual may have established all of the following: multiple e-mail addresses; a handle or userid in the TWITTER service; an identity in a social networking system such as FACEBOOK, GOOGLE+, LINKEDIN, etc.; an identity in a shared data communication and display system such as PINTEREST; a 10-digit cellular radiotelephone number for a mobile computing device that is capable of sending and displaying SMS text messages; and other identifiers, names or handles.","In an embodiment, the communications logic is configured to receive a call from an application that provides one or more of the foregoing identifiers and to resolve the one or more identifiers into another one or more identifiers, including but not limited to a user identifier, an internet address, such as a single particular e-mail address, phone number, or other identifier. However, in an embodiment, the resolver does not require resolution into any one particular kind of target identifier; any of the foregoing may be the target of resolution and resolution into a single phone number, for example, is not required. In addition, facilitating communication between two persons does not necessarily require determining a phone number for one or both, because other messaging services such as TWITTER may be used to connect the persons. Thus, embodiments may be configured for disambiguating names or handles from various services and providing DNS-style resolution for Internet identity values.","In an embodiment, the communications logic also implements a policy framework that may be configured with user-specific policies that specify which users are permitted to communicate using the system with which other particular users. For example, if ALICE knows the TWITTER handle of BOB, but does not know BOB's identity in FACEBOOK, and if the policy data is configured appropriately, then the communications logic may permit ALICE to initiate messages via FACEBOOK to BOB after resolving BOB's handle in TWITTER into a corresponding identity in FACEBOOK.","Name resolution in these embodiments enables apps to identify a specific person and initiate communications with that person. In some embodiments, disambiguation of identifiers may be supported by retrieving social graph data for various users and using the social graph data to assist in separating one particular user from another who may have a similar name or other attributes, or determining that a particular handle from another service corresponds to a particular user in the social networking service. In some embodiments, the server computer logic may build and maintain a communication graph that describes who has been in communication with whom using calls into the server computer logic, and may use the communication graph in later operations for disambiguation.","Name resolution in these embodiments may be used for functions other than initiating messages. For example, if an email address can be resolved into the name of an individual user so that the email address is known to be associated with a human, then the email address can be given a different score value, for purposes of fraud detection, than an address that is associated with a machine. Additionally, an email address that receives a high score as likely to be associated with a natural person may be given a higher quality of service designation for purposes of performing various messaging functions; for example, a particular individual with a highly scored address or name may be given treatment as a VIP for purposes of receiving or forwarding messages or performing other functions such as notifications, surfacing messages to applications, etc.","Name resolution in these embodiments also may be obtained using the client device logic on any device that a particular user uses, because the name resolution is performed using the server computer logic and therefore the results are available for use with any device.","In an embodiment, a resolved name database associated with the server computer logic may serve as an authoritative repository for identity information that may be queried by and used by any number of other applications. The resolved name database may obtain authoritative information about particular end users based upon queries to authoritative sources such as the graph data or databases of known reputable sources such as FACEBOOK, LINKEDIN, GOOGLE+, etc. In addition, the resolved name database may store authoritative bindings of a first identity value to a second identity value, and there may be any number of such one-to-one bindings for a particular user. In an embodiment, the resolved name database will not store a list or association of all identity values that are associated with a particular user, for purposes of enforcing reasonable privacy safeguards. Instead, the focus is on the ability to resolve an email address into a corresponding LINKEDIN identity, and\/or to resolve the LINKEDIN identity into a FACEBOOK identifier, using separate calls or queries.","In an embodiment, name resolution processes may be supported by importing contact file records from users of the system via applications that invoke calls to the system to perform messaging or communications functions. Examples include contact data records from the CONTACTS app in APPLE IOS devices, the PEOPLE app in ANDROID devices, GMAIL contacts, YAHOO! contacts, MICROSOFT OUTLOOK, etc. For example, using a contact data import function, the server computer logic may provide the service of importing users' contact file entries, which identify persons by name, address, phone, and other identifiers including TWITTER handles or LINKEDIN URLs. While performing the importing service, the server computer logic may silently scan the contact data entries and use the association of a phone number and handle for a particular person to form an entry in the name resolution database that associates the phone number and handle. This process may be iterated over all identifiers that are in a particular contact file record and for all contact file records that are imported. In this manner, the server computer logic may rapidly form a database of trusted bindings of identifiers.","In an embodiment, the resolved name database may be called using a contact data resolution function that is integrated into a contact record management system. For example, a contact record management app may be implemented for mobile computing platforms that stores data records indexed by names of natural persons. Each data record may include a name, address, phone number, email address, and handles or identifiers for various external systems. In such an app, and in other apps such as the CONTACTS app in APPLE IOS devices, the PEOPLE app in ANDROID devices, GMAIL contacts, YAHOO! contacts, MICROSOFT OUTLOOK, etc., a typical occurrence is the creation of multiple data records that contain different identity data for the same natural person, as a result of import, synch, or other transfer operations. For example, a user's app may hold a first data record for CHARLIE SMITH that contains an address and mobile phone number, and a second data record that includes null values for address and mobile phone number but a valid email address value of CSMITH@DOMAIN.COM. In an embodiment, the contact record management app is configured with a RESOLVE function which, when selected, calls the resolved name database for each of the data records and, in response to a successful resolution, consolidates the first data record and second data record and deletes the second data record. For example, calling the resolved name database with the value CSMITH@DOMAIN.COM may result in a response identifying CHARLIE SMITH and a mobile phone number; by matching the mobile phone number to all phone numbers in the data records managed by the contact record management app, the first data record may be located. The value CSMITH@DOMAIN.COM then can be copied into the first data record, and the second data record may be deleted.","The resolved name database also may support a user control interface with which a particular end user may log in and, subject to appropriate authentication and authorization or other verification, reconfigure or control important identity items such as email addresses, phone numbers, handles or other identifiers; thus, embodiments offer the opportunity for individual users to maintain, prune or otherwise tend to their identity information. For example, email addresses or other identity values may be added or marked for removal. In some embodiments, items that are marked for removal may be given less weight in resolution operations, while remaining retained in the database.","In some embodiments, the user control interface may be configured to permit users to review a list of apps that can access the resolved name database, and to specify one or more of the apps as not permitted to access that particular user's identity data in the resolved name database. For example, users could be permitted to configure the server computer logic not to persistently store messages that are communicated through the server computer logic via calls from the app kit logic. These functions are economically possible for a service configured in the manner disclosed herein, as a subscription-based fee model may be used that is not dependent upon retaining messages for purposes of reading the content of the messages and selling advertising opportunities based upon analysis of the content of the messages.","2.2 Address Book Service","In an embodiment, an address book service enables application developers to import and store their users address-books on the infrastructure described herein. In an embodiment, methods defined in the SDK are configured to simplify the import of local address-book data. In an embodiment, the address-book service stores all the available address-book fields for every record in the device address-book","In an embodiment, a local address-book deduplication service helps developers clean up address-book records by outputting a confidence score that describes the likelihood of a match for every couple of records in the address-book. In an embodiment, local deduplication is performed using a series of steps. For example, in a perfect matching approach, when two records in an address-book are identical the system flags the two records with a high confidence score that the developer can use to display only one record in the view. Perfect matching on local address-book data is a fast and efficient first pass. Fuzzy matching using various algorithms also may be performed.","In one embodiment, multiple overlapping graphs are used for deduplication (global deduplication) and global identity service input. The concept of overlapping graphs assumes the same entities are present in many address-books with different sets of attached identities. As an example, assume that entity AB1 has record A=a,b,c and the following other entities have the following records:","AB2 has record A=a","AB3 has record A=a,b","AB3 has record B=c","Based upon these records, it is likely that A and B in AB3 are the same entity even if there is no explicit information in AB3. The combined graphs of AB1 and AB2 can be used to determine that there is an entity with identities a,b,c in AB3.","In all embodiments, the data used in address book and identity services is securely stored and is not communicated outside of the logic described herein, and is used only as an input to a global identity service as a basis for a global routing service. In an embodiment, the global identity service maps several identities to a single entity and is directly tied to the global deduplication service. For example, person A (an entity) can have multiple identities 1, 2 and 3 (i.e.: 1@a.com, 2@a.com, 3@a.com), and any unique identifier can be used as an identity (email, phone number, twitter handle, FB profile id . . . )","The global routing service enables routing of messages between entities even when the destination address identity is not explicitly matched with an entity in a specific service. For example, assume:\n\n","In this situation, when a message is sent from B to 1@a.com the routing service performs a lookup for identity 1@a.com and matches it with entity A. It then checks for the routing policy\/permissions and re-routes it to the identity used by A for a specific service (3@a.com). This process makes it possible for B to successfully communicate with A without knowing the specific identity A used to sign up for a service or application. This approach assumes that an identity service has been implemented with connections mapping entities and identities.","3. Message Communication Functions","3.1 Overview","Embodiments may implement functions in the app kit logic and the server computer logic that take advantage of research into improved ways to interact with mobile applications. In other words, the server computer logic and app kit logic may implement improved messaging, voice and video functions and the entity that manages and provides the server computer logic and app kit logic may invest the resources necessary to develop the improvements, so that app developers are not required to make such an investment of resources but may still obtain the benefit of the improvements.","In one embodiment, the messaging functions described herein may be implemented in the context of a mobile computing application that provides message functions, call functions, and contact card functions. Alternatively, the functions may be implemented as separate apps. In one embodiment, a contact card app presents contact data records in the form of a two-level list in which a first level comprises an alphabetized list of persons, and selecting a person causes displaying a contact card superimposed over the list. In some embodiments, calls may be initiated directly from the contact card, and prior message conversations may be viewed directly from the contact card by selecting a conversations function.","In this manner, messages may be sorted and organized by people, and not by time. This approach provides more efficiency for the computer and for users because a particular user who wishes to search for and potentially resume a conversation with a particular person tends to think about the conversation in terms of the counterparty rather than the time at which it occurred. Thus, in conventional approaches, finding a user's last SMS text conversation with JOHN SMITH requires searching the SMS message list of a smartphone app in reverse chronological order rather than by person identifier. In an embodiment, the server computer logic is configured to create and store metadata about messages that are communicated via calls from apps to the app kit logic and to the server computer logic, and the metadata may be returned in response to queries to enable apps to sort or present messages in different ways. For example, an app can be formed to show all conversations associated with a particular person, across SMS, social networking services, and all other services.","In an embodiment, a conversation comprises an identifier associated with a container object; each container object is associated with a particular subject identifier and\/or all messages exchanged between two users that occurred within a common time interval, for example, within 15 minutes. As an example, starting a new conversation results in creating a new conversation object having a unique conversation identifier that is associated with it, and the conversation may be separately listed, selected, viewed, and resumed. In sharp contrast, conventional SMS messaging approaches use a continuous chronological list of messages that cannot be identified or separated by subject or time. Each conversation object also may be associated with a person identifier of the persons who are participating in the conversation, to facilitate searching for conversations based on person identifiers, handles, or other values.","In certain embodiments, style sheets may be used to drive the appearance of user interface elements as they are rendered at user computing devices. For example, when URLs or links are added to message content, then the client app kit logic may use a style sheet to determine the appearance of the link or other content on the device on which the app kit logic is executing. In this approach, a link may be converted to a metadata description of the web object referenced in the link, and the style sheets may be used on a device-by-device basis to drive the appearance of the web object. Further, as the message is communicated through the system, the metadata generated for the web object may be carried with the message; consequently, since the metadata identifies the type of content, the location at which it was created, or other values, the metadata can be scanned by other apps and used to control sorting, presentation or other functions by those other apps.","An authentication service is provided. In an embodiment, the authentication service provides methods for federating identity back to integrating application developers, and secure addressing based on the scheme of a name space for integrating developers name. In this context, an application developer creates an account at a server computer that implements the logic described herein. From that account, the developer can have multiple identity providers. The developer provides the server computer with a public key from a public-private key pair, and the server logic validates the key that they generated. The server computer creates a registration record, and the developer receives a key ID and a provider ID. The server computer issues a nonce, which is random and ephemeral; the developer creates a web signature structure, for example using JSON, with a set of claims, in a developer-side computer. One of the claims is: This user is this person. A signature is then created on top of this claim and handed back to the server computer. Thereafter, the server computer can look at any given structure and definitely say if it was generated by the right key.","In most systems, the developer would sign into the app and the app only would send credentials to other servers for authentication. In sharp contrast, the logic herein is configured to validate, using Secure Sockets Layer (SSL) certificates, the device as a device that the server computer knows about, and then separately the server computer logic validates these external identities through the provider mechanism noted above. The server computer logic then combines the two identity results and binds them.","3.2 Implementation Example\u2014Apple IOS","This section describes an implementation example that is compatible with APPLE IOS software. APPENDIX 1, which is attached hereto and is hereby incorporated by reference as if fully set forth herein, describes an implementation example that is compatible with ANDROID software. In an embodiment, the service herein introduces three concepts which facilitate all messaging. The concepts and their function are the following:","Conversations\u2014represented by the LYRConversation object in LayerKit. Conversations coordinate messaging within Layer and can contain up to 25 participants. All Messages sent with LayerKit are sent within the context of conversation.","Messages\u2014represented by the LYRMessage object in LayerKit. Messages can be made up of one or many individual pieces of content. Messages have a file size limit of 64 kb.","Message Parts\u2014represented by the LYRMessagePart object in LayerKit. Message Parts are the atomic object in the Layer universe. They represent the individual pieces of content embedded with a message. MessageParts take an \u2018NSData\u2019 object and a MIME type string. LayerKit does not enforce any restrictions on the type of data you send, nor the MIME types your applications wishes to support.","The code of TABLE 2 demonstrates sending a message with LayerKit. Each line of code will be discussed in detail below.",{"@attributes":{"id":"p-0111","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Declares a MIME type string"},{"entry":"static NSString *const MIMETypeTextPlain = @\u2033text\/plain\u2033;"},{"entry":"\/\/ Creates and returns a new conversation object with a single participant represented by"},{"entry":"\/\/ your backend's user identifier for the participant"},{"entry":"LYRConversation *conversation = [LYRConversation"},{"entry":"conversationWithParticipants:@[@\u2033USER-IDENTIFIER\u2033]];"},{"entry":"\/\/ Creates a message part with a text\/plain MIMEType"},{"entry":"NSData *messageData = [@\u2033Hi, how are you?\u2033"},{"entry":"dataUsingEncoding:NSUTF8StringEncoding];"},{"entry":"LYRMessagePart *messagePart = [LYRMessagePart"},{"entry":"messagePartWithMIMEType:MIMETypeTextPlain data:messageData];"},{"entry":"\/\/ Creates and returns a new message object with the given conversation and array of "},{"entry":"message parts"},{"entry":"LYRMessage *message = [LYRMessage messageWithConversation:conversation"},{"entry":"parts:@[messagePart]];"},{"entry":"\/\/ Sends the specified message"},{"entry":"[layerClient sendMessage:message error:nil];"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"CONVERSATIONS. The LYRConversation object coordinates all messaging within the Layer service. It represents a stream of messages that are synchronized among all participants of a conversation. All messages sent with LayerKit must be sent within the context of a conversation. LYRConversation objects are created by calling the class method conversationWithParticipants:. The participants array is simply an array of user identifiers. As the Layer Authentication Guide allows you to represent users within the Layer service via your backend's identifier for that user, a participant in a conversation is represented with that same user identifier.",{"@attributes":{"id":"p-0113","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Creates and returns a new conversation object with a participant identifier"},{"entry":"LYRConversation *conversation = [LYRConversation"},{"entry":"\u2003conversationWithParticipants:@[@\u2033USER-IDENTIFIER\u2033]];"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"PARTICIPANTS. Once a conversation has been created, participant lists remain mutable and participants can be added or removed. The Layer service does not enforce ownership of conversations so any client can both add and remove participants to a conversation.",{"@attributes":{"id":"p-0115","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Adds a participant to an existing conversation"]},{"entry":[{},"\/\/ New participants will gain access to all previous "]},{"entry":[{},"messages in a conversation."]},{"entry":[{},"[layerClient addParticipants:@[@\u2033USER-IDENTIFIER\u2033] "]},{"entry":[{},"toConversation:conversation error:nil];"]},{"entry":[{},"\/\/ Removes a participant from an existing conversation"]},{"entry":[{},"\/\/ Removed participants will only lose access to future content. "]},{"entry":[{},"They will retain access"]},{"entry":[{},"\/\/ to the conversation and all preceding content."]},{"entry":[{},"[layerClient removeParticipants:@[@\u2033USER-IDENTIFIER\u2033] "]},{"entry":[{},"fromConversation:conversation error:nil];"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"FETCHING CONVERSATIONS. LYRClient exposes a simple API for fetching conversations for an authenticated user. In order to fetch all conversations, call conversationForIdentifiers:, passing nil for identifiers.",{"@attributes":{"id":"p-0117","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Returns an NSOrderedSet of all conversations for the signed in user"]},{"entry":[{},"NSSet *conversations =[layerClient conversationsForIdentifiers:nil];"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Correspondingly, to fetch a specific conversation, that conversation's identifier must be passed.",{"@attributes":{"id":"p-0119","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Returns an NSOrderedSet of all conversations for the signed in user"]},{"entry":[{},"NSSet *conversations = [layerClient conversationsForIdentifiers:[NSSet"]},{"entry":[{},"setWithObject:@\u2033CONVERSATION-IDENTIFER\u2033]];"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"DELETION. LayerKit supports the deletion of both conversations and messages. Deletion of a conversation deletes the conversation object and all associated messages for all current participants. Deletion of a messages only affects that individual message and it's parts.",{"@attributes":{"id":"p-0121","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"\/\/ Deletes a conversation"]},{"entry":[{},{},"[layerClient deleteConversation:"]},{"entry":[{},{},"conversation error:nil];"]},{"entry":[{},{},"\/\/ Deletes a message"]},{"entry":[{},{},"[layerClient deleteMessage:"]},{"entry":[{},{},"message error:nil];"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"INITIALIZATION. The LYRClient object represents the primary interface for interacting with the Layer service. Your application should only instantiate one instance of LYRClient and should retain the instance at all times. The object is initialized with an application key. We have created an application for you titled, <YOUR-APPNAME>, and the sample code below contains your application's key. You can create additional Layer applications by visiting our developer dashboard. This key is specific to your application and should be kept private at all times. Copy and paste the following into application:DidFinishLaunchingWithOptions: in your AppDelegate.",{"@attributes":{"id":"p-0123","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Initializes a LYRClient object"},{"entry":"NSUUID *appID = [[NSUUID alloc]"},{"entry":"initWithUUIDString:@\u201c%%C-INLINE-APPID%%\u201d];"},{"entry":"LYRClient *layerClient = [LYRClient clientWithAppID:appID];"},{"entry":"\/\/ Tells the LayerClient to establish a connection with the Layer service"},{"entry":"[layerClient connectWithCompletion:{circumflex over (\u2009)}(BOOL success, NSError *error) {"},{"entry":"\u2003if (success) {"},{"entry":"\u2003\u2003NSLog(@\u201cClient is Connected!\u201d);"},{"entry":"\u2003}"},{"entry":"}];"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"On subsequent application launches, LayerKit will attempt to establish a network connection on its own. You can inspect LayerKit's connection state via the public property is Connected on LYRClient.",{"@attributes":{"id":"p-0125","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","if (layerClient.isConnected) {"]},{"entry":[{},{},"\u2003\u2003\u2003\/\/ LayerKit is connected, no need to call "]},{"entry":[{},{},"connectWithCompletion:"]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Be sure to import the LayerKit headers into your AppDelegate.h",{"@attributes":{"id":"p-0127","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#import <LayerKit\/LayerKit.h>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"INSTALLATION. The simplest way to add LayerKit to your application is with CocoaPods (http:\/\/www.cocoapods.org). CocoaPods provides a simple, versioned dependency management system that automates configuring libraries and frameworks. You can install Cocoapods via the following command.",{"@attributes":{"id":"p-0129","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"$ sudo gem install cocoapods"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"To install LayerKit, first run the following:",{"@attributes":{"id":"p-0131","num":"0146"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 12"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","$ pod setup"]},{"entry":[{},{},"$ pod repo add layer-releases git@github.com:layerhq\/"]},{"entry":[{},{},"releases-cocoapods.git"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Navigate to your project's root directory and run \u2018pod init\u2019 to create a Podfile","Open up the Podfile and add: pod init","Save the file and run the following to install LayerKit: pod init Cocoapods will download and install LayerKit and also create a .xcworkspace project. If you do not want to use CocoaPods, you can also clone the LayerKit repository from Github (https:\/\/github.com\/layerhq\/releases-ios) and install the framework directly:","SETUP. If you clone the LayerKit repos or download the source, you will need to drag the framework directly into your project.","1. Open up LayerKit and locate LayerKit.embeddedframework","2. Drag LayerKit.embeddedframework into the Frameworks folder in your XCode project.","3. Make sure \u201cCopy items into destination group's folder\u201d option is checked.","LINK DEPENDENCIES. LayerKit needs a few other frameworks to be included in your project in order to function properly.","1. In XCode, navigate to your Target Settings.","2. Select the \u201cBuild Phases\u201d section and expand the \u201cLink Binary With Libraries\u201d. Add the following frameworks to your project:\u2014SystemConfiguration.framework;\u2014CFNetwork.framework;\u2014MobileCoreServices.framework;\u2014Security.framework.","3. Navigate to your \u201cBuild Settings\u201d tab and add the -ObjC and -lz flag to the \u201cOther Linker Flags\u201d setting.","MESSAGES. The LYRMessage object represents an individual message within a conversation. A message within the Layer service can consist of one or many pieces of content, represented by the LYRMessagePart object.","LYRMessagePart.","Layer does not enforce restrictions on the type of data you send through the service. As such, LYRMessagePart objects are initialized with an NSData object and a MIME type string. The MIME type string simply describes the type of content the LYRMessagePart object contains. TABLE 13 demonstrates creating message parts with both text\/plain and image\/jpeg MIME types.",{"@attributes":{"id":"p-0146","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/ MIME type declarations"]},{"entry":[{},"static NSString *const MIMETypeTextPlain = @\u201ctext\/plain\u201d;"]},{"entry":[{},"static NSString *const MIMETypeImageJPEG = @\u201cimage\/jpeg\u201d;"]},{"entry":[{},"\/\/ Creates a message part with a string of text and text\/plain MIME type."]},{"entry":[{},"NSData *messageData = [@\u201cHi, how are you?\u201d"]},{"entry":[{},"dataUsingEncoding:NSUTF8StringEncoding];"]},{"entry":[{},"LYRMessagePart *messagePart = [LYRMessagePart"]},{"entry":[{},"messagePartWithMIMEType:MIMETypeTextPlain data:messageData];"]},{"entry":[{},"\/\/ Creates a message part with an image"]},{"entry":[{},"UIImage *image = [UIImage imageNamed:@\u201cawesomeImage.jpg\u201d];"]},{"entry":[{},"NSData *imageData = UIImagePNGRepresentation(image);"]},{"entry":[{},"LYRMessagePart *imagePart = [LYRMessagePart"]},{"entry":[{},"messagePartWithMIMEType:MIMETypeImageJPG data:imageData];"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The LYRMessagePart object also declares a convenience method for creating messages with text\/plain MIME type as in TABLE 14.",{"@attributes":{"id":"p-0148","num":"0163"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/ Creates a message part with a string of text"]},{"entry":[{},"LYRMessagePart *part = [LYRMessagePart messagePartWithText:"]},{"entry":[{},"@\u201cHi, how are you?\u201d];"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"LYRMessage. LYRMessage objects are initialized with an array of LYRMessagePart objects and an LYRConversation object. The object is created by calling messageWithConversation:parts: on LYRMessage. This creates an LYRMessage object that is ready to be sent.",{"@attributes":{"id":"p-0150","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/ Creates and returns a new message object with the given "]},{"entry":[{},"conversation and array of message parts"]},{"entry":[{},"LYRMessage *message = "]},{"entry":[{},"[LYRMessage messageWithConversation:conversation"]},{"entry":[{},"parts:@[messagePart]];"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"SENDING THE MESSAGE. Once an LYRMessage object is initialized, it is ready to be sent. The message is sent by calling sendMessage:error: on LYRClient.",{"@attributes":{"id":"p-0152","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/Sends the specified message"]},{"entry":[{},"BOOL success = [layerClient sendMessage:message error:nil];"]},{"entry":[{},"if (success) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003NSLog(@\u201cMessage send succesful\u201d);"]},{"entry":[{},"} else {"]},{"entry":[{},"\u2003\u2003\u2003\u2003NSLog(@\u201cMessage send failed\u201d);"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The sendMessage method returns a Boolean value which indicates if the message has passed validation and was queued for delivery in the local data store. If LayerKit has a current network connection, the message will immediately be sent off of the device. Otherwise it will remain queued locally until the SDK re-establishes a network connection. At that point, the SDK will automatically send the message.","LYRMessage objects declare a Boolean property, isSent, which tells your application if the message was successfully sent from your device and synchronized with the Layer service. Your application can observe this property to be notified when a message was successfully sent.",{"@attributes":{"id":"p-0155","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 17"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Notifies the LYRClientDelegate that a message "]},{"entry":[{},{},"or messages were successfully sent"]},{"entry":[{},{},"[self addObserver:message forKeyPath:@\u201cisSent\u201d "]},{"entry":[{},{},"options:NSKeyValueObservingOptionNew"]},{"entry":[{},{},"context:NULL];"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Your application will then need to implement observeValueForKeyPath:ofObject:change:context: to respond to send notifications.",{"@attributes":{"id":"p-0157","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 18"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object"},{"entry":"change:(NSDictionary *)change context:(void *)context"},{"entry":"{"},{"entry":"\u2003if ([keyPath isEqualToString:@\u201cisSent\u201d]) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003NSLog(@\u201cMessage sent\u201d);"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"FETCHING DATA. The LYRClient object exposes a simple API for fetching all messages for a given conversation. This method will return an NSOrderedSet of messages with in descending order.",{"@attributes":{"id":"p-0159","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 19"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Fetch all messages for a given conversation object"]},{"entry":[{},{},"NSOrderedSet *messages = "]},{"entry":[{},{},"[layerClient messagesForConversation:conversation];"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"METADATA. Metadata is a flexible mechanism by which applications can attach contextually relevant information to conversations or messages. Applications do this by associating key-value stores of information to any LYRConversation or LYRMessage object. Layer supports two distinct types of metadata:","Participant Metadata\u2014Information that is synchronized among all participants in a conversation or recipients of a message.","Private Metadata\u2014Information that is private to a given participant, but synchronized among all of their devices.","Metadata may be any mix of nested dictionaries, arrays, strings, booleans, integers, longs, doubles, or NULL.",{"@attributes":{"id":"p-0164","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 20"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/ Adds metadata to an object"]},{"entry":[{},"- (void)setMetadata:(NSDictionary *)metadata forObject:(id)object;"]},{"entry":[{},"\/\/ Updates any existing metadata for an object"]},{"entry":[{},"- (void)updateMetadata:(NSDictionary *)metadata forObject:(id)object"]},{"entry":[{},"merge:(BOOL)mergeWithExistingValue;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"TABLE 21 demonstrates how to attach latitude and longitude info to a new conversation.",{"@attributes":{"id":"p-0166","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 21"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Adds location metadata to a new conversation object"]},{"entry":[{},{},"LYRConversation *conversation = [client"]},{"entry":[{},{},"conversationWithParticipants:@[@\u201cUSER_IDENTIFIER\u201d]];"]},{"entry":[{},{},"NSDictionary *metadata = @{@\u201clat\u201d : @\u201c37.7833\u201d,"]},{"entry":[{},{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003@\u201clon\u201d : @\u201c122.4167\u201d};"]},{"entry":[{},{},"[layerClient setMetadata:metadata forObject:conversation];"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A common use case for Private metadata is a \u2018Favorites\u2019 feature. The following demonstrates how an application could attach metadata to implement a favorites feature.",{"@attributes":{"id":"p-0168","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 22"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Adds location metadata to a new conversation object"]},{"entry":[{},{},"LYRConversation *conversation = [LYRConversation"]},{"entry":[{},{},"conversationWithParticipants:@[@\u201cUSER-IDENTIFIER\u201d]];"]},{"entry":[{},{},"NSDictionary *metadata = @{@\u201clat\u201d : @\u201c37.7833\u201d,"]},{"entry":[{},{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003@\u201clon\u201d : @\u201c122.4167\u201d};"]},{"entry":[{},{},"[layerClient setMetadata:metadata onObject:conversation];"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"3.3. Transmission Design; Transmission Protocol","In an embodiment, a computer system as described herein implements a data transmission protocol that satisfies the following: Multiple simultaneous requests; Fair frame scheduling; Multiple frame\/channel types; Async inbound messages (push notifications); Secure\u2014works over SSL; A unified base frame specifies the frame type\/contents.","The protocol supports multiple channels for transmission of data. The data is split into multiple frames, allowing for interleaving of packets and enabling fair packet scheduling. The protocol supports two types of channels; push and RPC. A client can open multiple channels of both types, and receive or transmit data on them simultaneously, depending on the channel type. In one approach, there can be at most 255 channels opened by the client, with IDs ranging from 0 to 254 inclusive. Channel types have numerical values assigned to them. In an embodiment, two types of channels are defined as seen in TABLE 23:",{"@attributes":{"id":"p-0172","num":"0187"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 23"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CHANNEL TYPES"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Channel type","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Push","0"]},{"entry":[{},"RPC","1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"PUSH CHANNELS. In an embodiment, push channels allow for one-way communication from a server implementing the services herein to the client computing device. They are used to transfer data such as notifications and synchronization requests.","RPC CHANNELS. RPC channels are used for remote procedure calls from the client device to the server and may be one-way or two-way. Any data that needs to be transmitted to the server may be sent over an RPC channel by calling a predefined function. The server may or may not return any data back to the client as a result of the procedure call. Thus, an RPC channel comprises RPC input data communicated from client computing device to server, and optionally RPC output data communicated from the server computer to the client computing device.","FRAMES. Any data sent over the protocol can be split into multiple frames, depending on the size of the payload. There are four types of frames: Init frames; Control frames; Response frames; Keepalive frames; Data frames.","INIT FRAME. In an embodiment, the init frame is the first frame the client must send after establishing a connection. If the frame is not sent in a certain amount of time (dependent on the server) the server drops the connection. The packet has the structure of TABLE 24:",{"@attributes":{"id":"p-0177","num":"0192"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 24"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"INIT FRAME PACKET"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Byte",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0","5","LAYER","The protocol descriptor string"]},{"entry":[{},{},{},"\u201cLAYER\u201d, specifying that"]},{"entry":[{},{},{},"this is the Layer protocol"]},{"entry":["5","1","VER_MAJ","The major part of the protocol"]},{"entry":[{},{},{},"version to be used; this is the"]},{"entry":[{},{},{},"1 in the 1.3 version, for example"]},{"entry":["6","1","VER_MIN","The minor part of the protocol"]},{"entry":[{},{},{},"version to be used; this is the"]},{"entry":[{},{},{},"3 in the 1.3 version, for example"]},{"entry":["7","4","FRAME_SIZE","The max frame size to be used in"]},{"entry":[{},{},{},"responses sent from the server"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The specified protocol version is used for any subsequent frames. The specified frame size will be used for inbound messages, while messages sent by the client may use any size for a particular request. If an invalid Init packet is sent (the server doesn't support the version, invalid descriptor string, zero frame size) the connection is dropped by the server immediately.","BASE FRAME. All other frame types are subtypes of the base frame. It has the following structure:",{"@attributes":{"id":"p-0180","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 25"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Byte","Byte",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","4","PAYLOAD_SIZE","The size of the data payload"]},{"entry":[{},{},{},"for the current frame, +1"]},{"entry":[{},{},{},"byte for the header"]},{"entry":["4","1","FRAME_HEAD","The frame header, which is"]},{"entry":[{},{},{},"described below"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The frame header has the following structure:",{"@attributes":{"id":"p-0182","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 26"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit","Bit",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","2","FRAME_TYPE","Specifies the type of frame"]},{"entry":["3","6","EXTENDED_HEAD","Extended header, dependent"]},{"entry":[{},{},{},"on the frame type"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"CONTROL FRAME. Control frames are used to send commands to the server. Control frames expect a response frame from the server to indicate if the operation was successful. In one embodiment, three types of control frames are defined: ChAdd; ChDel; Auth. Control frames have a frame type value of 0. The ChAdd frame is used to add a channel. It has the following structure:",{"@attributes":{"id":"p-0184","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 27"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit","Bit",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","32","PAYLOAD_SIZE","Always set to 2 bytes; 1 for the"]},{"entry":[{},{},{},"header and 1 for the channel ID"]},{"entry":["32","2","FRAME_TYPE","Always set to 0, specifying a"]},{"entry":[{},{},{},"control frame"]},{"entry":["34","4","OP","Always set to 1, specifying a"]},{"entry":[{},{},{},"channel add operation"]},{"entry":["38","2","CH_TYPE","Specifying the channel type to add"]},{"entry":["40","8","CH_ID","The channel ID requested for the"]},{"entry":[{},{},{},"added channel"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"If an invalid request is made (channel already exists, invalid channel type, etc) the server responds with an error response frame.","The ChDel frame is used to add a channel. It has the following structure:",{"@attributes":{"id":"p-0187","num":"0202"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 28"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit","Bit",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","32","PAYLOAD_SIZE","Always set to 1 byte"]},{"entry":["32","2","FRAME_TYPE","Always set to 0, specifying"]},{"entry":[{},{},{},"a control frame"]},{"entry":["34","4","OP","Always set to 2, specifying"]},{"entry":[{},{},{},"a channel delete operation"]},{"entry":["38","2","PAD","Padding, set to 0"]},{"entry":["40","8","CH_ID","The channel ID to of the"]},{"entry":[{},{},{},"channel to delete"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"If the channel does not exist the server responds with an error response frame. The Auth frame is used to authenticate a user with an authentication token. It has the following structure:",{"@attributes":{"id":"p-0189","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 29"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit","Bit",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","32","PAYLOAD_SIZE","Set to 1 + token length"]},{"entry":["32","2","FRAME_TYPE","Always set to 0, specifying"]},{"entry":[{},{},{},"a control frame"]},{"entry":["34","4","OP","Always set to 0, specifying"]},{"entry":[{},{},{},"an authenticate operation"]},{"entry":["38","2","PAD","Padding, set to 0"]},{"entry":["40","8 *","AUTH_TOKEN","The authentication token"]},{"entry":[{},"token length"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"If an invalid token is sent the server responds with an error response frame. If authentication is successful all open channels are closed and must be added again.","KEEPALIVE FRAME. In an embodiment, clients should send a keepalive frame every N minutes and expect a reply of the same format. If the server does not receive a keepalive frame in a predetermined amount of time, the session is closed. The frame has the following structure:",{"@attributes":{"id":"p-0192","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 30"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit","Bit",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","32","PAYLOAD_SIZE","Always set to 1 byte"]},{"entry":["32","3","FRAME_TYPE","Always set to 3, specifying"]},{"entry":[{},{},{},"a keepalive frame"]},{"entry":["34","6","PAD","Padding, set to 0"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"RESPONSE FRAME. Response frames are used to send control operation statuses to the client. There are two types of response frames: OK, and Error. Response frames have a frame type value of 2.","The OK response frame is used to indicate a successful control operation. It has the following structure:",{"@attributes":{"id":"p-0195","num":"0210"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 31"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit","Bit",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","32","PAYLOAD_SIZE","Always set to 1 byte"]},{"entry":["32","2","FRAME_TYPE","Always set to 2, specifying"]},{"entry":[{},{},{},"a response frame"]},{"entry":["34","1","RESP_TYPE","Always set to 0, specifying"]},{"entry":[{},{},{},"an OK response"]},{"entry":["38","5","PAD","Padding, set to 0"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The Error response frame is used to indicate an unsuccessful control operation and has the following structure:",{"@attributes":{"id":"p-0197","num":"0212"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 32"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit","Bit",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","32","PAYLOAD_SIZE","Always set to 1 byte"]},{"entry":["32","2","FRAME_TYPE","Always set to 2, specifying"]},{"entry":[{},{},{},"a response frame"]},{"entry":["34","1","RESP_TYPE","Always set to 1, specifying"]},{"entry":[{},{},{},"an error response"]},{"entry":["38","5","ERR_CODE","Error code specifying the"]},{"entry":[{},{},{},"type of error"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"DATA FRAMES. Data frames are used to transmit payloads to and from the client. Data frames have a frame type value of 1.",{"@attributes":{"id":"p-0199","num":"0214"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit","Bit",{},{}]},{"entry":["offset","size","Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","32","PAYLOAD_SIZE","1 byte + the data frame size"]},{"entry":[{},{},{},"from the end of the base frame"]},{"entry":["32","2","FRAME_TYPE","Always set to 1, specifying a"]},{"entry":[{},{},{},"data frame"]},{"entry":["34","6","P_TYPE","Specifies the packet type"]},{"entry":["0","1","CH_ID","The channel on which this data"]},{"entry":[{},{},{},"frame was sent"]},{"entry":["1","4","TOTAL_SIZE","Total size of the payload, split"]},{"entry":[{},{},{},"across all packet frames"]},{"entry":["5","Payload","PAYLOAD","The frame payload (Length -"]},{"entry":[{},"size",{},"header - channel id - total size)"]},{"entry":[{},{},{},"which will be interpreted as"]},{"entry":[{},{},{},"specified by the registered packet"]},{"entry":[{},{},{},"type"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The base frame is followed by the rest of the data frame, which has the following structure:","PACKET TYPES. Packet types specify the type of data contained within the payload of each frame. Packet types are local to channel types\u2014each channel type supports different packet types.",{"@attributes":{"id":"p-0202","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Packet type","Numerical value","Channel type"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Sync request","2","Push"]},{"entry":[{},"Normalized message","0","RPC"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Sync requests are sent by the server to indicate to a client that synchronization is required. Normalized messages are contain RPC data, and are used by all RPC calls.",{"@attributes":{"id":"p-0204","num":"0219"},"figref":["FIG. 3","FIG. 3","FIG. 1"],"b":["110","106","144","142","102","102","102","102","102"]},"3.4. Synchronization Design","In an embodiment, the services herein include logic that is configured to synchronize message states among multiple different end user computing devices that are associated with or logged in with the same account. In an embodiment, the synchronization logic also implements real-time message synchronization, so that changes are seen immediately if devices are online. In an embodiment, the synchronization logic also implements offline synchronization so that changes are propagated when the device comes online. Example actions involved in synchronization include create message, delete message, change read receipt (delivered, seen), add\/remove tag.","The Layer platform implements communications in a client\/server model wherein messages are exchanged between clients using the Layer server computer  as an intermediary. On the Layer server computer , threads of communications are modeled as Streams of Events. Each Stream has a set of members that represent the unique people who are communicating. The Stream can be implemented, in one embodiment, as an append-only log, in which each Event represents an activity within the thread of communication between the members. Many of these events are Messages sent by one of the members, but Events also model changes to the Stream itself such as the addition and removal of members, the deletion of previously sent Messages, or other activity such as a typing indicator or presence notification. As each Event is written to the Stream, it is assigned a monotonically increasing sequence number. These sequence numbers are used by the Layer client in order to synchronize local state with the server. A Message, in this context, may be the delivery of text, images, or video content.","For use by an app , the Layer APIs present communications in a different form from Streams and Events as used at the server computer . In one embodiment, the app  interacts with the API using Conversations containing Messages, which may have an arbitrary number of Message Parts. Conversations are threads of communication occurring between two or more Participants. Each Message sent to a Conversation has a particular status value associated with each Participant. The status values are determined based upon Delivery Receipts and Read Receipts and enable clients to determine whether a particular message has been successfully sent, delivered, or read by another participant. Conversations and Messages may be created and sent while the client does not have Internet access and thus cannot communicate with the Layer platform. Such offline content is queued locally on the clients and delivered once connectivity can be re-established.","The use of two different communication models for the Layer client and server enables the system disclosed herein to effectively serve both developers of app  and infrastructure engineers who maintain server computer . For example, developers of app  may prefer a rich, intuitive programming model in which to implement communications, whereas infrastructure engineers working on the server computer  may prefer a simple system that is straightforward to deploy and easy to scale.","For the two models to co-exist while interoperating with a single data set, they may be harmonized when the clients and server interact; harmonization of the models may be implemented in a two phase process termed Synchronization and Reconciliation. In one embodiment, app  is configured to transfer data between the two models using a two phase process termed Synchronization and Reconciliation.","Synchronization is now described. For a Layer client such as app  to harmonize its local Conversations and Messages model with the Streams and Events model of the server computer , the app is configured to synchronize its local database with the canonical representation on the server. In one embodiment, app  is configured to refresh its list of Streams from the server. Refreshing the list of Streams enables the app  to discover any newly created Streams that the app has not yet represented in storage. Refreshing also permits the app  to discover any updates to existing Streams that the app needs to consume. In response to receiving a request to refresh the list of Streams from app , server computer  returns the latest sequence number, which the app may compare to the highest sequence number that the app previously received to determine whether new content is available. Once the client app  has discovered the latest sequence number for all Streams, the app can compute the list of Events that the app needs to request from the server computer , and submit requests for those Events. The server computer  replies by providing the Events, and the app  updates local persistent storage with Streams and Events. Once a client has persisted all of the Streams and Events that it belongs to it is said to be synchronized with the server.","However, in an embodiment, synchronization alone as just described is not sufficient to harmonize a client with the server and enable communications. In an embodiment, the client app  uses a Reconciliation process to transform Events and Streams into a set of database tables at the app representing Conversations, Messages, and Message Parts. To implement Reconciliation, each Layer client maintains two local database tables configured as queues that represent differences between the Streams and Events, on the one hand, and Conversations and Messages on the other. In one embodiment, the local database tables include a Syncable Changes table and Unprocessed Events table. In an embodiment, each row in the Syncable Changes table represents a difference that was created on the local database and needs to be transmitted to the Layer server computer  as a new Event. In an embodiment, each row in the Unprocessed Events table represents an Event that was retrieved from the Layer server computer  and needs to be updated as changes in the Conversations and Messages data of the app .","In an embodiment, Reconciliation is performed in two phases: Outbound and Inbound. Outbound Reconciliation involves the creation and publication of Events for local changes that are queued as Syncable Changes. Inbound Reconciliation involves the processing of Unprocessed Events into changes on the local data model. Once these two queues have been fully processed the client app  is said to be in a Synchronized and Reconciled state.","In one embodiment, the model of Conversations and Messages implemented for an app  is presented via an object oriented interface that abstracts away the underlying storage and transport concerns. Because these objects are local representations of distributed network state, the app  should have the capability to detect changes to the object model that are made by remote instances of the same app, so that the local user interface can be updated to reflect the best current understanding of Conversation state. Producing such live changes to objects held in memory may benefit from the implementation of object identity values that are unique across peer app instances, and a means to apply changes to objects. In an embodiment, the Layer SDK's identify local objects using server-defined identity values, and use a caching layer to ensure unique identity. Once unique object identity is established, change notifications can be emitted by the object that is undergoing a change during the Reconciliation process.","To ensure that objects are globally unique across all instances of a Client app  that may be running on different mobile computing devices, a unique object identifier value is created for each object that is instantiated or retrieved from the local database. For newly instantiated objects, a temporary object identifier is assigned, and later the Layer server computer  assigns a permanent identifier. When an object is retrieved from the database, the object identifier is loaded with all other attribute data.","Using the globally-unique object identifiers, the system can enforce thread and process level uniqueness. In an embodiment, when changed data for an object is to be stored persistently, the Layer client such as app  provides the object identifier to a cache, which attempts to identify an existing object instance for a given object identifier and returns the existing instance or else instantiates a new instance if no existing instance could be found.","The use of object identifiers that are globally unique across all instances of an app enable the system to globally track and notify interested objects of mutations made to the local object graph. To accomplish this, Layer objects maintain a set of object changes that model mutation to the properties of a given object by tracking the name of the property that was changed, its value prior to mutation, and its value after the mutation was made. These values are queued in association with the object until the object is persisted back to the database. At persistence time, all object changes are committed and emitted via a notification back to the public API consumer using a publish-subscribe mechanism.","In one implementation, synchronization is based on users exchanging changelogs with the server. When committing a change the user sends a changelog with his last sync anchor point to the user and gets a new set of changes back. Both user and the server need to apply the received changes. The server will, if needed, inform all of the users which need to be notified about changes waiting on the server. The exchange is performed using Thrift RPC services and structures. Each user can have multiple clients or devices. One user has only one message store and changelog. These are independent between users but are shared between users clients.","In an embodiment, the system defines 3 types of operations. Operation is defined as one change in the changelog. A New message operation sends a message and is a global operation. An Update status operation changes the read receipt status and is a global operation. An Update tags operation creates a new list of tags. Deleting a message can be implemented as a tag. This is a local operation. Some operations only work on a user's message store, while others get applied to recipients messages as well. All parties which get affected by the changes get notified via the SyncUpdate asynchronous notification. The notification is defined on the transport protocol layer.","In an embodiment, the following data structures may be used:",{"@attributes":{"id":"p-0221","num":"0236"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","enum SyncOperationType {"]},{"entry":[{},{},"\u2002NEW_MESSAGE,"]},{"entry":[{},{},"\u2002UPDATE_STATUS,"]},{"entry":[{},{},"\u2002UPDATE_TAGS"]},{"entry":[{},{},"}"]},{"entry":[{},{},"struct NewMessageOp {"]},{"entry":[{},{},"\u20021:optional Message message"]},{"entry":[{},{},"}"]},{"entry":[{},{},"struct UpdateTagsOp {"]},{"entry":[{},{},"\u20021:required list<string> tags"]},{"entry":[{},{},"}"]},{"entry":[{},{},"struct UpdateStatusOp {"]},{"entry":[{},{},"\u20021:required i32 status"]},{"entry":[{},{},"}"]},{"entry":[{},{},"struct UpdateRecepientStateOp {"]},{"entry":[{},{},"\u20021:required i32 state"]},{"entry":[{},{},"\u20022:required MessagingAddress recepient"]},{"entry":[{},{},"}"]},{"entry":[{},{},"struct SyncOperation {"]},{"entry":[{},{},"\u20021:required SyncOperationType type,"]},{"entry":[{},{},"\u20022:optional i32 seq = 0,"]},{"entry":[{},{},"\u20023:required string messageld,"]},{"entry":[{},{},"\u20024:optional NewMessageOp newMessageOp,"]},{"entry":[{},{},"\u20025:optional UpdateTagsOp updateTagsOp,"]},{"entry":[{},{},"\u20026:optional UpdateStatusOp updateStatusOp,"]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The initial anchor point used by the client is 0. In this case all messages will be received by the initiating device. The server will return only the latest version of the message without subsequent changes (or operations) which might have been performed later. After each synchronization request the user receives an anchor point which he must send to the server on the next synchronization request.","When the server receives changes it first removes duplicates. If a certain operation is performed on the same message only the last one is used. All previous changes are discarded. All operations should be in the order in which they are applied. Merging of the changes is performed by the server on any synchronization requests it gets from the client. When the changelog is received it fetches all of its stored changes since the last anchor point and joins the lists. All new operations are written and applied, and new (to the client) are sent as a reply to the client.","Conflict resolution is different depending on operation type. \u201cLast Write Wins\u201d strategy is used in general. In an insert message operation, if the id is the same, then the last message is used. In an update tags operation, all conflicting tags are merged. There are no deletions in this case. In an update status operation, the one with a higher status is chosen. You can never apply decreasing statuses. Thus, Sent<Delivered<Read where Read is the final status.","The client commits its changes by calling the synchronize method on the server. The client can do so whenever the client has pending changes, or when the client receives a SyncUpdate notification from the server. In the later case the committed changes can be empty and only new changes will be received. When the sent changelog is not empty the server performs merging, conflict resolution as described above and notifies all participating parties of available changes. When committing an operation the sequence number or operation identifier should not be set.",{"@attributes":{"id":"p-0226","num":"0241"},"figref":"FIG. 5","b":["144","140"]},{"@attributes":{"id":"p-0227","num":"0242"},"figref":"FIG. 6"},"The synchronization approach herein has numerous technical benefits over the general idea of synchronization. From the perspective of a client computer or client application developer, the synchronization approach appears to involve conversations, metadata, and groups of people, with features such as read, typing, etc. However, the server side code may implement all such items as events. Thus, an embodiment may implement the concept of messages on top of a stream of events. Further, the server algorithm is scalable and reliable because it is configured only to assert with truth that an event happened and to give the event a sequence number; everything else is client-defined.",{"@attributes":{"id":"p-0229","num":"0244"},"figref":["FIG. 14","FIG. 15A","FIG. 15B","FIG. 15C","FIG. 16"]},"In one embodiment, client-server event generation for the purpose of synchronizing multiple client computing devices uses the SQLite database as a foundation, with triggers to maintain an ongoing catalog of changes. As Conversations, Messages and associated metadata models change within the data store, a series of triggers are configured to track interesting changes into a synchronization table, which may be denoted in one example as the syncable_changes table. In an embodiment, the synchronization table has the following schema:",{"@attributes":{"id":"p-0231","num":"0246"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"-- Valid change types enum: INSERT=\u2205, UPDATE=1, DELETE=2 CREATE TABLE"},{"entry":"syncable_changes( \u2003change_identifier INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,"},{"entry":"table_name TEXT NOT NULL, \u2003row_identifier INTEGER NOT NULL, \u2003change_type"},{"entry":"INTEGER NOT NULL, \u2003column_name TEXT );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The synchronization table maintains a log of all client side data model changes that are capable of synchronization, and that have occurred since the completion of the previous synchronization operation. When the synchronization process is ready to create Event objects for local changes, the synchronization process performs the following steps: Open a transaction. Select all rows from the changes table. Iterate across all rows, creating an Event object for each syncable change (as appropriate\u2014not all changes may have corresponding event representations) and deleting the record from the syncable_changes table as it is processed. Publish all pending Events to the server. Reconcile the local Events database with the server (request missing Event sequences). Replay all fetched Events on top of the Messages database, reconciling local state with the events. Commit the transaction.","In an embodiment, the triggers are configured to avoid the creation of additional rows in the synchronization table as the process proceeds. This avoids the need to do book-keeping to determine which rows represent genuine changes as opposed to administrative creations. Once a transaction has been opened for a synchronization operation, the count of syncable rows will only decrease, regardless of externally occurring inserts.","In an embodiment, the synchronization logic is configured to maintain a list of server-originating events that have not yet been applied to the message data model. In an embodiment, maintaining the list is accomplished using a trigger on the Events table:","CREATE TRIGGER queue_events_for_processing AFTER INSERT ON events WHEN NEW.server_sequence IS NOT NULL BEGIN INSERT INTO unprocessed_events(event_database_identifier, created_at) VALUES(NEW.database_identifier, datetime(\u2018now\u2019)); END;","This trigger differentiates between client and server originating events by relying on the fact that local, unpublished events will have a NULL sequence number. Once each queued event has been processed, its row is deleted from the unprocessed_events table. Any events that cannot be processed for whatever reason can remain in the queue for subsequent processing runs.","4. Authentication Logic and Protocol","In an embodiment, an authentication service implements a Layer Authentication Protocol that provides a way for the system herein to authenticate devices and users and secure communications with them, using a federated identity from a third-party provider. At a high level, the Layer Authentication Protocol creates a Transport Layer Security (TLS) connection with a Client, which is used to protect all communication with Layer, but without any notion of identity. Within this TLS connection, there are one or more authentication sessions, bound to a specific user identity, which can be used to perform application actions. Separating these two concepts makes it possible to cache sessions and avoid expensive authentication requests to external servers. Authentication is performed by the Client making a call to a third party identity Provider. The Provider generates a cryptographic token, which verifies the identity of the user of the Client. This token is returned to the Client, and then sent to Layer, which uses it to make an association to an internal Layer user.",{"@attributes":{"id":"p-0239","num":"0254"},"figref":["FIG. 7","FIG. 8","FIG. 7"],"b":["142","142"]},"In the Disconnected state, a TLS socket connection is opened to the Client. If no error occurs during the SSL handshake phase for establishing the connection, then the Client is transitioned to the Certified state which is maintained until the Client or Layer Server breaks the connection.","Referring now to , in one embodiment, a Client begins at the Unauthenticated state and may send a request for a communications service to the Layer server, such as a request to place a phone call, perform a synchronization, or invoke other services. In response, the authentication logic  tests whether the Client is Certified and if not, then enters a wait state until the underlying TLS connection is Certified as seen in . If a Certified secure socket connection exists then the authentication logic  tests whether a valid Session is present.","If no valid Session exists, then the Client app requests a nonce from the authentication logic . Then the authentication logic  tests whether delivery of the nonce was successful; a failure state here is shown in case the authentication logic  generates an error for some reason, and in that case the Client remains in the Unauthenticated state and may re-try. Generating a good nonce results in alerting the nonce to the SDK at the Client. At that point, the Client app  certifies with its server-side Provider  using the nonce and appropriate credentials such as username and password, or token, and the Provider returns an Identity Token to indicate that the Provider authenticated the Client. A wait state and test are provided in the process of  to await return of the Identity Token that the Client obtained from the app's Provider. The authentication logic  next creates a Session that includes an application ID and signature, and a session token. The session details may be persistently stored in the repository .","The authentication logic  then authenticates a herald connection and opens channels. Success in these operations results in transitioning the Client to the Authenticated state. If the connection is destroyed, as by revocation of the certificate, then the process is repeated; a challenge also may occur at any state. Challenges contain a new nonce. The old signature token and session token are discarded and renegotiated.",{"@attributes":{"id":"p-0244","num":"0259"},"figref":"FIG. 9","b":["142","130"]},"In an embodiment, Layer authentication maintains two state machines: Connection State and Authentication State. These state machines are separate but related, with Authentication State nested within Connection State. Connection State models the physical connection of a Client with Layer. This connection is intended to secure the low level connection, to prevent eavesdropping and provide a consistent context for identity session management and resumption. Connection State doesn't address user identity or authentication; these are modeled by Authentication State.  illustrates an example Connection State Diagram.","In the Uncertified state, allowed actions are Certify. In this state, the Client has never communicated with Layer, or has had its certification revoked. This represents a new Client with no TLS client certificate, or an existing Client with an invalid TLS client certificate. In the Disconnected state, allowed actions are Connect. The Client is not connected with Layer, but has been certified by Layer. This represents a new Client with a valid TLS client certificate, but no TLS connection with Layer.","The intent of the certification process is to have a consistent context within which to perform authentication. Ideally, certification should happen only once, and certificates will have a long lifetime, in the range of years. However, Layer may revoke this certification at any time, and clients must be prepared to return to Uncertified and restart the process at any time. A secondary goal is to provide a hook for device validation, for anti-abuse purposes. In one embodiment, the system can obtain a CAPTCHA value as part of the certification. After performing the Certify operation, the socket that was used is terminated. Subsequent requests are received on a new socket, to create a new TLS session using the newly issued certificate.","In the Connected state, allowed actions are Disconnect. In this state, the Client is connected to Layer. This represents a Client with live TLS connection with Layer. The connection is initiated by Client, and is established using a standard TLS handshake with client certificate authentication. Client must validate Layer's certificate against its trust chain, and also pin the certificate to the embedded Layer fingerprint. Layer must validate Client's certificate against its internal CA. The Connected state doesn't imply anything about identity or authentication. This is modeled separately by the nested Authentication State. The Connected state only provides eavesdropping protection for the communication between Client and Layer.","In an embodiment, the Authentication State models the authentication and user identity of a Client. This allows a Client to establish an identity session which can be used when communicating with Layer. The identity of a Client is used to attribute the source of events and the ownership of content within Layer applications. The identity of a Client is provided by an external Provider, but managed by Layer.  illustrates an example Authentication State Diagram.","In the Unauthenticated state, allowed actions are CreateSession. In this state, the Client is not authenticated. This represents a Client with no identity session, for instance because the Client has never authenticated, or was authenticated but subsequently logged out. A Client in this state can't perform any application actions, but it can create a new identity session.","In the Authenticated state, allowed actions are DestroySession, Challenge. In this state, the Client is authenticated to Layer. This represents a Client with a valid identity session. A Client in this state can perform all application actions, which will be associated with the identity.","In the Challenged state, allowed actions are RenewSession, DestroySession. In this state, the Client was authenticated to Layer, but has been challenged. This represents a Client with a previous identity session that's no longer valid, for instance because of timeout or other security restriction. A Client in this state can't perform any application actions, but it can renew the previous identity session, retaining the same underlying identity.","The Connection State and Authentication State machines are largely independent. Connection State models the state of the TLS session, and Authentication State models the state of a user identity session, one or more of which can exist inside the context of a Connection State. However, Connection State can restrict available actions in Authentication State. In summary, in the Connected states, all allowed actions are available. When the Client is Disconnected, only DestroySession is available; as a result, Authenticated and Challenged can move to Unauthenticated, but no other transitions are available.  illustrates a nested state diagram for both the Connection State and Authentication State logic.","In an embodiment, the logic herein uses federated identities issued by an external Provider. A Client's external identity captured in the external Identity Token, which is a cryptographic object asserting a set of claims that are made by Provider regarding the Client. The external Identity Token is obtained from Provider before the Client calls the CreateSession action, using an out-of-band authentication request to Provider. In implementing that authentication request, the Provider may use any appropriate means; an example would be application logic that collects a login and password, submits these credentials to an existing back end authentication mechanism, then returns the external Identity Token. When generating the external Identity Token, in addition to its own credentials, the Provider may obtain a Nonce generated by Layer. In various embodiments, the Nonce can be obtained explicitly, by calling the GetNonce action, or as a side effect of an action that returns STATUS_NEW_SESSION_NEEDED and an accompanying Nonce; the latter approach can save a network round trip. In an embodiment, application logic submit these along with any external credentials to the Provider.",{"@attributes":{"id":"p-0255","num":"0270"},"figref":["FIG. 13","FIG. 13","FIG. 13"],"b":"110"},"As seen in , an Unauthenticated Client requests a nonce by calling the GetNonce action, or initiates an action that returns STATUS_NEW_SESSION_NEEDED. In reply, Layer generates a random or pseudo-random Nonce and provides it to Client. The Client then collects credentials from a user that relate to an external authentication provider; for example, app  may prompt a user to enter a username and password. The Client sends these credentials, with the Nonce, to the external Provider, which validates the credentials. If validation is successful, then the Provider generates an Identity Token that includes the Nonce and a user identifier for the user of the Client app ; the Identity Token may be encrypted using the previously negotiated long-lived session key. The Provider returns the Identity Token to the Client, which does not use it but forwards the Identity Token to Layer with a CreateSession request. Layer then decrypts or otherwise validates the Identity Token and, if successful, generates a Session and binds the user identifier to a session identifier.","By this efficient, federated process, the Layer server computer  can establish a trust relationship with the user of the Client app  without managing passwords, tokens or other credentials of users. As a result, a large number of app developers can connect apps in a secure manner to Layer communications services without having to disclose user credentials to Layer. Further, this process permits initially creating a secure connection between Client and Layer, using SSL, TLS or another protocol, without having identity information for a user of the Client app ; later, after the user has authenticated itself to a third-party Provider, user identifying information becomes bound to the Layer session and therefore to the secure connection.","In an embodiment, the following message header and payload definitions may be used. While the protocol actions set forth below are given in generic form, in practice, they should be bound to a particular transport (e.g., the Herald Thrift binding) in the idiomatic manner of that transport.",{"@attributes":{"id":"p-0259","num":"0274"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ACTIONS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Field","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Certify - Action"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Request","csr","ByteArray","Certification request in Layer CSR format (see below)"]},{"entry":["Response","cert","ByteArray","Standard RFC 5280 (X.509) certificate in DER format"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Notes","The Certify action validates a Client and issues a new TLS client certificate."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"GetNonce - Action"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["REQ","<NONE>",{},{}]},{"entry":["RES","status","Integer","zero for success, non-zero for failure"]},{"entry":[{},"nonce","ByteArray","A cryptographic nonce, to be used in a subsequent call to"]},{"entry":[{},{},{},"CreateSession"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Notes","The GetNonce action obtains a new cryptographic nonce, for use in identifying a single"]},{"entry":[{},"authentication flow. Nonces are random and time bound, to avoid replay attacks. In addition to"]},{"entry":[{},"calling the GetNonce action, nonces can be obtained as a side effect of another action which fails"]},{"entry":[{},"with STATUS_NEW_SESSION_REQUIRED, and thus returns a nonce."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CreateSession - Action"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["REQ","ext-id-token","String","External Identity Token in Layer EIT format (see below)"]},{"entry":["RES","status","Integer","Zero for success, non-zero for failure"]},{"entry":[{},"user-id","String","The Layer internal user id"]},{"entry":[{},"session-token","ByteArray","The Layer session token, to be used in subsequent actions to identify"]},{"entry":[{},{},{},"this session"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["NOTES","The CreateSession action creates a new external identity session within a connection. Multiple"]},{"entry":[{},"sessions can be active at once."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"ResumeSession - Action"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["REQ","user-id","String","The Layer internal user id, cached from a previous call to"]},{"entry":[{},{},{},"CreateSession"]},{"entry":[{},"session-token","ByteArray","The Layer session token, cached from a previous call to CreateSession"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CreateSession - Action"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["RES","status","Integer","Zero for success, non-zero for failure"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0260","num":"0275"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"FORMATS"},{"entry":"Layer CSR - Format"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Field","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Header","typ","String = \u201cJWS\u201d","JSON Web Signature"]},{"entry":[{},"cty","String = \u201clayer-csr; v = 1","Layer Certification"]},{"entry":[{},{},{},"Request, version 1"]},{"entry":[{},"alg","String = \u201cRS256\u201d","Signature algorithm,"]},{"entry":[{},{},{},"RSASSA-PKCS-v1_5"]},{"entry":[{},{},{},"using SHA-256"]},{"entry":["Payload","uat","String","Layer User Agent"]},{"entry":[{},"prn","String","Layer Device ID (TBD;"]},{"entry":[{},{},{},"for now, client-generated"]},{"entry":[{},{},{},"UUID is OK)"]},{"entry":[{},"pka","String = \u201cRSA\u201d","Public key algorithm, RSA"]},{"entry":[{},"pky","Base64 String","Public key bytes"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Notes","The Layer CSR format is used in the Certify action"]},{"entry":[{},"to specify the client parameters for certification."]},{"entry":[{},"It is a string in JWS format, compact serialization."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In another embodiment, rather than using an application-layer messaging protocol, authentication may be implemented in the transport layer using HTTP and SPDY. In such an approach, standard WWW-Authenticate & Authorization headers are used. On unauthorized requests, server replies with status , and WWW-Authenticate header containing realm and nonce fields. Then the Client retries with Authorization header containing identity-token field. On successful requests, server replies with status , and X-Layer-User-ID, X-Layer-Session-Token and X-Layer-Session-TTL headers, to be used as an optimization by the client. Thereafter, client can optimize by sending Authorization header containing only session-token field. An example is:",{"@attributes":{"id":"p-0262","num":"0277"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\u2003***** REQUEST ***** GET \/nonce HTTP\/1.1"},{"entry":"\u2003\u2003\u2003\u2003***** RESPONSE ***** HTTP\/1.0 401 Unauthorized WWW-Authenticate: Layer"},{"entry":"realm=\u201cdonthardwireme.layer.com\u201d nonce=\u201cuGrmKJv2u6hv2Xo9Ne86==\u201d"},{"entry":"\u2003\u2003\u2003\u2003***** REQUEST ***** GET \/action HTTP\/1.1 Authorization: Layer"},{"entry":"realm=\u201cdonthardwireme.layer.com\u201d identity-"},{"entry":"token=\u201cewogICAgInR5cCI6ICJK...1V3fxxuBCj1DpQphoIAg\u201d"},{"entry":"\u2003\u2003\u2003\u2003***** RESPONSE ***** HTTP\/1.0 200 OK X-Layer-User-ID: C2459744-31C7-"},{"entry":"442D-B93D-17A46420752B X-Layer-Session-Token: pQilXCGBf9fCfxThSwStdQ, "},{"entry":"X-Layer-Session-TTL: 86400"},{"entry":"\u2003\u2003\u2003\u2003***** REQUEST ***** GET \/action HTTP\/1.1 Authorization: Layer session-"},{"entry":"token=\u201cpQilXCGBf9fCfxThSwStdQ,\u201d"},{"entry":"\u2003\u2003\u2003\u2003***** RESPONSE ***** HTTP\/1.0 200 OK X-Optimization-Headers: Not Sent "},{"entry":"This Time"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Client applications participate in authentication by calling specific server methods and implementing specific logic. In an embodiment, client certificates are used to establish TLS sessions. In an embodiment, when an app on a device uses the server logic for the first time, the app obtains a certificate signed by Layer to establish a herald connection. In one approach, the app is configured to generate CSR on the device and POST the CSR to an HTTP endpoint for this purpose. An example POST is:","POST auth.layer.com\/certificates { \u201ccsr\u201d: \u201cegaijseap3q2n3npa8jpa9jqwh38pq92j3p . . . \u201d}","And returns:","OK { \u201ccertificate\u201d: \u201cMIIHI21NLKN1231 . . . \u201d}","The certificate may be provided in PEM format. In one approach, certificates are long lasting, but apps are configured to repeat the foregoing process if the TLS connection fails as unauthorized or because the certificate expired or was revoked. Once a TLS session is established, a nonce is used to assist in identifying the application session. In an embodiment, the nonce is a random or pseudo-random string that is provided by the server logic to uniquely identify and track the authentication flow.",{"@attributes":{"id":"p-0267","num":"0282"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","string getNonce( ) throws (1:exceptions.PlatformException "]},{"entry":[{},"platformExc,"]},{"entry":[{},"2:exceptions.ApplicationException appExc)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In an embodiment, the nonce is sent to the provider to be incorporated into a signature that proves the identity of the app. This step may be implemented by the server logic exposing a hook or callback that developers complete when developing an app with the SDK.","public abstract String requestSignature(String nonce);","In an embodiment, the foregoing method is filled in with a request back to the app's existing back end authentication mechanism to obtain the signature as described in the specification; this process returns a string comprising JWT token, but from the SDK's perspective it can be treated as a black box.","A session with a new user then can be created. In an embodiment, two different ways to log in are provided, depending on whether or not the user has an account at the server computer. If the user does not have such an account, then the app is configured to create one.",{"@attributes":{"id":"p-0272","num":"0287"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","data.Session createSession(1:string app_id, 2:string signature) throws"]},{"entry":[{},"(1:exceptions.PlatformException platformExc, "]},{"entry":[{},"2:exceptions.ApplicationException appExc)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In response, the server logic provides an AuthResponse containing the address of a new account and a session token for use to authenticate. The session token returned by createSession can be used to resume a previously created Session by directly authenticating with Herald. The app may be configured to handle an Authentication challenge when the app attempts this operation. As a client-side optimization, the app can check the expiration date of the Session before attempting to resume. In an embodiment, logging out deletes the access token, thus forcing a new signature.","5. VOIP Kit","In an embodiment, the communications logic implements a plurality of methods and function calls that communications applications may use to perform specified communications functions. In one embodiment, an example communications function is establishing a phone call between a calling party (a Caller) and a called party (a Callee). The methods and function calls may be packaged in a software development kit (\u201cSDK\u201d or \u201cKit\u201d herein).","In one embodiment, a VoIP Call Establishment Process is implemented. In an embodiment, the Call Establishment Process starts using a STUN request to a publicly available STUN server that is located in the Layer Cloud Infrastructure. In response, the LYRVoipKit obtains its PUBLIC ADDRESS (that means globally routable unicast IP address) and port number. Simultaneously the LOCAL ADDRESS of the user's device is obtained from a networking interface device. Optionally LYRVoipKit can also send a TURN Allocation Request to a TURN server to retrieve a RELAYED ADDRESS.","When these addresses have been collected, a VoIPCallRequestMessage is composed, serialized and sent through the Layer System Messaging Channel to a Callee contact.","The caller device then generates a unique random alphanumeric security token (CALLER TOKEN) that is a part of VoIPCallRequestMessage. The VoIPCallRequestMessage is broadcast to all callee devices that are then currently logged in to the system.","In response to receiving a VoIPCallRequestMessage, the LYRVoIPKit at each callee's device initiates an address discovery procedure in the same manner described above for a Caller. When the addresses have been collected, the callee generates a security token (CALLEE TOKEN), serializes and sends a VoIPCallResponseMessage within a Layer System Message.","Approximately simultaneously, the callee sends STUN Binding Requests to all the addresses that it received via the VoIPCallRequestMessage. These requests start a UDP hole punching procedure. The STUN Binding Requests contain the CALLER TOKEN as the NONCE STUN Attribute.","After the VoIPCallResponseMessage is delivered to a LYRVoipKit on the caller's side, the caller sends STUN Binding Requests to all the callee's addresses.","When one or more of the STUN Binding Requests is received on the callee side or the caller side, the STUN server component of LYRVoIPKit performs steps as follows:","Match token from NONCE STUN Attribute with CALLEE or CALLER TOKEN received in VoIPCallRequest\/ResponseMessage","If no token is matched, silently discard the STUN Request.","If token is matched, then respond with a STUN Binding Success message.","Reception of the STUN Binding Success message on the caller side indicates that the UDP hole punching procedure succeeded, and thus a peer to peer IAX2 VoIP call can be established.","The caller originates an IAX2 call to all callee devices. Every call is originated with the IAX2 extension set to CALLEE TOKEN. If the LYRVoipKit at a callee receives a call to the IAX2 extension that does not match with any CALLEE TOKEN, then the call is rejected. Otherwise, the call is accepted.","In an embodiment, the first call that is picked up becomes the actual call, and any other receives a hang-up from the caller.","References: IAX2 Protocol spec\u2014http:\/\/tools.ietf.org\/html\/rfc5456; STUN Protocol spec\u2014http:\/\/tools.ietforg\/html\/rfc3489; http:\/\/tools.ietf.org\/html\/rfc5389; TURN Protocol spec\u2014http:\/\/tools.ietf.org\/html\/rfc5766; State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs)\u2014http:\/\/tools.ietforg\/html\/rfc5128","6. User Interface Kit","This section describes the design and implementation of an example of Layer UI logic , for use with APPLE IOS software. In an embodiment, There are currently three UI components that specified in this document as examples: Participant Picker\u2014Presents a view for selecting participants in order to begin a conversation. Conversation List\u2014Presents a list of all existing conversations for resuming communication on a previous conversation. Conversation View\u2014Presents a view of all messages in a conversation that includes the ability to compose and send new messages.","In one embodiment, the participant picker component provides a scrollable, selectable, optionally searchable list of people that the user may wish to engage in a conversation. Unlike other components in the UI kit, this component is driven by an application defined data model (because Layer does not have an internal notion of users). Supports single and multiple selection modes. Provides support for asynchronously searching the list of participants. Integrates with an external model of a User\/Contact",{"@attributes":{"id":"p-0293","num":"0308"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/** @abstract The \u2018LYRUIParticipant\u2018 protocol must be adopted by objects wishing to represent"},{"entry":"Layer participants in the user interface. *\/"},{"entry":"@protocol LYRUIParticipant <NSObject>"},{"entry":"\/** @abstract The full name of the participant as it should be presented in the user interface. *\/"},{"entry":"@property (nonatomic, readonly) NSString *fullName;"},{"entry":"\/**"},{"entry":"@abstract The unique identifier of the participant as it should be used for Layer addressing."},{"entry":"@discussion This identifier is issued by the Layer identity provider backend."},{"entry":"*\/"},{"entry":"@property (nonatomic, readonly) NSString *participantIdentifier;"},{"entry":"\/**"},{"entry":"@abstract Returns the avatar image of the receiver."},{"entry":"*\/"},{"entry":"@property (nonatomic, readonly) UIImage *avatarImage;"},{"entry":"\/**"},{"entry":"@abstract Returns the text to be used for sectioning."},{"entry":"@discussion Typically the first name, last name, or company name is used for sectioning."},{"entry":"*\/"},{"entry":"@property (nonatomic, readonly) NSString *sectionText;"},{"entry":"@end"},{"entry":"\/**"},{"entry":"@abstract The \u2018LYRUIParticipantPresenting\u2018 protocol must be adopted by objects that wish to"},{"entry":"present Layer"},{"entry":"participants in the user interface."},{"entry":"*\/"},{"entry":"@protocol LYRUIParticipantPresenting <NSObject>"},{"entry":"\/**"},{"entry":"@abstract Tells the receiver to present an interface for the given participant."},{"entry":"@param participant The participant to present."},{"entry":"*\/"},{"entry":"\u2212 (void)presentParticipant:(id<LYRUIParticipant>)participant;"},{"entry":"@end"},{"entry":"@protocol LYRUIParticipantPickerControllerDataSource,"},{"entry":"LYRUIParticipantPickerControllerDelegate;"},{"entry":"\/**"},{"entry":"@abstract The \u2018LYRUIParticipantPickerController\u2018 class presents a user interface that allows"},{"entry":"the selection of one or more"},{"entry":"Layer participants."},{"entry":"*\/"},{"entry":"@interface LYRUIParticipantPickerController : UINavigationController"},{"entry":"\/\/\/------------------------------------"},{"entry":"\/\/\/ @name Creating a Participant Picker"},{"entry":"\/\/\/------------------------------------"},{"entry":"\/**"},{"entry":"@abstract Creates and returns a participant picker initialized with the given set of participants."},{"entry":"@param dataSource The data source managing a collection of \u2018LYRUIParticipant\u2018 objects with"},{"entry":"which to drive the participant picker."},{"entry":"@returns A new participant picker initialized with the given data source."},{"entry":"@raises NSInvalidArgumentException Raised if any object in the set of participants returned by"},{"entry":"the data source does not conform to the \u2018LYRUIParticipant\u2018 protocol."},{"entry":"*\/"},{"entry":"+"},{"entry":"(instancetype)participantsPickerWithDataSource:(id<LYRUIParticipantPickerControllerDataSou"},{"entry":"rce>)dataSource;"},{"entry":"\/\/\/----------------------------------------"},{"entry":"\/\/\/ @name Accessing the Picker Data Source & Delegate"},{"entry":"\/\/\/----------------------------------------"},{"entry":"\/**"},{"entry":"@abstract The receiver's data source. Cannot be \u2018nil\u2018."},{"entry":"*\/"},{"entry":"@property (nonatomic, weak, readonly) id<LYRUIParticipantPickerControllerDataSource>"},{"entry":"dataSource;"},{"entry":"\/**"},{"entry":"@abstract The receiver's delegate."},{"entry":"*\/"},{"entry":"@property (nonatomic, weak) id<LYRUIParticipantPickerControllerDelegate> delegate;"},{"entry":"\/\/\/---------------------------------"},{"entry":"\/\/\/ @name Configuring Picker Options"},{"entry":"\/\/\/---------------------------------"},{"entry":"\/**"},{"entry":"@abstract A Boolean value that determines whether multiple participants can be selected at"},{"entry":"once."},{"entry":"@discussion The defauly value of this property is \u2018YES\u2018."},{"entry":"*\/"},{"entry":"@property (nonatomic, assign) BOOL allowsMultipleSelection;"},{"entry":"\/**"},{"entry":"@abstract The table view cell class for customizing the display of participants."},{"entry":"@default \u2018[LYRUIParticipantTableViewCell class]\u2018"},{"entry":"@raises NSInternalInconsistencyException Raised if the value is mutated after the receiver has"},{"entry":"been presented."},{"entry":"*\/"},{"entry":"@property (nonatomic) Class<LYRUIParticipantPresenting> cellClass;"},{"entry":"\/**"},{"entry":"@abstract Configures the height of each row in the receiver."},{"entry":"@default 44.0f"},{"entry":"@raises NSInternalInconsistencyException Raised if the value is mutated after the receiver has"},{"entry":"been presented."},{"entry":"*\/"},{"entry":"@property (nonatomic, assign) CGFloat rowHeight;"},{"entry":"@end"},{"entry":"\/**"},{"entry":"@abstract Objects wishing to act as the data source for a participant picker must adopt the"},{"entry":"\u2018LYRUIParticipantsPickerDataSource' protocol."},{"entry":"*\/"},{"entry":"@protocol LYRUIParticipantsPickerDataSource <NSObject>"},{"entry":"\/**"},{"entry":"@abstract The set of participants to be presented in the picker. Each object in the returned"},{"entry":"collection must conform to the \u2018LYRUIParticipant\u2018 protocol."},{"entry":"@discussion The picker presents the returned participants in alphabetical order sectioned by the"},{"entry":"value returned by the \u2018sectionText\u2018 property."},{"entry":"*\/"},{"entry":"@property (nonatomic, readonly) NSSet *participants;"},{"entry":"\/**"},{"entry":"@abstract Asynchronously searches for participants that match the given search text."},{"entry":"@discussion Invoked by the participant picker controller when the user inputs text into the"},{"entry":"search bar. The receiver is"},{"entry":"to perform the search, build a set of matching participants, and then call the completion block."},{"entry":"The controller will section"},{"entry":"the participants using the value returned by the \u2018sectionText\u2019 property and present them in"},{"entry":"alphabetical order."},{"entry":"*\/"},{"entry":"\u2212 (void)searchForParticipantsMatchingText:(NSString *)searchText completion:(void ({circumflex over (\u2009)})(NSSet"},{"entry":"*participants))completion;"},{"entry":"@end"},{"entry":"\/**"},{"entry":"@abstract The \u2018LYRUIParticipantPickerControllerDelegate\u2018 protocol must be adopted by"},{"entry":"objects that wish to act"},{"entry":"as the delegate for a \u2018LYRUIParticipantPickerController\u2018 object."},{"entry":"*\/"},{"entry":"@protocol LYRUIParticipantPickerControllerDelegate <NSObject>"},{"entry":"\/**"},{"entry":"@abstract Tells the receiver that the participant selection view was dismissed without making a"},{"entry":"selection."},{"entry":"@param participantSelectionViewController The participant selection view that was dismissed."},{"entry":"*\/"},{"entry":"\u2212 (void)participantSelectionViewControllerDidCancel:(LYRUIParticipantPickerController"},{"entry":"*)participantSelectionViewController;"},{"entry":"\/**"},{"entry":"@abstract Tells the receiver that the user has selected a set of participants from a participant"},{"entry":"selection view."},{"entry":"@param participantSelectionViewController The participant selection view in which the"},{"entry":"selection was made."},{"entry":"@param participants The set of participants that was selected."},{"entry":"*\/"},{"entry":"\u2212 (void)participantSelectionViewController:(LYRUIParticipantPickerController"},{"entry":"*)participantSelectionViewController didSelectParticipants:(NSSet *)participants;"},{"entry":"@end"},{"entry":"\/**"},{"entry":"@abstract The \u2018LYRUIParticipantTableViewCell\u2018 class provides a lightweight, customizable"},{"entry":"table"},{"entry":"view cell for presenting Layer conversation participants."},{"entry":"*\/"},{"entry":"@interface LYRUIParticipantTableViewCell : UITableViewCell"},{"entry":"<LYRUIParticipantPresenting>"},{"entry":"\/\/ TODO: Add appropriate properties with UI Appearance selectors."},{"entry":"@end"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The Conversation List component presents a scrollable, selectable, searchable list of conversations that the user may wish to re-engage with. The view is driven by Layer messaging models. Supports searching for conversations with messages matching text (requires new SDK support). Optionally supports editing of the conversations list (i.e. edit mode with multi-delete and swipe to delete). Supports the selection of a single conversation from the list. Performs live update when a new conversation is synchronized. Works with option for soft delete in the SDK.",{"@attributes":{"id":"p-0295","num":"0310"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"@protocol LYRUIConversationListViewControllerDelegate;"},{"entry":"\/**"},{"entry":"@abstract The \u2018LYRUIConversationListViewController\u2018 class presents an interface allowing"},{"entry":"for the display, selection, and searching of Layer conversations."},{"entry":"*\/"},{"entry":"@interface LYRUIConversationListViewController : UINavigationController"},{"entry":"\/\/\/---------------------------------------"},{"entry":"\/\/\/ @name Initializing a Conversation List"},{"entry":"\/\/\/---------------------------------------"},{"entry":"\/**"},{"entry":"@abstract Creates and returns a new conversation list initialized with the given Layer client."},{"entry":"@param layerClient The Layer client from which to retrieve the conversations for display."},{"entry":"@return A new conversation list controller."},{"entry":"*\/"},{"entry":"+ (instancetype)conversationListViewControllerWithLayerClient:(LYRClient *)layerClient;"},{"entry":"\/**"},{"entry":"@abstract The delegate for the receiver."},{"entry":"*\/"},{"entry":"@property (nonatomic, weak) id<LYRUIConversationListViewControllerDelegate> delegate;"},{"entry":"\/\/\/----------------------------------------"},{"entry":"\/\/\/ @name Customizing the Conversation List"},{"entry":"\/\/\/----------------------------------------"},{"entry":"\/**"},{"entry":"@abstract A Boolean value that determines if editing is enabled."},{"entry":"@discussion When \u2018YES\u2018, an Edit button item will be displayed on the left hand side of the"},{"entry":"receiver's navigation item that toggles the editing state of the receiver."},{"entry":"@default \u2018YES\u2018"},{"entry":"@raises NSInternalInconsistencyException Raised if the value is mutated after the receiver has"},{"entry":"been presented."},{"entry":"*\/"},{"entry":"@property (nonatomic, assign) BOOL allowsEditing;"},{"entry":"\/**"},{"entry":"@abstract The table view cell class for customizing the display of the conversations."},{"entry":"@default \u2018[LYRUIConversationTableViewCell class]\u2018"},{"entry":"@raises NSInternalInconsistency Exception Raised if the value is mutated after the receiver has"},{"entry":"been presented."},{"entry":"*\/"},{"entry":"@property (nonatomic) Class<LYRUIConversationPresenting> cellClass;"},{"entry":"\/**"},{"entry":"@abstract Sets the height for cells within the receiver."},{"entry":"@default \u201844.0\u2018"},{"entry":"@raises NSInternalInconsistencyException Raised if the value is mutated after the receiver has"},{"entry":"been presented."},{"entry":"*\/"},{"entry":"@property (nonatomic, assign) CGFloat rowHeight;"},{"entry":"@end"},{"entry":"@protocol LYRUIConversationListViewControllerDelegate <NSObject>"},{"entry":"\/**"},{"entry":"@abstract Tells the delegate that a conversation was selected from a conversation list."},{"entry":"@param conversationListViewController The conversation list in which the selection occurred."},{"entry":"@param conversation The conversation that was selected."},{"entry":"*\/"},{"entry":"\u2212 (void)conversationListViewController:(LYRUIConversationListViewController"},{"entry":"*)conversationListViewController didSelectConversation:(LYRConversation *)conversation;"},{"entry":"\/**"},{"entry":"@abstract Tells the delegate that the conversation list was dismissed without making a selection."},{"entry":"@param conversationListViewController The conversation list that was dismissed."},{"entry":"*\/"},{"entry":"\u2212 (void)conversationListViewControllerDidCancel:(LYRUIConversationListViewController"},{"entry":"*)conversationListViewController;"},{"entry":"\/**"},{"entry":"@abstract Asks the delegate for the Conversation Label for a given set of participants in a"},{"entry":"conversation."},{"entry":"@param participants The identifiers for participants in a conversation within the conversation"},{"entry":"list."},{"entry":"@param conversationListViewController The conversation list in which the participant appears."},{"entry":"@return The conversation label to be displayed for a given conversation in the conversation list."},{"entry":"*\/"},{"entry":"\u2212 (NSString *)conversationLabelForParticipants:(NSSet *)participants"},{"entry":"inConversationListViewController:(LYRUIConversationListViewController"},{"entry":"*)conversationListViewController;"},{"entry":"@end"},{"entry":"\/**"},{"entry":"@abstract The \u2018LYRUIConversationPresenting\u2018 protocol must be adopted by any view"},{"entry":"component"},{"entry":"that wishes to present a Layer conversation object."},{"entry":"*\/"},{"entry":"@interface LYRUIConversationPresenting <NSObject>"},{"entry":"\/**"},{"entry":"@abstract Tells the receiver to present a given Layer Conversation."},{"entry":"@param conversation The conversation to present."},{"entry":"*\/"},{"entry":"\u2212 (void)presentConversation:(LYRConversation *)conversation;"},{"entry":"@end"},{"entry":"\/**"},{"entry":"@abstract The \u2018LYRUIConversationTableViewCell\u2018 class provides a lightweight, customizable"},{"entry":"table"},{"entry":"view cell for presenting Layer conversation objects."},{"entry":"*\/"},{"entry":"@interface LYRUIConversationTableViewCell : UITableViewCell"},{"entry":"<LYRUIConversationPresenting>"},{"entry":"@property (nonatomic) UIFont *titleFont UI_APPEARANCE_SELECTOR;"},{"entry":"@property (nonatomic) UIColor *titleColor UI_APPEARANCE_SELECTOR;"},{"entry":"@property (nonatomic) UIFont *subtitleFont UI_APPEARANCE_SELECTOR;"},{"entry":"@property (nonatomic) UIColor *subtitleColor UI_APPEARANCE_SELECTOR;"},{"entry":"@end"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The Conversation List component provides an iMessage-like messaging experience for communicating with the participants in a Layer Conversation. Supports Person to Person or Group conversations. Support for sending messages. Supports the embedding of images\/videos into new messages. Live updates in response to incoming messages. Supports \u201cLoad More\u201d functionality when the top of history is reached but there is still unsynchronized content",{"@attributes":{"id":"p-0297","num":"0312"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**"},{"entry":"Required Reading:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"*"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"https:\/\/developer.apple.com\/library\/ios\/documentation\/WindowsViews\/Conceptual\/CollectionVie"},{"entry":"wPGforIOS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"* http:\/\/www.objc.io\/issue-3\/collection-view-layouts.html"]},{"entry":[{},"* https:\/\/github.com\/objcio\/issue-3-collection-view-layouts"]},{"entry":[{},"* http:\/\/skeuo.com\/uicollectionview-custom-layout-tutorial"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"*\/"},{"entry":"@protocol LYRUIConversationViewControllerDataSource;"},{"entry":"\/**"},{"entry":"Expectations:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"* Uses collection view"]},{"entry":[{},"* Messages are grouped into sections by time. When a new time period is encountered you"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"create a section. I\u2019m guessing we use intervals of like 15-30 mins (maybe configurable)"},{"entry":"*\/"},{"entry":"@interface LYRUIConversatioriViewController : UIViewController"},{"entry":"+ (instancetype)conversationViewControllerWithConversation:(LYRConversation"},{"entry":"*)conversation;"},{"entry":"@property (nonatomic, weak) LYRUIConversationViewControllerDataSource *dataSource;"},{"entry":"@property (nonatomic, readonly) LYRUIMessageInputToolbar *inputToolbar;"},{"entry":"@property (nonatomic, assign) BOOL allowsEditing;"},{"entry":"@end"},{"entry":"@protocol LYRUIConversationViewControllerDataSource <NSObject>"},{"entry":"\u2212 (id<LYRUIParticipant>)conversationViewController:(LYRUIConversationViewController"},{"entry":"*)conversationViewController participantForIdentifier:(NSString *)participantIdentifier;"},{"entry":"\/\/nil suppresses the behavior?"},{"entry":"\u2212 (NSString *)conversationViewController:(LYRUIConversationViewController"},{"entry":"*)conversationViewController attributedStringForDisplayOfDate:(NSDate *)date;"},{"entry":"\u2212 (NSString *)conversationViewController:(LYRUIConversationViewController"},{"entry":"*)conversationViewController"},{"entry":"attributedStringForDisplayOfRecipientStatus:(LYRRecipientStatus)recipientStatus;"},{"entry":"@end"},{"entry":"@protocol LYRUIMessagePresenting <NSObject>"},{"entry":"\u2212 (void)presentMessage:(LYRMessage *)message"},{"entry":"fromParticipant:(id<LYRUIParticipant>)participant;"},{"entry":"@end"},{"entry":"@interface LYRUIMessageCollectionViewCell : UICollectionViewCell"},{"entry":"<LYRUIMessagePresenting>"},{"entry":"\/\/ TODO: Define the UIAppearance enabled accessors"},{"entry":"@end"},{"entry":"@interface LURUIIncomingMessageCollectioriViewCell : LYRUIMessageCollectionViewCell"},{"entry":"@end"},{"entry":"@interface LURUIOutgoingMessageCollectionViewCell : LYRUIMessageCollectionViewCell"},{"entry":"@end"},{"entry":"@interface LYRUIMessageInputToolbar : UIToolbar"},{"entry":"\/\/auto-resizing message composition field"},{"entry":"@property (nonatomic) UIMessageComposeTextView *textView;"},{"entry":"\/\/ When set, draws to the left of the compose text area. Default to \u2018nil\u2019"},{"entry":"@property (nonatomic) UIButton *accessoryButton;"},{"entry":"@end"},{"entry":"\/\/Auto-resizing. Support insertion of audio and videos?"},{"entry":"@interface UIMessageComposeTextView : UITextView"},{"entry":"\u2212 (void)insertImage:(UIImage *)image;"},{"entry":"\u2212 (void)insertVideoAtPath:(NSString *)videoPath;"},{"entry":"@end"},{"entry":"\/**"},{"entry":"@discussion Lays out cells with the following rules:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1. Participant avatar decoration views are draw to the left of incoming message cells."]},{"entry":[{},"2. Header accessory views for the participant name are drawn above each incoming message"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"cell"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"3. A date footer is drawn below each message whose next message occurred >= 15 mins"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"*\/"},{"entry":"@interface LYRUIConversationCollectionViewFlowLayout : UICollectionViewFlowLayout"},{"entry":"@end"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"7. Implementation Example\u2014Hardware Overview","According to one embodiment, the techniques described herein are implemented by one or more special-purpose computing devices. The special-purpose computing devices may be hard-wired to perform the techniques, or may include digital electronic devices such as one or more application-specific integrated circuits (ASICs) or field programmable gate arrays (FPGAs) that are persistently programmed to perform the techniques, or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware, memory, other storage, or a combination. Such special-purpose computing devices may also combine custom hard-wired logic, ASICs, or FPGAs with custom programming to accomplish the techniques. The special-purpose computing devices may be desktop computer systems, portable computer systems, handheld devices, networking devices or any other device that incorporates hard-wired and\/or program logic to implement the techniques.","For example,  is a block diagram that illustrates a computer system  upon which an embodiment of the invention may be implemented. Computer system  includes a bus  or other communication mechanism for communicating information, and a hardware processor  coupled with bus  for processing information. Hardware processor  may be, for example, a general purpose microprocessor.","Computer system  also includes a main memory , such as a random access memory (RAM) or other dynamic storage device, coupled to bus  for storing information and instructions to be executed by processor . Main memory  also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions, when stored in non-transitory storage media accessible to processor , render computer system  into a special-purpose machine that is customized to perform the operations specified in the instructions.","Computer system  further includes a read only memory (ROM)  or other static storage device coupled to bus  for storing static information and instructions for processor . A storage device , such as a magnetic disk or optical disk, is provided and coupled to bus  for storing information and instructions.","Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","Computer system  may implement the techniques described herein using customized hard-wired logic, one or more ASICs or FPGAs, firmware and\/or program logic which in combination with the computer system causes or programs computer system  to be a special-purpose machine. According to one embodiment, the techniques herein are performed by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another storage medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions.","The term \u201cstorage media\u201d as used herein refers to any non-transitory media that store data and\/or instructions that cause a machine to operation in a specific fashion. Such storage media may comprise non-volatile media and\/or volatile media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device . Volatile media includes dynamic memory, such as main memory . Common forms of storage media include, for example, a floppy disk, a flexible disk, hard disk, solid state drive, magnetic tape, or any other magnetic data storage medium, a CD-ROM, any other optical data storage medium, any physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, NVRAM, any other memory chip or cartridge.","Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example, transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.","Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card, cable modem, satellite modem, or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer system , are example forms of transmission media.","Computer system  can send messages and receive data, including program code, through the network(s), network link  and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface .","The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution.","In the foregoing specification, embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The sole and exclusive indicator of the scope of the invention, and what is intended by the applicants to be the scope of the invention, is the literal and equivalent scope of the set of claims that issue from this application, in the specific form in which such claims issue, including any subsequent correction.","The Layer service introduces three concepts which facilitate all messaging. The concepts and their function are the following:","Conversations\u2014represented by the Conversation object in the Layer SDK. Conversations coordinate all messaging within Layer. All messages sent with the Layer SDK are sent within the context of conversation, and all participants of that conversation will receives those messages.","Messages\u2014represented by the Message object in the Layer SDK. Messages can be made up of one or many individual pieces of content.","Message Parts\u2014represented by the MessagePart object in the Layer SDK. Message Parts are the atomic object in the Layer universe. They represent the individual pieces of content embedded with a message. MessageParts take a byte[ ] object and a MIME type string. The Layer SDK does not put any restrictions on the type of data you send, nor the MIME types your applications wishes to support.",{"@attributes":{"id":"p-0317","num":"0332"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/ Creates and returns a new convertion object "]},{"entry":[{},"with sample participant identifiers"]},{"entry":[{},"Conversation conversation = "]},{"entry":[{},"Conversation.newInstance(Arrays.asList(\u201c948374839\u201d));"]},{"entry":[{},"\/\/ Create a message part with a string of text"]},{"entry":[{},"MessagePart messagePart = MessagePart.newInstance(\u201ctext\/plain\u201d, "]},{"entry":[{},"\u201cHi, how are you?\u201d.getBytes( ));"]},{"entry":[{},"\/\/ Creates and returns a new message object with the given "]},{"entry":[{},"conversation and array of message parts"]},{"entry":[{},"Message message = Message.newInstance(conversation, "]},{"entry":[{},"Arrays.asList(messagePart));"]},{"entry":[{},"\/\/Sends the specified message"]},{"entry":[{},"client.sendMessage(message);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Conversations","The Conversation object coordinates all messaging within the Layer service. It represents a stream of messages that are synchronized between all participants of a conversation. All messages sent with the Layer SDK must be sent within the context of a conversation. Conversation objects are created by calling Conversation.newInstance( ). This method takes a list of participant identifiers. As Layer Authentication allows you to represent users within the Layer service via your backend's federated identifier, participants are represented with those same user identifiers.",{"@attributes":{"id":"p-0320","num":"0335"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Creates and returns a new conversation object with "]},{"entry":[{},{},"sample participant identifiers"]},{"entry":[{},{},"Conversation conversation = "]},{"entry":[{},{},"Conversation.newInstance(Arrays.asList(\u201cUSER-"]},{"entry":[{},{},"IDENTIFIER\u201d));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Add\/Remove Participants","Once a conversation has been created, participant lists remain mutable, meaning participants can be both added and removed. The Layer service does not enforce any ownership, so any client can both add and remove participants.",{"@attributes":{"id":"p-0323","num":"0338"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/ Adds a participant to a given conversation"]},{"entry":[{},"client. addParticipants(conversation, Arrays.asList(\u201c948374848\u201d));"]},{"entry":[{},"\/\/ Removes a participant from a given conversation"]},{"entry":[{},"client.removeParticipants(conversation, "]},{"entry":[{},"Arrays.asList(\u201c948374848\u201d));"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Fetching Data","Layer Client exposes a simple API for fetching conversations for an authenticated user. In order to fetch all conversations, call getConversations( ).",{"@attributes":{"id":"p-0326","num":"0341"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/ Returns a List of all conversations for the currently authenticated user"]},{"entry":[{},"List<Conversation> conversations = client.getConversations( );"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Correspondingly, to fetch a specific conversation, that conversation's identifier must be passed.",{"@attributes":{"id":"p-0328","num":"0343"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Returns a specific conversation"]},{"entry":[{},{},"Conversation conversation = "]},{"entry":[{},{},"client.getConversation(someConversationIdentifier);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Deletion","The Layer SDK supports the deletion of both conversations and messages. Deletion of a conversation deletes that conversation object and all associated messages for all current participants.",{"@attributes":{"id":"p-0331","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Deletes a messages. "]},{"entry":[{},{},"layerClient.deleteMessage(message);"]},{"entry":[{},{},"\/\/ Deletes a conversation,"]},{"entry":[{},{},"layerClient.deleteConversation(conversation)."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Fetching Data","Conversations","Layer Client exposes a simple API for fetching conversations for an authenticated user. In order to fetch all conversations, call getConversations( ).",{"@attributes":{"id":"p-0335","num":"0350"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/ Returns a List of all conversations for the currently authenticated user"]},{"entry":[{},"List<Conversation> conversations = client.getConversations( );"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Correspondingly, to fetch a specific conversation, that conversation's identifier must be passed.",{"@attributes":{"id":"p-0337","num":"0352"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Returns a specific conversation"]},{"entry":[{},{},"Conversation conversation = "]},{"entry":[{},{},"client.getConversation(someConversationIdentifier);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Please view the Layer Conversation Guide for a full tutorial on creating, displaying and updating conversations.","Fetching Messages","Layer Client exposes a simple API for fetching all messages for a given conversation.",{"@attributes":{"id":"p-0341","num":"0356"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Fetch all messages for a given conversation object"]},{"entry":[{},{},"List<Message> messages = client.getMessages(conversation);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Initialization","The LayerClient object represents the primary interface for interacting with the Layer service. Only one instance of LayerClient should be instantiated by your application and should be retained at all times. The object is initialized with a Context, and Application Key, and an GCM Sender ID.","**We have created an application for you titled <APPNAME> and the sample code below contains your application's key.**","This key is specific to your application and should be kept private at all times. Copy and paste the following code into your Application object's on Create( ) method.",{"@attributes":{"id":"p-0346","num":"0361"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/\/ Instructions a LayerClient object"]},{"entry":[{},{},"LayerClient client = LayerClient.newInstance(this, "]},{"entry":[{},{},"\u201c<APPID>\u201d, \u201cGCM ID\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"You can create additional Layer applications by visiting our developer dashboard.","Listeners","The LayerClient object leverages the listener pattern to notify your application to specific events. On launch, your application should register as a LayerConnectionListener and LayerAuthenticationListener.","client,registerConnectionListener(this).registerAuthenticationListener(this);","Connect The SDK","Once you have registered your listeners, you connect the SDK",{"@attributes":{"id":"p-0353","num":"0368"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Asks the LayerSDK to establish a network connection with the Layer"},{"entry":"service client.connect( );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Installation","The Layer Android SDK is built using the new Android build system. The Android SDK is available via an AAR or JAR file hosted on Github (https:\/\/github.com\/layerhq\/releases-android). To install the SDK, perform the one of following (either for local JAR or remote AAR).","JAR (Downloaded to Local \u2018libs\u2019 Directory)","1. Download the \u2018layer-sdk-0.7.9.jar\u2019 JAR file from Github (https:\/\/github.com\/layerhq\/releases-android)","2. Drag the JAR file into the \/libs directory of your Android Studio application","3. Navigate to the JAR file in Android Studio navigator, right click and select \u201cAdd As A Library . . . \u201d","4. Navigate to your build.gradle file and ensure that you include the following:",{"@attributes":{"id":"p-0361","num":"0376"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"apply plugin: \u2018maven\u2019"]},{"entry":[{},"dependencies {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"compile fileTree(dir: \u2018libs\u2019, include: [\u2018*.jar\u2019])"]},{"entry":[{},"compile \u2018com.android.support:appcompat-v7:20.+\u2019"]},{"entry":[{},"compile \u2018com.android.support:support-annotations:20.+\u2019"]},{"entry":[{},"compile \u2018com.google.android.gms:play-services:5.+\u2019"]},{"entry":[{},"compile \u2018org.slf4j:slf4j-api:1.7.7\u2019"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"AAR (with Layer \u2018git-repo\u2019 Gradle Plugin)","Navigate to your build.gradle file and ensure that you include the following:",{"@attributes":{"id":"p-0364","num":"0379"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"apply plugin: \u2018maven\u2019"]},{"entry":[{},"dependencies {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"compile \u2018com.layer.sdk:layer-sdk:0.7.9\u2019"]},{"entry":[{},"compile \u2018org.slf4j:slf4j-api:1.7.7\u2019"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Example AndroidManifest.xml","The Layer Android SDK requires some permissions and references from your app's AndroidManifest.xml file. These permissions allow the SDK to monitor network state and receive Google Cloud Messaging messages. Below is an example with a com.myapp.newstandalone package; replace with your own package when merging with your own manifest.",{"@attributes":{"id":"p-0367","num":"0382"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cutf-8\u201d?>"},{"entry":"<manifest"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package=\u201ccom.myapp.newstandalone\u201d"]},{"entry":[{},"xmlns:android=\u201chttp:\/\/schemas.android.com\/apk\/res\/android\u201d>"]},{"entry":[{},"<!-- Layer SDK uses these for monitoring network state and receiving GCM -->"]},{"entry":[{},"<uses-permission android:name=\u201candroid.permission.ACCESS_NETWORK_STATE\u201d\/>"]},{"entry":[{},"<uses-permission android:name=\u201candroid.permission.GET_ACCOUNTS\u201d\/>"]},{"entry":[{},"<uses-permission android:name=\u201candroid.permission.INTERNET\u201d\/>"]},{"entry":[{},"<uses-permission android:name=\u201candroid.permission.READ_PHONE_STATE\u201d\/>"]},{"entry":[{},"<uses-permission android:name=\u201candroid.permission.RECEIVE_BOOT_COMPLETED\u201d\/>"]},{"entry":[{},"<uses-permission android:name=\u201candroid.permission.WAKE_LOCK\u201d\/>"]},{"entry":[{},"<uses-permission android:name=\u201ccom.google.android.c2dm.permission.RECEIVE\u201d\/>"]},{"entry":[{},"<!-- GCM permission for your app (replace [com.myapp.newstandalone] with your package"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"name) -->"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<permission android:name=\u201ccom.myapp.newstandalone.permission.C2D_MESSAGE\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"android:protectionLevel=\u201csignature\u201d\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<uses-permission"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"android:name=\u201ccom.myapp.newstandalone.permission.C2D_MESSAGE\u201d\/>"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"<application ... >"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<!-- Layer SDK has these for monitoring network, boot, and GCM -->"]},{"entry":[{},"<receiver android:name=\u201ccom.layer.sdk.internal.receivers.LayerReceiver\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<intent-filter>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<actionandroid:name=\u201candroid.net.conn.CONNECTIVITY_CHANGE\u201d\/>"]},{"entry":[{},"<actionandroid:name=\u201candroid.intent.action.ANY_DATA_STATE\u201d\/>"]},{"entry":[{},"<actionandroid:name=\u201candroid.intent.action.BOOT_COMPLETED\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/intent-filter>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/receiver>"]},{"entry":[{},"<receiver"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"android:name=\u201ccom.layer.sdk.internal.push.GcmBroadcastReceiver\u201d"]},{"entry":[{},"android:permission=\u201ccom.google.android.c2dm.permission.SEND\u201d>"]},{"entry":[{},"<intent-filter>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<action android:name=\u201ccom.google.android.c2dm.intent.RECEIVE\u201d\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<!-- Replace [com.myapp.newstandalone] with your package name -->"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<category android:name=\u201ccom.myapp.newstandalone\u201d\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/intent-filter>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/receiver>"]},{"entry":[{},"<service android:name=\u201ccom.layer.sdk.internal.push.GcmIntentService\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/application>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/manifest>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Messages","The Message object represents an individual message within a conversation. A message within the Layer service can consist of one or many pieces of content, represented by the MessagePart object.","MessagePart","Layer does not place restrictions on the type of data you send through the service. As such, MessagePart objects are initialized with an Byte object and a MIME type string. The MIME Type simply describes the type of content the MessagePart contains.","The following demonstrates creating message parts with both text\/plain and image\/jpeg MIME types.",{"@attributes":{"id":"p-0373","num":"0388"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Creates a message part with a string of next and text\/plain MIME type."},{"entry":"String messageText = \u201cHi! How are you\u201d;"},{"entry":"MessagePart messagePart = MessagePart.newInstance(\u201ctext\/plain\u201d,"},{"entry":"messageText.getBytes( ));"},{"entry":"\/\/ Creates a message part with an image"},{"entry":"Bitmap imageBitmap = BitmapFactory.decodeResource(getResources( ),"},{"entry":"R.drawable.back_icon);"},{"entry":"ByteArrayOutputStream stream = new ByteArrayOutputStream( );"},{"entry":"imageBitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream);"},{"entry":"byte[ ] imageData = stream.toByteArray( );"},{"entry":"MessagePart messagePart = MessagePart.newInstance(\u201cimage\/jpeg\u201d,"},{"entry":"imageData);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The MessagePart object also declares a convenience method for creating messages with text\/plain MIME type:",{"@attributes":{"id":"p-0375","num":"0390"},"tables":{"@attributes":{"id":"TABLE-US-00060","num":"00060"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"String messageText = \u201cHi! How are you\u201d;"},{"entry":"MessagePart messagePart = MessagePart.newInstance(messageText);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Your application can declare additional MIME types that it wishes to support. The following demonstrates sending location data.",{"@attributes":{"id":"p-0377","num":"0392"},"tables":{"@attributes":{"id":"TABLE-US-00061","num":"00061"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Creates a HashMap with latitude and longitude"},{"entry":"HashMap location = new HashMap<String, String>( );"},{"entry":"location.put(\u201clat\u201d, \u201c25.43567\u201d);"},{"entry":"location.put(\u201clon\u201d, \u201c123.54383\u201d);"},{"entry":"\/\/Convert the location to data"},{"entry":"ByteArrayOutputStream locationData = new ByteArrayOutputStream( );"},{"entry":"ObjectOutputStream outputStream = new"},{"entry":"ObjectOutputStream(locationData);"},{"entry":"outputStream.writeObject(location);"},{"entry":"MessagePart locationPart = client.newMessagePart(\u201ctext\/location\u201d,"},{"entry":"locationData.toByteArray( ));"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Message","Message objects are initialized with an array of MessagePart objects and a Conversation object. The object is created by calling newInstance( ). This creates a Message object that is ready to send.","Message message=Message.newInstace(conversation, Arrays.asList(messagePart))","Sending The Message","Once an Message object is initialized, it is ready for sending. The message is sent by calling sendMessage( ) on LayerClient.",{"@attributes":{"id":"p-0383","num":"0398"},"tables":{"@attributes":{"id":"TABLE-US-00062","num":"00062"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Sends the specified message"]},{"entry":[{},"client.sendMessage(message);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Fetching Messages","Layer Client exposes a simple API for fetching all messages for a given conversation.",{"@attributes":{"id":"p-0386","num":"0401"},"tables":{"@attributes":{"id":"TABLE-US-00063","num":"00063"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Fetch all messages for a given conversation object"]},{"entry":[{},"List<Message> messages = client.getMessages(conversation);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Metadata","Metadata is a flexible mechanism by which applications can attach contextually relevant information to conversations and messages. Applications do this by associating key-value stores of information, called metadata, to any Conversation or Message object. Layer supports two distinct types of metadata:","Participant Metadata\u2014Information that is synchronized among participants in a Conversation.","Private Metadata\u2014Information that is private to a given participant, but synchronized among all of their devices.","Metadata may be any mix of nested dictionaries, arrays, strings, booleans, integers, longs, doubles, or NULL.",{"@attributes":{"id":"p-0392","num":"0407"},"tables":{"@attributes":{"id":"TABLE-US-00064","num":"00064"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Adds metadata to an object"]},{"entry":[{},"public abstract void mergeMetadata(Map<String, Parcelable>"]},{"entry":[{},"metadata, Map<String,"]},{"entry":[{},"Parcelable> userInfo, Object object);"]},{"entry":[{},"\/\/ Removes any existing metadata for an object"]},{"entry":[{},"public abstract void removeMetadata(List<String> metadataKeys,"]},{"entry":[{},"List<String> userInfo Keys,"]},{"entry":[{},"Object object);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following demonstrates how to attach latitude and longitude info to a new conversation.",{"@attributes":{"id":"p-0394","num":"0409"},"tables":{"@attributes":{"id":"TABLE-US-00065","num":"00065"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"List<Conversation> conversation = client.getConversations(identifier);"},{"entry":"HashMap metadata = new HashMap<String, String>( );"},{"entry":"metadata.put(\u201clat\u201d, \u201c25.43567\u201d);"},{"entry":"metadata.put(\u201clon\u201d, \u201c123.54383\u201d);"},{"entry":"client.mergeMetadata(metadata, null, conversation);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A common use case for Private metadata is a Favorites feature. The following demonstrates how you could attach boolean metadata to implement a favorites feature.",{"@attributes":{"id":"p-0396","num":"0411"},"tables":{"@attributes":{"id":"TABLE-US-00066","num":"00066"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"List<Conversation> conversation = client.getConversations(identifier);"},{"entry":"HashMap metadata = new HashMap<String, String>( );"},{"entry":"location.put(\u201cfavorite\u201d, true);"},{"entry":"client.mergeMetadata(null, metadata, conversation);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["In the drawings:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 15A","FIG. 15B","FIG. 15C"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
