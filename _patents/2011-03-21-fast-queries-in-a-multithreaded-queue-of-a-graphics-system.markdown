---
title: Fast queries in a multithreaded queue of a graphics system
abstract: According to one aspect of the invention, a query request is received from a client application at a multithreaded graphics framework. The multithreaded graphics framework including a first thread configured to place graphics commands from the client application into a command queue and a second thread configured to dispatch the graphics commands from the command queue to a graphics processing unit (GPU) for execution. In response to the query request, the first thread is configured to store query information of the query request in a query block of memory that is separated from the command queue and notifying the second thread. In response to the notification, the second thread is configured to issue a query command to the GPU based on the query information retrieved from the query block, prior to dispatching remaining graphics commands pending in the command queue.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09330430&OS=09330430&RS=09330430
owner: Apple Inc.
number: 09330430
owner_city: Cupertino
owner_country: US
publication_date: 20110321
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE DESCRIPTION","DETAILED DESCRIPTION"],"p":["Embodiments of the present invention relate generally to graphics processing systems. More particularly, embodiments of the invention relate to fast queries in a multithreaded queue of a graphics system.","Computer graphics refers to any processing device or program that makes a data processing system, such as a computer capable of displaying and manipulating (e.g., drawing, inputting, and outputting) graphics objects. Accordingly, processes of rendering information to be displayed may require a computer system have considerable memory and processing speed. Typically, a graphics processing unit (\u201cGPU\u201d) is used to process graphics objects, which lifts the burden off the central processing unit (\u201cCPU\u201d) which can then be used to perform other tasks.","In order to exploit multiple CPU threads, software can be written to use a producer consumer queue where one thread issues commands to a queue which are read by another thread for processing. This reduces the amount of time spent by a producer thread by dispatching the work to another thread. As commands are processed by a consumer thread, information is accumulated in data structures that are coherent with the consumer thread, but not with the producer thread. The producer thread often needs to retrieve information from the consumer thread or the GPU. However, since the queue may contain commands pending to be executed, the only way to ensure that the producer and consumer threads are synchronized is to ensure that the queue is empty and the GPU has completed all commands therein.","A conventional multithreaded graphics engine, such as Open Graphics Language or OpenGL\u2122, forms a command queue between two threads. A producer thread can reside on the application main thread or in a drawing thread created by the application. A consumer thread is created along with the command queue (e.g., a first-in-first-out or FIFO queue). The command queue can contain many commands from the producer and is kept in synchronized using common mechanisms used in software FIFO's and queues. State queries in this architecture require the command queue to be emptied and the GPU to complete any commands dependent on this query. This can be a time consuming issue, as all the commands need to be processed by the consumer thread and finished by the GPU.","Techniques for efficiently processing graphics query requests are described herein. According to one aspect of the invention, a query request is received from a client application at a multithreaded graphics framework. The multithreaded graphics framework including a first thread configured to place graphics commands from the client application into a command queue and a second thread configured to dispatch the graphics commands from the command queue to a graphics processing unit (GPU) for execution. In response to the query request, the first thread is configured to store query information of the query request in a query block of memory that is separated from the command queue and notifies the second thread. In response to the notification, the second thread is configured to issue a query command to the GPU based on the query information retrieved from the query block, prior to dispatching remaining graphics commands pending in the command queue.","Other features of the present invention will be apparent from the accompanying drawings and from the detailed description which follows.","Various embodiments and aspects of the invention will be described with reference to details discussed below, and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However, in certain instances, well-known or conventional details are not described in order to provide a concise discussion of embodiments of the present invention.","Reference in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification do not necessarily all refer to the same embodiment.","Accordingly, embodiments of the invention do not require complete flush of a command queue and only require a GPU to complete the commands up to the desired query. This reduces the amount of time to retrieve information back from a consumer thread and\/or the GPU by reducing substantial work by the consumer thread and\/or the GPU for a query. According to some embodiments, a synchronization command is issued after each command that produces critical information that requires fast access such as an occlusion query. The synchronization command is used to determine exactly where in a command stream to the GPU the query command is located and if the result can be retrieved without completing the entire command buffer sent to the GPU.","In one embodiment, in response to a query request received from a client application via an application programming interface (API) of a multithreaded graphics framework, a fast query can be performed by a producer thread of the graphics framework by issuing a query request in a designated query block of memory that is separated from the command queue. Once the query request has been placed in the query block, the producer thread sets a flag in the query block to a predetermined value indicating that a query request is pending and notifies a consumer thread of the graphics framework. Thereafter, the producer thread may wait for the query result, perform other tasks, or transition into a sleep state until the query result is ready.","In response to the notification, the consumer thread retrieves the query request from the query block and issues a query command based on the query request to a graphics driver which places the query command in a command buffer of a GPU that executes the query command. In one embodiment, the query command is issued by the consumer thread without having to dispatch the remaining graphics commands pending in a command queue. That is, the query command is issued bypassing the remaining graphics commands in the command queue. In addition, according to one embodiment, after issuing the query command, the consumer thread also issues a synchronization command to the GPU, where the synchronization command is associated with a synchronization object. Thereafter, the consumer thread can either wait for the query command to be executed by the GPU, perform other tasks, or transition itself into a sleep state until the query command has been executed by the GPU.","When the GPU finishes execution of the synchronization command after executing the query command, in one embodiment, the consumer thread is notified by the GPU via the synchronization object. In response to the notification, the consumer thread retrieves the query result from the GPU and stores the query result in the query block that is shared between the consumer thread and the producer thread. Thereafter, the consumer thread sets the flag of the query block to a predetermined value, which in turn notifies or wakes up the producer thread regarding availability of the query result. The producer thread can then retrieve the query result from the query block and return the query result to the client. As a result, a query command can be executed without having the GPU finish the graphics commands remaining in the command queue, which literately puts the query command in a \u201cfast lane\u201d for execution.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","101","102","104","103","101","104","101","101","102"]},"Graphics framework  may be implemented as part of an operating system (OS) running within a data processing system, where the operating system may be any kind of operating system, such as Windows\u2122 operating system from Microsoft, Mac OS\u2122 from Apple Inc, a LINUX or UNIX operating system, etc. For example, graphics framework  may be executed as part of an operating system in a system memory by a central processing unit (CPU) (not shown), where the CPU may include one or more processors or processor cores. Graphics hardware  may include one or more GPUs and a video memory. Graphics hardware  may be integrated within a chipset of the data processing system such as an IO (input\/output) bridge (also referred to as a south bridge), where the video memory may be specifically allocated from the system memory. In such a configuration, graphics driver  may be executed in the system memory by the CPU, for example, in a kernel space of the operating system. Alternatively, graphics hardware  may be implemented as a dedicated graphics acceleration device coupled to the CPU and system memory via a variety of buses, such as, for example, an accelerated graphics port (AGP) bus, a peripheral component interconnect (PCI) bus, or a PCI-Express bus, etc. In this configuration, graphics driver  may be executed by graphics hardware .","In one embodiment, graphics framework  is a multithreaded graphics framework that provides one or more APIs (e.g., OpenGL\u2122 or DirectX\u2122) to clients , where clients  may be executed in one or more threads by one or more processors or processor cores of a CPU. Graphics framework  includes application thread , command queue , and worker thread . Graphics commands received from clients  via the APIs are placed or packed into command queue  by application thread . On the other hand, worker thread  is configured to retrieve or unpack the graphics commands from command queue  and dispatch the graphics commands to graphics driver , where the dispatched graphics commands are placed in command buffer  to be executed by graphics hardware  (e.g., one or more GPUs). Certain statuses of operations of graphics hardware  can be retrieved by reading from one or more registers  of graphics hardware .","In one embodiment, application thread  and worker thread  are executed by the CPU in a multithreaded operating environment (e.g., multithreaded ready operating system) and they are running independently. In this configuration, with respect to command queue , application thread  operates as a producer thread that is responsible to produce or insert graphics commands into command queue , while worker thread  operates as a consumer thread to consume or retrieve graphics commands from command queue  to be dispatched to graphics hardware  via graphics driver . Command queue  may be specifically allocated from the system memory and shared by application thread  and worker thread .","In addition, according to one embodiment, graphics framework  further includes query block  for query operations, where query block may be a block of memory specifically allocated from system memory and shared between application thread  and worker thread . However, such a query block is separated from command queue  and is specifically used for handling query operations for querying states or statuses of graphics hardware  (e.g., results of execution of specific graphics commands). Query block  may be allocated per application thread  or alternatively, query block  may be allocated per clients . In one embodiment, query block  includes one or more fields - to allow application thread  and worker thread  to communicate with each other for query purposes, in addition to normal downstream communications of graphics commands via command queue. That is, command queue  is a one-way downstream communication channel for sending down graphics commands for execution by graphics hardware , while query block  is a two-way communication channel between application thread  and worker thread .","In one embodiment, when there is a need to query information from graphics hardware, client  transmits a query request to graphics framework  via a proper API (e.g., OpenGL or DirectX). In response to the query request, application thread  (e.g., a first thread or producer thread) places the query information in query block  based on the query request. Once the query request has been placed in query block , application thread  notifies, via the operating system, worker thread  (e.g., a second thread or a consumer thread) that a query request has been placed in query block . Thereafter, application thread  may wait for the query result, perform other tasks, or transition into a sleep state until the query result is ready.","In response to the notification, worker thread  retrieves the query request from query block  and issues a query command based on the query request to a graphics driver which places the query command in command buffer  of graphics hardware  that executes the query command. In one embodiment, the query command is issued by the consumer thread without having to dispatch the remaining graphics commands pending in command queue . That is, the query command is issued bypassing the remaining graphics commands in command queue .","When graphics hardware  finishes execution of the query command, in one embodiment, the consumer thread  is notified by graphics hardware . In response to the notification, consumer thread  retrieves the query result from registers  of graphics hardware  and stores the query result in query block  that is shared between consumer thread  and producer thread . Thereafter, the consumer thread  notifies or wakes up producer thread  regarding the query result. Producer thread  can then retrieve the query result from query block  and return the query result to the client . As a result, a query command can be executed without having graphics hardware  finish the graphics commands remaining in command queue , which literately puts the query command in a \u201cfast lane\u201d for execution, bypassing the graphics commands pending in command queue .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["200","100","105","106","107","106","113","104","106","106","113","104","104","103"]},"In one embodiment, when a query request is received from a client, application thread  is configured to place the query information of the query request in query block , including specifying a type of the query in type field  and other information. For example, information concerning a number of occlusions between a viewer and a light source or a number of GPU clock cycles to complete a particular operation involved in a query may also be included. Once the query information has been populated in query block , in one embodiment, application thread  sets flag  of query block to a predetermined value (e.g., a non-zero value) to indicate that there is a pending query request in query block . In addition, application thread  notifies or wakes up worker thread  concerning the pending query request. In some situations, if there is no graphics command pending in command queue  or command buffer  is full or some other conditions, worker thread  may enter into a sleep state or perform other tasks.","In one embodiment, application thread  may be woken up via a notification event or software interrupt issued by the operating system. In one embodiment, application thread  may insert a predetermined command (e.g., a dummy command) in command queue , which triggers a notification event or a software interrupt sent by the operating system to worker thread . Thereafter, application thread  may wait for the query request to be completed, enter into a sleep state, or perform other tasks. In one embodiment, application thread  may invoke a lock mechanism (e.g., spinlock, semaphore, or mutex, etc.) provided by the operating system for the purpose of waiting for the query request to be completed. For example, application thread  may acquire a spinlock on flag  via the operating system, where the value of flag  is utilized as a state of the spinlock indicating whether the corresponding spinlock has been acquired or released. Alternatively, a thread may be dispatched with the work items in the queue and the thread may process the queue or be dispatched to perform the query.","In response to the notification, according to one embodiment, worker thread  examines flag  of query block to determine whether there is a pending query request in the query block. Note that there may be multiple query blocks configured to support multiple clients, where there is a specific query block for each client. When worker thread  is notified, it has to examine each query block to determine which of the query blocks contains a pending query request. If it is determined that flag  has been set to a predetermined value, worker thread  examines type  to generate a query command associated with the specific type and issues the query command to graphics driver , which places the query command into command buffer , as query command . Command buffer  in general is a FIFO buffer having graphics commands - to be executed in a first-come-first-served order by GPU . Once the query command has been issued, worker thread  may wait, enter into a sleep state, or perform other tasks, until the query command has been executed. As a result, the query command is issued and executed without having to flush the remaining graphics commands in command queue . This literally puts the query command in a \u201cfast lane\u201d for execution, bypassing the pending graphics commands in command queue .","Once query command  has been executed by GPU , worker thread  is notified. In response, worker thread  retrieves the query result from registers  associated with GPU , where registers  may be hardware registers, software registers, or a combination of both. Worker thread  then populates the query result in query block  as part of query result . Once the query result has been populated into query block , worker thread  is configured to notify application thread  via the operating system. In one embodiment, worker thread  is configured to set flag  to a predetermined value (e.g., zero), which in turn notifies application thread . For example, application thread  may periodically read or poll flag  to determine whether the value of flag  has been changed as a way to determine whether the query result has been populated in query block . Thus, by setting the value of flag  to a different value by worker thread , application thread  is notified. Alternatively, application thread  may acquire a spinlock on flag  from the operating system, and by setting the value of flag  to a predetermined value such as a zero, worker thread  literally \u201creleases\u201d the spinlock, which in turn notifies application thread . In response to the notification, application thread  retrieves the query result from query block  and returns the query result to the client.","According to one embodiment, after issuing query command  to command buffer , worker thread  issues synchronization command . Synchronization command  is associated with synchronization object , which is used for notification purposes. In one embodiment, after issuing the synchronization command, worker thread  sets a predetermined field or member of synchronization object  to a predetermined value and waits for a change of the value of the predetermined field or member. Meanwhile, worker thread  may perform other tasks or simply enter a sleep state. Since command buffer  is a FIFO buffer, after executing query command  by GPU , GPU  executes synchronization command. In one embodiment, in response to the synchronization command, GPU  does not perform any graphics operation; rather, GPU  and\/or graphics driver  sets the predetermined field or member of synchronization object  to a different value, which in turn notifies worker thread , for example, via an API by a synchronization server (not shown).","In one embodiment, a synchronization command, as well as a synchronization object, is utilize to serialize commands in multiple graphics command streams that access a common resource, where the synchronization is organized or managed by a synchronization server (not shown). Generally, a synchronization object is placed in the command stream at a point after which the command stream has completed its use of the common resource. For example, if the command stream A had four drawing commands using the common resource and three drawing commands not using the common resource, the synchronization object may be set in the command stream after the first four commands but before the last three commands. In this way, the command stream indicates through the synchronization object when commands related to the common resource have been completed.","A client, in this example, worker thread , can send via the API a request for a synchronization object test to the synchronization server requesting information as to whether or not the current state of the synchronization object indicates that commands in other command streams, in this example, graphics driver , that depend on the common resource have been completed. The synchronization server may reply to the request with an indication of whether the command stream may proceed with commands dependent on the common resource.","In one embodiment, the synchronization server may receive a notice generated by a processing device (e.g., GPU or graphics driver) performing the commands in command stream (e.g., GPU) has reached the synchronization object in the command stream. For example, a method associated with the synchronization object may be called by the processing device when the processing device encounters the synchronization object in the command stream. In response to the processing device calling the method associated with the synchronization object, the state of the synchronization object changes to indicate that the command stream has completed processing a set of commands dependent on the common resource.","When the synchronization server receives a synchronization object test from worker thread , if the GPU or graphics driver  has processed the synchronization object when the synchronization server receives the test, the synchronization server indicates to worker thread  that it may begin processing commands dependent on the common resource. If the GPU or graphics driver  has not processed the synchronization object when the synchronization server receives the test request, then the synchronization server responds to the test with an indication that worker thread  may not process commands dependent on the common resource corresponding to the synchronization object. A synchronization object may be globally allocated.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 3","FIG. 1","FIG. 3"],"b":["300","105","301","302","304","305"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 4","FIG. 1","FIG. 4"],"b":["400","107","401","402","403","404","405","406"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 5","FIG. 1","FIG. 5","FIG. 5"],"b":["500","100"]},"As shown in , the computer system , which is a form of a data processing system, includes a bus or interconnect  which is coupled to one or more microprocessors  and a ROM , a volatile RAM , and a non-volatile memory . The microprocessor  is coupled to cache memory . The bus  interconnects these various components together and also interconnects these components , , , and  to a display controller and display device , as well as to input\/output (I\/O) devices , which may be mice, keyboards, modems, network interfaces, printers, and other devices which are well-known in the art.","Typically, the input\/output devices  are coupled to the system through input\/output controllers . The volatile RAM  is typically implemented as dynamic RAM (DRAM) which requires power continuously in order to refresh or maintain the data in the memory. The non-volatile memory  is typically a magnetic hard drive, a magnetic optical drive, an optical drive, or a DVD RAM or other type of memory system which maintains data even after power is removed from the system. Typically, the non-volatile memory will also be a random access memory, although this is not required.","While  shows that the non-volatile memory is a local device coupled directly to the rest of the components in the data processing system, the present invention may utilize a non-volatile memory which is remote from the system; such as, a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus  may include one or more buses connected to each other through various bridges, controllers, and\/or adapters, as is well-known in the art. In one embodiment, the I\/O controller  includes a USB (Universal Serial Bus) adapter for controlling USB peripherals. Alternatively, I\/O controller  may include an IEEE-1394 adapter, also known as FireWire adapter, for controlling FireWire devices.","Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as those set forth in the claims below, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","Embodiments of the invention also relate to an apparatus for performing the operations herein. Such a computer program is stored in a non-transitory computer readable medium. A machine-readable medium includes any mechanism for storing information in a form readable by a machine (e.g., a computer). For example, a machine-readable (e.g., computer-readable) medium includes a machine (e.g., a computer) readable storage medium (e.g., read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media, optical storage media, flash memory devices).","The processes or methods depicted in the preceding figures may be performed by processing logic that comprises hardware (e.g. circuitry, dedicated logic, etc.), software (e.g., embodied on a non-transitory computer readable medium), or a combination of both. Although the processes or methods are described above in terms of some sequential operations, it should be appreciated that some of the operations described may be performed in a different order. Moreover, some operations may be performed in parallel rather than sequentially.","Embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.","In the foregoing specification, embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the invention are illustrated by way of example and not limitation in the figures of the accompanying drawings in which like references indicate similar elements.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
