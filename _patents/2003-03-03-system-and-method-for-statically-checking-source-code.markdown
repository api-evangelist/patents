---
title: System and method for statically checking source code
abstract: The present invention is directed at a system and method for statically checking source code to determine potential compatibility issues with a new software release. The system and method perform a static check on input source files associated with a software release. The static check includes identifying programming constructs, such as function prototypes, structures, unions, and the like, within source code files associated with the software release. The programming constructs undergo a filtering process that reduces the number of potentially false change errors. The filtered programming constructs are saved in a database associated with the software release. The database is then compared with another database containing programming constructs for another software release in order to identify differences between the two software releases. A list of changes is generated that identifies the differences between the two software releases. These changes are used to identify potential incompatibilities between the two software releases.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06873935&OS=06873935&RS=06873935
owner: Microsoft Corporation
number: 06873935
owner_city: Redmond
owner_country: US
publication_date: 20030303
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["An important factor in determining the success of a new release of software is the degree of compatibility that the new release has with third party applications and hardware. For each error that the new release causes with existing applications and hardware, the release is viewed less and less favorably by software consumers. If the new release causes a significant number of errors, many consumers may forego upgrading to the new release, which impacts the profitability of the new release.","There have been attempts at checking new software releases for potential problems. Some attempts provide dynamic checking and others provide static checking. Dynamic checking checks the executable code as the new software release is running. Static checking checks the source code that will become the executable code of the new release.","When the source code is not very large, a manual process of comparing files may be attempted. However, typically, today, new releases involve a few thousand source code files with each source code file having several lines of code. Therefore, the manual process is not a very useful technique. Some static checkers have automated the process, but have experienced limited success. One such type of automated static checker performs a document compare on source code files in a new release with source code files from a prior release. This type of automated static checker gives many false change indications. For example, if the same code is used in the new release, but is moved within a file or is moved to another file, this type of automated static checker indicates a change in the file or files. Thus, giving a false change error. Other attempts require programmers to annotate the code in order for the static checker to identify potential problems.","Until the present invention, a static checker that works on a large source code base, requires no code annotation, and generates meaningful and useful errors has not been realized.","The present invention is directed at a system and method for statically checking source code to determine potential compatibility issues with a new software release. The system and method perform a static check on input source files associated with a software release. The static check includes identifying programming constructs, such as function prototypes, structures, unions, and the like, within source code files associated with the software release. The programming constructs undergo a filtering process that reduces the number of potentially false change errors. The filtered programming constructs are saved in a database associated with the software release. The database is then compared with another database containing programming constructs for another software release in order to identify differences between the two software releases. A list of changes is generated that identifies the differences between the two software releases. These changes are used to identify potential incompatibilities between the two software releases.","The static checker of the present invention is superior to current static checkers because the present invention minimizes the number of false change errors that get reported.","The present invention is directed at a system and method for statically checking source code to determine potential compatibility issues with a new software release. The system determines compatibility issues by tracking changes made to Application Programming Interfaces (APIs). The system and method perform a static check on input source files associated with a particular software release. The static check includes identifying programming constructs, such as function prototypes, structures, unions, typedefs, and the like. The programming constructs undergo a filtering process that reduces the number of potentially false change errors. The filtered programming constructs are saved in a database associated with the particular software release. The particular software release is then compared with an older or a new version of the software release to identify changes between the two releases. A list of changes is generated that identifies the differences between the two software releases. These changes are used to identify potential incompatibilities between the two software releases. As will be described in detail below, the static checker of the present invention is superior to current static checkers because the present invention minimizes the number of false change errors that get reported.","The following detailed description is divided into several sections. A first section describes an illustrative computing device in which the present invention may be implemented. A second section describes exemplary environments for implementing the invention. A third section describes an exemplary embodiment of the invention. It will be appreciated that the invention is not limited to the specific embodiments described herein.","Illustrative Computing Environment",{"@attributes":{"id":"P-00015","num":"00015"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","102","104","104","104","105","106","107","106","108"]},"Computing device  may have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. These devices are well know in the art and need not be discussed at length here.","Computing device  may also contain communication connections  that allow the device to communicate with other computing devices , such as over a network. Communication connections  is one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.","Illustrative Environment",{"@attributes":{"id":"P-00019","num":"00019"},"figref":"FIG. 2","b":["200","200","202","204","206","206","208","208","206","204","206","206","206","204","204","202"]},"The compiler plug-in mechanism  enables the header files to be parsed in a manner similar to the manner in which existing compilers parse header files. The compiler plug-in mechanism  may be a general purpose mechanism that allows third party plug-ins to be added or may be custom software written specifically for supplying the programming constructs received from compiler  to the static checker . The input source files  are fed into the compiler plug-in mechanism  by the static checker . One example of a general purpose compiler plug-in mechanism  is a programming application named \u201cPREFAST\u201d that is manufactured by the Microsoft Corporation in Redmond, Wash. For this embodiment, static checker  is registered with the operating system, which makes it available as a plug-in to the compiler plug-in mechanism . The compiler plug-in mechanism  is then configured to execute the static checker . In essence, complier plug-in mechanism  provides a means for supplying programming constructs to the static checker  of the present invention.","The input source files  represent the files associated with a particular software release. When the source files are written in C\/C++, the input source files #include every header file that ships with the software release. The software release may be associated with an operating system, an application, and the like. In addition, the software release may accommodate several compilation types, such as supporting different versions of device drivers (e.g., NDIS 4, NDIS 5 and NDIS 6 versions). The input source files  for each software release are stored in a separate subdirectory. In addition, any input source files associated with a compilation type (e.g., NDIS 4) for the software release, are stored in a compilation subdirectory off the software release subdirectory.","The static checker  is configured to launch compiler  and the compiler plug-in mechanism . The static checker  inputs the input source files  and directs compiler  to compile the input source files . As mentioned above, compiler  compiles the input source files  and whenever compiler  encounters a programming construct, compiler  sends information about the programming construct to the compiler plug-in mechanism . The compiler plug-in mechanism  then relays the information to the static checker . Although illustrated in  as a single component, it will be appreciated that the static checker  is likely made up of several different components acting together, as will be made more clear from the following discussion in conjunction with FIG. . Using the information received from the compiler , the static checker  produces database  as output. Database  describes the programming constructs within the release, in addition to other information, such as #defines. Database  is described in more detail below in conjunction with FIG. . The static checker  may be configured to track public interface changes, private interface changes, and\/or both. The following discussion describes an embodiment in which the static checker  is configured to track public interface changes.",{"@attributes":{"id":"P-00023","num":"00023"},"figref":"FIG. 3","b":["300","202","302","304","302","304","2","202","308","308"]},"The set of queries  compare the tables within the first and second database ,  using a standard query language that is known to those skilled in the art. The set of queries  compares records within the first and second database ,  that have the same compilation type (e.g., NDIS ). During this comparison, a list of changes  is generated. The list of changes  may be in one document or in several documents. For example, the list of changes  may include a document for each type of programming construct. In this case, the document pertaining to one particular programming construct will list the syntactical changes identified for that particular programming construct (e.g., function prototype) between the first and second database , . The list of changes  will identify inconsistencies between the software releases, such as function prototypes that have been added, programming constructs that have changed, header sets that are inconsistent, and the like.","Illustrative Implementation",{"@attributes":{"id":"P-00026","num":"00026"},"figref":["FIG. 4","FIG. 4"],"b":["202","2","202","418","202","418","418","418"]},"The static checker  includes a managing component , a set-up component , a pre-processor component , an optional exporter component , a parser component , a filter component , a database builder component , and a database updater component . As those skilled in the art will appreciate the functionality provided by these components may be combined or further divided without departing from the scope of the present invention. The following discussion has divided the functionality provided by static checker  into components -, which will now be described in detail.","The managing component  is configured to manage the execution of the other components -. The managing component  manages the input source files (not shown) in a manner such that the location of the input source files do not negatively impact the operation of the static checker . For example, in some software releases, header files may be located in the same directories as sample source files. If this occurs, the include paths may be conditionally embedded into the input source files, which is undesirable. Therefore, in this situation, the managing component  copies the header files located in the sample source tree into the main include directory associated with the software release. In addition, the managing component  identifies each conditional that the parser component  uses when generating the log files . The list of conditionals may be obtained from documentation or may be retrieved from each input source file. As will be explained below, because the static checker is aware of the conditional that is defined when a particular programming construct is encountered, the static checker records the condition along with the programming construct in the database. Therefore, in accordance with the present invention, the static checker compares programming constructs that are generated with the same condition defined, which reduces the number of errors generated.","The managing component  is also configured to launch the pre-processor component . As described above, the static checker of the present invention uses a compiler (i.e., compiler  shown in ) to obtain the programming constructs. However, compiler  supplies the compiler plug-in mechanism  the programming constructs after the input source files have been pre-processed. Therefore, static compiler  includes the pre-processor component  that searches for \u201c#define\u201d within the input source files. Upon finding \u201c#define\u201d, the pre-processor component  writes the \u201c#define\u201d declaration to a #define log . The #define log  may be a text file, a structured binary file, or the like.","Pre-processor component  handles macro declarations that are on a single line or span multiple lines. In addition, if the macro declaration does not include a value, the pre-processor component  writes a string \u201c<NO VALUE>\u201d in a value column within the #define log . Because pre-processor component  performs mainly string manipulation, one embodiment for pre-processor component  is a script written using the Perl programming language. However, pre-processor component  may be written using other programming languages.","Exporter component  is an optional component. Managing component  determines whether or not to execute the exporter component  based on a command line parameter given to execute the static checker. For example, in one embodiment, the static checker  is invoked using the following command line syntax:","<executable name><path><sub-dir><base kit name>[<SkipBin>]","where,","<executable name>=the name of the static checker executable","<path>=the path to the input source file directory","<sub-dir>=the subdirectory name of the base kit","<base kit name>=name that will become the name of database","<SkipBin>=parameter for determining whether to produce binary import table.","The <SkipBin> parameter may be specified if the static checker is running against the base build. Also, the <SkipBin> parameter may be specified if the static checker is not interested in private prototypes, such as prototypes declared in header files, but not exported in a binary file. If the <SkipBin> parameter is not specified, the managing component  calls the exporter component . The exporter component  logs all the exports given in the libraries and the binaries associated with the target build. In one embodiment, exporter component  uses dumpbin to log the exports. In one embodiment, dumpbin may be provided by the compiler. The libraries are stored in a Lib Import Log  and the binaries are stored in a Bin Export Log .","The managing component  is also configured to invoke the database builder component . The database builder component  is responsible for creating a new database that will become populated with programming constructs. If a database with the same name as the name specified on the command line already exists, the database builder component  attempts to remove the existing database. Using a standard database interface, such as ActiveX Data Objects (ADO), the database builder component  creates a new database file  and begins adding tables. In one embodiment, separate tables are used to store the various programming constructs. Thus, there may be separate tables for function prototypes, structures, unions, classes, enums, typedefs, global variables, #defines, library exports, binary exports, and the like.","Each table has various fields associated with the type of programming constructs that is being stored. For example, a function prototype table may include fields for identifying the name of the function, a return type, a type for each parameter, and the like. A variable table may include fields for identifying the name of the variable and the type. A structure table may include fields for identifying the name of the structure, the name of a member, the type and name of each variable, and the like. In one embodiment, the structure table may also include a memo field called \u201cmembers\u201d that contains a string representation of all the members in the structure. The members in the string may be separated by the pipe \u2018|\u2019 character. In addition, the structure table may include a number of character fields for storing pieces of the memo field. This is useful when queries cannot use the memo field. The character fields may be fixed at a predetermined number of bytes (e.g., 255 bytes). The first character field stores the first predetermined number of bytes of the memo field, the next character field stores the next predetermined number of bytes of the memo field, and so on. In addition, each table includes a header field that identifies the header file containing the programming construct and a compilation type field that stores the compilation type (e.g., NDIS 4) that is defined when the programming construct is identified.","The database builder component  also creates an index for each table that has a unique attribute set. This prevents duplicate records from being recorded in the database . Because several header files may be included more than once, the log files , described below, may contain duplicate records. Thus, the indexes created by the database builder component  prevent these duplicate records from being duplicated within the database . Database builder component  may also create other indexes which improve query performance. Database builder component  is configured to import the records from the #define log , the lib import log , and the bin export log  into the database .","The parser component  is invoked by the managing component  to obtain the information about the programming constructs that will be stored in the database . Parser component  first creates a build environment appropriate for the type of software release. The build environment may be created by calling the set-up component . The set-up component  is configured to properly set-up the build environment for the associated software release using the parameters supplied by the parser component  from the managing component . For example, the settings may be parameters that are input into a \u201csetenv.cmd\u201d associated with a particular operating system. The managing component  determines the parameters and supplies the parameters to the parser component  which in turn calls the set-up component  and provides the parameters to the set-up component .","The parser component  configures the build environment in a manner such that the compiler plug-in mechanism  is invoked in conjunction with compiler . Each directory in the input source directory tree associated with the new software release is parsed in the following manner. The parser component  deletes any previous log files  in the current directory and launches a build of the input source files found in the current directory. The build will launch the compiler plug-in mechanism that will enable the static checker to generate the log files . The log files  list the programming constructs identified in the header files associated with the new software release. In one embodiment, there may be a plurality of log files with each log file being associated with one type of programming construct. For example, a log file associated with function prototypes may contain lines that list the function name, return type, and the parameters to the function for each function prototype identified.","Parser component  launches the builds of the input source files by the compiler and the compiler plug-in mechanism. Using the information obtained from the compiler via the compiler plug-in mechanism, the parser component  creates log files . The parser component  is aware of each compilation type and directs the compiler and compiler plug-in mechanism to provide the programming constructs for each compilation type. The compilation type is then saved with the identified programming construct in the log files .","The managing component  invokes the filter component . The filter component  is responsible for filtering the entries in the log files  in a manner to reduce the number of erroneous change indications. For example, spaces may be removed from prototypes so that a compare on the same prototype, but having a space, does not get reported as a change. Thus, the filter component  inputs the log files , filters the log files , and outputs a filtered version of the log files (i.e., filtered log files ). Thus, in one embodiment, filter component  removes the non-significant spaces (e.g., spaces that do not separate identifiers and\/or keywords). In addition, filter component  may also remove other decorations that do not pertain to an API change.","The managing component  is also responsible for invoking the database updater component . The database updater component  is configured to input the filtered log files , extract information, and update database  with the information. The database updater component  reads a line from the log file , splits the line into separate fields, and writes the fields as a new record in the database . The database updater component  includes instructions that do not allow duplicate records to be written into the database .","Once all the source input files have been processed by the static checker and the relevant programming constructs stored in database , the static checker is ready to detect incompatibilities between two databases as described above in conjunction with FIG. . In addition, by generating database  in accordance with the present invention, documentation related to the new software release may be automatically updated using the information within database . Using the teaching of the present invention, the information within database  may be utilized for these and various other uses.","In another embodiment of the invention, the static checker  is configured to compare two sets of log files, where each set of log files is associated with a different version or release of the software. For this embodiment, parser component  may perform the document compare functionality or another component may perform the document compare functionality. The document compare functionality may strip unnecessary information from the log files before performing the document compare, such as stripping line numbers which may have changed, but would not indicate a change in the code. This embodiment allows developers the ability to easily see inadvertent modifications during development.","The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"P-00008","num":"00008"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00009","num":"00009"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00010","num":"00010"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"P-00011","num":"00011"},"figref":["FIG. 4","FIG. 2"]}]},"DETDESC":[{},{}]}
