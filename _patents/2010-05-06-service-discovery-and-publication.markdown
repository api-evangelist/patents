---
title: Service discovery and publication
abstract: A system and methods for service discovery and publication are disclosed. Application programs write requests for service discovery, publication, and subscription to a service discovery application programming interface. The service discovery application programming interface invokes one or more lower-level protocols to satisfy the discovery, publication and/or subscription request. Service information retrieved from lower-layer protocols is formatted into a consistent data model and returned to the client application. In addition, service information may be stored in a persistent data store managed by a discovery persistence service communicatively connected to the service discovery API.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08489759&OS=08489759&RS=08489759
owner: Microsoft Corporation
number: 08489759
owner_city: Redmond
owner_country: US
publication_date: 20100506
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["This application is a Continuation of, and claims priority to, co-pending application Ser. No. 10\/693,653, filed Oct. 24, 2003, entitled \u201cService Discovery and Publication,\u201d which is incorporated herein by reference.","The described subject matter relates to digital computing, and more particularly to service discovery in computing devices and computing networks.","Application programs that execute on computing devices and computer networks may require the use of services provided by other physical or logical devices connected to the computing device or network. Presently, application programs use a wide range of application programming interfaces (APIs), protocols, and object models to discover, enumerate, and describe services and devices on a local computing device or across a plurality of devices in a computer network. The mechanisms available to discover, enumerate, and describe services and devices differ significantly, even when the services and devices involved are conceptually similar.","For example, consider a situation in which an application seeks to enumerate available printers. When executing within an administered, corporate environment, the application may need to use Lightweight Directory Access Protocol (LDAP) to communicate with a Microsoft Active Directory\u00ae directory service store to discover registered corporate printers, NetBT to discover print queue servers, and Bluetooth to discover personal area network printers. In addition, the application might have to invoke device management APIs to discover direct attached printers, and UPnP\u2122 APIs to discover UPnP printers. Each of these mechanisms requires understanding of a particular API, protocol, and query semantic.","The number of APIs and protocols required to for an application to discover, enumerate, and describe services complicates the task of software development.","Implementations described and claimed herein address these and other problems by providing a uniform interface that simplifies discovery and publication tasks. The uniform interface permits underlying protocols to be leveraged and eliminates the need for application developers to understand low-level protocols. The uniform interface provides a consistent, high-level abstraction of services and associated operations that targets the discovery and publication of service details over a wide range of lower-level APIs, protocols, stores, and network environments.","In one exemplary implementation, a method for discovering services available in a computing environment is provided. The method comprises: in an application program, defining a discovery scope; defining a discovery filter; and initiating a search request to a first application programming interface; and in the first application programming interface: parsing the search request; retrieving service information corresponding to the requested discovery scope and discovery filter; and returning the service information to the application program.","In another exemplary implementation, a method for publishing services available in a computing environment is provided. The method comprises, in an application program: defining a service entry object; defining a publication scope; assigning a unique key to the service; assigning a service type; defining properties for the service; and defining endpoints for the service; and initiating a publication request to a first application programming interface; and in the first application programming interface: parsing the search request; and executing at least one low-level API call to publish the service.","In another exemplary implementation, a method for deleting a published service in a computing environment is provided. The method comprises, in an application program: defining a service entry object; specifying a key corresponding to the published service; defining a deletion scope; and initiating a deletion request to a first application programming interface; and in the first application programming interface: parsing the search request; and executing at least one low-level API call to delete the service.","In another exemplary implementation, a method of subscribing to service events in a computing environment is provided. The method comprises, in an application program: defining a scope; defining a filter; defining a callback function; and initiating a subscription request to a first application programming interface; and in the first application programming interface: parsing the search request; and executing at least one low-level API call to subscribe to service events; and returning information from service events to the application program.","In another exemplary implementation, a system for managing information about services available in a computing environment is provided. The system comprises a first application programming interface configured to accept service queries from an application, wherein the first application programming interface receives service queries in a first service query protocol, processes the service queries, and launches at least one corresponding service query to a second protocol; a discovery persistence service communicatively connected to the first application programming interface, wherein the discovery persistence service receives service information from the first application programming interface and stores the service information in a data store.","Described herein are exemplary methods and software architecture for service discovery and publication. The methods described herein may be embodied as logic instructions on a computer-readable medium. When executed on a processor, the logic instructions cause a general purpose computing device to be programmed as a special-purpose machine that implements the described methods. The processor, when configured by the logic instructions to execute the methods recited herein, constitutes structure for performing the described methods.","Exemplary Operating Environment",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1","b":["130","130"]},"Computing device  includes one or more processors or processing units , a system memory , and a bus  that couples various system components including the system memory  to processors . The bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. The system memory  includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computing device , such as during start-up, is stored in ROM .","Computing device  further includes a hard disk drive  for reading from and writing to a hard disk (not shown), a magnetic disk drive  for reading from and writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the bus  by an SCSI interface  or some other appropriate interface. The drives and their associated computer-readable media provide nonvolatile storage of computer-readable instructions, data structures, program modules and other data for computing device . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer-readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROMs), and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk , magnetic disk , optical disk , ROM , or RAM , including an operating system , one or more application programs , other program modules , and program data . A user may enter commands and information into computing device  through input devices such as a keyboard  and a pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are connected to the processing unit  through an interface  that is coupled to the bus . A monitor  or other type of display device is also connected to the bus  via an interface, such as a video adapter . In addition to the monitor, personal computers typically include other peripheral output devices (not shown) such as speakers and printers.","Computing device  commonly operates in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to computing device , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, computing device  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, computing device  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the bus  via a serial port interface . In a networked environment, program modules depicted relative to the computing device , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Generally, the data processors of computing device  are programmed by means of instructions stored at different times in the various computer-readable storage media of the computer. Programs and operating systems are typically distributed, for example, on floppy disks or CD-ROMs. From there, they are installed or loaded into the secondary memory of a computer. At execution, they are loaded at least partially into the computer's primary electronic memory. The invention described herein includes these and other various types of computer-readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described below.","Exemplary Software Architecture Overview",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 2","FIG. 1"],"b":["200","134","134","210"]},"Application programs  invoke service discovery API  to discover services available in the computing environment. Service discovery API  provides a high-level grammar for expressing discovery queries. The grammar may be implemented in OPath, a natural query language used for expressing discovery queries. This high-level grammar provides software developers a more conceptual mechanism to express the service(s) the developer is looking for, rather than requiring a more granular and protocol-specific expression that may be required by the underlying protocols -. The developer can construct a query using the high-level grammar, which may then be forwarded to either a specific set of protocols, referred to as a number of \u201cconcrete scopes\u201d, or use an \u201cabstract scope\u201d which is a predefined or configured set of concrete scopes. In addition to supporting service discovery, the system supports service publication\/deleting, and monitoring for events.","Service discovery API , in turn, invokes one or more underlying protocols, represented in the diagram by Protocol 1  through Protocol 8 . The particular number of underlying protocols is not important. Certain of the protocols - may be directory-backed protocols such as, e.g., LDAP, Universal Description, Discovery and Integration (UDDI), and Domain Name System (DNS) Server. Other protocols may be ad-hoc protocols such as, e.g., Bluetooth, UPnP, and NetBT. One or more of the underlying protocols - uses a communication connection  to communicate with other components or services available in the computing environment.","In response to the discovery request, the service discovery API returns a collection of ServiceEntry objects that represent matching services discovered either on the local machine or on the network. A ServiceEntry object is a generalized data structure that can represent much of the relevant detail returned by the underlying protocols that system supports. Each ServiceEntry object corresponds to a single instance of a service. In one implementation, the ServiceEntry object provides descriptive and identifying properties including: (1) a service name; (2) a service description; (3) endpoints, which typically contain a network address(es) for the service; (4) a key, that identifies the service instance; (5) properties, e.g., an extensible list of name-value pairs for service or device characteristics; and (6) a provider, e.g., an identifier that identifies the entity that provides the service.","A discovery persistence service  communicates with service discover API . Among other things, discovery persistence service  registers for announcement events over ad-hoc protocols. The discovery persistence service is notified when an announcement event is detected, and the discovery persistence service copies information about the service announcement into a memory location in data store . Storing service details in a memory location enables discovery of services that may be currently unavailable. For example, even if a printer is currently switched off details about the printer may be registered in the memory location and can be discovered. In addition, service queries are not restricted to the protocol that communicates with the service. Moreover, the performance of querying the memory location may be much better than issuing a broad network discovery query.","Exemplary Operations","In an exemplary implementation, the service discovery API  provides methods for service discovery, service publication, and subscribing to service event notifications.  is a flowchart illustrating operations  for service discovery. At operation  an application defines a scope, at operation  the application defines a filter, and at operation  the application issues a search request. The service discovery API  receives the search request and, at operation , the service discovery API  parses the search request. At optional operation , the service discovery API  determines whether the search request is resolvable using information stored in the discovery persistence service . In one implementation, information managed by the discovery persistence service  includes a time-of-life indicator that specifies the lifespan of the information in the discovery persistence service . Depending upon control and configuration, the service discovery API  may query the discovery persistence service  to determine whether the discovery request can be satisfied using information the discovery persistence service  manages on the data store . If the discovery request is resolvable using the discovery persistence service , then control passes to operation , and the service entry objects retrieved from the discovery persistence service  are returned to the application.","By contrast, if the discovery request is not resolved or resolvable using information managed by the discovery persistence service , then control passes to operation , and the service discovery API  executes the low-level API call(s) required to fulfill the discovery request. At operation  the service information returned from the low-level API calls is formatted into service entry objects, and at optional operation  the service entry objects are forwarded to the discovery persistence service, which may store the service entry objects on data store . At optional operation  further processing and filtering of the service entry results such as duplicate detection and removal may be performed. At operation  the service entry objects are returned to the application for further processing, at operation . The particular details of the further processing performed by the application are not important.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 4","b":["410","415","420","425","430","432","435"]},"The service discovery API  receives the publication request and, at operation , parses the publication request. At operation  the service discovery API  executes the low-level API calls to execute the service publication request. At optional operation  the service publication is stored in the discovery persistence service .","The service publication facilities of the service discovery API  can also be used to delete a published service.  is a flowchart illustrating operations for service deletion. At operation  an application defines a service entry object for the service publication. At operation  the application specifies the unique key for the service. At operation  the application defines a scope for the service deletion. At operation  the application generates a service deletion request.","The service discovery API  receives the deletion request and, at operation , parses the deletion request. At operation  the service discovery API  executes the low-level API calls to execute the service deletion request. At optional operation  the service publication is deleted from the discovery persistence service .","The service discovery API  can also be used to allow applications to be notified of service events, such as the arrival or departure of a new service or device of a particular type.  is a flowchart illustrating operations  for subscribing to service events. At operation  an application defines a scope that specifies the particular low-level protocol to monitor. At operation  the application defines a filter that specifies the type of event. At operation  the application defines a callback function that will receive ServiceEntry details as matching events occur. At operation  an application generates a subscription request, which is forwarded to the service discovery API .","The service discovery request API  receives the subscription request and, at operation , parses the subscription request. At operation  the service discovery request executes the low-level protocol calls required to implement the subscription service. When a service event occurs the low-level protocol will provide the service discovery API with a notification of the event. At operation  the event notification is formatted into a service entry object. At optional operation  the service entry object may be stored in the discovery persistence service , and at operation  the service entry object is returned to the application using the previously specified callback function. At operation  the application performs further processing on the service entry object. The particular details of the further processing performed by the application are not important.","The system's components and operations are discussed in greater detail below.","API Classes","Filters","A Filter is a set of rules by which a service description can be evaluated, resulting in true (i.e., service description matches the filter) or false (i.e., service description doesn't match the filter). A filter can be expressed either as a simple filter, which specifies particular properties, or as a rich filter, which uses more expressive grammar. Whether expressed as a simple filter or a rich filter, queries can be specified and executed over more than one protocol without modification, subject to the capabilities of the underlying protocols. The service discovery request API  manages the re-expression of the higher level query into the correct format for the underlying low-level protocol. For example, the service discovery request API  can receive a query for a particular service type and express and evaluate it using LDAP for Active Directory and using the UDDI protocol for a UDDI Web service registry. An application developer is not required to work directly with the individual protocols.","In an exemplary implementation, the service discovery request API  requires discovery modules to support a simple filter, providing exact match semantics for provided criteria, and a rich filter containing a query expressed in the OPath grammar. It will be appreciated that each may also support additional \u201cnative\u201d filter types. Different discovery modules may have protocol-specific native filter types, e.g., UPnP may use XPath filters, Active Directory may natively use LDAP filters, and UDDI may natively use a UDDI filter.","The base level of OPath filter functionality across the modules further insulates applications from underlying discovery protocols. The filter class exposes additional methods to parse and interpret the filter in a way that is shared across the modules.","A simple filter provides for expression of queries by specifying a service type, services interfaces, and\/or properties. Any combination of these settings may be provided in a search query, and services will be included in the resulting service entry collection only if all of the criteria exactly match.","The service type may be implemented as a string that specifies the type that must match the service instances. A common set of service types are predefined in the service discovery request API . This set may be extended as key entities within protocols and stores are identified. For example, for printers in Active Directory, this would specify: filter.ServiceType=CommonServiceTypes.Printer.","The service interfaces may be implemented as a string collection that specifies identifiers for interfaces that services must match. As an example, for web services in UDDI, the following tModel identifiers could be specified: filter.ServiceInterfaces.Add(\u201cuuid:ac104dcc-d623-452f-88a7-f8acd94d9b2b\u201d); filter.ServiceInterfaces.Add(\u201cuuid:4d2ac1ca-e234-142f-e217-4d9b2f8acd9b\u201d)","Properties may be implemented in a property dictionary that specifies service characteristics that services must match. As an example, for printers in Active Directory, the following properties could be specified: filter.Properties.Add (\u201cprintcolor\u201d, \u201cTRUE\u201d); filter.Properties.Add (\u201cpagesperminute\u201d, \u201c50\u201d)","A rich filter provides a mechanism for expressing significantly richer query semantics using, e.g., the OPath grammar, by setting a Query string property. As an example, for web services in UDDI, the Query string would specify the required name and a required supported interface: filter.Query=\u201cWebService[name=\u2018Fabrikam\u2019 and ServiceInterface=\u2018uuid:ac104dcc-d623-452f-88a7-f8acd94d9b2b\u2019]\u201d","As a more expressive example to find printers in Active Directory capable of printing more than 25 pages per minute where A4 paper is not available: filter.Query=\u201cPrinter[printPagesPerMinute>20+5 and not(printmediaReady=\u2018A4\u2019)]\u201d.","Since the capabilities of the underlying protocols and stores are far from identical, ranging from the basic NetBT to the rich Active Directory query semantics, the ability to use the more expressive constructs of OPath will depend upon the scope (protocol) selected.","Scopes","A scope identifies a query domain that can be searched, usually coarse and by network location or administrative boundary. Discovery queries are directed to one or more scopes, and the query result includes a subset of the services within those scopes, i.e., the query result is the subset of all services within the scope that match the given filter. Exemplary scopes include workgroup, localmachine, and domain.","The service discovery API  accommodates concrete scopes and abstract scopes. A concrete scope specifies a query domain in three pieces. A Protocol identifier that identifies a specific protocol, e.g., mapping to a single discovery module such as ConcreteScope.NetBtProtocol. or ConcreteScope.ADProtocol, an Address (optional) identifier that specifies a server to which to direct operations on this scope such as \u201chttp:\/\/intra-uddi\/uddi\/inquire.asm\u00d7\u201d for an intranet UDDI server, and a path identifier (optional) that identifies a partition of the module's namespace, such as an LDAP search base which could be set to \u201cCN=joe-dev,CN=Computers,DC=corp,DC=fabrikam,DC=com\u201d, or a UPnPv2 scope name.","The service discovery request API  passes concrete scopes to modules. The service discovery request API  does not preclude modules from performing additional indirection on concrete scopes such as, e.g., transmitting the concrete scope over the wire to a second machine and passing the concrete scope to a corresponding API on that second machine.","An abstract scope is a moniker for one or more concrete scopes and possibly further abstract scopes. Abstract scopes provide a mechanism for targeting a query across a logical predefined or configured concrete scope collection. This provides an additional abstraction that allows the developer to target, for example, an \u201centerprise\u201d scope, without requiring explicit protocol, address, and connection details for particular directory servers.","The mapping of abstract scopes to concrete scopes is machine-wide and configurable. For example, an abstract scope AbstractScope.Enterprise might map to include both of the concrete scopes in Table 1.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"protocol = ConcreteScope.ADProtocol"]},{"entry":[{},"address = \u201cldap:\/\/dev.corp.fabrikam.com\u201d"]},{"entry":[{},"path = null"]},{"entry":[{},"protocol = ConcreteScope.UddiProtocol"]},{"entry":[{},"address = \u201chttp:\/\/uddi.fabrikam.com\/inquire.asmx\u201d"]},{"entry":[{},"path = null"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 7","b":["730","750","730","750","214"]},"Abstract scopes - provide a higher level hierarchical abstraction over and above concrete scopes. Abstract scopes are configured to include the concrete or abstract scopes that make them up. This scope mapping will be available to system administrators, who can be able to configure exactly how, for example, the AbstractScope.EnterpriseScope should be resolved.","Both concrete and abstract scopes can be used by a user of the service discovery API . In the case where an abstract scope is provided, the service discovery API  will resolve this down, through the hierarchy, to a number of concrete scopes.","Abstract scopes allow developers of application programs  to work at a relatively high level and include scope identifying terms such as \u201cAbstractScope.Enterprise\u201d in code. In this way, for example, the developer is not required to hardcode the specifics of a particular UDDI server into his code. This abstraction provides for greater reuse and portability of code. The same piece of code can be used in a variety of enterprise environments without change or recompilation. Only the abstract scope configuration would change between environments.","There may be multiple hierarchies of abstract to concrete scope mappings. In  AbstractScope.LocalMachine does not map up into AbstractScope.All even though all of its constituents are included.","In an exemplary implementation the scope map configuration may be manipulated through group policy by a system administrator to control the use of the service discover API  in the enterprise. By way of example, an administrator could define one or more abstract scopes available in the enterprise computing environment, or in a portion of the enterprise computing environment. This permits a system administrator to regulate the discovery and use of resources by applications.","ServiceEntry Results","An application developer can select appropriate Scope and Filter expression, which may then be set as properties on a service finder object. The application can then use the FindOne or FindAll methods to execute a discovery request. The FindAll method returns all services matching the supplied criteria, whereas the FindOne method returns a single matching service. The methods may be executed using a synchronous or an asynchronous calling pattern.","Assuming that there are services that match the provided filter within the specified scope, the FindOne or FindAll methods will return one, or a collection of, service entry objects. The service entry object is an abstraction over the various representations of services that the underlying protocols can provide. Each service entry object corresponds to a single instance of a service and as such, offers descriptive and identifying properties including those set forth in Table 2.",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"Property","Comments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Name","Identifies Service Instance"]},{"entry":[{},"Description","Description of Service Instance"]},{"entry":[{},"Endpoints","The set of endpoints at which the"]},{"entry":[{},{},"service instance can be accessed"]},{"entry":[{},"Key","The identifying key for the service"]},{"entry":[{},{},"instance"]},{"entry":[{},"Scopes","The scopes that an entity was"]},{"entry":[{},{},"discovered from or is to be published"]},{"entry":[{},{},"into"]},{"entry":[{},"Credentials","Specifies the credentials that will be"]},{"entry":[{},{},"used when publishing this service."]},{"entry":[{},"Provider","References the \u201cprovider\u201d (container) of"]},{"entry":[{},{},"the service, if any"]},{"entry":[{},"Expiration","Time at which the service entry will"]},{"entry":[{},{},"expire, based on a time-to-live"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"A public void Save( ) function is provided to create or update the service entry representation in the scopes specified in the scopes collection.","A public void Delete( )method removes this ServiceEntry object from the scopes specified in the Scopes property. An exception will be thrown if the service is not already published.","Pseudo-Code",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIGS. 8-19"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 19"},"Exemplary OPath Syntax","Table 3 provides exemplary OPath syntax for various discovery functions.",{"@attributes":{"id":"p-0095","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["OPath","Refers to"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Printer","Find all printers and print "]},{"entry":[{},"queues."]},{"entry":["Printer[ name = \u2018Upstairs Printer\u2019 ]","Find all printers where the "]},{"entry":[{},"name is Upstairs Printer."]},{"entry":["Printer[ printPagesPerMinute > 20 + 5 and","Find all printers capable of"]},{"entry":["not( printmediaReady = \u2018A4\u2019 )]","printing more than 25 pages "]},{"entry":[{},"per minute and A4 paper is "]},{"entry":[{},"not available."]},{"entry":["Printer[ Properties.name like \u2018Pri\u2019 and (","Find all printers where the "]},{"entry":["printPagesPerMinute \u2003>\u200310 \u2003or","name begins with Pri and "]},{"entry":["printMediaReady = \u2018letter\u2019 )]","either the pages per minute "]},{"entry":[{},"is greater than 10 or letter "]},{"entry":[{},"paper is available."]},{"entry":["Printer[\u2003supportsColor \u2002=\u2003true \u2002&& \u2002(","Find all printers which "]},{"entry":["printerName like \u2018Home\u2019 or name like ","support color and the name "]},{"entry":["\u2018Work\u2019 ) ]","begins with Home or Work."]},{"entry":["Service[","Find all services which are"]},{"entry":["ServiceInterface=ServiceConnectionPoint]","ServiceConnectionPoint "]},{"entry":[{},"objects."]},{"entry":["Service[\u2003(serviceType \u2002=\u2003\u2018Printer\u2019\u2003or","Find all services, either "]},{"entry":["serviceType= \u2018Computer\u2019 ) and name like","printers or computers, that "]},{"entry":["\u2018Work\u2019 ]","have a name like Work."]},{"entry":["Computer[\u2003operatingSystemVersion \u2002like","Find all computers that are"]},{"entry":["\u2018%3790%\u2019 ]","running an operating system"]},{"entry":[{},"whose version number "]},{"entry":[{},"contains 3790."]},{"entry":["Computer[\u2003\u2003operatingSystem=\u2018Windows","Find all computers that are"]},{"entry":["Server 2003\u2019 ]","running a particular "]},{"entry":[{},"operating system. The "]},{"entry":[{},"operatingSystem attribute "]},{"entry":[{},"is not included in the"]},{"entry":[{},"global catalog."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 4 contains examples of OPath syntax that can be used on the UDDI protocol.",{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["OPath","Refers to"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["WebService[ name = \u2018Fabrikam\u2019]","Find all Web services where the"]},{"entry":[{},"name is Fabrikam."]},{"entry":["WebService[ name = \u2018UDDI%\u2019","Find all Web services where the"]},{"entry":["&& \u2003\u2003ServiceInterface \u2003\u2003=","name starts with UDDI and that"]},{"entry":["\u2018uuid:ac104dcc-d623-452f-88a7-","supports the identified interface"]},{"entry":["f8acd94d9b2b\u2019 ]","(i.e. the tModel uddi-"]},{"entry":[{},"org:inquiry_v2)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 5 contains examples of OPath syntax that can be used on the NetBT protocol.",{"@attributes":{"id":"p-0099","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["OPath","Refers to"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Workstation","Find all workstations."]},{"entry":["Service[\u2003\u2003ServiceType \u2003\u2003=","Find all services of type"]},{"entry":["\u2018PrintQueueServer\u2019 ]","PrintQueueServer."]},{"entry":["Computer[\u2003\u2003serviceInterface \u2003=","Find all domain controller"]},{"entry":["\u2018DomainController\u2019\u2003\u2003\u2003\u2003and","computers running as a terminal"]},{"entry":["ServiceInterface = \u2018TerminalServer\u2019 ]","server."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"As described briefly above, the discovery persistence service  manages a persistent data store for service information. Periodically, or at predetermined events, such as startup, the discovery persistence service registers to receive ad-hoc device\/service announcements. As an example, when a new UPnP device is introduced it will generate a device announcement that will be handled by the UPnP protocol module. This module will then surface details of that event (the device and its services) to the discovery persistence service through the service discovery API .","Using its persistent data store, the discovery persistence service then determines whether this is a new device\/service or a returning device\/service. If it is a new device\/service, the details of the device and its services will be registered in the persistent data store. When another consumer of the service discovery API  then attempts to find services, the service discovery API  will be able to return services for ad-hoc devices\/services, even if the devices are not currently available. For the above example, in the case where the device\/service is currently available, depending upon the scope specified, both the UPnP protocol module and the persistent data store module may return results for the device. In addition to UPnP, this functionality applies to other ad-hoc discovery mechanisms.","Thus, the discovery persistence service , the service discovery API , and the local database store  provide a layer of abstraction over the various low-level protocols used for device and service discovery. This additional layer of abstraction establishes a common and improved search semantic that application developers may use in developing applications.","In addition, the discovery persistence service , the service discovery API , and the local database store  provide a consolidated discovery model for services and devices on a local machine, a home network(s), an enterprise network(s), and the internet. Thus, application developers can discover services in a wide variety of locations by writing to a single, consistent API.","Although the described arrangements have been described in language specific to structural features and\/or methodological operations, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or operations described. Rather, the specific features and operations are disclosed as preferred forms of implementing the claimed present subject matter."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
