---
title: Providing access to shared state data
abstract: Methods, systems, and computer-readable media for manipulating in-memory data entities are provided. Embodiments of the present invention use a Representational State Transfer (“REST”) web service to manipulate the in-memory data entities. In one embodiment, a “snap shot” is taken of the in-memory data entities at a point in time to create representations of the entities. A hierarchy of the representations is built. The hierarchy is used to make the entities addressable via a URI. Embodiments of the invention may then map the entity representations in the hierarchy to the entities. An embodiment of the invention uses handlers to process a REST style request addressed to an entity representation. The handler reads the command and determines whether the command is authorized for performance on the entity and performs that command, if appropriate.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08856260&OS=08856260&RS=08856260
owner: Microsoft Corporation
number: 08856260
owner_city: Redmond
owner_country: US
publication_date: 20110614
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["With improved connectivity and access of computers and other devices to various networks, it has become commonplace for different programs, or clients, to share access to the same information, such as data objects. Sharing of data objects enables the sharing of information in real-time across multiple, disparate clients, such as machines that are running multiple pieces of technology. With the sharing of data objects comes the inevitable issue of access to the data objects, including who is allowed to modify the data and what modifications are allowed. In order to track the modifications, applications running on different machines maintain active communications sessions with a central machine that managers data truth and\/or with other machines that are accessing the data.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used in isolation as an aid in determining the scope of the claimed subject matter.","Embodiments of the present invention use a Representational State Transfer (\u201cREST\u201d) web service to manipulate in-memory data entities. Natively, the in-memory data entities can not be manipulated with a REST style command, in part, because the entities are not addressable with a uniform resource identifier (\u201cURI\u201d) due to the nature of the in-memory storage. Additionally, without embodiments of the present invention, the in-memory data entities that are actively involved in a data sharing service are not well suited for manipulation with a REST style command because entities states may be rapidly changing apart from the REST web service.","In one embodiment, a \u201csnapshot\u201d is taken of the in-memory data entities at a point in time to create representations of the entities. A hierarchy of the representations is built. The hierarchy is used to make the entities addressable via a URI that is addressed to the entity representations in the hierarchy. Example entities include namespaces, collections, objects, and properties.","An embodiment of the invention uses handlers to process a REST style request addressed to an entity representation. As used herein, handlers are specialized applications that process the REST style requests. Initially, one or more handlers follow the URI to the entity that corresponds to the addressed representation. The handler reads the command in the request and determines whether the command is authorized for performance on the entity. The authorization could be based on entity type. For example, rules can be created that specify that certain actions could be preformed on objects, but not collections. In addition, the entity may have changed states since the representation was created and the handler may determine that the action can't be taken due to the change in state.","The subject matter of embodiments of the invention is described with specificity herein to meet statutory requirements. However, the description itself is not intended to limit the scope of this patent. Rather, the inventors have contemplated that the claimed subject matter might also be embodied in other ways, to include different steps or combinations of steps similar to the ones described in this document, in conjunction with other present or future technologies. Moreover, although the terms \u201cstep\u201d and\/or \u201cblock\u201d may be used herein to connote different elements of methods employed, the terms should not be interpreted as implying any particular order among or between various steps herein disclosed unless and except when the order of individual steps is explicitly described.","Embodiments of the present invention use a Representational State Transfer (\u201cREST\u201d) web service to manipulate in-memory data entities. Natively, the in-memory data entities can not be manipulated with a REST style command, in part, because the entities are not addressable with a uniform resource identifier (\u201cURI\u201d) due to the nature of the in-memory storage. Additionally, without embodiments of the present invention, the in-memory data entities that are actively involved in a data sharing service are not well suited for manipulation with a REST style command because entities states may be rapidly changing apart from the REST web service.","In one embodiment, a \u201csnap shot\u201d is taken of the in-memory data entities at a point in time to create representations of the entities. A hierarchy of the representations is built. The hierarchy is used to make the entities addressable via a URI that is addressed to the entity representations in the hierarchy. Example entities include namespaces, collections, objects, and properties.","An embodiment of the invention uses handlers to process a REST style request addressed to an entity representation. As used herein, handlers are specialized applications that process the REST style requests. Initially, one or more handlers follow the URI to the entity that corresponds to the addressed representation. The handler reads the command in the request and determines whether the command is authorized for performance on the entity. These commands may be defined as part of the Hypertext Transfer Protocol (\u201cHTTP\u201d) protocol (and REST design pattern) and include: POST, PUT, GET and DELETE which map to: Create, Read, Update and Delete\u2014commonly referred to as CRUD. The authorization could be based on entity type. For example, rules can be created that specify that certain actions could be preformed on objects, but not collections. In addition, the entity may have changed states since the representation was created and the handler may determine that the action can't be taken due to the change in state.","Having briefly described an overview of embodiments of the invention, an exemplary operating environment suitable for use in implementing embodiments of the invention is described below.","Exemplary Operating Environment","Referring to the drawings in general, and initially to  in particular, an exemplary operating environment for implementing embodiments of the invention is shown and designated generally as computing device . Computing device  is but one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing device  be interpreted as having any dependency or requirement relating to any one or combination of components illustrated.","The invention may be described in the general context of computer code or machine-useable instructions, including computer-executable instructions such as program components, being executed by a computer or other machine, such as a personal data assistant or other handheld device. Generally, program components, including routines, programs, objects, components, data structures, and the like, refer to code that performs particular tasks, or implements particular abstract data types. Embodiments of the invention may be practiced in a variety of system configurations, including handheld devices, consumer electronics, general-purpose computers, specialty computing devices, etc. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote-processing devices that are linked through a communications network.","With continued reference to , computing device  includes a bus  that directly or indirectly couples the following devices: memory , one or more processors , one or more presentation components , input\/output (I\/O) ports , I\/O components , and an illustrative power supply . Bus  represents what may be one or more busses (such as an address bus, data bus, or combination thereof). Although the various blocks of  are shown with lines for the sake of clarity, in reality, delineating various components is not so clear, and metaphorically, the lines would more accurately be grey and fuzzy. For example, one may consider a presentation component such as a display device to be an I\/O component . Also, processors have memory. The inventors hereof recognize that such is the nature of the art, and reiterate that the diagram of  is merely illustrative of an exemplary computing device that can be used in connection with one or more embodiments of the invention. Distinction is not made between such categories as \u201cworkstation,\u201d \u201cserver,\u201d \u201claptop,\u201d \u201chandheld device,\u201d etc., as all are contemplated within the scope of  and reference to \u201ccomputer\u201d or \u201ccomputing device.\u201d","Computing device  typically includes a variety of computer-storage media. By way of example, and not limitation, computer-storage media may comprise Random Access Memory (RAM); Read Only Memory (ROM); Electronically Erasable Programmable Read Only Memory (EEPROM); flash memory or other memory technologies; Compact Disk Read-Only Memory (CDROM), digital versatile disks (DVDs) or other optical or holographic media; magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices; or any other medium that can be used to encode desired information and be accessed by computing device . Computer-storage media may be nontransitory.","Memory  includes computer-storage media in the form of volatile and\/or nonvolatile memory. The memory  may be removable, nonremovable, or a combination thereof. Exemplary memory includes solid-state memory, hard drives, optical-disc drives, etc. Computing device  includes one or more processors  that read data from various entities such as bus , memory  or I\/O components . Presentation component(s)  present data indications to a user or other device. Exemplary presentation components  include a display device, speaker, printing component, vibrating component, etc. I\/O ports  allow computing device  to be logically coupled to other devices including I\/O components , some of which may be built in. Illustrative I\/O components  include a microphone, joystick, game pad, satellite dish, scanner, printer, wireless device, etc.","Exemplary System Architecture","Referring now to , a block diagram is provided illustrating an exemplary computing system environment  suitable for use in implementing embodiments of the present invention. It will be understood and appreciated by those of ordinary skill in the art that the computing system environment  shown in  is merely an example of one suitable computing system environment and is not intended to suggest any limitation as to the scope of use or functionality of embodiments of the present invention. Neither should the computing system environment  be interpreted as having any dependency or requirement related to any single module\/component or combination of modules\/components illustrated therein.","The system environment  includes client devices  and , a shared data server , a data store , a receiving component , a shared-object service , and a REST service , all in communication with one another through a network . The network  may include, without limitation, one or more local area networks (LANs) and\/or wide area networks (WANs) including the Internet. Such networking environments are commonplace. Accordingly, the network  is not further described herein.","In some embodiments, one or more of the illustrated components\/modules may be implemented as stand-alone applications. In other embodiments, one or more of the illustrated components\/modules may be integrated directly into other components. Further, components\/modules may be located on any number of servers, client devices, or the like. By way of example only, the shared data server  might reside on a larger server, cluster of servers, or a computing device remote from one or more of the remaining components.","With continued reference to , each of client devices  and , and shared data server  may be any type of computing device, such as computing device  described with reference to . It should be understood that any number of client devices, servers, and data stores may be employed within the system environment  within the scope of the present invention. Each may comprise a single device or multiple devices cooperating in a distributed environment. For instance, the shared data server  may comprise multiple devices arranged in a distributed environment that collectively provide the functionality of the shared data server  described herein. Additionally, other components not shown may also be included within the system environment , while components shown in  may be omitted in some embodiments.","The client devices  and  may be any type of computing device owned and\/or operated by a client that can access the network . For instance, each of the client devices  and  may be a desktop computer, a laptop computer, a tablet computer, a mobile device, or any other device having network access. Generally, a user may employ the client devices  and  to, among other things, attempt to open, delete, modify, etc., a data object stored on the shared data server . In one instance, the client device  attempts to access and modify a data object stored on the data store . As will be described herein, logic on the shared data server  may dictate whether this client is even allowed to open that data object, let alone make any modifications to it.","The shared data server  comprises various components, including a receiving component , the shared-object service , and the REST service . Generally, the receiving component  is configured to receive rule enforcement logic from a developer of an application, typically referred to as an originating client. Rule enforcement logic is logic that, in one embodiment, is provided by the developer of an application that may be used in conjunction with data objects. Instead of being stored by each developer individually, the rule enforcement logic may be stored by the system, such as on the shared data server  or the data store .","The receiving component  routes communications between client devices  and  and shared-object service  and REST service . As mentioned, the data within data store  may be manipulated through two different mechanisms. Accordingly, the receiving component  directs communications to the appropriate components. The receiving component  may maintain connections and manage communication sessions between the shared data server  and client devices  and .","The shared-object service  manages a shared-object model. The shared-object model comprises data entities . The data entries are shared between different applications, which may manipulate the entities . The entities  stored in data store  represents the \u201ctruth\u201d of an entity, in the sense that differences between what the server copy says about the entity and what a local copy says about the entity may be resolved in favor of the server copy. The shared-object service  may manage concurrency and\/or access controls on an object, property, collection, or namespace.","The shared-object service  propagates the truth of an entity to machines other than those that make up the shared data server . For example, client device  includes a local copy  of the entities . Applications on client device  directly interact with the local copy . A shared-object runtime on client device  notifies the shared-object service  of the change to entities that arise on the client device . The shared-object service  then changes the entities  to reflect the changes made in the machines. These changes may then be propagated to other devices that are currently accessing the entities .","If two machines make changes to an entity at the same time, conflict resolution rules may be used to resolve inconsistent changes to an entity. Once the truth of the entity is determined by shared-object service  the subscribing clients are notified of updates to the entity's state. If access controls had been set on the entity, then the current state of the entity is provided only to machines that are allowed to access the entity. Access control rules might be used to reject any updates from clients that don't have permission to write to the entity, to delete the entity, etc. When a client device receives a notification that the truth of the entity has changed, the shared-object runtime on each client device updates the client's local copy of the entity to match the truth of the entity. The notifications back and forth may be routed by receiving component .","The REST service  provides an alternative mechanism for modifying entities . The REST service  does not require that the client device maintain a local copy of an entity. Instead, the REST service uses Representational state transfer (\u201cREST\u201d) style requests to modify the entities  and receives information about the states of the entities . REST is an application program style used in computing environments that include servers and clients. Clients may initiate requests to servers, servers process the request, and return appropriate responses. These requests (or commands) may be defined as part of the HTTP protocol (and REST design pattern) and include: POST, PUT, GET and DELETE which map to: Create, Read, Update and Delete\u2014commonly referred to as CRUD. The REST service  receives these requests and processes them. As with the shared-object service , the REST service  may determine whether clients have access to an entity, and the type of access presented. Further, the REST service may allow different actions to be performed on different types of entities. The different types of actions allowed for different entities will be explained in more detail subsequently.","In embodiments of the present invention, the data store maintains the entities  in an in-memory type of storage. Entities within the in-memory storage are not directly addressable by a URI because the entities do not maintain a fixed location or address within the in-memory storage. The hierarchy of entities can change so there are no fixed URI addressing schemes. REST type requests include a URI with an instruction to manipulate an entity associated with the URI. The REST service  builds a representation of the entities  that is addressable so that the REST type request can be processed to manipulate an entity. In one embodiment, the REST service  takes a \u201csnapshot\u201d of the state of each entity within entities  at a point in time to build entity representations. In one embodiment, the \u201cpoint in time\u201d is when a request is received. Representations of entities are then placed into an entity hierarchy. The hierarchy reflects relationships between the entities. For example, a namespace entity may be a root note. Collections within that namespace may be a subnode to the namespace, objects within a particular collection may be a subnode to a particular collection, and properties associated with an object may be subnodes under the object level.  is one example of such a hierarchy and the relationships between entities.","Embodiments of the present invention manipulate data entities within in-memory storage. Examples of the data entities include namespaces, collections, objects, and object properties. In order for different machines, applications, and application instances to share access to an object, they share a common namespace. That is, for all entities that will access a shared object, the same name refers to the same object. For example, a first namespace may contain names bob, bob, and bob. If client devices  and  are to share access to bob, then the name of that object (e.g., bob) will have the same meaning on both client devices  and . One example of a namespace is an instance of a chat room.","Data objects, as used herein, refer to any entity that is able to be manipulated by commands of one or more programming languages, such as value, variable, function, or data structure. In software development, objects are used to implement abstract data structures by bringing together the data components with the procedures that manipulate them. An object stores its state in fields, or variables in some programming languages, and exposes its behavior through methods, or functions in some programming languages. Many instances of a particular object may exist, and thus these instances belong to a particular class, which is the blueprint from which individual objects are created. Once created, objects may be updated or modified by a number of clients. In one embodiment, a client attempts to perform an action (e.g., open, close, delete, modify) on a data object that has been opened using a particular application. As used herein, an application is computer software designed to assist a user to perform tasks, and as mentioned, may be used to open and modify various data objects, including documents. A chat entry is one example of an object that may be shared between clients.","An object may be a container for one or more properties. Properties can be modified and form a separate type of entity. The property may be defined independently of an object and then associated with one or more objects. A property is not a container for other entities.","A collection is a group of objects. Collections themselves implement a set of operations, such as adding and removing items from a collection. In the REST modeling, certain objects can act as \u201ccontainers\u201d which means they can support operations such as \u201cCreate\u201d which would create a subordinate resource under the container. A collection and an object are examples of containers. Some examples of collections include lists, arrays, sets, bags, and various other groups of data. Some types of collections are ordered. That is, the current state of an ordered collection is defined not merely by the contents of the collection, but also by the order in which those contents appear. For example, {1, 2, 3, 4, 5} is a collection of data that contains the integers one through five, inclusive. If the collection is ordered, then {1, 2, 3, 4, 5} is a different state from {2, 4, 3, 1, 5} because these two states have different orders even though they both contain the same items. A list of chat entries is one example of a collection.","Turning now to , a representation hierarchy  that models entities within in-memory data is shown, in accordance with an embodiment of the present invention. Three namespace representations are shown on the first or root level: Namespace , , namespace , , and namespace , . Each namespace representation may be thought of as a root node. As shown, only namespace , , has subnodes. Namespace representations may have collections or objects as subnodes. The collection representations include collection , , collection ,  and collection N, . Under collection , , three object representations are shown. The object representations include object , , object , , and object N, . Under object , , three property representations are shown. The property representations include property , , property , , and property N, .","URI  is addressed to an entity in the hierarchy . The URI  may be thought of as including five different segments. The first segment \u201chost.com\u201d identifies a particular set of shared entities. The second segment \u201cnamespace \u201d identifies a namespace within the shared entities. In this case, \u201cnamespace \u201d corresponds to namespace , . The third segment \u201ccollection \u201d corresponds with collection , . The fourth segment corresponds with object , . The fifth segment, \u201cproperty \u201d corresponds with property , . Thus, a REST style request with the URI  is addressed to property   representation. Property ,  can then be mapped to a property within the entities  by the REST service . Again, the representations in the hierarchy are not the actual entities, but instead provide a fixed address that the REST service uses to process a REST style request. As part of the processing, a representation may be mapped to a corresponding entity.","In one embodiment, handlers are invoked for each level of the hierarchy . For example, a handler, which is a specific application that processes REST requests, may handle all requests that are addressed to a namespace representation. Initially, upon receiving a request, the request may be sent to a handler associated with the root node of a hierarchy, in this case, namespaces. The handler determines whether the URI is addressed to a namespace representation. If the URI is not addressed to a namespace representation, then the namespace handler passes the request along to a handler associated with the hierarchal level below namespaces. In this case, the namespace handler would pass a request addressed to URI  to the collection handler. The collection handler would make a similar determination and pass the request addressed to URI  to the object handler. The object handler would similarly determine that the request addressed to URI  is not addressed to an object entity and pass the request to a property handler. The property handler would determine that the request addressed to URI  is addressed to a property representation. Further the property handler would recognize that the request is addressed to property , . The property handler would then perform the instruction specified in the request after validating that the instruction should be performed.","Turning now to , communications occurring during the handling of requests are shown, in accordance with an embodiment of the present invention. The computing environment  in  includes a client device , that may be similar to client device  described previously with reference to . Computing environment  also includes a namespace handler , a collection handler , an object handler , and a property handler . The handlers , , , and  may be associated with a component similar to the REST service  described previously.","Initially, a request  is communicated from the client device  to the namespace handler . In an actual embodiment, there may be several intermediate components such as receiving component  in between the client device  and the namespace handler . Those components are not shown as the primary purpose of  is to illustrate how the handlers , , , and  process a request.","The namespace handler  initially determines  that the request  does not include a URI that is addressed to a representation of a namespace. For example, URI  (in ) is not addressed to a namespace because it includes additional segments that are below a namespace. Having determined  that the request  is not addressed to a namespace representation, the namespace handler  communicates the request  to the collection handler , which is associated with representations of collections. The collection handler  similarly determines  that the request  is not addressed to a collection representation. The collection handler  then passes the request  to the object handler . The object handler  determines  that the request  is not addressed to an object representation either. Finally, the object handler  communicates the request  to a property handler .","The property handler  determines  that the request  is addressed to a representation of a property. The property handler  then maps the representation of the property to the corresponding property within the in-memory storage. The instruction associated with the request  is then processed. For example, the request  may be a GET request to retrieve the current value of a property. In this case, the property handler  retrieves the current state of the property associated with the property representation indicated in the URI within request  and communicates a response  back to the client device . Other types of requests that may be received include a POST request, a PUT request, and a DELTE request. A POST-request would not be appropriate for properties in this case because there is no subordinate resource for properties.","In , specific handlers have management responsibility for specific hierarchical levels or entities. Embodiments of the present invention are not limited to dedicated handlers. Further, embodiments are not limited to four hierarchical levels. More generally, a handler with management responsibility for a URI segment inspects the current portion of the URI segment and if there are no remaining segments then it handles the request. If there are remaining segments, then it looks at its \u201cchildren\u201d and passes the URI to them. That is, to a child URI handler. In this way, the abstract URI handler is extensible to any kind of hierarchy.","Turning now to , a method  of manipulating in-memory data entities is shown, in accordance with an embodiment of the present invention. The in-memory data entities may include, namespaces, collections, objects, and properties. At step , a request is received to manipulate entities within the in-memory storage that are not addressable by the URI in the entity's native form. The request may be defined as part of the HTTP protocol (and REST design pattern) and include: POST, PUT, GET, and DELETE which map to: Create, Read, Update and Delete\u2014commonly referred to as CRUD.","At step , representations of entities within the in-memory data are generated. The representations are based on a state of the entities at a particular point in time. Once the representations are generated, the states may change apart from the representation within the in-memory storage. The representations themselves provide a fixed, addressable location that can then be mapped to the entities using the entities name. Throughout the specification, a URI may be described as being addressed to either an entity representation or just the entity for short. In either case, a representation is used to provide an addressable location.","At step , a hierarchy of the representations is generated. The hierarchy is based on entity type and relationships between entities within the in-memory data. For example objects within a collection are placed a level below the representation of the collection. The representation of the objects are placed in nodes that are attached to the collection representation. As mentioned, each level of the hierarchy may correspond with a URI segment. In that way, each entity representation within the hierarchy of representations may be addressed by a URI.","At step , the URI is inspected to identify segments within the URI. At step , the hierarchy is traversed using the segments to reach a representation of an entity indicated by the URI. In one embodiment, the hierarchy is traversed by a group of handlers passing the request down the hierarchy until the appropriate entity representation is identified. At step , the manipulation instruction within the request is performed on the entity indicated by the URI. As mentioned, the URI actually points to a representation of the entity, but the intent is to modify the entity that is associated with the representation, not the representation. A handler processing the request is able to locate the actual entity associated with the entity representation. In one embodiment, the handler uses unique identification information associated with the entity and the entity representation to locate the entity. By performing the manipulation, the actual entity may be changed. If the manipulation requested is only a read operation, then the entity may be unchanged. In one embodiment, once an entity is changed, the new state of the entity is propagated to all applications that are sharing the object.","Turning now to , a method  of manipulating in-memory data using representational state transfer (\u201cREST\u201d) style commands is shown, in accordance with an embodiment of the present invention. At step , representations of entities within the in-memory data are generated. The representations have been described previously. At step , a hierarchy of the representations is generated according to entity type and according to relationships between the entities within the in-memory data. For example, objects within a collection may be subnodes of the collection node. At step , an entity representation within the hierarchy is mapped to an entity within the in-memory data. The mapping may occur by a handler once a request is determined to be addressed to the entity representation. In another embodiment, the mapping is maintained by the handlers in anticipation of receiving a request.","At step , a REST style request is processed by following the URI within the REST style request to a representation of the entity indicated by the URI and performing a command included in the REST style request on the corresponding entity. Different commands may be performed on different types of entities. For example, with reference to namespaces, a GET command that allows a list of all top-level objects in the namespace to be retrieved may be permissible. Similarly, a POST command that allows a new object or collection to be created within the namespace may be allowed. A PUT command may not be supported. A DELETE command allows the entire namespace to be deleted. In one embodiment, referencing particular objects within a collection are not supported. Similarly, replacing an entire namespace is also not supported.","With reference to collections, a GET, POST, PUT, or DELETE command is allowed in some embodiments of the present invention. Within collections, the GET command reads a list of objects in a collection. The POST command creates a new object in the collection. The PUT command creates or updates a collection. The delete command deletes the collection.","With reference to objects, a GET command, a POST command, a PUT command, and a DELETE command are allowed in one embodiment of the present invention. A GET command reads the current state of an object. The POST command creates a new property. The PUT command creates or updates an object. The DELETE command deletes an object.","With reference to the properties, a GET command, a PUT command, and a DELETE command are allowed in one embodiment of the present invention. A POST command may not be allowed for properties because there are no subordinate resources for properties within one embodiment of the present invention. However, if additional entities were subordinate to properties, then a POST command may be allowed. The GET command retrieves the current value of a property, the PUT command creates or updates the value of a property, and a delete command deletes a property.","Turning now to , a method  of manipulating shared in-memory data entities that are actively being shared by multiple clients is shown, in accordance with an embodiment of the present invention. At step , representations of entities within the shared in-memory data are generated. The shared in-memory data service, similar to shared-object service  maintains a true copy of the entities within the shared in-memory data and communicates copies of the entities to client devices that maintain local copies of the entities. The local copies are acted on by applications on the client devices. The sharing service receives updates generated by the applications and updates the true copy of the entities and propagates the updates to each of the client devices actively sharing the entities. The entities as they are natively stored are not addressable by a uniform resource identifier.","At step , representations of the entities are generated. As mentioned previously, the representations of the entities are based on state information associated with the entities at a particular point in time. In another embodiment, the representations do not include any state information and simply represent relationships between entities at a particular point in time and provide a fixed location that is addressable by a URI.","At step , a hierarchy of representations is generated. At step , a representational state transfer (\u201cREST\u201d) style request to manipulate the shared in-memory data is received. The request comprises a URI. The request may also specify a manipulation command to be performed on an entity corresponding to a representation addressed by the URI. An entity may be addressed by addressing the representation of the entity within the hierarchy. At step , the hierarchy is traversed to reach an entity representation indicated by the URI. At step , the request is confirmed to comply with one or more rules governing allowed manipulation of the entity. Some of these rules have been mentioned previously with reference to the type of actions that can be performed on various types of entities. Other rules, such as user access to the entity, may also be checked before performing an action.","At step , the request is confirmed to still be applicable based on a current state of the entity. As mentioned, since the entities are part of a shared in-memory data, the state of an entity could change between when a request was generated and the hierarchy was built. For example, a collection could be dissolved, or objects removed from a collection. In this case, an instruction to add or delete the collection may be moot, or not possible to follow based on the changes already made. In this case, the request may be denied. The new state of the objects may be communicated to a device that sent the request in response to a request that is not able to be performed because of the changed state of an entity. At step , the request is performed on the entity that is mapped to the entity representation.","Embodiments of the invention have been described to be illustrative rather than restrictive. It will be understood that certain features and subcombinations are of utility and may be employed without reference to other features and subcombinations. This is contemplated by and is within the scope of the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the invention are described in detail below with reference to the attached drawing figures, wherein:",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
