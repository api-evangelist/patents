---
title: Graphics system interface
abstract: An interface for a graphics system includes simple yet powerful constructs that are easy for an application programmer to use and learn. Features include a unique vertex representation allowing the graphics pipeline to retain vertex state information and to mix indexed and direct vertex values and attributes; a projection matrix value set command; a display list call object command; and an embedded frame buffer clear/set command.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07071945&OS=07071945&RS=07071945
owner: Nintendo Co., Ltd.
number: 07071945
owner_city: Kyoto
owner_country: JP
publication_date: 20031120
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND AND SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXAMPLE EMBODIMENTS OF THE INVENTION","Example Call Display List Command","Other Example Compatible Implementations","Example Higher-Level API Cells"],"p":["This is a continuation of application Ser. No. 10\/207,120, filed Jul. 30, 2002, now U.S. Pat. No. 6,697,074, which is a continuation of application Ser. No. 09\/723,336, filed Nov. 28, 2000, now U.S. Pat. No. 6,452,600, the entire contents of which are hereby incorporated by reference in this application.\n\n","The present invention relates to computer graphics, and more particularly to interactive graphics systems including but not limited to home video game platforms. Still more particularly this invention relates to an advantageous software programming interface including binary command functions for controlling a graphics chip and to methods for generating, storing and decoding same.","Many of us have seen films containing remarkably realistic dinosaurs, aliens, animated toys and other fanciful creatures. Such animations are made possible by computer graphics. Using such techniques, a computer graphics artist can specify how each object should look and how it should change in appearance over time, and a computer then models the objects and displays them on a display such as your television or a computer screen. The computer takes care of performing the many tasks required to make sure that each part of the displayed image is colored and shaped just right based on the position and orientation of each object in a scene, the direction in which light seems to strike each object, the surface texture of each object, and other factors.","Because computer graphics generation is complex, computer-generated three-dimensional graphics just a few years ago were mostly limited to expensive specialized flight simulators, high-end graphics workstations and supercomputers. The public saw some of the images generated by these computer systems in movies and expensive television advertisements, but most of us couldn't actually interact with the computers doing the graphics generation. All this has changed with the availability of relatively inexpensive 3D graphics platforms such as, for example, the Nintendo 64\u00ae and various 3D graphics cards now available for personal computers. It is now possible to interact with exciting 3D animations and simulations on relatively inexpensive computer graphics systems in your home or office.","A problem graphics system designers confronted in the past was how to provide a control interface for a graphics system that enables fast, efficient and flexible use of the graphics system by applications designed to be executed thereon. Various application programming interfaces (APIs) and application binary interfaces (ABIs) have been developed in the past for the purpose of enabling graphics application programmers to control the operation of a graphics chip provided in a graphics system. Perhaps the most commonly-used 3D graphics application programming interfaces in current use are Microsoft's Direct3D interface and the OpenGL interface developed through cooperation with Silicon Graphics. See, for example, Kovach, 3-3(Microsoft Press 2000); and Neider et al., 1 (Addison-Wesley Publishing Co. 1993).","As explained in the Kovach book, Microsoft's DirectX application programming interface (API) provides a set of interfaces offering efficient control of multimedia hardware on a computer running Microsoft Windows. Kovach states that DirectX lets programmers work with commands and data structures that are very close to those that the hardware can natively process, without being so low level that code has to be written differently for each device. By writing device-independent code, programmers can create software that will theoretically always perform at its best (according to Kovach)\u2014even as users enhance their systems with new and improved 3D graphics accelerators, sound cards, input devices and other system capabilities.","Kovach explains that the device-independence of DirectX is obtained because the DirectX APIs are built on a hardware abstraction layer (HAL) that hides the device-specific dependencies of the hardware. In fact, DirectX defines some hardware acceleration support features that aren't available on much of the hardware built today in order to provide extensibility for the future.","While the DirectX approach has been widely adopted and is successful in providing compatibility across a wide range of different platform configurations, the use of a thick hardware abstraction layer and associated hardware emulation layer is not particularly suitable for current low cost dedicated video game platforms at the current time. The DirectX API was primarily designed for personal computers costing many hundreds or thousands of dollars and manufactured in a variety of different configurations and permutations. While the DirectX API has been successful in providing compatibility across a wide range of such different platform configurations, this compatibility has come at the expense of efficiency and performance. In the context of a dedicated low-cost video game platform, it is possible to do much better in terms of providing a fully capable programming interface that is very close to the hardware while providing a highly capable and flexible interface for achieving a wide variety of interesting 3-dimensional graphics effects.","One prior approach is described in U.S. patent application Ser. No. 08\/990,133 filed Dec. 12, 1997 by Van Hook et al., entitled \u201cInterface For A High Performance Low Cost Video Game System With Coprocessor Providing High Speed Efficient 3D Graphics And Digital Audio Signal Processing.\u201d However, further improvements are possible and desirable. In particular, some people criticized the interface described in this prior Van Hook et al., patent application because they thought it was difficult to write applications to. In the home video game arena, it is desirable to maximize performance while keeping the interface used to invoke and control such performance and capabilities as simple and easy to use as possible. Requiring application programmers to write to an unduly complicated interface may increase the time it takes to develop such applications. This can have devastatingly negative effects when it comes time to launch a new video game platform\u2014since the success of the platform may often depend on achieving a certain \u201ccritical mass\u201d in terms of the number of games or other applications available at launch time. As some developers of prior new home video game platforms found out, no one wants to buy a new video game system if there are no games to play on it. It is therefore desirable to provide a graphics programming interface that is simple and easy to use and yet is very powerful and flexible.","The present invention solves this problem by providing new and improved interface for graphics systems that is designed to be as thin as possible in order to achieve high performance, while also providing a logical and orthogonal view of the graphics hardware.","The present invention provides a graphics system programming interface with graphics commands allowing geometry to be rendered with many attributes. The interface provides two main methods for drawing geometry. An immediate mode allows the command stream source to send a stream of graphics commands directly to the graphics processor for consumption. This immediate mode interface is useful when the main processor must synthesize geometry data from a higher-level description (e.g., a height field or Bezier patch). The second method feeds a command stream to the graphics processor using a memory-resident display list format. This interface provides superior performance for static data. The immediate interface and the display list interface both support configurable vertex representations. The configurable vertex representations include, for example, direct or indexed vertex components. Vertex components (e.g., position, normal, color and texture coordinates for a number of textures) can all be indexed independently from arrays, or placed directly in the command stream. Additional flexibility is provided by allowing each vertex component to have a differently-sized representation and precision. The available direct types may include, for example, 8-bit signed and unsigned integer, 16-bit signed and unsigned integer, and 32-bit floating point. A scale is available to position the decimal point for the integer types. The indirect types (e.g., 8-bit index or 16-bit index) can be used to index into an array of any of the direct types. This flexible representation allows the game developer to organize vertex data in a way that is appropriate for the game. The ability to index each component separately eliminates a great deal of data duplication.",{"@attributes":{"id":"p-0033","num":"0038"},"figref":"FIG. 1","b":["50","50"]},"In this example, system  is capable of processing, interactively in real time, a digital representation or model of a three-dimensional world. System  can display some or all of the world from any arbitrary viewpoint. For example, system  can interactively change the viewpoint in response to real time inputs from handheld controllers , or other input devices. This allows the game player to see the world through the eyes of someone within or outside of the world. System  can be used for applications that do not require real time 3D interactive display (e.g., 2D display generation and\/or non-interactive display), but the capability of displaying quality 3D images very quickly can be used to create very realistic and exciting game play or other graphical interactions.","To play a video game or other application using system , the user first connects a main unit  to his or her color television set  or other display device by connecting a cable  between the two. Main unit  produces both video signals and audio signals for controlling color television set . The video signals are what controls the images displayed on the television screen , and the audio signals are played back as sound through television stereo loudspeakers L, R.","The user also needs to connect main unit  to a power source. This power source may be a conventional AC adapter (not shown) that plugs into a standard home electrical wall socket and converts the house current into a lower DC voltage signal suitable for powering the main unit . Batteries could be used in other implementations.","The user may use hand controllers , to control main unit . Controls  can be used, for example, to specify the direction (up or down, left or right, closer or further away) that a character displayed on television  should move within a 3D world. Controls  also provide input for other applications (e.g., menu selection, pointer\/cursor control, etc.). Controllers  can take a variety of forms. In this example, controllers  shown each include controls  such as joysticks, push buttons and\/or directional switches. Controllers  may be connected to main unit  by cables or wirelessly via electromagnetic (e.g., radio or infrared) waves.","To play an application such as a game, the user selects an appropriate storage medium  storing the video game or other application he or she wants to play, and inserts that storage medium into a slot  in main unit . Storage medium  may, for example, be a specially encoded and\/or encrypted optical and\/or magnetic disk that stores commands for graphics and audio processor  and\/or instructions controlling main processor  to develop such commands. The user may operate a power switch  to turn on main unit  and cause the main unit to begin running the video game or other application based on the software stored in the storage medium . The user may operate controllers  to provide inputs to main unit . For example, operating a control  may cause the game or other application to start. Moving other controls  can cause animated characters to move in different directions or change the user's point of view in a 3D world. Depending upon the particular software stored within the storage medium , the various controls  on the controller  can perform different functions at different times.","Example Electronics of Overall System",{"@attributes":{"id":"p-0039","num":"0044"},"figref":"FIG. 2","b":"50","ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["a main processor (CPU) ,","a main memory , and","a graphics and audio processor ."]}}}},"In this example, main processor  (e.g., an enhanced IBM Power PC 750) receives inputs from handheld controllers  (and\/or other input devices) via graphics and audio processor . Main processor  interactively responds to user inputs, and executes a video game or other program supplied, for example, by external storage media  via a mass storage access device  such as an optical disk drive. As one example, in the context of video game play, main processor  can perform collision detection and animation processing in addition to a variety of interactive and control functions.","In this example, main processor  generates 3D graphics and audio commands and sends them to graphics and audio processor . The graphics and audio processor  processes these commands to generate interesting visual images on display  and interesting stereo sound on stereo loudspeakers R, L or other suitable sound-generating devices.","Example system  includes a video encoder  that receives image signals from graphics and audio processor  and converts the image signals into analog and\/or digital video signals suitable for display on a standard display device such as a computer monitor or home color television set . System  also includes an audio codec (compressor\/decompressor)  that compresses and decompresses digitized audio signals and may also convert between digital and analog audio signaling formats as needed. Audio codec  can receive audio inputs via a buffer  and provide them to graphics and audio processor  for processing (e.g., mixing with other audio signals the processor generates and\/or receives via a streaming audio output of mass storage access device ). Graphics and audio processor  in this example can store audio related information in an audio memory  that is available for audio tasks. Graphics and audio processor  provides the resulting audio output signals to audio codec  for decompression and conversion to analog signals (e.g., via buffer amplifiers L, R) so they can be reproduced by loudspeakers L, R.","Graphics and audio processor  has the ability to communicate with various additional devices that may be present within system . For example, a parallel digital bus  may be used to communicate with mass storage access device  and\/or other components. A serial peripheral bus  may communicate with a variety of peripheral or other devices including, for example:\n\n","A further external serial bus  may be used to communicate with additional expansion memory  (e.g., a memory card) or other devices. Connectors may be used to connect various devices to busses , , .","Example Graphics And Audio Processor",{"@attributes":{"id":"p-0045","num":"0056"},"figref":"FIG. 3","b":["114","114","141"],"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["a processor interface ,","a memory interface\/controller ,","a 3D graphics processor ,","an audio digital signal processor (DSP) ,","an audio memory interface ,","an audio interface and mixer ,","a peripheral controller , and","a display controller ."]}}}},"3D graphics processor  performs graphics processing tasks. Audio digital signal processor  performs audio processing tasks. Display controller  accesses image information from main memory  and provides it to video encoder  for display on display device . Audio interface and mixer  interfaces with audio codec , and can also mix audio from different sources (e.g., streaming audio from mass storage access device , the output of audio DSP , and external audio input received via audio codec ). Processor interface  provides a data and control interface between main processor  and graphics and audio processor .","Memory interface  provides a data and control interface between graphics and audio processor  and memory . In this example, main processor  accesses main memory  via processor interface  and memory interface  that are part of graphics and audio processor . Peripheral controller  provides a data and control interface between graphics and audio processor  and the various peripherals mentioned above. Audio memory interface  provides an interface with audio memory .","Example Graphics Pipeline",{"@attributes":{"id":"p-0048","num":"0067"},"figref":"FIG. 4","b":["154","154","200","180","110","200","110","112","111","114","111","114"]},"Command processor  receives display commands in binary format from main processor  and parses and decodes them\u2014obtaining any additional data necessary to process them from shared memory . The command processor  provides a stream of vertex commands to graphics pipeline  for 2D and\/or 3D processing and rendering. Graphics pipeline  generates images based on these commands. The resulting image information may be transferred to main memory  for access by display controller\/video interface unit \u2014which displays the frame buffer output of pipeline  on display .",{"@attributes":{"id":"p-0050","num":"0069"},"figref":"FIG. 5","b":["154","110","210","212","214","112","200","150","110","210","110","200"],"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":{"@attributes":{"id":"ul0009-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":["command streams from main memory  via an on-chip FIFO memory buffer  that receives and buffers the graphics commands for synchronization\/flow control and load balancing,","display lists  from main memory  via an on-chip call FIFO memory buffer , and","vertex attributes from the command stream and\/or from vertex arrays  in main memory  via a vertex cache ."]}}}},"Command processor  performs command processing operations that convert attribute types to floating point format, and passes the resulting complete vertex polygon data to graphics pipeline  for rendering\/rasterization. A programmable memory arbitration circuitry  (see ) arbitrates access to shared main memory  between graphics pipeline , command processor  and display controller\/video interface unit .",{"@attributes":{"id":"p-0052","num":"0074"},"figref":"FIG. 4","b":"180","ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["a transform unit ,","a setup\/rasterizer ,","a texture unit ,","a texture environment unit , and","a pixel engine ."]}}}},"Transform unit  performs a variety of 2D and 3D transform and other operations (see ). Transform unit  may include one or more matrix memories for storing matrices used in transformation processing . Transform unit  transforms incoming geometry per vertex from object space to screen space; and transforms incoming texture coordinates and computes projective texture coordinates (). Transform unit  may also perform polygon clipping\/culling . Lighting processing also performed by transform unit provides per vertex lighting computations for up to eight independent lights in one example embodiment. Transform unit  can also perform texture coordinate generation () for embossed type bump mapping effects, as well as polygon clipping\/culling operations ().","Setup\/rasterizer  includes a setup unit which receives vertex data from transform unit  and sends triangle setup information to one or more rasterizer units () performing edge rasterization, texture coordinate rasterization and color rasterization.","Texture unit  (which may include an on-chip texture memory (TMEM) ) performs various tasks related to texturing including for example:\n\n","Texture unit  outputs filtered texture values to the texture environment unit  for texture environment processing (). Texture environment unit  blends polygon and texture color\/alpha\/depth, and can also perform texture fog processing () to achieve inverse range based fog effects. Texture environment unit  can provide multiple stages to perform a variety of other interesting environment-related functions based for example on color\/alpha modulation, embossing, detail texturing, texture swapping, clamping, and depth blending.","Pixel engine  performs depth (z) compare () and pixel blending (). In this example, pixel engine  stores data into an embedded (on-chip) frame buffer memory . Graphics pipeline  may include one or more embedded DRAM memories  to store frame buffer and\/or texture information locally. Z compares \u2032 can also be performed at an earlier stage in the graphics pipeline  depending on the rendering mode currently in effect (e.g., z compares can be performed earlier if alpha blending is not required). The pixel engine  includes a copy operation that periodically writes on-chip frame buffer  to main memory  for access by display\/video interface unit . This copy operation can also be used to copy embedded frame buffer  contents to textures in the main memory  for dynamic texture synthesis effects. Anti-aliasing and other filtering can be performed during the copy-out operation. The frame buffer output of graphics pipeline  (which is ultimately stored in main memory ) is read each frame by display\/video interface unit . Display controller\/video interface  provides digital RGB pixel values for display on display .","Example Graphics System Application Interface","As described above, main processor  sends graphics commands to graphics and audio processor . These graphics commands tell the graphics and audio processor  what to do. For example, the graphics commands can tell the graphics and audio processor  to draw a particular image onto display device . Commands might also tell the graphics and audio processor  to produce a particular sound for output by loudspeakers . Still other commands might tell the graphics and audio processor  to perform so-called \u201chousekeeping\u201d commands and\/or to set up a particular state in preparation for a subsequent \u201caction\u201d command.","In the example embodiment, the commands that main processor  sends to graphics and audio processor  can come from a number of sources. One source of commands is the main processor  itself. Under control of program instructions provided, for example, by mass storage access device  and\/or boot ROM , main processor  can dynamically create or generate graphics commands under program control to send to graphics and audio processor . Main processor  can create and send graphics and audio processor  any command that the graphics and audio processor understands. Graphics and audio processor  will act on the commands and perform the action requested by the command.","Another source of graphics commands for graphics and audio processor  is mass storage access device . It takes some time for main processor  to dynamically create graphics commands. When system  is animating a scene in response to real-time inputs from hand controllers  or the like, there may be no alternative other than for main processor  to dynamically create the graphics commands telling the graphics and audio processor  to draw a particular cartoon or other character in a particular position. That way, as the user operates hand controllers  of system  responds to other input devices, main processor  can dynamically adjust or animate the displayed scene in response to those real-time inputs to provide interactive animation. Such fun and exciting interactive animation is generally provided by main processor  dynamically creating graphics commands \u201con the fly.\u201d","Sometimes, however, some part of a scene to be displayed is relatively static and does not change in response to real-time inputs. For example, a complicated 3D world background such as a castle, a mountain fortress, a landscape or an undersea world may not change much or at all as animated characters move through the world. In such cases, it is possible to use an offline authoring computer to develop the complex series of graphics commands required to draw the particular scene or portion of the scene and store them in a preconstructed display list. Similarly, sound effects, music and other sounds can be pre-generated off-line by a sound authoring system. The resulting display list(s) and\/or audio list(s) can be stored on an optical disk  or other mass storage device. When it comes time to draw the scene and\/or play the sound, the associated display list(s) and\/or audio list(s) can simply be read from the mass storage device  and stored into main memory . Main processor  may then, under program control, tell the graphics and audio processor  where to find the preconstructed display list(s) and\/or audio list(s), and instruct the graphics and audio processor to execute the lists. In this way, main processor  does not have to devote its processing resources to develop complicated display lists and\/or audio lists since that task is off-loaded to an off-line authoring system that pre-compiles the lists in preparation for use by the graphics and audio processor . Such display lists can be stored by any storage device within system  or accessible to it, including but not limited to memory card , flash memory , boot ROM , audio memory , etc. The commands could be embedded in hardware such as gate arrays or the like, and communicated to system  via any of the external interfaces such as bus , bus , handheld controller ports, parallel bus , infrared, etc.","Still another possibility is for commands intended for processing by the graphics and audio processor  to arrive via a data communications connection such as network . In one example, graphics commands, audio commands and\/or other commands intended to be processed by graphics and audio processor  may arrive from a data communications network  via modem . Such commands could be transmitted, for example, from a remote system  of the same configuration as that shown in  in order to provide interactive multi-user remote game play. The commands could originate from any other source including a personal computer, a mini-computer or main frame computer, a data transmitter, or any other data source.","Irrespective of how commands intended for graphics and audio processor  arrive and how they are stored before and\/or after arrival, the first step in causing such commands to be processed by the graphics and audio processor  is to make them available to the graphics and audio processor. In the example embodiment, making the commands available to graphics and audio processor  can be accomplished either by having main processor  send the commands directly to the graphics and audio processor via a data bus in an immediate mode of command transfer, or by storing the commands in some memory accessible to the graphics and audio processor  (e.g., main memory , audio memory , or any other memory device to which the graphics and audio processor  is coupled) and informing the graphics and audio processor where to find the commands and instructing it to begin processing those commands.","Graphics Command Stream","In the example embodiment, graphics and audio processor  may receive register and other commands from main processor  and\/or some other source (e.g., main memory ) in the form of a graphics command stream. Generally, the data that is sent from main processor  to the graphics and audio processor  can be called the \u201ccommand stream.\u201d The command stream holds drawing commands along with vertices and their attributes and mechanisms for loading registers and changing modes in the graphics pipeline . The stream of graphics commands are sent to the graphics and audio processor  for processing in a generally sequential manner. Such stream commands can be provided in a so-called \u201cimmediate mode\u201d directly from main processor  to the graphics and audio processor  through a write gatherer arrangement (see ) to provide very efficient transfer of graphics and audio commands from the main processor  to the graphics and audio processor . The graphics command stream can also be provided to graphics and audio processor  via main memory  or other memory or other data communications capabilities within system . The cache\/command processor  within the graphics and audio processor  performs tasks such as, for example, fetching the command stream from main memory ; fetching vertex attributes (e.g., either from the command stream or from arrays in main memory); converting attribute types to appropriate formats (e.g., floating point); and transferring complete vertices to the remainder of the graphics pipeline  for processing.","As shown in , the command stream is fetched from the first-in-first-out buffer  (see also above-referenced Provisional Application No. 60\/226,912, filed Aug. 23, 2000 and its corresponding utility application Ser. No. 09\/726,215, filed Nov. 28, 2000, both entitled \u201cMethod and Apparatus for Buffering Graphics Data in a Graphics System\u201d, and read into a FIFO buffer . The command processor  strips and decodes the commands to decide the number of data associated with it. The data is then taken from the stream and\/or fetched from an array in main memory , based on an index value. The vertex attributes are converted to floating point data that can be consumed by the transform engine .","The following are example command stream formats in the example embodiment:",{"@attributes":{"id":"p-0067","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Opcode","Opcode(7:0)","Next","Followed by"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["NOP","00000000","none","none"]},{"entry":["Draw_Quads","10000vat(2:0)","VertexCount(15:0)","Vertex attribute stream"]},{"entry":["Draw_Triangles","10010vat(2:0)","VertexCount(15:0)","Vertex attribute stream"]},{"entry":["Draw_Triangle_strip","10011vat(2:0)","VertexCount(15:0)","Vertex attribute stream"]},{"entry":["Draw_Triangle_fan","10100vat(2:0)","VertexCount(15:0)","Vertex attribute stream"]},{"entry":["Draw_Lines","10101vat(2:0)","VertexCount(15:0)","Vertex attribute stream"]},{"entry":["Draw_Line_strip","10110vat(2:0)","VertexCount(15:0)","Vertex attribute stream"]},{"entry":["Draw_Points","10111vat(2:0)","VertexCount(15:0)","Vertex attribute stream"]},{"entry":["CP_LoadRegs","00001xxx","Address[7:0]","32 bits data"]},{"entry":"(for CP only registers)"},{"entry":["XF_LoadRegs","00010xxx","none","(N+2)*32 bits"]},{"entry":["(This is used for",{},{},"First 32 bit:"]},{"entry":["loading all XF",{},{},"\u200315:00 register address in XF"]},{"entry":["registers, including",{},{},"\u200319:16 number of 32 bit registers to be"]},{"entry":["matrices. It can be",{},{},"loaded (N+1, 0 means 1, 0xff means 16)"]},{"entry":["used to load matrices",{},{},"\u200331:20 unused"]},{"entry":["with immediate data)",{},{},"Next N+1 32 bits:"]},{"entry":[{},{},{},"\u2003\u200931:00 register data"]},{"entry":["XF_IndexLoadRegA","00100xxx","none","32 bits"]},{"entry":["(registers are in the",{},{},"11:0 register address in XF"]},{"entry":["first 4K address space",{},{},"15:12 number of 32 bit data, (0 means 1,"]},{"entry":["of the XF. It can be",{},{},"0xff means 16)"]},{"entry":["used to block load",{},{},"31:16 index to the register Array A"]},{"entry":"matrix and light"},{"entry":"registers)"},{"entry":["XF_IndexLoadRegB","00101xxx","none","32 bits"]},{"entry":["(registers are in the",{},{},"11:0 register address in XF"]},{"entry":["first 4K address space",{},{},"15:12 number of 32 bit data, (0 means 1,"]},{"entry":["of the XF. It can be",{},{},"0xff means 16)"]},{"entry":["used to block load",{},{},"31:16 Index to the register Array B"]},{"entry":"matrix and light"},{"entry":"registers)"},{"entry":["XF_IndexLoadRegC","00110xxx","none","32 bits"]},{"entry":["(registers are in the",{},{},"11:0 register address in XF"]},{"entry":["first 4K address space",{},{},"15:12 number of 32 bit data, (0 means 1,"]},{"entry":["of the XF. It can be",{},{},"0xff means 16)"]},{"entry":["used to block load",{},{},"31:16 Index to the register Array C"]},{"entry":"matrix and light"},{"entry":"registers)"},{"entry":["XF_IndexLoadRegD","00111xxx","none","32 bits"]},{"entry":["(registers are in the",{},{},"11:0 register address in XF"]},{"entry":["first 4K address space",{},{},"15:12 number of 32 bit data, (0 means 1,"]},{"entry":["of the XF. It can be",{},{},"0xff means 16)"]},{"entry":["used to block load",{},{},"31:16 Index to the register Array D"]},{"entry":"matrix and light"},{"entry":"registers)"},{"entry":["Call_Object","01000xxx","none","2x32"]},{"entry":[{},{},{},"25:5 address (need to be 32 byte align)"]},{"entry":[{},{},{},"25:5 count (32 byte count)"]},{"entry":["V$_Invalidate","01001xxx","none","none"]},{"entry":["SU_ByPassCmd","0110,SUattr(3:0)","none","32 bit data"]},{"entry":"(This includes all the"},{"entry":"register load below XF"},{"entry":"and all setup unit"},{"entry":"commands, which"},{"entry":"bypass XF)"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"As shown in Table I above, the graphics command stream can include register load commands. Register commands are, in general, commands that have the effect of writing particular state information to particular registers internal to the graphics and audio processor . The graphics and audio processor  has a number of internal registers addressable by main processor . To change the state of the graphics and audio processor  in particular way, main processor  can write a particular value to a particular register internal to the graphics and audio processor . Register commands have the advantage of allowing the graphics pipeline to retain drawing state information that main processor  can selectively change by sending further register load commands.","For example, the vertices in a draw command can all share the same vertex attribute data structure defining a number of attributes associated with a vertex. Sending all of the vertex attribute information before a draw command could be costly. It therefore may be desirable to store most of the common vertex types in registers within the graphics and audio processor , and to simply pass an index to the stored table. These tables may not need to be updated each time a new draw command is sent down, but may only need to be updated every once in a while. In the example embodiment, command processor  holds a vertex command descriptor register (VCD) and a eight-entry vertex attribute table (VAT) defining whether the attribute is present and if so whether it is indexed or direct. A \u201cload_VCD\u201d register command is used to update the register whenever updating is necessary.","In certain situations, main processor  may also read the graphics and audio processor  internal registers to determine the state of the graphics and audio processor. For example, the main processor  can start and stop the graphics and audio processor  and\/or determine its general status by reading from and\/or writing to internal registers within the graphics and audio processor. Main processor  can also load a number of graphics values (e.g., transformation matrices, pixel formats, vertex formats, etc.) by writing to registers within the graphics and audio processor . As another example, main processor  can write to a series of FIFO control registers within the graphics and audio processor  that control where the graphics and audio processor  obtains further commands for processing.","The following are example command registers used for defining transformation matrices, vertex control data, vertex attribute tables, vertex arrays, vertex stride, and other state parameters:",{"@attributes":{"id":"p-0072","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Register name","Register address[7:0]","Bit fields"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MatrixIndexA","0011xxxx","5:0 index for position\/normal matrix"]},{"entry":[{},{},"11:6 index for tex0 matrix"]},{"entry":[{},{},"17:12 index for tex1 matrix"]},{"entry":[{},{},"23:18 index for tex2 matrix"]},{"entry":[{},{},"29:24 index for tex3 matrix"]},{"entry":["MatrixIndexB","0100xxxx","5:0 index for tex4 matrix"]},{"entry":[{},{},"11:6 index for tex5 matrix"]},{"entry":[{},{},"17:12 index for tex6 matrix"]},{"entry":[{},{},"23:18 index for tex7 matrix"]},{"entry":["VCD_Lo","0101xxxx","16:00 VCD 12 to 0"]},{"entry":[{},{},"0 PosMatIdx"]},{"entry":[{},{},"1 Tex0MatIdx"]},{"entry":[{},{},"2 Tex1MatIdx"]},{"entry":[{},{},"3 Tex2atIdx"]},{"entry":[{},{},"4 Tex3MatIdx"]},{"entry":[{},{},"5 Tex4MatIdx"]},{"entry":[{},{},"6 Tex5MatIdx"]},{"entry":[{},{},"7 Tex6MatIdx"]},{"entry":[{},{},"8 Tex7MatIdx"]},{"entry":[{},{},"10:9 Position"]},{"entry":[{},{},"12:11 Normal"]},{"entry":[{},{},"14:13 ColorDiffused"]},{"entry":[{},{},"16:15 ColorSpecular"]},{"entry":["VCD_-Hi","0110xxxx","15:00 VCD 20 to 13"]},{"entry":[{},{},"01:00 Tex0Coord"]},{"entry":[{},{},"03:02 Tex1Coord"]},{"entry":[{},{},"05:04 Tex2Coord"]},{"entry":[{},{},"07:06 Tex3Coord"]},{"entry":[{},{},"09:08 Tex4Coord"]},{"entry":[{},{},"11:10 Tex5Coord"]},{"entry":[{},{},"13:12 Tex6Coord"]},{"entry":[{},{},"15:14 Tex7Coord"]},{"entry":["VAT_group0","0111x,vat[2:0]","32 bits"]},{"entry":[{},{},"08:00 Position parameters"]},{"entry":[{},{},"12:09 Normal parameters"]},{"entry":[{},{},"16:13 ColorDiffused parameters"]},{"entry":[{},{},"20:17 ColorSpecular parameters"]},{"entry":[{},{},"29:21 Tex0Coord parameters"]},{"entry":[{},{},"30:30 ByteDequant"]},{"entry":[{},{},"31:31 NormalIndex3"]},{"entry":["VAT_group1","1000x,vat[2:0]","32 bits"]},{"entry":[{},{},"08:00 Tex1Coord parameters"]},{"entry":[{},{},"17:09 Tex2Coord parameters"]},{"entry":[{},{},"26:18 Tex3Coord parameters"]},{"entry":[{},{},"30:27 Tex4Coord parameters sub-field[3:0]"]},{"entry":[{},{},"31unused"]},{"entry":["VAT_group2","1001x,vat[2:0]","32 bits"]},{"entry":[{},{},"04:00 Tex4Coord parameters sub-field[8:4]"]},{"entry":[{},{},"13:05 Tex5Coord parameters"]},{"entry":[{},{},"22:14 Tex6Coord parameters"]},{"entry":[{},{},"31:23 Tex7Coord parameters"]},{"entry":["ArrayBase","1010,array[3:0]","32 bit data"]},{"entry":[{},"array[3:0]:","25:00 Base(25:0)"]},{"entry":[{},"\u20030000 = attribute9 base register","31:26 unused"]},{"entry":[{},"\u20030001 = attribute10 base register"]},{"entry":[{},"\u20030010 = attribute11 base register"]},{"entry":[{},"\u20030011 = attribute12 base register"]},{"entry":[{},"\u20030100 = attribute13 base register"]},{"entry":[{},"\u20030101 = attribute14 base register"]},{"entry":[{},"\u20030110 = attribute15 base register"]},{"entry":[{},"\u20030111 = attribute16 base register"]},{"entry":[{},"\u20031000 = attribute17 base register"]},{"entry":[{},"\u20031001 = attribute18 base register"]},{"entry":[{},"\u20031010 = attribute19 base register"]},{"entry":[{},"\u20031011 = attribute20 base register"]},{"entry":[{},"\u20031100 = IndexRegA base register"]},{"entry":[{},"\u20031101 = IndexRegB base register"]},{"entry":[{},"\u20031110 = IndexRegC base register"]},{"entry":[{},"\u20031111 = IndexRegD base register"]},{"entry":["ArrayStride","1011,array[3:0]","32 bit data"]},{"entry":[{},"array[3:0]:","07:00 Stride(7:0)"]},{"entry":[{},"\u20030000 = attribute9 stride register","31:08 unused"]},{"entry":[{},"\u20030001 = attribute10 stride register"]},{"entry":[{},"\u20030010 = attribute11 stride register"]},{"entry":[{},"\u20030011 = attribute12 stride register"]},{"entry":[{},"\u20030100 = attribute13 stride register"]},{"entry":[{},"\u20030101 = attribute14 stride register"]},{"entry":[{},"\u20030110 = attribute15 stride register"]},{"entry":[{},"\u20030111 = attribute16 stride register"]},{"entry":[{},"\u20031000 = attribute17 stride register"]},{"entry":[{},"\u20031001 = attribute18 stride register"]},{"entry":[{},"\u20031010 = attribute19 stride register"]},{"entry":[{},"\u20031011 = attribute20 stride register"]},{"entry":[{},"\u20031100 = IndexRegA stride register"]},{"entry":[{},"\u20031101 = IndexRegB stride register"]},{"entry":[{},"\u20031110 = IndexRegC stride register"]},{"entry":[{},"\u20031111 = IndexRegD stride register"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In the example embodiment, the command processor  converts the command stream to a vertex stream which it sends to transform unit  for further processing. The vertex stream sent to the transform unit  can change based on the current mode, but the data ordering per vertex is essentially the same and is fixed as shown in the following table:",{"@attributes":{"id":"p-0074","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Location in",{},{}]},{"entry":["stream (in words)","Data","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20020 to 2","X, Y, Z in 32b SPFP","Geometry information in single"]},{"entry":[{},{},"precision floating point format"]},{"entry":["\u20023 to 5","Nx, Ny, Nz in 32b SPFP","Normal vector"]},{"entry":["\u20026","RGBA in 32b integer (8 b\/comp)","Color0 per vertex (RGBA)"]},{"entry":["\u20027","RGBA in 32b integer (8 b\/comp)","Color1 per vertex (RGBA)"]},{"entry":["\u20028 to 10","Tx, Ty, Tz in 32b SPFP","Binormal vector T"]},{"entry":["11 to 13","Bx, By, Bz in 32b SPFP","Binormal vector B"]},{"entry":["14 to 15","S0, T0 in 32b SPFP","Texture 0 data"]},{"entry":["16 to 29","Sn, Tn in 32b SPFP","Texture 1 to n data"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}],"b":["6","8"]},{"@attributes":{"id":"p-0075","num":"0106"},"figref":["FIG. 6","FIG. 6","FIG. 7","FIG. 6"],"b":["50","56","50","134","610","110","114","612","50","614","114","616","50","618","702","114","113","112","620","164","622","624"]},"Example Simple Graphics Command Stream","For purposes of illustration  shows an example simple graphics command stream drawing a single graphics primitive (e.g., a single triangle) on display . In this example simple graphics command stream, the first set of graphics commands initializes the graphics pipeline  (GXInit( )) (block ). When the graphics and audio processor  comes out of hardware reset, its internal register values are undefined and therefore need to be set by main processor  under control of boot ROM  and\/or the application program. A series of initialization commands such as register load commands may be issued to set the state of graphics and audio processor  to a known, pre-defined state that is suitable for the particular application that is to be performed. Of course, the application can reset any of these values to any other desired value on a dynamic basis. However, to save the application work, it may be desirable for boot ROM  to provide a series of state-setting graphics initialization commands that set up the graphics and audio processor  so that it is operating in a known functioning default graphics mode.","One example initialization may be to clear (set) the internal embedded frame buffer  to an all-black color value with z (distance) of the corresponding embedded depth buffer being set to infinite distance at each location. Such a \u201cset copy clear\u201d instruction effectively sets up a clean canvas onto which graphics and audio processor  can draw the next image, and is re-formed during an embedded frame buffer copy operation in the example embodiment.  shows an example binary data stream that may be sent to the graphics and audio processor  to control it to clear (set) its internal frame buffer  to a black color at each and every pixel location and to set the corresponding internal depth buffer to infinite distance at every pixel. In the particular example shown, such a command stream comprises three pixel engine register load commands:\n\n","In this example, the first portion of each register load command includes a \u201ccp_cmd_su_bypass\u201d command string (0x61) (where \u201c0x\u201d indicates hexadecimal). As explained in Table I above, this command string provides access to registers within graphics pipeline  below transform unit . This string is followed by a pixel engine register designation (0x4F in the case of a pixel engine copy clear alpha\/red command), a 1-byte pad; and a 1-byte alpha value and a 1-byte red value (FF for black).","A similar format is used for the pe_copy_clear_green blue command except that the last two bytes indicate the green and blue values (FF for black), and a different pixel engine register designation (0x50) is used for the green\/blue register values. Similarly, the pe_copy_clear_z command is issued by sending a cp_cmd_su_bypass string (0x61) followed by a register designator 0x51 (designating a pixel engine z value register) followed by a 24-bit z (depth) value. The three set copy clear commands shown in  could be issued in any order (e.g., set z copy clear or set green\/blue copy clear could be issued first). See  which shows example register formats.","In response to receipt of the  commands, pixel engine  writes the specified alpha, red, green, blue and z values into embedded frame buffer .","Referring once again to . a next step in preparing to display an image onto display  may be to define the various data structures associated with the vertices of the primitive to be drawn. The  diagram shows, for purposes of illustration, example vertex and vertex attribute descriptors that can be used to describe vertices. In the example embodiment, all vertices within a given primitive share the same vertex descriptor and vertex attribute format. The vertex descriptor in the example embodiment describes which attributes are present in a particular vertex format and how they are transmitted from the main processor  (or other source) to the graphics processor  (e.g., either direct or indexed). The vertex attribute format describes the format (e.g., type, size, format, fixed point scale, etc.) of each attribute in a particular vertex format. The vertex attribute format together with the vertex descriptor may be thought of as the overall vertex format.","The following is an example of a vertex attribute table (VAT) (see also above-referenced application Ser. No. 09\/465,754 filed Dec. 17, 1999 entitled \u201cVertex Cache For 3D Computer Graphics\u201d) indexed by a draw command \u201cvat\u201d field, with each entry in the table specifying characteristics for all of the thirteen attributes:",{"@attributes":{"id":"p-0083","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":{"entry":"TABLE IV"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VERTEX ATTRIBUTE TABLE (VAT)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Attribute","Attribute",{},{}]},{"entry":["number","name","bits","Encoding"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","PosMatIdx","\u20020","Position\/normal matrix index. Always direct if present"]},{"entry":[{},{},{},"0: not present 1: present"]},{"entry":[{},{},{},"NOTE: position and normal matrices are stored in 2 separate"]},{"entry":[{},{},{},"RAMs in the Xform unit, but there is a one to one correspondence"]},{"entry":[{},{},{},"between normal and position index. If index \u201cA\u201d is used for the"]},{"entry":[{},{},{},"position, then index \u201cA\u201d needs to be used for the normal as well."]},{"entry":["1","Tex0MatIdx","\u20021","TextCoord0 matrix index, always direct if present"]},{"entry":[{},{},{},"0: not present 1: present"]},{"entry":["2","Tex1MatIdx","\u20022","TextCoord0 matrix index, always direct if present"]},{"entry":[{},{},{},"0: not present 1: present"]},{"entry":["3","Tex2MatIdx","\u20023","TextCoord0 matrix index, always direct if present"]},{"entry":[{},{},{},"0: not present 1: present"]},{"entry":["4","Tex3MatIdx","\u20024","TextCoord0 matrix index, always direct if present"]},{"entry":[{},{},{},"0: not present 1: present"]},{"entry":["5","Tex4MatIdx","\u20025","TextCoord0 matrix index, always direct if present"]},{"entry":[{},{},{},"0: not present 1: present"]},{"entry":["6","Tex5MatIdx","\u20026","TextCoord0 matrix index, always direct if present"]},{"entry":[{},{},{},"0: not present 1: present"]},{"entry":["7","Tex6MatIdx","\u20027","TextCoord0 matrix index, always direct if present"]},{"entry":[{},{},{},"0: not present 1: present"]},{"entry":["8","Tex7MatIdx","\u20028","TextCoord0 matrix index, always direct if present"]},{"entry":[{},{},{},"0: not present 1: present"]},{"entry":["9","Position","10:9","00: reserved 10: 8 bit index"]},{"entry":[{},{},{},"01: direct \u2003\u200311: 16 bit index"]},{"entry":["10","Normal","12:11","00: not present 10: 8 bit index"]},{"entry":[{},{},{},"01: direct \u2003\u200311: 16 bit index"]},{"entry":["11","Color0","14:13","00: not present 10: 8 bit index"]},{"entry":[{},{},{},"01: direct \u2003\u200311: 16 bit index"]},{"entry":["12","Color1","16:15","00: not present 10: 8 bit index"]},{"entry":[{},{},{},"01: direct \u2003\u200311: 16 bit index"]},{"entry":["13","Tex0Coord","18:17","00: not present"]},{"entry":[{},{},{},"01: direct"]},{"entry":[{},{},{},"10: 8 bit index"]},{"entry":[{},{},{},"11: 16 bit index"]},{"entry":["14","Tex1Coord","20:19","00: not present"]},{"entry":[{},{},{},"01: direct"]},{"entry":[{},{},{},"10: 8 bit index"]},{"entry":[{},{},{},"11: 16 bit index"]},{"entry":["15","Tex2Coord","22:21","00: not present"]},{"entry":[{},{},{},"01: direct"]},{"entry":[{},{},{},"10: 8 bit index"]},{"entry":[{},{},{},"11: 16 bit index"]},{"entry":["16","Tex3Coord","24:23","00: not present"]},{"entry":[{},{},{},"01: direct"]},{"entry":[{},{},{},"10: 8 bit index"]},{"entry":[{},{},{},"11: 16 bit index"]},{"entry":["17","Tex4Coord","26:25","00: not present"]},{"entry":[{},{},{},"01: direct"]},{"entry":[{},{},{},"10: 8 bit index"]},{"entry":[{},{},{},"11: 16 bit index"]},{"entry":["18","Tex5Coord","28:27","Same as above"]},{"entry":["19","Tex6Coord","30:29","00: not present"]},{"entry":[{},{},{},"01: direct"]},{"entry":[{},{},{},"10: 8 bit index"]},{"entry":[{},{},{},"11: 16 bit index"]},{"entry":["20","Tex7Coord","32:31","00: not present"]},{"entry":[{},{},{},"01: direct"]},{"entry":[{},{},{},"10: 8 bit index"]},{"entry":[{},{},{},"11: 16 bit index"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"As described in application Ser. No. 09\/465,754, as well as above, entries in the vertex descriptor information can be either direct or indexed. Indexed vertex attributes include an index to an array instead of a value. The index may be an 8-bit or 16-bit pointer into an array of attributes. In the example embodiment, there is one base address register per attribute in the command processor . The index is not simply an offset into the array, but rather depends on a number of factors including, for example, the number of components in the attribute; the size of the component; padding between attributes for alignment purposes; and whether multiple attributes are interleaved in the same array. To provide maximum flexibility, there is also an array stride register for each attribute. The distance between two attributes (computed by software) is loaded into this register. Calculations are used to calculate the offset and to calculate the actual memory address based on an index value. An example address calculation is as follows:\n\nMemory address=ArrayBase[]+index*ArrayStride[\n\nwhere I is the attribute number. In one particular implementation, the ArrayBase value is a 26-bit byte address, and ArrayStride is an 8-bit value.\n","A vertex can have direct and indirect attributes intermixed. For short values, it may be more efficient to send the actual value than a pointer to the value. Any attribute in the example embodiment can be sent directly or as in index into an array.","In general, the steps required to draw a primitive include describing which attributes are present in the vertex format (i.e., define the vertex attribute table); describing whether the attributes are indexed or referenced directly (i.e., define the vertex descriptor); for indexed data, delivering a vertex array that can be referenced by array pointers and strides; describing the number of elements in each attribute and their type; describing the primitive type; and then, finally, drawing the primitive by sending the graphics processor  draw command with a stream of vertices that match the vertex description in attribute format (see , blocks , , ).",{"@attributes":{"id":"p-0087","num":"0121"},"figref":["FIG. 11","FIG. 8","FIG. 11"],"b":"1004","ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":{"@attributes":{"id":"ul0018-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":["an initial \u201c0x08\u201d value indicating \u201ccp_cmd_loadreg\u201d (i.e., load a command processor  register) followed by","a 2-byte value indicating which array base register is to be loaded, followed by","an additional 4-byte value providing an address to the array in memory."]}}}},"In this particular example, the 2-byte value indicating which array base register is to be loaded has the format \u201c0xAx\u201d, where the byte \u201cx\u201d following the \u201cA\u201d value encodes a particular one of the attributes set forth in Table IV above. Note that some of the Table IV attributes (i.e., the matrix indices) are not included in the encoding in the example embodiment. In the example embodiment, the 4-byte address in memory is encoded by providing six initial bits of 0 padding followed by a 26-bit address. Setting the array stride register value is similar except that the third and fourth bytes indicate an array stride register (e.g., \u201c0xBx\u201d and the following value comprises four bytes containing an initial 24-bit  padded value and an 8-bit stride value for the array.","Referring once again to , a further step preliminary to issuing a draw command may be to set up a vertex descriptor and a vertex attribute table (block ).  shows an example command stream used to set a vertex descriptor. In the example embodiment, setting a vertex descriptor involves setting two associated register values (\u201cvcd_lo\u201d \u201cvcd_hi\u201d) within command processor  in order to specify the particular vertex descriptor attributes associated with the primitive to be displayed.  shows particular binary encodings used to tell the graphics and audio processor  to load the vcd_lo and vcd_hi registers (e.g., \u201c0x0850\u201d for an example vcd_lo register and \u201c0x0860\u201d to specify loading a cp_vcd_hi register). Values following each of these 4-byte commands indicates particular vertex attribute values as shown in Table 4 above, and as encoded in the particular binary bit patterns slots shown in .","In more detail, the vertex descriptor stored in the VCD_lo VCD_hi register includes at least one bit for each of the twenty attributes shown in Table IV, that bit generally indicating whether the attribute is provided directly or via an array. In the example embodiment, the VCD_lo register contains a 17-bit value, providing bit flags indicating direct or indexed for each of the first twelve attributes in Table IV. The particular bit encodings are shown in the last column of Table IV. Note that certain attribute encodings indicate whether or not the attribute is present (since the attribute is always direct if it is present), and certain other encodings span multiple bits and provide information as to the type of index if the attribute is indexed (e.g., the \u201cposition\u201d value may span two bits with a value \u201c01\u201d for direct, \u201c10\u201d for 8-bit index, and \u201c11\u201d for 16-bit index). Similarly, the VCD_hi register contains bit fields corresponding to attributes 13\u201320 (i.e., texture  coordinate through texture  coordinate) as shown in Table IV above.","On a more abstract level, the GXSetVtxDesc command is used to indicate whether an attribute is present in the vertex data, and whether it is indexed or direct. There is only one active vertex descriptor, known as the current vertex descriptor. A GXSetVtxDesc command can be used to set a value of GX_NONE for all the attributes in the current vertex descriptor to indicate that no data for this attribute will be present in the vertex. Once the VCD registers are cleared, the application only needs to describe attributes that it intends to provide. As shown in Table IV, possible attributes are:\n\n","Up to 8 texture coordinates, GX_VA_TEX0-7.","A position\/normal matrix index, GX_VA_PNMTXIDX.","A texture matrix index, GX_VA_TEX0MTXIDX-GX_VA_TEX7MTXIDX.","The last two attributes listed are 8-bit indices which are used for referencing a transformation matrix in the on-chip matrix memory. This supports simple skinning of a character, for example. These indices are different from the other attributes in that they may only be sent as direct data.","The graphics processor (GP)  assumes that the application will send any attribute data you have specified in the ascending order shown in Table IV, that is:","Order Attribute",{"@attributes":{"id":"p-0097","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":["0 GX_VA_PNMTXIDX","1 GX_VA_TEX0MTXIDX","2 GX_VA_TEX1MTXIDX","3 GX_VA_TEX2MTXIDX","4 GX_VA_TEX3MTXIDX","5 GX_VA_TEX4MTXIDX","6 GX_VA_TEX5MTXIDX","7 GX_VA_TEX6MTXIDX","8 GX_VA_TEX7MTXIDX","9 GX_VA_POS","10 GX_VA_NRM or GX_VA_NBT","11 GX_VA_CLR0","12 GX_VA_CLR1","13 GX_VA_TEX0","14 GX_VA_TEX1","15 GX_VA_TEX2","16 GX_VA_TEX3","17 GX_VA_TEX4","18 GX_VA_TEX5","19 GX_VA_TEX6","20 GX_VA_TEX7"]}},"Texture coordinates are enabled sequentially, starting at GX_VA_TEX0","Describing Attribute Data Formats",{"@attributes":{"id":"p-0099","num":"0160"},"figref":["FIGS. 13A and 13B","FIG. 14"],"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":{"@attributes":{"id":"ul0023-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":["The number of elements for the attribute.","The format and size information.","The number of fractional bits for fixed-point formats using the scale parameter (the scale parameter is not relevant to color or floating-point data).\n\nExample Vertex Attribute Format Command (GXSetVtxAttrFmt)\n"]}}}},"\/\/format index attribute n elements format n frac bits GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S8, 0);","GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_CLR, GX_CLR_RGBA, GX_RGBA, );","The high-level code above defines vertex attribute format zero. GX_VTXFMT0 indicates that \u201cposition\u201d is a 3-element coordinate (x, y, z) where each element is an 8-bit 2's complement signed number. The scale value indicates the number of fractional bits for a fixed-point number, so zero indicates that the data has no fractional bits. The second command specifies that the GX_VA_CLR0 attribute has four elements (r, g, b, a) where each element is 8 bits. The matrix index format is not specified in the table because it is always an unsigned 8-bit value. The scale value is implied for normals (scale=6 or scale=14) and not needed for colors. Also, normals are assumed to have three elements, Nx, Ny, Nz (for GX_VA_NRM), and nine elements, Nx, Ny, Nz, Bx, By, Bz, Tx, Ty, Tz (for GX_VA_NBT). Normals are generally always signed values. The normal format (GX_VA_NRM) is also used for binormals\/tangents (GX_VA_NBT) when they are enabled in the current vertex descriptor. The VAT in the Graphics Processor has room for eight vertex formats. The application can describe most of its attribute quantization formats early in the application, loading this table as required. Then the application provides an index into this table, which specifies the vertex attribute data format, when it starts drawing a group of primitives. If the application requires more than eight vertex formats it must manage the VAT table by reloading new vertex formats as needed.",{"@attributes":{"id":"p-0103","num":"0167"},"figref":"FIGS. 13A and 13B","b":["114","114"],"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":{"@attributes":{"id":"ul0025-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":["\u201c0x0870\u201d [4-byte value] to write to the cp_VAT_A register,","\u201c0x0880\u201d [4-byte value] to write to the cp_VAT_B register, and","\u201c0x0890\u201d [4-byte value] to write to the cp_VAT_C register."]}}}},"As shown in , the binary bit field encoding for the VAT_A register write involves providing position, normal, color , color , texture  coordinate, and other information (i.e., byte dequantization and normal index bits) in the binary pattern slots shown. Similarly, the binary bit field encoding for the VAT_B register write involves providing formatting information for texture coordinate , texture coordinate , texture coordinate  and part of texture coordinate ; and the information to be stored in the VAT_C register provides attribute format information for the rest of texture coordinate , texture coordinate , texture coordinate  and texture coordinate .  show the particular bit pattern encodings that may be used. Additional explanation of these particular attributes is set forth in Table V:",{"@attributes":{"id":"p-0105","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE V"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["Bit","Attribute","Attribute","CompCount","CompSize","Shift amount"]},{"entry":["field","number","name","sub-field(0)","sub-field(3:1)","sub-field(8:4)"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20028:0","\u20029","Position","0: two (x, y)","0: ubyte 1: byte 2: ushort","Location of decimal point"]},{"entry":[{},{},{},"1: three","3: short 4: float 5\u20137","from LSB. This shift applies"]},{"entry":[{},{},{},"(x, y, z)","reserved","to all u\/short components and"]},{"entry":[{},{},{},{},{},"to u\/byte components where"]},{"entry":[{},{},{},{},{},"ByteDequant is asserted"]},{"entry":[{},{},{},{},{},"(Below)."]},{"entry":["12:9","10","Normal","0: three","0: reserved 1: byte","NA (Byte: 6, Short: 14)"]},{"entry":[{},{},{},"normals","2: reserved"]},{"entry":[{},{},{},"1: nine","3: short 4: float 5\u20137"]},{"entry":[{},{},{},"normals","reserved"]},{"entry":["16:13","11","Color0","0: three","0: 16 bit 565 (three comp)","NA"]},{"entry":[{},{},{},"(r, g, b)","1: 24 bit 888 (three comp)"]},{"entry":[{},{},{},{},"2: 32 bit 888x (three"]},{"entry":[{},{},{},{},"comp)"]},{"entry":[{},{},{},"1: four","3: 16 bit 4444 (four comp)"]},{"entry":[{},{},{},"(r, g, b, a)","4: 24 bit 6666 (four comp)"]},{"entry":[{},{},{},{},"5: 32 bit 8888 (four comp)"]},{"entry":["20:17","12","Color1","0: three","0: 16 bit 565 (three comp)","NA"]},{"entry":[{},{},{},"(r, g, b)","1: 24 bit 888 (three comp)"]},{"entry":[{},{},{},{},"2: 32 bit 888x (three comp)"]},{"entry":[{},{},{},{},"3:16 bit 4444 (four comp)"]},{"entry":[{},{},{},"1: four","4: 24 bit 6666 (four comp)"]},{"entry":[{},{},{},"(r, g, b, a)","5: 32 bit 8888 (four comp)"]},{"entry":["29:21","13","Tex0Coord","0: one (s)","0: ubyte 2: ushort 4: float","Location of decimal point"]},{"entry":[{},{},{},"1: two (s, t)","1: byte 3: short 5\u20137","from LSB. This shift applies"]},{"entry":[{},{},{},{},"reserved","to all u\/short components and"]},{"entry":[{},{},{},{},{},"to u\/byte components where"]},{"entry":[{},{},{},{},{},"ByteDequant is asserted"]},{"entry":[{},{},{},{},{},"(Below)."]},{"entry":["38:30","14","Tex1Coord","0: one (s)","0: ubyte 2: ushort 4: float","Location of decimal point"]},{"entry":[{},{},{},"1: two (s, t)","1: byte 3: short 5\u20137","from LSB. This shift applies"]},{"entry":[{},{},{},{},"reserved","to all u\/short components and"]},{"entry":[{},{},{},{},{},"to u\/byte components where"]},{"entry":[{},{},{},{},{},"ByteDequant is asserted"]},{"entry":[{},{},{},{},{},"(Below)."]},{"entry":["47:39","15","Tex2Coord","0: one (s)","0: ubyte 2: ushort 4: float","Location of decimal point"]},{"entry":[{},{},{},"1: two (s, t)","1: byte 3: short 5\u20137","from LSB. This shift applies"]},{"entry":[{},{},{},{},"reserved","to all u\/short components and"]},{"entry":[{},{},{},{},{},"to u\/byte components where"]},{"entry":[{},{},{},{},{},"ByteDequant is asserted"]},{"entry":[{},{},{},{},{},"(Below)."]},{"entry":["56:48","16","Tex3Coord","0: one (s)","0: ubyte 2: ushort 4: float","Location of decimal point"]},{"entry":[{},{},{},"1: two (s, t)","1: byte 3: short 5\u20137","from LSB. This shift applies"]},{"entry":[{},{},{},{},"reserved","to all u\/short components and"]},{"entry":[{},{},{},{},{},"to u\/byte components where"]},{"entry":[{},{},{},{},{},"ByteDequant is asserted"]},{"entry":[{},{},{},{},{},"(Below)."]},{"entry":["65:57","17","Tex4Coord","0: one (s)","0: ubyte 2: ushort 4: float","Location of decimal point"]},{"entry":[{},{},{},"1: two (s, t)","1: byte 3: short 5\u20137","from LSB. This shift applies"]},{"entry":[{},{},{},{},"reserved","to all u\/short components and"]},{"entry":[{},{},{},{},{},"to u\/byte components where"]},{"entry":[{},{},{},{},{},"ByteDequant is asserted"]},{"entry":[{},{},{},{},{},"(Below)."]},{"entry":["74:66","18","Tex5Coord","0: one (s)","0: ubyte 2: ushort 4: float","Location of decimal point"]},{"entry":[{},{},{},"1: two (s, t)","1: byte 3: short 5\u20137","from LSB. This shift applies"]},{"entry":[{},{},{},{},"reserved","to all u\/short components and"]},{"entry":[{},{},{},{},{},"to u\/byte components where"]},{"entry":[{},{},{},{},{},"ByteDequant is asserted"]},{"entry":[{},{},{},{},{},"(Below)."]},{"entry":["83:75","19","Tex6Coord","0: one (s)","0: ubyte 2: ushort 4: float","Location of decimal point"]},{"entry":[{},{},{},"1: two (s, t)","1: byte 3: short 5\u20137","from LSB. This shift applies"]},{"entry":[{},{},{},{},"reserved","to all u\/short components and"]},{"entry":[{},{},{},{},{},"to u\/byte components where"]},{"entry":[{},{},{},{},{},"ByteDequant is asserted"]},{"entry":[{},{},{},{},{},"(Below)."]},{"entry":["92:84","20","Tex7Coord","0: one (s)","0: ubyte 2: ushort 4: float","Location of decimal point"]},{"entry":[{},{},{},"1: two (s, t)","1: byte 3: short 5\u20137","from LSB. This shift applies"]},{"entry":[{},{},{},{},"reserved","to all u\/short components and"]},{"entry":[{},{},{},{},{},"to u\/byte components where"]},{"entry":[{},{},{},{},{},"ByteDequant is asserted"]},{"entry":[{},{},{},{},{},"(Below)."]},{"entry":["93:93","FLAG","ByteDequant","(Rev B Only)","0: Shift does not apply to","Shift applies for u\/byte"]},{"entry":[{},{},{},{},"u\/byte","components of position and"]},{"entry":[{},{},{},{},"1: Shift does apply to","texture attributes."]},{"entry":[{},{},{},{},"u\/byte"]},{"entry":["94:94","FLAG","NormalIndex3","(Rev B Only)","0: Single index per Normal","When nine normals selected"]},{"entry":[{},{},{},{},"1: Triple index per nine-","in indirect mode, input will"]},{"entry":[{},{},{},{},"Normal","be treated as three staggered"]},{"entry":[{},{},{},{},{},"indices (one per triple biased"]},{"entry":[{},{},{},{},{},"by component size), into"]},{"entry":[{},{},{},{},{},"normal table."]},{"entry":[{},{},{},{},{},"NOTE!!"]},{"entry":[{},{},{},{},{},"First index internally biased"]},{"entry":[{},{},{},{},{},"by 0."]},{"entry":[{},{},{},{},{},"Second index internally"]},{"entry":[{},{},{},{},{},"biased by 1."]},{"entry":[{},{},{},{},{},"Third index internally"]},{"entry":[{},{},{},{},{},"biassed by 2."]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0106","num":"0173"},"figref":"FIG. 15","b":"50","ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":{"@attributes":{"id":"ul0027-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0028","list-style":"none"},"li":["GX_POINTS\u2014draws a point at each of the n vertices.","GX_LINES\u2014draws a series of unconnected line segments. Segments are drawn between v and v, v and v, etc. The number of vertices drawn should be a multiple of 2.","GX_LINESTRIP\u2014draws a series of connected lines, from v to v, then from v to v, and so on. If n vertices are drawn, n-1 lines are drawn.","GX_TRIANGLES\u2014draws a series of triangles (three-sided polygons) using vertices v, v, v, then v, v, v, and so on. The number of vertices drawn should be a multiple of 3 and the minimum number is 3.","GX_TRIANGLSTRIP\u2014draws a series of triangles (three-sided polygons) using vertices v, v, v, then v, v, v (note the order), then v, v, v, and so on. The number of vertices must be at least 3.","GX_TRIANGLEFAN\u2014draws a series of triangles (three-sided polygons) using vertices v, v, v, then v, v, v, and so on. The number of vertices must be at least 3.","GX_QUADS\u2014draws a series of non-planar quadrilaterals (4-sided polygons) beginning with v, v, v, v, then v, v, v, v, and so on. The quad is actually drawn using two triangles, so the four vertices are not required to be coplanar. it is noted that the diagonal common edge between the two triangles of a quad is oriented as shown in . The minimum number of vertices is 4."]}}}},"The application draws primitives by calling vertex functions (GXPosition, GXColor, etc.) between GXBegin\/GXEnd pairs. The application should call a vertex function for each attribute it enables using GXSetVtxDesc( ). Each vertex function has a suffix of the form GXData[n][t], which describes the number (n) and type (t) of elements passed to the vertex function.","The following case fragment demonstrates how to draw primitives using vertex functions:","GXBegin(GX_TRIANGLES, GX_VTXFMT0, 3);","GXPosition1x8(0); \/\/index to position","GXColor1x16(0); \/\/index to color","GXPosition1x8(1);","GXColor1x16(1);","GXPosition1x8(2);","GXColor1x16(2);","GXEnd( );","GXBegin specifies the type of primitive, an index into the VAT, and the number of vertices between the GXBegin\/GXEnd pair. This information, along with the latest call to GXSetVtxDesc( ), fully describes the primitive, vertex, and attribute format. GXEnd( ) is actually a null macro that can be used to make sure that GXBegin and GXEnd are paired properly.","Loading a Projection Matrix",{"@attributes":{"id":"p-0118","num":"0192"},"figref":["FIG. 16","FIG. 8","FIG. 8"],"b":["300","1004","300"]},{"@attributes":{"id":"p-0119","num":"0193"},"figref":"FIG. 16","b":["300","0","10","114","300","0","15","16","19"]},"In the example embodiment, every register in the transform unit  is mapped to a unique 32 b address. All addresses are available to the xform register load command (command 0x30). The first block is formed by the matrix memory. Its address range is 0 to 1 k, but only 256 entries are used. This memory is organized in a 64 entry by four 32 b words. Each word has a unique address and is a single precision floating point number. For block writes, the addresses auto increment. The memory is implemented in less than 4-32 b rams, then it is possible that the memory writes to this block will require a minimum write size larger than 1 word:",{"@attributes":{"id":"p-0121","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Register Address","Definition","Configuration"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0x0000","Matrix Ram word 0","32b matrix data"]},{"entry":[{},"0x0001\u20130x00ff","Matrix Ram word (n)","32b matrix data"]},{"entry":[{},"0x0100\u20130x03ff","Not used"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The second block of memory is mapped to the 1 k\u02dc1.5 k range. This memory is the normal matrix memory. It is organized as 32 rows of 3 words. Each word has a unique address and is a single precision floating point number. Also, each word written is 32 b, but only the 20 most significant bits are kept. For simplicity, the minimum granularity of writes will be 3 words:",{"@attributes":{"id":"p-0123","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Register Address","Definition","Configuration"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x0400\u20130x402","Normal Ram words 0,1,2","20b data"]},{"entry":["0x0403\u20130x045f","Normal Ram word (n)","20b data"]},{"entry":["0x0460\u20130x05ff","Not used"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The third block of memory holds the dual texture transform matrices. The format is identical to the first block of matrix memory. There are also 64 rows of 4 words for these matrices. These matrices can only be used for the dual transform of regular textures:",{"@attributes":{"id":"p-0125","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Register Address","Definition","Configuration"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0x0500","Matrix Ram word 0","32b matrix data"]},{"entry":[{},"0x0501\u20130x05ff","Matrix Ram word (n)","32b matrix data"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The fourth block of memory is the light memory. This holds all the lighting information (light vectors, light parameters, etc.). Both global state and ambient state are stored in this memory. Each word written is 32 b, but only the 20 most significant bits are kept. Each row is 3 words wide. Minimum word write size is 3 words.","As described in the above-referenced patent application No. 09\/726,215, filed Nov. 28, 2000 entitled \u201cMethod and Apparatus for Buffering Graphics Data in a Graphics System,\u201d system  includes a capability for calling a display list.  shows an example binary bit stream format used to call a display object such as a display list. In the example shown, the binary bit pattern format includes an initial \u201c0\u00d740\u201d indicating \u201cCP_CMD_CALLOBJECT\u201d, followed by a 4-byte address of the display list in memory as well as a 4-byte count or size of the display list. The 4-byte address field may include an initial seven bits of 0 padding followed by a 25-bit value. The 4-byte count value may include an initial seven bits of padding followed by a 25-bit count value indicating the count or size of the display list in 32-byte chunks.","Certain of the above-described system components  could be implemented as other than the home video game console configuration described above. For example, one could run graphics application or other software written for system  on a platform with a different configuration that emulates system  or is otherwise compatible with it. If the other platform can successfully emulate, simulate and\/or provide some or all of the hardware and software resources of system , then the other platform will be able to successfully execute the software.","As one example, an emulator may provide a hardware and\/or software configuration (platform) that is different from the hardware and\/or software configuration (platform) of system . The emulator system might include software and\/or hardware components that emulate or simulate some or all of hardware and\/or software components of the system for which the application software was written. For example, the emulator system could comprise a general purpose digital computer such as a personal computer, which executes a software emulator program that simulates the hardware and\/or firmware of system .","Some general purpose digital computers (e.g., IBM or MacIntosh personal computers and compatibles) are now equipped with 3D graphics cards that provide 3D graphics pipelines compliant with DirectX or other standard 3D graphics command APIs. They may also be equipped with stereophonic sound cards that provide high quality stereophonic sound based on a standard set of sound commands. Such multimedia-hardware-equipped personal computers running emulator software may have sufficient performance to approximate the graphics and sound performance of system . Emulator software controls the hardware resources on the personal computer platform to simulate the processing, 3D graphics, sound, peripheral and other capabilities of the home video game console platform for which the game programmer wrote the game software.",{"@attributes":{"id":"p-0131","num":"0205"},"figref":"FIG. 18A","b":["1201","1303","62","1201","1303","1201","62","1201","1303","50","62","1201"]},"As one example, in the case where the software is written for execution on a platform using an IBM PowerPC or other specific processor and the host  is a personal computer using a different (e.g., Intel) processor, emulator  fetches one or a sequence of binary-image program instructions from storage medium  and converts these program instructions to one or more equivalent Intel binary-image program instructions. The emulator  also fetches and\/or generates graphics commands and audio commands intended for processing by the graphics and audio processor , and converts these commands into a format or formats that can be processed by hardware and\/or software graphics and audio processing resources available on host . As one example, emulator  may convert these commands into commands that can be processed by specific graphics and\/or or sound hardware of the host  (e.g., using standard DirectX, OpenGL and\/or sound APIs).","An emulator  used to provide some or all of the features of the video game system described above may also be provided with a graphic user interface (GUI) that simplifies or automates the selection of various options and screen modes for games run using the emulator. In one example, such an emulator  may further include enhanced functionality as compared with the host platform for which the software was originally intended.",{"@attributes":{"id":"p-0134","num":"0208"},"figref":"FIG. 18B","b":["1201","1303","1201","1203","1205","1207","1205","1203","1207","1207","1252","1254","1256","1201","1252","1201","1209","1211","1213","1215","1217","1219","1209","1217","1207","1221","1225","1201"]},"A number of program modules including emulator  may be stored on the hard disk , removable magnetic disk , optical disk  and\/or the ROM  and\/or the RAM  of system memory . Such program modules may include an operating system providing graphics and sound APIs, one or more application programs, other program modules, program data and game data. A user may enter commands and information into personal computer system  through input devices such as a keyboard , pointing device . microphones, joysticks, game controllers, satellite dishes, scanners or the like. These and other input devices can be connected to processing unit  through a serial port interface  that is coupled to system bus , but may be connected by other interfaces, such as a parallel port, game port Fire wire bus or a universal serial bus (USB). A monitor  or other type of display device is also connected to system bus  via an interface, such as a video adapter .","System  may also include a modem  or other network interface means for establishing communications over a network  such as the Internet. Modem , which may be internal or external, is connected to system bus  via serial port interface . A network interface  may also be provided for allowing system  to communicate with a remote computing device  (e.g., another system ) via a local area network  (or such communication may be via wide area network  or other communications path such as dial-up or other communications means). System  will typically include other peripheral output devices, such as printers and other standard peripheral devices.","In one example, video adapter  may include a 3D graphics pipeline chip set providing fast 3D graphics rendering in response to 3D graphics commands issued based on a standard 3D graphics application programmer interface such as Microsoft's DirectX 7.0 or other version. A set of stereo loudspeakers  is also connected to system bus  via a sound generating interface such as a conventional \u201csound card\u201d providing hardware and embedded software support for generating high quality stereophonic sound based on sound commands provided by bus . These hardware capabilities allow system  to provide sufficient graphics and sound speed performance to play software stored in storage medium .","The following show example higher level API cells that a library interprets and\/or computes to create the binary level command streams described above:","GXSetCopyClear",{"@attributes":{"id":"p-0139","num":"0213"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Argument:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GXColor","ClearColor;","\/\/Color value to clear the framebuffer to"]},{"entry":[{},{},"during copy."]},{"entry":["u32","ClearZ;","\/\/24 bit Z value to clear the framebuffer to"]},{"entry":[{},{},"during copy."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},{"@attributes":{"id":"p-0140","num":"0214"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Arguments:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GX","Attr","Attr; \/\/Which attribute (Position, Normal, Color,"]},{"entry":[{},{},"etc.)"]},{"entry":["GX","Attr","Type Type; \/\/Attribute Type (None, Direct, Indexed,"]},{"entry":[{},{},"etc.)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},{"@attributes":{"id":"p-0141","num":"0215"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Argument:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GXVtxFmt","vtxfmt;","\/\/Index into the Vertex Attribute"]},{"entry":[{},{},"Table (0\u20137)."]},{"entry":["GXAttr","Attr;","\/\/Attribute Type."]},{"entry":["GXCompCnt","CompCnt;","\/\/Number of components for the attribute."]},{"entry":["GXCompType","CompType","\/\/Type of each Component."]},{"entry":["u8","Shift;","\/\/Locatin of decimal point for fixed point"]},{"entry":[{},{},"format types."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},{"@attributes":{"id":"p-0142","num":"0216"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Arguments:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GXAttr","Attr;","\/\/Attribute type."]},{"entry":["u32","Base;","\/\/Address (25:0) of the attribute data array in"]},{"entry":[{},{},"main memory."]},{"entry":["u8","Stride;","\/\/Number of bytes between successive elements"]},{"entry":[{},{},"in the attribute array."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},{"@attributes":{"id":"p-0143","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Arguments:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f32","Matrix[4][4]","\/\/Projection matrix."]},{"entry":[{},"GXProjMtxType","type;","\/\/Indicates if the projection is"]},{"entry":[{},{},{},"orthographic."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Perspective Projection:",{"@attributes":{"id":"p-0145","num":"0219"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mi":"X"}},{"mtd":{"mi":"Y"}},{"mtd":{"mi":"Z"}},{"mtd":{"mi":"W"}}]}},{"mrow":[{"mo":["[","]"],"mrow":{"mtable":[{"mtr":[{"mtd":{"mi":"p0"}},{"mtd":{"mn":"0"}},{"mtd":{"mn":"0"}},{"mtd":{"mn":"0"}}]},{"mtr":[{"mtd":{"mn":"0"}},{"mtd":{"mi":"p2"}},{"mtd":{"mn":"0"}},{"mtd":{"mn":"0"}}]},{"mtr":[{"mtd":{"mi":"p1"}},{"mtd":{"mi":"p3"}},{"mtd":{"mi":"p4"}},{"mtd":{"mrow":{"mo":"-","mn":"1"}}}]},{"mtr":[{"mtd":{"mn":"0"}},{"mtd":{"mn":"0"}},{"mtd":{"mi":"p5"}},{"mtd":{"mn":"0"}}]}],"mo":["\u2062","\u2062","\u2062"]}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mi":"Xe"}},{"mtd":{"mi":"Ye"}},{"mtd":{"mi":"Ze"}},{"mtd":{"mn":"1"}}]}}],"mo":"\u2061"}],"mo":"="}}}},"Orthographic Projection:",{"@attributes":{"id":"p-0147","num":"0221"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mi":"X"}},{"mtd":{"mi":"Y"}},{"mtd":{"mi":"Z"}},{"mtd":{"mi":"W"}}]}},{"mrow":[{"mo":["[","]"],"mrow":{"mtable":[{"mtr":[{"mtd":{"mi":"p0"}},{"mtd":{"mn":"0"}},{"mtd":{"mn":"0"}},{"mtd":{"mn":"0"}}]},{"mtr":[{"mtd":{"mn":"0"}},{"mtd":{"mi":"p2"}},{"mtd":{"mn":"0"}},{"mtd":{"mn":"0"}}]},{"mtr":[{"mtd":{"mn":"0"}},{"mtd":{"mn":"0"}},{"mtd":{"mi":"p4"}},{"mtd":{"mn":"0"}}]},{"mtr":[{"mtd":{"mi":"p1"}},{"mtd":{"mi":"p3"}},{"mtd":{"mi":"p5"}},{"mtd":{"mn":"1"}}]}],"mo":["\u2062","\u2062","\u2062"]}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mi":"Xe"}},{"mtd":{"mi":"Ye"}},{"mtd":{"mi":"Ze"}},{"mtd":{"mn":"1"}}]}}],"mo":"\u2061"}],"mo":"="}}}},"All document referred to herein are expressly incorporated by reference as if expressly set forth.","As used herein, the notation \u201c0x\u201d indicates a hexadecimal value. For example, \u201c0x61\u201d indicates a hexadecimal value. For example, \u201c0x61\u201d indicates a two-byte hexadecima value of \u201c61\u201d\u2014which people of ordinary skill in the art understand has a binary format of \u201c01100001\u201d. See Table VI below for conversion of hexadecimal notaion to binary notation:",{"@attributes":{"id":"p-0150","num":"0224"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE VI"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Hex","Binary"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","0000"]},{"entry":[{},"1","0001"]},{"entry":[{},"2","0010"]},{"entry":[{},"3","0011"]},{"entry":[{},"4","0100"]},{"entry":[{},"5","0101"]},{"entry":[{},"6","0110"]},{"entry":[{},"7","0111"]},{"entry":[{},"8","1000"]},{"entry":[{},"9","1001"]},{"entry":[{},"A","1010"]},{"entry":[{},"B","1011"]},{"entry":[{},"C","1100"]},{"entry":[{},"D","1101"]},{"entry":[{},"E","1110"]},{"entry":[{},"F","1111"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other features and advantages provided by the invention will be better and more completely understood by referring to the following detailed description of presently preferred embodiments in conjunction with the drawings, of which:",{"@attributes":{"id":"p-0014","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0020"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0021"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0017","num":"0022"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0023"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0019","num":"0024"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0025"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0021","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0027"},"figref":["FIG. 9","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0028"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0024","num":"0029"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0030"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0026","num":"0031"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0027","num":"0032"},"figref":"FIGS. 13A and 13B"},{"@attributes":{"id":"p-0028","num":"0033"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0029","num":"0034"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0030","num":"0035"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0031","num":"0036"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0032","num":"0037"},"figref":"FIGS. 18A and 18B"}]},"DETDESC":[{},{}]}
