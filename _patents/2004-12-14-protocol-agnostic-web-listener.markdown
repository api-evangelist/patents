---
title: Protocol agnostic web listener
abstract: A system and method for facilitating exposing a resource over a protocol is provided. The system includes a class factory that holds identifiers associated with determining which, if any, registered listener object creator should be employed to create a listener object. The listener object implements an abstract network protocol base class. The listener object is employed to abstract details of exposing a resource over a protocol and to provide a byte stream interface to communications occurring over the protocol, while removing protocol specific code from a server program. The method includes creating an instance of a listener object from a source of registered protocol handlers based on a request to expose a resource over a protocol and using a base class API to communicate over the protocol through the listener object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07437742&OS=07437742&RS=07437742
owner: Microsoft Corporation
number: 07437742
owner_city: Redmond
owner_country: US
publication_date: 20041214
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a divisional of U.S. Pat. No. 6,931,647 (U.S. patent application Ser. No. 09\/818,448), filed Mar. 27, 2001, issued Aug. 16, 2005, and entitled \u201cPROTOCOL AGNOSTIC WEB LISTENER.\u201d The entirety of this application is incorporated herein by reference. This application is also related to U.S. Pat. No. 7,120,916 (U.S. patent application Ser. No. 11\/047,294), filed Jan. 31, 2005, issued Oct. 10, 2006, and entitled, \u201cPROTOCOL AGNOSTIC WEB LISTENER.\u201d","The present invention relates generally to computer programming and more particularly to simplifying exposing resources (e.g., applications, content and services) to applications accessing such resources over a network, by providing network objects operable to abstract protocol specific communication details.","As more programs and users have become accustomed to seeking access to applications, services and content sources (hereinafter resources) available over networks, it has become more common for providers of such resources to expose and serve up (hereinafter \u201cexpose\u201d) their resources via a network. Conventionally, exposing resources requires employing a server program that consumes significant resources (e.g., processing cycles, disk, communication bandwidth). But some providers of resources may not require the comprehensive features provided by conventional servers and may not be able to afford the resources required by such \u201cheavyweight\u201d conventional servers. Thus, resources that could be made available over networks may not be made available, limiting the expansion and value of such networks.","Exposing resources over a network typically requires formatting communications in a protocol supported by the network. Such communication is typically handled by a server. For example, messages traversing the Internet can be formatted in protocols including, but not limited to, Hypertext Transfer Protocol (HTTP), File Transfer Protocol (FTP) and Simple Mail Transport Protocol (SMTP). Such a diversity of protocols facilitates communication between a wide range of devices, applications and\/or processes in a variety of methods. But such diversity leads to problems for server programmers trying to expose resources through different networks and by different protocols to facilitate wide accessibility.","Conventionally, a server program written to expose resources provided over a network includes code specific to the protocol employed to transport messages across the network. For example, a programmer writing a peer-to-peer application for exposing files that can be shared across a network includes code specific to the protocol existing between the peer processes. By way of illustration, a file-sharing program may have to include HTTP specific code. Including such protocol specific code in a server program can negatively impact writing such a server program by requiring the programmer(s) involved in writing the server program to learn details of the protocol. Learning such details, and coding such protocol specific details can increase program complexity while reducing program flexibility.","Program flexibility can be important to programs exposing resources. For example, protocols change, and thus an inflexible program that cannot adapt to such changes will have restricted utility and shortened lifespan. By way of illustration, a program written to communicate specifically via HTTP 1.0 may not be able to communicate via HTTP 1.1. Thus, the server program may need to be rewritten and recompiled to take advantage of the newer protocol. By way of further illustration, peer-to-peer communications are characterized by dynamically formed ad hoc networks. Such dynamic ad hoc networks require servers capable of being protocol and URI agile. Server programs relying solely on protocol and URI specific code cannot provide the desired agility.","The dynamic ad hoc networks prevalent in peer-to-peer communications are typically established between peers with limited resources. For example, a college student with a personal computer may desire to establish a peer-to-peer network with his family and friends to share files. His family and friends may similarly only have available a set of small computers to engage in the desired communications. Conventionally, a server program written to expose resources provided over a network required large amounts of computer resources (e.g., processing cycles, disk space, network bandwidth) and thus the college student and his peers may not be able to establish the desired communications. Servers that require such large amounts of computer resources can be referred to as \u201cheavyweight\u201d servers. Heavyweight servers, therefore, can limit the ability to form ad hoc networks, and thus limit desired communications between peers.","Programmers writing server programs to expose resources addressable by a URI (Uniform Resource Identifier) typically are required to know the URI, to leave the resource at the known URI, to know the protocol employed to access the URI and to write code specific to the protocol required to access that URI. Thus, changing the URI of an application, service and\/or content source could require a server program to be rewritten and recompiled, thus restricting the ability to move content from one location to another and introducing opportunities to introduce new bugs into a system when such relocation is attempted. Further, user written server programs conventionally are prevented from sharing a protocol (e.g., HTTP) namespace with a commercially provided server unless the user written server program can co-exist with (often by being dominated by) the commercial server. Further still, user written servers tend to consume the entire namespace on the machine on which they run, restricting a machine to running one server. But it can be advantageous to have a machine expose a plurality of smaller, less resource intensive resources (e.g., content source of a single page of data, a simple ZIP code lookup application, a simple file sharing service) through a plurality of small servers.","Programmers are further constrained by conventional systems and methods to transmit and receive messages in message sizes and formats dictated by a protocol. For example, a server exposing email content may be required to listen for requests for email where the requests are formatted as a packet with a header and trailer according to a first protocol. Similarly, a server exposing an encyclopedia may be required to listen for HTTP get requests consisting of a few words formatted according to a second protocol. Such protocol specific packaging and size restrictions add complexity to server programs and limit the ability of one server to expose multiple resources over a variety of protocols.","Thus a system and\/or method for enabling server applications to expose resources and to communicate simply over a plurality of protocols is still needed to mitigate problems associated with conventional systems.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key or critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The present invention provides a system and method for a server program to expose and serve up (hereinafter \u201cexpose\u201d) applications, services and content sources (hereinafter \u201cresources\u201d) at one or more URIs and to communicate over a variety of protocols without having to rewrite and recompile the server program when interacting with different protocols or when exposing different resources. The system further facilitates a server program interacting with a new protocol without having to rewrite and recompile the server program. The system facilitates making messages sent and received over a network appear to be a simple byte stream. Such a byte stream can be read and\/or written by a server program without protocol specific sizing and\/or packaging details, thus mitigating sizing problems associated with conventional systems. The system facilitates providing a server that requires fewer resources than a conventional \u201cheavyweight\u201d server that attempts to perform substantially all functions related to one or more protocols, and can thus be referred to as a \u201clightweight\u201d server. The system facilitates multiple server programs operating concurrently on one computer.","The system includes a class factory that houses identifiers and associated registered listener object creators. The identifiers can be, but are not limited to being, registered URIs and\/or URI prefixes. When a server programmer desires to write a server application that will expose resources addressable by an identifier, the server programmer will be able to request that the class factory provide a listener object suitable for communicating over the protocol(s) by which the resources can be accessed. The server programmer will not be required to learn details associated with communicating by the protocol(s) employed by accessing applications to communicate with the resources. Thus, complexity problems associated with conventional systems are mitigated.","If a suitable listener object has been registered with the class factory, then the class factory will return a listener object capable of communicating over that protocol. The listener object can make messages received over the protocol appear as a continuous byte stream to the programmer. Further, the listener object facilitates sending messages by writing to a continuous byte stream. Thus, problems associated with sizing are mitigated.","The system includes a listener object registration system that facilitates making new listener objects available to server applications. When such listener objects become available, they can be registered with the class factory. Such registration makes the listener object available to the server program without requiring server program rewriting or recompiling. Thus, problems associated with program flexibility and adaptability are mitigated. Such registration, and subsequent availability to user written server programs facilitates having multiple server programs operate concurrently on one computer. For example, a first server program may access a registered listener object operable to communicate via a first protocol, while a second server program may access a second and a third registered listener object to communicate via a second and third protocol.","The present invention also provides a method for allowing a server program to expose resources over different protocols. The method includes registering protocol handlers with a listener object generating process. The method includes accepting a request from an application seeking to expose resources. The method accepts the request and the listener object generating process creates an instance of a listener object from the registered protocol handlers. For example, if the application seeks to expose resources accessible via HTTP, the method can return a listener object capable of processing HTTP requests and responses. Such requests may be represented by a WebRequest object, for example. The listener object would be further operable to treat such requests (e.g., as represented by WebRequest objects) and responses as a byte stream. The server program can then communicate with the entities accessing the exposed resources through the listener object by employing methods available through a base class API.","The present invention may also provide separate analogous objects, processes and methods for returning the content requested by an accessing application, where such request was received via the listener object, to the accessing application, in lieu of employing the listener object to both receive and return information.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative of but a few of the various ways in which the principles of the invention may be employed and the present invention is intended to include all such aspects and their equivalents. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The present invention is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate description of the present invention.","The term \u201ccomponent\u201d refers to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be a process running on a processor, a processor, an object, an executable, a thread of execution, a program and a computer. By way of illustration, both an application running on a server and the server can be components.","The term \u201cclass factory\u201d refers to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a class factory may be a process running on a processor, a processor, an object, an executable, a thread of execution, a program and a computer. By way of illustration, both an application running on a server and the server can be class factories.","The term \u201ccreator\u201d refers to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a creator may be a process running on a processor, a processor, an object, an executable, a thread of execution, a program and a computer. By way of illustration, both an application running on a server and the server can be creators.","The term \u201cconstructor\u201d refers to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a constructor may be a process running on a processor, a processor, an object, an executable, a thread of execution, a program and a computer. By way of illustration, both an application running on a server and the server can be constructors.","It is to be appreciated that various aspects of the present invention may employ technologies associated with facilitating unconstrained optimization and\/or minimization of error costs. Thus, non-linear training systems\/methodologies (e.g., back propagation, Bayesian, fuzzy sets, non-linear regression, or other neural networking paradigms including mixture of experts, cerebella model arithmetic computer (CMACS), radial basis functions, directed search networks and function link networks) may be employed.","Referring initially to , server programs , and through , N being an integer, (collectively the server programs ) are illustrated exposing an application , a content  and a service  (collectively the resources ) to a accessing applications , and through , N being an integer, (collectively the accessing applications ), via one or more protocols . Exposing the resources  involves making the resources  available to the accessing applications . Conventionally, a server program desiring to expose the resources  is required to include code specific to the protocol(s)  by which the server program and the accessing applications  will communicate. For example, a first server program desiring to expose a Hypertext Markup Language (HTML) Web page can be required to include code specific to the Hypertext Transfer Protocol (HTTP). Similarly, a second server program desiring to expose an FTP resource may be required to include code specific to the File Transfer Protocol. Embedding such protocol specific code in a server program increases server program complexity while reducing server program flexibility. Thus, the present invention facilitates writing a server program to expose the resources  while remaining abstracted from the details of the protocol(s) .","Although the server programs  and the accessing applications  are illustrated as separate entities, it is to be appreciated by one skilled in the art that a computer may host both a server program  and an accessing application . It is to be further appreciated that although the first server program , the second server program and the Nth server program are illustrated as separate entities, that a single computer may host more than one server program , with such server programs operating concurrently.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 2","b":["200","210","240","260","230","210","260","235","200","210","220","210","260","250","250","230","200","200","210","210","240","200","240","230","240","200"]},"Conventionally, the server program  would be required to format data intended for a first accessing application in a manner consistent with a first protocol  through which the resource  was exposed by including protocol specific code. By way of illustration, if a first resource  was an HTML page, the server program  could be required to include code specific to an HTTP protocol. By way of further illustration, if a second resource  was an FTP data source, then the server program  could be required to include code specific to an FTP protocol to expose the resource  a second accessing application . Including such protocol specific code in the server program  can increase the server program  complexity and cost. Furthermore, including such protocol specific code in the server program  can limit the flexibility and thus shorten the lifespan of the server program . Conventionally, if the server program  desired to expose more than one resource  via more than one protocol, then the server program  could be required to include code specific to each of the protocols with which it would interact, thus increasing the server program  size and complexity.","The present invention thus provides a listener object  that mitigates problems associated with requiring the inclusion of protocol specific code in the server program . The listener object  facilitates establishing a data communications channel, exposing the resource  and receiving requests. Such requests may be represented, for example, in a WebRequest object that facilitates treating requests in a generic manner. By way of illustration, if the resource  was an HTML page, the server program  would not be required to include code specific to an HTTP protocol, rather the server program  would communicate via a first byte stream  with a first listener object . The first listener object  would include the protocol specific code that facilitates exposing the resource  via the HTTP protocol. Thus, if a first accessing application made a request for content exposed in the resources , the listener object  could receive such a request (represented, for example, in a WebRequest object), parse the request, and provide the content of the request to the server application  as a byte stream. By way of further illustration, if the resource  was an FTP data source, then the server program  would not be required to include code specific to an FTP protocol. Rather, the server program  would expose the resource  via a second byte stream  with a second listener object . The second listener object  would include the protocol specific code that facilitates exposing the resource  via the FTP protocol. Thus, if a second accessing application made a request for content exposed in the resource , the listener object  could receive such a request, parse the request, and provide the content of the request to the server application  as a byte stream. The listener object  could convert the byte stream  to a format consistent with the protocol by which the desired resource  is accessed. For example, a first protocol object  could convert a first byte stream  associated with a first accessing application into data consistent with an HTTP protocol while a second listener object  could convert a second byte stream  associated with a second accessing application into data consistent with an FTP protocol.","The present invention thus mitigates complexity and inflexibility problems associated with conventional systems by providing listener objects  that can receive requests represented, for example, by WebRequest objects and remove code associated with the protocol specific details from the server program , making exposing the resource  possible via a byte stream . The present invention thus simplifies writing server programs  that expose one or more resources  to one or more accessing applications  via one or more protocols . Thus, writing server programs  that can accept requests from a first accessing application via a first protocol  and that can then write data related to such requests to a second accessing application via a second protocol is simplified. Furthermore, writing server programs  that expose resources  that are mobile (e.g., which can change URI) without requiring the server program  to be recompiled is simplified. By way of illustration, a server program  may expose a resource  locatable via a first URI through a first protocol but then the resource  may change its URI. Conventionally, the server program  may be required to add additional code to deal with a new protocol through which the resource  would be exposed. Including such additional code could require recompiling the server program . But the present invention can accept, by way of illustration, a URI as an identifier to determine which of a plurality of listener objects to employ to facilitate exposing a resource . Thus, no additional code needs to be added to the server program  to facilitate dealing with the different protocol and thus no recompilation is required.","By way of illustration of the decrease in complexity possible through the present invention, the following code fragment illustrates one possible method for a server program  to create a listener object , the listener object  interacting with requests represented as WebRequest objects, for example, and the listener object  including the code specific to a protocol and operable to provide the server program  with a byte stream.","1. WebListener WL=WebListenerClassFactory.create(protocol1);","2. WL.AddURIPrefix(Resources_name);","3. WebRequest WR=WL.GetRequest( );","Line 1 creates a web listener object for listening over the protocol specified by the variable protocol1. The variable protocol1 may have been populated, for example, by a command line argument, from a field read from a file, or by an interactive method (e.g., data acquired by an Active Server Page). The argument protocol1 can be, for example, a registered index. The create method is employed to invoke a listener object constructor based, at least in part, on the value of the argument protocol1.","Line 2 creates a URI identifying an address at which the resource is exposed. For example, if the value of protocol1 were \u201chttp\u201d and the value of Resources_name were mymoney, and lines 1 and 2 were invoked from a computer named ServerX1, then the URI http:\/\/ServerX1\/mymoney would be created in the server's name space, and accessing applications would be able to access the content of mymoney exposed at the URI.","Line 3 starts the listening process for the listener object created in line 1. Requests received through the listening process can be stored in the WebRequest object WR created in line 3. Thus, requests received through the listener object created in line 1 are parsed and placed into a byte stream that is available to the server program that include lines 1, 2 and 3.","Thus, lines 1, 2 and 3 illustrate one example of server program  creation that does not require protocol specific code, and which is thus relatively simple and flexible as compared to conventional systems.","Turning now to , a schematic block diagram illustrates a server program  employing a listener object  and an answering object  to expose a resource  via a protocol  to an accessing application . Although the answering object  and the listener object  are illustrated as two separate objects, it is to be appreciated by one skilled in the art that the listening and answering functionality may be accomplished in a greater or lesser number of separate, combined, and\/or distributed objects. It is to be further appreciated that although a listener object  is illustrated, a reading component may perform the listening functionality. Any suitable reading component may be employed in accordance with the present invention. Similarly, it is to be further appreciated that although an answering object  is illustrated, a writing component may perform the answering functionality. Any suitable writing component may be employed in accordance with the present invention. It is to be further appreciated that although a server program  is illustrated, an exposing component may be employed to expose the resource  to the accessing application  through the listener object  and\/or the answering object .","The answering object  may be, for example, a WEB_ANSWER object, which accepts a byte stream  of data related to a request generated by the accessing application  and produces a data  consistent with the protocol . The answering object  may also accept a generic WebResponse object  and produce protocol specific objects including, but not limited to, HttpWebResponse objects  and FtpWebResponse objects . The protocol specific code required to provide such functionality is removed from the server program , which leads to reduced server program  complexity and increased server program  flexibility. The listener object  may be, for example, a WEB_LISTENER object, which produces a byte stream  from a data  associated with a request generated by the accessing application , the data  being formatted consistently with the protocol . The listening object  may also accept protocol specific objects including, but not limited to, HttpWebRequest objects  and FtpWebRequest objects  and produce a generic WebRequest object . The protocol specific code required to provide such functionality is removed from the server program , which leads to reduced server program  complexity and increased server program  flexibility. The answering object  and the listener object  can thus make the accessing application  appear as a pair of byte streams and\/or as a series of generic, protocol-free request and response objects to the server program , simplifying the process of writing the server program . Although a WEB_ANSWER object and a WEB_LISTENER object are illustrated as examples of the answering object  and the listener object , it is to be appreciated by one skilled in the art that any appropriate listening and\/or answering objects can be employed in accordance with the present invention.","Due, at least in part, to the functionality provided by the listener object  and\/or the answering object , the server program  is not required to include code specific to the protocol , but rather the server program  includes code that can be employed to generate the creation of the listener object  and\/or the answering object . Such generating code can be employed to create objects that can be employed to expose a resource  to a plurality of accessing applications  via a plurality of protocols . Furthermore, such generating code can be responsive to parameters input to the server program , allowing the server program  to be flexible and avoid recoding and recompilations. The input parameters may, for example, be associated with identifiers stored in a class factory (e.g., , ) employed to select a listener object creator operable to create the listener object  and\/or the answering object . Thus, with input parameters available to be passed through to a class factory callable by generic program code, the server program  can be isolated from protocol specific details, increasing flexibility and lifespan over conventional systems. The server program  may invoke such generating code one or more times, as needed, to concurrently expose one or more resources  via one or more protocols  to one or more accessing applications . Thus, complexity and program size problems associated with conventional systems are mitigated.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 4","FIG. 4"],"b":["400","450","410","405","480","430","420","470","410","450","450","410","400","405","480","450","410","420","410","410","410","420","440","430","410","422","442","444","440","400","410","400","410","450","450","460","430","470","450","462","464","472","440","460","410","450","440","460","430","450","460","470","410","430","420","440"]},"While the server program  is illustrated interacting with one outgoing byte stream  and one incoming byte stream , it is to be appreciated by one skilled in the art that the server program  may concurrently expose one or more resources  by one or more protocols  to one or more accessing applications , and therefore more than one outgoing byte stream  may be associated with the server program  and more than one incoming byte stream  may be associated with the server program . Similarly, more than one answering object  may be associated with the server program  and more than one listener object  may be associated with the server program .","It is to be further appreciated that although one server program  is illustrated, that more than one server program  may reside on a computer. Removing protocol specific code from the server program  and depositing it in protocol specific objects, which objects may run on the same computer as the server program , or which objects may run on one or more computers separate from the computer whereon the server program  runs facilitates reducing the size of the server program . Furthermore, removing the protocol specific code to the protocol specific objects facilitates simplifying the server program , which in turns facilitates having multiple server programs  reside on one computer. By allowing multiple server programs  to reside on one computer, server exclusivity problems associated with conventional systems are mitigated and the creation of ad hoc peer-to-peer networks is facilitated.","Referring now to , a system  for facilitating a server program  exposing one or more resources (e.g., , ) to one or more accessing applications (e.g., , ) over one or more protocols (e.g., , ) is illustrated. The system  includes a class factory  that has access to a first constructor , and a second constructor through an Nth constructor , N being an integer. The constructors , through can be referred to collectively as the constructors . The first constructor may be operable to produce listener and\/or answering objects that facilitate exposing a resource (e.g., , ) via a first protocol (e.g., HTTP) while the second constructor may be operable to produce listener and\/or answering objects that facilitate exposing a resource (e.g., , ) via a second protocol (e.g., FTP). To expose a resource (e.g., , ) to one or more accessing applications (e.g., , ) via a protocol (e.g., , ) the server program  can first request that a listener object be created by the class factory . The class factory  can select an appropriate constructor to employ to construct such a listener object based on an identifier associated with the resource (e.g., , ) that the server program  seeks to expose. By way of illustration, if the server program  seeks to expose a resource identified by the URI http:\/\/ServerX1\/mymoney then the class factory  may employ a constructor to produce a listener object operable to interact with the HTTP protocol. By way of further illustration, if the server program  seeks to expose a resource identified by the URI ftp:\/\/ServerX1\/yourmoney then the class factory  may employ a different constructor to produce a listener object operable to interact with the FTP protocol.","Thus, in the example presented, the server program  may supply a URI to the class factory . The URI can be an input to the server program  (e.g., a command line parameter, a field read from a file, a string input by a user) that is employed by the code that invokes the operations of the class factory . Thus, the server program  can be substantially insulated from protocol specific actions, thereby mitigating flexibility problems associated with conventional systems. The class factory  is then responsible for selecting a constructor, invoking a create method in the chosen constructor and returning a listener object operable to facilitate the desired exposure by the server program . Thus, by moving creator selection to a class factory  that is external to the server program , flexibility and complexity problems associated with conventional systems are mitigated. Furthermore, removing such protocol specific code to the class factory  facilitates minimizing the computer resource requirements of the server program , which in turn facilitates running multiple server programs  on one computer.","The class factory  can access a data store  of registered protocol handlers to facilitate determining which, if any, constructor to employ to create a listener object to expose a desired resource. By way of illustration, the data store  of registered protocol handlers may store items including, but not limited to, a list of constructors associated with one or more URIs, a list of constructors associated with one or more URI prefixes and a list of rules for selecting a constructor based on a URI. While the previous sentence refers to lists, it is to be appreciated by one skilled in the art that the data store  can employ other data structures including, but not limited to, an array, a table, a database, a stack, a heap, a linked list, a heap and a data cube.","One problem with conventional systems was the difficulty with which such systems responded to new protocols, typically requiring recoding and recompilation of server programs when new protocols were introduced. Thus, turning to , a system  for registering new listener object constructors with a class factory , the new listener object constructors operable to produce listener objects operable to facilitate exposing a resource via a new protocol, is illustrated. Before the addition of a new constructor and related registered listener handler information, the class factory  had access to a first constructor and a second constructor through an Nth constructor , N being an integer. The first constructor may be operable to produce listener and\/or answering objects associated with a first protocol (e.g., HTTP), while the second constructor may be operable to produce listener and\/or answering objects associated with a second protocol (e.g., FTP). Information sufficient to determine which constructor, if any, is appropriate to employ to construct a listener and\/or answering object to facilitate exposing a resource can be stored in a data store  of registered protocol handlers. The data store  may store items including, but not limited to, a list of constructors associated with one or more URIs, a list of constructors associated with one or more URI prefixes and a list of rules for selecting a constructor based on a URI. While the previous sentence refers to lists, it is to be appreciated by one skilled in the art that the data store  can employ other data structures including, but not limited to, an array, a table, a database, a stack, a heap, a linked list, a heap and a data cube.","When a registering entity  desires to add a new protocol to the class factory  set of protocols for which constructors are available, the registering entity  will take at least two actions. The registering entity  will produce a new constructor , and the registering entity  will register the new constructor with the data store . Registering the new constructor with the data store  may involve updating items including, but not limited to, a list of constructors associated with one or more URIs, a list of constructors associated with one or more URI prefixes and a list of rules for selecting a constructor based on a URI. While the previous sentence refers to lists, it is to be appreciated by one skilled in the art that updating the data store  can involve updating other data structures including, but not limited to, an array, a table, a database, a stack, a heap, a linked list, a heap and a data cube. Once the data store  is updated, then the class factory  can employ the new constructor to create protocol objects associated with the new protocol. It is to be appreciated by one skilled in the art that although a registering entity  is illustrated, that an adding component may be employed to add an identifier to the data store  of registered protocol handlers and that any suitable adding component may be employed with the present invention.","Adding a new constructor operable to produce listener and\/or answering objects associated with the new protocol can thus be completed without requiring changes to a server program (e.g., , ). To acquire a listener object created by the new constructor , a server program (e.g., , ) would not require recompilation, thus mitigating lifespan problems associated with conventional systems. A server program (e.g., , ) may not even be aware that the new constructor became available. By way of illustration, acquiring a listener object operable to facilitate exposing a resource through a new protocol may involve inputting a parameter to the server program (e.g., , ), and passing the parameter to existing generator code that will in turn access the class factory . The parameter may be a URI. To acquire a listener object created by the new constructor , a server program (e.g., , ) could provide a URI to the class factory, which would be responsible for determining that the new constructor was available and appropriate for the desired communication, and which would further be responsible for invoking the new constructor and returning the listener object(s) created by the new constructor . The class factory  will be able to interact with the new constructor and a server program will be able to interact with a listener object created by the new constructor if the new constructor implements a set of methods defined in an abstract network base class. Such abstract base class enabled access to the new constructor can thus be accomplished with no changes to the server program.","Thus, turning to , an abstract base class  and a protocol handler class  that inherits from the abstract base class  and which implements the abstract base class  are illustrated. It is to be appreciated by one skilled in the art that the protocol handler class  can provide the functionality of a listener object (e.g., , ) and\/or an answering object (e.g., , ). The abstract base class  defines an interface , which includes N methods, N being an integer. The abstract base class  may also define one or more properties. The protocol handler class  inherits from the abstract base class , and implements the interface . In an abstract base class, methods are defined but not implemented. The present invention employs such abstract base classes to define an interface that protocol handler classes can implement.","The interface  can have methods including, but not limited to, methods for creating an object, methods for writing to a byte stream, methods for reading from a byte stream, methods for adding protocol specific information to data, methods for removing protocol specific information from data, methods for registering a protocol object creator and methods for determining the status of an exposure. It is to be appreciated by one skilled in the art that some methods may be visible to a server program interacting with a protocol handler class object  (e.g., write to byte stream, read to byte stream) while other methods may not be visible to such a server program (e.g., add protocol header, remove protocol header). It is to be further appreciated that some methods (e.g., creator methods) may be invoked by a class factory (e.g., , FIG. ). The implementation of the interface  by the class specific object  facilitates implementing class factory functionality, with such functionality being removed from an application program, which thus mitigates server program complexity and size problems.","Turning to , a block diagram illustrates a class factory  with a registry  of protocol object creators. It is to be appreciated by one skilled in the art that although protocol object creators are discussed in connection with , that such protocol objects can provide the functionality of a listener object (e.g., , ) and\/or an answering object (e.g., , ). The registry  of protocol object creators can include identifiers that can be employed to resolve a URI. Such identifiers may be associated with parameters that can be input to a server program (e.g., , ). The registry  can be employed to associate identifiers with protocol object creators in protocol objects that have implemented an abstract base class creator method . By way of illustration, the creator method  may be an implementation of a base class create method , with the creator method  defined by a protocol object class associated with facilitating exposing a resource via HTTP. By way of further illustration, the creator method  may be an implementation of the base class create method , with the creator method  being defined by a protocol object class associated with facilitating exposing a resource via FTP.","The registry  can be indexed, for example, by a URI, and\/or by a prefix associated with a URI. For example, the prefix \u201chttp\u201d in a URI http:\/\/ServerX1\/mymoney may be employed as an identifier in the registry . The identifier can be employed to locate a creator method  appropriate to create a listener object associated with facilitating exposing a resource via the HTTP protocol. The creator method  can be, for example, the HTTP_WEB_LISTENER::CREATE method. Also, for example, the prefix \u201cftp\u201d in a URI ftp:\/\/ServerX1\/yourmoney may be employed as an identifier in the registry . The identifier can be employed to locate a creator method  appropriate to create a listener object associated with facilitating exposure via the FTP protocol. The creator method  can be, for example, the FTP_WEB_LISTENER::CREATE method.","By employing the registry  and the identifiers stored in the registry  to locate methods implementing methods defined in the abstract base class , the present invention facilitates adding creator methods that can be employed to create listener objects associated with new protocols, with such addition not requiring changes to a server program employing such creator methods. The registry  can be updated, and a new creator method can be added without requiring rewriting and\/or recompilation of a server program (e.g., , ), thus mitigating complexity and lifespan problems associated with conventional systems.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 9","b":"900"},"The base class definition  can include properties and methods. The properties can include, but are not limited to a URI_LIST. The methods can include, but are not limited to, an ADD URI_PREFIX(STRING)method, a REMOVE_URI_PREFIX(STRING) method, a REMOVE_ALL( ) method, a GET_REQUEST( ) method, a BEGIN_GET_REQUEST( ) method and an END_GET_REQUEST( ) method. While one property and six methods are illustrated in , it is to be appreciated by one skilled in the art that a greater or lesser number of properties and\/or methods can be employed in a listening\/reading object in accordance with the present invention.","The URI_LIST property may hold, for example, a list of strings containing identifiers (e.g., URIs) of exposed resources registered with a listener object. Such a list may be employed to associate listener objects with entities being accessed, for example. Thus, data stored in the properties can be employed to facilitate exposing a resource to one or more accessing applications via one or more protocols by storing information employed in facilitating such exposure. Storing such information in a listener object implementing an abstract base class definition facilitates reducing server program complexity by removing such protocol specific information from a server program, thus mitigating complexity problems associated with conventional systems.","The ADD_URI_PREFIX(STRING) method can be employed, for example, to register an identifier (e.g., a URI, a URI prefix) in a class factory data store (e.g., , ) to facilitate associating one or more listener objects with one or more resources. Conversely, the REMOVE_URI_PREFIX(STRING) method can be employed, for example, to deregister an identifier (e.g., URI, prefix) in a class factory data store (e.g., , ) when the listener object association is no longer valid. Similarly, the REMOVE_ALL( ) method can be employed, for example, to deregister identifiers (e.g., URIs, prefixes) in a class factory data store (e.g., , ) when the listener object associations are no longer valid and\/or available. The GET_REQUEST( ) method can be employed, for example, to facilitate synchronous listening. The GET_REQUEST( ) method can return an object containing a web request in a generic, protocol-free form (e.g., a WebRequest object). The GET_REQUEST( ) can block until such a request is received, thus facilitating synchronous listening. The BEGIN_GET_REQUEST(CALLBACK_FUNCTION) method can perform, for example, an asynchronous listen, which does not block waiting for a request to be received by the listener object upon which the method was invoked. The END_GET_REQUEST( ) method completes, in the callback function identified in the callback function identified in the CALLBACK_FUNCTION parameter, the asynchronous listen initiated by the BEGIN_GET_REQUEST(CALLBACK_FUNCTION) method. Moving such functionality to methods implementing an abstract base class facilitates simplifying server programs and thus mitigates complexity problems associated with conventional systems.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 10","b":"1000"},"The STATUS property may hold, for example, a status code associated with a response to a request from an accessing application (e.g., HTTP 404 error code). The STATUS_DESCRIPTION property may hold, for example, a string describing the response status code (e.g., \u201cpage not found\u201d). The CONTENT_LENGTH property may hold, for example, the length of the data response from the exposed resource. The RESPONSE_URI property may hold, for example, a URI that was associated with the location to which the response to the request from the accessing application should be sent. The value of the RESPONSE_URI property does not have to match the URI of the accessing application, thus facilitating receiving requests from a first accessing application and returning data responsive to the request to a second accessing application. Thus, data stored in the properties can be employed to facilitate exposure of one or more resources to one or more accessing applications via one or more protocols by storing information employed in facilitating such exposure. Storing such information in properties in an answering object that implements the abstract base class facilitates reducing server program complexity by removing such protocol specific information from the server program, thus mitigating complexity problems associated with conventional systems.","The ANSWER method may, for example, return content from an exposed resource to an accessing application. The ANSWER method may employ one or more properties stored in the answering object, thus simplifying server program code. Moving such functionality to methods implementing an abstract base class definition facilitates simplifying server programs and thus mitigates complexity problems associated with conventional systems.","Turning now to , a block diagram compares and contrasts a protocol-centric server program  running on a first server  with a number of lightweight servers , through , N being an integer, running on a second server . A typical protocol-centric server  consumes substantially all of the namespace of the server  on which it runs. Similarly, a typical protocol-centric server  may function optimally if it is the only server program running on the server . Thus, conventional systems may be limited to exposing one resources or one set of resources, all of which interact with the protocol-centric server . Furthermore, the protocol-centric server  may consume substantially all of the computer resources available for network communications on the server . Thus, conventional protocol-centric systems may not be suitable for creating ad hoc peer-to-peer networks.","The lightweight servers , through , N being an integer, running on the second server  may not consume substantially all of the namespace of the server  on which they run. Thus, more than one lightweight server may be able to operate concurrently on the server . Such concurrent operation can facilitate the creation of ad hoc peer-to-peer networks. Furthermore, a lightweight server may not consume substantially all of the computer resources available on the server  for network communications. Thus, additional resources  may be available for network communications facilitating the concurrent operation of other lightweight servers (e.g., through ). Again, such concurrent operation can facilitate the creation of ad hoc peer-to-peer networks. Another advantage of such concurrent operation is the ability to concurrently expose one or more resources to one or more accessing applications via one or more protocols, with different resources interacting with different lightweight servers.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 12","b":["1200","1210","1200","1220","1200","1230","1240","1250","1230","1250"]},"In view of the exemplary systems shown and described above, methodologies, which may be implemented in accordance with the present invention, will be better appreciated with reference to the flow diagram of . While for purposes of simplicity of explanation, the methodology of  is shown and described as a series of blocks representative of acts and\/or events in accordance with the present invention, it is to be understood and appreciated that the present invention is not limited by the order and\/or number of blocks, as some blocks may, in accordance with the present invention, occur in different orders and\/or concurrently with other blocks from that shown and described herein. Moreover, not all illustrated blocks may be required to implement a methodology in accordance with the present invention.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 13","b":["1300","1310","1310","1320","1310","1330","1330","1340","1330","1350","1310","1330","1310"]},"At , the requested exposure can be undertaken, such exposure facilitated by employing the protocol object(s) created at . At  a determination is made concerning whether the requested exposure is complete. If the determination at  is NO, then processing can proceed at . If the determination at  is YES, then at  the protocol object(s) created at  may be released (e.g., deallocated, destructed). At  a determination is made concerning whether there are any more requests to expose resources. If the determination at  is YES, then processing continues at . If the determination at  is NO, then processing concludes.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 14","FIG. 14"],"b":"1410"},"With reference to , an exemplary environment  for implementing various aspects of the invention includes a computer , the computer  including a processing unit , a system memory  and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  may be any of various commercially available processors. Dual microprocessors and other multi-processor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure including a memory bus or memory controller, a peripheral bus and a local bus using any of a variety of commercially available bus architectures. The system memory  includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM .","The computer  further includes a hard disk drive , a magnetic disk drive , (e.g., to read from or write to a removable disk ) and an optical disk drive , (e.g., for reading a CD-ROM disk  or to read from or write to other optical media). The hard disk drive , magnetic disk drive  and optical disk drive  can be connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface  and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the computer , including for the storage of broadcast programming in a suitable digital format. Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as zip drives, magnetic cassettes, flash memory cards, digital video disks, cartridges, and the like, may also be used in the exemplary operating environment, and further that any such media may contain computer-executable instructions for performing the methods of the present invention.","A number of program modules can be stored in the drives and RAM , including an operating system , one or more application programs , other program modules  and program data . It is to be appreciated that the present invention can be implemented with various commercially available operating systems or combinations of operating systems.","A user can enter commands and information into the computer  through a keyboard  and a pointing device, such as a mouse . Other input devices (not shown) may include a microphone, an IR remote control, a joystick, a game pad, a satellite dish, cameras, in the sense of gesture interpreted through cameras and machine-vision software, a scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus , but may be connected by other interfaces, such as a parallel port, a game port, a universal serial bus (\u201cUSB\u201d), an IR interface, etc. A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, a computer typically includes other peripheral output devices (not shown), such as speakers, printers etc.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer(s) . The remote computer(s)  may be a workstation, a server computer, a router, a personal computer, microprocessor based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory storage device  is illustrated. The logical connections depicted include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem , or is connected to a communications server on the LAN, or has other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","What has been described above includes examples of the present invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly, the present invention is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d, as comprising is interpreted as a transitional word in a claim."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
