---
title: System and method for using anonymous tokens for efficient memory management
abstract: A mechanism for managing pointers or handles to transient objects is disclosed. An anonymous token is assigned to an object. When an anonymous token is needed for an object, an unused token value is obtained from a list of available values and is associated with the object, the token value is removed from the list of available values, and data elements of a token data array entry associated with the anonymous token value are updated. When an operation is performed on an object identified by an anonymous token, data elements are evaluated and if reuse counts are not identical or if the validity indicator does not indicate that the object is valid, the operation is not performed. When an object is de-allocated, the token value associated with the object is returned to the available list and the data elements associated with the token value are updated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06874059&OS=06874059&RS=06874059
owner: Unisys Corporation
number: 06874059
owner_city: Blue Bell
owner_country: US
publication_date: 20011114
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS","CONCLUSION"],"p":["This invention relates to the field of computer programming and more particularly to managing objects and pointers, references or handles to objects.","It is often necessary to have pointers, references and\/or handles which locate and identify an object stored in memory. When the object is no longer needed, it would be preferable to be able to make the memory used to store the object available for reuse. In order for the memory to be available for reuse, it is typically necessary to insure that existing pointers, references and\/or handles to the object are de-allocated, invalidated or otherwise modified so that they can no longer be used to access the memory location formerly occupied by the object. Current mechanisms available to address this memory management problem are complex, resource consuming and error-prone. One such mechanism employs a handle as described below.","A handle is a temporary name or number assigned to an object or file. For example, an operating system may assign a (typically sequential) number to each file that the operating system opens, as a way of identifying the file. A typical way to implement a handle to aid in managing objects is illustrated in .  depicts an exemplary computing environment  including a computing device  comprising a central processing unit  and memory . Memory  may be any kind of volatile memory. As shown in , a handle  is associated with an index into a pointer array . Pointer array  comprises a series of entries , ,  . . . n, to which handle  may point. In , handle  points to the fourth entry  in pointer array . The fourth entry  typically contains a pointer to an object, such as object . After object  is de-allocated, the pointer in pointer array  entry  will point to the location in memory formerly occupied by object  or to the location in memory occupied by a new object or to a location in memory not occupied by any object (often location zero), causing obvious problems. To prevent these problems, it is desirable to somehow locate and modify all pointers, including any copies that may exist, that point to the de-allocated object . This process frequently requires a significant expenditure of system resources.","There are other well-known techniques to address the memory management problem. For example, one approach is to structure the programs to prevent copying pointers, references or handles when the objects pointed to may not exist as long as the pointers, references or handles do. Minimal overhead is associated with this option but it is often not possible or not convenient to structure programs this way.","Another known technique is to keep a linked list of the pointers, references or handles and update the linked list whenever an object pointed to by an element of the linked list is de-allocated. A linked list contains at least a pointer to the next item in the list and frequently contains a pointer to the previous item in the list as well. Use of a linked list requires the use of a data structure containing an element for the storage of the pointer to the next item in the list (\u201cnext pointer\u201d) and an element for the storage of the pointer to the previous item in the list (\u201cprevious pointer\u201d), thus a linked list has increased space requirements. Furthermore, all code associated with the linked list must update the linked list properly, including updating the \u201cnext\u201d and (when employed) the \u201cprevious\u201d pointers, whenever additions or deletions to the list occur, creating added programming overhead. If multiple programs update the linked list, the linked list must be locked so that two processes do not update the list at the same time. When the object pointed to is deallocated, all the pointers, references or handles must be searched for, found and updated. Alternatively, the object could remain in memory indefinitely (until reboot) and\/or be marked invalid so that subsequent access of the object is prevented. This technique would not permit the memory used to store the object to be reused and thus would require that the amount of memory available between re-boots would be adequate to store all the objects instantiated between re-boots.","Another known technique would involve keeping track of objects that are no longer in use, but not immediately making the memory location of the object available for re-use. The memory location would remain unavailable until some period of time elapsed or until some trigger condition occurred (such as available memory is running low) at which time a single search could be used to find and invalidate all the pointers, references, or handles to all those objects.","Accordingly, a primary goal of the present invention is to provide a mechanism for referencing objects that imposes minimal or no restrictions on where the references may be stored. A further goal of the present invention is to provide a mechanism that imposes little or no extra overhead when copying the object references, and that enables the object associated with the reference to be de-allocated and its memory immediately made available for reuse, without a need to search for the copies of the references or to modify the copies, and that involves little extra overhead upon object deallocation.","The present invention provides a mechanism which eliminates the need to search for pointers to de-allocated objects. In one embodiment of the present invention an anonymous token includes an anonymous token reuse count and an anonymous token value (handle) assigned to an object to identify and locate the object in memory. It is presently contemplated that the anonymous token will not be reused between system boots, and that the anonymous token value will be used as an index into an array of token data entries. In a presently preferred embodiment of the invention, a token data array entry includes a token data array entry reuse count, a token data array entry lock, a token data array entry validity indicator and a token data array entry reference to an object (object reference). Illustrative uses of an anonymous token in accordance with the present invention are described below, as are other aspects of the present invention.","Overview","As discussed above, the present invention provides an anonymous token for use in managing transient objects. The use of the anonymous token eliminates the need to search for pointers, references or handles to an object remaining in memory after the object directly or indirectly pointed to is deallocated. In a presently preferred implementation, an anonymous token includes an anonymous token \u201creuse count\u201d and an anonymous token \u201cvalue\u201d, which acts as a handle. The value is assigned to an object to identify and locate the object in memory. A data structure such as, but not limited to, an array, may be used to store data elements associated with the object identified by the token. Data elements associated with the object in a presently preferred implementation include a \u201clock,\u201d a \u201creuse count,\u201d an \u201cobject reference,\u201d and a \u201cvalidity indicator.\u201d","When an anonymous token is needed for an object, a token value is obtained from a list of available anonymous token values, and the anonymous token value assigned to the object is removed from the list of available token values. In addition, the object is assigned the anonymous token value. For example, the anonymous token value may be stored in a data element (object anonymous token value) associated with the object by appending the object anonymous token value to the object. Alternately the object may be linked to the object anonymous token value via a database or by other suitable methods. In addition, the data elements of the token data array entry associated with the anonymous token value are updated: the token data array entry validity indicator is set to indicate validity, the token data array entry reuse count is incremented by one, and the token data array entry object reference is set to the location of the object in memory. In addition, the anonymous token reuse count is set to the token data array entry reuse count.","By way of further explanation of how an anonymous token may be employed, consider what happens when an operation is performed on an object identified by an anonymous token. In an exemplary implementation of the present invention, the anonymous token reuse count is compared to the token data array entry reuse count of the data array entry associated with the anonymous token value of the object. The operation will not be performed if the reuse counts are not identical or if the token data array entry validity indicator of the data array entry associated with the object does not indicate validity. Moreover, when an object associated with an anonymous token is de-allocated, the token data array entry validity indicator is set to indicate invalidity, the token data array entry object reference is set to zero or to some value indicating that no object is associated with the token data array entry, thus orphaning the anonymous token. Any subsequent attempt to access an object via an orphaned anonymous token will be rejected because the anonymous token reuse count will not match the token data array entry reuse count and\/or the token data array entry validity indicator will indicate invalidity. The anonymous token value is returned to the available list, unless the token data array entry reuse count has exceeded some specified maximum value.","Preferably, whenever a token data array entry is used or modified, the entry is locked to prevent another process from modifying the entry concurrently. The entry is unlocked after the entry is used or modified.","Thus, when an object is de-allocated, it is not necessary to search for, locate and modify all the copies of the handles. As soon as an object is deallocated, the anonymous token reuse count and the token data array entry reuse count associated with the object will no longer agree and\/or the token data array entry validity indicator will indicate invalidity and the de-allocated object will not be accessible by the anonymous token. When a reuse count has reached some configurable maximum the anonymous token value is retired by removing the anonymous token value from the available token list.","We will now explain in greater detail the presently preferred structure and use of anonymous tokens in accordance with the present invention.","Anonymous Tokens","A mechanism is disclosed that overcomes the drawbacks of the prior art. In one embodiment of the invention, an anonymous token is created that includes a value used as a handle to an object. The anonymous token also includes a reuse count that is used to determine if the location in memory pointed to, is still occupied by the object associated with the handle. The anonymous token value is also associated with an entry in a token data array. The token data array may include a number of entries, up to some configured maximum number. Each entry in the token data array includes a number of data elements, preferably including a lock element, a reuse count element, an object reference and a validity indicator. The object reference of the token data array entry contains a pointer or reference to the object identified by the anonymous token value. A data element associated with the object contains the anonymous token value associated with the object.","In one embodiment the anonymous token is comprised of 48-bits, wherein none of the 48-bit values will be reused until the system is rebooted. Up to 2anonymous token values can be valid at any one point in time. When an object associated with an anonymous token is de-allocated, the token data array entry data for the token associated with the object will be invalidated, orphaning the 48-bit anonymous token. Thereafter, any attempt to access a de-allocated object via an orphaned anonymous token will be rejected without ever having to search for the tokens. Locking insures that only one process at a time updates the central data for the token.",{"@attributes":{"id":"P-00028","num":"00028"},"figref":["FIG. 3","FIG. 3"],"b":["202","204","206","204","210","204","202","3","214","210","210","211","212","213","214","215","210"],"sup":"20"},"In one embodiment token data array  contains an \u201centry \u201d  associated with token data value=zero, an \u201centry \u201d  associated with token data value=one and so on up to maximum entry number m. Each entry ,  . . . m of token data array  contains a data array lock (e.g., lock  for entry ), a token data array reuse count (e.g., reuse count  for entry ), a token data object reference (e.g., object reference  for entry ) and a token data validity indicator (e.g., validity indicator  for entry ). Token data object reference  may point to object . Object  may be associated with data element object token data value .","Anonymous token , token data array  and object  may be stored anywhere in the volatile memory  of a computer system  (FIG. ). Preferably the anonymous tokens generated by the anonymous token algorithms cannot be changed by software other than the anonymous token software. Preferably anonymous tokens cannot be forged by software other than the anonymous token software. Preferably use of the anonymous tokens application programming interfaces (APIs) are limited to trusted software. Alternately, use of the anonymous token API could be limited by employing well known hardware (e.g., memory tag) or software (e.g., compiler enforcement) data protection techniques to protect the anonymous tokens.","When an anonymous token (e.g., anonymous token ) is valid, that is, the anonymous token (e.g., anonymous token ) is associated with an object (e.g., object ), the reuse count field of the anonymous token will match the reuse count field of the corresponding token data array entry. It is unnecessary to overwrite or change an obsolete anonymous token, because the reuse count mechanism catches and rejects any attempt to use an obsolete anonymous token.","Hence a mechanism for managing objects in accordance with one embodiment of the present invention may comprise the following steps: 1.) assigning a anonymous token value to an allocated object 2.) updating data elements associated with the anonymous token value 3.) before allowing the object associated with the anonymous token to be accessed via the anonymous token, requiring that the anonymous token reuse count and the token data array reuse count match and 4.) when an object is de-allocated, modifying the token data array validity indicator of the entry associated with the de-allocated object, modifying the token data array object reference of the entry associated with the de-allocated object and returning the anonymous token value associated with the de-allocated object to the available list. Preferably, before the anonymous token value is returned to the available list, the token data array reuse count is checked to see if it has exceeded a configurable maximum value. If the reuse count has exceed the maximum allowable value, the anonymous token value is not returned to the available list.","Assigning an Anonymous Token to an Allocated Object","Generally, an object capable of being identified by an anonymous token may also have other means of identification. In one embodiment of the invention, an anonymous token mechanism adds anonymous token identification to an object which is already allocated and which already may have another means of identification. In the pseudo code of , the object reference passed to a procedure such as exemplary procedure GET_TOKEN of  is intended to represent such a means of identifying the object.","Preferably, entry  of token data array  is not used to contain token data for an object such as object . An object  capable of being identified by an anonymous token  preferably is associated with an object token data value  which may be used to store a value that is used as an index into token data array . When an object such as object  is allocated, (before it is associated with an anonymous token ), object token data value  is preferably set to zero, indicating that object  has not yet been assigned an anonymous token .",{"@attributes":{"id":"P-00036","num":"00036"},"figref":"FIG. 4","b":["230","401","210"]},"A list  () of available anonymous token values ,  . . . m, where m is some maximum number of tokens, is maintained. A procedure such as TOKEN_GETTOKEN determines a free entry in the token data array by accessing the available token values list .","Every time an anonymous token is used to identify and locate an object, the reuse count of the token data array entry associated with the object is incremented. That token data array entry reuse count is then copied to the reuse count of the anonymous token associated with the object. When the token data array reuse count reaches some configurable maximum number, the token data array entry is retired. For example, if the maximum value for reuse count is 10, and the value of entry  reuse count  has reached 10, when the object  associated with entry  is de-allocated, anonymous token  token data value=3 is not returned to a list of available token values .","Furthermore, if the number of entries in the available token values list  is reduced to zero, an error condition will occur. Therefore the maximum anonymous token value m preferably should be at least large enough to allow simultaneous allocation of as many objects (and thus anonymous token values) as will ever be in simultaneous use during the time between boots. Preferably the maximum value of the reuse count field is large enough so that only a small number of entries ,  . . . m in token data array  will be retired during the time period bounded by two re-boots, assuming the highest reasonable rate of anonymous token allocation and the longest reasonable time period bounded by two re-boots.","Assume that procedure TOKEN_GETTOKEN called in step  returns a value of \u201c3\u201d.","At step , the value returned (3) is compared to zero. If the value returned is zero, token data array  is full and the procedure returns a value representing that a resource limit has been reached.","If the value of the cell returned is not zero, at step , the specified entry in token data array  is locked (e.g., entry  in token data array  is locked).","At step  the value contained in object 's anonymous token value  is examined. If the value in object anonymous token value  is not zero, then object  has already been assigned an anonymous token. At step  the value in object anonymous token value  is determined. Assume the value associated with object  anonymous token value  is 2. If this is the case, at step  entry  in token data array  is unlocked. At step  entry  associated with anonymous token value  in token data array  is locked. If validity indicator (not shown) of token data array entry  indicates that entry  is valid, and the token data array entry  object reference (not shown) is the same as the object reference passed to the procedure for object , then an anonymous token with anonymous token value=2 is constructed, entry  is unlocked and entry  is returned to the available token values list  at step .","If, however, token data array  entry  validity indicator indicates that the entry is not valid, or the token data entry  object reference is not the same as the object reference to object  passed to the procedure, object  is no longer allocated and a \u201cbad object\u201d error is returned at step  and processing continues at step . At step  the token data array  entry  is unlocked and entry  is returned to the available token values list .","Assume now that the value of object  anonymous token value  is zero. If, at step , the value of object  anonymous token value  equals zero, object  has not been associated with an anonymous token. At step  token data array  entry  reuse count  is incremented by one and token data array  entry  object reference  is set to the object reference provided to the procedure, and token data array  entry  validity indicator  is set to indicate validity. An anonymous token  reuse count  is set to token data array  entry  reuse count  and anonymous token  token data value  is set to \u201c3\u201d. Object  anonymous token value  is set to 3. A variable that is used to indicate whether or not a token has been successfully associated with an object is set to indicate success. At step  token data array  entry  is unlocked. At step , the anonymous token constructed in step  is returned.","Performing an Operation on an Object Associated with an Anonymous Token",{"@attributes":{"id":"P-00047","num":"00047"},"figref":"FIG. 5","b":["230","230","202"]},"At step , the anonymous token  anonymous token value  is validated to see if anonymous token value  falls with a specified range of values. If it does not, the token is invalid. If anonymous token  is valid, at step  the token data array entry represented by anonymous token value  is locked. For example, assume that the value of anonymous token value  is 3, representing entry . In that case, token data array  entry  containing data elements lock , reuse count , object reference  and validity indicator  are locked at step . If validity indicator  does not indicate a valid entry or the reuse count  of entry  is not identical to anonymous token  reuse count , then token  is not valid and the operation is not performed. If validity indicator  is true and the reuse count  of entry  is identical to anonymous token  reuse count , token  is valid and the operation is performed at step . At step  the token data array  entry  is unlocked.","De-allocating an Object Identified by an Anonymous Token",{"@attributes":{"id":"P-00050","num":"00050"},"figref":["FIG. 6","FIG. 6"],"b":["230","202"]},"At step , the value in object  token data value  is retrieved, using the reference to object  passed to the procedure. Assume that object  token data value  is 3. At step  token data array  entry  is locked. At step , if token data array  entry  validity indicator  indicates validity and token data array  entry  object reference  is identical to the object reference passed to the procedure, token data array  entry  validity indicator  is set to indicate invalidity and token data array  entry  object reference  is set to 0. At step  entry  is unlocked. At step  the token return procedure is called. At step  the status of the return token operation is returned.","Managing a List of Available Token Values",{"@attributes":{"id":"P-00053","num":"00053"},"figref":"FIG. 7","b":["700","701","260","700","210","440","260","441","260","210","210","210","210","260"]},"At step  if the list of available token values  contains entries, the next available free value is returned. At step  available token values list  is unlocked.","Procedure  of  illustrates a method in accordance with the invention for returning a value to the available token values list . An entry value 1, 2, 3 . . . m is retired by not linking the value to the available token values list . A anonymous token value is retired when the corresponding tokens data array entry reuse count reaches some maximum value, which in one embodiment is the limit imposed by the finite size of the containers in which reuse count is stored.","Assume that object  () associated with token data value= has been de-allocated. At step  if token data array  entry  reuse count  is less than the designated maximum value mv, token data value \u201c3\u201d is linked to the available token values list . If token data array  entry  reuse count  in not less than the designated maximum value mv, token data value \u201c3\u201d is not linked to the available token values list  and entry  will not be used again to identify and locate an allocated object until reboot time, at which time reuse count  will be reset to zero.","Locking","In one embodiment of the present invention, the type of locking used is simple mutual exclusion locking, implemented by the operating system. When a thread or program locks a lock which is not already locked, the lock is marked as owned and the thread or program is permitted to proceed. When a thread or program locks a lock which is already locked, the operating system blocks its execution until the owning thread or program unlocks the lock and the blocked thread or program is granted ownership. Such a lock is often called a MUTEX. Other locking mechanisms are contemplated by the invention.","The programming necessary to effectuate the processes performed in connection with the present invention is relatively straight-forward and should be apparent to the relevant programming public. Any particular programming language or methodogies may be employed to effectuate the present invention without departing from the spirit and scope thereof.","In the foregoing description, it can be seen that the present invention comprises a new and useful mechanism for managing objects. It should be appreciated that changes could be made to the embodiments described above without departing from the inventive concepts thereof. It should be understood, therefore, that this invention is not limited to the particular embodiments disclosed, but it is intended to cover modifications within the spirit and scope of the present invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"P-00011","num":"00011"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00012","num":"00012"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00013","num":"00013"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00014","num":"00014"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00015","num":"00015"},"figref":"FIG. 5"},{"@attributes":{"id":"P-00016","num":"00016"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00017","num":"00017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
