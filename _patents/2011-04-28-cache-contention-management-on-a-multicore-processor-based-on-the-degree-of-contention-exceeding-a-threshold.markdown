---
title: Cache contention management on a multicore processor based on the degree of contention exceeding a threshold
abstract: A first indicator of a first number of cache misses to a cache memory of a multicore processor for a first application over a first time period is received. The first application executes on a first core of the processor and a second application simultaneously executes on a second core of the processor during the first time period. The first and second cores share the cache memory. A second indicator of a second number of cache misses to the cache memory for the first application over a second time period is received. During the second time period, the first application executes on the first core and the second application does not execute on the second core. A degree of contention among the first and second applications is determined based on the first and second indicators, and execution of the second application is adjusted based on the determined degree of contention.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268542&OS=09268542&RS=09268542
owner: Google Inc.
number: 09268542
owner_city: Mountain View
owner_country: US
publication_date: 20110428
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This document relates to optimizing the performance of a multicore processor.","Multicore processor architectures are widely used in modern computing systems. These architectures dominate in many domains, including those with quality of service (QoS) and low latency requirements. A multicore processor architecture includes two or more processing cores, on which two or more software applications may execute in parallel. When two or more applications are executing in parallel on separate cores of a single multicore processor, the applications are said to be co-located on the processor.","The processing cores of the multicore processor often use both private resources and shared resources to perform tasks associated with the executing applications. Private resources are generally replicated across each of the processing cores, for exclusive use by a corresponding individual processing core. Shared resources, by contrast, may generally be used by any of the processing cores of the multicore processor. When two or more applications that are simultaneously executing on separate cores each attempt to use a shared resource, contention for the shared resource can result. Often, contention for shared resources can result in reduced performance, or cross-core application interference, for one or both of the applications competing for the shared resource.","This document describes systems and techniques that may be used for detecting and responding to contention among two or more applications vying for shared resources in a multicore processor environment.","In a first general aspect, a computer-implemented method for contention handling includes receiving a first indicator of a first number of cache misses to a cache memory of a multicore processor for a first software application over a first time period. The first software application executes on a first core of the multicore processor and a second software application simultaneously executes on a second core of the multicore processor during the first time period. The first core and the second core share the cache memory of the multicore processor. The method also includes receiving a second indicator of a second number of cache misses to the cache memory of the multicore processor for the first software application over a second time period. The first software application executes on the first core during the second time period and the second software application does not execute on the second core during the second time period. The method further includes determining a degree of contention among the first software application and the second software application based on the first indicator and the second indicator, and adjusting execution of the second software application based on the determined degree of contention.","In various implementations, the adjusting execution of the second software application based on the determined degree of contention may include: (i) halting execution of the second software application on the second core for a first response period of time if the determined degree of contention exceeds a determined contention threshold, or (ii) enabling execution of the second software application on the second core for a second response period of time if the degree of contention does not exceed the determined contention threshold. The method may further include halting execution of the second software application on the second core for a time period longer than the first response period of time when successively measured degrees of contention between the first software application and the second software application exceed the determined contention threshold. Each of the first core and the second core may include a private cache memory, and the cache memory of the multicore processor that is shared by the first core and the second core may include a last level cache for the first core and the second core. Receiving the first indicator may include reading from a memory location that is accessible by the first core and the second core, and receiving the second indicator may include reading a performance counter that is associated with the second core. The first time period and the second time period may occur during a single execution of the first software application. The degree of contention may be determined during the single execution of the first software application. The first software application may be more sensitive to latency than is the second software application. The method may also include detecting contention among the first software application and the second software application for another shared resource of the multicore processor and adjusting execution of the second software application based on the detected contention for the another shared resource of the multicore processor.","In a second general aspect, a computer-implemented method for managing contention to separate cores of a multicore processor includes receiving a first indicator of a number of cache misses to a cache memory of a multicore processor for a first software application over a first time period. The first software application executes on a first core of the multicore processor and a second software application executes on a second core of the multicore processor during the first time period, and the first core and the second core share the cache memory of the multicore processor. The method also includes receiving a second indicator of a number of cache misses to the cache memory of the multicore processor for the second software application over the first time period. The method further includes determining a degree of contention between the first software application and the second software application based on the first indicator and the second indicator, and based on the determined degree of contention: (i) preventing the second software application from accessing the cache memory shared by the first core and the second core if the degree of contention exceeds a determined contention threshold, or (ii) permitting the second software application to access the cache memory shared by the first core and the second core if the degree of contention does not exceed the determined contention threshold.","In various implementations, receiving the first indicator may include reading from a memory location accessible by the first core and the second core, and receiving the second indicator may include reading a performance counter associated with the second core. The first time period may occur during a first execution of the first software application, and the degree of contention may also be determined during the first execution of the first software application.","In a third general aspect, a computer-implemented method for managing contention between applications concurrently executing on separate cores of a multicore processor includes determining a degree of contention between a first application executing on a first core of a multicore processor and a second application simultaneously executing on a second core of the multicore processor, wherein the first core and the second core share a cache memory of the multicore processor. The method also includes, based on the determined degree of contention: (i) halting execution of the second software application on the second core for a first response period of time if the determined degree of contention exceeds a determined contention threshold, or (ii) enabling execution of the second software application on the second core for a second response period of time if the determined degree of contention does not exceed the determined contention threshold.","In a fourth general aspect, a system includes a processor that includes: a first processing core and a second processing core, the first processing core and the second processing each being configured to execute instructions of software applications, a cache memory that is accessible by the first processing core and by the second processing core, and a first counter configured to count a number of misses to the cache memory by a software application executing on the first processing core, and a second counter configured to count a number of misses to the cache memory by a software application executing on the second processing core. The system also includes computer storage storing instructions for implementing a runtime engine configured to: determine a degree of contention for the cache memory between a first application executing on the first processing core and a second application simultaneously executing on the second processing core by comparing a first number of cache misses provided by the first counter with a second number of cache misses provided by the second counter, and halt execution of the second application on the second processing core for a first determined period of time if the degree of contention exceeds a determined contention threshold, and enable execution of the second application on the second processing core for a second determined period of time if the degree of contention does not exceed the determined contention threshold.","In various implementations, the runtime engine includes a first component runtime engine and a second component runtime engine, where the first component runtime engine may be associated with the first application and the second component runtime engine may be associated with the second application. The runtime engine may execute periodically in response to an interrupt. The first application may be more sensitive to latency than is the second application. The runtime engine may be further configured to halt execution of the second application on the second core for a time period longer than the first response period of time when successively measured degrees of contention between the first application and the second application exceed the determined contention threshold. Each of the first processing core and the second processing core may include a private cache memory, and the cache memory that is accessible by the first processing core and the second processing core may include a last level cache for the first processing core and the second processing core.","The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings, and from the claims.","Like reference numbers and designations in the various drawings indicate like elements.","Cross-core application interference due to contention for shared on-chip and off-chip resources can pose a significant challenge to providing application level quality of service (QoS) guarantees on commodity multicore processor micro-architectures. Cross-core interference can be especially problematic for software applications that are latency-sensitive, such as applications that are expected to respond to an input or query within a short period of time, such as a few milliseconds or tens of milliseconds, for example, and where an undue delay in response may displease a user. Examples of latency-sensitive applications may include web search, image search, e-mail applications, mapping applications, or other user-facing applications commonly found in web service data center application domains.","In contrast to latency-sensitive applications, so-called \u201cbatch\u201d software applications may not generally include low-latency execution requirements, and may instead tend to be throughput-oriented. Examples of batch applications may include various compression applications, encoding applications, backup applications, or other applications that are not actively responsive to user service requests. Batch applications may nevertheless contend for shared resources with co-located applications executing in parallel on a multicore processor under various circumstances.","Modern multicore processors can include one or more private (unshared) cache memories for each core of the multicore processor, and a larger shared cache memory that may generally be used by any of the cores of the processor (or by applications, threads, or processes executing on the cores). One example multicore processor includes two cores, where each core includes a private L1 memory cache for exclusive use by the respective core. The processor also includes a larger (4 Mb in this example) L2 memory cache that is shared by the two cores, where either core may generally access the shared cache at any time under conventional operation. One or both cores may use the shared cache, for example, when a working set for an application executing on the core is too large to fit within the core's private L1 cache. Another example multicore processor architecture includes four cores, each having private L1 and L2 caches for dedicated use by the respective core, and a single shared L3 cache (8 Mb in this example) that may be used by any of the four cores. Multicore processors having 8 cores or 12 cores are also commercially available.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","102","104","106","108","104","106","104","106","104","106","104","106"]},"The environment  shows that a first application  and a second application  are co-located on the multicore processor, with the first application  executing on the first core  and the second application  executing on the second core . In an implementation, the first application  may be more latency sensitive than the second application . For example, the first application  may be a latency-sensitive application, such as web search, and the second application  may be a non-latency-sensitive batch application, such as a compression application. First application  or second application  may alternatively be threads or processes of an application or applications, in various implementations.","In various implementations, the runtime engine  provides a run-time solution that detects contention or cross-core interference as it is actually happening between co-located applications, such as the first application  and the second application , and adjusts execution of a less-latency-sensitive application, if appropriate. In this manner, contention on a commodity multicore processor may be detected as it occurs using a software solution, and steps to minimize contention may be taken in response to detection of contention. Because the runtime engine  detects contention online\u2014that is, as the contention is occurring\u2014between co-located applications, the runtime engine  may be better able to avoid false positive contention predictions that can be common with conventional systems that attempt to merely predict when contention will occur based on historical characteristics of applications. Additionally, the runtime engine may provide a dynamic solution that detects contention between co-located, executing applications rather than a static analysis that merely attempts to predict future contention based on historical behavioral data or profiling data. As will be discussed further below, runtime engine  may include component runtime engines, and the determination that contention is occurring, as well as any response to the contention, may in various implementations be performed by a single component runtime engine of runtime engine , by two or more of the component runtime engines, by a subset of the component runtime engines, or by all of the component runtime engines.","Referring again to , runtime engine  includes a first runtime engine and a second runtime engine . The first runtime engine is shown running on the first core , and the second runtime engine is shown running on the second core , in this example. The runtime engines , , or \u201cruntimes,\u201d may comprise code that runs on, or is executed by, a respective core, in addition to the previously described applications  and . In some examples, one or more of the runtime engines , may be a process. In some examples, one or more of the runtime engines , may be a system daemon. In some examples, one or more of the runtime engines , may be linked as a shared library file. The number of runtimes in execution environment  is not limited to what is shown in . For processor architectures having a different number of processing cores than what is shown in , the runtime engine  may include a corresponding number of component runtime engines , , . . . , each of which may run on a particular core of the multicore processor. The runtime engines may provide a dedicated software solution to shared resource contention and may provide reaction thereto. The runtime engines may be used with off-the-shelf commodity multicore processors to minimize contention and maximize core utilization, according to some implementations.","In various implementations, one or more of the runtime engines , may be interrupt driven. In one example, all of the runtime engines are interrupt driven. For example, code associated with the runtime engines and may respectively execute following receipt of an interrupt by the corresponding core. The interrupt may occur periodically, such as about once per millisecond in one example. In other examples, the interrupt frequency may be any appropriate value, such as about every 500 microseconds, 800 microseconds, 1.2 milliseconds, 1.5 milliseconds, 2 milliseconds, or the like. The interrupts to the respective cores ,  may be synchronized in some implementations. Upon occurrence of an interrupt at a processing core, the core may temporarily halt execution of the application (e.g., application  or application ) loaded on the core, execute the runtime engine code, and then resume execution of the application. In various examples, the runtime engine may use an empirical method to detect when two or more applications are contending for shared resources (e.g., a last level cache), and may stagger, pause, or shutter execution of a less important application to permit a more important application to execute with less contention.","As will be described below, the runtime engine  provides a low-overhead run-time solution that minimizes cross-core interference due to contention for shared resources, while maximizing utilization of the processor cores. In various implementations, the runtime engine  (e.g., engine ) detects actual contention between co-located applications, threads, or processes, and responds to detected contention by throttling back execution of a less-latency-sensitive application (e.g., application ) so that a more-latency-sensitive application (e.g., application ) may prospectively see less contention. With reference to , the runtime engine  (e.g., engine ) may thereafter periodically check for contention among the applications  and , and may adjust execution of application  accordingly. For example, if the runtime engine  (e.g., engine ) continues to detect contention, the runtime engine may more aggressively scale back execution of application  in a continuing effort to reduce contention. If the runtime engine  (e.g., engine ) determines that contention has abated, the runtime engine  may allow application  to resume execution.","The runtime engine  may be described as a Contention Aware Execution Runtime (CAER) engine that provides a computationally light-weight runtime solution. In the example shown in , the engine  includes an instance of a first runtime engine , labeled \u201cCAER M,\u201d and an instance of a second runtime engine , labeled \u201cCAER.\u201d The CAER M engine may be a monitoring engine, and is associated with the first core , on which the first (latency-sensitive) application  is executing in this example. The CAER engine may be a contention-detection-and-reaction engine, and is associated with the second core , on which the second (non-latency-sensitive) application  is executing. The runtime engines , may represent virtual layers beneath the application threads running on the particular cores of the multicore processor. In various implementations, the virtual layers may be cooperative and share information. The virtual layers may additionally respond or adapt to each other, according to some implementations. The functions of the CAER M engine and the CAER engine will be discussed in greater detail below.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["200","102","202","204","206","208","210","202","204","206","208","200","212","214","202","204","216","218","206","208","202","204","206","208"]},"Monitoring runtime engines (CAER M) are shown associated with the cores ,  on which the latency-sensitive applications  and  are located, and contention-detection-and-response runtime engines are shown associated with the cores ,  on which the non-latency-sensitive batch applications  and  are located.","In some implementations, the code for the runtime engines (e.g., the runtime engines and of  and ) may initially be stored in a non-volatile storage location (e.g., a disk) of the system in which the multicore processor operates. The code for the runtime engines may be stored in a shared library file, for example, and may be linked in as a shared library so that it may be executed by an individual core (e.g., a CPU on the core). In some examples, the runtime engines (i.e., runtimes)  may be statically linked into the binary.","Referring again to  and as described above, the first application  and the second application  are co-located on the multicore processor. Co-located applications, processes, or threads may place varying amounts of demand on shared resources, such as the shared memory cache , or other shared resources (not shown) such as the bus, front-side bus (if applicable), memory controller, main memory, disk, other I\/O devices, network interface card, or network, among others. This demand can often lead to contention for these resources, and such contention can directly impact application performance.","When a working set of an application process or thread executing on an individual core fits neatly into the private cache of the core, so that the working set does not spill over into the shared cache , there may be no cross-core interference (assuming coherence traffic is at a minimum, for example). However, when the size of an application's working set exceeds the size of the private cache, the working set can spill over into the shared cache . In some implementations, the shared (e.g., last-level) cache  presents the first level of possible contention. For example, when more than one application is using the shared cache , and the data is not shared, contention can occur. This contention can be especially problematic if one application (e.g., application ) causes data from another application (e.g., application ) to be flushed from the shared cache , so that such data is not readily available in the shared cache  when application  needs it. Contention can also exist later in the memory subsystem, such as contention on the bus, in the memory controller, for higher-level shared memory, disk, at a network interface card, on a network, and the like. However, much of the contention in these levels is manifested as off-chip traffic, and thus may be reflected as last-level-cache misses on the chip. The runtime engine  may monitor activity in the shared cache (which may be the last level of cache) to detect contention.","In various implementations, the techniques described herein may also be used in detecting contention on these other types of shared resources, and when contention is detected execution of a software application may be adjusted.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["300","302","304","306","308","310","312"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4","i":"a ","b":["400","402"]},"The horizontal axis represents time for each of graphs  and , and the graphs ,  share a common time axis scale. The vertical axis of graph  represents last level cache misses, and the vertical axis of graph  represents a number of instructions retired. As can be seen when viewing graphs  and  together, during periods where cache misses are at high levels, such as the period indicated by arrow A, the corresponding number of instructions retired is relatively low (see arrow B). Similarly, when the number of cache misses is low or zero, such as the period indicated by arrow C, the corresponding number of instructions retired is relatively high (see arrow D).",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 4","FIG. 4"],"i":["b ","a"],"b":["420","422","400","402","420","422"]},"Modern multicore processors can include, within or associated with each processing core of the multicore processor, various hardware-performance monitors that can provide real-time micro-architectural information relating to the application currently running on the core. In some implementations, these monitors are counters that increment in response to occurrences of particular actions or inactions. Cache misses are one example of an occurrence that can be tracked by performance counters of modern processors. These monitors or counters generally do not impede execution of the application program.","Referring again to , a shared table  is shown residing in shared memory .  similarly shows a shared table  residing in shared memory . In various implementations, the shared table  or  resides in shared virtual memory, and may be accessed by any of the cores. The discussion that follows will be presented with reference to  for simplicity, but a similar discussion may also apply to the environment  of . The shared table may permit cooperation between the runtime engines , . In various implementations, runtime engine may read one or more performance counters or monitors associated with the first core , and may copy the value or an associated value to the shared table . In some implementations, the runtime engine may use a software application programming interface (API), such as the Performance API (PAPI) or the Perfmon API, to read one or more performance monitors or counters.","As can be seen in , the CAER M runtime engine (or virtual layer) is thinner than the CAER runtime engine (or virtual layer) , which may indicate that the CAER M runtime engine is streamlined as compared to the CAER runtime engine (i.e., lighter weight). In some examples, the CAER M engine collects performance data for the application  or core , such as data indicative of last level cache misses, and places the data in the shared table . In some examples, runtime engine writes a value indicative of a number of cache misses experienced by application  running on the first core  over a predetermined period of time to the shared table . The number of cache misses may represent a number of last level cache misses, for example (such as misses to cache , e.g.).","The CAER runtime engine (or virtual layer) that lies beneath the throughput-oriented batch application  may read the information from the shared table . Engine may also optionally read or receive performance information concerning application  or the second core , and may optionally write the information to the shared table . In some examples, engine processes the information to perform contention detection and response heuristics. If the CAER runtime engine detects contention between application  and application , it may apply dynamic adaption or modification to the batch application . In various implementations, only execution of the less-latency-sensitive application (e.g., application  in this example) may be staggered or paused in response to contention, and the more-latency-sensitive application (application  here) may be allowed to execute without modification.","The runtime engine  may employ a periodic probing approach to gather and analyze data. The approach may be interrupt-driven, and performance counters may be read and restarted following each interrupt. In one implementation, each runtime engine probes the relevant performance monitoring units and reports last level cache information to the communication table  or . The table is thus used to record a window of sample points, so that trends of several samples may be observed. With reference to , each of the runtime engines , may write performance values to the shared table .","The main CAER engines that lie under the batch processes detect and react to contention. In some implementations, the main CAER engines cause a coordinated reaction among the batch processes\/threads. In some implementations, reaction directives may also be recorded in the table  or , and runtime engines may force all batch processes to adhere to the reaction directives. Reaction directives can include pausing and staggering execution, for example.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 5","FIG. 5"],"b":["450","102","452","454","452","456","454","458","460","102","456","458","460","102","102","458","460","458","102","456","460","102","456"],"i":["b","b ","b ","b ","b ","b "]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6","b":["500","502","504","102","114","102","114","102","114","102","114"],"i":["a ","b ","a ","b "]},"Execution of the second application may be restarted (), and cache miss information may be collected for the first application (). The cache miss information may correspond to last-level-cache miss information, and this information may be indicative of how the first application performs when the second application is executing. For example, if the first application and the second application both use the shared cache, the first application may compete with the second application for use of the shared cache, which may result in cross-core application interference. If this occurs, cache miss rates for the first application may be higher during periods when the second application is executing. In some implementations, samples of the cache miss information for the first application are collected over a number of periods, and an average of the samples is computed. In some implementations, a runtime engine may read a cache miss performance counter and write the corresponding value to the shared table , and the runtime engine may read the value from the shared table . In some implementations, the runtime engine may write several values to the shared table , and the runtime engine may read the values from the shared table .","If the number of first-application cache misses corresponding to the period where the second application is executing is significantly higher than the number of first-application cache misses corresponding to the period where the second application is halted (), contention may be asserted (). Otherwise, a lack of contention is asserted (), which may occur when the number of first-application cache misses is not higher or is only marginally higher when the second application is executing as compared to when the second application is halted. In some implementations, runtime engine may compare the corresponding values and make the contention determination.","This contention detection heuristic may be referred to as a shutter-burst approach, because cache misses for the first application are separately observed during periods when a co-located application is halted or shuttered, and when the co-located application is executed (or executed in a burst mode). A runtime engine (e.g., runtime engine ) may determine whether two co-located applications are contending by comparing performance of a latency-sensitive application during periods of inactivity and burst activity of a co-located application. The method may be executed, for example, while the runtime engine is operating in the detect contention state  (), for example. For a batch application that is contentious with a co-located latency-sensitive application, the runtime engine may see a spike in last-level cache misses of the latency-sensitive application during periods where the batch application has a burst of execution, as compared to periods where the batch application is paused or halted.","A number of parameters of the shutter-burst contention detection approach may be adjusted or tuned. In various examples, the parameters may be tuned to meet QoS requirements of the application. In some implementations, the runtime engine may dynamically adjust parameters based on behavior or performance of the applications under test. This may permit the runtime engine to dynamically adapt. For example, the number of periods or length of time that the batch application is halted may be adjusted. Also, the number of periods or length of time that the batch application is executed during the burst portion of the approach may be adjusted. Additionally, the runtime engine may adjust or vary the threshold difference (or impact threshold) that it uses to determine whether contention is occurring (e.g., the number of additional cache misses seen during execution of the second application as compared to the number of misses seen while the second application is halted). For example, the impact threshold determines how much cross-core interference the latency application is willing to withstand, and may be adjusted to provide a \u201cknob\u201d that can be intuitively used to set the amount of impact needed to trigger an assertion of contention. In some examples, threshold differences may be percentage differences, such as 3%, 5%, 7%, 10%, 20%, 30%, 40%, or the like. In some cases, threshold differences may be a difference in cache miss counts for a particular monitoring period.","With reference again to , the runtime engine may transition to a Modify Execution of (batch) Application state  when contention is detected. In some implementations, the runtime engine may halt execution of the batch application for a fixed number of periods or a fixed period of time (e.g., 5 ms, 10 ms, 15 ms, 20 ms, or any appropriate period of time) when contention is detected (that is, while in state ). In some implementations, the runtime engine may halt execution of the batch application for an adaptive number of periods when contention is detected (that is, while in state ). For example, when contention is observed in successive periods, or if contention is consistently being detected, the runtime engine may halt execution of the batch application for a longer period of time (e.g., for a longer number of periods or a longer period of time). For example, if a previous response halted execution of the batch application for a certain period of time (e.g., 10 ms), and contention persists, the batch application may thereafter be halted for twice as long (e.g., 20 ms). As described above, when a lack of contention is detected, the runtime engine may permit the batch application to execute without limitation (e.g., while in state ).","The forgoing response approach may be referred to as a red-light, green-light approach. When contention among co-located applications is detected, a red light is applied to the less-latency-sensitive application, and when a lack of contention among the applications is detected, a green light is applied to the less-latency-sensitive application.","The runtime engine may cause execution of a software application to be adjusted in various ways. For example, in some implementations, the runtime engine may ask an operating system to prevent the software application from executing for a period of time or to command the software application to halt for a period of time. In examples where the runtime engine is linked to the application, the application may request to enter a sleep mode for a period of time based on the runtime engine's determination of contention, according to various implementations.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 7","b":["600","602","604"]},"In some implementations, a runtime engine may read a cache miss performance counter for the first application and write the corresponding value to the shared table , and the runtime engine may read a cache miss performance counter for the second application, and may optionally write the corresponding value to the shared table . In some implementations, the runtime engines may write several values to the shared table .","If the number of cache misses for the first application is above a first threshold value, and if the number of cache misses for the second application is above a second threshold value (), contention may be asserted (). This may occur, for example, when both applications making heavy usage of the shared cache and evicting each other's data from the cache. One example of a threshold value may be 1500 for a monitoring period of 1 ms, for example, but this value may be varied as appropriate. In some examples, the same threshold value may be used in monitoring each application, while in other implementations different threshold values may be used. If either of the cache miss values does not exceed the corresponding threshold, a lack of contention may be asserted (). For example, if the latency-sensitive application is not heavily incurring cache misses, it is probably not suffering from cache contention, and similarly if the batch application is not heavily incurring cache misses, it is probably not using or at least not contending in the cache very much.","In some examples, running averages of last-level cache-miss windows for both the latency-sensitive application and the batch application are maintained. When the average for either application rises above a particular threshold, where the threshold may be a common threshold for both applications or separate thresholds, contention may be asserted. One example of a threshold may be 1500 misses over a 1 ms period, for example. By contrast, when the average for either application dips below the corresponding threshold, a lack of contention may be asserted.","The  contention detection heuristic may be referred to as a rule-based approach. A runtime engine (e.g., runtime engine ) may perform the rule-based contention detection heuristic, for example, while the runtime engine is operating in the detect contention state  (), for example. The runtime engine may adjust or vary a number of parameters of the rule-based approach. For example, the size of the window may be varied, and the one or more thresholds used for determining whether the applications are missing heavily can be adjusted. Examples, of durations over which misses may be monitored can include durations less than a millisecond (500 microseconds, 800 microseconds, e.g.), or durations of about one millisecond, a few milliseconds (e.g., 2 ms, 5 ms, 8 ms, or the like), or tens of milliseconds (e.g., 10 ms, 15 ms, 20 ms, 30 ms, 50 ms, 70 ms, or the like). These durations may apply to either the shutter-burst detection approach or to the rule-based detection approach.","With reference again to , the runtime engine may transition to a Modify Execution of (batch) Application state  when contention is detected. In some implementations, the runtime engine may apply a soft lock on the shared cache (e.g., while in state , see ) to prevent the cache from being used by applications other than the latency-sensitive application until the cache is no longer being used heavily by the latency-sensitive application. The batch application may be allowed to fully resume execution when the pressure on the cache subsides (e.g., when in state , see ). The forgoing response approach may be referred to as a soft-locking approach.","In some implementations, the runtime engine may use the shutter-burst approach to detect contention and may use the red-light, green-light approach to respond to contention (or lack of contention). In alternative implementations, the runtime engine may use the shutter-burst approach to detect contention and may use the soft-locking approach to respond to contention (or lack of contention).","In some implementations, the runtime engine may use the rule-based approach to detect contention and may use the red-light, green-light approach to respond to contention (or lack of contention). In alternative implementations, the runtime engine may use the ruled-based approach to detect contention and may use the soft-locking approach to respond to contention (or lack of contention).","Classification of an application as either a latency-sensitive application or a non-latency-sensitive (e.g., batch) application may be done in various ways. In some examples, the runtime engine may classify the applications. In some examples, an administrator may classify the applications, such as when the applications are deployed. In some examples, the classification of an application may be changed.","Advantages of the approaches discussed herein can include reducing cross-core application interference seen by latency-sensitive applications, which may improve an instruction retirement rate of the latency-sensitive application. Also, core utilization may be improved over conventional solutions that avoid co-locating latency-sensitive applications with batch locations on a multicore chip. This can provide substantial cost savings in various settings. For example, in a data center application where hundreds, thousands, or tens of thousands of multicore processors may be used to perform tasks associated with the data centers, a core utilization improvement of 30%, 20%, 10%, or even 1% may mean millions of dollars in saved expense. Work may additionally get done faster as a result of improved utilization. Power may be conserved, for example, if the processor may enter a lower power mode during periods of inactivity because scheduled tasks may have completed faster. Power may additionally be conserved when fewer processors are needed to perform a given set of work because of improved core utilization.","In various examples, the techniques described herein may be used in data center server applications. The techniques may also be used in consumer devices, such as desktop or laptop computers, tablets, personal digital assistants, smartphones, cell phones, set-top boxes, portable music players, portable electronic reading devices, and the like.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 8","b":"700"},"For each of the applications listed along the horizontal axis in chart , three bars are shown. The vertical axis of chart  shows the execution time penalty due to cross-core interference for the various configurations, versus the latency-sensitive application executing alone. The first bars show the cross-core interference penalty when co-locating the native applications directly on the multicore chip and letting the applications simultaneously execute. The second bars show the cross-core interference penalty when co-locating the native applications and using the CAER runtime engines with the shutter-burst contention detection heuristic. The last bars show the results for co-location using the CAER runtime engines with the rule-based contention detection approach.","As can be seen in , the cross-core interference penalty is significantly reduced when using the CAER runtime engines for the wide range of SPEC2006 benchmarks. For the experiment, the burst shutter contention detection technique was paired with the red-light green-light response approach, with a response length of 10 periods. An impact threshold of 5% was used for the shutter-burst contention detection method, so that if the batch application burst caused a spike of 5% or more in last level cache misses of the latency-sensitive application, the runtime engine would assert contention. On average, use of the CAER runtime engines implementing the shutter-burst and red-light, green-light approaches resulted in a reduction of overhead due to contention from 17% down to 6%, and resulted in nearly a 60% gain in processor utilization, as can be seen in , described below.","For the experiment, the rule-based contention detection technique was paired with the soft-locking response approach, with the usage threshold set to 1500. Heavy usage of the cache was declared if an average of 1500 or more last level cache misses per period (1 ms) was observed. On average, use of the CAER runtime engines implementing the rule-based contention detection and soft-locking response approaches resulted in a reduction of overhead due to contention from 17% down to 4%, and resulted in a 58% gain in processor utilization, as can be seen in , described below.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 9","FIG. 8"],"b":"800"},"In various examples, an amount of performance impact an application can experience due to contention for shared resources can differ from application to application. For a given application, this may be referred to as its cross-core interference sensitivity. This characteristic can also be determined by the amount of reliance an application puts on a shared resource. Applications whose working set fits in its core-specific private cache(s) may be cross-core interference insensitive. Applications whose working set uses shared cache, memory, or other shared resources may be cross-core interference sensitive.","In various implementations, the runtime engines discussed herein may handle contention detection and response differently for cross-core interference insensitive applications as compared to cross-core interference sensitive applications. For example, an amount of utilization that is sacrificed to reduce contention for a cross-core interference sensitive application may be higher than for a cross-core interference insensitive application. As an example, if application A is 50% slower when experiencing contention with application X, while application B is only 4% slower when contending with application X, then application A is more cross-core interference sensitive than application B, and the runtime engines may be more willing to sacrifice utilization to eliminate contention that application A sees to reduce the cross-core interference penalty. The runtime engines may accordingly adjust parameters of the approaches discussed herein to achieve these goals.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 10","b":["900","950","900","950","900","950"]},"Computing device  includes a multicore processor , memory , a storage device , a high-speed interface  connecting to memory  and high-speed expansion ports , and a low speed interface  connecting to low speed bus  and storage device . Each of the components , , , , , and , are interconnected using various busses, and may be mounted on a common motherboard or in other manners as appropriate. Each core of the multicore processor  can process instructions for execution within the computing device , including instructions stored in the memory  or on the storage device  to display graphical information for a GUI on an external input\/output device, such as display  coupled to high speed interface . In other implementations, multiple multicore (or single core) processors and\/or multiple buses may be used, as appropriate, along with multiple memories and types of memory. Also, multiple computing devices  may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system).","The memory  stores information within the computing device . In one implementation, the memory  is a volatile memory unit or units. In another implementation, the memory  is a non-volatile memory unit or units. The memory  may also be another form of computer-readable medium, such as a magnetic or optical disk.","The storage device  is capable of providing mass storage for the computing device . In one implementation, the storage device  may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations. A computer program product can be tangibly embodied in an information carrier. The computer program product may also contain instructions that, when executed, perform one or more methods, such as those described above. The information carrier is a computer- or machine-readable medium, such as the memory , the storage device , or memory on processor .","The high-speed controller  manages bandwidth-intensive operations for the computing device , while the low speed controller  manages lower bandwidth-intensive operations. Such allocation of functions is example only. In one implementation, the high-speed controller  is coupled to memory , display  (e.g., through a graphics processor or accelerator), and to high-speed expansion ports , which may accept various expansion cards (not shown). In the implementation, low-speed controller  is coupled to storage device  and low-speed expansion port . The low-speed expansion port, which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet), may be coupled to one or more input\/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.","The computing device  may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server , or multiple times in a group of such servers. It may also be implemented as part of a rack server system . In various implementations, such servers  or rack server systems  may be used in large data centers, for example. In addition, it may be implemented in a personal computer such as a laptop computer . Alternatively, components from computing device  may be combined with other components in a mobile device (not shown), such as device . Each of such devices may contain one or more of computing device , , and an entire system may be made up of multiple computing devices ,  communicating with each other.","Computing device  includes a multicore processor , memory , an input\/output device such as a display , a communication interface , and a transceiver , among other components. The device  may also be provided with a storage device, such as a microdrive or other device, to provide additional storage. Each of the components , , , , , and , are interconnected using various buses, and several of the components may be mounted on a common motherboard or in other manners as appropriate.","Each core of the multicore processor  can execute instructions within the computing device , including instructions stored in the memory . The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors. Additionally, the processor may be implemented using any of a number of architectures. For example, the processor  may be a CISC (Complex Instruction Set Computers) processor, a RISC (Reduced Instruction Set Computer) processor, or a MISC (Minimal Instruction Set Computer) processor. The processor may provide, for example, for coordination of the other components of the device , such as control of user interfaces, applications run by device , and wireless communication by device .","Processor  may communicate with a user through control interface  and display interface  coupled to a display . The display  may be, for example, a TFT (Thin-Film-Transistor Liquid Crystal Display) display or an OLED (Organic Light Emitting Diode) display, or other appropriate display technology. The display interface  may comprise appropriate circuitry for driving the display  to present graphical and other information to a user. The control interface  may receive commands from a user and convert them for submission to the processor . In addition, an external interface  may be provide in communication with processor , so as to enable near area communication of device  with other devices. External interface  may provide, for example, for wired communication in some implementations, or for wireless communication in other implementations, and multiple interfaces may also be used.","The memory  stores information within the computing device . The memory  can be implemented as one or more of a computer-readable medium or media, a volatile memory unit or units, or a non-volatile memory unit or units. Expansion memory  may also be provided and connected to device  through expansion interface , which may include, for example, a SIMM (Single In Line Memory Module) card interface. Such expansion memory  may provide extra storage space for device , or may also store applications or other information for device . Specifically, expansion memory  may include instructions to carry out or supplement the processes described above, and may include secure information also. Thus, for example, expansion memory  may be provide as a security module for device , and may be programmed with instructions that permit secure use of device . In addition, secure applications may be provided via the SIMM cards, along with additional information, such as placing identifying information on the SIMM card in a non-hackable manner.","The memory may include, for example, flash memory and\/or NVRAM memory, as discussed below. In one implementation, a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that, when executed, perform one or more methods, such as those described above. The information carrier is a computer- or machine-readable medium, such as the memory , expansion memory , or memory on processor  that may be received, for example, over transceiver  or external interface .","Device  may communicate wirelessly through communication interface , which may include digital signal processing circuitry where necessary. Communication interface  may provide for communications under various modes or protocols, such as GSM voice calls, SMS, EMS, or MMS messaging, CDMA, TDMA, PDC, WCDMA, CDMA2000, or GPRS, among others. Such communication may occur, for example, through radio-frequency transceiver . In addition, short-range communication may occur, such as using a Bluetooth, WiFi, or other such transceiver (not shown). In addition, GPS (Global Positioning System) receiver module  may provide additional navigation- and location-related wireless data to device , which may be used as appropriate by applications running on device .","Device  may also communicate audibly using audio codec , which may receive spoken information from a user and convert it to usable digital information. Audio codec  may likewise generate audible sound for a user, such as through a speaker, e.g., in a handset of device . Such sound may include sound from voice telephone calls, may include recorded sound (e.g., voice messages, music files, etc.) and may also include sound generated by applications operating on device .","The computing device  may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a cellular telephone . It may also be implemented as part of a smartphone , personal digital assistant, or other similar mobile device.","Various implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and\/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and\/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.","These computer programs (also known as programs, software, software applications or code) include machine instructions for a programmable processor, and can be implemented in a high-level procedural and\/or object-oriented programming language, and\/or in assembly\/machine language. As used herein, the terms \u201cmachine-readable medium\u201d \u201ccomputer-readable medium\u201d refers to any computer program product, apparatus and\/or device (e.g., magnetic discs, optical disks, memory, Programmable Logic Devices (PLDs)) used to provide machine instructions and\/or data to a programmable processor, including a machine-readable medium that receives machine instructions as a machine-readable signal. The term \u201cmachine-readable signal\u201d refers to any signal used to provide machine instructions and\/or data to a programmable processor.","To provide for interaction with a user, the systems and techniques described here can be implemented on a computer having a display device (e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor) for displaying information to the user and a keyboard and a pointing device (e.g., a mouse or a trackball) by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback (e.g., visual feedback, auditory feedback, or tactile feedback); and input from the user can be received in any form, including acoustic, speech, or tactile input.","The systems and techniques described here can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here), or any combination of such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), peer-to-peer networks (having ad-hoc or static members), grid computing infrastructures, and the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","A number of implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the invention. In addition, the logic flows depicted in the figures do not require the particular order shown, or sequential order, to achieve desirable results. In addition, other steps may be provided, or steps may be eliminated, from the described flows, and other components may be added to, or removed from, the described systems. Accordingly, other implementations are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4","i":"a "},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4","i":"b "},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
