---
title: Determining a maximal set of dependent software updates valid for installation
abstract: Described is a system and method by which a collection of software packages for installing (e.g., on an embedded computing device) are reviewed for their dependent relations, whereby it is possible to choose a maximal set of install possibilities to allow for maximal version updates for any given package in the fewest update steps possible, while honoring package dependency constraints. An update validation process organizes and validates update packages that have been downloaded to a device, and builds a graph for each group. The graph data including paths between updates are processed to validate the updates and to determine a minimal and optimal set of packages that can be applied to the existing image on the device to produce the desired update, with the least amount of weight (cost) when more than one path can be used to get to the same version.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07568195&OS=07568195&RS=07568195
owner: Microsoft Corporation
number: 07568195
owner_city: Redmond
owner_country: US
publication_date: 20040501
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention claims priority to U.S. provisional patent application Ser. No. 60\/530,130 filed Dec. 16, 2003, and incorporated herein in its entirety.","The present invention is related to the following United States patent applications, filed concurrently herewith and incorporated herein in their entireties:","Ser. No.: 10\/837,250, filed May 1, 2007, entitled \u201cApplying Custom Software Image Updates To Non-Volatile Storage in a Failsafe Manner;\u201d","Ser. No.: 10\/837,151, filed May 1, 2004, entitled \u201cEnsuring that a Software Update may be Installed or Run only on a Specific Device or Class of Devices;\u201d","Ser. No.: 10\/837,024, filed May 1, 2004, entitled \u201cSelf-Describing Software Image Update Components\u201d and Ser. No.: 10\/837,150, filed May 1, 2004, entitled \u201cCreating File Systems Within a File In a Storage Technology-Abstracted Manner.\u201d","The invention relates generally to computing devices such as those having embedded operating systems, and more particularly to updating the non-volatile storage of computing devices.","Mobile computing devices such as personal digital assistants, contemporary mobile telephones, and hand-held and pocket-sized computers are becoming important and popular user tools. In general, they have become small enough to be extremely convenient, while consuming less battery power, and at the same time have become capable of running more powerful applications.","During the process of manufacturing such devices, embedded operating system images are typically built into a monolithic image file and stored in non-volatile storage (e.g., NAND or NOR flash memory, a hard disk and so forth) of each device. As a result, updating such a device is necessary or desirable from time-to-time.","However, a monolithic operating system has a number of disadvantages, including that to install an update, a large amount of resources (e.g., temporary storage and bandwidth) are needed to replace the entire monolithic image. At the same time, installing some subset components of the operating system is a difficult task, because the existing package install state on the device is variable, and there may be any number of versioned packages queued for install. At present there is not a known intelligent image update server infrastructure that can query the installed image on a device to figure out what to install. Even if such a server infrastructure can be developed, however, there would be privacy concerns with sharing a device's install state information with a server. What is needed is an efficient way to handle device updates on the device side, that can deal with the many update versions and conflicts and dependencies between those versions.","Briefly, the present invention is directed towards a system and method by which a collection of packages for installing (e.g., on an embedded device) are reviewed for their dependent relationships, whereby it is possible to choose a maximal set of install possibilities to allow for maximal version updates for any given package in the fewest update steps possible, while honoring package dependency constraints. This is accomplished by knowing both the existing package install state on the device as well as the versioned packages queued for installation.","Any package to be installed is first validated, which refers to a process in which the packages queued for install are reviewed for completeness, the contents are validated, update authority is determined (from a signature mechanism), and dependency relationships are determined. In one implementation, the result of the validation process comprises two lists: a list of packages that can be installed because they pass the validation requirements, and a list of packages which cannot because they fail to meet one or more of the validation requirements, along with a failure reason. The lists may be sorted into an installation order.","An update validator\/validation process is provided, which in general organizes and validates a set of update packages that have been downloaded to a device into groups that are based on the target package being updated. Each group is processed to determine a minimal and optimal set of packages that can be applied to the existing image on the device to produce the update. To determine the minimal and optimal set of packages, the packages are organized into a graph that may have multiple paths from the base node (representing the target package) to each of the leaf nodes. The graph facilitates determining an optimal path through the set of packages, whereby the existing device package may be updated to the highest possible version of each package specified within the update set with the lowest cost (weighted) update. To this end, after the graphs are built, they are walked for various validation purposes, while attempting to find the highest version that the device can be update to, with the least amount of weight (cost) when more than one path can be used to get to the same version.","In one implementation, the validation process is accessible as an application programming interface called, for example, by an update application. The validation process looks for a device manifest file for each package (the device manifest file describes the package), and when found, the package is added (e.g., as a representative node for that package) to the package graph. When each the manifest files have been processed, graph processing looks for certificate information, including checking the parent node's certificate chain and pruning any corresponding branch from the tree from the parent node when not valid. When the branches and nodes of the graph have been processed including for signature verification, the lowest weighted branch is determined, and that branch is added to the update list that is to be returned to the calling entity.","Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environment",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["120","122","124","126","128","129","124","130","124","122"]},"One or more application programs  are loaded into memory  and run on the operating system . Examples of applications include email programs, scheduling programs, PIM (personal information management) programs, word processing programs, spreadsheet programs, Internet browser programs, and so forth. The handheld personal computer  may also include a notification manager  loaded in the memory , which executes on the processor . The notification manager  handles notification requests, e.g., from the application programs . Also, as described below, the handheld personal computer  includes networking software  (e.g., hardware drivers and the like) and network components  (e.g., a radio and antenna) suitable for connecting the handheld personal computer  to a network, which may include making a telephone call.","The handheld personal computer  has a power supply , which is implemented as one or more batteries. The power supply  may further include an external power source that overrides or recharges the built-in batteries, such as an AC adapter or a powered docking cradle.","The exemplary handheld personal computer  represented in  is shown with three types of external notification mechanisms: one or more light emitting diodes (LEDs)  and an audio generator . These devices may be directly coupled to the power supply  so that when activated, they remain on for a duration dictated by a notification mechanism even though the handheld personal computer processor  and other components might shut down to conserve battery power. The LED  preferably remains on indefinitely until the user takes action. Note that contemporary versions of the audio generator  use too much power for today's handheld personal computer batteries, and so it is configured to turn off when the rest of the system does or at some finite duration after activation.","Note that although a basic handheld personal computer has been shown, virtually any device capable of receiving data communications and processing the data in some way for use by a program, such as a mobile telephone, is equivalent for purposes of implementing the present invention.","Determining Software Updates Valid for Installation","The present invention is generally directed towards updating software that is stored on small mobile computing devices, such as Microsoft Windows\u00ae CE .NET-based portable devices, including those in which the initial software or software update is written to the embedded device's non-volatile memory, e.g., flash memory. Notwithstanding, the present invention provides benefits to computing in general, and thus may apply to other computing devices and other types of storage, including various types of memory and\/or other types of storage media such as hard disk drives. For purposes of simplicity, the term \u201cflash\u201d hereinafter will be used with reference to the updatable storage of a device, although it is understood that any storage mechanism is equivalent. Further, the term \u201cimage\u201d will generally include the concept of the initial software installation image as well as subsequent software updates to an image, even when only part of an existing image is updated.","In accordance with an aspect of the present invention, an appropriate subset of available software updates in the form of self-contained, secure entities is applied to an embedded device's non-volatile storage in an efficient, intelligent (and failsafe) manner. Various types of software updates may be applied, including full replacement updates and updates that may contain only the changes to a previous update. These software updates may contain both executable code and data, with the executable code customized to the virtual address space environment of the embedded device at install time.","Unlike monolithic updates, once the initial manufacturing image is installed on a device, updates to the image may be performed by updating discrete parts of the image via the present invention. In one implementation, these discrete parts are encapsulated into packages, wherein a package is a self-describing collection of image files (code, data, scripts and so forth), and may comprise a collection of components that is signed and packaged for distribution. In this implementation, the entire operating system image is built from one or more packages, each of which may be updated individually or in combination with other packages, depending upon each package's requirements.","Packages may be configured in various ways, including \u201ccanonical,\u201d \u201cdelta\/difference,\u201d and \u201csuper\u201d forms, that each serves various purposes with respect to software updates. For example, canonical packages contain a complete copy of each file within the package, while delta\/difference packages contain one or more files which contain only the binary differences based on an earlier revision of the file. Delta\/difference packages are applied to a previous version that is already installed, and are thus typically smaller in size relative to other packages and used when trying to reduce download cost and download time. Super packages contain other packages, and are used as a convenience when it is needed to download more than one package, such as when updating interdependent packages.","Canonical packages are generated during a build process by associating operating system features and metadata (e.g., a specific application's executable code and the associated data and configuration information) with a package definition. Delta\/difference packages are generated from canonical packages by applying a binary difference algorithm to the contents of two canonical packages and, in keeping with the present invention as described below, capturing the dependent relationship that the delta\/difference package has on the baseline canonical package version.","In accordance with an aspect of the present invention, there is provided an update validator\/validation process that organizes and validates a set of update packages that have been downloaded to a device. A first step in this process organizes the packages into coherent groups based on the target package being updated. After the packages have been organized into groups, each group is processed to determine the minimal and optimal set of packages that can be applied to the existing image on the device to produce the update. The coherent groups each comprise a set of packages that target the same existing package on the device. Each of the new packages may have a different base version and be applicable to a different target version.","To determine the minimal and optimal set of packages, the packages are organized into a graph that may have multiple paths from the base node (representing the target package) to each of the leaf nodes. This facilitates determining an optimal path through the set of packages that comprise the graph. Each group is processed to determine the optimal set of packages within the group to install, whereby the existing device package is updated to the highest possible version of each package specified within the update set.","A variety of factors affect the outcome of this processing. For example, if a dependency or signature cannot be validated, then that branch of the update is removed from the graph, and a different branch attempted, if one is available. One branch may be more efficient than another with respect to how much data needs to be updated; note that a canonical package is considered to have an infinite weight, because any way to obtain the update without using the canonical package (that is, via at least some deltas, possibly in multiple packages) is likely more efficient than writing (e.g., flashing) each file in the canonical package. Alternatively, it is feasible to have an actual weight for a canonical package.","Thus, a graph is built for each package, whether in an NK (kernel) partition or a system partition, wherein partitions are essentially different file systems, which may have different properties, where package contents may be stored, as generally described in the aforementioned related patent application entitled \u201cCreating File Systems Within a File In a Storage Technology-Abstracted Manner.\u201d Note that the packages having contents that go into the NK partition are the same kind of packages as the packages which their contents go into the IMGFS partition. However, loading\/booting sequence of the operating system is different for NK and system updates to the IMGFS partition, in that the NK partition is loaded first, and the drivers in the NK partition are used to locate and load the IMGFS partition files.","A node for each update package is added to the corresponding graph for that package. Version dependency relationships spelled out in the package manifests are then used to connect the nodes in the graph, e.g., version two of a package may upgrade version one of a package, and version three may upgrade version two (but not version one), whereby there would be an edge connection between version one and two and version two and three, but not between version one and three. It should be understood that the above version relationships only an example, and the relationships actually depend on the way the update is built. For example, it is possible to build a version 3 package that updates from a version 1 package. In general, each update package has a specific source version and a specific destination (final) version, and can only update from that source version, (which is not necessarily the destination version minus one). Note that a canonical update package can update any earlier version.","After the graphs are built, they are walked for various validation purposes, e.g., to check signatures as described below. In general, the graph walking process traverses the path in each graph, attempting to find the highest version that the device can be updated to, with the least amount of weight (cost) when more than one path can be used to get to the same version. While walking, if a node is not validated, that node and its path are essentially removed from the graph.","With respect to package manifests, as described in the aforementioned related patent application entitled \u201cSelf-Describing Software Image Update Components,\u201d each package type contains a device-side manifest file (e.g., having a .dsm extension) that fully describes both the contents of the package as well as more general package characteristics (including dependency information).  represents a layout of the manifest file.","As seen in the table below, the device manifest header contains a globally-unique identifier (GUID) which uniquely refers to the lineage of that specific package and a version which refers to the specific package file:",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct _DeviceManifestHeader"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003const DWORD dwStructSize;","\/\/ Size of this structure (in bytes)"]},{"entry":[{},"\/\/ for versioning"]},{"entry":["\u2003\u2003const DWORD dwPackageVersion;","\/\/ Version of this package"]},{"entry":["\u2003\u2003const DWORD dwPrevPkgVersion;","\/\/ Version of package that this package"]},{"entry":[{},"\/\/ updates. (0) for Canonical"]},{"entry":["\u2003\u2003const DWORD dwPackageFlags;","\/\/ package specific identifiers."]},{"entry":["\u2003\u2003const DWORD dwProcessorID;","\/\/ what processor (matches defines in"]},{"entry":[{},"\/\/ winnt.h)"]},{"entry":["\u2003\u2003const DWORD dwOSVersion;","\/\/ what version of the operating system"]},{"entry":[{},"\/\/ was this built to."]},{"entry":["\u2003\u2003const DWORD dwPlatformID;","\/\/ what was the target platform."]},{"entry":["\u2003\u2003const DWORD dwNameLength;","\/\/ length of filename in bytes."]},{"entry":["\u2003\u2003const DWORD dwNameOffset;","\/\/ offset to Friendly name of package"]},{"entry":["\u2003\u2003const DWORD dwDependentCount;","\/\/ How many entries in Dependent GUID"]},{"entry":[{},"\/\/ list."]},{"entry":["\u2003\u2003const DWORD dwDependentOffset;","\/\/ How many bytes from the front of the"]},{"entry":[{},"\/\/ file are the dependent GUID structs."]},{"entry":["\u2003\u2003const DWORD dwShadowCount;","\/\/ How many entries in shadow GUID list."]},{"entry":["\u2003\u2003const DWORD dwShadowOffset;","\/\/ How many bytes from front of file is"]},{"entry":[{},"\/\/ the array of shadowed package GUIDs."]},{"entry":["\u2003\u2003const DWORD dwFileCount;","\/\/ How many files are there listed in"]},{"entry":[{},"\/\/ this manifest."]},{"entry":["\u2003\u2003const DWORD dwFileListOffset;","\/\/ How many bytes from the front of file"]},{"entry":[{},"\/\/ to the first FileEntry."]},{"entry":["\u2003\u2003const DWORD cbCERTData;","\/\/ number of bytes of digital certificate"]},{"entry":[{},"\/\/ data"]},{"entry":["\u2003\u2003const DWORD dwCERTDataOffset;","\/\/ How many bytes from the front of file"]},{"entry":[{},"\/\/ to the certificate data."]},{"entry":["\u2003\u2003const GUID guidPackage;","\/\/ GUID of this package"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}DeviceManifestHeader, *PDeviceManifestHeader;"},{"entry":"typedef struct _DependentEntry {"},{"entry":"\u2003\u2003const DWORD size;"},{"entry":"\u2003\u2003const DWORD version;"},{"entry":"\u2003\u2003const GUID guid;"},{"entry":"}DependentEntry,*PDependentEntry;"},{"entry":"typedef struct _FileEntry {"},{"entry":"\u2003\u2003const DWORD dwNameLength;"},{"entry":"\u2003\u2003const DWORD dwFlags;"},{"entry":"\u2003\u2003const DWORD dwOffset;"},{"entry":"\u2003\u2003const DWORD dwBase; \/\/ Base address that file was originally linked with."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003const DWORD dwFileSize;","\/\/ Size of the whole file. Not accurate for"]},{"entry":[{},"\/\/ update packages."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}FILEENTRY,*PFILEENTRY;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Also seen in the device manifest header is a list of packages on which the current package is dependent, each described by the following structure:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _DependentEntry {"]},{"entry":[{},"\u2003\u2003const DWORD size;"]},{"entry":[{},"\u2003\u2003const DWORD version;"]},{"entry":[{},"\u2003\u2003const GUID guid;"]},{"entry":[{},"}DependentEntry,*PDependentEntry;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"There can be any number of packages each uniquely described by a GUID; all versions of a package share the same GUID. The dependency rules for a package require that the package or packages on which a package is dependent are either at or above the version number identified in the dependency list. A package is at or above the specified version if such a version is already installed on the device, or the install is pending and its dependencies are satisfied (thus ensuring its install).","To provide access to the information in the device side manifest file, which in one implementation is a binary file with a proprietary format, a common Package Information API (PackageInfoAPI) is provided. The present invention uses the package information API to determine the existing install state for a package on the device, as well as for packages that are queued for possible install. The API exists as a build system API as well as an embedded device API, and serves to effectively parse the device manifest files of a collection of package files. In general, the package information API provides the ability to enumerate the pre-existing packages on a device, to enumerate the shadow order information (described below) for a specific package, to enumerate the dependency information for a specific package, and to enumerate the list of file names of the files that belong to a specific package. The package information API also provides the ability to open a file that is stored in the file system as a device side manifest, open a device side manifest from within a specified package, and retrieve the package information (e.g., _PACKAGEINFO) for a specific package. The Package Information API also provides an interface to calculate a CRC32 value for a specific file, when given a path to that file, and to calculate a CRC32 value for a specific package, given a path to that package. The PackageInfoAPI component contains an implementation of the APIs set forth below.","The following API set defines the external interface to the PackageInfoAPI. The data types are described as follows:\n\n","The following API finds the first valid (valid==not a malicious \u2018impersonator\u2019) package and supplies the handle needed to retrieve the package info:",{"@attributes":{"id":"p-0048","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT Pkg_FindFirstPackage("]},{"entry":[{},"\u2003\u2003\/* [out] *\/ HPKGENUM *phPkgEnum,"]},{"entry":[{},"\u2003\u2003\/* [out] *\/ HPKG *phPkg);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following API finds the next valid package and supplies the handle needed to retrieve the package info (S_FALSE indicates the end of the enumeration):",{"@attributes":{"id":"p-0050","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT Pkg_FindNextPackage("]},{"entry":[{},"\u2003\u2003\/* [in] *\/ HPKGENUM hPkgEnum,"]},{"entry":[{},"\u2003\u2003\/* [out] *\/ HPKG *phPkg);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following API closes the package enumerator:\n\n","The following API will \u2018open\u2019 a Device Side Manifest file with specified GUID supplying the handle needed to retrieve the package info. This is an alternative to using the FindFirstPackage\/FindNextPackage APIs:",{"@attributes":{"id":"p-0053","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT Pkg_OpenPackageByGUID("]},{"entry":[{},"\u2003\u2003\u2003\u2003REFGUID guidPkg,,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* [out] *\/ HPKG *phPkg);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following API will \u2018open\u2019 a Device Side Manifest file with specified name supplying the handle needed to retrieve the package info. This is an alternative to using the FindFirstPackage\/FindNextPackage APIs:",{"@attributes":{"id":"p-0055","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT Pkg_OpenPackageByName("]},{"entry":[{},"\u2003\u2003LPCTSTR szFileName, ,"]},{"entry":[{},"\u2003\u2003\/* [out] *\/ HPKG *phPkg);"]},{"entry":[{},"\/\/ \u2018close\u2019 the package (previously opened with"]},{"entry":[{},"\/\/ Pkg_FindFirstPackage,"]},{"entry":[{},"\/\/ Pkg_FindNextPackage or Pkg_OpenPackageByGUID)"]},{"entry":[{},"HRESULT Pkg_Close(HPKG hPkg);"]},{"entry":[{},"\/\/ Enumerate shadowed packages. S_FALSE indicates"]},{"entry":[{},"\/\/ the end of the enumeration"]},{"entry":[{},"HRESULT Pkg_GetNextShadowedPackage (HPKG hPkg, \/*"]},{"entry":[{},"[out] *\/ GUID *pguidShadowedPkg);"]},{"entry":[{},"\/\/ Start enumeration of the GUID dependencies of the"]},{"entry":[{},"\/\/ specified package."]},{"entry":[{},"HRESULT Pkg_GetFirstDependentPackage("]},{"entry":[{},"\u2003\u2003HPKG hPkg,"]},{"entry":[{},"\u2003\u2003\/* [out] *\/ GUID pguidDependentPkg,"]},{"entry":[{},"\u2003\u2003\/* [out] *\/ DWORD*"]},{"entry":[{},"pdwDependentPackageVersion );"]},{"entry":[{},"\/\/ Continue the enumeration of GUID dependencies for"]},{"entry":[{},"\/\/ the given package. S_FALSE indicates the end of"]},{"entry":[{},"\/\/ the enumeration"]},{"entry":[{},"HRESULT Pkg_GetNextDependentPackage(HPKG hPkg, \/*"]},{"entry":[{},"[out] *\/ GUID *pguidDependentPkg, \/* [out] *\/ DWORD"]},{"entry":[{},"*pdwDependentPackageVersion);"]},{"entry":[{},"\/\/ Start enumeration of the files listed in the"]},{"entry":[{},"\/\/ Package. If the buffer is not large"]},{"entry":[{},"\/\/ enough (or is NULL), then cbSize will be set to"]},{"entry":[{},"\/\/ the required size of the"]},{"entry":[{},"\/\/ buffer, including the NUL character at the end."]},{"entry":[{},"HRESULT Pkg_GetFirstFile("]},{"entry":[{},"\u2003\u2003HPKG hPkg,"]},{"entry":[{},"\u2003\u2003\/* [out] *\/ LPTSTR pszFileName,"]},{"entry":[{},"\u2003\u2003\/* [in\/out] *\/ DWORD *cbSize );"]},{"entry":[{},"\/\/ Enumerate files in the package. S_FALSE indicates"]},{"entry":[{},"\/\/ the end of the enumeration."]},{"entry":[{},"HRESULT Pkg_GetNextFile(HPKG hPkg, \/* [out] *\/"]},{"entry":[{},"LPTSTR pszFilename, DWORD cbSize );"]},{"entry":[{},"\/\/ Get the single-occurrence info for the package"]},{"entry":[{},"HRESULT Pkg_GetPkgInfo(HPKG hPkg, \/* [out] *\/"]},{"entry":[{},"PPACKAGEINFO pPackageInfo);"]},{"entry":[{},"\/\/ Maps the specified file as a DSM file. Returns"]},{"entry":[{},"\/\/ E_FAIL if it is not a DSM."]},{"entry":[{},"HRESULT PkgInfo_OpenByName( LPCTSTR szFullName );"]},{"entry":[{},"\/\/ Determine if a specific file is contained within"]},{"entry":[{},"\/\/ the specified package."]},{"entry":[{},"\/\/ If the named file is part of the package,"]},{"entry":[{},"HFILEENTRY will be non-NULL."]},{"entry":[{},"HRESULT Pkg_ContainsFile("]},{"entry":[{},"\u2003\u2003HPKG hPkg,"]},{"entry":[{},"\u2003\u2003LPTSTR szFileName,"]},{"entry":[{},"\u2003\u2003\/* [out] *\/ HFILEENTRY** pFileEntry );"]},{"entry":[{},"\/\/ Validate the header for the specified Package."]},{"entry":[{},"HRESULT Pkg_ValidateHeader("]},{"entry":[{},"\u2003\u2003HPKG hPkg,"]},{"entry":[{},"\u2003\u2003DWORD dwFileSize );"]},{"entry":[{},"\/\/ Copies the CERT data from the specified Package"]},{"entry":[{},"\/\/ into the passed in buffer."]},{"entry":[{},"\/\/ If the buffer is not large enough, or is NULL,"]},{"entry":[{},"\/\/ then pcbBufferSize is set"]},{"entry":[{},"\/\/ to the required size."]},{"entry":[{},"HRESULT Pkg_GetCERTData("]},{"entry":[{},"\u2003\u2003HPKG hPkg,"]},{"entry":[{},"\u2003\u2003LPVOID lpBuffer,"]},{"entry":[{},"\u2003\u2003DWORD* pcbBufferSize );"]},{"entry":[{},"\/\/ and the CRC calculation API (this will be used by"]},{"entry":[{},"\/\/ test, for example, to verify against the CRC"]},{"entry":[{},"\/\/ stored on the device)"]},{"entry":[{},"HRESULT\u2003\u2003Pkg_CalculateFileCRC("]},{"entry":[{},"\u2003\u2003LPCTSTR pszFilename,"]},{"entry":[{},"\u2003\u2003\/* [out] *\/ DWORD *pdwCRC);"]},{"entry":[{},"HRESULT\u2003\u2003Pkg_CalculatePackageCRC("]},{"entry":[{},"\u2003\u2003LPCTSTR pszPackageName,"]},{"entry":[{},"\u2003\u2003\/* [out] *\/ DWORD *pdwCRC);"]},{"entry":[{},"\/\/ Opens the CAB, extracts the DSM and maps it."]},{"entry":[{},"\/\/ Returns E_FAIL if the file doesn't exit or isn't"]},{"entry":[{},"a DSM."]},{"entry":[{},"HRESULT PkgInfo_ExtractFrom( LPCTSTR szCABFile );"]},{"entry":[{},"\/\/ Given an HCAB returned by the CABAPI, finds the"]},{"entry":[{},"\/\/ DSM, extracts it and maps it. Returns E_FAIL if"]},{"entry":[{},"\/\/ the file doesn't exist or is not a DSM."]},{"entry":[{},"HRESULT PkgInfo_ExtractFromHCAB ( HCAB hCab );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In accordance with an aspect of the present invention, any package to be installed is first validated. Package validation refers to a process in which the packages queued for install are reviewed for completeness, their contents are validated, update authority is determined (from a signature mechanism), and dependency relationships are determined. In one implementation, the result of the validation process comprises two lists: a list of one or more packages which can be installed because they pass the validation requirements, and a list of one or more packages which cannot be installed because they fail to meet one or more of the validation requirements, along with a failure reason for each. The lists may be sorted into an installation order, which, in addition to ensuring that any needed files will be present if deltas are applied, can depend on size considerations to reduce fragmentation and ensure there is enough space to do the update.  comprise a flowchart describing the overall validation process.","In one implementation, the validation process is accessible as an application programming interface called, for example, by an update application. There are two functions, one called with the filenames of updates to validate and return installation data therefor, and another where the calling program provides a path to a directory where update packages are stored. For purposes of simplicity, the updates generally will be considered herein as being in a directory.","In , a number of tests are performed to determine whether a package can be installed, e.g., when given a directory containing one ore more packages to install. Step  takes the directory of packages, and tests determine whether the directory exists (step ) and the directory contains file(s) (step ). If not, an error message is returned via step  and the validation process ends.","If the directory exists with at least one file therein, steps  and  loop to iterate through each of the files, performing tests on each. Step  tests whether the file is a suitable type of package file; if so, step  attempts to extract the device-side manifest file (DSM) from the package. More particularly, in one implementation, a CABAPI is used to attempt to open the file as a CAB file. If this succeeds, then an attempt to extract the DSM is made. If the file cannot be loaded as a CAB file, the name is recorded into a list of bad packages with an HRESULT error code indicating that the specified file name could not be loaded as a CAB file. If the DSM cannot be extracted, then the name of the file is recorded in the list of bad packages with an HRESULT error code indicating that there was not a DSM in the CAB. If not a CAB file, or if the device manifest file is not found as evaluated at step , the next package file is selected and tested until none remain.","When a device-side manifest file is found, the package is added (e.g., as a representative node for that package) to a package graph via step . If not successful as tested by step , the validation process ends (at step ) as a result of failing to create the node.","When each the files have been processed, the graph should not be empty if at least one file in the directory was a package file having a device manifest file. If the graph is empty (step ), none of the files were valid packages, and the process ends at step . Otherwise the process continues to step  of .","Step  (along with step ) of  represent a loop for processing each branch in the graph, while step  (along with step ) represent a nested loop for processing each node in the branch currently being processed. In general the processing looks for certificate information, including checking the parent node's certificate chain via steps  and , pruning the corresponding branch from the tree from the parent node when not found via step .","If found, the signature is verified via steps  and . If found, weighting data (that is used to evaluate efficiency when deciding which package to use relative to others when more than one path can be used to provide the same result) is added at step  to the branch based on the node, and the next node is selected until none remain via step . The weighting information is calculated when the package is loaded and is added to the weight of the path when the path is constructed. The initial graph construction works off of the assumption that the packages are valid, and thus the signature information only has to be verified for the packages that the process wants to use, rather than performing it on every package in the update set, which hopefully reduces the number of signature checks performed. If the signature is not valid at step , the branch is pruned from the current node at step .","When the branches and nodes of the graph have been processed in this manner, the graph is walked as represented by step  to find the lowest weighted branch, and that branch is added to the update list that is to be returned.","In accordance with an aspect of the present invention, the validation process provides the version-dependency calculation requirements that enable the determination of the maximal dependent software updates that are valid for installation. As represented by the block diagram of , the validation process  is associated with (or can be considered as including) various components to make the determination, including an update ordering component . The update ordering component  constructs a graph  of the set of packages that have been downloaded to a device as an update set , extracting the dependency information from the package manifest  and verifying that the other packages  are present on the device (or in the queued install packages ) with the correct version. In addition, the update ordering component  is responsible for parsing the existing and new device manifest files  and  and generating an install order for the packages based on the dependency requirements.",{"@attributes":{"id":"p-0066","num":"0072"},"figref":"FIGS. 5A and 5B","b":["500","502","504","506"]},"Once the packages to install have been added, each graph is walked, including for the purposes of evaluating paths and performing file validation. Note that the paths through the graph were constructed in real time as the nodes were added to the graph. As described below with reference to , once the packages have been loaded, the update validator walks each graph looking for the optimal path among the set of paths available for the graph. Once a path is selected for a graph, then the signatures for the nodes in the path are validated. If the signature for a specific node cannot be validated, then the path is pruned starting at the failing node, and then the path selection process is re-run for that graph. This process is repeated until either the nodes in a path are determined to have valid signatures or there are no more paths to process for the given graph.","If processing is successful at step , the update ordering process continues to step  of , wherein for each resulting package graph, if the package is part of the NK partition, the Package information is added to NK list  () via step . If the Package is not part of the NK partition, the package is added to an Other list  (). Once all Package Graphs have been processed, the other list  is appended to the NK list  via step , and if the append is successful as evaluated at step , a NOERROR state is returned with the appended NK list  and an invalid list .","Another part of the validation process  is directed to constructing an update graph, and is accomplished by an update graph component , which is responsible for building a graph of the packages that comprise an update on the device. Each preexisting package on the device will be used to create the base node for an independent graph. In one implementation, each package is represented by a package node object; note that in this implementation, each node object is contained within one, and only one, package graph object.","The graph construction process is represented in . In general, the update graph  () contains two arrays, including an array of node objects  and an array of edge objects . The edge objects connect nodes to each other. When a new package is added to the graph, a node object is created for the package and added to the node array , as represented by step . If the node is not created as evaluated at step , the process fails.","Steps  and  attempt to find an existing graph corresponding to this package; if none are found the package is new and a graph is created therefor at step , (and ensured that it is properly created via step ). If successfully created, the new graph is returned at step , else a failure is returned.","If the node create was successful and a graph was found for that package, step  branches to step , where, via steps -, for each node in the node array, if the base version of the new node matches the version number for the existing node, an edge object is created in the update graph  () and added to the array . In this condition, the edge object specifies the existing node as the source and the new node as the sink. If instead the base version of the existing node matches the version number of the new node, an edge object is created specifying the new node as the source and the existing node as the sink.","Note that it is possible for a package to be added that, at the time of addition, has no connections to any existing nodes. This condition will be rectified through one of two outcomes, namely (a) there are no nodes that can be reached through this package node and there are no paths to this package node through other package nodes in the update; in this circumstance, the node will be marked as bad and will end up on the invalid update list, and (b) a package that will be added later will connect to the node. In this circumstance, the node will be processed during the graph walk phase, described below with reference to .","Further, note that if two packages have the same target version, then the two device-side manifest files are compared. If they are not equal, both nodes are marked as invalid, because for any given package, the device-side manifest file for a specific version should be the same across all packages that update the given package to a specific version.","As another part of the validation process, an update graph walker component  traverses each package graph in order to determine the highest final version number for the package based on possibly multiple paths through the graph. While walking, the update graph walker component  validates the digital signatures on the packages in the graph. If a signature check fails, the graph is pruned at that point and any the edges that connect to the failed node are removed.","Once the highest version number is determined, the dependencies for that node are validated. This is accomplished by querying the update graph  for a package graph that matches the dependent .GUID. If a new update graph has not been validated, then the update graph walker starts the walking process over on the new package graph. If a dependency cannot be satisfied, then the branch is abandoned and a new branch is attempted. The edges connecting the nodes in the branch are removed. If all possible branches are exhausted and the dependency requirements cannot be met, then the packages represented by the nodes in the graph are moved to the invalid update list.",{"@attributes":{"id":"p-0077","num":"0083"},"figref":"FIGS. 7A and 7B","b":["702","706","704","708","718","714","716"]},"If instead there was an edge at step , the process branches to step  of  to check the node to see if it has a CERT chain. If there is no CERT chain at step , the CERT block is obtained from the device-side manifest file corresponding to the node. Note that if there is no CERT block in the device-side manifest file, the node is marked as bad at step  and the process returns.","If there is CERT data at step  or step , the process proceeds to step  to decode the data. If the decoding fails, the node is marked as bad at step  and the process returns.","Otherwise, an attempt to find the sink node at the end of the edge is performed at step , with a test at step  as to whether there is no sink node; if not, a graph integrity error is logged and the process returns via step .","If the sink node is found, the CERT data is used to validate the sink node (step ). If the sink node passes signature validation, then this function is recursively called, passing the sink node at step , returning to step  of . If the sink node fails, then the edge is marked as bad.","In this manner, the maximal set of updates is determined and returned in an ordered update list, along with a list of any invalid updates. This may correspond to the minimal number of packages that maximize the device package versions.","As can be seen from the foregoing detailed description, there is provided a mechanism that handles device updates on the device side. The mechanism deals with the many update versions and conflicts and dependencies between those versions to provide a minimal number of valid packages when applied will maximize the device package versions.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 7A and 7B"}]},"DETDESC":[{},{}]}
