---
title: Primitive program compilation for flat attributes with provoking vertex independence
abstract: Systems and methods for compiling high-level primitive programs are used to generate primitive program micro-code for execution by a primitive processor. A compiler is configured to produce micro-code for a specific target primitive processor based on the target primitive processor's capabilities. The compiler supports features of the high-level primitive program by providing conversions for different applications programming interface conventions, determining output primitive types, initializing attribute arrays based on primitive input profile modifiers, and determining vertex set lengths from specified primitive input types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08171461&OS=08171461&RS=08171461
owner: NVIDIA Coporation
number: 08171461
owner_city: Santa Clara
owner_country: US
publication_date: 20060224
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Primitive Input Profile Modifiers","Primitive Output Profile Modifiers","Attribute Arrays","Emitting Vertices","Shaded Primitive Attributes"],"p":["1. Field of the Invention","Embodiments of the present invention generally relate to compiling high-level primitive programs into primitive program micro-code and, more specifically, to compiling the high-level primitive program for execution by a target primitive processor.","2. Description of the Related Art","Recently programmable primitive processors have been developed necessitating the development of compilers to produce primitive program micro-code for execution by the programmable primitive processors. Conventional primitive processors include fixed function units that may be configured, for example to produce particular primitive types, but are not programmable. The capabilities of different programmable primitive processors may vary and a program written for one processor may not run on another processor without modification.","Accordingly, it is desirable to compile primitive programs written in a high-level language into executable micro-code optimized for a particular programmable primitive processor.","The current invention involves new systems and methods for compiling high-level primitive programs to generate primitive program micro-code. A compiler may be configured to produce micro-code for a specific target primitive processor based on the target primitive processor's capabilities. The compiler also supports features of the high-level primitive program by providing conversions for different applications programming interface conventions, determining output primitive types, initializing attribute arrays based on primitive input profile modifiers, and determining vertex set lengths from specified primitive input types. Therefore, the high-level primitive program may expressly control a particular primitive processor and the micro-code will be optimized for execution by the particular primitive processor, improving performance and portability of the high-level primitive program.","Various embodiments of the invention include a programmable graphics processor configured to perform multi-threaded processing of graphics data.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the present invention. However, it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the present invention.","A high-level primitive program is designed to operate on assembled primitives, e.g., triangles, lines, points, and the like. Primitive programs may be used to perform a variety of geometry operations including clipping, primitive subdivision, shadow volume generation, cube map rendering, cylindrical texture wrapping, curve interpolation, spline interpolation, and the like. A compiler is used to convert a high-level primitive program into the micro-code optimized for execution by a particular primitive processor. Therefore, the compiler supports the features of the high-level primitive program and may be configured to optimize and convert the high-level primitive program into micro-code for one or more target primitive processors.  illustrates a flow diagram of an exemplary method of compiling a high-level primitive program into primitive program micro-code in accordance with one or more aspects of the present invention.","In step  the compiler receives primitive program source code expressed in a high-level language. In step  the compiler receives target information that may specify a particular primitive processor and\/or a particular applications programming interface (API), e.g., Microsoft's DirectX\u2122, Open Graphics Library (OpenGL\u00ae), or the like. In step  the compiler compiles the primitive program source code based on the target information. In step  the compiler outputs primitive program micro-code optimized based on the target information.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1B","FIG. 1A"],"b":["110","120","125","130","125","130","135"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2A","b":["200","201","201","200"]},"Primitive program source code  is processed by a parser  using techniques known to those skilled in the art to produce a parsed primitive program. The parsed primitive program is processed by one or more transformers  that perform optimizations on the parsed primitive program based on a target platform  to produce a transformed primitive program. Target platform  may specify a particular primitive processor and\/or a particular API that will be used to execute micro-code . The transformed primitive program is received by a micro-code generator  that converts the transformed primitive program into micro-code  for execution on the particular target platform that corresponds to target platform . In some embodiments of the present invention, primitive program compiler  produces optimized translations of primitive program source code  in other high-level hardware shading languages, such as HLSL (high-level shader language) and GLSL (OpenGL\u00ae's shader language).",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2B","FIG. 2A"],"b":["200","210","201","206","200","211","211","205","212","211","212","213","213","200","205"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2C","FIG. 2A"],"b":["200","200","214","212","214","213","200"]},"In conventional graphics processing systems, vertex programs and fragment programs are used to process vertices and fragments, respectively. The corresponding processing units that execute the vertex and fragment programs are programmable while primitive processing is performed using dedicated configurable processing units. Although the configuration of the dedicated processing units may be changed, the operations are limited to the set of computations provided by the dedicated processing units. More recently, graphics processing systems include programmable primitive processing units that execute primitive programs. In addition to the functionality provided by the configurable processing units, the primitive programs may be used to perform more complex or more efficient primitive processing. Primitive programs operate in a graphics processing pipeline subsequent to vertex programs and initial primitive assembly and prior to clipping, perspective division, rasterization, and fragment programs. Unlike vertex programs that output a vertex for each input vertex or fragment programs that output zero or one fragment for each input fragment, primitive programs output zero or more primitives for a set of input vertices.","Vertex processing, typically performed by a vertex program, generates a stream of post-transformed vertices. A compiled primitive program, represented by micro-code , operates on an assembled primitive, e.g., triangle, line, or point, defined by the stream of post-transformed vertices.  illustrates a point input primitive defined by a vertex , in accordance with one or more aspects of the present invention.  illustrates a line segment input primitive defined by a vertex  and vertex , in accordance with one or more aspects of the present invention.  illustrates a line with adjacency input primitive defined by vertex , vertex , and adjacency vertices  and , in accordance with one or more aspects of the present invention.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 3D","FIG. 3E"],"b":["301","302","303","301","302","303","304","305","306"]},"A primitive processor executes the primitive program represented by micro-code  on each assembled input primitive. Several primitives may be processed in parallel and each primitive program instance may be executed independently, i.e., without communication between the primitive program instances. Each primitive program instance has access to all the transformed vertex attributes output by the upstream vertex processing. Each primitive program instance receives primitive specific input parameters and common uniform parameters. Because each primitive program instance is executed independently, many primitive program instances can execute in parallel for high-performance.","Execution of a primitive program instance produces an ordered stream of zero or more output primitives. Output primitive types include points, line segments, and triangles. The output primitive type may be specified by the primitive program or may be inferred from the input primitive type. Each output primitive is assembled from an appropriate number of vertices that include per-vertex attributes such as clip-space position and per-vertex texture coordinates. These output attributes are used by clipping and interpolation during rasterization. Some primitive programs may perform clipping, in which case, clipped positions are output. When a primitive program is not present, unmodified vertex attributes for each primitive are passed through to clipping and rasterization.","Primitive programs include a geometry profile entry function that returns \u201cvoid\u201d and indicates the type of input primitive that the geometry program expects. A primitive profile modifier portion of the entry function specifies the primitive input or output type. TABLE I includes examples of several primitive input profile modifiers and their expected inputs.",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["POINT","0: single vertex"]},{"entry":["LINE","0: start vertex of line segment"]},{"entry":[{},"1: end vertex of line segment"]},{"entry":["LINE_ADJ","0: pre-adjacent vertex to line strip"]},{"entry":[{},"1: start vertex of line strip"]},{"entry":[{},"2: end vertex of line strip"]},{"entry":[{},"3: post-adjacent vertex to line strip"]},{"entry":["TRIANGLE","0: first vertex of triangle"]},{"entry":[{},"1: second vertex of triangle"]},{"entry":[{},"2: third (last) vertex of triangle"]},{"entry":["TRIANGLE_ADJ","0: first vertex of triangle"]},{"entry":[{},"1: adjacent vertex to first and second vertex of triangle"]},{"entry":[{},"2: second vertex of triangle"]},{"entry":[{},"3: adjacent vertex to second and third vertex of triangle"]},{"entry":[{},"4: third (last) vertex of triangle"]},{"entry":[{},"5: adjacent vertex to third and first vertex of triangle"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A primitive program for a point input primitive expects a scalar or one-element array of input variables. A primitive program for a line input primitive expects a two-element array of input variables. The first element is the start vertex and the second element is the end vertex. A primitive program for a line adjacency input primitive expects a four-element array of input variables. The first element is the pre-adjacent vertex, the second element is the start vertex, the second element is the end vertex, and the fourth element is the post-adjacent vertex. For example, in  vertex  and vertex  may be the first and fourth elements.","A primitive program for a triangle input primitive expects three-element array of input variables. The first element is the first vertex, the second element is the second vertex, and the third element is the third (last) vertex. A primitive program for a triangle adjacency input primitive expects six-element array of input variables. The first element is the first vertex of a triangle, the second element is the adjacent vertex to the first and second vertex of the triangle, the third element is the second vertex of the triangle, the fourth element is the adjacent vertex to the second and third vertex of the triangle, and the fifth element is the third (last) vertex of the triangle, and the sixth element is the adjacent vertex to the third and first vertex of the triangle. For example, in  vertices , , and  are the first, second, and third vertices of the triangle and vertices , , and , respectively, are the adjacency vertices (second, fourth, and sixth elements).","The type of a primitive program (point, line, line adjacency, triangle, adjacency, or other primitive type) can be determined by a compiler based on the primitive input profile modifier specified by the primitive program.","Each type of OpenGL primitive batch supported by \u201cglBegin\u201d corresponds to a different primitive input profile modifier. For example, GL_POINTS corresponds to the point primitive input profile modifier. GL_LINES, GL_LINE_STRIP, and GL_LINE_LOOP correspond to the line primitive input profile modifier. GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON correspond to the triangle primitive input profile modifier. GL_LINES_ADJACENCY_NV and GL_LINE_STRIP_ADJACENCY_NV correspond to the line adjacency primitive input profile modifier. GL_TRIANGLES_ADJACENCY_NV and GL_TRIANGLE_STRIP_ADJACENCY_NV correspond to the triangle adjacency primitive input profile modifier. Other rendering APIs may specify the primitive type for a batch of primitives differently.","A primitive program's entry function should be declared using a profile identifier that is a primitive input profile modifier. For example, a TRIANGLE profile modifier may be used to specify the input primitive type for a primitive program's entry function (simple) as shown in TABLE 2.",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003TRIANGLE void simple(AttribArray<float4> position : "},{"entry":"\u2003\u2003POSITION, uniform float4 flatColor)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Vertex domain outputs are inputs to the primitive domain. Therefore, the vertex domain output semantics are primitive domain input semantics. The primitive domain input semantics are also the primitive domain output semantics. Specifically, POSITION is a clip-space position that is typically represented in floating point format. COLORn is a primary (n=0) and secondary (n=1) color (front-facing color if two-sided color assignment enabled) that is typically represented in a floating point format. BCOLn is a back-facing primary (n=0) and secondary (n=1) color that is typically represented in a floating point format. TEXCOORDn is a texture coordinate set n that is typically represented in a floating point format. FOG is a fog coordinate that is typically represented in a floating point format. CLPn is a clip coordinate n that is typically represented in a floating point format. PSIZ is a point size that is typically represented in a floating point format. Additional semantics may be specified for some embodiments of the present invention.","Primitive program entry functions do not have output variables. Unlike vertex and fragment programs that generate results based on output parameters, primitive programs output vertices using emitVertex functions. Vertex programs output a vertex for each input vertex. Fragment programs output zero or one fragment for each input fragment. In contrast, primitive programs output zero or more primitives for a set of input vertices. The vertex set lengths are inferred by primitive program compiler based on the specified primitive input profile modifier. The stream of vertices received by a primitive program is separated into the vertex sets, and each vertex set includes the number of input vertices that correspond to the expected inputs for each primitive input profile modifier shown in TABLE 1.","The output primitive type may be inferred by primitive program compiler  from the input primitive type. For example, the output primitive type is point when the input primitive type is point. The output primitive type is line when the input primitive type is line or line adjacency. The output primitive type is triangle when the input primitive type is triangle or triangle adjacency. Alternatively, the output primitive type may be specified using a primitive output profile modifier.","The vertices emitted by a primitive program can form points, line strips, or triangle strips. A single primitive program emits only one of the output primitive types, e.g., point, line, or triangle. A primitive output profile modifier may be specified that is applied to the primitive program's entry function. In particular, a primitive output profile modifier may be specified in order to output a different type of primitive than is specified by the primitive input profile modifier. Primitive output profile modifiers are specified as POINT_OUT, LINE_OUT, and TRIANGLE_OUT. The point output profile modifier emits vertices that are assembled to render points. The line output profile modifier emits vertices that are assembled to render line strips. The triangle output profile modifier emits vertices that are assembled to render triangle strips.","Each primitive program has a primitive output type that is determined based only on the primitive output profile modifier for the primitive program's entry function. Primitive program compiler  may generate a warning if a primitive program calls a function having a primitive output profile modifier that does not match that of the primitive program's entry function.","A primitive program receives a stream of vertices and associated attributes, e.g., color, normal vector, texture coordinates, position, or the like, as input. The primitive program may also receive \u201cuniform\u201d parameter constants that are used to process the vertices based on their usage in the program. The associated attributes are specified as an array that is sized by primitive program compiler  based on the number of vertices in the input primitive type. For example a triangle primitive type has three arrays of attributes, one attribute array per vertex. The attribute array element values are initialized to the values of each corresponding vertex sent to the geometry program when each program instance is executed. Using structures of attribute arrays is preferred to using arrays of attribute structures since the attribute structures are fixed. The attribute arrays of the present invention may be defined to have more or fewer attributes.","\u201cAttribArray< >,\u201d as shown in TABLE 2, is a predefined template used to declare input variables for the array of attributes accepted by a primitive program and it is unique to geometry profiles. Because the attribute arrays are unsized, they can be used in helper functions that are called by different primitive programs with varying input primitive types. As shown in TABLE 2, \u201cposition\u201d acts like an array with as many elements as the primitive profile modifier mandates. This is 3 for the TRIANGLE input primitive type because a triangle primitive is assembled from 3 vertices. The semantics for the variable applies to every element of the array. Therefore, elements of the position attribute array, position[0], position[1], and position[2] all use the POSITION semantic.","As with any array, elements of attribute arrays may be accessed using the \u201c[ ]\u201d operator. The \u201c.length\u201d accessor for a primitive profile array declared with AttribArray< > may be used to determine how many elements are included in the attribute array. For example, in the \u201csimple\u201d function shown in TABLE 2, position.length would evaluate to 3 because the profile modifier is TRIANGLE. As shown in TABLE 3, arrays are allowed to use AttribArray< >.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003typedef float4 Float4Array[4];"},{"entry":"\u2003\u2003AttribArray<Float4Array> texcoord : TEXCOORD0"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The AttribArray< > usage can be used for typedefs and variable definitions other than in the primitive program entry function as shown in TABLE 4.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003typedef AttribArray<float4> PositionSet;"},{"entry":"\u2003\u2003void TRIANGLE simple(PositionSet position : "},{"entry":"\u2003\u2003POSITION, uniform float4"},{"entry":"\u2003flatColor)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","AttribArray<AttribArray<float4>> bogus; \/\/ error","\u2003"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"AttribArray< > array declarations may be used in local variables or in non-entry functions, such as the helper function shown in TABLE 6. The perspectiveDivideAll helper function may be used generically by primitive program entry functions with differing input primitive profile modifiers and the attribute arrays will be sized accordingly based on the primitive input profile modifier provided for each primitive program entry function.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","void perspectiveDivideAll(AttribArray<float4>","\u2003"]},{"entry":[{},"position : POSITION, out float3",{}]},{"entry":[{},"result[6])",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003for (int i=0; i<position.length; i++) {",{}]},{"entry":[{},"\u2003\u2003result[i] = position[i].xyz \/ position[i].w;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Primitive programs write a set of output variables with associated vertex semantics and then \u201cemit\u201d a vertex. The emitted vertex is formed by the current state of the output variable at emit time. A primitive program may emit zero or more vertices. In some embodiments of the present invention the primitive processor may impose a limit on the number of vertices that are emitted for a primitive program. In other embodiments of the present invention, primitive program compiler  may infer the upper bound for the maximum vertex count based on a primitive processor imposed limit or a programmer specified limit. Some primitive programs may be too complex for primitive program compiler  to determine the upper bound due to branching or data-dependent program behavior. For those primitive programs a predetermined default upper bound may be used.","Limiting the number of vertices emitted may facilitate efficient parallel execution of the primitive program using a multi-threaded primitive processor. In particular, because hardware resources, such as registers may be allocated based on the number of vertices or attributes, it may be advantageous for the hardware to allocate the resources based on a predetermined limit. A lower limit may permit more primitive program instances to run in parallel, resulting in higher performance compared with using a higher limit. In some embodiments of the present invention, a limit may also be applied to the number of vertex attributes that are emitted for a primitive program.","When the primitive program's output type is POINT_OUT, every emitVertex call emits a point. When the primitive program's output type is LINE_OUT, the first emitVertex call in a primitive program or first emitVertex since a restartStrip call begins the assembly of a new line strip. Every second and subsequent emitVertex (until the next restartStrip) assembles a line segment from the current vertex and the immediately previous vertex. When the primitive program's output type is TRIANGLE_OUT, the first and second emitVertex call in the primitive program or the first and second emitVertex call since a restartStrip call initiates assembly of a new triangle strip. Every subsequent emitVertex (until the next restartStrip) assembles a triangle from the current vertex and the two preceding vertices.","The standard library functions shown in TABLE 7 may be used in primitive profiles.",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","void emitVertex(...);","\u2003"]},{"entry":[{},{},"void restartStrip(void);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"During execution of a primitive program, when emitVertex is called, a vertex is generated based on the current values of the output variables. An arbitrary number of parameters (attributes) can be passed to emitVertex and used to generate the vertex. The semantics of the passed parameters map the parameter values to hardware resources. For example, the parameters foo and bar shown in TABLE 8 result in a vertex having a position of foo and a color of bar.",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"float4 foo : POSITION;"},{"entry":"float4 bar : COLOR;"},{"entry":"foo = someComputedPosition;"},{"entry":"bar = someComputedColor;"},{"entry":"emitVertex(foo, bar);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Parameters with unspecified or unrecognized semantics may be assigned to hardware resources based on the parameter order. Because foo and bar have recognized semantics, changing the order of the parameters, i.e., emitVertex (bar, foo); provides the same result as the emitVertex usage shown in TABLE 8.","A function, restartStrip, is used to restart strips of output primitives from a primitive program. restartStrip is used to terminate the current line or triangle strip and start another line or triangle strip originating at the next vertex. restartStrip is a no-op function for a primitive program specifying POINT_OUT primitive output. Primitive program compiler  maintains the ordering of the output vertices, including maintaining ordering for strips generated using the restartStrip function. Transformations by the compiler must preserve the ordering of executed emitVertex and restartStrip operations.","Primitive programs may be configured to output per-vertex attributes that are smooth shaded (typically perspective-correct interpolated) and per-primitive attributes that are flat shaded. However, different provoking vertex conventions are used by different APIs for specifying flat shaded attributes for a primitive. Microsoft's Direct3D provides per-primitive attributes for constant interpolation (what OpenGL calls flat shading) with the first vertex of each assembled primitive, i.e., the first vertex is the provoking vertex. APIs that use the OpenGL convention provide the per-primitive attributes for flat shading with the last vertex of each assembled primitive, i.e., the last vertex is the provoking vertex. To permit programmers to write primitive programs independent of the 3D API's provoking vertex convention for flat shaded attributes, a flatAttrib routine is used to specify flat shaded attributes. Primitive program compiler  compiles the flatAttrib routine based on target platform  to support varying API conventions for specifying flat shaded attributes.","TABLE 10 shows an example of how the flatAttrib routine may be used within a primitive program to provide API independence. A first triangle stored in buffer 0 consists of positions 0, 1, and 2 and is flat shaded red. A second triangle stored in buffer 1 consists of positions 1, 2, and 0 and is flat shaded green.",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"float flatRed : COLOR = float4(1.0, 0.0, 0.0, 1.0);"},{"entry":"float flatGreen : COLOR = float4(0.0, 1.0, 0.0, 1.0);"},{"entry":"AttribArray<float4> position : POSITION;"},{"entry":"flatAttrib(flatRed, 0 : BUFFER_INDEX); \/\/ for triangle 0"},{"entry":"emitVertex(position[0]);"},{"entry":"flatAttrib(flatGreen, 1 : BUFFER_INDEX); \/\/ for triangle 1"},{"entry":"emitVertex(position[1]);"},{"entry":"emitVertex(position[2]);"},{"entry":"emitVertex(position[0]);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The VIEWPORT_INDEX and BUFFER_INDEX output semantics are provided for vertices output by a primitive program. VIEWPORT_INDEX may range from 0 through 15 and is used for flat attributes. BUFFER_INDEX may range from 0 through 7 and is also used for flat attributes.","The present invention provides many benefits for primitive programming. In particular the primitive programs may be written independent of particular D APIs and\/or particular primitive processors. When provided with target platform , primitive program compiler  will produce micro-code  that is optimized for execution by target platform . The input primitive type may be used to determine an output primitive type, vertex set lengths, and attribute array sizes. The triangle primitive program shown in TABLE 11A illustrates several of these features.","The triangle program (passthru) passes a triangle with its position and texture coordinate set 0 unmodified, but forces the color to a uniform flat color. In particular, note that the parameters provided to AttribArray are sized based on the input primitive type (triangle). The output primitive type is inferred to be the same as the input primitive type. The \u201cfor loop\u201d iterates based on the length of the POSITION array, and is therefore also determined by the input primitive type. Finally, the flat shaded attribute is output independent of a provoking vertex convention.",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"TRIANGLE void passthru(AttribArray<float4>position : POSITION,"},{"entry":"\u2003\u2003\u2003\u2003AttribArray<float4> texCoord : TEXCOORD0,"},{"entry":"\u2003\u2003\u2003uniform float4 flatColor : COLOR)"},{"entry":"{"},{"entry":"\u2003flatAttrib(flatColor);"},{"entry":"\u2003for (int i=0; i<position.length; i++) {"},{"entry":"\u2003\u2003emitVertex(position[i], texCoord[i]);"},{"entry":"\u2003}"},{"entry":"restartStrip( ); \u2003\u2003\u2003\u2003\/\/no-op, just for the example"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The triangle primitive program shown in TABLE 11A may be compiled to produce micro-code shown in TABLE 11B, excluding the comments indicated by #s. Notice that primitive program compiler  determines position.length is 3 based on the input primitive profile modifier being TRIANGLE and unrolls the loop for better performance. Primitive program compiler  also determines the \u201cPRIMITIVE_OUT_TRIANGLE_STRIP\u201d based on the TRIANGLE input primitive profile modifier. Primitive program compiler  determines that VERTICES_OUT is 3 based on the loop.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11B"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"# triangle input primitive inferred by compiler from TRIANGLE input "},{"entry":"profile modifier"},{"entry":"PRIMITIVE_IN TRIANGLES;"},{"entry":"# triangle strip output inferred by compiler from TRIANGLE input "},{"entry":"profile modifier"},{"entry":"PRIMITIVE_OUT TRIANGLE_STRIP;"},{"entry":"# compiler determines exactly 3 vertices output"},{"entry":"VERTICES_OUT 3;"},{"entry":"# output first vertex"},{"entry":"MOV result.position, vertex[0].position;"},{"entry":"MOV result.texcoord[0], vertex[0].texcoord[0];"},{"entry":"EMIT;"},{"entry":"# output second vertex"},{"entry":"MOV result. position, vertex[1].position;"},{"entry":"MOV result.texcoord[0], vertex[1].texcoord[0];"},{"entry":"EMIT;"},{"entry":"# output third vertex"},{"entry":"MOV result.position, vertex[2].position;"},{"entry":"MOV result.texcoord[0], vertex[2].texcoord[0];"},{"entry":"MOV result.color, program.local[0];"},{"entry":"EMIT;"},{"entry":"# restartPrimitive would generate ENDPRIM but compiler eliminates it"},{"entry":"END"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The flatAttrib(flatColor) call results in a MOV to result.color for the last vertex (before the third EMIT) because primitive program compiler  is configured to use the provokina vertex convention for OpenGL. For Direct3D, the MOV to result.color would be right before the first EMIT.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 4","FIG. 1B","FIG. 4"],"b":["125","205","135","405","200","410","200","200","420","415","200"]},"When compiling the code shown in TABLE 11A, primitive program compiler  can determine that exactly 3 vertices will be output. In more complex examples, this determination may be more difficult or even beyond the compiler's capability to determine; in such cases, the compiler must make a conservative determination. For example, when \u201ci<position[i].length\u201d in TABLE 11A is replaced with \u201ci<(position.length+position[0].x)\u201d the number of iterations cannot be determined at compile time since the value of position[0].x will vary. Therefore, primitive program compiler  determines a conservative maximum output vertex count, or as previously described, primitive program compiler  may use an explicit default limit provided by the primitive program. Maximum limits may also be determined or specified for the number of vertex attributes that may be output by the primitive program. Any maximum limits are provided to the primitive processor for use during execution of micro-code .","In step  primitive program compiler  determines the input primitive type specified by the primitive input profile modifier for the primitive program entry function. In step  primitive program compiler  determines if the primitive output type is specified by a primitive output profile modifier, and, if so, then primitive program compiler  proceeds directly to step . Otherwise, in step , primitive program compiler  determines that the output primitive type is the same as the input primitive type.","In step  primitive program compiler  determines if flat attributes are specified, and if not, primitive program compiler  proceeds directly to step . Otherwise, primitive program compiler  determines if the target platform API is specified as Direct3D (D3D), and, if so, in step  the leading vertex of each assembled primitive will provide the flat attribute values. Otherwise, the target platform API uses the OpenGL convention, and in step  the last (referred to as provoking in OpenGL) vertex of each assembled primitive will provide the flat attribute values. Primitive program compiler  provides the flat attribute convention information for the target platform API in micro-code  for use during execution of the primitive program. The compiler must also transform the compiler so that the output of flat attributes is deferred until the proper emitVertex call.","In step  primitive program compiler generates micro-code  for execution by target platform . Micro-code  includes the information provided by the translation shown in , e.g., input primitive type, output primitive type, maximum limits for vertices and\/or attributes, and the provoking vertex convention.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 5A","b":["205","200","500","205","505","510"]},"In step  the primitive program instance executes micro-code  to produce emitted vertices. In step  the emitted vertices and strip restarts are collected by the primitive program instance. In step  zero or more output primitives are assembled from the emitted vertices and output to complete execution of the primitive program instance. In step  the assembled primitives may be rasterized using techniques known to those skilled in the art to produce fragments.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 5B","FIG. 5A"],"b":["515","535","536","540","542","540","545","547","2","3"]},"In step  the primitive program instance reads the vertex attributes, parameters, and\/or any temporary registers specified as operands by the primitive program instruction. In step  the primitive program instance executes the instruction by performing the operation specified by the instruction. In step  results of the operations are stored in temporary registers specified as destination operands in the instruction. In step  the primitive program instance determines if another primitive program instruction should be executed, and, if so, returns to step . Otherwise, the primitive program instance proceeds to step  to collect the emitted vertices.","The primitive program shown in TABLE 12 is an example of a primitive program that may be used to perform Hermite curve interpolation. The primitive program shown in TABLE 12 may be compiled to produce micro-code for execution by a primitive processor.",{"@attributes":{"id":"p-0085","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"LINE void hermiteCurve(AttribArray<float4> position : POSITION,"},{"entry":"\u2003\u2003\u2003\u2003\u2003AttribArray<float4> tangent : TEXCOORD0,"},{"entry":"\u2003\u2003\u2003uniform float4 steps) \/\/ # line segments to approx. curve"},{"entry":"{"},{"entry":"emitVertex(position[0]);"},{"entry":"for (int t=1; t<steps; t++) {"},{"entry":"\u2003\u2003float s\u2003\u2003= t \/ steps;"},{"entry":"\u2003\u2003float ssquared = s*s;"},{"entry":"\u2003\u2003float scubed = s*s*s;"},{"entry":"\u2003\u2003float h1 = 2*scubed \u2212 3*ssquared + 1; \/\/ calculate basis function 1"},{"entry":"\u2003\u2003float h2 = \u22122*scubed + 3*ssquared;\u2003\/\/ calculate basis function 2"},{"entry":"\u2003\u2003float h3 =\u2003scubed \u2212 2*ssquared + s;\u2002\/\/ calculate basis function 3"},{"entry":"\u2003\u2003float h4 = scubed \u2212 ssquared;\u2003\u2003\u2003\/\/ calculate basis function 4"},{"entry":"\u2003\u2003float4 p : POSITION = h1*position[0] + \/\/ multiply and sum "},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003all functions"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003h2*position[1] +\u2003\u2003\u2003\u2002\/\/ together to build "},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002the interpolated"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003h3*tangent[0] +\u2003\u2003\u2003\u2003\/\/ point along the curve."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003h4*tangent[1];"},{"entry":"\u2003\u2003emitVertex(p);"},{"entry":"\u2003}"},{"entry":"\u2003emitVertex(position[1]);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The primitive program shown in TABLE 13 is an example of a primitive program that may be used to perform Catmull-Rom spline interpolation. This primitive program receives 4 points as input and interpolates a section of a line between the second and third point. This primitive program uses the LINE_ADJ primitive input profile modifier. Like the primitive program shown in TABLE 12, this primitive program may also be compiled to produce micro-code for execution by a primitive processor.",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"LINE_ADJ void catmullRomSpline(AttribArray<float4> "},{"entry":"position : POSITION,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003uniform float4 steps) \/\/ # line segments to approx. curve"},{"entry":"{"},{"entry":"\u2003emitVertex(position[0]);"},{"entry":"\u2003for (int t=1; t<steps; t++) {"},{"entry":"\u2003\u2003float s\u2003\u2003\u2003= t \/ steps;"},{"entry":"\u2003\u2003float ssquared = s*s;"},{"entry":"\u2003\u2003float scubed = s*s*s;"},{"entry":"\u2003\u2003p = 0.5 *( (2*position[1] ) + ( \u2212position[0] + position[2]) * s"},{"entry":"\u2003\u2003\u2003+ (2*position[0] \u2212 5*position[1] + 4*position[2] \u2212 "},{"entry":"\u2003\u2003\u2003position[3]) * ssquared"},{"entry":"\u2003\u2003\u2003+ ( \u2212position[0] + 3*position[1] \u2212 3*position[2] + "},{"entry":"\u2003\u2003\u2003position[3]) * scubed);"},{"entry":"\u2003\u2003emitVertex(p : POSITION);"},{"entry":"\u2003}"},{"entry":"\u2003emitVertex(position[1]);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Primitive programs may be used to perform a variety of geometry operations including clipping, primitive subdivision, shadow volume generation, cube map rendering, cylindrical texture wrapping, and the like. A primitive program may be used to compute the area of each primitive and subdivide primitive's whose area exceeds a threshold value to improve the rendered image quality. Similarly, a primitive program may compute a value that is a function of the area, such as the sign or twice the area. A primitive program may also be used to compute a facet normal of each assembled primitive. The facet normals may be used to determine when to use flat shading and to perform other shading computations.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 6A","b":["600","610","670","600","610","614","612","612","615","615","612","615"]},"A graphics device driver, driver , interfaces between processes executed by host processor , such as application programs, and a programmable graphics processor , translating program instructions as needed for execution by graphics processor . Driver  also uses commands to configure sub-units within graphics processor . Specifically, driver  may program registers within graphics processor  based on application programming interface (API) imposed limits for nesting levels that specify a maximum stack depth for use during multi-threaded processing.","Host computer  communicates with graphics subsystem  via system interface  and a graphics interface  within a graphics processor . Data received at graphics interface  can be passed to a front end  or written to a local memory  through memory controller . Graphics processor  uses graphics memory to store graphics data and program instructions, where graphics data is any data that is input to or output from components within the graphics processor. Graphics memory can include portions of host memory , local memory , register files coupled to the components within graphics processor , and the like.","Graphics processor  includes, among other components, front end  that receives commands from host computer  via graphics interface . Front end  interprets and formats the commands and outputs the formatted commands and data to an IDX (Index Processor) . Some of the formatted commands are used by programmable graphics processing pipeline  to initiate processing of data by providing the location of program instructions or graphics data stored in memory. IDX , programmable graphics processing pipeline  and a raster operations unit  each include an interface to memory controller  through which program instructions and data can be read from memory, e.g., any combination of local memory  and host memory .","IDX  optionally reads processed data, e.g., data written by raster operations unit , from memory and outputs the data, processed data and formatted commands to programmable graphics processing pipeline . Programmable graphics processing pipeline  and raster operations unit  each contain one or more programmable processing units to perform a variety of specialized functions. Some of these functions are table lookup, scalar and vector addition, multiplication, division, coordinate-system mapping, calculation of vector normals, tessellation, calculation of derivatives, interpolation, and the like. Programmable graphics processing pipeline  and raster operations unit  are each optionally configured such that data processing operations are performed in multiple passes through those units or in multiple passes within programmable graphics processing pipeline . Programmable graphics processing pipeline  and raster operations unit  also each include a write interface to memory controller  through which data can be written to memory.","In a typical implementation, programmable graphics processing pipeline  performs geometry computations, rasterization, and pixel computations. Therefore, programmable graphics processing pipeline  is programmed to operate on surface, primitive, vertex, fragment, pixel, sample or any other data. For simplicity, the remainder of this description will use the term \u201csamples\u201d to refer to graphics data such as surfaces, primitives, vertices, pixels, fragments, or the like.","Samples output by programmable graphics processing pipeline  are passed to raster operations unit , which optionally performs near and far plane clipping and raster operations, such as stencil, z test, and the like, and saves the results or the samples output by programmable graphics processing pipeline  in local memory . When the data received by graphics subsystem  has been completely processed by graphics processor , an output  of graphics subsystem  is provided using an output controller . Output controller  is optionally configured to deliver data to a display device, network, electronic control system, other computing system , other graphics subsystem , or the like. Alternatively, data is output to a film recording device or written to a peripheral device, e.g., disk drive, tape, compact disk, or the like.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 6B","FIG. 6A"],"b":["650","635","650"]},"Samples, such as surfaces, primitives, or the like, are received from IDX  by programmable graphics processing pipeline  and stored in a vertex input buffer  including a register file, FIFO (first in first out), cache, or the like (not shown). The samples are broadcast to execution pipelines , four of which are shown in . Each execution pipeline  includes at least one multi-threaded processing unit, to be described further herein. The samples output by vertex input buffer  can be processed by any one of the execution pipelines . A sample is accepted by an execution pipeline  when a processing thread within the execution pipeline  is available to process the sample. Each execution pipeline  signals to vertex input buffer  when a sample can be accepted or when a sample cannot be accepted. In one embodiment of the present invention, programmable graphics processing pipeline  includes a single execution pipeline  containing one multi-threaded processing unit. In other embodiments of the present invention, programmable graphics processing pipeline  includes a plurality of execution pipelines .","Execution pipelines  may receive first samples, such as higher-order surface data, and tessellate the first samples to generate second samples, such as vertices. Execution pipelines  may be configured to transform the second samples from an object-based coordinate representation (object space) to an alternatively based coordinate system such as world space or normalized device coordinates (NDC) space. Each execution pipeline  may communicate with texture unit  using a read interface (not shown in ) to read program instructions and graphics data such as texture maps from local memory  or host memory  via memory controller  and a texture cache . Texture cache  is used to improve memory read performance by reducing read latency. In one embodiment of the present invention, texture cache  is omitted. In another embodiment of the present invention, a texture unit  is included in each execution pipeline . Alternatively, each execution pipeline  has a dedicated instruction read interface to read program instructions from local memory  or host memory  via memory controller .","Execution pipelines  output processed samples, such as vertices, that are stored in a vertex output buffer  including a register file, FIFO, cache, or the like (not shown). Processed vertices output by vertex output buffer  are received by execution pipelines . Execution pipelines  execute a primitive program to process the vertices and produce primitives. The primitives are output to a primitive output buffer . A raster unit  receives the primitive from primitive output buffer  and performs scan conversion on samples, such as vertices, and outputs samples, such as fragments, to a pixel input buffer . Alternatively, raster unit  resamples processed vertices and outputs additional vertices to pixel input buffer .","Pixel input buffer  outputs the samples to each execution pipeline . Samples, such as pixels and fragments, output by pixel input buffer  are each processed by only one of the execution pipelines . Pixel input buffer  determines which one of the execution pipelines  to output each sample to depending on an output pixel position, e.g., (x,y), associated with each sample. In this manner, each sample is output to the execution pipeline  designated to process samples associated with the output pixel position. In an alternate embodiment of the present invention, each sample output by pixel input buffer  is processed by one of any available execution pipelines .","Each execution pipeline  signals to pixel input buffer  when a sample can be accepted or when a sample cannot be accepted. Program instructions configure programmable computation units (PCUs) within an execution pipeline  to perform operations such as tessellation, perspective correction, texture mapping, shading, blending, and the like. Processed samples are output from each execution pipeline  to a pixel output buffer . Pixel output buffer  optionally stores the processed samples in a register file, FIFO, cache, or the like (not shown). The processed samples are output from pixel output buffer  to raster operations unit .","One characteristic of the system disclosed in  is that it may be configured to embody a SIMD (single instruction multiple data) architecture, where a thread is assigned to each sample processed in the one or more execution pipelines . Therefore, a single program may be used to process several sets of samples. Persons skilled in the art will appreciate that any system configured to perform the method steps of , B, , A, or B, or their equivalents, is within the scope of the present invention.","Primitive programs may be used to perform a variety of geometry operations including clipping, primitive subdivision, shadow volume generation, cube map rendering, cylindrical texture wrapping, curve interpolation, spline interpolation, and the like. Primitive program compiler  may be configured to compile a primitive program and produce micro-code  for a specific target primitive processor based on the target primitive processor's capabilities. Primitive program compiler  also supports features of the high-level primitive program by providing conversions for different API conventions, determining output primitive types, initializing attribute arrays based on primitive input profile modifiers, and determining vertex set lengths from specified primitive input types. Therefore, the high-level primitive program may be written independent of a particular primitive processor or API and micro-code  will be optimized for execution by the particular primitive processor.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The listing of steps in method claims do not imply performing the steps in any particular order, unless explicitly stated in the claim.","All trademarks are the respective property of their owners."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 2B","FIG. 2A"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 2C","FIG. 2A"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 3A","b":["3","3","3","3"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 4","FIG. 1B"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5B","FIG. 5A"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 6B","FIG. 6A"]}]},"DETDESC":[{},{}]}
