---
title: Method of maintaining data consistency in a loose transaction model
abstract: A method, an apparatus, a system, a computer program product, and a computer program are disclosed for maintaining consistency of object content () and metadata () related to the object () in a loose transaction model, preferably using SQL Mediated Object Manipulation (SMOM), for object and meta-data updates. The related meta-data () and a reference to the object () are stored in a table of a database. The object is stored externally to the database in an object store. The reference is used to obtain a handle for directly accessing or manipulating the external object. A version number embedded in the handle is then obtained. The embedded version number is then compared with a version number of a latest committed version of the externally stored object to determine if the handle refers to a current version of the externally stored object. Next, the last modification timestamp of the file is compared with the last modification timestamp of the latest committed version, in order to detect uncommitted updates. A mismatch indicates that stale data is being referenced, and in that situation an appropriate error is returned.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06874001&OS=06874001&RS=06874001
owner: International Business Machines Corporation
number: 06874001
owner_city: Armonk
owner_country: US
publication_date: 20011005
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","1. The Update Model","2. Solution","3. Scenarios Analyzed"],"p":["The present invention relates generally to electronic information technology and more particularly to electronic data management systems.","Content management systems store, access, and manage digital information or content in networked environments, including such information generated in e-business applications. Well integrated content has many applications, and for example, can accelerate business process automation across an enterprise for various sized e-businesses. Relevant content can include electronic documents, text files, XML and HTML files, digital audio and video files, scanned images, facsimiles, and the like.","Content management systems, especially those designed for managing distributed content, may also store meta-data describing an object or related information in a store that is separate from a file containing the object's content. DB2 Universal Database (UDB) is an example of a scalable database that can be used in content management systems as a database management system (DBMS). The DBMS is an essential part of the system for storing digital information or content. Meta-data can be stored in a repository of the DBMS. Examples of meta-data include information about data sources, access authorization, archive and backup histories, data accesses and content identification labels (e.g., video, audio, text).","A particular challenge arising in content management systems is maintaining consistency between file content and the associated meta-data from the point of view of an application accessing the content and meta-data (simply referred to hereinafter as a reader). If file and meta-data updates are tightly coupled (i.e. both updates happen within a single unified transaction), a transaction coordinator typically ensures a consistent view by locking out readers of meta-data as well as file data until the transaction is committed. Intermediate\/uncommitted updates to either are not visible. However, this approach has a number of disadvantages including the circumstance that content edits can require considerable amounts of time. This approach also does not allow the convenience of directly accessing and updating the file content on the native filesystem, using native filesystem operations.","On the other hand, in systems where a loose transaction model is provided, and direct content edits are allowed, consistency between file-data and meta-data may not be guaranteed at all times.","A need therefore clearly exists for an improved technique for providing a consistent view of file data and meta-data in the presence of a loose-transaction model.","Management of External Data Using DATALINKS","Content can be referenced within a database using the DATALINK data type, which is part of the ANSI ISO standard described in document ISO\/IEC 9075-9:2000(E), \u201cInformation Technology\u2014Database Languages SQL\u2014Part 9: Management of External Data (SQL\/MED)\u201d.","Datalinks (DL) is a mechanism that can be used with DB2 UDB, facilitating management of files residing outside of a database as though the files are logically within the database. Datalinks ensures referential integrity of the external files, provides access control for the files, and supports automatic and coordinated backup and restore capabilities. In this manner, a coordinated administration point is provided for file and database data. In the following description, a DATALINK type is referred to for SQL management of external data.","Datalinks maintains a reference to a file residing in a file system in a column of a DB2 table. The reference is stored as DATALINK data type, which uses a Uniform Resource Locator (URL). A table in the database may have one or more DATALINK columns. The database may also store meta-data about the files with DATALINK references in the same table or other tables. Thus, a row may contain a DATALINK reference and meta-data related to the external file. An SQL query or statement issued by an application or reader may be applied against the table on the meta-data, for example, to locate the (external) file of interest. The URL retrieved from the DATALINK column of the row is then used to access the external file via the native API of the file system or browser.",{"@attributes":{"id":"P-00012","num":"00012"},"figref":"FIG. 1"},"Further information regarding the datalink structure shown in  can be found in Section 4.8 \u201cDatalinks\u201d at pages 31-35 in the ANSI ISO standard of ISO\/IEC 9075-9:2000(E), \u201cInformation Technology\u2014Database Languages SQL\u2014Part 9: Management of External Data (SQL\/MED)\u201d.","DataLinks supports two modes of \u201cWRITE PERMISSION\u201d:FS (File System) or BLOCKED. In the FS case, users are allowed to update a file while the file is linked to the database (i.e. the database has a DATALINK value which is currently pointing to the file). However, this mode does not provide file data recovery, which means if the disk crashes or a user needs to restore the database, there is no file backup data to recover from. This could cause inconsistency between the file data and the database data after RESTORE\/ROLLFORWORD to a point in time other than the time of the crash. Moreover, WRITE PERMISSION FS does not support the SQL mediated access model like the one provided in READ PERMISSION DB.","On the other hand, WRITE PERMISSION BLOCKED provides data recovery for a file with a reference in a DATALINK column. However, a user cannot update the file while the file is currently linked. In order to modify the file, the user has to unlink the file in one transaction, modify the content and link the file in another transaction. So between the two transactions, the file is not linked, which means it is not under the control of the database (DataLinks) and the file reference is not visible in the database.",{"@attributes":{"id":"P-00016","num":"00016"},"figref":"FIG. 4","b":["100","80","20","80","80","50","20","75","80","75"]},"The database  stores an employee table  including a name column , a department column , and a picture column . The name column  typically contains a string, the department column an integer, while the picture column would contain a reference to an image stored in one of a number of external data files . The external data file  may also contain other forms of data, including documents, presentations, engineering drawings, spreadsheets, or video clips.","It would be undesirable for any one of the external data files  to get deleted, modified, or renamed while that external data file  continues to be referenced by the database , and in particular the picture column . A Datalinks File Manager (DLFM)  is therefore provided for maintaining a table (not illustrated) of linked file references. The DLFM  may also be responsible for controlling access permission and ownership of the external data files . The table maintained by the DLFM  contains attributes and subsets of the data stored in the external data files , along with logical references to the location of the external data files .","In operation, an application program  searches the database  via a SQL Application Programming Interface (API) request  to identify database entries  of interest. In the example illustrated in , this typically occurs when an employee record is viewed and there is a requirement for the image of the employee to be displayed with his\/her other information.","The DBMS  is responsible for managing the links between the database  and the data files  and provides to the application  references to the selected external data files  via a handle. An example of the DBMS  is the DB2\u2122 Universal Database product of International Business Machines Corporation. The application  can now access the external data file  directly using standard file-system API calls . Typical file-system API calls  are \u201cfile-open\u201d, \u201cfile-read\u201d and \u201cfile-delete\u201d.","A Datalinks File System Filter DLFF  is a thin, database control layer or filter on the file system . The DLFF  intercepts certain of the file-system API calls  issued by the application . The file-system API calls  that are intercepted include file-open, file-rename, and file-delete calls. If the external data file  is referenced in the database , the DLFF  is responsible for enforcing referential-integrity constraints and access-control requirements defined for the data file . The referential integrity constraints ensure that the reference to data files  remains valid as long as it is \u201clinked\u201d to the database . DLFF  also ensures that any access call  meets Database Management System (DBMS)  access control requirements. An example of SQL mediated access is in the use of an authorization token, which is generated by the DBMS as part of the handle and verified by DLFF.","The DLFF  validates any authorization token (not illustrated) embedded in the file pathname for a \u2018file-open\u2019 operation. For example, when a user of application  submits a SQL API Request  to retrieve the employee picture (image) from the database , the DBMS  checks to see if the user has permission to access the employee table  containing the picture column . The permission may include select and view privileges on the employee table . The DBMS  returns the file name of the external file  to the application  only if the user has the required permission. An authorization token is embedded in the file name as part of the value returned for the picture column  by the DBMS . The application  then uses the file API call  to retrieve the image from the external file . When the DLFF  intercepts the file-open request, the DLFF  validates the authorization token to determine whether or not to pass the file-open request through to the native file system . If the validation fails, the file-open request is rejected. Once access has been authorized by a valid token, the application  interacts directly with the file system  for delivery of the external file  without the need for the DLFF  to further control the file access. This allows the application  the same speed of access as to a native file system.","In accordance with a first aspect of the invention, there is provided a method of maintaining consistency of content of an object and meta-data related to the object in a loose transaction model for object and meta-data updates. The method includes the steps of storing the related meta-data and a reference to the object in a table of a database, the object being stored externally to the database in an object store, the reference used to obtain a handle for directly accessing or manipulating the external object; obtaining a version number embedded in the handle and comparing the embedded version number with a version number of a latest committed version of the externally stored object to determine if the handle refers to a current version of the externally stored object.","Preferably the method further includes the steps of, if the encoded version number and the version number of the latest committed version match, comparing a last modification time stamp of the object with a last modification time stamp for the latest committed version of the object; and if the last modification time stamp of the object matches with the last modification time stamp for the latest committed version of the object, permitting access to the externally stored object. The method may further include the step of, if the last modification time stamp of the object does not match with the last modification time stamp for the latest committed version of the object, generating an error to indicate that the handle refers to stale content in the object.","Preferably the method further includes the steps of updating the object in-place under either DBMS control or file system control and linking the meta-data and the object under DBMS control.","Preferably the method further includes wherein the loose-transaction update model uses SQL Mediated Object Manipulation (SMOM) for an object that resides external to the database.","Preferably the method further includes the step of intercepting a native access to the externally stored object or a file system and validating the caller's access rights based on a combination of the version number and a last modification time stamp for a version of the object. The method may further include the intercepting step being carried out using a filter layer of the object store for the stored object.","Optionally, the object store is a local file system, or a distributed file system, the object being accessed from a remote file system client. A file access which occurs in the presence of authoritative caching and the comparing steps may be performed at the file system client. The method may further include the steps of caching the last known version number and the corresponding last modification time stamp at the file system client after an access and refreshing the last known version number and the corresponding last modification time stamp with latest values from a file server the next time one or both of the comparisons fail with the previously cached values, in which case the comparing steps are retried with refreshed values.","Preferably the method further includes the object which is a file.","Preferably the method further includes the version number associated with the object is embedded in an access token.","Preferably the method further includes the version number is temporally unique.","Preferably the method further includes the last-modification-time stamp attribute associated with the object is maintained by the object store.","In further aspects of the invention, an apparatus, a computer program, a computer program product, and a system for maintaining meta-data and file-data consistency in a loose transaction model of object and meta-data updates are provided.","A method, an apparatus, a computer program, a computer program product and a system for maintaining (or ensuring) meta-data and object-data consistency in a loose transaction model of object and meta-data updates, from the perspective of a reader application, are described hereinafter. Preferably, the object may be a file and an object store may be a file system. In the following description, numerous details are set forth. It will be apparent to one skilled in the art, however, that the present invention may be practised without these specific details. In other instances, well-known features are not described in detail so as not to obscure the present invention.","With the embodiments of the invention, allowing file content to be accessed and updated in-place by directly accessing the file system natively is more convenient. Besides, since content edits can be relatively long running, a loose transaction model for file and meta-data updates is useful where the file can be edited independently of the meta-data. A user can update a file while it is currently linked. In addition, the meta-data for that file can be accessed by other users while the file is in the process of being updated. The meta-data is always visible, even while the file is being update. However, access to the file may be denied. SQL mediated access can be extended to allow update-in-place. Specifically, the WRITE PERMISSION clause in  can be extended to achieve this.","The embodiments of the invention address the noted problem in the context of meta-data maintained in a database table associated with an external file reference to content that is stored in a file system or an object store external to the database.","Generally, a file update takes longer than meta-data updates or typical database transactions. In a typical update, access to the file is requested and the file is locked. The content of the file is modified as well as corresponding meta-data generated. The file is then unlocked (i.e., the file update is declared to be completed) and the meta-data is imported into the database. Changes to the content of the file happen outside a regular DB2 transaction.","In particular, the problem addressed by the embodiments of the invention is ensuring that a reader application always gets a consistent view of the content of a file and the meta-data related to the file, given a loose transaction model for file and meta-data updates. An error can acceptably be returned in situations where the file data being accessed is not consistent with the corresponding meta-data seen by the reader.","Solutions are provided by the embodiments of the invention, firstly for files accessed from a local file system . This is then extended to a distributed file system environment  for files accessed from remote file system clients in the presence of authoritative caching.",{"@attributes":{"id":"P-00048","num":"00048"},"figref":"FIG. 6","b":["700","710","722","720","732","730","720","724","722","724","726","724","728","730","760","770","760","734","736","740","724","720","736","730","740","770","750","710","732","750","752","738","736","752","754","754","756","760"]},{"@attributes":{"id":"P-00049","num":"00049"},"figref":["FIG. 7","FIG. 6"],"b":["800","810","822","820","832","830","800","880","820","830","820","720","724","824","7","860","830","890","832","810","850","870","830","850","852","838","890","860","852","854","830","854","856"]},"The file server  includes a local repository  and a file manager daemon . A control path  bi-directionally extends between the DBMS  of the meta-data server  and the file manager daemon  of the file server . Likewise, the file manager daemon  of the file server  is bi-directionally coupled with the proxy daemon  of the client . The file server  also includes a distributed file system server . The distributed file system server  is coupled to a file server store . The distributed file system server  of the file server  is bi-directionally coupled (indicated by dashed line) to the distributed file system client  of the client .","The file is updated using normal file system application program interfaces (API's) , . The file can be updated via SQL Mediated Object Manipulation (SMOM) where a handle is obtained from the mediator , , that is preferably a filename with an encrypted access token string embedded as part of the filename, and is supplied as the filename to the filesystem API. The file may be updated several times before the file's meta-data is updated in the database , . To effect the corresponding meta-data updates and relate those updates to the file updates, the user issues an SQL update through the mediator DBMS , , optionally passing in the object handle, and commits both file and meta-data updates together. Another possibility is that the file may be updated based on the filesystem permissions. To effect the corresponding meta-data updates and relate those updates to the file updates, the user issues an SQL update through the mediator DBMS , , and commits both file and meta-data updates together.","Preferably, a filter layer ,  transparently intercepts native access to the external object store or file system ,  and , making use of the embodiments of the invention, to allow or deny access to the object based on a combination of an implicit version number and the last modification timestamp for a given version. This is done to validate the consistency of the meta-data retrieved by the reader and the content of the file.","The file edits happen outside of the DB transaction. The file updates get committed to the database (DB) via the DBMS ,  once the update is done. DBMS ,  communicates with the file management mediator daemon (also referred to as DLFM in the Datalinks product) ,  passing a version number or generation number associated with the file, which is temporally unique on every committed update to the file. The file management mediator daemon ,  utilizes a local repository (i.e. local to the fileserver node) ,  to store the version number attribute of the file. (The repository ,  could be a local database, as is the case of the embodiment implemented as part of the DB2 Datalinks product). The file management mediator daemon ,  also saves a last modification timestamp attribute of the file maintained natively by the file system (or external store) as the last modified time of the latest committed version of the file.","This file management mediator daemon ,  utilizes the local repository ,  (i.e. local to the fileserver node) to store the attributes of these objects at the time of their association with the DB, and at the time of committed updates. (Again, the repository could be a local database, as is the case of the embodiment implemented as part of the DB2 Datalinks product)","The solution provided by the embodiments of the invention extends the functionality of this filter layer ,  and the associated file management mediator daemon ,  to ensure file-data meta-data consistency. The solution returns an error for file accesses where the file content are no longer consistent with the meta-data associated with the handle being used to reference the object. Preferably, the error code is ESTALE in the Unix operating system.","2.1 Observation","It may be observed that the token (embedded in the handle used to reference the object) becomes obsolete in the following situations:\n\n","These uncommitted file updates may have happened after the token is generated, or may have been pending from before the token generation. In this case, the meta-data in the table at the time the token was generated corresponds to the last committed file data and does not reflect uncommitted file updates that happened before the token was generated.","Such uncommitted file updates can happen via a re-linking of the same file (after an unlink and a change in content via a rename or a write to the file), or through an SQL Update commit for an update-in-place. There are two cases here:\n\n","The access token preferably contains a one-way hash value, h which is computed as follows:\n\n=hash(, file name, servername, token length, flags),\n\nwhere K is a secret symmetric key and Tx is the expiration time and the flags contain information about the token including which type of access is granted. Tx, token length and flags are also passed as part of the token. For cases where consistency is to be maintained between the DBMS meta-data and the object, the token can be setup to contain a version number and a different one-way hash value, H, computed as:\n\n=hash(, file name, server name, token length, flags, ),\n\nwhere Vc is the latest committed version at which the token is created and flags can contain information indicating that consistency is requested.\n","On the file manager side  for token validation, the file system filter  passes the token up to the file manager daemon . If the flags indicate that consistency is requested, the daemon  validates the token by calculating H where Vc is obtained from the last committed version number stored in the daemon's repository tables. The daemon  checks that the token has not expired and compares H with the one way hash contained within the access token.","Steps  and  in the previous section may be modified to just use the one-way hash value as the basis for checking for a version number match, instead of requiring that the version number be extracted from the token\/handle. Step  could instead just retrieve the hash function portion of the token, H(token) and compute the one-way hash value H(commit) corresponding to V(commit), while the comparison for detecting staleness in step  may be replaced by \u201cif H(token)\u2260H(commit)\u201d.","A content management system is described with reference to . In particular,  are block diagrams illustrating the content management system . The content management system includes a database , preferably a DB2 UDB, and a file system . The database  contains one or more tables  (only one is shown to simplify the drawing). Again to simplify the drawing, the table is shown with only two rows and two columns. However, these numbers are for purposes of illustration only and differing numbers of columns and rows may be practiced. Column  (\u201cCOL\u201d) contains meta-data that is searchable, and column  (\u201cDL\u201d) is the DATALINK type column enabled with options to provide in-place updating of a DATALINKed file, token-based access control on a write operation, and file data recovery.","The table  may contain more than one DATALINK column. The entry for the first row has \u201c1000\u201d in column  and URL' in the DATALINK column DL. The second row has \u201c1019\u201d in column  and NULL in column DL. As indicated by a dotted line, URL' in row  of the table  refers to file  in the file system . The file  is stored externally to the database , and the content of the file  may include electronic documents, text, XML and HTML, digital audio and video, scanned images, facsimiles. The foregoing are merely examples of the type of the file . Other file types may be practiced without departing from the scope and spirit of the invention.","The content management system  also includes a DB2 agent  coupled to the database , a Data Link File Manager (DLFM) , and a Data Link File System Filter (DLFF) . An application  is a reader in the system  of FIG. .","The operation of the content management system  is described with reference to the flow diagrams of , B and C illustrating the control process . The numbered arrows of  extending between elements shown in that drawing have counterpart steps shown in  to describe the operation of the system . The control process includes steps - and -.","With reference to , arrow  extends between application  and DB2 agent . In step  of , the application  requests a write access token from the DB2 agent  via a SQL SELECT statement.","Arrow  extends from DB2 agent  to application . In step , a write access token is returned. The write access token includes a hash value that encodes the latest version number. Arrow  extends between the application  and DLFF . The application  opens the file for a write operation using a write access token via the DLFF . Arrow  extends from the DLFF  to the DLFM . The DLFF  forwards the write access token to the DLFM  for token validation. If the token is valid, then DLFM also checks if the file-data is consistent with the meta-data corresponding to the token. Arrow  extends from the DLFF module  to the application . In step  of , the file system returns the file descriptor to the application .","Arrow  extends from the application  to the file  in the file system . In step , the application  modifies the file  using the file descriptor. Arrow  extends from the application  to the DB2 agent module . In step , once the file update is completed, the application  issues a SQL UPDATE to the database DB2  via the DB2 agent  and imports other meta-data into the database. Arrow  extends from the DB2 agent  to the DLFM  in FIG. A. In step , the DB2 agent  invokes a DB2-DLFM update API and update the DLFM meta-data. At this stage, the DLFM determines the last modification timestamp of the file (same as the Tm(commit)) and records that timestamp in its local repository along with the updated version number (same as the link recovery id).","With reference to , an arrow  extends from the application  to the DB2 agent . In step , a SQL COMMIT is issued by the application  to the DB2 agent . An arrow  extends between the DB2 agent  and the DLFM . In step  of , a PREPARE statement is sent to the DLFM  by the DB2 agent . An arrow  extends from the DLFM  to the DB2 agent . In step , the DLFM  hardens the DLFM meta-data and replies OK to the DB2 agent . Harden means guaranteeing that local repository modifications made by the DLFM for the file are remembered persistently (i.e., locally committing\/hardening the information). An arrow  extends between the DB2 agent  and the DLFM . In step , a final COMMIT statement (phase ) is sent to the DLFM  by the DB2 agent . This completes the control process.","In the case of a read operation, the flow is as follows. The application  requests a read access token from the DB2 agent  via a SQL SELECT statement. A read access token is returned. The read access token includes a hash value that encodes the latest version number. The application  opens the file for a read operation using a read access token via the DLFF . The DLFF  forwards the read access token to the DLFM  for token validation. If the token is valid, then DLFM also checks if the file-data is consistent with the meta-data corresponding to the token. This is how the DLFM performs the check. The DLFM looks up the latest committed version number V(commit) and the corresponding modification timestamp Tm(commit) in its local repository (R). Then the DLFM determines if the version number embedded in the token, i.e. V(token) matches V(commit) (preferably by computing the one-way hash value corresponding to V(commit) and comparing it with the hash value embedded in the token). In case of a mismatch, the DLFM returns an error to DLFF. Otherwise, the DLFM obtains the last modification timestamp of the file Tm(access) from the filesystem, and determines if Tm(access) is later than Tm(commit). If so, then the DLFM has detected an inconsistency and returns an error to DLFF, which reports ESTALE to the application. If not, then the DLFM returns OK and DLFF returns success. The file system returns the file descriptor to the application  for a successful open. The application  reads the file  using the file descriptor.","2.3 Extension to a Distributed File System Environment","A further embodiment of the invention extends the above solution to a distributed environment  of  for accesses to the file from distributed file system clients while minimizing performance overheads in communication with the central file server  where the file manager daemon's repository  is located, especially in situations where the file system client  is likely to service accesses from the client's cache without connecting to the server . The distributed file system  is assumed to implement its own cache coherency mechanisms.","A proxy daemon  may be set up at each client  to service upcalls  from the filter module , which intercepts file accesses on the client . This proxy daemon  contacts the central server \/repository  when required. As described hereinbefore, the requirement is to minimize these contacts, especially for read performance in the most typical cases (i.e. repeated accesses to the same file should be servicable from the cache without contacting the server as far as possible).","First Time Access","The first time a file is accessed with a token at the client, the client proxy daemon  contacts the remote central repository  and makes an entry in a local (possibly in-memory) table with:\n\n","The check for stale data is:\n\nis_stale=((token)\u2260(commit))OR((access)\u2260(commit)).\n\nCached Case (Repeated Accesses):\n","The next time the same file is accessed (either with the same or a different token), the proxy daemon  can simply look up the proxy daemon's local table entry and if Fid(access)=Fid(commit), then the proxy daemon  can use the in-memory entry to perform the above check.\n\n","Fid(commit) and Fid(access) refer to the file-id value at the time of commit and time of access respectively, i.e. Fid(commit)=value of Fid (Filename, Tm(commit)) where Fid(f,t)=value of unique file id of the file named \u201cf\u201d at time \u201ct\u201d.","The reason for explicitly introducing these in the distributed case, is to correctly handle cases where the file may have been unlinked, renamed and relinked under the same name (as in Scenario 2). By indexing V(commit) and Tm(commit) against Fid(commit) in the local in-memory table, and looking up the cached entry against Fid(access). This ensures that the version number and Tm values refer to the same file, so that a comparison with Tm(access) makes sense. This is important in the distributed case, because the cached value of V may be stale, making Tm(access) the real determinant of whether the entry should be considered stale or not.","The unique file id maintained by a distributed filesystem usually includes some kind of per inode generation number of its own to account for reuse of inode numbers after files are deleted. This inode generation number is typically incremented every time an inode number is reassigned to a newly created file. This ensures the temporal uniqueness of a file identifier.","Just as in the local case, if Tm(access)>Tm(commit) and the token is a write token, an optional step of checking the file if an update-in-progress with the same token\/user may be involved (e.g. by checking state information in the repository).","This approach causes the client to contact the central repository on the server only if the file changed or got relinked since the last time the entry was looked up. The in-memory table entries can be flushed\/reused based on the expiration time and resource limits.",{"@attributes":{"id":"P-00113","num":"00113"},"figref":["FIG. 5B","FIG. 7"],"b":["656","660","660","664","660","662","882","660","664","666","666","672","666","668"]},"In step , the current value of the timestamp Tm(access) is obtained from the file. In decision block , a check is made to determine if the timestamp Tm(commit) is equal to Tm(access). If decision block  returns false (NO), processing continues at decision block . If decision block  returns true (YES), the file and meta-data are consistent, the variable refreshed is set to false, and access is allowed to the object in step .","In decision block , a check is made to determine if the cache was accessed (i.e. REFRESHED equals false). If decision block  returns true (YES), processing continues at block . Finally, if decision block  returns false (NO), the meta-data and file data are inconsistent and an error is returned in step .","This section discusses various key scenarios and how the embodiments handle each of these situations to prevent potential inconsistencies from arising.","Initial Assumption:","It is sufficient to guarantee the consistency at the point of the file\/object open. The user is expected to use some form of file\/application-level locking as in a normal file system to ensure serialization between concurrent readers and updaters. Specifically, an updater must not start its updates if there is any reader that has opened the file. Otherwise, the reader could see inconsistent data. Table 1 is a legend of terminology used hereinafter.",{"@attributes":{"id":"P-d0e3887","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Term","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Qr(f, t)","user does a SQL query and an access token for a file f is"]},{"entry":[{},"assigned at time t."]},{"entry":["Qw(f, t)","user does the SQL query for a write token and the write token"]},{"entry":[{},"for the file f is assigned at time t."]},{"entry":["C(f, t)","Content of the file f at time t."]},{"entry":["Rs(f, t)","time when the reader opens the file f with access token for"]},{"entry":[{},"generated at t."]},{"entry":["Re(f, t)","time when the reader closes the file f (finished reading the file)"]},{"entry":[{},"corresponding to Rs(f, t)."]},{"entry":["Us(f, t)","time when the writer opens the file f for update using the write"]},{"entry":[{},"token generated at t."]},{"entry":["Ue(f, t)","time when the writer closes the file f (i.e. finishes writing the"]},{"entry":[{},"file) corresponding to Us(f, t), but not yet committed to the"]},{"entry":[{},"database (DB) using SQL update."]},{"entry":["Uc(f, t)","time when meta-data in DB is updated and committed together"]},{"entry":[{},"with the file-data updates for the file f."]},{"entry":["I(f)","time when the file f is linked (inserted into) to the database."]},{"entry":["D(f)","time when the file f is unlinked (deleted) from the database"]},{"entry":[{},"(restore on unlink)."]},{"entry":["Us(f)","time when the writer opens the file for an update without a"]},{"entry":[{},"token."]},{"entry":["Ue(f)","time when the writer closes the file (finishes writing the file)"]},{"entry":[{},"corresponding to Us(f)."]},{"entry":["M(f\u2032, f)","time when the file f\u2032 is moved to f (could be rm f, mv f\u2032 f)"]},{"entry":[{},"results in f getting replaced by f\u2032 \u2212 both data + attributes"]},{"entry":[{},"(including timestamp) C(f, ta) <= C(f\u2032, tb), where ta < M(f\u2032, f) <"]},{"entry":[{},"tb."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The application is responsible for ensuring serialization, so that Rs-Re essentially happens under a shared file lock and Us-Ue happens under an exclusive file lock. However, multiple Us-Ue iterations can happen before Uc to finally commit the update, and an Rs-Re can happen between two such Us-Ue sequences.\n\n","As in scenario (1) above, with the embodiments of the invention, Rs(f,t) fails since V(token)<V(commit), i.e., the version-id embedded in the read-token is earlier than the one in I(f). In the distributed file system case, where the client's in memory table has a stale value of V(commit) and Tm(commit), the condition [Tm(access) for f\u2032>Tm(commit) for f] may not suffice to detect stale information. However, the check Fid(access)=Fid(commit) fails, and a refresh of the values of V(commit) and Tm(commit) from the server is triggered.\n\n","The file data consistent with Qr(f,t) is C(f,I(f)) or C(f,t), but not C(f,t) since the meta-data has not changed yet at t but only after that. C(f,Rs(f,t)) differs from C(f, t) as the file content has been updated between t and t.","With the embodiments of the invention, Rs(f,t) fails since V(token)<V(commit).","Another case that can be considered equivalent to the above for current purposes is:\n\nI(f); Qw(f,t); Us(f,t); Qr(f,t); Ue(f,t); Uc(f,t); Rs(f,t).\n","With the embodiments of the invention, Rs(f,t) fails since V(token)<V(commit).\n\n","With the embodiments of the invention, Rs (f,t) fails since V(token)<V(commit).\n\n","As the foregoing embodiments of the invention illustrate, a loose transaction model for updates to a file and its corresponding meta-data through a mediator is useful for directly performing in-place edits of content data residing on stores external to the indexed meta-data store (the latter could be a DBMS). This is subject to the requirement of ensuring consistency between the file content and the associated meta-data from a reader's perspective. The embodiments of the invention encode a version number in the handle for referencing the object associated with a given meta-data state. A thin interceptor layer on the native store, where the objects content are stored, decodes this version number and compares the decoded version number with the version number of the latest committed version of the file. This is done to determine if the handle refers to the current version. If the version matches, the thin interceptor layer checks for uncommitted updates by comparing the last modification time stamp of the file with the last modification timestamp for the latest committed version. If these match, the thin interceptor layer allows access to proceed as usual for the file. Otherwise, the thin interceptor layer reports an error indicating that the handle refers to stale data.","The embodiments of the invention are advantageous in a number of ways. The embodiments enable in-place updates of file content to be made directly on the file system, which is separate from the meta-data store. This is done while ensuring that a reader application does not see an inconsistency between the meta-data and the file data. Another advantage is that the consistency check on file access can be performed without contacting the meta-data server, which is separate from the meta-data store. This results in fast content access times even when the file and meta-data servers are distributed.","Advantageously, this approach is suitable for a distributed model for file and meta-data storage, since the file content access path checks do not require any direct communication with the meta-data server. This approach extends easily to a configuration where the external store is a distributed file system and the content is accessed directly from distributed file system clients. This works even in the presence of authoritative caching (as in DCE-DFS) with minimal communication overheads and does so using an entirely client initiated approach, without any client specific state being required to be maintained on the servers. The approach may be enhanced to work correctly (in terms of preventing accesses to potentially inconsistent data) with mobile file systems (e.g., Coda or Intermezzo) that operate in disconnected mode. The consistency check makes efficient use of caching for improved performance without losing correctness.","Further, the method described does not require clock synchronization between the database server and the filesystem server, and even with the filesystem client in the distributed filesystem case. Note that even in the scenario where the clocks are synchronized, it is not efficient for the DB server to save the time when the latest update was committed, T(Commit) (instead of V(commit)), and provide it to the mediator daemon at transaction commit to save the same (T(commit) value) for the corresponding files in the local repository on the file server. The reason is that this would require the database server to track all the rows involved in the linkfile operation for a particular transaction, update them prior to doing its commit processing with the T(Commit) value, and the same would have to be done at the file management daemon's end.","The solution is capable of covering cases where the database has been rolled back to an earlier state, as might happen in the case of a point-in-time restore, and should also work with database replication, as long as the legitimacy of the last modified timestamp of the file is maintained during a restore and across replicas.","The embodiments of the invention are preferably implemented using one or more general-purpose computers. In particular, the processing or functionality of  and - can be implemented as software, or a computer program, executing on the computer(s). The method or process steps for maintaining (or ensuring) meta-data and file-data consistency in a loose transaction model of file and meta-data updates, especially for use with an application or reader, are effected by instructions in the software. The software may be implemented as one or more modules for implementing the process steps. A module is a part of a computer program that usually performs a particular function or related functions. Also, a module can also be a packaged functional hardware unit for use with other components or modules.","In particular, the software may be stored in a computer readable medium, including the storage devices described below. The software is preferably loaded into the computer from the computer readable medium and then carried out by the computer. A computer program product includes a computer readable medium having such software or a computer program recorded on it that can be carried out by a computer. The use of the computer program product in the computer preferably effects advantageous apparatuses for maintaining (or ensuring) meta-data and file-data consistency in a loose transaction model of file and meta-data updates.","Preferably, a computer system includes a computer, a video display, and input devices. In addition, the computer system can have any of a number of other output devices including line printers, laser printers, plotters, and other reproduction devices connected to the computer. The computer system can be connected to one or more other computers via a communication interface using an appropriate communication channel such as a modem communications path, a computer network, or the like. The computer network  may include a local area network (LAN), a wide area network (WAN), an Intranet, and\/or the Internet.","The computer itself consists of a central processing unit(s) (simply referred to as a processor hereinafter), a memory which may include random access memory (RAM) and read-only memory (ROM), input\/output (IO) interfaces, a video interface, and one or more storage devices. The storage device(s) can consist of one or more of the following: a floppy disc, a hard disc drive, a magneto-optical disc drive, CD-ROM, magnetic tape or any other of a number of non-volatile storage devices well known to those skilled in the art. Each of the components is typically connected to one or more of the other devices via a bus that in turn can consist of data, address, and control buses.","The foregoing system is simply provided for illustrative purposes and other configurations can be employed without departing from the scope and spirit of the invention. Computers with which the embodiment can be practiced include IBM-PC\/ATs or compatibles, one of the Macintosh (TM) family of PCs, Sun Sparcstation (TM), a workstation or the like. The foregoing are merely examples of the types of computers with which the embodiments of the invention may be practiced. Typically, the processes of the embodiments, are resident as software or a program recorded on a hard disk drive as the computer readable medium, and read and controlled using the processor. Intermediate storage of the program and intermediate data and any data fetched from the network may be accomplished using the semiconductor memory, possibly in concert with the hard disk drive.","In some instances, the program may be supplied to the user encoded on a CD-ROM or a floppy disk, or alternatively could be read by the user from the network via a modem device connected to the computer, for example. Still further, the software can also be loaded into the computer system from other computer readable medium including magnetic tape, a ROM or integrated circuit, a magneto-optical disk, a radio or infra-red transmission channel between the computer and another device, a computer readable card such as a PCMCIA card, and the Internet and Intranets including email transmissions and information recorded on websites and the like. The foregoing are merely examples of relevant computer readable mediums. Other computer readable mediums may be practiced without departing from the scope and spirit of the invention.","In the foregoing manner, a method, an apparatus, a computer program, a computer program product, and a system for maintaining (or ensuring) meta-data and file-data consistency in a loose transaction model of file and meta-data updates are disclosed. While only a small number of embodiments are described, it will be apparent to those skilled in the art in view of this disclosure that numerous changes and\/or modifications can be made without departing from the scope and spirit of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A small number of embodiments of the invention are described hereinafter with reference to the drawings, in which:",{"@attributes":{"id":"P-00035","num":"00035"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00036","num":"00036"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"P-00037","num":"00037"},"figref":["FIGS. 3A","FIG. 2"],"b":["3","3"]},{"@attributes":{"id":"P-00038","num":"00038"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00039","num":"00039"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"P-00040","num":"00040"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00041","num":"00041"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
