---
title: Coverage analysis of message flows
abstract: A method for assessing adequacy of message flow testing, including defining coverage criteria for testing a message flow through a set of message flow elements, determining a message-flow-coverage-goal for the message flow with respect to the coverage criteria, and designing a test suite responsive to the message-flow-coverage-goal. The method further includes applying the test suite to the message flow to generate a coverage result for the set of message flow elements and comparing the coverage result with the message-flow-coverage-goal.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07137103&OS=07137103&RS=07137103
owner: International Business Machines Corporation
number: 07137103
owner_city: Armonk
owner_country: US
publication_date: 20020307
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["This application claims the benefit of U.S. Provisional Patent Application No. 60\/274,320, filed Mar. 8, 2001, which is assigned to the assignee of the present invention and which is incorporated herein by reference.","The present invention relates generally to testing software, and specifically to testing visual message flows.","Many types of software have been identified in the field of software engineering, though no single taxonomy system is yet universally accepted. It is common to refer to types of software according to programming and architectural paradigms known in the art. In an article entitled \u201cLanguage and Architecture Paradigms as Object Classes: A Unified Approach Towards Multiparadigm Programming\u201d by Spinellis, et al., published in , pages 191\u2013207, by Springer-Verlag in 1994, and which is incorporated herein by reference, the authors define a paradigm as \u201ca category of entities sharing a common characteristic.\u201d In the context of software, Spinellis, et al. note that \u201c[c]omputer language paradigms offer linguistic abstractions . . . for expressing program implementations. Similarly, system architectures offer the hardware abstractions and quantitative theories applicable to the execution of compiled programs.\u201d The authors go on to describe a number of properties which may be used to characterize different paradigms, e.g., the property of problem decomposition entity. The problem decomposition entity is the primary architectural entity in a paradigm, i.e., the principal unit used to characterize and implement an application. In the case of an object-oriented system, for example, objects comprise the primary architectural element, and are used to model and implement the software.","Object-oriented, procedural, logical, component-oriented, visual, agent-oriented, and concurrent software are only a few examples of architectural and programming paradigms known in the art. Moreover, because many of the paradigms are overlapping and independent, a software application may be described in terms of a plurality of paradigms. For example, a given application may be at once object-oriented, visual, concurrent, and component-based.","In an article titled \u201cToward an Execution Model for Component Software,\u201d by Michael Franz, published in 10-96, pages 144\u2013149, Linz, 1996, and which is incorporated herein by reference, the author states that \u201c[w]hen discussing different programming paradigms, we usually base our taxonomy on the underlying design methodology, or, less subtly, on the programming language being used in a design. Strangely enough, this is no longer true when it comes to component-oriented programming.\u201d Franz further suggests that the programming model, distribution model, and execution model are useful properties in the classification of types of software including component-oriented software.","Software designers typically select one or more programming and architectural paradigms in the design and implementation of an application. Many criteria exist in the art for selecting a paradigm, including compatibility with an existing system, cost of development and testing, cost of long-term maintenance, and similarity of the paradigm to the underlying application problem. As Spinellis, et al. observe \u201c[i]t is widely accepted that each paradigm offers a different set of tradeoffs between efficiency, provability, elision, and implementation cost.\u201d","A software paradigm identified in the art is message-oriented software. Message-oriented software treats messages as the primary architectural element, or the problem decomposition entity, according to Spinellis, et al. Applications are defined in terms of message flows, i.e., incoming and outgoing messages, and the processing performed on the messages. While the message-oriented paradigm is applicable to a wide range of business problems, the paradigm is especially compatible with a class of software applications known in the art as message-oriented middleware (MOM).","In an article titled \u201cMessage-Oriented Middleware\u201d by Vondrak, published in the -which can be found at http:\/\/www.sei.cmu.edu\/str\/descriptions, and which is incorporated herein by reference, MOM is defined as \u201ca client\/server infrastructure that increases the interoperability, portability, and flexibility of an application by allowing the application to be distributed over multiple heterogeneous platforms. It reduces the complexity of developing applications that span multiple operating systems and network protocols by insulating the application developer from the details of the various operating system and net interfaces. Application Programming Interfaces (APIs) that extend across diverse platforms and networks are typically provided by the MOM.\u201d In other words, MOM is software that focuses on the interface between applications in a distributed environment, possibly on a variety of platforms. MOM implements inter-application communication as a separate function, independent of the communicating applications. Thus, in a world of diverse systems, developed in different languages, using different paradigms, and running on different hardware, MOM facilitates interaction among the diverse systems. This capability is especially significant for organizations with a varied collection of legacy systems; further, it provides a way to integrate new systems, e.g., a system acquired as a result of a merger or acquisition, without substantial investment. A plurality of implementations of MOM exist in the art, for example, the MQSeries produced by IBM Corporation of Armonk, N.Y., and Tuxedo by BEA Systems, Inc. of San Jose, Calif.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1","b":["10","10","12","18","24","14","20","26"]},"Client programs typically implement system functions visible to a user of the system, e.g., displaying results of a query or recording a new transaction. Server programs comprise programs providing services to client programs. Server programs supply a range of services, including access to a centralized resource such as a database, calculations, and communications services.","Client program A, client program B, and server program C are implemented using one or more of a plurality of programming and architectural paradigms known in the art. Client program A, client program B, and client program C may each utilize different architectural and programming paradigms. Typically, client program A, client program B, and server program C interact with each other by sending and receiving messages via a network . Client programs A, B, and C, and their respective platforms, are assumed to comprise different software paradigms and hardwares.","Because of the diversity of hardware platforms and software paradigms included in system , messages created by client program A must undergo transformations in order to render them understandable to network , and to client program B and server program C. Similar transformations are required for messages to and from client program B and server program C. A message-oriented middleware  provides the transformation service. MOM  comprises a platform interface which converts messages created by client program A from client platform A format into a protocol suitable for network , and transforms messages received by client program A from network  format into client platform A format. MOM  performs substantially similar transformations for client program B and server program C. Typically, the platform interface interprets message header and trailer data, removes or adds headers and trailers, and breaks up or reassembles messages.","In addition to the platform interface, MOM  comprises application-level logic for message processing. Thus, MOM  transforms a message sent by client program A, and produces a message that is valid in the context of communication via network ; however, the message format and content may not match the expectations of one or more intended recipients of the message. Moreover, client program A is not necessarily aware of all the programs wishing to receive its message. For these cases, MOM  encapsulates the application logic required to re-format and route the message.","IBM's MQSeries Integrator comprises an example of an implementation of MOM . As described in Chapter 1 of , published by IBM Corporation, 2000, and incorporated herein by reference, the services provided include the ability to \u201croute a message to several destinations, using rules that act on the contents of one or more of the fields in the message or message header, transform a message, so that applications using different formats can exchange messages in their own formats . . . modify the contents of a message (for example, by adding data extracted from a database . . . )\u201d Further, Chapter 1 cites the two principal benefits of MOM: message and data transformations are performed in a single place, thereby facilitating upgrades and modifications; and additional systems can be integrated quickly, by focusing on interface requirements.","Development of message-oriented software comprises defining message flows. Message flows describe the transformations, processing, and routing that are associated with a message. In an article titled \u201cCoverage Analysis for Message Flows,\u201d by Aizenbud-Reshef, to be presented at ISSRE 2001, the 12International Symposium on Software Reliability Engineering in Hong Kong, Nov. 27\u201330, 2001, which is incorporated herein by reference, the author states that a message flow is a visual program describing the processing logic as a directed graph, which represents that processing performed on a message. Development environments for message-oriented software typically provide graphical tools for the definition and debugging of message flows, since visual programming is considered the most natural paradigm for message-oriented software. The Free On-Line Dictionary of Computing (FOLDOC), which can be found at http:\/\/foldoc.doc.ic.ac.uk\/foldoc and which is incorporated herein by reference, defines a visual programming environment as \u201c[s]oftware which allows the use of visual expressions (such as graphics, drawings, animation or icons) in the process of programming. These visual expressions may be used as graphical interfaces for textual programming languages. They may be used to form the syntax of new visual programming languages leading to new paradigms such as programming by demonstration or they may be used in graphical presentations of the behaviour or structure of a program.\u201d",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2","b":["50","50","52","50","56","66","50","60","52","56","58","60","56","60","58","58","57","59","61","63"]},"Typically, a message flow developer works in a visual development environment and constructs message flows by selecting nodes from a store of pre-defined nodes, extending existing nodes to create new nodes, or creating completely new nodes. Message flow developers implement logic in nodes by writing code in a language such as Structured Query Language (SQL). A node may itself contain a message flow, termed a sub-flow, in which case the node is considered a compound node. In message flow , processing node  can identify a run-time exception, which directs the message flow to a special type of output terminal, a failure terminal  and an exception handler .","Message flows can range from the very simple, performing just one action on a message, to the complex, providing a number of actions on the message to transform its format and content. A message flow can process one message in several ways to deliver a number of output messages, perhaps with different format and content, to a number of target applications.","Developers test all types of software for the same reason: to provide an assurance that the software performs as specified, without defects. Testing, according to the Free On-Line Dictionary of Computing, is defined as \u201c[t]he process of exercising a product to identify differences between expected and actual behaviour.\u201d Since testing is costly and time-consuming, criteria are needed to assess the sufficiency of a set of tests. In an article titled \u201cTest Adequacy Criteria for Component-Based Visual Software\u201d by Keren and Shaham-Gafni, published in the (TCS 99) in June, 1999, which is incorporated herein by reference, the authors note that \u201c[t]he main technique for demonstrating that testing has been thorough is called test coverage analysis. Simply stated, the idea of test coverage analysis is to create, in some systematic fashion, a large and comprehensive list of tasks corresponding to the program under test. The tester's goal is to create a test suite that covers this list of tasks.\u201d",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3","b":["80","51","82","51","84","82","80","51","86","84","51","51"]},"In a build test suite step , a test suite is generated, comprising a plurality of test conditions  and a way of evaluating expected results . Test conditions  comprise input values and conditions intended to exercise SUT  and perform one or more coverage tasks . Ideally, test conditions  should perform all coverage tasks generated in step , although in practice it may be difficult to identify a complete set of test conditions a priori. An oracle function typically evaluates expected results, either via manual inspection by a human expert or via automatic comparison to predetermined expected results . In an execution step , a test harness loads a test condition from test conditions  and executes SUT . Ideally, the test harness provides a way to execute SUT  while controlling inputs and monitoring outputs. During execution, a measure coverage step  runs, to assess the coverage achieved during the test. Execution of SUT  produces actual results, responsive to the test conditions loaded from test conditions . The oracle function performs a comparison step  between actual results of execution  and expected results , and a condition  determines the success or failure of the test. An outcome of failure generally indicates a defect in SUT , which requires developer attention in a debug step . A condition  checks whether sufficient testing of SUT  has completed, i.e., if the results of measuring coverage in step  accord with the coverage goals established in step . If the coverage goals have been accomplished, testing process  terminates.","If the coverage goals have not yet been achieved, testing process  continues in a condition  which checks if unexecuted tests remain in test suite . If tests remain, a next test condition is selected from test conditions , and execution step  again executes SUT  under the next test condition. If all tests in test suite  have executed without achieving the coverage goals of step , it is necessary to augment test suite  with additional tests in an add tests to test suite step , and continue in execution step .","Test adequacy criteria for different types of software have been proposed. For example, in Keren et el. propose coverage criteria for component-based visual software, based on utilization of a family of graph representations including the component containment graph, component call graph, component control flow graph, and framed graph. In an article titled \u201cTesting Strategies for Form-Based Visual Programs\u201d by Rothermel, et al., published in the , pages 96\u2013107, November 1997, and which is incorporated herein by reference, the authors suggest some test adequacy criteria for testing form-based programs, e.g., spreadsheet applications. The criteria make use of a cell relation graph, and include node and edge, cell dependence, and dataflow adequacy criteria.","Adequacy criteria are known in the art for testing object-oriented software. For example, in an article titled \u201cInvestigating the Applicability of Traditional Test Adequacy Criteria for Object-oriented Programs\u201d by Kim et al., presented at FESMA-AEMES 2000: The European Software Measurement Conference, Madrid, October 2000, which is incorporated herein by reference, the authors explore the applicability of non-object-oriented adequacy criteria such as control-flow coverage and data flow-coverage to object-oriented software. Kim et al. conclude that \u201c[t]he experimental result shows that the test criteria are able to deal with most of the OO [object-oriented] features, i.e., many of the defects related to the features could be revealed by the adequate test sets. However, they do not appear to be sufficient. There are a few OO-specific features that the investigated criteria are ineffective at handling, which indicates that the effectiveness of the criteria may be weakened in the presence of those OO features.\u201d In sum, it is accepted in the art that test adequacy criteria, i.e., coverage criteria, must suit the software and architectural paradigms used in the application.","In preferred embodiments of the present invention, a method for evaluating test adequacy for visual message flows is defined. The method comprises analyzing a level of coverage of message flow elements achieved by a test suite. The method provides a way to determine to what extent a message flow is tested, thereby facilitating formulation of coverage goals criteria for stopping the testing process, and directing creation of additional tests In addition, the method indicates untested or partially tested elements in the message flow.","In the context of the present patent application and the claims, message flows are defined as comprising the following visual and textual elements: processing nodes, connections, external resources, and messages. Processing nodes, in turn, comprise the following additional message flow elements: terminals, statements, conditions, and exceptions. Message flow elements are defined and assembled by a message flow developer to create new message flows, typically in a visual environment. Adequacy of a test suite is assessed according to one or more measured test coverage criteria corresponding to the message flow elements. Preferably, a level of coverage is reported in a textual and graphical way, e.g., using color, shading, or shape, to differentiate completely and partially covered elements from elements not covered by a test suite. In preferred embodiments of the present invention, an evaluation of test adequacy is reported on hard-copy and electronic media.","Unlike other methods known in the art for evaluating test adequacy for message flows, in preferred embodiments of the present invention:\n\n","In preferred embodiments of the present invention, a method for evaluating test adequacy for visual message flows comprises the following coverage criteria:\n\n","There is therefore provided, according to a preferred embodiment of the present invention, a method for assessing adequacy of message flow testing, including defining coverage criteria for testing a message flow through a set of message flow elements, determining a message-flow-coverage-goal for the message flow with respect to the coverage criteria, and designing a test suite responsive to the message-flow-coverage-goal. The method further includes applying the test suite to the message flow to generate a coverage result for the set of message flow elements and comparing the coverage result with the message-flow-coverage-goal.","Preferably, the message flow includes a message-oriented software program wherein a message is a primary architectural element.","Preferably, the message flow is included in a message-oriented middleware application.","Preferably, the message flow includes a visual program describing processing logic as a directed graph, and the message flow includes an independent function, outside of a message sender or message receiver.","Preferably, the message flow includes a program processing a message produced by an application chosen from one of a group of applications including a client application and a server application.","Further preferably, the application includes a message-sending-application and a message-receiving-application executing on different hardware platforms.","Further preferably, the message-sending-application and the message-receiving-application are implemented using different software and architectural paradigms.","Preferably, the message flow elements include at least one element chosen from messages, nodes, connections, terminals, statements, conditions, external resources, and exceptions.","Preferably, defining the coverage criteria includes selecting a coverage model from at least one of processing node coverage, terminal coverage, connection coverage, path coverage, N-node coverage, statement coverage, multiple condition coverage, exception coverage, external resources coverage, and message content coverage.","Preferably, determining the message-flow-coverage-goal includes establishing a required coverage level for at least one of the coverage criteria.","Preferably, applying the test suite to the message flow includes performing an execution of at least a part of the test suite and evaluating an attained coverage level resulting from the execution.","Further preferably, evaluating the attained coverage level includes visiting one or more nodes during the execution of the at least part of the test suite, comparing a number of processing nodes visited to a total number of all processing nodes in the message flow, and computing a processing node coverage metric responsive to the comparison.","Further preferably, visiting the one or more nodes includes entering a simple node.","Further preferably, visiting the one or more nodes includes entering a compound node and visiting zero or more nodes in a constituent sub-flow.","Preferably, evaluating the attained coverage level includes traversing one or more terminals during the execution of the at least part of the test suite, comparing a number of processing node terminals traversed to a total number of processing node terminals in the message flow, and computing a terminal coverage metric responsive to the comparison.","Preferably, evaluating the attained coverage level includes traversing one or more connections during the execution of the at least part of the test suite, comparing a number of connections traversed to a total number of connections in the message flow, and computing a connection coverage metric responsive to the comparison.","Preferably, evaluating the attained coverage level includes selecting a group of one or more sets of N-nodes from the message flow, wherein N includes any whole number less than or equal to a total number of nodes in the message flow, performing at least one execution of the message flow so as to determine a number of nodes visited in each of the one or more sets during the at least one execution, and generating a respective set coverage result for each of the one or more sets, responsive to the number of nodes visited. Further, evaluating the attained coverage level includes determining a number of covered-sets, responsive to the set coverage results, comparing the number of covered-sets to a total number of sets in the group, and computing an N-node coverage metric responsive to the comparison.","Preferably, evaluating the attained coverage level includes performing zero or more runtime exceptions during the execution of the at least part of the test suite, comparing a number of runtime exceptions performed to a total number of all runtime exceptions in the message flow, and computing an exception coverage metric responsive to the comparison.","Preferably, evaluating the attained coverage level includes visiting zero or more failure terminals during the execution of the at least part of the test suite, comparing a number of failure terminals visited to a total number of all failure terminals in the message flow, and computing an exception coverage metric responsive to the comparison.","Preferably, evaluating the attained coverage level includes executing zero or more node statements at least once during the execution of the at least part of the test suite, comparing a number of node statements executed to a total number of node statements in the message flow, and computing a statement coverage metric responsive to the comparison.","Further preferably, computing the statement coverage metric includes comparing a number of node statements executed in a single node to a total number of node statements in the single node.","Further preferably, computing the statement coverage metric includes comparing a number of node statements executed in a compound node's constituent sub-flows to a total number of node statements in the compound node's constituent sub-flows.","Preferably, evaluating the attained coverage level includes assessing an achievement of true and false values for each of zero or more boolean sub-expressions independently during the execution of the at least part of the test suite, comparing the achievement for the one or more boolean sub-expressions to a total number of boolean sub-expression values possible in the message flow, computing a multiple condition coverage metric responsive to the comparison.","Further preferably, computing the multiple condition coverage metric includes comparing a number of achieved true and false values for zero or more boolean sub-expressions in a node to a total number of boolean sub-expression values possible in the node.","Further preferably, computing the multiple condition coverage metric includes comparing a number of achieved true and false values for zero or more boolean sub-expressions in a compound node's constituent sub-flows to a total number of boolean sub-expression values possible in the compound node's constituent sub-flows.","Preferably, evaluating the attained coverage level includes assessing a number of values assumed by each of one or more fields in a message during the execution of the at least part of the test suite, comparing the number of values assumed to a total number of possible values for each field in the message, and computing a message content coverage metric responsive to the comparison.","Further preferably, the method includes computing a strong message content coverage metric wherein the total number of values possible for each field in the message includes a cross product of the message fields with their possible values.","Further preferably, the method includes computing a weak message content coverage metric wherein the total number of values possible for each field in the message includes a sum of the number of possible values for each message field independently.","Preferably, evaluating the attained coverage level includes traversing one or more paths during the execution of the at least part of the test suite, comparing a number of paths traversed to a total number of paths in the message flow, and computing a path coverage metric responsive to the comparison.","Preferably, evaluating the attained coverage level includes performing zero or more types of accesses to an external resource during the execution of the at least part of the test suite, comparing a number of types of accesses performed to a total number of types of accesses in the message flow, and computing a external resources coverage metric responsive to the comparison.","Preferably, designing the test suite responsive to the message-flow-coverage-goal includes identifying an initial test suite for the message flow, assessing a coverage level achieved by the initial test suite, and adding additional tests to the initial test suite so as to increase the coverage level.","Preferably, applying the test suite includes generating message-flow-coverage-reports.","Further preferably, the method includes integrating the message-flow-coverage-reports into a visual message flow development environment.","Preferably, the method includes reporting coverage graphically using at least one graphical element chosen from a set of color, shading, highlighting, graphing, fonts, line styles, icons, and labels.","Preferably, the method includes reporting coverage via at least one medium chosen from hard-copy media and electronic media.","Preferably, generating the coverage result includes collecting coverage data using at least one method of data collection chosen from message flow instrumentation and data logging.","There is further provided, according to a preferred embodiment of the present invention, apparatus for assessing adequacy of message flow testing, including a computer system which is adapted to define coverage criteria for testing a message flow through a set of message flow elements, determine a message-flow-coverage-goal for the message flow with respect to the coverage criteria, design a test suite responsive to the message-flow-coverage-goal, apply the test suite to the message flow to generate a coverage result for the set of message flow elements, and compare the coverage result with the message-flow-coverage-goal.","There is further provided, according to a preferred embodiment of the present invention, a computer software product for assessing adequacy of message flow testing, comprising a computer-readable medium having computer program instructions recorded therein, which instructions, when read by a computer, cause the computer to define coverage criteria for testing a message flow through a set of message flow elements, determine a message-flow-coverage-goal for the message flow with respect to the coverage criteria, design a test suite responsive to the message-flow-coverage-goal, apply the test suite to the message flow to generate a coverage result for the set of message flow elements, and compare the coverage result with the message-flow-coverage-goal.","The present invention will be more fully understood from the following detailed description of the preferred embodiments thereof, taken together with the drawings, in which:","Reference is now made to , which is a schematic message flow directed graph showing elements in a sample message flow , according to a preferred embodiment of the present invention. Message flow  implements the handling of a message in the context of system  (). Message flow  is implemented by message-oriented middleware (MOM) , on client platform A, client platform B, or server platform C. As shown in  and described in the Background of the Invention, MOM  is a function separate from client program A, client program B, and server program C. Thus, client program B generates a message for client program A, which is handled by MOM , as an independent function, outside of message sender client program B or message receiver client program A. A message Incoming Message  is sent, for example, to client platform A via network . Incoming Message  enters message flow  through a terminal  of an input node Input . Node Input  comprises a message queue and message queue functions that are typically comprised in message-oriented middleware.","In the context of the present patent application and the claims, \u201cmessage processing node,\u201d \u201cprocessing node,\u201d and \u201cnode\u201d are assumed to be equivalent terms referring to a set of actions performed on a message and constituting a well-defined stage of processing of a message, as is known in the art. A node may be supplied with a development environment with a pre-defined functionality, e.g., nodes Input  and Check . Alternatively, processing nodes may comprise user-coded statements defining special processing to perform on a message, e.g., a node InternalNode  and a node ChangeStatus . Further, message processing nodes themselves may comprise one or more message flows, e.g., node InternalNode . A message flow comprised within a node of a second message flow is called a \u201csub-flow,\u201d and a node comprising a sub-flow, such as InternalNode , is called a \u201ccompound\u201d node. A node which does not comprise a sub-flow is called a \u201csimple\u201d node, such as a node Check  and ChangeStatus . Message flow  comprises a plurality of messages, message processing nodes, and connections. The processing nodes in message flow , in turn, comprise the following additional message flow elements: terminals, statements, conditions, and exceptions. Table I below presents element types, a description of the element, and respective identifying numerals for each element comprised in message flow :",{"@attributes":{"id":"p-0079","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Element type","Description","Identifying Numeral"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","Message","Incoming","152"]},{"entry":[{},{},"Outgoing","216, 224"]},{"entry":["2.","Message","Input","156"]},{"entry":[{},"Processing","Output","212, 220"]},{"entry":[{},"Node","Other","170, 184, 200"]},{"entry":["3.","Connection",{},"164, 176, 178, 194,"]},{"entry":[{},{},{},"196, 206, 208"]},{"entry":["4.","Exception","Failure, run-time","192"]},{"entry":[{},{},"error"]},{"entry":["5.","Terminal",{},"154, 158, 160, 162,"]},{"entry":[{},{},{},"168, 172, 174, 180,"]},{"entry":[{},{},{},"182, 186, 198, 190,"]},{"entry":[{},{},{},"198, 202, 204, 210,"]},{"entry":[{},{},{},"214, 218, 222"]},{"entry":["6.","Statement","Contained in","184 (within its sub-"]},{"entry":[{},{},"nodes","flow), 200"]},{"entry":["7.","Condition","Contained in","184 (within its sub-"]},{"entry":[{},{},"nodes","flow), 200"]},{"entry":["8.","External","Database","228"]},{"entry":[{},"resource"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Processing nodes comprise zero or more terminals. In the context of the present patent application and the claims, a terminal is defined as an access channel to a processing node, through which a message enters or exits a node.","Message processing node ChangeStatus  comprises code statements defining processing to perform on Incoming Message . The code statements comprise conditional statements, evaluating to a true or false result based on user-coded comparisons between Incoming Message fields, internal constants, and variables. InternalNode  does not contain code statements of its own, but rather comprises a sub-flow, constructed of nodes comprising code statements.","Message flows commonly operate upon external resources, such as a database. Thus, although external resources are not, strictly speaking, elements of a message flow, nonetheless accesses to such resources merit coverage analysis. For example, processing node Check  reads information from external resource database  in order to verify data. Therefore, in the context of the present patent application and the claims, external resources accessed by a message flow will be considered to belong to the set of message flow elements, together with messages, message processing nodes, connections, terminals, statements, conditions, and exceptions.","According to a preferred embodiment of the present invention, a system for evaluating message flow test adequacy comprises one or more of the criteria presented in Table II below, and described in detail subsequently:",{"@attributes":{"id":"p-0084","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Criterion",{},"Applicable to element"]},{"entry":["no.","Coverage criteria","type"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","Processing node","Processing node"]},{"entry":[{},"coverage"]},{"entry":["2.","Processing node","Terminal"]},{"entry":[{},"terminal coverage"]},{"entry":["3.","Connection coverage","Connection"]},{"entry":["4.","Path coverage","Processing node"]},{"entry":["5.","N-Node coverage","Processing node"]},{"entry":["6.","Statement coverage","Processing node"]},{"entry":[{},{},"(comprising statements)"]},{"entry":["7.","Multiple condition","Processing node"]},{"entry":[{},"coverage","(comprising statements)"]},{"entry":["8.","Exception coverage","Exception"]},{"entry":["9.","External resources","External resource"]},{"entry":[{},"coverage"]},{"entry":["10.\u2002","Message content","Message"]},{"entry":[{},"coverage"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In a preferred embodiment of the present invention, coverage of message flow elements is indicated in a graphical and\/or textual manner, including, but not limited to, using color, shading, highlighting, shapes, graphs, icons, and labels to differentiate completely-covered, partially-covered, and uncovered elements. Coverage is reported via hard-copy and\/or electronic media. The system for evaluating message flow test adequacy, using criteria of Table II, is implemented on any computer system, most preferably an industry-standard computer system, by reading instructions from a computer-readable medium such as a volatile or involatile memory.","In the following description of the coverage criteria presented in Table II, reference is made to coverage goals, coverage tasks, and a test suite. A description of these elements is provided with reference to  in the Background of the Invention.","Processing node coverage measures whether each processing node in message flow  is executed during a full or partial execution of the test suite. The set of coverage tasks is a list of all the processing nodes in message flow . Thus, 100% processing node coverage signifies that all nodes , , , , ,  were executed. For a simple node, such as Check , entering the node comprises executing it. Execution of a compound node, e.g., InternalNode , preferably comprises either partial or full execution, calculated according to a percentage of nodes in the sub-flow contained within the compound node InternalNode  that were executed.","A refinement of processing node coverage reports whether each terminal of a processing node is traversed during a full or partial execution of the test suite. The set of coverage tasks is a list of all the terminals in message flow . In this case, 100% processing node terminal coverage signifies that all input and output terminals of nodes , , , , ,  were traversed. The list of all terminals in message flow  is given in Table I above. Measuring processing node terminal coverage for a compound node such as InternalNode  comprises evaluating a level of terminal coverage for its constituent sub-flows, not shown in Table I above.","Connection coverage measures a percentage of connections in message flow  which are traversed during a full or partial execution of the test suite. The set of coverage tasks is a list of all the connections in message flow . Complete connection coverage comprises traversing all connections , , , , , , . Measuring connection coverage for a compound node, such as InternalNode , comprises measuring a level of connection coverage for its constituent sub-flows.","Path coverage analyzes whether each of the possible paths through the message flow have been traversed. A path is defined as a unique sequence of processing nodes starting at an initial input node at the beginning of a message flow and ending either at a final output node of a message flow, or at a terminal without an outgoing connection (a dead end). The set of coverage tasks is the list of all possible paths through message flow , which begin at Input , and terminate at either Output , Output , or at one of the dead ends, e.g., terminal .","N-node coverage evaluates whether a set of N nodes, selected by the user, is visited in a single execution of message flow . N is any whole number less than or equal to a total number of nodes in the message flow. Each selection of N nodes represents a partial or complete path through message flow . The set of coverage tasks is a group of selections of N-node sets. Complete N-node coverage comprises processing node coverage for all of the N-node selections in the group.","Statement coverage calculates a percentage of statements executed in processing nodes containing code, during a full or partial execution of the test suite. The set of coverage tasks is a list of code statements for each processing node in message flow . For a compound node or an entire message flow, node statement coverage expresses a level of coverage for all constituent nodes. Table III below presents an example of statements contained in processing node ChangeStatus :",{"@attributes":{"id":"p-0093","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["State-",{}]},{"entry":["ment",{}]},{"entry":["no.","Statements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","SET OutputRoot = InputRoot;"]},{"entry":["2.","SET OutputRoot.XML.e_Human.e_Emp.e_Family . . ."]},{"entry":["3.","CASE InputRoot.XML.e_Human.e_Emp.e_Name"]},{"entry":["4.","WHEN \u2018Yaron\u2019 THEN \u2018Aizenbud\u2019"]},{"entry":["5.","WHEN \u2018Gabi\u2019 THEN \u2018Zodik\u2019"]},{"entry":["6.","END;"]},{"entry":["7.","IF InputRoot.XML.e_Human.e_Occupation = \u2018CEO\u2019 OR"]},{"entry":[{},"InputRoot.XML.e_Human.e_Occupation = \u2018CTO\u2019"]},{"entry":["8.","SET OutputRoot.XML.e_Human.e Emp.e Status . . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A test suite may execute only some of the code statements in ChangeStatus . For example, if statements 1, 2, 3, 4, 6, and 7 are executed during the test suite, 75% statement coverage is achieved for ChangeStatus . A similar calculation may be made for all processing nodes containing code, in order to produce a node statement coverage measurement for message flow .","Multiple condition coverage reports for every processing node that contains a boolean sub-expression, the true or false outcome of each sub-expression, separated by logical AND and logical OR if they occur, in message flow , during a full or partial execution of the test suite. Mulitiple condition coverage measures the sub-expressions independently of each other. The set of coverage tasks is a list of all boolean sub-expression of a processing node containing a boolean expression. Referring to Table III above, multiple condition coverage for ChangeStatus  evaluates that each of the two sub-expressions \u201cInputRoot.XML.e_Human.e_Occupation=\u2018CEO\u2019\u201d and \u201cInputRoot.XML.e_Human.e_Occupation=\u2018CTO\u2019\u201d assumed both true and false values over execution of a test suite. If, for example, \u201cInputRoot.XML.e_Human.e_Occupation=\u2018CEO\u2019\u201d evaluated to both true and false, and \u201cInputRoot.XML.e_Human.e_Occupation=\u2018CTO\u2019\u201d evaluated only to false over an execution of the test suite, condition coverage for ChangeStatus  would be 50%. Exception coverage measures whether run-time exceptions occur in processing nodes having a capability of raising a run-time exception. Typically, run-time exceptions are implemented by way of failure terminals. The set of coverage tasks comprises all processing nodes having a failure terminal in message flow . Thus, 100% exception coverage for message flow  comprises covering node InternalNode  and terminal , i.e., covering exception .","External resources coverage checks whether each access to an external resource was exercised. Accesses to an external resource may be classified in various ways, for example, read, write, update, create, delete. The set of coverage tasks comprises a list of all external resources paired with each class of possible access. In message flow , for example, node Check  reads from database  and node ChangeStatus  reads and updates database . 100% external resource coverage comprises exercising both read and update access to database .","Message content coverage reports whether a message field contained every possible value from a range of possible values for the field, during a full or partial execution of the best suite. A strong message content coverage criterion defines the set of coverage tasks as a cross product of message fields with their possible values. A weak message content coverage criterion determines if each message field assumed all possible values, considered independently of other message fields. For example, message Incoming Message  comprises fields ID and PRIORITY. Assuming ID has allowable values {1, 2, 3} and PRIORITY has allowable values {A, B, C}, Table IV below presents the set of message content coverage tasks for the strong message content coverage criterion for message . Complete message content coverage, according to a strong criterion, means that the fields in message  assumed every combination of values shown in Table IV, during a full or partial execution of the test suite. A weak message content coverage criterion would require only that ID assumed each of the three possible values and, independently, that PRIORITY assumed each of the three possible values, at some time during a full or partial execution of the test suite.",{"@attributes":{"id":"p-0098","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE IV"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"ID","PRIORITY"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1","A"]},{"entry":[{},"2","A"]},{"entry":[{},"3","A"]},{"entry":[{},"1","B"]},{"entry":[{},"2","B"]},{"entry":[{},"3","B"]},{"entry":[{},"1","C"]},{"entry":[{},"2","C"]},{"entry":[{},"3","C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"After creating message flow , the message flow developer typically performs testing on the message flow, to determine that all elements perform as expected, and that the overall message flow accomplishes its goals in a reliable manner. As with other types of software, the message flow developer performs the testing process substantially as described with reference to  above. During the testing process, coverage data is collected via message flow instrumentation, data logging, and\/or other methods known in the art","Referring to , in determine coverage model step , the message flow developer selects one or more coverage models from a plurality of coverage models used for message flows. The plurality comprises the coverage criteria presented in Table II above. For example, the message flow developer selects processing node coverage, connection coverage, and message content coverage for testing message flow . In establish coverage goals step , the developer determines coverage goals responsive to the coverage models selected in . Thus, coverage goals for message flow  might be 100% processing node coverage, 100% connection coverage, and 50% message content coverage. Factors influencing determination of coverage models and coverage goals typically comprise time and cost constraints, risk analysis, fault tolerance, and availability of testing tools.","Coverage tasks are defined in step , corresponding to the coverage models and coverage goals determined in steps  and . For message flow , for example, coverage tasks for the processing node coverage goal comprise executing processing nodes , , , all processing nodes in the sub-flow comprised in , , , and  in the message flow. Similar coverage tasks are defined for the connection coverage and message content coverage goals. A set of tests is generated in build test suite , with the aim of achieving all of the coverage tasks defined in step .","Testing process  as applied to message flow  continues substantially as described above with reference to , to measure coverage step . The coverage measured is the specific message flow coverage that was defined in steps , , and . The measured coverage is used as a criterion for halting testing in condition , and as a guide to the creation of additional tests in add tests to test suite step . For example, if coverage measurements revealed that a test suite executed all processing nodes except node Output , an additional test could be added to the test suite in step , designed expressly to cover Output .","Unlike other methods known in the art for evaluating test adequacy for message flows, in preferred embodiments of the present invention, definition of coverage models, goals, and tasks, and display of coverage information is performed in a visual environment. Information is reported graphically and textually. Preferably, the visual environment is integrated into the message flow development environment, so that the message flow developer utilizes familiar concepts and views to evaluate test adequacy for message flows. Further preferably, the visual environment for message flow coverage provides a user interface allowing the message flow developer to specify types and formats of message flow coverage information to report.","Reference is now made to , which are graphical and textual message flow coverage reports, according to a preferred embodiment of the present invention. Graphical and textual message flow coverage reports present coverage information for message flow , according to the coverage models selected in determine coverage model  (), and measured in measure coverage  () over a test suite formulated in build test suite  and add tests to test suite  (). Graphical and textual message flow coverage reports may be produced on hard-copy or presented on electronic media, most preferably through a system integrated into a message flow development environment running on an industry-standard computer system. It is appreciated that coverage measurements may be indicated in the graphical and textual message flow coverage reports by a plurality of methods, including, but not limited to, shading, patterns, colors, labels, icons, graphs, shapes, font styles, and line styles. Additional reports and methods for displaying coverage information will be apparent to those skilled in the art.","Reference is now made to , which is a graphical and textual message flow coverage report for the sample message flow of . Message flow coverage report  comprises a graphical display panel  and a textual display panel . In graphical display panel , message flow  () is displayed together with annotations indicating message flow coverage measurements for coverage models selected by the user in determine coverage model  (), for a set of tests executed from test suite  ().","Processing node coverage is indicated by a shading pattern inside the shape representing the nodes, e.g., node Input  contains a cross-hatch pattern , indicating 100% node coverage of Input. Thus, nodes Input , Check , ChangeStatus , and Output  achieved 100% node coverage. Node InternalNode  contains a dotted pattern , indicating only partial node coverage. Node Output  contains no shading pattern, indicating a 0% coverage.","Graphical display panel  displays annotations of the connections comprised in message flow , so as to indicate a level of connection coverage. Connections , , , and  are displayed as double lines, signifying coverage of these connections. Connections , , and  are displayed as single lines, indicating that these connections were not traversed.","Exception coverage for message flow  comprises coverage of node InternalNode  and terminal . In graphical display panel , terminal  is designated by a small flag icon . Flag icon  is white, indicating that the exception was not covered. Coloring flag icon  black would indicate coverage of the exception.","Indications of statement coverage and multiple condition coverage are displayed in graphical display panel  in the form of small bar graphs. Statement coverage applies to processing nodes containing code statements, i.e., nodes comprised in the sub-flow of InternalNode  and ChangeStatus . Bar graphs  and  display statement coverage levels for nodes InternalNode and ChangeStatus respectively. In the case of bar graph , 100% statement coverage is indicated by complete shading of bar graph . In the case of bar graph , partial statement coverage, approximately 66%, is indicated by a partial shading of bar graph . Since InternalNode  is a compound processing node, i.e., it contains a sub-flow, bar graph  reflects an aggregation of coverage measurements for all component nodes.","Multiple condition coverage is presented in graphical display panel  in substantially the same way as statement coverage. Bar graphs  and  designate the level of condition coverage for nodes comprised in the sub-flow of InternalNode  and ChangeStatus  respectively. Both bar graph  and bar graph  indicate a partial condition coverage of approximately 66%. It is noted that, although node ChangeStatus  achieved 100% statement coverage, only partial condition coverage is achieved, a situation resulting from independent evaluation of boolean sub-expressions.","Textual display panel  presents coverage information in a textual format for a selected message processing node. In graphical display panel , the user selected node ChangeStatus , as indicated by an arrow  pointing to the node. Thus, textual display panel  displays information for node ChangeStatus. Report lines , , and  summarize respectively node coverage, statement coverage, and multiple condition coverage data for ChangeStatus. Report lines , , , , , , , and  present the SQL statements comprised in node ChangeStatus, with italics used to indicate covered statements. Preferably, the user can select nodes interactively via a user-friendly graphic user interface, and view summary information for each node selected.","Reference is now made to , which is a textual condition coverage report for the sample message flow of . A textual multiple condition coverage report panel  comprises a title  and report lines , , , , , and . Title  indicates that the information displayed applies to node ChangeStatus . Report line  presents the headings of the data displayed in the subsequent report lines. The data displayed comprises the following elements: the condition itself, e.g., \u201cInputRoot.XML.e_Human.e_Occupation=\u2018CEO\u2019\u201d in the case of report line ; the line number in the SQL code which contains the condition, e.g.,  in the case of report line ; the complete SQL statement containing the condition; the number of times the condition evaluated to false over the test suite for which the measurements were performed; and the number of times the condition evaluated to true over the test suite for which the measurements were performed. Textual multiple condition coverage report panel  comprises a report line for each sub-expression in each condition in the the node.","Reference is now made to , which is a textual summary coverage report for the sample message flow of . A textual summary coverage report panel  comprises a summary line section  and a processing nodes detailed report section . Summary line section  comprises summary report lines , , , , and . Thus, over a full or partial execution of the test suite prior to producing summary coverage report panel , message flow  achieved the following coverage: 81% node coverage, 66% connection coverage, 0% exception coverage, 81% statement coverage, and 66% condition coverage. Processing nodes detailed report section  supplies detailed information for each node, comprising the node lablel, a unique identifier for the node, and details about statement and condition coverage measurements. For example, coverage for node ChangeStatus is given in detail line . Statement and multiple condition coverage are not applicable to nodes which have no SQL code statements. Therefore, statement coverage and condition coverage are indicated as \u22121, as in detail line  for node Input.","Reference is now made to , which is a graphical message flow coverage progress report for the sample message flow of , according to a preferred embodiment of the present invention. A coverage progress report panel  comprises a legend  and graphs , , , , and . Legend  provides a key to distinguish among the different graphs presented. In preferred embodiments of the present invention, the graphs are distinguished using line styles, colors, thicknesses, and other means known in the art for the differentiation of lines. Legend  associates a type of coverage with a graph line. Graphs , , , and  plot a coverage percentage over a number of tests executed. The number of tests executed refers to the testing process illustrated in , wherein test execution step  is repeated for each test in test suite . The coverage percentage is the coverage measured in measure coverage , for each of the coverage models selected in determine coverage model . Coverage progress report panel  presents the behavior of coverage measurements as additional tests are executed. It may be seen, for example, that no additional coverage benefit was derived from executing more tests after the ninth test.","It will be appreciated that the preferred embodiments described above are cited by way of example, and that the present invention is not limited to what has been particularly shown and described hereinabove. Rather, the scope of the present invention includes both combinations and subcombinations of the various features described hereinabove, as well as variations and modifications thereof which would occur to persons skilled in the art upon reading the foregoing description and which are not disclosed in the prior art."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0069","num":"0081"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0070","num":"0082"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0071","num":"0083"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0072","num":"0084"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0073","num":"0085"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0074","num":"0086"},"figref":["FIG. 6","FIG. 4"]},{"@attributes":{"id":"p-0075","num":"0087"},"figref":["FIG. 7","FIG. 4"]},{"@attributes":{"id":"p-0076","num":"0088"},"figref":["FIG. 8","FIG. 4"]}]},"DETDESC":[{},{}]}
