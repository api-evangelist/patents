---
title: Unified assembly instruction set for graphics processing
abstract: Systems and methods for providing a unified instruction set allow shader programs of different types to use a common instruction set. The unified instruction set provides easy access for new graphics hardware features and faster compile times for shader programs. Programmers may use the unified instruction set to write fragment, vertex, or geometry programs. Functions that use the unified instruction set can be included in shader, vertex, or geometry programs without modification. Existing shader programs may be compiled to produce shader microcode based on the unified instruction set. The shader microcode may then be executed by processing units designed to support the unified instruction set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08154554&OS=08154554&RS=08154554
owner: NVIDIA Corporation
number: 08154554
owner_city: Santa Clara
owner_country: US
publication_date: 20061010
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","The Unified Shader Program Instruction Set Architecture"],"p":["This application claims benefit of U.S. provisional patent application titled, \u201cAPI Extensions for Advanced Graphics Processing Units,\u201d filed Jul. 28, 2006, and having Ser. No. 60\/833,978, which is herein incorporated by reference.","1. Field of the Invention","One or more aspects of the present invention relate generally to instruction sets, and more particularly to a unified instruction set for vertex, fragment, or geometry programs.","2. Description of the Related Art","Over the past decade, the cost of adding on-chip logic to processors has substantially decreased. Consequently, certain types of processors, such as advanced graphics processing units (GPUs), now include functionality not previously available in earlier GPU designs. For example, the newest GPUs are now able to perform geometry processing operations; whereas, such operations traditionally had been left to the central processing unit (CPU). One benefit of this shift in responsibilities is that more graphics processing may now be performed on the GPU instead of the CPU, thereby reducing performance bottlenecks in the graphics pipeline.","To fully realize additional processing capabilities of advanced GPUs, as much GPU functionality as possible needs to be exposed to graphics application developers. Among other things, doing so enables graphics application developers to tailor their shader programs to optimize the way GPUs process graphics scenes and images. Exposing new GPU processing capabilities, like geometry processing, to graphics application developers requires that the application programming interface (API) be configured with new calls and libraries that make new features and functionalities directly accessible by developers.","Some graphics APIs expose an interface to graphics application developers that consists of a set of calls written in a high-level programming language. To access the API, graphics application developers have to write their shader programs in the same high-level programming language or have their program code translated into that same high-level programming language. One drawback of this approach is that the shader programs written or translated into the high-level programming language of the API must first be compiled within the API layer into microcode that can then be executed on the GPU. Compiling shader programs is typically performed by the CPU while the application is running. The processing overhead required for the compilation can reduce the application's frame rate. When the compilation is performed off-line, the shader program is compiled to produce microcode for a specific GPU, limiting a user's ability to use another GPU for execution of the microcode. Another drawback is that the set of calls to which graphics application developers have access may not reflect the full functionality of the GPU. In a sense, developers are held hostage to the whims of the API architect. For example, if the API architect chooses not to write an API call that exposes one of the salient features of the GPU to the graphics application developer, then the developer has no way to access that GPU feature.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1","b":["150","155","160","155","160","115","105","120","110"]},"Program instructions included in fragment ISA  are designed for execution in the fragment domain and generally may not be executed in the vertex domain. Likewise, program instructions included in vertex ISA  are intended for execution in the vertex domain and generally may not be executed in the fragment domain. Due to these differences between fragment ISA  and vertex ISA , application developers can not be assured that code developed using an ISA for one processing domain can be used without substantial modifications for a different processing domain. Therefore, dedicated microcode assemblers are used to translate the shader programs for each domain. Specifically, a GPU vertex microcode assembler  compiles vertex shader program  into microcode for execution by vertex processing unit . Similarly, a GPU fragment microcode assembler  compiles fragment shader program  into microcode for execution by fragment processing unit . Upon execution of the microcode, graphics processor  outputs processed graphics data .","As the processing capabilities of graphics processor  evolve, instructions are added in vertex ISA  and fragment ISA  as needed to expose the new processing capabilities. Processing capabilities that are available for both vertex and fragment shaders must be added to both vertex ISA  and fragment ISA . Additionally, both compilers, GPU vertex microcode assembler and GPU fragment microcode assembler , are updated to translate any new instructions into microcode.","As the foregoing illustrates, what is needed in the art is an application programming interface that exposes new processing capabilities of GPUs, while requiring minimal changes to the programming architecture.","Systems and methods of the present invention provide a unified instruction set that allows shader programs of different types to use a common instruction set. The unified instruction set provides easy access for new graphics hardware features and faster compile times for shader programs written using the unified instruction set compared with shader program written using a high-level programming language. Programmers may use the unified instruction set to write fragment, vertex, or geometry programs. Functions that use the unified instruction set may be included in shader, vertex, or geometry programs without modification. Existing shader programs written in high-level languages may be compiled to produce shader programs that use the unified instruction set. Shader programs written using the unified instruction set are assembled to produce shader microcode for execution by any graphics processors designed to support the unified instruction set.","Various embodiments of the invention include a computer device comprising a processing unit and a software program. The processing unit has a vertex execution unit that is configured to execute vertex shader microcode and a fragment execution unit that is configured to execute fragment shader microcode. The software program is configured to receive a shader program from an application, determine a target execution unit of the processing unit that is specified by the shader program, and convert the shader program into shader microcode for execution by the target unit of the processing unit. The shader program is comprised of assembly instructions and includes a set of assembly instructions from a unified shader program assembly instruction set that can be executed by both the vertex execution unit of the processing unit and the fragment execution unit of the processing unit.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the present invention. However, it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the present invention.","Systems and methods for providing a unified instruction set allow shader programs of different types to use a common instruction set. The unified instruction set provides easy access for new graphics hardware features and faster compile times for shader programs. Programmers may use the unified instruction set to write fragment, vertex, or geometry programs. Existing high-level shader programs and assembly level shader programs using conventional instruction sets may be compiled to produce shader microcode based on the unified instruction set. The shader microcode may then be executed by graphics processors designed to support the unified instruction set.","Importantly, the unified instruction set allows a programmer to access new features of graphics processors. In particular, the unified instruction set provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers. A uniform set of structured branching constructs, e.g., if tests, loops, subroutines, and the like, is provided that fully support runtime condition testing. Several new texture mapping capabilities of graphics processors are also exposed. For example, shadow cube maps are supported, where cube map faces can encode depth values. Assembly texture lookup instructions can include an immediate texel offset, which can assist in advanced texture filtering and querying. New assembly instructions are provided for fetching a single texel by address in a texture map and querying the size of a specified texture level.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 2A","FIG. 2C"],"b":["200","240","200","215","220","200","200"]},"Unified microcode assembler  converts the shader program assembly instructions in vertex shader program  and fragment shader program  into microcode for execution by vertex processing unit  and fragment processing unit , respectively. GPU unified microcode assembler  is configured to operate in a runtime mode in order to output the shader microcode to the appropriate execution unit within graphics processor  as the shader microcode is generated. GPU unified microcode assembler  determines which of the execution units within graphics processor , e.g., vertex processing unit  and fragment processing unit , a shader program targets and includes domain specific interfaces corresponding to the inputs and outputs of the target execution unit. In some embodiments of the present invention, the target execution unit is identified by a header or tag in the shader program, e.g., vertex shader program  and fragment shader program . Vertex processing unit  and fragment processing unit  execute the shader microcode produced by GPU unified microcode assembler  and graphics processor  outputs processed graphics data .",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2B","b":["200","242","215","220","255","260","242","242","235","230","215","220","235","230","250","242","235","230"]},"GPU unified microcode assembler  and  may be included within a device driver to convert shader programs based on specific capabilities of graphics processor  and other graphics processors. Therefore, vertex shader program  and fragment shader program  may be executed on other graphics processors, including new graphics processors, as long as the shader programs are written using assembly shader program instructions included in unified ISA . In other embodiments of the present invention, graphics processor  may be a general purpose processor that is configured to execute shader programs.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2C","b":["200","240","285","280","285","280","245","200","245","240","245","245","245","250"]},"HLLs provide programmers with a familiar programming language, allowing complex graphics shader programs to be written quickly and with fewer errors compared with writing the same shader programs using assembly instructions. When a programmer uses a proprietary language to compose a shader program, a corresponding compiler may be used to translate the proprietary language instructions into shader assembly instructions from unified ISA . However, disadvantages of using an HLL instead of assembly shader instructions are that HLLs may not expose new hardware capabilities and shader programs written using assembly shader instructions may provide faster compile times and better graphics processing performance when executed by a graphics processor.","The new shader program text corresponding to vertex shader program  and fragment shader program  is converted into shader microcode by GPU unified microcode assembler  for execution by vertex processing unit  and fragment processing unit , respectively. When the shader microcode is executed by vertex processing unit  and fragment processing unit , graphics processor  outputs processed graphics data.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2D","b":["275","275","240","285","280","275","200","290","295","245","290","295","245","245"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 3A","FIG. 2A"],"b":["300","340","255","260","350","365","315"]},"Unified ISA  includes assembly shader program instructions that may be executed by geometry processing unit , vertex processing unit , and fragment processing unit . In some embodiments of the present invention unified ISA  is the same as unified ISA . GPU unified microcode assembler  is configured to convert the shader program assembly instructions in vertex shader program , fragment shader program , and geometry shader program , into microcode for execution by vertex processing unit , fragment processing unit , and geometry processing unit , respectively. GPU unified microcode assembler  is configured to operate in a runtime mode in order to output the shader microcode to the appropriate execution unit within graphics processor  as the shader microcode is generated.","GPU unified microcode assembler  determines which of the execution units within graphics processor , e.g., geometry processing unit , vertex processing unit , and fragment processing unit , a shader program targets and includes domain specific interfaces corresponding to the inputs and outputs of the target execution unit. Geometry processing unit , vertex processing unit , and fragment processing unit  execute the shader microcode produced by GPU unified microcode assembler  and graphics processor  outputs processed graphics data .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3B","b":["300","342","342","215","220","315","255","260","365","242","342","342","330","235","230","315","215","220","330","235","230","350","342","330","235","230"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3C","b":["300","340","315","285","280","315","285","280","345","300"]},"The new shader program text corresponding to geometry shader program , vertex shader program , and fragment shader program  is converted into shader microcode by GPU unified microcode assembler  for execution by geometry processing unit , vertex processing unit , and fragment processing unit , respectively. When the shader microcode is executed by geometry processing unit , vertex processing unit , and fragment processing unit , graphics processor  outputs processed graphics data.","In some embodiments of the present invention, the new shader text produced by HLL compiler  is stored and processed by GPU unified microcode assembler  at a later time. Furthermore, GPU unified microcode assembler  may be replaced with GPU unified microcode assembler . HLL compiler  may be included within a device driver or HLL compiler  may be separate from the device driver. HLL compiler  may also be configured to operate in a runtime mode or to operate in an off-line mode and generate an executable file for storage. HLL compiler  may be executed by a CPU that is in a different computing system than graphics processor . Furthermore, GPU unified microcode assembler  may be omitted and HLL compiler  may be included within a device driver and configured to convert geometry shader program , vertex shader program , and fragment shader program  into shader microcode for execution by geometry processing unit , vertex processing unit , and fragment processing unit , respectively.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 4A","b":["400","410","470","400","410","414","412","412","415","415","412"]},"GPU unified microcode assembler  or  may be stored in host memory  for execution by host processor  to produce shader microcode for execution by graphics processor  or . In particular, GPU unified microcode assembler , or  produces microcode based on the specific capabilities of the graphics processor that will execute the microcode. For example, when geometry processing unit  is included in graphics processor  the shader microcode may include microcode corresponding to a geometry shader program. Although computing system  includes GPU unified microcode assembler  or  and graphics subsystem , in other embodiments of the present invention, GPU unified microcode assembler  or  may be executed in a computing system that does not include graphics subsystem .","Host computer  communicates with graphics subsystem  via system interface . Data received by graphics processor  or  can be processed by a graphics pipeline within graphics processor  or  or written to a local memory . Graphics processor  uses graphics memory to store graphics data and program instructions, where graphics data is any data that is input to or output from components within graphics processor  or . Graphics memory can include portions of host memory , local memory , register files coupled to the components within graphics processor  or , and the like. Graphics processor  or  includes one or more processing units that may each read and\/or write graphics memory. Details of graphics processor  or  are described in conjunction with .","In a typical implementation graphics processor  or  performs geometry computations, rasterization, pixel computations and raster operations. When the data received by graphics subsystem  has been completely processed by graphics processor  or  outputs processed graphics data  or  to graphics memory. In some embodiments of the present invention, graphics processor  or  is optionally configured to deliver data to a display device, network, electronic control system, other computing system , other graphics subsystem , or the like. Alternatively, data is output to a film recording device or written to a peripheral device, e.g., disk drive, tape, compact disk, or the like. Host processor  may also be configured to read processed graphics data  or  from graphics memory.","Vertex shader program , geometry shader program , and fragment shader program  are stored in host memory . A graphics device driver  is also stored in host memory . GPU unified microcode assembler  or  may be included within graphics device driver . Graphics device driver  may be configured to determine the capabilities of graphics processor  or  and convert the assembly shader instructions of vertex shader program , geometry shader program , and fragment shader program  for execution by execution units within graphics processor  or , or other graphics processors based on the specific capabilities of each graphics processor.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 4B","FIG. 4A","FIGS. 2C"],"b":["405","410","470","405","425","240","242","340","342","245","345","240","242","340","342","245","345","425","285","280","315","312","300","245","345","2","3","245","345","300","240","242","340","342","245","345","330","235","230"]},"When operating in an off-line mode, GPU unified microcode assembler  or  produces geometry shader program microcode , vertex shader program microcode , and fragment shader program microcode  for execution by graphics processor . Graphics processor  or  executes the shader program microcode to produce processed graphics data  or  that is stored in local memory . In some embodiments of the present invention, geometry shader program microcode , vertex shader program microcode , and fragment shader program microcode  may be produced by a GPU unified microcode assembler , , , or  and\/or HLL compiler  or  executed on a CPU that is not included within host computer .","The unified instruction set allows a programmer to access new features of graphics processors and use a common instruction set to program different types of shaders. In particular, the unified instruction set provides assembly instructions for execution by a programmable geometry processing unit. Shader code written using unified ISA  and  may be leveraged for use in different types of shader programs. Additionally, conventional fragment shader code and vertex shader code can be translated to use unified ISA  and  for execution on newer graphics processors.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 4C","FIGS. 3A"],"b":["350","3","4","4","350","430","255","450","365","455","260","465","430","255","255","255","255","340"]},"Primitive assembler  is fixed function unit that receives processed vertex data from vertex processing unit  and constructs graphics primitives, e.g., points, lines, triangles, or the like, for processing by geometry processing unit . Geometry processing unit  is a programmable execution unit that is configured to execute geometry shader programs, transforming graphics primitives received from primitive assembler  as specified by the geometry shader programs. For example, geometry processing unit  may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters, such as plane equation coefficients, that are used to rasterize the new graphics primitives. Geometry processing unit  outputs the parameters and new graphics primitives to rasterizer . Geometry processing unit  may read texture map data that is stored in local memory  through an interface (not shown) for use in processing the geometry data.","Rasterizer  is a fixed function unit that scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Rasterizer  may include an assembly unit that collects the vertices emitted by geometry processing unit  into individual graphics primitives, e.g., points, lines, triangles, and the like, for scan conversion. Fragment processing unit  is a programmable execution unit that is configured to execute fragment shader programs, transforming fragments received from rasterizer  as specified by the fragment shader programs. For example, fragment processing unit  may be programmed to perform operations such as perspective correction, texture mapping, shading, blending, and the like, to produce shaded fragments that are output to raster operations unit . Fragment processing unit  may read texture map data that is stored in local memory  through an interface (not shown) for use in processing the fragment data. Raster operations unit  is a fixed function unit that optionally performs near and far plane clipping and raster operations, such as stencil, z test, and the like, and outputs pixel data as processed graphics data  for storage in graphics memory.","In some embodiments of the present invention, geometry processing unit  is replaced with a fixed function unit that is not configured to execute a geometry shader program and graphics device driver  does not use assembly shader instructions from unified ISA  to produce microcode for execution by the fixed function unit. Because each of the fixed function units may not support the same interfaces, the shader programs for each of the execution units may need to include domain specific code for the input and output interfaces that match the interface of the corresponding fixed function unit. For example, inputs to rasterizer  are vertices and outputs of rasterizer  are fragments. Therefore, a shader program type, e.g., vertex, geometry, fragment, is used to specify the input and output semantics for a shader program as needed to interface with the fixed function units within a graphics processor. Although assembly instructions from unified ISA  may be used for any shader program, programs for different shader types may vary as needed to interface with the fixed function units.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 5","b":["250","350","500","420","425","510","420","425","200","300","510","420","425","515","245","345","520","245","345","200","300","525","510","420","425","420","425","525","240","340","245","515","520","525","245"]},"In step  GPU unified microcode assembler  or  converts the shader program expressed in assembly shader instructions in unified ISA  or  into shader program microcode for execution by a shader processing unit. In step  graphics device driver  or  outputs the shader program microcode for execution by the shader processing unit. In other embodiments of the present invention, graphics device driver  or  may output an executable file for execution at a later time by the shader processing unit. Persons skilled in the art will appreciate that any system configured to perform the method steps of  or its equivalents, is within the scope of the present invention.","Unified ISA  and  provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers. A uniform set of structured branching constructs, e.g., if tests, loops, and subroutines that fully support runtime condition testing are also included in unified ISA  and . For example, a conventional if\/then\/else construct represented in c code is shown in TABLE 1A.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"if (A>B)"]},{"entry":[{},{},"\u2003A = A + 1;"]},{"entry":[{},{},"else"]},{"entry":[{},{},"\u2003B = B + 1;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["200","300","245","345"]},"The if\/then\/else construct for a vertex shader program, written without using unified ISA  or , is shown in TABLE 1B.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1B"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003TEMP R0, A, B;","# declaration"]},{"entry":["\u2003ADDC R0.x, A.x, \u2212B.x;","# add the first component of vectors"]},{"entry":["\u2003BRA else (LE.x)","# branch if the sum was <=0"]},{"entry":["\u2003ADD A.x, A.x, 1;",{}]},{"entry":["\u2003BRA endif;","# jump to an \u201cendif\u201d"]},{"entry":["else:",{}]},{"entry":["\u2003ADD B.x, B.x, 1;",{}]},{"entry":"endif:"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The if\/then\/else construct for a shader program, written using unified ISA  or , is shown in TABLE 1C. The construct shown in TABLE 1C may be used for a conventional fragment program, but not for a conventional vertex shader program. Note that the branch instructions that are used in the conventional vertex shader program shown in TABLE 1B are not needed when unified ISA  or  is used to express the shader program.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TEMP R0, A, B;","# declaration"]},{"entry":[{},"ADDC R0.x, A.x, \u2212B.x;",{}]},{"entry":[{},"IF GT.x;",{}]},{"entry":[{},"ADD A.x, A.x, 1;",{}]},{"entry":[{},"ELSE;",{}]},{"entry":[{},"ADD B.x, B.x, 1;",{}]},{"entry":[{},"ENDIF;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A conventional loop construct used for a 10 iteration loop that is represented in C code is shown in TABLE 2A.",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"for (i = 0; i < 10; i++) {",{}]},{"entry":[{},{},"\u2003sum = sum + c[i];",{}]},{"entry":[{},{},"\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The sum operation is performed 10 times, once for each value of i as i is incremented from 0 to 10. In a conventional shader programming environment, a different set of instructions is used to implement the same loop construct, depending on whether the construct is used in a shader program or a vertex program, as shown in TABLES 2B and 2C. When unified ISA  or  is used, the same construct may be used for vertex, fragment, and geometry programs as shown in TABLE 2D.","The loop construct for a vertex shader program, written without using unified ISA  or , is shown in TABLE 2B.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2B"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ADDRESS A0;",{}]},{"entry":["TEMP sum, t;",{}]},{"entry":["PARAM c[10];",{}]},{"entry":["MOV t, {10, 0, \u22121, 1};",{}]},{"entry":["ARLC A0, t;",{}]},{"entry":["loop:",{}]},{"entry":["BRA end (LE.x);",{}]},{"entry":["ADD sum.x, sum.x, c[A0.y];",{}]},{"entry":["ARAC A0.xy, A0;","# special instruction to do loops"]},{"entry":["BRA loop","# do another iteration"]},{"entry":"end:"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"\u201cA0\u201d is a four-component integer \u201caddress register\u201d with capability that is limited to performing indexed array lookups and sum and t are floating-point temporaries. c[ ] is an array of constants. The instruction MOV t.xy, {10, 0, \u22121, 1} specifies a special address register value t with 10 as a the number of loops left, 0 as the starting loop counter, \u22121 is added to the number of loops left for each step, and 1 is added to the loop counter for each step. The instruction ARLC A0, t loads the address register with t and updates a condition code based on the value of t. The branch instruction, BRA end (LE.x) causes the loop to jump to \u201cend\u201d when the number of loops left is less than or equal (LE) to 0. Otherwise, the sum is computed where c[A0.y] uses the loop counter A0.y to fetch the constant for that iteration. The ARAC instruction is used to perform loops by computing A0.x=A0.x+A0.z to decrement the number of loops left and A0.y=A0.y+A0.w to increment the loop counter. General purpose math is not allowed using the address register, so the ARAC instruction is used to perform the operations needed for looping. Finally, a second branch instruction, BRA loop is used to perform another iteration of the loop.","The loop construct for a fragment shader program, written without using unified ISA  or , is shown in TABLE 2C.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"TEMP sum;",{}]},{"entry":[{},{},"LOOP {10, 0, 1};",{}]},{"entry":[{},{},"ADD sum.x, sum.x, fragment.texcoord[A0.x];",{}]},{"entry":[{},{},"ENDLOOP;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Sum and t are floating-point temporaries. The instruction LOOP {10, 0, 1} specifies a loop instruction with 10 as the number of iterations, 0 as the starting loop counter, and 1 is added to the loop counter for each step. The loop instruction values must be constants because the conventional fragment program architecture does not permit loops with the iteration count determined at run time. The ADD instruction adds in a value passed in an array of texture coordinates from a vertex shader. A0.x is a special loop counter that is only available in the innermost LOOP construct. The conventional fragment program architecture doesn't allow indexing of constants.","The loop construct for a shader program, written using unified ISA  or , is shown in TABLE 2D. Note that branch instructions and specialized counters are not needed to perform a loop operation when unified ISA  or  is used to express the shader program.",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2D"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"INT TEMP t;",{}]},{"entry":[{},{},"TEMP sum;",{}]},{"entry":[{},{},"\u2002PARAM c[10];",{}]},{"entry":[{},{},"\u2002MOV.S t.x, 0;",{}]},{"entry":[{},{},"\u2002REP 10;",{}]},{"entry":[{},{},"\u2002ADD sum.x, sum.x, c[t.x];",{}]},{"entry":[{},{},"\u2002ADD.S t.x, t.x, 1;",{}]},{"entry":[{},{},"\u2002ENDREP;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"t is an integer temporary and sum is a floating point value. The MOV.S instruction loads t with the integer 0. The REP (repeat) instruction causes the block of code between REP and ENDREP to be repeated 10 times. The first ADD instruction computes the sum, using the loop counter as an index. The second ADD instruction increments the loop counter, t.x. Note that the ADD instruction in the code shown in TABLE 2C uses the loop counter as an index. Therefore, no arithmetic operations can be performed on the loop counter using the conventional fragment program architecture.","A conventional loop until done construct that is represented in C code is shown in TABLE 3A. C is multiplied by itself until c is greater than or equal to 18.",{"@attributes":{"id":"p-0079","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"float c = 1.7;",{}]},{"entry":[{},{},"while (c < 18) {",{}]},{"entry":[{},{},"\u2003c = c * c;",{}]},{"entry":[{},{},"\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The loop until done construct for a conventional vertex shader program, written without using unified ISA  or , is shown in TABLE 3B.",{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"\u2002TEMP c;",{}]},{"entry":[{},{},"\u2002MOV c.x, 1.7;",{}]},{"entry":[{},{},"loop:",{}]},{"entry":[{},{},"\u2002ADDC c.y, c.x, \u221218;",{}]},{"entry":[{},{},"\u2002BRA endloop (GE.y);",{}]},{"entry":[{},{},"\u2002MUL c.x, c.x, c.x;",{}]},{"entry":[{},{},"\u2002BRA loop;",{}]},{"entry":[{},{},"endloop:"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The loop until done construct for a conventional fragment shader program, written without using unified ISA  or , is shown in TABLE 3C. There is no dynamic branching support for loop instructions in fragment shader program. Therefore the REP instruction must use a constant upper bound to perform a loop and a break instruction (BRK) to exit the loop. Note that this mechanism does not work when a constant upper bound on the number of loop iterations cannot be determined statically.",{"@attributes":{"id":"p-0083","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"TEMP c;",{}]},{"entry":[{},{},"\u2002MOV c.x, 1.7;",{}]},{"entry":[{},{},"\u2002REP {100};",{}]},{"entry":[{},{},"\u2003ADDC c.y, c.x, \u221218;",{}]},{"entry":[{},{},"\u2003BRK GE.x;",{}]},{"entry":[{},{},"\u2003MUL c.x, c.x, c.x;",{}]},{"entry":[{},{},"\u2002ENDREP"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The loop until done construct for a shader program, written using unified ISA  or , is shown in TABLE 3D. Note that branch instructions and an upper bound for the REP instruction are not needed when unified ISA  or  is used to express the shader program.",{"@attributes":{"id":"p-0085","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3D"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"TEMP c;",{}]},{"entry":[{},{},"\u2002MOV c.x, 1.7;",{}]},{"entry":[{},{},"\u2002REP;",{}]},{"entry":[{},{},"\u2003ADDC c.y, c.x, \u221218;",{}]},{"entry":[{},{},"\u2003BRK GE.x;",{}]},{"entry":[{},{},"\u2003MUL c.x, c.x, c.x;",{}]},{"entry":[{},{},"\u2002ENDREP"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The unified instruction set provided by unified ISA  and  provides shader instructions that may be used to express vertex, fragment, and geometry programs. Functions that use the unified instruction set may be included in shader, vertex, or geometry programs without modification. Existing shader programs may be compiled to produce shader microcode based on the unified instruction set. HLL compilers may be used to convert HLL shader programs into shader microcode using unified ISA  or . The shader microcode may then be executed by graphics processors designed to support unified ISA  and  and new hardware features exposed by the unified assembly instructions. A single instruction set enables easy access for new graphics hardware features and faster compile times for shader programs.","Unified ISA  or  includes some new procedures and functions that may be used for vertex, fragment, and geometry shader programs. TABLE 4 lists the new procedures and functions where PLP stands for ProgramLocalParameters, PEP stands for ProgramEnvParameter, and GPLP stands for GetProgramLocalParameter.",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void PLPI4iNV(enum target, uint index, int x, int y, int z, int w);"},{"entry":"void PLPI4ivNV(enum target, uint index, const int *params);"},{"entry":"void PLPI4ivNV(enum target, uint index, sizei count, const int *params);"},{"entry":"void PLPI4uiNV(enum target, uint index, uint x, uint y, uint z, uint w);"},{"entry":"void PLPI4uivNV(enum target, uint index, const uint *params);"},{"entry":"void PLPI4uivNV(enum target, uint index, sizei count, const uint *params);"},{"entry":"void PEPI4iNV(enum target, uint index, int x, int y, int z, int w);"},{"entry":"void PEPI4ivNV(enum target, uint index, const int *params);"},{"entry":"void PEPI4ivNV(enum target, uint index, sizei count, const int *params);"},{"entry":"void PEPI4uiNV(enum target, uint index, uint x, uint y, uint z, uint w);"},{"entry":"void PEPI4uivNV(enum target, uint index, const uint *params);"},{"entry":"void PEPI4uivNV(enum target, uint index, sizei count, const uint *params);"},{"entry":"void GPLPIivNV(enum target, uint index, int *params);"},{"entry":"void GPLPIuivNV(enum target, uint index, uint *params);"},{"entry":"void GPLPIivNV(enum target, uint index, int *params);"},{"entry":"void GPLPIuivNV(enum target, uint index, uint *params);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Unified ISA  or  includes some new tokens that may be used for vertex, fragment, and geometry shader programs. TABLE 5A lists the new tokens that are accepted by the <pname> parameter of GetBooleanv, GetIntegerv, GetFloatv, and GetDoublev.",{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 5A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MIN_PROGRAM_TEXEL_OFFSET_NV","0x8904"]},{"entry":[{},"MAX_PROGRAM_TEXEL_OFFSET_NV","0x8905"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0091","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5B"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PROGRAM_ATTRIB_COMPONENTS_NV","0x8906"]},{"entry":["PROGRAM_RESULT_COMPONENTS_NV","0x8907"]},{"entry":["MAX_PROGRAM_ATTRIB_COMPONENTS_NV","0x8908"]},{"entry":["MAX_PROGRAM_RESULT_COMPONENTS_NV","0x8909"]},{"entry":["MAX_PROGRAM_GENERIC_ATTRIBS_NV","0x8DA5"]},{"entry":["MAX_PROGRAM_GENERIC_RESULTS_NV","0x8DA6"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Each program object has an associated array of program local parameters. Program local parameters are four-component vectors whose components can hold floating-point, signed integer, or unsigned integer values. The data type of each local parameter is established when the parameter's values are assigned. If a program attempts to read a local parameter using a data type other than the one used when the parameter is set, the values returned are undefined. TABLE 6A lists commands included in unified ISA  or  that update the values of the program local parameter numbered <index> belonging to the program object currently bound to <target>. For the non-vector versions of these commands, the four components of the parameter are updated with the values of <x>, <y>, <z>, and <w>, respectively. For the vector versions, the components of the parameter are updated with the array of four values pointed to by <params>. The error INVALID_VALUE is generated if <index> is greater than or equal to the number of program local parameters supported by <target>.",{"@attributes":{"id":"p-0093","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6A"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","PLP4fARB(enum target, uint index, float x, float y, float z, float w);"]},{"entry":["void","PLP4fvARB(enum target, uint index, const float *params);"]},{"entry":["void","PLP4dARB(enum target, uint index, double x, double y, double z, "]},{"entry":[{},"double w);"]},{"entry":["void","PLP4dvARB(enum target, uint index, const double *params);"]},{"entry":["void","PLPI4iNV(enum target, uint index, int x, int y, int z, int w);"]},{"entry":["void","PLPI4ivNV(enum target, uint index, const int *params);"]},{"entry":["void","PLPI4uiNV(enum target, uint index, uint x, uint y, uint z, uint w);"]},{"entry":["void","PLPI4uivNV(enum target, uint index, const uint *params);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"TABLE 6B lists commands included in unified ISA  or  that update the values of the program local parameters numbered <index> through <index>+<count>\u22121 with the array of 4*<count> values pointed to by <params>. The error INVALID_VALUE is generated if the sum of <index> and <count> is greater than the number of program local parameters supported by <target>.",{"@attributes":{"id":"p-0095","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 6B"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void PLP4fvNV(enum target, uint index, sizei count, const float *params);"},{"entry":"void PLPI4ivNV(enum target, uint index, sizei count, const int *params);"},{"entry":"void PLPI4uivNV(enum target, uint index, sizei count, const uint *params);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"When a program local parameter is updated, the data type of its components is assigned according to the data type of the provided values. If values provided are of type \u201cfloat\u201d or \u201cdouble\u201d, the components of the parameter are floating-point. If the values provided are of type \u201cint\u201d, the components of the parameter are signed integers. If the values provided are of type \u201cuint\u201d, the components of the parameter are unsigned integers.","Additionally, each program target has an associated array of program environment parameters. Unlike program local parameters, program environment parameters are shared by all program objects of a given target. Program environment parameters are four-component vectors whose components can hold floating-point, signed integer, or unsigned integer values. The data type of each environment parameter is established when the parameter's values are assigned. If a program attempts to read an environment parameter using a data type other than the one used when the parameter is set, the values returned are undefined. TABLE 6C lists commands included in unified ISA  or  that update the values of the program environment parameter numbered <index> for the given program target <target>. For the non-vector versions of these commands, the four components of the parameter are updated with the values of <x>, <y>, <z>, and <w>, respectively. For the vector versions, the four components of the parameter are updated with the array of four values pointed to by <params>. The error INVALID_VALUE is generated if <index> is greater than or equal to the number of program environment parameters supported by <target>.",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6C"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","PEP4fARB(enum target, uint index, float x, float y, float z, float w);"]},{"entry":["void","PEP4fvARB(enum target, uint index, const float *params);"]},{"entry":["void","PEP4dARB(enum target, uint index, double x, double y, double z, "]},{"entry":[{},"double w);"]},{"entry":["void","PEP4dvARB(enum target, uint index, const double *params);"]},{"entry":["void","ProgramEnvParameterI4iNV(enum target, uint index, int x, int y,"]},{"entry":[{},"int z, int w);"]},{"entry":["void","ProgramEnvParameterI4ivNV(enum target, uint index, const"]},{"entry":[{},"int *params);"]},{"entry":["void","PEPI4uiNV(enum target, uint index, uint x, uint y, uint z, uint w);"]},{"entry":["void","PEPI4uivNV(enum target, uint index, const uint *params);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"TABLE 6D lists commands included in unified ISA  or  that update the values of the program environment parameters numbered <index> through <index>+<count>\u22121 with the array of 4*<count> values pointed to by <params>. The error INVALID_VALUE is generated if the sum of <index> and <count> is greater than the number of program local parameters supported by <target>.",{"@attributes":{"id":"p-0100","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6D"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"void PEP4fvNV(enum target, uint index, sizei count,"]},{"entry":[{},{},"const float *params);"]},{"entry":[{},{},"void PEPI4ivNV(enum target, uint index, sizei count,"]},{"entry":[{},{},"const int *params);"]},{"entry":[{},{},"void PEPI4uivNV(enum target, uint index, sizei count,"]},{"entry":[{},{},"const uint *params);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"When a program environment parameter is updated, the data type of its components is assigned according to the data type of the provided values. If values provided are of type \u201cfloat\u201d or \u201cdouble\u201d, the components of the parameter are floating-point. If the values provided are of type \u201cint\u201d, the components of the parameter are signed integers. If the values provided are of type \u201cuint\u201d, the components of the parameter are unsigned integers.","GPU program strings are specified as an array of ASCII characters containing the program text. When a GPU program is loaded by a call to ProgramStringARB, the program string is parsed into a set of tokens possibly separated by whitespace. Spaces, tabs, newlines, carriage returns, and comments are considered whitespace. Comments begin with the character \u201c#\u201d and are terminated by a newline, a carriage return, or the end of the program array.","The Backus-Naur Form (BNF) grammar shown in TABLE 7 specifies the syntactically valid sequences for GPU programs. The set of valid tokens can be inferred from the grammar. A line containing \u201c\/* empty *\/\u201d represents an empty string and is used to indicate optional rules. A program is invalid if it contains any tokens or characters not defined in this specification. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","Programs may operate on a number of different variables during their execution. The following sections define the different classes of variables that can be declared and used by a program.","Some variable classes require variable bindings. Variable classes with bindings refer to state that is either generated or consumed outside the program. Examples of variable bindings include a vertex's normal, the position of a vertex computed by a vertex program, an interpolated texture coordinate, and the diffuse color of light . Variables that are used only during program execution do not have bindings.","Variables may be declared explicitly according to the <namingStatement> grammar rule. Explicit variable declarations allow a program to establish a variable name that can be used to refer to a specified resource in subsequent instructions. Variables may be declared anywhere in the program string, but must be declared prior to use. A program will fail to load if it declares the same variable name more than once, or if it refers to a variable name that has not been previously declared in the program string. Variables may also be declared implicitly, simply by using a variable binding as an operand in a program instruction. Such uses are considered to automatically create a nameless variable using the specified binding. Only variable from classes with bindings can be declared implicitly.","Explicit variable declarations may include one or more modifiers that specify additional information about the variable, such as the size and data type of the components of the variable. Variable modifiers are specified according to the <varModifier> grammar rule. By default, variables are considered typeless. They can be used in instructions that read or write the variable as floating-point values, signed integers, or unsigned integers. If a variable is written using one data type but then read using a different one, the results of the operation are undefined. Variables with bindings are considered to be read or written when their values are produced or consumed; the data type used by unified ISA  or  is specified in the description of each binding.","Explicitly declared variables may optionally have one data type modifier, which can be used to detect data type mismatch errors. Type modifiers of \u201cINT\u201d, \u201cUINT\u201d, and \u201cFLOAT\u201d indicate that the components of the variable are stored as signed integers, unsigned integers, or floating-point values, respectively. A program will fail to load if it attempts to read or write a variable using a data type other than the one indicated by the data type modifier. Variables without a data type modifier can be read or written using any data type. GPU unified microcode assemblers , , , and  may be configured to perform error checking based on the specified data type modifiers.","Explicitly declared variables may optionally have one storage size modifier. Variables declared as \u201cSHORT\u201d will be represented using at least 16 bits per component. \u201cSHORT\u201d floating-point values will have at least 5 bits of exponent and 10 bits of mantissa. Variables declared as \u201cLONG\u201d will be represented with at least 32 bits per component. \u201cLONG\u201d floating-point values will have at least 8 bits of exponent and 23 bits of mantissa. If no size modifier is provided, GPU unified microcode assembler  and  will automatically select component sizes. Implementations are not required to support more than one component size, so \u201cSHORT\u201d, \u201cLONG\u201d, and the default could all refer to the same component size. Each variable declaration can include at most one data type and one storage size modifier. A program will fail to load if it specifies multiple data type or multiple storage size modifiers in a single variable declaration.","Explicitly declared variables of all types may be declared as arrays. An array variable has one or more members, numbered 0 through <n>\u22121, where <n> is the number of entries in the array. The total number of entries in the array can be declared using the <optArraySize> grammar rule. For variable classes without bindings, an array size must be specified in the program, and must be a positive integer. For variable classes with bindings, a declared size is optional, and is taken from the number of bindings assigned in the declaration if omitted. A program will fail to load if the declared size of an array variable does not match the number of assigned bindings.","When a variable is declared as an array, instructions that use the variable must specify an array member to access according to the <arrayMem> grammar rule. A program will fail to load if it contains an instruction that accesses an array variable without specifying an array member or an instruction that specifies an array member for a non-array variable.","Program attribute variables represent per-vertex or per-fragment inputs to the program. All attribute variables have associated bindings, and are read-only during program execution. Attribute variables may be declared explicitly via the <ATTRIB_statement> grammar rule, or implicitly by using an attribute binding in an instruction. The set of available attribute bindings depends on the program type, and is enumerated in the specifications for each program type. A special modifier for fragment programs may be used to control the interpolation state. The special modifier specifies the type of interpolation to be used for the attribute, e.g., flat, centroid, or centroid without perspective correction.","The set of bindings allowed for attribute array variables is limited to attribute state grouped in arrays (e.g., texture coordinates, generic vertex attributes). Unified ISA  and  provides a generic array that can be used to pass variables between adjacent program stages, i.e., from a vertex shader to a geometry shader. Conventional instruction architectures use variables with specific meanings, e.g., color, position, or texture coordinates, to pass data between different program stages. Additionally, all bindings assigned to the array must be of the same binding type and must increase consecutively. Examples of valid and invalid binding lists are shown in TABLE 8.",{"@attributes":{"id":"p-0114","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vertex.attrib[1], vertex.attrib[2]","#valid, 2-entry array"]},{"entry":["vertex.texcoord[0..3]","#valid, 4-entry array"]},{"entry":["vertex.attrib[1], vertex.attrib[3]","#invalid, skipped attrib 2"]},{"entry":["vertex.attrib[2], vertex.attrib[1]","#invalid, wrong order"]},{"entry":["vertex.attrib[1], vertex.texcoord[2]","#invalid, different types"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Implementations may have a limit on the total number of attribute binding components used by each program target (MAX_PROGRAM_ATTRIB_COMPONENTS). Programs that use more attribute binding components than this limit will fail to load. The method of counting used attribute binding components is implementation-dependent, but must satisfy the following properties (1) if an attribute binding is not referenced in a program, or is referenced only in declarations of attribute variables that are not used, none of its components are counted (2) an attribute binding component may be counted as used only if there exists an instruction operand where the component is enabled for read by the swizzle pattern and the attribute binding is referenced directly by the operand, bound to a declared variable referenced by the operand, or bound to a declared array variable where another binding in the array satisfies one of the two previous conditions.","Implementations are not required to optimize out unused elements of an attribute array or components that are used in only some elements of an array. The last of these rules is intended to cover the case where the same attribute binding is used in multiple variables. For example, an operand whose swizzle pattern selects only the x component may result in the x component of an attribute binding being counted, but may never result in the counting of the y, z, or w components of any attribute binding. Implementations are not required to determine that components read by an instruction are actually unused due to (1) write masks (for example, a component-wise ADD operation that only writes the \u201cx\u201d component doesn't have to read the \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d components of its operands) or (2) any other properties of the instruction (for example, the DP3 instruction computes a 3-component dot product doesn't have to read the \u201cw\u201d component of its operands).","Program parameter variables are used as constants during program execution. All program parameter variables have associated bindings and are read-only during program execution. Program parameters retain their values across program invocations, although their values may change between invocations due to GL state changes. Program parameter variables may be declared explicitly via the <PARAM_statement> grammar rule, or implicitly by using a parameter binding in an instruction. Except where otherwise specified, program parameter bindings always specify floating-point values.","When declaring program parameter array variables, all bindings are supported and can be assigned to array members in any order. The only restriction is that no parameter binding may be used more than once in array variables accessed using relative addressing. A program will fail to load if any program parameter binding is used more than once in a single array accessed using relative addressing or used at least once in two or more arrays accessed using relative addressing.","If a program parameter binding matches the <constantScalar> or <signedConstantScalar> grammar rules, the corresponding program parameter variable is bound to the vector (X,X,X,X), where X is the value of the specified constant. If a program parameter binding matches <constantVector>, the corresponding program parameter variable is bound to the vector (X,Y,Z,W), where X, Y, Z, and W are the values corresponding to the first, second, third, and fourth match of <signedConstantScalar>. If fewer than four constants are specified, Y, Z, and W assume the values 0, 0, and 1, if their respective constants are not specified.","Constant bindings can be interpreted as having signed integer, unsigned integer, or floating-point values, depending on how they are used in the program text. For constants in variable declarations, the components of the constant are interpreted according to the variable's component data type modifier. If no data type modifier is specified in a declaration, constants are interpreted as floating-point values. For constant bindings used directly in an instruction, the components of the constant are interpreted according to the required data type of the operand. A program will fail to load if it specifies a floating-point constant value (matching the <floatConstant> grammar rule) that should be interpreted as a signed or unsigned integer, or a negative integer constant value that should be interpreted as an unsigned integer.","If the value used to specify a floating-point constant can not be exactly represented, the nearest floating-point value will be used. If the value used to specify an integer constant is too large to be represented, the program will fail to load. TABLE 9A lists program environmental\/local parameter bindings where <a> and <b> indicate parameter numbers, where <a> must be less than or equal to <b>.",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9A"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Binding","Components","Underlying State"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["program.env[a]","(x, y, z, w)","program environment parameter a"]},{"entry":["program.local[a]","(x, y, z, w)","program local parameter a"]},{"entry":["program.env[a..b]","(x, y, z, w)","program environment"]},{"entry":[{},{},"parameters a through b"]},{"entry":["program.local[a..b]","(x, y, z, w)","program local parameters"]},{"entry":[{},{},"a through b"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"If a program parameter binding matches \u201cprogram.env[a]\u201d or \u201cprogram.local[a]\u201d, the four components of the program parameter variable are filled with the four components of program environment parameter <a> or program local parameter <a> respectively. Additionally, for program parameter array bindings, \u201cprogram.env[a . . . b]\u201d and \u201cprogram.local[a . . . b]\u201d are equivalent to specifying program environment or local parameters <a> through <b> in order, respectively. A program using any of these bindings will fail to load if <a> is greater than <b>.","Program environment and local parameters are typeless, and may be specified as signed integer, unsigned integer, or floating-point variables. If a program environment parameter is read using a data type other than the one used to specify it, an undefined value is returned. TABLE 9B lists material property bindings.",{"@attributes":{"id":"p-0125","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9B"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Binding","Components","Underlying State"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["state.material.ambient","(r, g, b, a)","front ambient material color"]},{"entry":["state.material.diffuse","(r, g, b, a)","front diffuse material color"]},{"entry":["state.material.specular","(r, g, b, a)","front specular material color"]},{"entry":["state.material.emission","(r, g, b, a)","front emissive material color"]},{"entry":["state.material.shininess","(s, 0, 0, 1)","front material shininess"]},{"entry":["state.material.front.ambient","(r, g, b, a)","front ambient material color"]},{"entry":["state.material.front.diffuse","(r, g, b, a)","front diffuse material color"]},{"entry":["state.material.front.specular","(r, g, b, a)","front specular material color"]},{"entry":["state.material.front.emission","(r, g, b, a)","front emissive material color"]},{"entry":["state.material.front.shininess","(s, 0, 0, 1)","front material shininess"]},{"entry":["state.material.back.ambient","(r, g, b, a)","back ambient material color"]},{"entry":["state.material.back.diffuse","(r, g, b, a)","back diffuse material color"]},{"entry":["state.material.back.specular","(r, g, b, a)","back specular material color"]},{"entry":["state.material.back.emission","(r, g, b, a)","back emissive material color"]},{"entry":["state.material.back.shininess","(s, 0, 0, 1)","back material shininess"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"If a material face is not specified in the binding, the front property is used. If a program parameter binding matches any of the material properties listed in TABLE 9B, the program parameter variable is filled according to TABLE 9B. For ambient, diffuse, specular, or emissive colors, the \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d components are filled with the \u201cr\u201d, \u201cg\u201d, \u201cb\u201d, and \u201ca\u201d components, respectively, of the corresponding material color. For material shininess, the \u201cx\u201d component is filled with the material's specular exponent, and the \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d components are filled with the floating-point constants 0, 0, and 1, respectively. Bindings containing \u201c.back\u201d refer to the back material; all other bindings refer to the front material.","Material properties can be changed inside a Begin\/End pair, either directly by calling Material, or indirectly through color material. However, such property changes are not guaranteed to update program parameter bindings until the following End command. Program parameter variables bound to material properties changed inside a Begin\/End pair are undefined until the following End command.","TABLE 9C lists light property bindings where <n> indicates a light number.",{"@attributes":{"id":"p-0129","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9C"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"Com-",{}]},{"entry":["Binding","ponents","Underlying State"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["state.light[n].ambient","(r, g, b, a)","light n ambient color"]},{"entry":["state.light[n].diffuse","(r, g, b, a)","light n diffuse color"]},{"entry":["state.light[n].specular","(r, g, b, a)","light n specular color"]},{"entry":["state.light[n].position","(x, y, z, w)","light n position"]},{"entry":["state.light[n].attenuation","(a, b, c, e)","light n attenuation constants"]},{"entry":[{},{},"and spot light exponent"]},{"entry":["state.light[n].spot.direction","(x, y, z, c)","light n spot direction and"]},{"entry":[{},{},"cutoff angle cosine"]},{"entry":["state.light[n].half","(x, y, z, 1)","light n infinite half-angle"]},{"entry":["state.lightmodel.ambient","(r, g, b, a)","light model ambient color"]},{"entry":["state.lightmodel.scenecolor","(r, g, b, a)","light model front scene color"]},{"entry":["state.lightmodel.front.scenecolor","(r, g, b, a)","light model front scene color"]},{"entry":["state.lightmodel.back.scenecolor","(r, g, b, a)","light model back scene color"]},{"entry":["state.lightprod[n].ambient","(r, g, b, a)","light n\/front material ambient"]},{"entry":[{},{},"color product"]},{"entry":["state.lightprod[n].diffuse","(r, g, b, a)","light n\/front material diffuse"]},{"entry":[{},{},"color product"]},{"entry":["state.lightprod[n].specular","(r, g, b, a)","light n\/front material specular"]},{"entry":[{},{},"color product"]},{"entry":["state.lightprod[n].front.ambient","(r, g, b, a)","light n\/front material ambient"]},{"entry":[{},{},"color product"]},{"entry":["state.lightprod[n].front.diffuse","(r, g, b, a)","light n\/front material diffuse"]},{"entry":[{},{},"color product"]},{"entry":["state.lightprod[n].front.specular","(r, g, b, a)","light n\/front material specular"]},{"entry":[{},{},"color product"]},{"entry":["state.lightprod[n].back.ambient","(r, g, b, a)","light n\/back material ambient"]},{"entry":[{},{},"color product"]},{"entry":["state.lightprod[n].back.diffuse","(r, g, b, a)","light n\/back material diffuse"]},{"entry":[{},{},"color product"]},{"entry":["state.lightprod[n].back.specular","(r, g, b, a)","light n\/back material"]},{"entry":[{},{},"specular color product"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"If a program parameter binding matches \u201cstate.light[n].attenuation\u201d, the \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d components of the program parameter variable are filled with the constant, linear, and quadratic attenuation parameters of the specified light, respectively. The \u201cw\u201d component of the program parameter variable is filled with the spot light exponent of the specified light. If a program parameter binding matches \u201cstate.light[n].spot.direction\u201d, the \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d components of the program parameter variable are filled with the \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d components of the spot light direction of the specified light, respectively. The \u201cw\u201d component of the program parameter variable is filled with the cosine of the spot light cutoff angle of the specified light. If a program parameter binding matches \u201cstate.light[n].half\u201d, the \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d components of the program parameter variable are filled with the x, y, and z components, respectively, of the normalized infinite half-angle vector h_inf=\u2225P+(0, 0, 1)\u2225.","The \u201cw\u201d component is filled with 1.0. In the computation of h_inf, P consists of the x, y, and z coordinates of the normalized vector from the eye position P_e to the eye-space light position P_pli. h_inf is defined to correspond to the normalized half-angle vector when using an infinite light (w coordinate of the position is zero) and an infinite viewer (v_bs is FALSE). For local lights or a local viewer, h_inf is well-defined but does not match the normalized half-angle vector, which will vary depending on the vertex position.","If a program parameter binding matches \u201cstate.lightmodel.ambient\u201d, the \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d components of the program parameter variable are filled with the \u201cr\u201d, \u201cg\u201d, \u201cb\u201d, and \u201ca\u201d components of the light model ambient color, respectively. If a program parameter binding matches \u201cstate.lightmodel.scenecolor\u201d or \u201cstate.lightmodel.front.scenecolor\u201d, the \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d components of the program parameter variable are filled with the \u201cr\u201d, \u201cg\u201d, and \u201cb\u201d components respectively of the \u201cfront scene color\u201d c_scene=a_cs*a_cm+e_cm, where a_cs is the light model ambient color, a_cm is the front ambient material color, and e_cm is the front emissive material color. The \u201cw\u201d component of the program parameter variable is filled with the alpha component of the front diffuse material color. If a program parameter binding matches \u201cstate.lightmodel.back.scenecolor\u201d, a similar back scene color, computed using back-facing material properties, is used. The front and back scene colors match the values that would be assigned to vertices using conventional lighting if all lights were disabled.","If a program parameter binding matches anything beginning with \u201cstate.lightprod[n]\u201d, the \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d components of the program parameter variable are filled with the \u201cr\u201d, \u201cg\u201d, and \u201cb\u201d components, respectively, of the corresponding light product. The three light product components are the products of the corresponding color components of the specified material property and the light color of the specified light (see TABLE 9C). The \u201cw\u201d component of the program parameter variable is filled with the alpha component of the specified material property.","Light products depend on material properties, which can be changed inside a Begin\/End pair. Such property changes are not guaranteed to take effect until the following End command. Program parameter variables bound to light products whose corresponding material property changes inside a Begin\/End pair are undefined until the following End command. TABLE 9D lists texture coordinate generation property bindings, where [n]\u201d is optional\u2014texture unit <n> is used if specified; texture unit 0 is used otherwise.",{"@attributes":{"id":"p-0135","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9D"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Binding","Components","Underlying State"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["state.texgen[n].eye.s","(a, b, c, d)","TexGen eye linear plane"]},{"entry":[{},{},"coefficients, s coord, unit n"]},{"entry":["state.texgen[n].eye.t","(a, b, c, d)","TexGen eye linear plane"]},{"entry":[{},{},"coefficients, t coord, unit n"]},{"entry":["state.texgen[n].eye.r","(a, b, c, d)","TexGen eye linear plane"]},{"entry":[{},{},"coefficients, r coord, unit n"]},{"entry":["state.texgen[n].eye.q","(a, b, c, d)","TexGen eye linear plane"]},{"entry":[{},{},"coefficients, q coord, unit n"]},{"entry":["state.texgen[n].object.s","(a, b, c, d)","TexGen object linear plane"]},{"entry":[{},{},"coefficients, s coord, unit n"]},{"entry":["state.texgen[n].object.t","(a, b, c, d)","TexGen object linear plane"]},{"entry":[{},{},"coefficients, t coord, unit n"]},{"entry":["state.texgen[n].object.r","(a, b, c, d)","TexGen object linear plane"]},{"entry":[{},{},"coefficients, r coord, unit n"]},{"entry":["state.texgen[n].object.q","(a, b, c, d)","TexGen object linear plane"]},{"entry":[{},{},"coefficients, q coord, unit n"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 9E lists fog property bindings.",{"@attributes":{"id":"p-0137","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9E"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Binding","Components","Underlying State"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["state.fog.color","(r, g, b, a)","RGB fog color (section 3.10)"]},{"entry":["state.fog.params","(d, s, e, r)","fog density, linear start and end,"]},{"entry":[{},{},"and 1\/(end-start)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 9F lists clip plane property bindings, where <n> specifies the clip plane number, and is required.",{"@attributes":{"id":"p-0139","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9F"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Binding","Components","Underlying State"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["state.clip[n].plane","(a, b, c, d)","clip plane n coefficients"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 9G lists point property bindings.",{"@attributes":{"id":"p-0141","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9G"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Binding","Components","Underlying State"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["state.point.size","(s, n, x, f)","point size, min and max size"]},{"entry":[{},{},"clamps, and fade threshold"]},{"entry":["state.point.attenuation","(a, b, c, 1)","point size attenuation constants"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 9H lists texture environment property bindings, where \u201c[n]\u201d is optional\u2014texture unit <n> is used if specified; texture unit 0 is used otherwise.",{"@attributes":{"id":"p-0143","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9G"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Binding","Components ","Underlying State"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["state.texenv[n].color","(r, g, b, a)","texture environment n color"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 9I lists depth property bindings.",{"@attributes":{"id":"p-0145","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9I"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Binding","Components","Underlying State"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["state.depth.range","(n, f, d, 1)","Depth range near, far, "]},{"entry":[{},{},"and (far-near)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 9J lists matrix property bindings, where the \u201c[n]\u201d syntax indicates a specific matrix number.",{"@attributes":{"id":"p-0147","num":"0146"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9J"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Binding","Underlying State"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"* state.matrix.modelview[n]","modelview matrix n"]},{"entry":[{},"state.matrix.projection","projection matrix"]},{"entry":[{},"state.matrix.mvp","modelview-projection matrix"]},{"entry":[{},"* state.matrix.texture[n]","texture matrix n"]},{"entry":[{},"state.matrix.program[n]","program matrix n"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"If the beginning of a program parameter binding matches any of the matrix binding names listed in Table X.11, the binding corresponds to a 4\u00d74 matrix. If the parameter binding is followed by \u201c.inverse\u201d, \u201c.transpose\u201d, or \u201c.invtrans\u201d (<stateMatModifier> grammar rule), the inverse, transpose, or transpose of the inverse, respectively, of the matrix specified in TABLE 9J is selected. Otherwise, the matrix specified in TABLE 9J is selected. If the specified matrix is poorly-conditioned (singular or nearly so), its inverse matrix is undefined. The binding name \u201cstate.matrix.mvp\u201d refers to the product of modelview matrix zero and the projection matrix, defined as MVP=P*M0, where P is the projection matrix and M0 is modelview matrix zero.","If the selected matrix is followed by \u201c.row[<a>]\u201d (matching the <stateMatrixRow> grammar rule), the \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d components of the program parameter variable are filled with the four entries of row <a> of the selected matrix. In the example, PARAM m0=state.matrix.modelview[1].row[0]; PARAM m1=state.matrix.projection.transpose.row[3]; the variable \u201cm0\u201d is set to the first row (row 0) of modelview matrix 1 and \u201cm1\u201d is set to the last row (row 3) of the transpose of the projection matrix.","For program parameter array bindings, multiple rows of the selected matrix can be bound via the <stateMatrixRows> grammar rule. If the selected matrix binding is followed by \u201c.row[<a> . . . <b>]\u201d, the result is equivalent to specifying matrix rows <a> through <b>, in order. A program will fail to load if <a> is greater than <b>. If no row selection is specified (<optMatrixRows> matches \u201c \u201d), matrix rows 0 through 3 are bound in order. In the example, PARAM m2[ ]={state.matrix.program[0].row[1.2]}; PARAM m3[ ]={state.matrix.program[0].transpose}; the array \u201cm2\u201d has two entries, containing rows 1 and 2 of program matrix zero, and \u201cm3\u201d has four entries, containing all four rows of the transpose of program matrix zero.","Program temporary variables are used to hold temporary results during program execution. Temporaries do not persist between program invocations, and are undefined at the beginning of each program invocation. Temporary variables are declared explicitly using the <TEMP_statement> grammar rule. Each such statement can declare one or more temporaries. Temporaries can not be declared implicitly. Temporaries can be declared using any component size (\u201cSHORT\u201d or \u201cLONG\u201d) and type (\u201cFLOAT\u201d or \u201cINT\u201d) modifier. Temporary variables may be declared as arrays. Temporary variables declared as arrays may be stored in slower memory than those not declared as arrays, and it is recommended to use non-array variables unless array functionality is required.","Program result variables represent the per-vertex or per-fragment results of the program. All result variables have associated bindings, are write-only during program execution, and are undefined at the beginning of each program invocation. Any vertex or fragment attributes corresponding to unwritten result variables will be undefined in subsequent stages of the pipeline. Result variables may be declared explicitly via the <OUTPUT_statement> grammar rule, or implicitly by using a result binding in an instruction. The set of available result bindings depends on the program type, and is enumerated in the specifications for each program type.","Result variables may generally be declared as arrays, but the set of bindings allowed for arrays is limited to state grouped in arrays (e.g., texture coordinates, clip distances, colors). Additionally, all bindings assigned to the array must be of the same binding type and must increase consecutively. Examples of valid and invalid binding lists for vertex programs are shown in TABLE 9K.",{"@attributes":{"id":"p-0154","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9K"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"result.clip[1], result.clip[2]","# valid, 2-entry array"]},{"entry":[{},"result.texcoord[0..3]","# valid, 4-entry array"]},{"entry":[{},"result.texcoord[1], result.texcoord[3]","# invalid, skipped texcoord 2"]},{"entry":[{},"result.texcoord[2], result.texcoord[1]","# invalid, wrong order"]},{"entry":[{},"result.texcoord[1], result.clip[2]","# invalid, different types"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Programs that require more result binding components than this limit will fail to load. The method of counting used result binding components is implementation-dependent, but must satisfy the following properties (1) if a result binding is not referenced in a program, or is referenced only in declarations of result variables that are not used, none of its components are counted and (2) a result binding component may be counted as used only if there exists an instruction operand where (i) the component is enabled in the write mask, and(ii) the result binding is either referenced directly by the operand, bound to a declared variable referenced by the operand, or bound to a declared array variable where another binding in the array satisfies one of the two previous conditions.","Implementations are not required to optimize out unused elements of a result array or components that are used in only some elements of an array. The last of these rules is intended to cover the case where the same result binding is used in multiple variables. For example, an instruction whose write mask selects only the x component may result in the x component of a result binding being counted, but may never result in the counting of the y, z, or w components of any result binding.","Program parameter buffers are arrays consisting of single-component typeless values stored in a buffer object. A buffer object is a portion of graphics memory that may be loaded in a variety of ways, including through graphics processor  or  or by host computer . A bound buffer object functions as an array of four component vectors with a single word of integer or floating-point values corresponding to a four component vector that may be read by graphics processor  or . Unified ISA  and  provides an implementation-dependent number of buffer object binding points for each program target, to which buffer objects can be attached. Program parameter buffer variables can be changed either by updating the contents of bound buffer objects, or simply by changing the buffer object attached to a binding point.","Program parameter buffer variables are used as constants during program execution. All program parameter buffer variables have an associated binding and are read-only during program execution. Program parameter buffers retain their values across program invocations, although their values may change as buffer object bindings or contents change. Program parameter buffer variables must be declared explicitly via the <BUFFER_statement> grammar rule. Program parameter buffer bindings can not be used directly in executable instructions. Program parameter buffer variables may be declared as arrays, but all bindings assigned to the array must use the same binding point and must increase consecutively.","TABLE 9L lists Program Parameter Buffer bindings, where <a> indicates a buffer number, <b> and <c> indicate individual elements.",{"@attributes":{"id":"p-0160","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9L"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Binding","Components","Underlying State"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"program.buffer[a][b]","(x, x, x, x) ","program parameter "]},{"entry":[{},{},{},"buffer a, element b"]},{"entry":[{},"program.buffer[a][b..c]","(x, x, x, x) ","program parameter "]},{"entry":[{},{},{},"buffer a, elements b"]},{"entry":[{},{},{},"through c"]},{"entry":[{},"program.buffer[a]","(x, x, x, x) ","program parameter "]},{"entry":[{},{},{},"buffer a, all elements"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"For program parameter buffer array declarations, \u201cprogram.buffer[a][b . . . c]\u201d is equivalent to specifying elements <b> through <c> of the buffer object bound to binding point <a> in order. For program parameter buffer array declarations, \u201cprogram.buffer[a]\u201d is equivalent to specifying the entire buffer\u2014elements 0 through <n>\u22121, where <n> is either the size of the array (if declared) or the implementation-dependent maximum parameter buffer object size limit (if no size is declared).","The program condition code registers are four-component vectors. Each component of this register is a collection of single-bit flags, including a sign flag (SF), a zero flag (ZF), an overflow flag (OF), and a carry flag (CF). There are two condition code registers (CC0 and CC1), whose values are undefined at the beginning of program execution. Most program instructions can optionally update one of the condition code registers, by designating the condition code to update in the instruction. When a condition code component is updated, the four flags of each component of the condition code are set according to the corresponding component of the instruction result. The value of these four flags can be combined in various condition code tests, which can be used to mask writes to destination variables and to perform conditional branches or other condition operations.","Programs can create aliases by matching the <ALIAS_statement> grammar rule. Aliases allow programs to use multiple variable names to refer to a single underlying variable. For example, the statement ALIAS var1=var0 establishes a variable name of \u201cvar1\u201d. Subsequent references to \u201cvar1\u201d in the program text are treated as references to \u201cvar0\u201d. The left hand side of an ALIAS statement must be a new variable name, and the right hand side must be an established variable name. Aliases are not considered variable declarations, so do not count against the limits on the number of variable declarations allowed in the program text.","The set of instructions supported for GPU programs is given in TABLE 10A. An instruction can use up to three operands when it executes, and most instructions can write a single result vector. Instructions may also specify one or more modifiers, according to the <opModifiers> grammar rule. Instruction modifiers affect how the specified operation is performed.","Shader programs may operate on signed integer, unsigned integer, or floating-point values; some instructions are capable of operating on any of the three types. However, the data type of the operands and the result are always determined based solely on the instruction and its modifiers. If any of the variables used in the instruction are typeless, they will be interpreted according to the data type derived from the instruction. If any variables with a conflicting data type are used in the instruction, the program will fail to load unless the \u201cNTC\u201d (no type checking) instruction modifier is specified.",{"@attributes":{"id":"p-0166","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10A"},{"entry":{"@attributes":{"namest":"1","nameend":"10","align":"center","rowsep":"1"}}},{"entry":["Instruction ","F","I","C","S","H","D","Out ","Inputs","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"10","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ABS","X","X","X","X","X","F","v","v","absolute value"]},{"entry":["ADD","X","X","X","X","X","F","v","v, v","add"]},{"entry":["AND","\u2014","X","X","\u2014","\u2014","S","v","v, v","bitwise and"]},{"entry":["BRK","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","c","break out of loop "]},{"entry":[{},{},{},{},{},{},{},{},{},"instruction"]},{"entry":["CAL","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","c","subroutine call"]},{"entry":["CEIL","X","X","X","X","X","F","v","vf","ceiling"]},{"entry":["CMP","X","X","X","X","X","F","v","v, v, v","compare"]},{"entry":["CONT","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","c","continue with next "]},{"entry":[{},{},{},{},{},{},{},{},{},"loop interation"]},{"entry":["COS","X","\u2014","X","X","X","F","s","s","cosine "]},{"entry":[{},{},{},{},{},{},{},{},{},"with reduction"]},{"entry":[{},{},{},{},{},{},{},{},{},"to [\u2212PI,PI]"]},{"entry":["DIV","X","X","X","X","X","F","v","v, s","divide vector "]},{"entry":[{},{},{},{},{},{},{},{},{},"components by "]},{"entry":[{},{},{},{},{},{},{},{},{},"scalar"]},{"entry":["DP2","X","\u2014","X","X","X","F","s","v, v","2-component "]},{"entry":[{},{},{},{},{},{},{},{},{},"dot product"]},{"entry":["DP2A","X","\u2014","X","X","X","F","s","v, v, v","2-comp. "]},{"entry":[{},{},{},{},{},{},{},{},{},"dot product "]},{"entry":[{},{},{},{},{},{},{},{},{},"w\/scalar add"]},{"entry":["DP3","X","\u2014","X","X","X","F","s","v, v","3-component "]},{"entry":[{},{},{},{},{},{},{},{},{},"dot product"]},{"entry":["DP4","X","\u2014","X","X","X","F","s","v, v","4-component "]},{"entry":[{},{},{},{},{},{},{},{},{},"dot product"]},{"entry":["DPH","X","\u2014","X","X","X","F","s","v, v","homogeneous "]},{"entry":[{},{},{},{},{},{},{},{},{},"dot product"]},{"entry":["DST","X","\u2014","X","X","X","F","v","v, v","distance vector"]},{"entry":["ELSE","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","start if test "]},{"entry":[{},{},{},{},{},{},{},{},{},"else block"]},{"entry":["ENDIF","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","end if test block"]},{"entry":["ENDREP","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","end of repeat block"]},{"entry":["EX2","X","\u2014","X","X","X","F","s","s","exponential base 2"]},{"entry":["FLR","X","X","X","X","X","F","v","vf","floor"]},{"entry":["FRC","X","\u2014","X","X","X","F","v","v","fraction"]},{"entry":["I2F","\u2014","X","X","\u2014","\u2014","S","vf","v","integer to float"]},{"entry":["IF","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","c","start of if test block"]},{"entry":["KIL","X","X","\u2014","\u2014","X","F","\u2014","vc","kill fragment"]},{"entry":["LG2","X","\u2014","X","X","X","F","s","s","logarithm base 2"]},{"entry":["LIT","X","\u2014","X","X","X","F","v","v","compute lighting "]},{"entry":[{},{},{},{},{},{},{},{},{},"coefficients"]},{"entry":["LRP","X","\u2014","X","X","X","F","v","v, v, v","linear interpolation"]},{"entry":["MAD","X","X","X","X","X","F","v","v, v, v","multiply and add"]},{"entry":["MAX","X","X","X","X","X","F","v","v, v","maximum"]},{"entry":["MIN","X","X","X","X","X","F","v","v, v","minimum"]},{"entry":["MOD","\u2014","X","X","\u2014","\u2014","S","v","v, v","modulus"]},{"entry":["MOV","X","X","X","X","X","F","v","v","move"]},{"entry":["MUL","X","X","X","X","X","F","v","v, v","multiply"]},{"entry":["NOT","\u2014","X","X","\u2014","\u2014","S","v","v","bitwise not"]},{"entry":["NRM","X","\u2014","X","X","X","F","v","v","normalize 3-"]},{"entry":[{},{},{},{},{},{},{},{},{},"component vector"]},{"entry":["OR","\u2014","X","X","\u2014","\u2014","S","v","v, v","bitwise or"]},{"entry":["PK2H","X","X","\u2014","\u2014","\u2014","F","s","vf","pack two "]},{"entry":[{},{},{},{},{},{},{},{},{},"16-bit floats"]},{"entry":["PK2US","X","X","\u2014","\u2014","\u2014","F","s","vf","pack two floats as "]},{"entry":[{},{},{},{},{},{},{},{},{},"unsigned 16-bit"]},{"entry":["PK4B","X","X","\u2014","\u2014","\u2014","F","s","vf","pack four floats as "]},{"entry":[{},{},{},{},{},{},{},{},{},"signed 8-bit"]},{"entry":["PK4UB","X","X","\u2014","\u2014","\u2014","F","s","vf","pack four floats as "]},{"entry":[{},{},{},{},{},{},{},{},{},"unsigned 8-bit"]},{"entry":["POW","X","\u2014","X","X","X","F","s","s, s","exponentiate"]},{"entry":["RCC","X","\u2014","X","X","X","F","s","s","reciprocal "]},{"entry":[{},{},{},{},{},{},{},{},{},"(clamped)"]},{"entry":["RCP","X","\u2014","X","X","X","F","s","s","reciprocal"]},{"entry":["REP","X","X","\u2014","\u2014","X","F","\u2014","v","start of repeat "]},{"entry":[{},{},{},{},{},{},{},{},{},"block"]},{"entry":["RET","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","c","subroutine return"]},{"entry":["RFL","X","\u2014","X","X","X","F","v","v, v","reflection vector"]},{"entry":["ROUND","X","X","X","X","X","F","v","vf","round to nearest "]},{"entry":[{},{},{},{},{},{},{},{},{},"integer"]},{"entry":["RSQ","X","\u2014","X","X","X","F","s","s","reciprocal "]},{"entry":[{},{},{},{},{},{},{},{},{},"square root"]},{"entry":["SAD","\u2014","X","X","\u2014","\u2014","S","vu","v, v, vu","sum of absolute "]},{"entry":[{},{},{},{},{},{},{},{},{},"differences"]},{"entry":["SCS","X","\u2014","X","X","X","F","v","s","sine\/cosine "]},{"entry":[{},{},{},{},{},{},{},{},{},"without reduction"]},{"entry":["SEQ","X","X","X","X","X","F","v","v, v","set on equal"]},{"entry":["SFL","X","X","X","X","X","F","v","v, v","set on false"]},{"entry":["SGE","X","X","X","X","X","F","v","v, v","set on greater "]},{"entry":[{},{},{},{},{},{},{},{},{},"than or equal"]},{"entry":["SGT","X","X","X","X","X","F","v","v, v","set on greater than"]},{"entry":["SHL","\u2014","X","X","\u2014","\u2014","S","v","v, s","shift left"]},{"entry":["SHR","\u2014","X","X","\u2014","\u2014","S","v","v, s","shift right"]},{"entry":["SIN","X","\u2014","X","X","X","F","s","s","sine with "]},{"entry":[{},{},{},{},{},{},{},{},{},"reduction"]},{"entry":[{},{},{},{},{},{},{},{},{},"to [\u2212PI,PI]"]},{"entry":["SLE","X","X","X","X","X","F","v","v, v","set on less "]},{"entry":[{},{},{},{},{},{},{},{},{},"than or equal"]},{"entry":["SLT","X","X","X","X","X","F","v","v, v","set on less than"]},{"entry":["SNE","X","X","X","X","X","F","v","v, v","set on not equal"]},{"entry":["SSG","X","\u2014","X","X","X","F","v","v","set sign"]},{"entry":["STR","X","X","X","X","X","F","v","v, v","set on true"]},{"entry":["SUB","X","X","X","X","X","F","v","v, v","subtract"]},{"entry":["SWZ","X","\u2014","X","X","X","F","v","v","extended swizzle"]},{"entry":["TEX","X","X","X","X","\u2014","F","v","vf","texture sample"]},{"entry":["TRUNC","X","X","X","X","X","F","v","vf","truncate (round "]},{"entry":[{},{},{},{},{},{},{},{},{},"toward zero)"]},{"entry":["TXB","X","X","X","X","\u2014","F","v","vf","texture sample "]},{"entry":[{},{},{},{},{},{},{},{},{},"with bias"]},{"entry":["TXD","X","X","X","X","\u2014","F","v","vf, vf, vf ","texture sample "]},{"entry":[{},{},{},{},{},{},{},{},{},"w\/partials"]},{"entry":["TXF","X","X","X","X","\u2014","F","v","vs","texel fetch"]},{"entry":["TXL","X","X","X","X","\u2014","F","v","vf","texture sample "]},{"entry":[{},{},{},{},{},{},{},{},{},"w\/LOD"]},{"entry":["TXP","X","X","X","X","\u2014","F","v","vf","texture sample "]},{"entry":[{},{},{},{},{},{},{},{},{},"w\/projection"]},{"entry":["TXQ","\u2014","\u2014","\u2014","\u2014","\u2014","S","vs","vs","texture info query"]},{"entry":["UP2H","X","X","X","X","\u2014","F","vf","s","unpack two "]},{"entry":[{},{},{},{},{},{},{},{},{},"16-bit floats"]},{"entry":["UP2US","X","X","X","X","\u2014","F","vf","s","unpack two "]},{"entry":[{},{},{},{},{},{},{},{},{},"unsigned 16-bit ints"]},{"entry":["UP4B","X","X","X","X","\u2014","F","vf","s","unpack four "]},{"entry":[{},{},{},{},{},{},{},{},{},"signed 8-bit ints"]},{"entry":["UP4UB","X","X","X","X","\u2014","F","vf","s","unpack four "]},{"entry":[{},{},{},{},{},{},{},{},{},"unsigned 8-bit ints"]},{"entry":["X2D","X","\u2014","X","X","X","F","v","v, v, v","2D coordinate "]},{"entry":[{},{},{},{},{},{},{},{},{},"transformation"]},{"entry":["XOR","\u2014","X","X","\u2014","\u2014","S","v","v, v","exclusive or"]},{"entry":["XPD","X","\u2014","X","X","X","F","v","v, v","cross product"]},{"entry":{"@attributes":{"namest":"1","nameend":"10","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The input and output columns describe the formats of the operands and results of the instruction, where v is a 4-component vector (data type is inherited from operation), of is a 4-component vector (data type is always floating-point), vs is a 4-component vector (data type is always signed integer), vu is a 4-component vector (data type is always unsigned integer), s is a scalar (replicated if written to a vector destination; data type is inherited from operation), c is a condition code test result (e.g., \u201cEQ\u201d, \u201cGT1.x\u201d), and vc is a 4-component vector or condition code test.","There are several types of instruction modifiers available. A data type modifier specifies that an instruction should operate on signed integer, unsigned integer, or floating-point data, when multiple data types are supported. A clamping modifier applies to instructions with floating-point results, and specifies the range to which the results should be clamped. A condition code update modifier specifies that the instruction should update one of the condition code variables. Several other special modifiers are also provided.","Instruction modifiers may be specified as stand-alone modifiers or as suffixes concatenated with the opcode name. A program will fail to load if it contains an instruction that (1) specifies more than one modifier of any given type,(2) specifies a clamping modifier on an instruction, unless it produces floating-point results, or (3) specifies a modifier that is not supported by the instruction (see TABLE 10A and the instruction description).","Stand-alone instruction modifiers are specified according to the <opModifiers> grammar rule using a \u201c<modifier>\u201d syntax. Multiple modifiers, separated by periods, may be specified. The set of supported modifiers is described in TABLE 10B.",{"@attributes":{"id":"p-0171","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 10B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Modifier","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"F","Floating-point operation"]},{"entry":[{},"U","Fixed-point operation, unsigned operands"]},{"entry":[{},"S","Fixed-point operation, signed operands"]},{"entry":[{},"CC","Update condition code register zero"]},{"entry":[{},"CC0","Update condition code register zero"]},{"entry":[{},"CC1","Update condition code register one"]},{"entry":[{},"SAT","Floating-point results clamped to [0, 1]"]},{"entry":[{},"SSAT","Floating-point results clamped to [\u22121, 1]"]},{"entry":[{},"NTC","Disable type-checking on operands\/results"]},{"entry":[{},"S24","Signed multiply (24-bit operands)"]},{"entry":[{},"U24","Unsigned multiply (24-bit operands)"]},{"entry":[{},"HI","Multiplies two 32-bit integer operands, returns the"]},{"entry":[{},{},"32 MSBs of the product"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"\u201cF\u201d, \u201cU\u201d, and \u201cS\u201d modifiers are data type modifiers and specify that the instruction should operate on floating-point, unsigned integer, or unsigned integer values, respectively. For example, \u201cADD.F\u201d, \u201cADD.U\u201d, and \u201cADD.S\u201d specify component-wise addition of floating-point, signed integer, or unsigned integer vectors, respectively. These modifiers specify a data type, but do not specify a precision at which the operation is performed. Floating-point operations will be carried out with an internal precision no less than that used to represent the largest operand. Fixed-point operations will be carried out using at least as many bits as used to represent the largest operand. Operands represented with fewer bits than used to perform the instruction will be promoted to a larger data type.","Signed integer operands will be sign-extended, where the most significant bits are filled with ones if the operand is negative and zero otherwise. Unsigned integer operands will be zero-extended, where the most significant bits are always filled with zeroes. For some instructions, the data type of some operands or the result is fixed; in these cases, the data type modifier specifies the data type of the remaining values.","\u201cCC\u201d, \u201cCC0\u201d, and \u201cCC1\u201d are condition code update modifiers that specify that one of the condition code registers should be updated based on the result of the instruction. \u201cCC\u201d and \u201cCC0\u201d specify that the condition code register CC0 be updated; \u201cCC1\u201d specifies an update to CC1. If no condition code update modifier is provided, the condition code registers will not be affected. \u201cSAT\u201d and \u201cSSAT\u201d are clamping modifiers that specify that the floating-point components of the instruction result should be clamped to [0,1] or [\u22121,1], respectively, before updating the condition code and the destination variable. If no clamping suffix is specified, unclamped results will be used for condition code updates (if any) and destination variable writes. Clamping modifiers are not supported on instructions that do not produce floating-point results.","\u201cNTC\u201d (no type checking) disables data type checking on the instruction, and allows instructions to use operands or result variables whose data types are inconsistent with the expected data types of the instruction. \u201cS24\u201d, \u201cU24\u201d, and \u201cHI\u201d are special modifiers that are allowed only for the MUL instruction, and are described in detail where MUL is documented. No more than one such modifier may be provided for any instruction.","If an instruction supports data type modifiers, but none is provided, a default data type will be chosen based on the instruction, as specified in TABLE 10A and the instruction set description. If condition code update or clamping modifiers are not specified, the corresponding operation will not be performed. Additionally, each instruction name may have one or more suffixes, concatenated onto the base instruction name, that operate as instruction modifiers. For conciseness, these suffixes are not spelled out in the grammar\u2014the base opcode name is used as a placeholder for the opcode and all of its possible suffixes. Instruction suffixes are provided mainly for compatibility with prior shader program instruction sets. The set of allowable suffixes, and their equivalent stand-alone modifiers, are listed in TABLE 10C.",{"@attributes":{"id":"p-0177","num":"0176"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10C"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Suffix ","Modifier","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["R","F","Floating-point operation, 32-bit precision"]},{"entry":["H","F(*)","Floating-point operation, at least 16-bit precision"]},{"entry":["C","CC0","Update condition code register zero"]},{"entry":["C0","CC0","Update condition code register zero"]},{"entry":["C1","CC1","Update condition code register one"]},{"entry":["_SAT ","SAT","Floating-point results clamped to [0, 1]"]},{"entry":["_SSAT","SSAT","Floating-point results clamped to [\u22121, 1]"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The \u201cR\u201d and \u201cH\u201d suffixes specify floating-point operations and are equivalent to the \u201cF\u201d data type modifier. They additionally specify a minimum precision for the operations. Instructions with an \u201cR\u201d precision modifier will be carried out at no less than IEEE single-precision floating-point (8 bits of exponent, 23 bits of mantissa). Instructions with an \u201cH\u201d precision modifier will be carried out at no less than 16-bit floating-point precision (5 bits of exponent, 10 bits of mantissa).","An instruction may have multiple suffixes, but they must appear in order, with data type suffixes first, followed by condition code update suffixes, followed by clamping suffixes. For example, \u201cADDR\u201d carries out an add at 32-bit precision. \u201cADDH_SAT\u201d carries out an add at 16-bit precision (or better) and clamps the results to [0,1]. \u201cADDRC1_SSAT\u201d carries out an add at 32-bit floating-point precision, clamps the results to [\u22121,1], and updates condition code one based on the clamped result.","Most program instructions operate on one or more scalar or vector operands. Each operand specifies an operand variable, which is either the name of a previously declared variable or an implicit variable declaration created by using a variable binding in the instruction. Attribute, parameter, or parameter buffer variables can be declared implicitly by using a valid binding name in an operand. Instruction operands are specified by the <instOperandV>, <instOperandS>, or <instOperandVNS> grammar rules.","If the operand variable is not an array, its contents are loaded directly. If the operand variable is an array, a single element of the array is loaded according to the <arrayMem> grammar rule. The elements of an array are numbered from 0 to <n>\u22121, where <n> is the number of entries in the array. Array members can be accessed using either absolute or relative addressing.","Absolute array addressing is used when the <arrayMemAbs> grammar rule is matched; the array member to load is specified by the matching integer. Out-of-bounds array absolute accesses are not allowed. If the specified member number is greater than or equal to the size of the array, the program will fail to load.","Relative array addressing is used when the <arrayMemRel> grammar rule is matched. This grammar rule allows the program to specify a scalar integer operand and an optional constant offset, according to the <arrayMemReg> and <arrayMemOffset> grammar rules. When performing relative addressing, unified ISA  or  evaluates the specified integer scalar operand (according to the rules specified in this section) and adds the constant offset. The array member loaded is given by this sum. The constant offset is considered zero if an offset is omitted. If the sum is negative or exceeds the size of the array, the results of the access are undefined, but may not lead to program or unified ISA  or  termination. The set of constant offsets supported for relative addressing is limited to values in the range [0,<n>\u22121], where <n> is the size of the array. A program will fail to load if it specifies an offset outside that range. If offsets outside that range are required, they can be applied by using an integer ADD instruction writing to a temporary variable.","After the operand is loaded, its components can be rearranged according to the <swizzleSuffix> grammar rule, or it can be converted to a scalar operand according to the <scalarSuffix> grammar rule. The <swizzleSuffix> grammar rule rearranges the components of a loaded vector to produce another vector. If the <swizzleSuffix> rule matches the <xyzwSwizzle> or <rgbaSwizzle> grammar rule, a pattern of the form \u201c.????\u201d is used, where each question mark is replaced with one of \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, \u201cw\u201d, \u201cr\u201d, \u201cg\u201d, \u201cb\u201d, or a\u2033. For such patterns, the x, y, z, and w components of the operand are taken from the vector components named by the first, second, third, and fourth character of the pattern, respectively. Swizzle components of \u201cr\u201d, \u201cg\u201d, \u201cb\u201d, and \u201ca\u201d are equivalent to \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d, respectively. For example, if the swizzle suffix is \u201c.yzzx\u201d or \u201c.gbbr\u201d and the specified source contains {2,8,9,0}, the result is the vector {8,9,9,2}. If the <swizzleSuffix> matches the <component> grammar rule, a pattern of the form \u201c.?\u201d is used. For this pattern, all four components of the operand are taken from the single component identified by the pattern. If the swizzle suffix is omitted, components are not rearranged and swizzling has no effect, as though \u201c.xyzw\u201d were specified. The swizzle suffix rules do not allow mixing \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, or \u201cw\u201d selectors with \u201cr\u201d, \u201cg\u201d, \u201cb\u201d, or \u201ca\u201d selectors. A program will fail to load if it contains a swizzle suffix with selectors from both of these sets.","The <scalarSuffix> grammar rule converts a vector to a scalar by selecting a single component. The <scalarSuffix> rule is similar to the swizzle selector, except that only a single component is selected. If the scalar suffix is \u201c.y\u201d and the specified source contains {2,8,9,0}, the value is the scalar value 8. Next, a component-wise negate operation is performed on the operand if the <operandNeg> grammar rule matches \u201c\u2212\u201d. Negation is not performed if the operand has no sign prefix, or is prefixed with \u201c+\u201d.","Next, a component-wise absolute value operation is performed on the operand if the <instOperandAbsV> or <instOperandAbsS> grammar rule is matched, by surrounding the operand with two \u201c|\u201d characters. The result is optionally negated if the <operandAbsNeg> grammar rule matches \u201c\u2212\u201d. For unsigned integer operands, the absolute value operation has no effect.","Most program instructions perform computations that produce a result, which will be written to a variable. Each instruction that computes a result specifies a destination variable, which is either the name of a previously declared variable or an implicit variable declaration created by using a variable binding in the instruction. Result variables can be declared implicitly by using a valid program result binding name in the result portion of the instruction. Instruction results are specified according to the <instResult> grammar rule.","The destination variable may be a single member of an array. In this case, a single array member is specified using the <arrayMem> grammar rule, and the array member to update is computed in the exact same manner as done for operand loads. If the array member is computed at run time, and is negative or greater than or equal to the size of the array, the results of the destination variable update are undefined and could result in overwriting other program variables.","The results of the operation may be obtained at a different precision than that used to store the destination variable. If so, the results are converted to match the size of the destination variable. For floating-point values, the results are rounded to the nearest floating-point value that can be represented in the destination variable. If a result component is larger in magnitude than the largest representable floating-point value in the data type of the destination variable, an infinity encoding (+\/\u2212INF) is used. Signed or unsigned integer values are sign-extended or zero-extended, respectively, if the destination variable has more bits than the result, and have their most significant bits discarded if the destination variable has fewer bits.","Writes to individual components of a vector destination variable can be controlled at compile time by individual component write masks specified in the instruction. The component write mask is specified by the <optWriteMask> grammar rule, and is a string of up to four characters, naming the components to enable for writing. If no write mask is specified, all components are enabled for writing. The characters \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d match the x, y, z, and w components respectively. For example, a write mask of \u201c.xzw\u201d indicates that the x, z, and w components should be enabled for writing but the y component should not be written. The grammar requires that the destination register mask components must be listed in \u201cxyzw\u201d order. Additionally, write mask components of \u201cr\u201d, \u201cg\u201d, \u201cb\u201d, and \u201ca\u201d are equivalent to \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d, respectively. The grammar does not allow mixing \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, or\u201cw\u201d components with \u201cr\u201d, \u201cg\u201d, \u201cb\u201d, and \u201ca\u201d ones.","Writes to individual components of a vector destination variable, or to a scalar destination variable, can also be controlled at run time using condition code write masks. The condition code write mask is specified by the <ccMask> grammar rule. If a mask is specified, a condition code variable is loaded according to the <ccMaskRule> grammar rule and tested as described in TABLE 10D to produce a four-component vector of TRUE\/FALSE values.",{"@attributes":{"id":"p-0192","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10D"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["mask rule","test name","condition"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["EQ, EQ0, EQ1","equal","!SF && ZF"]},{"entry":["GE, GE0, GE1","greater than or equal","!(SF {circumflex over (\u2009)} OF)"]},{"entry":["GT, GT0, GT1","greater than","(!SF {circumflex over (\u2009)} OF) && !ZF"]},{"entry":["LE, LE0, LE1","less than or equal","SF {circumflex over (\u2009)} (ZF \u2225 OF)"]},{"entry":["LT, LT0, LT1","less than","(SF && !ZF) {circumflex over (\u2009)} OF"]},{"entry":["NE, NE0, NE1","not equal","SF \u2225 !ZF"]},{"entry":["FL, FL0, FL1","false","always false"]},{"entry":["TR, TR0, TR1","true","always true"]},{"entry":["NAN, NAN0, NAN1","not a number","SF && ZF"]},{"entry":["LEG, LEG0, LEG1","less, equal, or greater","!SF \u2225 !ZF"]},{"entry":[{},{},"(anything but a NaN)"]},{"entry":["CF, CF0, CF1","carry flag","CF"]},{"entry":["NCF, NCF0, NCF1","no carry flag","!CF"]},{"entry":["OF, OF0, OF1","overflow flag","OF"]},{"entry":["NOF, NOF0, NOF1","no overflow flag","!OF"]},{"entry":["SF, SF0, SF1","sign flag","SF"]},{"entry":["NSF, NSF0, NSF1","no sign flag","!SF"]},{"entry":["AB, AB0, AB1","above","CF && !ZF"]},{"entry":["BLE, BLE0, BLE1","below or equal","!CF \u2225 ZF"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The allowed rules are specified in the \u201cmask rule\u201d column. If \u201c0\u201d or \u201c1\u201d is appended to the rule name (e.g., \u201cEQ1\u201d), the corresponding condition code register (CC1 in this example) is loaded, otherwise CC0 is loaded. After loading, each component is tested, using the expression listed in the \u201ccondition\u201d column. After the condition code tests are performed, the four-component result can be swizzled according to the <swizzleSuffix> grammar rule. Individual components of the destination variable are written only if the corresponding component of the swizzled condition code test result is TRUE. If both a (compile-time) component write mask and a condition code write mask are specified, destination variable components are written only if the corresponding component is enabled in both masks.","A program instruction can also optionally update one of the two condition code registers if the \u201cCC\u201d, \u201cCC0\u201d, or \u201cCC1\u201d instruction modifier is specified. These instruction modifiers update condition code register CC0, CC0, or CC1, respectively. The instructions \u201cADD.CC\u201d or \u201cADD.CC0\u201d will perform an add and update condition code zero, \u201cADD.CC1\u201d will add and update condition code one, and \u201cADD\u201d will simply perform the add without a condition code update. The components of the selected condition code register are updated if and only if the corresponding component of the destination variable is enabled by both write masks. For the purposes of condition code update, a scalar destination variable is treated as a vector where the scalar result is written to \u201cx\u201d (if enabled in the write mask), and writes to the \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d components are disabled.","When condition code components are written, the condition code flags are updated based on the corresponding component of the result. If a component of the destination register is not enabled for writes, the corresponding condition code component is also unchanged. For floating-point results, the sign flag (SF) is set if the result is less than zero or is a NaN (not a number) value. The zero flag (ZF) is set if the result is equal to zero or is a NaN. For signed and unsigned integer results, the sign flag (SF) is set if the most significant bit of the value written to the result variable is set and the zero flag (ZF) is set if the result written is zero.","For instructions other than those performing an integer add or subtract (ADD, MAD, SAD, SUB), the overflow and carry flags (OF and CF) are cleared. For integer add or subtract operations, the overflow and carry flags by doing both signed and unsigned adds\/subtracts as follows: (1) the overflow flag (OF) is set by interpreting the two operands as signed integers and performing a signed add or subtract. If the result is representable as a signed integer (i.e., doesn't overflow), the overflow flag is cleared; otherwise, it is set. (2) The carry flag (CF) is set by interpreting the two operands as unsigned integers and performing an unsigned add or subtract. If the result of an addition is representable as an unsigned integer (i.e., doesn't overflow), the carry flag is cleared; otherwise, it is set. If the result of a subtraction is greater than or equal to zero, the carry flag is set; otherwise, it is cleared.","For the purposes of condition code setting, negation modifiers turn add operations into subtracts and vice versa. If the operation is equivalent to an addition with both operands negated (\u2212A\u2212B), the carry and overflow flags are both undefined. Certain program instructions may access texture images. The coordinates, level-of-detail, and partial derivatives used for performing the texture lookup are derived from values provided in the program and may use the function shown in TABLE 10E which obtains a filtered texel value <tau> and returns a 4-component vector (R,G,B,A).",{"@attributes":{"id":"p-0198","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 10E"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"result_t_vec"},{"entry":"TextureSample(float_vec coord, float lod, float_vec ddx,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003float_vec ddy, int_vec offset);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The result vector is interpreted as floating-point, signed integer, or unsigned integer, according to the data type modifier of the instruction. If the internal format of the texture does not match the instruction's data type modifier, the results of the texture lookup are undefined. Note that for unextended OpenGL 2.0, all supported texture internal formats store integer values but return floating-point results in the range [0,1] on a texture lookup. An ARB_texture_float extension introduces floating-point internal format where components are both stored and returned as floating-point values. An EXT_texture_integer extension introduces formats that both store and return either signed or unsigned integer values.","<coord> is a four-component floating-point vector from which the (s,t,r) texture coordinates used for the texture access, the layer used for array textures, and the reference value used for depth comparisons are extracted according to TABLE 10F. If the texture is a cube map, (s,t,r) is projected to one of the six cube faces to produce a new (s,t) vector. For array textures, the layer used is derived by rounding the extracted floating-point component to the nearest integer and clamping the result to the range [0,<n>\u22121], where <n> is the number of layers in the texture.","<lod> specifies the level of detail parameter. <ddx> and <ddy> specify partial derivatives (ds\/dx, dt\/dx, dr\/dx, ds\/dy, dt\/dy, and dr\/dy) for the texture coordinates, and may be used to derive footprint shapes for anisotropic texture filtering. <offset> is a constant 3-component signed integer vector specified according to the <texelOffset> grammar rule, which is added to the computed <u>, <v>, and <w> texel locations prior to sampling. One, two, or three components may be specified in the instruction; if fewer than three are specified, the remaining offset components are zero. A limited range of offset values are supported; the minimum and maximum <texelOffset> values are implementation-dependent and given by MIN_PROGRAM_TEXEL_OFFSET_NV and MAX_PROGRAM_TEXEL_OFFSET_NV, respectively.","A program will fail to load in the following circumstances (1) if the texture target specified in the instruction is 1D, ARRAY1D, SHADOW1D, or SHADOWARRAY1D, and the second or third component of the offset vector is non-zero, (2) if the texture target specified in the instruction is 2D, RECT, ARRAY2D, SHADOW2D, SHADOWRECT, or SHADOWARRAY2D, and the third component of the offset vector is non-zero, (3) if the texture target is CUBE or SHADOWCUBE, and any component of the offset vector is non-zero\u2014texel offsets are not supported for cube map or buffer textures, or if any component of the offset vector is less than MIN_PROGRAM_TEXEL_OFFSET_NV or greater than MAX_PROGRAM_TEXEL_OFFSET_NV. Texel offsets are a new feature provided by unified ISA  and .","The texture used by TextureSample( ) is one of the textures bound to the texture image unit whose number is specified in the instruction according to the <texImageUnit> grammar rule. The texture target accessed is specified according to the <texTarget> grammar rule and TABLE 10F. Fixed-function texture enables are always ignored when determining the texture to access in a program.",{"@attributes":{"id":"p-0204","num":"0203"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":{"entry":"TABLE 10F"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},{},"coordinates used"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["texTarget","Texture Type","s ","t","r","layer ","shadow"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":["1D","TEXTURE_1D","x","\u2014","\u2014","\u2014","\u2014"]},{"entry":["2D","TEXTURE_2D","x","y","\u2014","\u2014","\u2014"]},{"entry":["3D","TEXTURE_3D","x","y","z","\u2014","\u2014"]},{"entry":["CUBE","TEXTURE_","x","y","z","\u2014","\u2014"]},{"entry":[{},"CUBE_MAP",{},{},{},{},{}]},{"entry":["RECT","TEXTURE_","x","y","\u2014","\u2014","\u2014"]},{"entry":[{},"RECTANGLE_ARB",{},{},{},{},{}]},{"entry":["ARRAY1D","TEXTURE_1D_","x","\u2014","\u2014","y","\u2014"]},{"entry":[{},"ARRAY_EXT",{},{},{},{},{}]},{"entry":["ARRAY2D","TEXTURE_2D_","x","y","\u2014","z","\u2014"]},{"entry":[{},"ARRAY_EXT",{},{},{},{},{}]},{"entry":["SHADOW1D","TEXTURE_1D","x","\u2014","\u2014","\u2014","z"]},{"entry":["SHADOW2D","TEXTURE_2D","x","y","\u2014","\u2014","z"]},{"entry":["SHADOWRECT ","TEXTURE_","x","y","\u2014","\u2014","z"]},{"entry":[{},"RECTANGLE_ARB",{},{},{},{},{}]},{"entry":["SHADOWCUBE ","TEXTURE_","x","y","z","\u2014","w"]},{"entry":[{},"CUBE_MAP",{},{},{},{},{}]},{"entry":["SHADOWARRAY1D ","TEXTURE_1D_","x","\u2014","\u2014","y","z"]},{"entry":[{},"ARRAY_EXT",{},{},{},{},{}]},{"entry":["SHADOWARRAY2D ","TEXTURE_2D_","x","y","\u2014","z","w"]},{"entry":[{},"ARRAY_EXT",{},{},{},{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BUFFER","TEXTURE_","<not supported>"]},{"entry":[{},"BUFFER_EXT"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Texture types accessed for each of the <texTarget>, and coordinate mappings. The \u201cSHADOW\u201d and \u201cARRAY\u201d targets are special pseudo-targets described below. The \u201ccoordinates used\u201d column indicate the input values used for each coordinate of the texture lookup, the layer selector for array textures, and the reference value for texture comparisons. Buffer textures are not supported by normal texture lookup functions, but are supported by TXF and TXQ, described below.","Texture targets with \u201cSHADOW\u201d are used to access textures with a DEPTH_COMPONENT base internal format using depth comparisons. Results of a texture access are undefined under the following circumstances (1) if a \u201cSHADOW\u201d target is used, and the corresponding texture has a base internal format other than DEPTH_COMPONENT or a TEXTURE_COMPARE_MODE of NONE, or (2) if a non-\u201cSHADOW\u201d target is used, and the corresponding texture has a base internal format of DEPTH_COMPONENT and a TEXTURE_COMPARE_MODE other than NONE. If the texture being accessed is not complete (or cube complete for cubemap textures) no texture access is performed and the result is undefined.","A program will fail to load if it attempts to sample from multiple texture targets (including the SHADOW pseudo-targets) on the same texture image unit. For example, a program containing any two the following instructions will fail to load: TEX out, coord, texture[0], 1D; TEX out, coord, texture[0], 2D; TEX out, coord, texture[0], ARRAY2D; TEX out, coord, texture[0], SHADOW2D; and TEX out, coord, texture[0], 3D.","Additionally, multiple texture targets for a single texture image unit may not be used at the same time by the shader program. The error INVALID_OPERATION is generated by Begin, RasterPos, or any command that performs an implicit Begin if an enabled program accesses one texture target for a texture unit while another enabled program or fixed-function fragment processing accesses a different texture target for the same texture image unit.","Some texture instructions use standard methods to compute partial derivatives and\/or the level-of-detail used to perform texture accesses. For fragment programs, the functions float_vec ComputePartialsX(float_vec coord); and float_vec ComputePartialsY(float_vec coord); compute approximate component-wise partial derivatives of the floating-point vector <coord> relative to the X and Y coordinates, respectively. For vertex and geometry programs, these functions always return (0,0,0,0). The function float ComputeLOD(float_vec ddx, float_vec ddy); maps partial derivative vectors <ddx> and <ddy> to ds\/dx, dt\/dx, dr\/dx, ds\/dy, dt\/dy, and dr\/dy and computes lambda_base(x,y).","The TXF instruction provides the ability to extract a single texel from a specified texture image using the function result_t_vec TexelFetch(uint_vec coord, int_vec offset). The extracted texel is converted to an (R,G,B,A) vector and the result vector is interpreted as floating-point, signed integer, or unsigned integer, according to the data type modifier of the instruction. If the internal format of the texture is not compatible with the instruction's data type modifier, the extracted texel value is undefined.","<coord> is a four-component signed integer vector used to identify the single texel accessed. The (i,j,k) coordinates of the texel and the layer used for array textures are extracted according to TABLE 10G. The level of detail accessed is obtained by adding the w component of <coord> to the base level (level_base). <offset> is a constant 3-component signed integer vector added to the texel coordinates prior to the texel fetch as described above. In addition to the restrictions described above, non-zero offset components are also not supported for BUFFER targets.","The texture used by TexelFetch( ) is specified by the image unit and target parameters provided in the instruction, as for TextureSample( ) above. Single texel fetches can not perform depth comparisons or access cubemaps. If a program contains a TXF instruction specifying one of the \u201cSHADOW\u201d or \u201cCUBE\u201d targets, it will fail to load. TABLE 10G lists mappings of texel fetch coordinates to texel locations.",{"@attributes":{"id":"p-0213","num":"0212"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"center"}}],"thead":{"row":{"entry":"TABLE 10G"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},{},"coordinates used"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["texTarget","supported","i ","j","k","layer","lod"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":["1D","yes","x","\u2014","\u2014","\u2014","w"]},{"entry":["2D","yes","x","y","\u2014","\u2014","w"]},{"entry":["3D","yes","x","y","z","\u2014","w"]},{"entry":["CUBE","no","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["RECT","yes","x","y","\u2014","\u2014","w"]},{"entry":["ARRAY1D","yes","x","\u2014","\u2014","y","w"]},{"entry":["ARRAY2D","yes","x","y","\u2014","z","w"]},{"entry":["SHADOW1D","no","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["SHADOW2D","no","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["SHADOWRECT","no","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["SHADOWCUBE","no","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["SHADOWARRAY1D","no","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["SHADOWARRAY2D","no","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["BUFFER","yes","x","\u2014","\u2014","\u2014","\u2014"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},"Single-texel fetches do not support LOD clamping or any texture wrap mode, and require a mipmapped minification filter to access any level of detail other than the base level. The results of the texel fetch are undefined (1) if the computed LOD is less than the texture's base level (level_base) or greater than the maximum level (level_max), (2) if the computed LOD is not the texture's base level and the texture's minification filter is NEAREST or LINEAR, (3) if the layer specified for array textures is negative or greater than the number of layers in the array texture, (4) if the texel at (i,j,k) coordinates refer to a border texel outside the defined extents of the specified LOD, where i<\u2212b_s, j<\u2212b_s, k<\u2212b_s, i>=w_s\u2212b_s, j>=h_s\u2212b_s, or k>=d_s\u2212b_s, where the size parameters (w_s, h_s, d_s, and b_s) refer to the width, height, depth, and border size of the image, or (5) if the texture being accessed is not complete (or cube complete for cubemaps).","In addition to basic arithmetic, logical, and texture instructions, a number of flow control instructions are provided, which are described in detail in further herein. Programs can contain several types of instruction blocks: IF\/ELSE\/ENDIF blocks, REP\/ENDREP blocks, and subroutine blocks. IF\/ELSE\/ENDIF blocks are a set of instructions beginning with an \u201cIF\u201d instruction, ending with an \u201cENDIF\u201d instruction, and possibly containing an optional \u201cELSE\u201d instruction. REP\/ENDREP blocks are a set of instructions beginning with a \u201cREP\u201d instruction and ending with an \u201cENDREP\u201d instruction. Subroutine blocks begin with an instruction label identifying the name of the subroutine and ending just before the next instruction label or the end of the program. Examples are shown in TABLE 10H.",{"@attributes":{"id":"p-0216","num":"0215"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 10H"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","MOVC CC, R0;","\u2003"]},{"entry":[{},{},"IF GT.x;",{}]},{"entry":[{},{},"\u2003MOV R0, R1; # executes if R0.x > 0",{}]},{"entry":[{},{},"ELSE;",{}]},{"entry":[{},{},"\u2003MOV R0, R2; # executes if R0.x <= 0",{}]},{"entry":[{},{},"ENDIF;",{}]},{"entry":[{},{},"REP repCount;",{}]},{"entry":[{},{},"ADD R0, R0, R1;",{}]},{"entry":[{},{},"ENDREP;",{}]},{"entry":[{},{},"\u2003square: # subroutine to compute R0{circumflex over (\u2009)}2",{}]},{"entry":[{},{},"MUL R0, R0, R0;",{}]},{"entry":[{},{},"RET;",{}]},{"entry":[{},{},"main:",{}]},{"entry":[{},{},"MOV R0, 9.0;",{}]},{"entry":[{},{},"CAL square; # compute 9.0{circumflex over (\u2009)}2 in R0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"IF\/ELSE\/ENDIF and REP\/ENDREP blocks may be nested inside each other, and inside subroutines. In all cases, each instruction block must be terminated with the appropriate instruction (ENDIF for IF, ENDREP for REP). Nested instruction blocks must be wholly contained within a block\u2014if a REP instruction is found between an IF and ELSE instruction, the corresponding ENDREP must also be present between the IF and ELSE.","Subroutines may not be nested inside IF\/ELSE\/ENDIF or REP\/ENDREP blocks, or inside other subroutines. A program will fail to load if any instruction block is terminated by an incorrect instruction, is not terminated before the block containing it, or contains an instruction label.","IF\/ELSE\/ENDIF blocks evaluate a condition to determine which instructions to execute. If the condition is true, all instructions between the IF and ELSE are executed. If the condition is false, all instructions between the ELSE and ENDIF are executed. The ELSE instruction is optional. If the ELSE is omitted, all instructions between the IF and ENDIF are executed if the condition is true, or skipped if the condition is false. A limited amount of nesting is supported\u2014a program will fail to load if an IF instruction is nested inside MAX_PROGRAM_IF_DEPTH_NV or more","IF\/ELSE\/ENDIF blocks.","REP\/ENDREP blocks are used to execute a sequence of instructions multiple times. The REP instruction includes an optional scalar operand to specify a loop count indicating the number of times the sequence of instructions should be repeated. If the loop count is omitted, the contents of a REP\/ENDREP block will be repeated indefinitely until the loop is explicitly terminated. A limited amount of nesting is supported\u2014a program will fail to load if a REP instruction is nested inside MAX_PROGRAM_LOOP_DEPTH_NV or more REP\/ENDREP blocks.","Within a REP\/ENDREP block, the CONT instruction can be used to terminate the current iteration of the loop by effectively jumping to the ENDREP instruction. The BRK instruction can be used to terminate the entire loop by effectively jumping to the instruction immediately following the ENDREP instruction. If CONT and BRK instructions are found inside multiply nested REP\/ENDREP blocks, they apply to the innermost block. A program will fail to load if it includes a CONT or BRK instruction that is not contained inside a REP\/ENDREP block.","A REP\/ENDREP block without a specified loop count can result in an infinite loop. To prevent obvious infinite loops, a program will fail to load if it contains a REP\/ENDREP block that contains neither a BRK instruction at the current nesting level or a RET instruction at any nesting level.","Subroutines are supported via the CAL and RET instructions. A subroutine block is identified by an instruction, which can be any valid identifier according to the <instLabel> grammar rule. The CAL instruction identifies a subroutine name to call according to the <instTarget> grammar rule. Instruction labels used in CAL instructions do not need to be defined in the program text that precedes the instruction, but a program will fail to load if it includes a CAL instruction that references an instruction label that is not defined anywhere in the program. When a CAL instruction is executed, it transfers control to the instruction immediately following the specified instruction label. Subsequent instructions in that subroutine are executed until a RET instruction is executed, or until program execution reaches another instruction label or the end of the program text. After the subroutine finishes, execution continues with the instruction immediately following the CAL instruction. When a RET instruction is issued, it will break out of any IF\/ELSE\/ENDIF or REP\/ENDREP blocks that contain it.","Subroutines may call other subroutines before completing, up to an implementation-dependent maximum depth of MAX_PROGRAM_CALL_DEPTH_NV calls. Subroutines may call any subroutine in the program, including themselves, as long as the call depth limit is obeyed. The results of issuing a CAL instruction while MAX_PROGRAM_CALL_DEPTH subroutines have not completed has undefined results, including possible program termination.","Several flow control instructions include condition code tests. The IF instruction requires a condition test to determine what instructions are executed. The CONT, BRK, CAL, and RET instructions have an optional condition code test; if the test fails, the instructions are not executed. Condition code tests are specified by the <ccTest> grammar rule. The test is evaluated like the condition code write mask, and passes if and only if any of the four components passes.","If an instruction label named \u201cmain\u201d is specified, GPU program execution begins with the instruction immediately following that label. Otherwise, it begins with the first instruction of the program. Instructions are executed in sequence until either a RET instruction is issued in the main subroutine or the end of the program text is reached.","Programs may specify a number of options to indicate that one or more extended language features are used by the program. All program options used by the program must be declared at the beginning of the program string. Each program option specified in a program string will modify the syntactic or semantic rules used to interpret the program and the execution environment used to execute the program. Features in program options not declared by the program are ignored, even if the option is otherwise supported by the unified ISA  and . Each option declaration consists of two tokens: the keyword \u201cOPTION\u201d and an identifier. The set of available options depends on the program type, and is enumerated in the specifications for each program type. Some program types may not provide any options.","Programs may include a number of declaration statements to specify characteristics of the program. Each declaration statement is followed by one or more arguments, separated by commas. The set of available declarations depends on the program type, and is enumerated in the specifications for each program type. Some program types may not provide declarations.","The following TABLES enumerate the set of instructions supported for shader programs. Some instructions allow the use of one of the three basic data type modifiers (floating point, signed integer, and unsigned integer). Unless otherwise mentioned: the result and all of the operands will be interpreted according to the specified data type, and if no data type modifier is specified, the instruction will operate as though a floating-point modifier (\u201cF\u201d) were specified. Some instructions will override one or both of these rules.","TABLE 11A describes the ABS (Absolute value) assembly instruction that is included in unified ISA  and . The ABS instruction performs a component-wise absolute value operation on the single operand to yield a result vector.",{"@attributes":{"id":"p-0232","num":"0231"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp = VectorLoad(op0);","\u2003"]},{"entry":[{},{},"result.x = abs(tmp.x);",{}]},{"entry":[{},{},"result.y = abs(tmp.y);",{}]},{"entry":[{},{},"result.z = abs(tmp.z);",{}]},{"entry":[{},{},"result.w = abs(tmp.w);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11B describes the ADD (Addition) assembly instruction that is included in unified ISA  and . The ADD instruction performs a component-wise add of the two operands to yield a result vector. ADD supports all three data type modifiers.",{"@attributes":{"id":"p-0234","num":"0233"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp0 = VectorLoad(op0);","\u2003"]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.x + tmp1.x;",{}]},{"entry":[{},{},"result.y = tmp0.y + tmp1.y;",{}]},{"entry":[{},{},"result.z = tmp0.z + tmp1.z;",{}]},{"entry":[{},{},"result.w = tmp0.w + tmp1.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"TABLE 11C describes the AND assembly instruction that is included in unified ISA  and . The AND instruction performs a bitwise AND operation on the components of the two source vectors to yield a result vector.",{"@attributes":{"id":"p-0236","num":"0235"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp0 = VectorLoad(op0);","\u2003"]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.x & tmp1.x;",{}]},{"entry":[{},{},"result.y = tmp0.y & tmp1.y;",{}]},{"entry":[{},{},"result.z = tmp0.z & tmp1.z;",{}]},{"entry":[{},{},"result.w = tmp0.w & tmp1.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11E lists pseudocode describing the operation of the BRK (Break out of loop) assembly instruction that is included in unified ISA  and . The BRK instruction conditionally transfers control to the instruction immediately following the next ENDREP instruction. A BRK instruction has no effect if the condition code test evaluates to FALSE.",{"@attributes":{"id":"p-0238","num":"0237"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11E"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (TestCC(cc.c***) \u2225 TestCC(cc.*c**) \u2225"},{"entry":"\u2003TestCC(cc.**c*) \u2225 TestCC(cc.***c)) {"},{"entry":"continue execution at instruction following the next ENDREP;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"TABLE 11F lists pseudocode describing the operation of the CAL (Subroutine Call) assembly instruction that is included in unified ISA  and . The CAL instruction conditionally transfers control to the instruction following the label specified in the instruction. It also pushes a reference to the instruction immediately following the CAL instruction onto the call stack, where execution will continue after executing the matching RET instruction.",{"@attributes":{"id":"p-0240","num":"0239"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11F"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (TestCC(cc.c***) \u2225 TestCC(cc.*c**) \u2225"},{"entry":"\u2003TestCC(cc.**c*) \u2225 TestCC(cc.***c)) {"},{"entry":"if (callStackDepth >= MAX_PROGRAM_CALL_DEPTH_NV) {"},{"entry":"\u2003\/\/ undefined results"},{"entry":"} else {"},{"entry":"\u2003callStack[callStackDepth] = nextInstruction;"},{"entry":"\u2003callStackDepth++;"},{"entry":"}"},{"entry":"\/\/ continue execution at instruction following <instTarget>"},{"entry":"} else {"},{"entry":"\/\/ do nothing"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the pseudocode shown in TABLE 11F, <instTarget> is the label specified in the instruction matching the <branchLabel> grammar rule, <callStackDepth> is the current depth of the call stack, <callStack> is an array holding the call stack, and <nextInstruction> is a reference to the instruction immediately following the CAL instruction in the program string. If the call stack overflows, the results of the CAL instruction are undefined, and can result in immediate program termination.","An instruction label signifies the beginning of a new subroutine. Subroutines may not nest or overlap. If a CAL instruction is executed and subsequent program execution reaches an instruction label before a corresponding RET instruction is executed, the subroutine call returns immediately, as though an unconditional RET instruction were inserted immediately before the instruction label.","TABLE 11G describes the CEIL (Ceiling) assembly instruction that is included in unified ISA  and . The CEIL instruction loads a single vector operand and performs a component-wise ceiling operation to generate a result vector.",{"@attributes":{"id":"p-0244","num":"0243"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11G"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp = VectorLoad(op0);","\u2003"]},{"entry":[{},{},"iresult.x = ceil(tmp.x);",{}]},{"entry":[{},{},"iresult.y = ceil(tmp.y);",{}]},{"entry":[{},{},"iresult.z = ceil(tmp.z);",{}]},{"entry":[{},{},"iresult.w = ceil(tmp.w);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The ceiling operation returns the nearest integer greater than or equal to the operand. For example ceil(\u22121.7)=\u22121.0, ceil(+1.0)=+1.0, and ceil(+3.7)=+4.0. CEIL supports all three data type modifiers. The single operand is always treated as a floating-point vector, but the result is written as a floating-point value, a signed integer, or an unsigned integer, as specified by the data type modifier. If a value cannot be exactly represented using the data type of the result (e.g., an overflow or writing a negative value to an unsigned integer), the result is undefined.","TABLE 11H describes the CMP (Compare) assembly instruction that is included in unified ISA  and . The CMP instruction performs a component-wise comparison of the first operand against zero, and copies the values of the second or third operands based on the results of the compare.",{"@attributes":{"id":"p-0247","num":"0246"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11H"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp0 = VectorLoad(op0);"]},{"entry":[{},{},"tmp1 = VectorLoad(op1);"]},{"entry":[{},{},"tmp2 = VectorLoad(op2);"]},{"entry":[{},{},"result.x = (tmp0.x < 0) ? tmp1.x : tmp2.x;"]},{"entry":[{},{},"result.y = (tmp0.y < 0) ? tmp1.y : tmp2.y;"]},{"entry":[{},{},"result.z = (tmp0.z < 0) ? tmp1.z : tmp2.z;"]},{"entry":[{},{},"result.w = (tmp0.w < 0) ? tmp1.w : tmp2.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11I lists pseudo-code describing the operation of the CONT (Continue with Next Loop Iteration) assembly instruction that is included in unified ISA  and . The CONT instruction conditionally transfers control to the next ENDREP instruction. A CONT instruction has no effect if the condition code test evaluates to FALSE.",{"@attributes":{"id":"p-0249","num":"0248"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11I"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","if (TestCC(cc.c***) \u2225 TestCC(cc.*c**) \u2225","\u2003"]},{"entry":[{},{},"\u2003TestCC(cc.**c*) \u2225 TestCC(cc.***c)) {",{}]},{"entry":[{},{},"continue execution at the next ENDREP;",{}]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"TABLE 11J describes the COS (Cosine with Reduction to [\u2212PI,PI]) assembly instruction that is included in unified ISA  and . The COS instruction approximates the trigonometric cosine of the angle specified by the scalar operand and replicates it to all four components of the result vector. The angle is specified in radians and does not have to be in the range [\u2212PI,PI].",{"@attributes":{"id":"p-0251","num":"0250"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11J"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp = ScalarLoad(op0);","\u2003"]},{"entry":[{},{},"result.x = ApproxCosine(tmp);",{}]},{"entry":[{},{},"result.y = ApproxCosine(tmp);",{}]},{"entry":[{},{},"result.z = ApproxCosine(tmp);",{}]},{"entry":[{},{},"result.w = ApproxCosine(tmp);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The DDX (Partial Derivative Relative to X) assembly instruction is included in unified ISA  and . The DDX instruction computes approximate partial derivatives of a vector operand with respect to the X window coordinate, and is only available to fragment programs. The DDY (Partial Derivative Relative to Y) assembly instruction is included in unified ISA  and . The DDY instruction computes approximate partial derivatives of a vector operand with respect to the Y window coordinate, and is only available to fragment programs.","TABLE 11K describes the DIV (Divide Vector Components by Scalar) assembly instruction that is included in unified ISA  and . The DIV instruction performs a component-wise divide of the first vector operand by the second scalar operand to produce a 4-component result vector.",{"@attributes":{"id":"p-0254","num":"0253"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11K"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp0 = VectorLoad(op0);","\u2003"]},{"entry":[{},{},"tmp1 = ScalarLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.x \/ tmp1;",{}]},{"entry":[{},{},"result.y = tmp0.y \/ tmp1;",{}]},{"entry":[{},{},"result.z = tmp0.z \/ tmp1;",{}]},{"entry":[{},{},"result.w = tmp0.w \/ tmp1;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11L describes the DP2 (2-Component Dot Product) assembly instruction that is included in unified ISA  and . The DP2 instruction computes a two-component dot product of the two operands (using the first two components) and replicates the dot product to all four components of the result vector.",{"@attributes":{"id":"p-0256","num":"0255"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11L"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp0 = VectorLoad(op0);"]},{"entry":[{},{},"tmp1 = VectorLoad(op1);"]},{"entry":[{},{},"dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y);"]},{"entry":[{},{},"result.x = dot;"]},{"entry":[{},{},"result.y = dot;"]},{"entry":[{},{},"result.z = dot;"]},{"entry":[{},{},"result.w = dot;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11M describes the DP2A (2-Component Dot Product with Scalar Add) assembly instruction that is included in unified ISA  and . The DP2 instruction computes a two-component dot product of the two operands (using the first two components), adds the x component of the third operand, and replicates the result to all four components of the result vector.",{"@attributes":{"id":"p-0258","num":"0257"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11M"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"tmp0 = VectorLoad(op0);"},{"entry":"tmp1 = VectorLoad(op1);"},{"entry":"tmp2 = VectorLoad(op2);"},{"entry":"dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) + tmp2.x;"},{"entry":"result.x = dot;"},{"entry":"result.y = dot;"},{"entry":"result.z = dot;"},{"entry":"result.w = dot;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11N describes the DP3 (3-Component Dot Product) assembly instruction that is included in unified ISA  and . The DP3 instruction computes a three-component dot product of the two operands (using the x, y, and z components) and replicates the dot product to all four components of the result vector.",{"@attributes":{"id":"p-0260","num":"0259"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11N"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"tmp0 = VectorLoad(op0);"},{"entry":"tmp1 = VectorLoad(op1);"},{"entry":"dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) + (tmp0.z * tmp1.z);"},{"entry":"result.x = dot;"},{"entry":"result.y = dot;"},{"entry":"result.z = dot;"},{"entry":"result.w = dot;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11O describes the DP4 (4-Component Dot Product) assembly instruction that is included in unified ISA  and . The DP4 instruction computes a four-component dot product of the two operands and replicates the dot product to all four components of the result vector.",{"@attributes":{"id":"p-0262","num":"0261"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11O"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"tmp0 = VectorLoad(op0);"},{"entry":"tmp1 = VectorLoad(op1):"},{"entry":"dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) +"},{"entry":"(tmp0.z * tmp1.z) + (tmp0.w * tmp1.w);"},{"entry":"result.x = dot;"},{"entry":"result.y = dot;"},{"entry":"result.z = dot;"},{"entry":"result.w = dot;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11P describes the DPH (Homogeneous Dot Product) assembly instruction that is included in unified ISA  and . The DPH instruction computes a three-component dot product of the two operands (using the x, y, and z components), adds the w component of the second operand, and replicates the sum to all four components of the result vector. This is equivalent to a four-component dot product where the w component of the first operand is forced to 1.0.",{"@attributes":{"id":"p-0264","num":"0263"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11P"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp0 = VectorLoad(op0);"]},{"entry":[{},{},"tmp1 = VectorLoad(op1):"]},{"entry":[{},{},"dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) +"]},{"entry":[{},{},"(tmp0.z * tmp1.z) + tmp1.w;"]},{"entry":[{},{},"result.x = dot;"]},{"entry":[{},{},"result.y = dot;"]},{"entry":[{},{},"result.z = dot;"]},{"entry":[{},{},"result.w = dot;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11Q lists pseudo-code that describes the exact behavior of the DST (Distance Vector) assembly instruction that is included in unified ISA  and . The DST instruction computes a distance vector from two specially-formatted operands. The first operand should be of the form [NA, d^2, d^2, NA] and the second operand should be of the form [NA, 1\/d, NA, 1\/d], where NA values are not relevant to the calculation and d is a vector length. If both vectors satisfy these conditions, the result vector will be of the form [1.0, d, d^2, 1\/d].",{"@attributes":{"id":"p-0266","num":"0265"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11Q"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","tmp0 = VectorLoad(op0);","\u2003"]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = 1.0;",{}]},{"entry":[{},{},"result.y = tmp0.y * tmp1.y;",{}]},{"entry":[{},{},"result.z = tmp0.z;",{}]},{"entry":[{},{},"result.w = tmp1.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"An ELSE (Start of If Test Else Block) assembly instruction is included in unified ISA  and . The ELSE instruction signifies the end of the \u201cexecute if true\u201d portion of an IF\/ELSE\/ENDIF block and the beginning of the \u201cexecute if false\u201d portion. If the condition evaluated at the IF statement was TRUE, when a program reaches the ELSE statement, it has completed the entire \u201cexecute if true\u201d portion of the IF\/ELSE\/ENDIF block. Execution will continue at the corresponding ENDIF instruction. If the condition evaluated at the IF statement was FALSE, program execution would skip over the entire \u201cexecute if true\u201d portion of the IF\/ELSE\/ENDIF block, including the ELSE instruction.","An EMIT (Emit Vertex) assembly instruction is included in unified ISA  and . The EMIT instruction emits a new vertex to be added to the current output primitive generated by a geometry program, and is only available to geometry programs. See the NV_geometry_program4 specification for more details.","An ENDIF (End of If Test Block) assembly instruction is included in unified ISA  and . The ENDIF instruction signifies the end of an IF\/ELSE\/ENDIF block. It has no other effect on program execution.","An ENDPRIM (End of Primitive) assembly instruction is included in unified ISA  and . A geometry program can emit multiple primitives in a single invocation. The ENDPRIM instruction is used in a geometry program to signify the end of the current primitive and the beginning of a new primitive of the same type. It is only available to geometry programs.","An ENDREP (End of Repeat Block) assembly instruction is included in unified ISA  and . The ENDREP instruction specifies the end of a REP block. When used with in conjunction with a REP instruction with a loop count, ENDREP decrements the loop counter. If the decremented loop counter is greater than zero, ENDREP transfers control to the instruction immediately after the corresponding REP instruction. If the loop counter is less than or equal to zero, execution continues at the instruction following the ENDREP instruction. When used in conjunction with a REP instruction without loop count, ENDREP always transfers control to the instruction immediately after the REP instruction. An example use of the REP instruction is shown in pseudo-code listed in TABLE 11R.",{"@attributes":{"id":"p-0272","num":"0271"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11R"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (REP instruction includes a loop count) {"},{"entry":"LoopCount--;"},{"entry":"if (LoopCount > 0) {"},{"entry":"\u2003\u2003continue execution at instruction following corresponding REP"},{"entry":"\u2003instruction;"},{"entry":"}"},{"entry":"\u2003} else {"},{"entry":"\u2003continue execution at instruction following corresponding REP"},{"entry":"\u2003\u2003instruction;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"TABLE 11S describes the EX2 (Exponential Base 2) assembly instruction that is included in unified ISA  and . The EX2 instruction approximates 2 raised to the power of the scalar operand and replicates the approximation to all four components of the result vector.",{"@attributes":{"id":"p-0274","num":"0273"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11S"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);",{}]},{"entry":[{},{},"result.x = Approx2ToX(tmp);",{}]},{"entry":[{},{},"result.y = Approx2ToX(tmp);",{}]},{"entry":[{},{},"result.z = Approx2ToX(tmp);",{}]},{"entry":[{},{},"result.w = Approx2ToX(tmp);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11T describes the FLR (Floor) assembly instruction that is included in unified ISA  and . The FLR instruction loads a single vector operand and performs a component-wise floor operation to generate a result vector.",{"@attributes":{"id":"p-0276","num":"0275"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11T"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},{},"result.x = floor(tmp.x);",{}]},{"entry":[{},{},"result.y = floor(tmp.y);",{}]},{"entry":[{},{},"result.z = floor(tmp.z);",{}]},{"entry":[{},{},"result.w = floor(tmp.w);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11U describes the FRC (Fraction) assembly instruction that is included in unified ISA  and . The FRC instruction extracts the fractional portion of each component of the operand to generate a result vector. The fractional portion of a component is defined as the result after subtracting off the floor of the component (see FLR), and is always in the range [0.0, 1.0). For negative values, the fractional portion is NOT the number written to the right of the decimal point\u2014the fractional portion of \u22121.7 is not 0.7\u2014it is 0.3. 0.3 is produced by subtracting the floor of \u22121.7 (\u22122.0) from \u22121.7.",{"@attributes":{"id":"p-0278","num":"0277"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11U"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},{},"result.x = fraction(tmp.x);",{}]},{"entry":[{},{},"result.y = fraction(tmp.y);",{}]},{"entry":[{},{},"result.z = fraction(tmp.z);",{}]},{"entry":[{},{},"result.w = fraction(tmp.w);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11V describes the 12F (Integer to Float) assembly instruction that is included in unified ISA  and . The 12F instruction converts the components of an integer vector operand to floating-point to produce a floating-point result vector.",{"@attributes":{"id":"p-0280","num":"0279"},"tables":{"@attributes":{"id":"TABLE-US-00060","num":"00060"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11V"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},{},"result.x = (float)tmp.x;",{}]},{"entry":[{},{},"result.y = (float)tmp.y;",{}]},{"entry":[{},{},"result.z = (float)tmp.z;",{}]},{"entry":[{},{},"result.w = (float)tmp.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"An IF (Start of If Test Block) assembly instruction that is included in unified ISA  and . The IF instruction performs a condition code test to determine what instructions inside an IF\/ELSE\/ENDIF block are executed. If the test passes, execution continues at the instruction immediately following the IF instruction. If the test fails, IF transfers control to the instruction immediately following the corresponding ELSE instruction (if present) or the ENDIF instruction (if no ELSE is present).","Implementations may have a limited ability to nest IF blocks in any subroutine. If the number of IF\/ENDIF blocks nested inside each other is MAX_PROGRAM_IF_DEPTH_NV or higher, a program will fail to compile. TABLE 11W lists example pseudo-code using the IF instruction.",{"@attributes":{"id":"p-0283","num":"0282"},"tables":{"@attributes":{"id":"TABLE-US-00061","num":"00061"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11W"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002\/\/ Evaluate the condition. If the condition is true, continue at the",{}]},{"entry":[{},"\u2002\/\/ next instruction. Otherwise, continue at the",{}]},{"entry":[{},"\u2002if (TestCC(cc.c***) \u2225 TestCC(cc.*c**) \u2225",{}]},{"entry":[{},"\u2003TestCC(cc.**c*) \u2225 TestCC(cc.***c)) {",{}]},{"entry":[{},"continue execution at the next instruction;",{}]},{"entry":[{},"} else if (IF block contains an ELSE statement) {",{}]},{"entry":[{},"continue execution at instruction following corresponding ELSE;",{}]},{"entry":[{},"} else {",{}]},{"entry":[{},"continue execution at instruction following corresponding ENDIF;",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Note that there is no run-time limit on the maximum overall depth of IF\/ENDIF nesting. As long as each individual subroutine of the program obeys the static nesting limits, there will be no run-time errors in the program. When conventional assembly instructions are used, a program could terminate abnormally if it called a subroutine inside a very deeply nested set of IF\/ENDIF blocks and the called subroutine also contained deeply nested IF\/ENDIF blocks. Such an error could occur even if neither subroutine exceeded static limits.","A KIL (Kill Fragment) assembly instruction that is included in unified ISA  and . The KIL instruction conditionally kills a fragment, and is only available to fragment programs.","TABLE 11X describes the LG2 (Logarithm Base 2) assembly instruction that is included in unified ISA  and . The LG2 instruction approximates the base 2 logarithm of the scalar operand and replicates it to all four components of the result vector.",{"@attributes":{"id":"p-0287","num":"0286"},"tables":{"@attributes":{"id":"TABLE-US-00062","num":"00062"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11X"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);",{}]},{"entry":[{},{},"result.x = ApproxLog2(tmp);",{}]},{"entry":[{},{},"result.y = ApproxLog2(tmp);",{}]},{"entry":[{},{},"result.z = ApproxLog2(tmp);",{}]},{"entry":[{},{},"result.w = ApproxLog2(tmp);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"If the scalar operand is zero or negative, the result is undefined. LG2 supports only floating-point data type modifiers.","The LIT (Compute Lighting Coefficients) instruction accelerates lighting computations by computing lighting coefficients for ambient, diffuse, and specular light contributions. TABLE 11Y describes the LIT assembly instruction that is included in unified ISA  and . The \u201cx\u201d component of the single operand is assumed to hold a diffuse dot product (n dot VP_pli). The \u201cy\u201d component of the operand is assumed to hold a specular dot product (n dot h_i). The \u201cw\u201d component of the operand is assumed to hold the specular exponent of the material (s_rm), and is clamped to the range (\u2212128, +128) exclusive.","The \u201cx\u201d component of the result vector receives the value that should be multiplied by the ambient light\/material product (always 1.0). The \u201cy\u201d component of the result vector receives the value that should be multiplied by the diffuse light\/material product (n dot VP_pli). The \u201cz\u201d component of the result vector receives the value that should be multiplied by the specular light\/material product (f_i*(n dot h_i) A s_rm). The \u201cw\u201d component of the result is the constant 1.0.","Negative diffuse and specular dot products are clamped to 0.0, as is done in the standard per-vertex lighting operations. In addition, if the diffuse dot product is zero or negative, the specular coefficient is forced to zero.",{"@attributes":{"id":"p-0292","num":"0291"},"tables":{"@attributes":{"id":"TABLE-US-00063","num":"00063"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11Y"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},"if (tmp.x < 0) tmp.x = 0;",{}]},{"entry":[{},"if (tmp.y < 0) tmp.y = 0;",{}]},{"entry":[{},"if (tmp.w < \u2212(128.0-epsilon)) tmp.w = \u2212(128.0-epsilon);",{}]},{"entry":[{},"else if (tmp.w > 128-epsilon) tmp.w = 128-epsilon;",{}]},{"entry":[{},"result.x = 1.0;",{}]},{"entry":[{},"result.y = tmp.x;",{}]},{"entry":[{},"result.z = (tmp.x > 0) ? RoughApproxPower(tmp.y, tmp.w) : 0.0;",{}]},{"entry":[{},"result.w = 1.0;"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11Z describes the LRP (Linear Interpolation) assembly instruction that is included in unified ISA  and . The LRP instruction performs a component-wise linear interpolation between the second and third operands using the first operand as the blend factor.",{"@attributes":{"id":"p-0294","num":"0293"},"tables":{"@attributes":{"id":"TABLE-US-00064","num":"00064"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11Z"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},"tmp2 = VectorLoad(op2);",{}]},{"entry":[{},"result.x = tmp0.x * tmp1.x + (1 \u2212 tmp0.x) * tmp2.x;",{}]},{"entry":[{},"result.y = tmp0.y * tmp1.y + (1 \u2212 tmp0.y) * tmp2.y;",{}]},{"entry":[{},"result.z = tmp0.z * tmp1.z + (1 \u2212 tmp0.z) * tmp2.z;",{}]},{"entry":[{},"result.w = tmp0.w * tmp1.w + (1 \u2212 tmp0.w) * tmp2.w;"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11AA describes the MAD (Multiple and Add) assembly instruction that is included in unified ISA  and . The MAD instruction performs a component-wise multiply of the first two operands, and then does a component-wise add of the product to the third operand to yield a result vector.",{"@attributes":{"id":"p-0296","num":"0295"},"tables":{"@attributes":{"id":"TABLE-US-00065","num":"00065"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11AA"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"tmp2 = VectorLoad(op2);",{}]},{"entry":[{},{},"result.x = tmp0.x * tmp1.x + tmp2.x;",{}]},{"entry":[{},{},"result.y = tmp0.y * tmp1.y + tmp2.y;",{}]},{"entry":[{},{},"result.z = tmp0.z * tmp1.z + tmp2.z;",{}]},{"entry":[{},{},"result.w = tmp0.w * tmp1.w + tmp2.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11BB describes the MAX (Maximum) assembly instruction that is included in unified ISA  and . The MAX instruction computes component-wise maximums of the values in the two operands to yield a result vector.",{"@attributes":{"id":"p-0298","num":"0297"},"tables":{"@attributes":{"id":"TABLE-US-00066","num":"00066"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11BB"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = (tmp0.x > tmp1.x) ? tmp0.x : tmp1.x;",{}]},{"entry":[{},{},"result.y = (tmp0.y > tmp1.y) ? tmp0.y : tmp1.y;",{}]},{"entry":[{},{},"result.z = (tmp0.z > tmp1.z) ? tmp0.z : tmp1.z;",{}]},{"entry":[{},{},"result.w = (tmp0.w > tmp1.w) ? tmp0.w : tmp1.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11CC describes the MIN (Minimum) assembly instruction that is included in unified ISA  and . The MIN instruction computes component-wise minimums of the values in the two operands to yield a result vector.",{"@attributes":{"id":"p-0300","num":"0299"},"tables":{"@attributes":{"id":"TABLE-US-00067","num":"00067"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11CC"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = (tmp0.x > tmp1.x) ? tmp1.x : tmp0.x;",{}]},{"entry":[{},{},"result.y = (tmp0.y > tmp1.y) ? tmp1.y : tmp0.y;",{}]},{"entry":[{},{},"result.z = (tmp0.z > tmp1.z) ? tmp1.z : tmp0.z;",{}]},{"entry":[{},{},"result.w = (tmp0.w > tmp1.w) ? tmp1.w : tmp0.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11DD describes the MOD (Modulus) assembly instruction that is included in unified ISA  and . The MOD instruction performs a component-wise modulus operation on the two operands to yield a result vector.",{"@attributes":{"id":"p-0302","num":"0301"},"tables":{"@attributes":{"id":"TABLE-US-00068","num":"00068"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11DD"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.x % tmp1.x;",{}]},{"entry":[{},{},"result.y = tmp0.y % tmp1.y;",{}]},{"entry":[{},{},"result.z = tmp0.z % tmp1.z;",{}]},{"entry":[{},{},"result.w = tmp0.w % tmp1.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["200","300"]},"TABLE 11EE describes the MUL (Multiply) assembly instruction that is included in unified ISA  and . The MUL instruction performs a component-wise multiply of the two operands to yield a result vector.",{"@attributes":{"id":"p-0304","num":"0303"},"tables":{"@attributes":{"id":"TABLE-US-00069","num":"00069"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11EE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.x * tmp1.x;",{}]},{"entry":[{},{},"result.y = tmp0.y * tmp1.y;",{}]},{"entry":[{},{},"result.z = tmp0.z * tmp1.z;",{}]},{"entry":[{},{},"result.w = tmp0.w * tmp1.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The \u201cS24\u201d and \u201cU24\u201d modifiers specify \u201cfast\u201d signed or unsigned integer multiplies of 24-bit quantities, respectively. The results of such multiplies are undefined if either operand is outside the range [\u22122^23,+2^23-1] for S24 or [0,2^24-1] for U24. If \u201cS24\u201d or \u201cU24\u201d is specified, the data type is implied and normal data type modifiers may not be provided.","The \u201cHI\u201d modifier specifies a 32-bit integer multiply that returns the 32 most significant bits of the 64-bit product. Integer multiplies without the \u201cHI\u201d modifier normally return the least significant bits of the product. If \u201cHI\u201d is specified, either of the \u201cS\u201d or \u201cU\u201d integer data type modifiers must also be specified. Note that if condition code updates are performed on integer multiplies, the overflow or carry flags are always cleared, even if the product overflowed. If it is necessary to determine if the results of an integer multiply overflowed, the MUL.HI instruction may be used.","TABLE 11FF describes the NOT (Bitwise Not) assembly instruction that is included in unified ISA  and . The NOT instruction performs a component-wise bitwise NOT operation on the source vector to produce a result vector.",{"@attributes":{"id":"p-0308","num":"0307"},"tables":{"@attributes":{"id":"TABLE-US-00070","num":"00070"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11FF"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp.x = ~tmp.x;",{}]},{"entry":[{},{},"tmp.y = ~tmp.y;",{}]},{"entry":[{},{},"tmp.z = ~tmp.z;",{}]},{"entry":[{},{},"tmp.w = ~tmp.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11GG describes the NRM (Normalize 3-Component Vector) assembly instruction that is included in unified ISA  and . The NRM instruction normalizes the vector given by the x, y, and z components of the vector operand to produce the x, y, and z components of the result vector. The w component of the result is undefined.",{"@attributes":{"id":"p-0310","num":"0309"},"tables":{"@attributes":{"id":"TABLE-US-00071","num":"00071"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11GG"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"tmp = VectorLoad(op0);"},{"entry":"scale = ApproxRSQ(tmp.x * tmp.x + tmp.y * tmp.y + tmp.z * tmp.z);"},{"entry":"result.x = tmp.x * scale;"},{"entry":"result.y = tmp.y * scale;"},{"entry":"result.z = tmp.z * scale;"},{"entry":"result.w = undefined;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11HH describes the OR (Bitwise Or) assembly instruction that is included in unified ISA  and . The OR instruction performs a bitwise OR operation on the components of the two source vectors to yield a result vector.",{"@attributes":{"id":"p-0312","num":"0311"},"tables":{"@attributes":{"id":"TABLE-US-00072","num":"00072"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11HH"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);"]},{"entry":[{},{},"tmp1 = VectorLoad(op1);"]},{"entry":[{},{},"result.x = tmp0.x | tmp1.x;"]},{"entry":[{},{},"result.y = tmp0.y | tmp1.y;"]},{"entry":[{},{},"result.z = tmp0.z | tmp1.z;"]},{"entry":[{},{},"result.w = tmp0.w | tmp1.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11II describes the PK2H (Pack Two 16-bit Floats) assembly instruction that is included in unified ISA  and . The PK2H instruction converts the \u201cx\u201d and \u201cy\u201d components of the single floating-point vector operand into 16-bit floating-point format, packs the bit representation of these two floats into a 32-bit unsigned integer, and replicates that value to all four components of the result vector. The PK2H instruction can be reversed by the UP2H instruction below.",{"@attributes":{"id":"p-0314","num":"0313"},"tables":{"@attributes":{"id":"TABLE-US-00073","num":"00073"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11II"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);"]},{"entry":[{},"\/* result obtained by combining raw bits of tmp0.x, tmp0.y *\/"]},{"entry":[{},"result.x = RawBits(tmp0.x) | (RawBits(tmp0.y) << 16);"]},{"entry":[{},"result.y = RawBits(tmp0.x) | (RawBits(tmp0.y) << 16);"]},{"entry":[{},"result.z = RawBits(tmp0.x) | (RawBits(tmp0.y) << 16);"]},{"entry":[{},"result.w = RawBits(tmp0.x) | (RawBits(tmp0.y) << 16);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11JJ describes the PK2US (Pack Two Floats as Unsigned 16-bit) assembly instruction that is included in unified ISA  and . The PK2US instruction converts the \u201cx\u201d and \u201cy\u201d components of the single floating-point vector operand into a packed pair of 16-bit unsigned scalars. The scalars are represented in a bit pattern where all \u20180\u2019 bits corresponds to 0.0 and all \u20181\u2019 bits corresponds to 1.0. The bit representations of the two converted components are packed into a 32-bit unsigned integer, and that value is replicated to all four components of the result vector. The PK2US instruction can be reversed by the UP2US instruction below.",{"@attributes":{"id":"p-0316","num":"0315"},"tables":{"@attributes":{"id":"TABLE-US-00074","num":"00074"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11JJ"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);"]},{"entry":[{},"if (tmp0.x < 0.0) tmp0.x = 0.0;"]},{"entry":[{},"if (tmp0.x > 1.0) tmp0.x = 1.0;"]},{"entry":[{},"if (tmp0.y < 0.0) tmp0.y = 0.0;"]},{"entry":[{},"if (tmp0.y > 1.0) tmp0.y = 1.0;"]},{"entry":[{},"us.x = round(65535.0 * tmp0.x); \/* us is a ushort vector *\/"]},{"entry":[{},"us.y = round(65535.0 * tmp0.y);"]},{"entry":[{},"\/* result obtained by combining raw bits of us. *\/"]},{"entry":[{},"result.x = ((us.x) | (us.y << 16));"]},{"entry":[{},"result.y = ((us.x) | (us.y << 16));"]},{"entry":[{},"result.z = ((us.x) | (us.y << 16));"]},{"entry":[{},"result.w = ((us.x) | (us.y << 16));"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11 KK describes the PK2B (Pack Four Floats as Signed 8-bit) assembly instruction that is included in unified ISA  and . The PK4B instruction converts the four components of the single floating-point vector operand into 8-bit signed quantities. The signed quantities are represented in a bit pattern where all \u20180\u2019 bits corresponds to \u2212128\/127 and all \u20181\u2019 bits corresponds to +127\/127. The bit representations of the four converted components are packed into a 32-bit unsigned integer, and that value is replicated to all four components of the result vector. The PK4B instruction can be reversed by the UP4B instruction below.",{"@attributes":{"id":"p-0318","num":"0317"},"tables":{"@attributes":{"id":"TABLE-US-00075","num":"00075"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11KK"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);"]},{"entry":[{},"if (tmp0.x < \u2212128\/127) tmp0.x = \u2212128\/127;"]},{"entry":[{},"if (tmp0.y < \u2212128\/127) tmp0.y = \u2212128\/127;"]},{"entry":[{},"if (tmp0.z < \u2212128\/127) tmp0.z = \u2212128\/127;"]},{"entry":[{},"if (tmp0.w < \u2212128\/127) tmp0.w = \u2212128\/127;"]},{"entry":[{},"if (tmp0.x > +127\/127) tmp0.x = +127\/127;"]},{"entry":[{},"if (tmp0.y > +127\/127) tmp0.y = +127\/127;"]},{"entry":[{},"if (tmp0.z > +127\/127) tmp0.z = +127\/127;"]},{"entry":[{},"if (tmp0.w > +127\/127) tmp0.w = +127\/127;"]},{"entry":[{},"ub.x = round(127.0 * tmp0.x + 128.0); \/* ub is a ubyte vector *\/"]},{"entry":[{},"ub.y = round(127.0 * tmp0.y + 128.0);"]},{"entry":[{},"ub.z = round(127.0 * tmp0.z + 128.0);"]},{"entry":[{},"ub.w = round(127.0 * tmp0.w + 128.0);"]},{"entry":[{},"\/* result obtained by combining raw bits of ub. *\/"]},{"entry":[{},"result.x = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},"result.y = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},"result.z = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},"result.w = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11LL describes the PK4UB (Pack Four Floats as Unsigned 8-bit) assembly instruction that is included in unified ISA  and . The PK4UB instruction converts the four components of the single floating-point vector operand into a packed grouping of 8-bit unsigned scalars. The scalars are represented in a bit pattern where all \u20180\u2019 bits corresponds to 0.0 and all \u20181\u2019 bits corresponds to 1.0. The bit representations of the four converted components are packed into a 32-bit unsigned integer, and that value is replicated to all four components of the result vector. The PK4UB instruction can be reversed by the UP4UB instruction below.",{"@attributes":{"id":"p-0320","num":"0319"},"tables":{"@attributes":{"id":"TABLE-US-00076","num":"00076"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11LL"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);"]},{"entry":[{},"if (tmp0.x < 0.0) tmp0.x = 0.0;"]},{"entry":[{},"if (tmp0.x > 1.0) tmp0.x = 1.0;"]},{"entry":[{},"if (tmp0.y < 0.0) tmp0.y = 0.0;"]},{"entry":[{},"if (tmp0.y > 1.0) tmp0.y = 1.0;"]},{"entry":[{},"if (tmp0.z < 0.0) tmp0.z = 0.0;"]},{"entry":[{},"if (tmp0.z > 1.0) tmp0.z = 1.0;"]},{"entry":[{},"if (tmp0.w < 0.0) tmp0.w = 0.0;"]},{"entry":[{},"if (tmp0.w > 1.0) tmp0.w = 1.0;"]},{"entry":[{},"ub.x = round(255.0 * tmp0.x); \/* ub is a ubyte vector *\/"]},{"entry":[{},"ub.y = round(255.0 * tmp0.y);"]},{"entry":[{},"ub.z = round(255.0 * tmp0.z);"]},{"entry":[{},"ub.w = round(255.0 * tmp0.w);"]},{"entry":[{},"\/* result obtained by combining raw bits of ub. *\/"]},{"entry":[{},"result.x = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},"result.y = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},"result.z = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":[{},"result.w = ((ub.x) | (ub.y << 8) | (ub.z << 16) | (ub.w << 24));"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11MM describes the POW (Exponentiate) assembly instruction that is included in unified ISA  and . The POW instruction approximates the value of the first scalar operand raised to the power of the second scalar operand and replicates it to all four components of the result vector.",{"@attributes":{"id":"p-0322","num":"0321"},"tables":{"@attributes":{"id":"TABLE-US-00077","num":"00077"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11MM"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = ScalarLoad(op0);"]},{"entry":[{},{},"tmp1 = ScalarLoad(op1);"]},{"entry":[{},{},"result.x = ApproxPower(tmp0, tmp1);"]},{"entry":[{},{},"result.y = ApproxPower(tmp0, tmp1);"]},{"entry":[{},{},"result.z = ApproxPower(tmp0, tmp1);"]},{"entry":[{},{},"result.w = ApproxPower(tmp0, tmp1);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11NN describes the RCC (Reciprocal, clamped) assembly instruction that is included in unified ISA  and . The RCC instruction approximates the reciprocal of the scalar operand, clamps the result to one of two ranges, and replicates the clamped result to all four components of the result vector. If the approximated reciprocal is greater than 0.0, the result is clamped to the range [2^\u221264, 2^+64]. If the approximate reciprocal is not greater than zero, the result is clamped to the range [\u22122^+64, \u22122^\u221264].",{"@attributes":{"id":"p-0324","num":"0323"},"tables":{"@attributes":{"id":"TABLE-US-00078","num":"00078"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11NN"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);"]},{"entry":[{},{},"result.x = ClampApproxReciprocal(tmp);"]},{"entry":[{},{},"result.y = ClampApproxReciprocal(tmp);"]},{"entry":[{},{},"result.z = ClampApproxReciprocal(tmp);"]},{"entry":[{},{},"result.w = ClampApproxReciprocal(tmp);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11OO describes the RCP (Reciprocal) assembly instruction that is included in unified ISA  and . The RCP instruction approximates the reciprocal of the scalar operand and replicates it to all four components of the result vector.",{"@attributes":{"id":"p-0326","num":"0325"},"tables":{"@attributes":{"id":"TABLE-US-00079","num":"00079"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11OO"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);"]},{"entry":[{},{},"result.x = ApproxReciprocal(tmp);"]},{"entry":[{},{},"result.y = ApproxReciprocal(tmp);"]},{"entry":[{},{},"result.z = ApproxReciprocal(tmp);"]},{"entry":[{},{},"result.w = ApproxReciprocal(tmp);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"A REP (Start of Repeat Block) assembly instruction is included in unified ISA  and . The REP instruction begins a REP\/ENDREP block. The REP instruction supports an optional operand whose x component specifies the initial value for the loop count. The loop count indicates the number of times the instructions between the REP and corresponding ENDREP instruction will be executed. If the initial value of the loop count is not positive, the entire block is skipped and execution continues at the instruction following the corresponding ENDREP instruction. If the loop count is specified as a floating-point value, it is converted to the largest integer less than or equal to the specified value (i.e., taking its floor).","If no operand is provided to REP, the loop count is ignored and the corresponding ENDREP instruction unconditionally transfers control to the instruction immediately following the REP instruction. The only way to exit such a loop is with the BRK instruction. To prevent obvious infinite loops, a program that includes a REP\/ENDREP block with no loop count will fail to compile unless it contains either a BRK instruction at the current nesting level or a RET instruction at any nesting level.","Implementations may have a limited ability to nest REP\/ENDREP blocks. If the number of REP\/ENDREP blocks nested inside each other is MAX_PROGRAM_LOOP_DEPTH_NV or higher, a program will fail to compile. TABLE 11PP lists pseudo-code for setting up a new nesting level.",{"@attributes":{"id":"p-0330","num":"0329"},"tables":{"@attributes":{"id":"TABLE-US-00080","num":"00080"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11PP"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"\/\/ Set up loop information for the new nesting level."]},{"entry":[{},{},"tmp = VectorLoad(op0);"]},{"entry":[{},{},"LoopCount = floor(tmp.x);"]},{"entry":[{},{},"if (LoopCount <= 0) {"]},{"entry":[{},{},"continue execution at the corresponding ENDREP;"]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"REP supports all three data type modifiers. The single operand is interpreted according to the data type modifier. Note that REP blocks support fully general looping; the specified loop count can be computed in the program itself. Additionally, there is no run-time limit on the maximum overall depth of REP\/ENDREP nesting. As long as each individual subroutine of the program obeys the static nesting limits, there will be no run-time errors in the program. With conventional assembly instructions, a program could terminate abnormally if it called a subroutine inside a deeply nested set of REP\/ENDREP blocks and the called subroutine also contained deeply nested REP\/ENDREP blocks. Such an error could occur even if neither subroutine exceeded static limits.","A RET (Subroutine Return) assembly instruction is included in unified ISA  and . The RET instruction conditionally returns from a subroutine initiated by a CAL instruction by popping an instruction reference off the top of the call stack and transferring control to the referenced instruction. TABLE 11QQ lists pseudo-code that describes the operation of the RET instruction.",{"@attributes":{"id":"p-0333","num":"0332"},"tables":{"@attributes":{"id":"TABLE-US-00081","num":"00081"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11QQ"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"if (TestCC(cc.c***) \u2225 TestCC(cc.*c**) \u2225"]},{"entry":[{},{},"\u2003TestCC(cc.**c*) \u2225 TestCC(cc.***c)) {"]},{"entry":[{},{},"if (callStackDepth <= 0) {"]},{"entry":[{},{},"\u2003\/\/ terminate program"]},{"entry":[{},{},"} else {"]},{"entry":[{},{},"\u2003callStackDepth--;"]},{"entry":[{},{},"\u2003instruction = callStack[callStackDepth];"]},{"entry":[{},{},"}"]},{"entry":[{},{},"\/\/ continue execution at <instruction>"]},{"entry":[{},{},"\u2003} else {"]},{"entry":[{},{},"\/\/ do nothing"]},{"entry":[{},{},"\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11RR describes the RFL (Reflection Vector) assembly instruction that is included in unified ISA  and . The RFL instruction computes the reflection of the second vector operand (the \u201cdirection\u201d vector) about the vector specified by the first vector operand (the \u201caxis\u201d vector). Both operands are treated as 3D vectors (the w components are ignored). The result vector is another 3D vector (the \u201creflected direction\u201d vector). The length of the result vector, ignoring rounding errors, should equal that of the second operand.",{"@attributes":{"id":"p-0335","num":"0334"},"tables":{"@attributes":{"id":"TABLE-US-00082","num":"00082"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11RR"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"axis = VectorLoad(op0);"]},{"entry":[{},{},"direction = VectorLoad(op1);"]},{"entry":[{},{},"tmp.w = (axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);"]},{"entry":[{},{},"tmp.x = (axis.x * direction.x + axis.y * direction.y +"]},{"entry":[{},{},"axis.z * direction.z);"]},{"entry":[{},{},"tmp.x = 2.0 * tmp.x;"]},{"entry":[{},{},"tmp.x = tmp.x \/ tmp.w;"]},{"entry":[{},{},"result.x = tmp.x * axis.x \u2212 direction.x;"]},{"entry":[{},{},"result.y = tmp.x * axis.y \u2212 direction.y;"]},{"entry":[{},{},"result.z = tmp.x * axis.z \u2212 direction.z;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11SS describes the ROUND (Round to Nearest Integer) assembly instruction that is included in unified ISA  and . The ROUND instruction loads a single vector operand and performs a component-wise round operation to generate a result vector.",{"@attributes":{"id":"p-0337","num":"0336"},"tables":{"@attributes":{"id":"TABLE-US-00083","num":"00083"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11SS"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);"]},{"entry":[{},{},"result.x = round(tmp.x);"]},{"entry":[{},{},"result.y = round(tmp.y);"]},{"entry":[{},{},"result.z = round(tmp.z);"]},{"entry":[{},{},"result.w = round(tmp.w);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11TT describes the RSQ (Reciprocal Square Root) assembly instruction that is included in unified ISA  and . The RSQ instruction approximates the reciprocal of the square root of the scalar operand and replicates it to all four components of the result vector.",{"@attributes":{"id":"p-0339","num":"0338"},"tables":{"@attributes":{"id":"TABLE-US-00084","num":"00084"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11TT"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);"]},{"entry":[{},{},"result.x = ApproxRSQRT(tmp);"]},{"entry":[{},{},"result.y = ApproxRSQRT(tmp);"]},{"entry":[{},{},"result.z = ApproxRSQRT(tmp);"]},{"entry":[{},{},"result.w = ApproxRSQRT(tmp);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11UU describes the SAD (Sum of Absolute Differences) assembly instruction that is included in unified ISA  and . The SAD instruction performs a component-wise difference of the first two integer operands (subtracting the second from the first), and then does a component-wise add of the absolute value of the difference to the third unsigned integer operand to yield an unsigned integer result vector.",{"@attributes":{"id":"p-0341","num":"0340"},"tables":{"@attributes":{"id":"TABLE-US-00085","num":"00085"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11UU"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);"]},{"entry":[{},"tmp1 = VectorLoad(op1);"]},{"entry":[{},"tmp2 = VectorLoad(op2);"]},{"entry":[{},"result.x = abs(tmp0.x \u2212 tmp1.x) + tmp2.x;"]},{"entry":[{},"result.y = abs(tmp0.y \u2212 tmp1.y) + tmp2.y;"]},{"entry":[{},"result.z = abs(tmp0.z \u2212 tmp1.z) + tmp2.z;"]},{"entry":[{},"result.w = abs(tmp0.w \u2212 tmp1.w) + tmp2.w;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11VV describes the SCS (Sine\/Cosine without Reduction) assembly instruction that is included in unified ISA  and . The SCS instruction approximates the trigonometric sine and cosine of the angle specified by the scalar operand and places the cosine in the x component and the sine in the y component of the result vector. The z and w components of the result vector are undefined. The angle is specified in radians and must be in the range [\u2212PI,PI].",{"@attributes":{"id":"p-0343","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00086","num":"00086"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11VV"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);"]},{"entry":[{},{},"result.x = ApproxCosine(tmp);"]},{"entry":[{},{},"result.y = ApproxSine(tmp);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11WW describes the SEQ (Set on Equal) assembly instruction that is included in unified ISA  and . The SEQ instruction performs a component-wise comparison of the two operands. Each component of the result vector returns a TRUE value (described below) if the corresponding component of the first operand is equal to that of the second, and a FALSE value otherwise.",{"@attributes":{"id":"p-0345","num":"0344"},"tables":{"@attributes":{"id":"TABLE-US-00087","num":"00087"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11WW"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = (tmp0.x == tmp1.x) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.y = (tmp0.y == tmp1.y) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.z = (tmp0.z == tmp1.z) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.w = (tmp0.w == tmp1.w) ? TRUE : FALSE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11XX describes the SFL (Set on False) assembly instruction that is included in unified ISA  and . The SFL instruction is a degenerate case of the other \u201cSet on\u201d instructions that sets all components of the result vector to a FALSE value (described below).",{"@attributes":{"id":"p-0347","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00088","num":"00088"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11XX"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"result.x = FALSE;",{}]},{"entry":[{},{},"result.y = FALSE;",{}]},{"entry":[{},{},"result.z = FALSE;",{}]},{"entry":[{},{},"result.w = FALSE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11YY describes the SGE (Set on Greater Than or Equal) assembly instruction that is included in unified ISA  and . The SGE instruction performs a component-wise comparison of the two operands. Each component of the result vector returns a TRUE value (described below) if the corresponding component of the first operand is greater than or equal to that of the second, and a FALSE value otherwise.",{"@attributes":{"id":"p-0349","num":"0348"},"tables":{"@attributes":{"id":"TABLE-US-00089","num":"00089"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11YY"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = (tmp0.x >= tmp1.x) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.y = (tmp0.y >= tmp1.y) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.z = (tmp0.z >= tmp1.z) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.w = (tmp0.w >= tmp1.w) ? TRUE : FALSE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11ZZ describes the SGT (Set on Greater Than) assembly instruction that is included in unified ISA  and . The SGT instruction performs a component-wise comparison of the two operands. Each component of the result vector returns a TRUE value (described below) if the corresponding component of the first operand is greater than that of the second, and a FALSE value otherwise.",{"@attributes":{"id":"p-0351","num":"0350"},"tables":{"@attributes":{"id":"TABLE-US-00090","num":"00090"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11ZZ"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = (tmp0.x > tmp1.x) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.y = (tmp0.y > tmp1.y) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.z = (tmp0.z > tmp1.z) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.w = (tmp0.w > tmp1.w) ? TRUE : FALSE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11AAA describes the SHL (Shift Left) assembly instruction that is included in unified ISA  and . The SHL instruction performs a component-wise left shift of the bits of the first operand by the value of the second scalar operand to produce a result vector. The bits vacated during the shift operation are filled with zeroes.",{"@attributes":{"id":"p-0353","num":"0352"},"tables":{"@attributes":{"id":"TABLE-US-00091","num":"00091"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11AAA"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = ScalarLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.x << tmp1;",{}]},{"entry":[{},{},"result.y = tmp0.y << tmp1;",{}]},{"entry":[{},{},"result.z = tmp0.z << tmp1;",{}]},{"entry":[{},{},"result.w = tmp0.w << tmp1;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11BBB describes the SHR (Shift Right) assembly instruction that is included in unified ISA  and . The SHR instruction performs a component-wise right shift of the bits of the first operand by the value of the second scalar operand to produce a result vector. The bits vacated during shift operation are filled with zeros if the operand is non-negative and ones otherwise.",{"@attributes":{"id":"p-0355","num":"0354"},"tables":{"@attributes":{"id":"TABLE-US-00092","num":"00092"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11BBB"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = ScalarLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.x >> tmp1;",{}]},{"entry":[{},{},"result.y = tmp0.y >> tmp1;",{}]},{"entry":[{},{},"result.z = tmp0.z >> tmp1;",{}]},{"entry":[{},{},"result.w = tmp0.w >> tmp1;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11CCC describes the SIN (Sine with Reduction to [\u2212PI,PI]) assembly instruction that is included in unified ISA  and . The SIN instruction approximates the trigonometric sine of the angle specified by the scalar operand and replicates it to all four components of the result vector. The angle is specified in radians and does not have to be in the range [\u2212PI,PI].",{"@attributes":{"id":"p-0357","num":"0356"},"tables":{"@attributes":{"id":"TABLE-US-00093","num":"00093"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11CCC"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);",{}]},{"entry":[{},{},"result.x = ApproxSine(tmp);",{}]},{"entry":[{},{},"result.y = ApproxSine(tmp);",{}]},{"entry":[{},{},"result.z = ApproxSine(tmp);",{}]},{"entry":[{},{},"result.w = ApproxSine(tmp);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11DDD describes the SLE (Set on Less Than or Equal) assembly instruction that is included in unified ISA  and . The SLE instruction performs a component-wise comparison of the two operands. Each component of the result vector returns a TRUE value (described below) if the corresponding component of the first operand is less than or equal to that of the second, and a FALSE value otherwise.",{"@attributes":{"id":"p-0359","num":"0358"},"tables":{"@attributes":{"id":"TABLE-US-00094","num":"00094"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11DDD"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = (tmp0.x <= tmp1.x) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.y = (tmp0.y <= tmp1.y) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.z = (tmp0.z <= tmp1.z) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.w = (tmp0.w <= tmp1.w) ? TRUE : FALSE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11EEE describes the SLT (Set on Less Than) assembly instruction that is included in unified ISA  and . The SLT instruction performs a component-wise comparison of the two operands. Each component of the result vector returns a TRUE value (described below) if the corresponding component of the first operand is less than that of the second, and a FALSE value otherwise.",{"@attributes":{"id":"p-0361","num":"0360"},"tables":{"@attributes":{"id":"TABLE-US-00095","num":"00095"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11EEE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = (tmp0.x < tmp1.x) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.y = (tmp0.y < tmp1.y) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.z = (tmp0.z < tmp1.z) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.w = (tmp0.w < tmp1.w) ? TRUE : FALSE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11FFF describes the SNE (Set on Not Equal) assembly instruction that is included in unified ISA  and . The SNE instruction performs a component-wise comparison of the two operands. Each component of the result vector returns a TRUE value (described below) if the corresponding component of the first operand is less than that of the second, and a FALSE value otherwise.",{"@attributes":{"id":"p-0363","num":"0362"},"tables":{"@attributes":{"id":"TABLE-US-00096","num":"00096"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11FFF"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = (tmp0.x != tmp1.x) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.y = (tmp0.y != tmp1.y) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.z = (tmp0.z != tmp1.z) ? TRUE : FALSE;",{}]},{"entry":[{},{},"result.w = (tmp0.w != tmp1.w) ? TRUE : FALSE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11GGG describes the SSG (Set Sign) assembly instruction that is included in unified ISA  and . The SSG instruction generates a result vector containing the signs of each component of the single vector operand. Each component of the result vector is 1.0 if the corresponding component of the operand is greater than zero, 0.0 if the corresponding component of the operand is equal to zero, and \u22121.0 if the corresponding component of the operand is less than zero.",{"@attributes":{"id":"p-0365","num":"0364"},"tables":{"@attributes":{"id":"TABLE-US-00097","num":"00097"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11GGG"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},{},"result.x = SetSign(tmp.x);",{}]},{"entry":[{},{},"result.y = SetSign(tmp.y);",{}]},{"entry":[{},{},"result.z = SetSign(tmp.z);",{}]},{"entry":[{},{},"result.w = SetSign(tmp.w);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11HHH describes the STR (Set on True) assembly instruction that is included in unified ISA  and . The STR instruction is a degenerate case of the other \u201cSet on\u201d instructions that sets all components of the result vector to a TRUE value (described below).",{"@attributes":{"id":"p-0367","num":"0366"},"tables":{"@attributes":{"id":"TABLE-US-00098","num":"00098"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11HHH"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"result.x = TRUE;",{}]},{"entry":[{},{},"result.y = TRUE;",{}]},{"entry":[{},{},"result.z = TRUE;",{}]},{"entry":[{},{},"result.w = TRUE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11III describes the SUB (Subtract) assembly instruction that is included in unified ISA  and . The SUB instruction performs a component-wise subtraction of the second operand from the first to yield a result vector.",{"@attributes":{"id":"p-0369","num":"0368"},"tables":{"@attributes":{"id":"TABLE-US-00099","num":"00099"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11III"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.x \u2212 tmp1.x;",{}]},{"entry":[{},{},"result.y = tmp0.y \u2212 tmp1.y;",{}]},{"entry":[{},{},"result.z = tmp0.z \u2212 tmp1.z;",{}]},{"entry":[{},{},"result.w = tmp0.w \u2212 tmp1.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"A SWZ (Extended Swizzle) assembly instruction is included in unified ISA  and . The SWZ instruction loads the single vector operand, and performs a swizzle operation more powerful than that provided for loading normal vector operands to yield an instruction vector. After the operand is loaded, the \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d components of the result vector are selected by the first, second, third, and fourth matches of the <extSwizComp> pattern in the <extendedSwizzle> rule.","A result component can be selected from any of the four components of the operand or the constants 0.0 and 1.0. The result component can also be optionally negated. The following pseudo-code listed in TABLE 11JJJ describes the component selection method. \u201coperand\u201d refers to the vector operand, \u201cselect\u201d is an enumerant where the values ZERO, ONE, X, Y, Z, and W correspond to the <extSwizSel> rule matching \u201c0\u201d, \u201c1\u201d, \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d, respectively. \u201cnegate\u201d is TRUE if and only if the <optionalSign> rule in <extSwizComp> matches \u201c\u2212\u201d.",{"@attributes":{"id":"p-0372","num":"0371"},"tables":{"@attributes":{"id":"TABLE-US-00100","num":"00100"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11JJJ"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003float ExtSwizComponent(floatVec operand, enum select, boolean"},{"entry":"negate)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003float result;"},{"entry":"\u2003\u2003switch (select) {"},{"entry":"\u2003case ZERO: result = 0.0; break;"},{"entry":"\u2003case ONE: result = 1.0; break;"},{"entry":"\u2003case X: result = operand.x; break;"},{"entry":"\u2003case Y: result = operand.y; break;"},{"entry":"\u2003case Z: result = operand.z; break;"},{"entry":"\u2003case W: result = operand.w; break;"},{"entry":"\u2003}"},{"entry":"\u2003\u2003if (negate) {"},{"entry":"\u2003result = \u2212result;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return result;"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The entire extended swizzle operation is then defined using the pseudo-code shown in TABLE 11KKK.",{"@attributes":{"id":"p-0374","num":"0373"},"tables":{"@attributes":{"id":"TABLE-US-00101","num":"00101"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11KKK"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},{},"result.x = ExtSwizComponent(tmp, xSelect, xNegate);",{}]},{"entry":[{},{},"result.y = ExtSwizComponent(tmp, ySelect, yNegate);",{}]},{"entry":[{},{},"result.z = ExtSwizComponent(tmp, zSelect, zNegate);",{}]},{"entry":[{},{},"result.w = ExtSwizComponent(tmp, wSelect, wNegate);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11LLL describes the TEX (Texture Sample) assembly instruction that is included in unified ISA  and . The TEX instruction takes the four components of a single floating-point source vector and performs a filtered texture access. The returned (R,G,B,A) value is written to the floating-point result vector. Partial derivatives and the level of detail are computed automatically.",{"@attributes":{"id":"p-0376","num":"0375"},"tables":{"@attributes":{"id":"TABLE-US-00102","num":"00102"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11LLL"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},"ddx = ComputePartialsX(tmp);",{}]},{"entry":[{},"ddy = ComputePartialsY(tmp);",{}]},{"entry":[{},"lambda = ComputeLOD(ddx, ddy);",{}]},{"entry":[{},"result = TextureSample(tmp, lambda, ddx, ddy, texelOffset);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11MMM describes the TRUNC (Truncate, round toward zero) assembly instruction that is included in unified ISA  and . The TRUNC instruction loads a single vector operand and performs a component-wise truncate operation to generate a result vector.",{"@attributes":{"id":"p-0378","num":"0377"},"tables":{"@attributes":{"id":"TABLE-US-00103","num":"00103"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11MMM"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},{},"result.x = trunc(tmp.x);",{}]},{"entry":[{},{},"result.y = trunc(tmp.y);",{}]},{"entry":[{},{},"result.z = trunc(tmp.z);",{}]},{"entry":[{},{},"result.w = trunc(tmp.w);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11NNN describes the TXB (Texture Sample with Bias) assembly instruction that is included in unified ISA  and . The TXB instruction takes the four components of a single floating-point source vector and performs a filtered texture access. The returned (R,G,B,A) value is written to the floating-point result vector. Partial derivatives and the level of detail are computed automatically, but the fourth component of the source vector is added to the computed LOD prior to sampling.",{"@attributes":{"id":"p-0380","num":"0379"},"tables":{"@attributes":{"id":"TABLE-US-00104","num":"00104"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11NNN"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},"ddx = ComputePartialsX(tmp);",{}]},{"entry":[{},"ddy = ComputePartialsY(tmp);",{}]},{"entry":[{},"lambda = ComputeLOD(ddx, ddy);",{}]},{"entry":[{},"result = TextureSample(tmp, lambda + tmp.w, ddx, ddy, texelOffset);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11OOO describes the TXD (Texture Sample with Partials) assembly instruction that is included in unified ISA  and . The TXD instruction takes the four components of the first floating-point source vector and performs a filtered texture access. The returned (R,G,B,A) value is written to the floating-point result vector. The partial derivatives of the texture coordinates with respect to X and Y are specified by the second and third floating-point source vectors. The level of detail is computed automatically using the provided partial derivatives. Note that for cube map texture targets, the provided partial derivatives are in the coordinate system used before texture coordinates are projected onto the appropriate cube face. The partial derivatives of the post-projection texture coordinates, which are used for level-of-detail and anisotropic filtering calculations, are derived from the original coordinates and partial derivatives in an implementation-dependent manner.",{"@attributes":{"id":"p-0382","num":"0381"},"tables":{"@attributes":{"id":"TABLE-US-00105","num":"00105"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11OOO"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},"tmp2 = VectorLoad(op2);",{}]},{"entry":[{},"lambda = ComputeLOD(tmp1, tmp2);",{}]},{"entry":[{},"result = TextureSample(tmp0, lambda, tmp1, tmp2, texelOffset);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11PPP describes the TXF (Texel Fetch) assembly instruction that is included in unified ISA  and . The TXF instruction takes the four components of a single signed integer source vector and performs a single texel fetch. The first three components provide the <i>, <j>, and <k> values for the texel fetch, and the fourth component is used to determine the level of detail (LOD) to access. The returned (R,G,B,A) value is written to the floating-point result vector. Partial derivatives are irrelevant for single texel fetches.",{"@attributes":{"id":"p-0384","num":"0383"},"tables":{"@attributes":{"id":"TABLE-US-00106","num":"00106"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11PPP"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},{},"result = TexelFetch(tmp, texelOffset);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11QQQ describes the TXL (Texture Sample with LOD) assembly instruction that is included in unified ISA  and . The TXL instruction takes the four components of a single floating-point source vector and performs a filtered texture access. The returned (R,G,B,A) value is written to the floating-point result vector. The level of detail is taken from the fourth component of the source vector. Partial derivatives are not computed by the TXL instruction and anisotropic filtering is not performed.",{"@attributes":{"id":"p-0386","num":"0385"},"tables":{"@attributes":{"id":"TABLE-US-00107","num":"00107"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11QQQ"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = VectorLoad(op0);",{}]},{"entry":[{},{},"ddx = (0,0,0);",{}]},{"entry":[{},{},"ddy = (0,0,0);",{}]},{"entry":[{},{},"result = TextureSample(tmp, tmp.w, ddx, ddy, texelOffset);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"2"},"TABLE 11RRR describes the TXP (Texture Sample with Projection) assembly instruction that is included in unified ISA  and . The TXP instruction divides the first three components of its single floating-point source vector by its fourth component, maps the results to s, t, and r, and performs a filtered texture access. The returned (R,G,B,A) value is written to the floating-point result vector. Partial derivatives and the level of detail are computed automatically.",{"@attributes":{"id":"p-0388","num":"0387"},"tables":{"@attributes":{"id":"TABLE-US-00108","num":"00108"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11RRR"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},"tmp0.x = tmp0.x \/ tmp0.w;",{}]},{"entry":[{},"tmp0.y = tmp0.y \/ tmp0.w;",{}]},{"entry":[{},"tmp0.z = tmp0.z \/ tmp0.w;",{}]},{"entry":[{},"ddx = ComputePartialsX(tmp);",{}]},{"entry":[{},"ddy = ComputePartialsY(tmp);",{}]},{"entry":[{},"lambda = ComputeLOD(ddx, ddy);",{}]},{"entry":[{},"result = TextureSample(tmp, lambda, ddx, ddy, texelOffset);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"2"},"TABLE 11SSS describes the TXQ (Texture Size Query) assembly instruction that is included in unified ISA  and . The TXQ instruction takes the first component of the single integer vector operand, adds the number of the base level of the specified texture to determine a texture image level, and returns an integer result vector containing the size of the image at that level of the texture.","For one-dimensional and one-dimensional array textures, the \u201cx\u201d component of the result vector is filled with the width of the image(s). For two-dimensional, rectangle, cube map, and two-dimensional array textures, the \u201cx\u201d and \u201cy\u201d components are filled with the width and height of the image(s). For three-dimensional textures, the \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d components are filled with the width, height, and depth of the image. Additionally, the number of layers in an array texture is returned in the \u201cy\u201d component of the result for one-dimensional array textures or the \u201cz\u201d component for two-dimensional array textures. All other components of the result vector is undefined. For the purposes of this instruction, the width, height, and depth of a texture do NOT include any border.",{"@attributes":{"id":"p-0391","num":"0390"},"tables":{"@attributes":{"id":"TABLE-US-00109","num":"00109"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11SSS"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp0.x = tmp0.x + texture[op1].target[op2].base_level;",{}]},{"entry":[{},{},"result.x = texture[op1].target[op2].level[tmp0.x].width;",{}]},{"entry":[{},{},"result.y = texture[op1].target[op2].level[tmp0.x].height;",{}]},{"entry":[{},{},"result.z = texture[op1].target[op2].level[tmp0.x].depth;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11TTT describes the UP2H (Unpack Two 16-bit Floats) assembly instruction that is included in unified ISA  and . The UP2H instruction unpacks two 16-bit floats stored together in a 32-bit scalar operand. The first 16-bit float (stored in the 16 least significant bits) is written into the \u201cx\u201d and \u201cz\u201d components of the result vector; the second is written into the \u201cy\u201d and \u201cw\u201d components of the result vector. This operation undoes the type conversion and packing performed by the PK2H instruction.",{"@attributes":{"id":"p-0393","num":"0392"},"tables":{"@attributes":{"id":"TABLE-US-00110","num":"00110"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11TTT"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp = ScalarLoad(op0);",{}]},{"entry":[{},"result.x = (fp16) (RawBits(tmp) & 0xFFFF);",{}]},{"entry":[{},"result.y = (fp16) ((RawBits(tmp) >> 16) & 0xFFFF);",{}]},{"entry":[{},"result.z = (fp16) (RawBits(tmp) & 0xFFFF);",{}]},{"entry":[{},"result.w = (fp16) ((RawBits(tmp) >> 16) & 0xFFFF);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"TABLE 11UUU describes the UP2US (Unpack Two Unsigned 16-bit","Integers) assembly instruction that is included in unified ISA  and . The UP2US instruction unpacks two 16-bit unsigned values packed together in a 32-bit scalar operand. The unsigned quantities are encoded where a bit pattern of all \u20180\u2019 bits corresponds to 0.0 and a pattern of all \u20181\u2019 bits corresponds to 1.0. The \u201cx\u201d and \u201cz\u201d components of the result vector are obtained from the 16 least significant bits of the operand; the \u201cy\u201d and \u201cw\u201d components are obtained from the 16 most significant bits. This operation undoes the type conversion and packing performed by the PK2US instruction.",{"@attributes":{"id":"p-0396","num":"0395"},"tables":{"@attributes":{"id":"TABLE-US-00111","num":"00111"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11UUU"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);",{}]},{"entry":[{},{},"result.x = ((RawBits(tmp) >> 0) & 0xFFFF) \/ 65535.0;",{}]},{"entry":[{},{},"result.y = ((RawBits(tmp) >> 16) & 0xFFFF) \/ 65535.0;",{}]},{"entry":[{},{},"result.z = ((RawBits(tmp) >> 0) & 0xFFFF) \/ 65535.0;",{}]},{"entry":[{},{},"result.w = ((RawBits(tmp) >> 16) & 0xFFFF) \/ 65535.0;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11VVV describes the UP4B (Unpack Four Signed 8-bit Integers) assembly instruction that is included in unified ISA  and . The UP4B instruction unpacks four 8-bit signed values packed together in a 32-bit scalar operand. The signed quantities are encoded where a bit pattern of all \u20180\u2019 bits corresponds to \u2212128\/127 and a pattern of all \u20181\u2019 bits corresponds to +127\/127. The \u201cx\u201d component of the result vector is the converted value corresponding to the 8 least significant bits of the operand; the \u201cw\u201d component corresponds to the 8 most significant bits. This operation undoes the type conversion and packing performed by the PK4B instruction.",{"@attributes":{"id":"p-0398","num":"0397"},"tables":{"@attributes":{"id":"TABLE-US-00112","num":"00112"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11VVV"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);",{}]},{"entry":[{},{},"result.x = (((RawBits(tmp) >> 0) & 0xFF) - 128) \/ 127.0;",{}]},{"entry":[{},{},"result.y = (((RawBits(tmp) >> 8) & 0xFF) - 128) \/ 127.0;",{}]},{"entry":[{},{},"result.z = (((RawBits(tmp) >> 16) & 0xFF) - 128) \/ 127.0;",{}]},{"entry":[{},{},"result.w = (((RawBits(tmp) >> 24) & 0xFF) - 128) \/ 127.0;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11WWW describes the UP4UB (Unpack Four Unsigned 8-bit Integers) assembly instruction that is included in unified ISA  and . The UP4UB instruction unpacks four 8-bit unsigned values packed together in a 32-bit scalar operand. The unsigned quantities are encoded where a bit pattern of all \u20180\u2019 bits corresponds to 0.0 and a pattern of all \u20181\u2019 bits corresponds to 1.0. The \u201cx\u201d component of the result vector is obtained from the 8 least significant bits of the operand; the \u201cw\u201d component is obtained from the 8 most significant bits. This operation undoes the type conversion and packing performed by the PK4UB instruction.",{"@attributes":{"id":"p-0400","num":"0399"},"tables":{"@attributes":{"id":"TABLE-US-00113","num":"00113"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11WWW"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp = ScalarLoad(op0);",{}]},{"entry":[{},{},"result.x = ((RawBits(tmp) >> 0) & 0xFF) \/ 255.0;",{}]},{"entry":[{},{},"result.y = ((RawBits(tmp) >> 8) & 0xFF) \/ 255.0;",{}]},{"entry":[{},{},"result.z = ((RawBits(tmp) >> 16) & 0xFF) \/ 255.0;",{}]},{"entry":[{},{},"result.w = ((RawBits(tmp) >> 24) & 0xFF) \/ 255.0;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11XXX describes the X2D (2D Coordinate Transformation) assembly instruction that is included in unified ISA  and . The X2D instruction multiplies the 2D offset vector specified by the \u201cx\u201d and \u201cy\u201d components of the second vector operand by the 2\u00d72 matrix specified by the four components of the third vector operand, and adds the transformed offset vector to the 2D vector specified by the \u201cx\u201d and \u201cy\u201d components of the first vector operand. The first component of the sum is written to the \u201cx\u201d and \u201cz\u201d components of the result; the second component is written to the \u201cy\u201d and \u201cw\u201d components of the result.",{"@attributes":{"id":"p-0402","num":"0401"},"tables":{"@attributes":{"id":"TABLE-US-00114","num":"00114"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11XXX"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"tmp2 = VectorLoad(op2);",{}]},{"entry":[{},{},"result.x = tmp0.x + tmp1.x * tmp2.x + tmp1.y * tmp2.y;",{}]},{"entry":[{},{},"result.y = tmp0.y + tmp1.x * tmp2.z + tmp1.y * tmp2.w;",{}]},{"entry":[{},{},"result.z = tmp0.x + tmp1.x * tmp2.x + tmp1.y * tmp2.y;",{}]},{"entry":[{},{},"result.w = tmp0.y + tmp1.x * tmp2.z + tmp1.y * tmp2.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11YYY describes the XOR (Exclusive OR) assembly instruction that is included in unified ISA  and . The XOR instruction performs a bitwise XOR operation on the components of the two source vectors to yield a result vector.",{"@attributes":{"id":"p-0404","num":"0403"},"tables":{"@attributes":{"id":"TABLE-US-00115","num":"00115"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11YYY"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.x {circumflex over (\u2009)} tmp1.x;",{}]},{"entry":[{},{},"result.y = tmp0.y {circumflex over (\u2009)} tmp1.y;",{}]},{"entry":[{},{},"result.z = tmp0.z {circumflex over (\u2009)} tmp1.z;",{}]},{"entry":[{},{},"result.w = tmp0.w {circumflex over (\u2009)} tmp1.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"TABLE 11ZZZ describes the XPD (Cross Product) assembly instruction that is included in unified ISA  and . The XPD instruction computes the cross product using the first three components of its two vector operands to generate the x, y, and z components of the result vector. The w component of the result vector is undefined.",{"@attributes":{"id":"p-0406","num":"0405"},"tables":{"@attributes":{"id":"TABLE-US-00116","num":"00116"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11ZZZ"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"tmp0 = VectorLoad(op0);",{}]},{"entry":[{},{},"tmp1 = VectorLoad(op1);",{}]},{"entry":[{},{},"result.x = tmp0.y * tmp1.z \u2212 tmp0.z * tmp1.y;",{}]},{"entry":[{},{},"result.y = tmp0.z * tmp1.x \u2212 tmp0.x * tmp1.z;",{}]},{"entry":[{},{},"result.z = tmp0.x * tmp1.y \u2212 tmp0.y * tmp1.x;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The listing of steps in method claims do not imply performing the steps in any particular order, unless explicitly stated in the claim.","All trademarks are the respective property of their owners."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2D"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 4C","FIGS. 4A and 4B"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
