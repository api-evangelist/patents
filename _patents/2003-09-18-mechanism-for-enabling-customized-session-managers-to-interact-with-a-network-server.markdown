---
title: Mechanism for enabling customized session managers to interact with a network server
abstract: A mechanism for enabling customized session managers to interact with a network server is disclosed. A programming interface enables customized session managers to “plug in” to and to interact with the server, making it possible to change session management functionality without having to make any changes to the core server. It also makes it possible to incorporate multiple session managers into the server. These aspects of the programming interface significantly increase the flexibility and scalability of the web server. The mechanism further includes a service engine for coordinating the interaction with the session managers. For each client request, the service engine determines which application needs to be invoked. Then, based upon that application, the service engine determines which, if any, associated session manager needs to be invoked to manage session (i.e. state) information for that application. The service engine invokes the session manager via the programming interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06944666&OS=06944666&RS=06944666
owner: Sun Microsystems, Inc.
number: 06944666
owner_city: Palo Alto
owner_country: US
publication_date: 20030918
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENT(S)"],"p":["This application is a divisional of U.S. application Ser. No. 09\/524,775, now U.S. Pat. No. 6,701,367, filed Mar. 14, 2000, which claims the benefit of priority to U.S. Provisional Application entitled \u201cWeb Server Architecture\u201d, Ser. No. 60\/156,305, filed Sep. 24, 1999, and U.S. Provisional Application entitled \u201cWeb Server Architecture\u201d, Ser. No. 60\/155,711, filed Sep. 24, 1999. The entire contents of these applications are hereby incorporated by reference.","This invention relates generally to computer systems, and more particularly to a mechanism for enabling a customized session manager to interact with a network server.","On the Internet or World Wide Web, information is generally communicated on a request-response basis. That is, a client (typically running a browser program) submits a service request to a server. The service request may simply ask for a static page (usually in HTML format), or it may request that a particular application or program be executed to generate a return page. In response to the service request, the server performs whatever tasks are necessary to service the request, and provides a return page to the client. This request-response sequence, referred to as a \u201croundtrip\u201d, is carried out for each request.","Generally, the Internet is a stateless environment. That is, each service request is treated as its own individual request, and there is no \u201cmemory\u201d of prior requests. Put another way, the server makes no association between a current request and a previous request, even if the requests are from the same client, and even if the requests have some common nexus. For simple applications in which every task that needs to be performed can be carried out in a single roundtrip, this statelessness is not a problem. However, for exchanges (such as transactions) that require multiple roundtrips, the lack of state presents a significant impediment.","An example of an application in which it is necessary to maintain state across multiple roundtrips is that of an \u201celectronic shopping cart\u201d application. More specifically, a user visits a merchant's website using a particular client machine. As the user peruses the website, he sees an item that he wishes to purchase, and puts that item into his \u201cshopping cart\u201d. As some point, the user invokes a link to another page of the website, and at that point, a request is sent to the server which requests the desired page and which also provides to the server all of the items currently in the shopping cart. The server responds to the request by storing information pertaining to the shopping cart items, and by providing the desired page to the client. Thereafter, the user peruses the new page and puts additional items into the shopping cart. In a subsequent request by the client, the additional items in the shopping are sent to the server. Since the subsequent request is from the same client, the server should associate the additional items with the previous items as being in the same shopping cart. To do this, though, the server needs to associate the subsequent request with the previous request, which in turn requires that the server maintain state information relating to the requests. However, as noted above, the Internet is generally a stateless environment. As a result, without further functionality on the part of the server, multiple roundtrip exchanges, such as those required by the electronic shopping cart application, cannot be implemented on the Internet.","To enable exchanges which require multiple roundtrips, some servers implement a session management functionality. Basically, this functionality maintains state information across multiple roundtrips so that associations between multiple requests can be made. Usually, state information is maintained by passing session ID information back and forth between the client and the server. For example, when a service on the server requiring state information is first invoked by a client request, a new session is created, and a new session ID is associated with the new session. The session acts as a \u201ccontainer\u201d that can be used to store all of the necessary state information relating to that particular session. Once the session is created (and possibly updated to include state information relating to processing of the current request), the associated session ID is provided to the client that requested the service. If that client makes a subsequent request to the same service, the client includes in that request the session ID. Using the session ID, the server accesses the associated session, and based upon the state information stored in the associated session, the server can determine what has transpired thus far. In this manner, the server is able to associate a current request with one or more previous requests.","Typically, the session management functionality of a server is an integral part of the server. This means that in order to make any changes to the session management functionality, it is necessary to change and to recompile the core server code. While this simplifies the overall architecture of the server, it can lead to significant drawbacks, such as inflexibility and non-scalability. Both of these limit the overall effectiveness of the server. As a result, there is a need for an improved session management architecture.","In light of the shortcomings of the prior art, the present invention provides an improved session management mechanism which enables customized session managers to interact with a network server. In accordance with the present invention, there is provided a programming interface which enables customized session managers to \u201cplug in\u201d to and to interact with the server. In one embodiment, the programming interface takes the form of an abstract class definition, and each customized session manager is a subclass of the abstract class. Each customized session manager can provide a customized method implementation for each method defined by the abstract class.","This programming interface makes it possible to change session management functionality without having to make any changes to the core server. More specifically, to change session management functionality, all that needs to be done is to alter the code for a particular session manager and to recompile that session manager. The server code does not need to be altered or recompiled. This significantly increases the flexibility of the server. In addition, the programming interface makes it possible to incorporate multiple session managers into the server. Each session manager can be assigned to a certain set of applications, and each session manager can manage sessions in its own customized fashion. The ability to incorporate multiple session managers into the server significantly increases the flexibility and scalability of the server.","In addition to the programming interface, the present invention further provides a service engine for coordinating the interaction with the session managers. More specifically, for each client request, the service engine determines which application needs to be invoked. Then, based upon that application, the service engine determines which, if any, associated session manager needs to be invoked to manager session (i.e. state) information for that application. The service engine invokes the session manager via the programming interface. With the programming interface and the service engine, the present invention provides a flexible and scalable mechanism for implementing session management functionality in a network server.","With reference to , there is shown a functional block diagram of a system  in which one embodiment of the present invention may be implemented, the system comprising a client , a network , and a server . For the sake of simplicity, only one client  is shown; however, it should be noted that multiple clients  may communicate with the server  via the network . For purposes of the present invention, the client  may be any mechanism capable of communicating with the server , including but not limited to a computer running a browser program. The client  may communicate with the server using any known protocol, including but not limited to HTTP and FTP. The network  may be any type of network, including but not limited to a local area network and a wide area network such as the Internet. The network  may even be as simple as a direct connection. Any mechanism capable of facilitating communication between the client  and the server  may serve as the network .","The server  is the component responsible for providing most of the functionality of the system . More specifically, the server  receives requests from the client  and responds to the requests by providing response pages. The response pages may be derived by simply accessing static files, or by executing one or more applications to dynamically generate the response pages. The term application is used broadly herein to refer to any type of program or routine (e.g. Java servlets) that is capable of performing one or more particular functions. What actions need to be carried out by the server  to derive the response pages is typically specified in the requests. Each request-response sequence is referred to as a roundtrip.","In one embodiment, the server  comprises a listener , a set of name translation functions , and a set of service subsystems . The primary function of the listener  is to receive a client request, parse the request into its various components (e.g. method, headers, universal resource identifier (URI), parameters, etc.), and store the various components into predefined structures. Once the request is parsed, it is ready for processing by the other components of the server .","In particular, the name translation functions  determine, based upon the URI of the request, which of the service subsystems  need to be invoked in response to the request. In one embodiment, there is a name translation function associated with each of the subsystems , ,  in the service subsystems . These name translation functions are executed in turn to determine which subsystem , ,  needs to be invoked to process the request. For example, the name translation function associated with the HTML engine  is invoked to determine whether the HTML engine  needs to be invoked to respond to the request. If not, then the name translation function associated with the service engine  is invoked to determine whether the service engine  needs to be invoked to respond to the request. This process of executing the name translation functions  continues until it is determined which of the service subsystems  needs to be invoked to process the request. Once the proper subsystem is determined, processing of the request continues with that subsystem.","As shown in , one of the service subsystems is the service engine . In one embodiment, the service engine  coordinates interaction between the applications  and the session managers  to manage session (i.e. state) information for exchanges that span multiple client requests. In carrying out its coordination function, the service engine  performs at least three major functions. First, it determines based upon the URI of the client request which application class  needs to be invoked to process the client request. Then, it invokes the proper application class  to give rise to an application instance . Thereafter, based upon the application class , the service engine  determines which session manager  to invoke to manager session information for that application class instance , and then invokes that session manager . Once that is done, the application instance  and the session manager  interact with each other to access and to update session information relating to a particular session.","To enable the service engine  to determine which application class  to invoke in response to a particular URI, each application class  is registered when it is incorporated into the server . In one embodiment, this registration takes the form of an entry in a configuration file. This entry comprises a reference to a particular application class , and a URI associated with that class . Given this information, the service engine  can determine, based upon the URI of the request, which application class  to invoke to service the request. In addition to this information, each entry may further comprise a context name and the name of the session manager  associated with that context. The context name allows multiple application classes  to be grouped together for purposes of session management so that the same session manager  can be invoked to manage session information for that group of application classes .","To enable the service engine  to invoke the one or more session managers , there is provided a session management application programming interface (API) . In one embodiment, the API  takes the form of an abstract class definition which sets forth a set of methods that need to be implemented by subclasses of that abstract class. Since the API  is an abstract class, it does not provide any actual implementations for the specified methods. It only specifies the methods themselves. It will be up to the subclasses of the abstract class to provide the actual method implementations.","The session manager classes  \u201cplug in\u201d to and interact with the server  by way of the API . More specifically, in one embodiment, the session manager classes  take the form of subclasses of the abstract class which is the API . Because each session manager class  is a subclass of the abstract class, each session manager class  provides an implementation for each method of the abstract class. These method implementations can be different for each session manager class . As a result, each session manager class  can be customized.","To enable the service engine  to determine which session manager class  to associate with which application class , each session manager class  is registered when it is incorporated into the server . In one embodiment, this registration takes the form of an entry in a configuration file. This entry comprises a reference to a particular session manager class , and either an associated context or a reference to an application class . Given this information, the service engine  can determine, based upon the application class , which session manager class  (and hence, which session manager ) to invoke to manage session information for instances of that application class . In one embodiment, each of the session manager classes  is instantiated upon system startup to give rise to the session manager instances . Since it is the instances  that are actually invoked by the service engine , this makes the server  ready for session management operation from the very outset.","With reference to , there is shown one possible embodiment for the session management API . As noted previous, the API  takes the form of an abstract class definition. This definition specifies the methods that need to be implemented by the session manager classes . These methods include: (1) Init; (2) CreateSession; (3) DeleteSession; (4) GetSession; (5) PutValue; (6) GetValue; (7) Update; and (8) Reaper.","The Init method is called upon initialization of a session manager  and is called only once. When invoked, the Init method prepares a session manager instance  for normal operation. The CreateSession method is invoked when a new session needs to be created. This typically occurs when a client invokes an application class  for the first time. The DeleteSession method is invoked to render an existing session invalid. This may occur at the end of a transaction or when a session \u201ctimes out\u201d. The GetSession method is invoked to access an existing session. This is used to continue an ongoing session. The PutValue method is invoked to write information into an existing session. This is usually invoked to write additional state information into an existing or new session. The GetValue method is invoked to retrieve state information from an existing session. This method makes it possible to ascertain what has transpired thus far in a particular session. The Update method is invoked when current processing of a session is completed. It gives the session manager  an opportunity to perform certain functions (such as making the session information persistent in a database) if it wishes. The Reaper method is invoked periodically by an external mechanism (such as a dedicated thread) to cause the session manager  to delete old or invalid sessions. This method causes the session manager  to perform \u201cclean up\u201d operations on outdated sessions.","In maintaining state information pertaining to sessions, the session managers  use session objects. A sample session object class definition  is shown in FIG. . Unlike the API , class definition  is an actual class definition, not an abstract class definition; thus, an implementation for each of the specified methods is provided with the object class . Two methods defined by the session object class  are the PutValue and the GetValue methods. The PutValue method is invoked to write additional information into a session, while the GetValue method is invoked to retrieve information from a session. In one embodiment, the implementations for these methods are straightforward: they invoke the corresponding methods on the appropriate session manager . That is, the PutValue method of the session object class  invokes the PutValue method of the session manager class , and the GetValue method of the session object class  invokes the GetValue method of the session manager class . Thus, it is the session manager  associated with a particular session object instance that actually writes and retrieves information pertaining to a session.","Another method of the session object class  is the GetAccessTime method. When invoked, this method returns the time of the last access of a particular session object. This method may be used by a session manager  to determine whether a particular session has \u201ctimed out\u201d. Yet another method of the session object class  is the IsValid method. This method is invoked to determine whether a session object is valid and may still be used.","The structure of the server  has been disclosed. With reference to the flow diagram of , the operation of the server  will now be described.  presents an overview of the interaction between the service engine , the application classes , and the session managers . Basically, the service engine  receives () a client request after the request has been parsed by the listener  and determined by the name translation functions  to be eligible for processing by the service engine . This client request may or may not include (as will be explained further below) a session ID. The session ID may be provided as part of the URI, or in the form of a \u201ccookie\u201d, or both. Based upon the URI, the service engine  determines () which of the application classes  to invoke to process the request. In one embodiment, this determination is made by consulting the configuration file previously described.","Once the service engine  determines the proper application class , it invokes () the application class  to give rise to an application instance . The application instance  then starts executing to process the client request. If the application instance  is of the type that processes exchanges involving multiple roundtrips, and hence, requires session information to be maintained, then one of the first acts of the application instance  is to request a session object from the service engine . If a session ID was included with the client request (thereby indicating that this client request relates to an already existing session object), then the service engine  uses the provided session ID to get the requested session object. If no session ID was included with the client request, then the service engine  generates a new session ID.","To get a session object for the application instance , the service engine  invokes one of the session managers . Before it does this, however, the service engine  first determines () which session manager  to invoke. In one embodiment, this determination is made based upon the application class . More specifically, using the configuration file described previously, the service engine  determines which session manager  is associated with the class of the application instance . Once the proper session manager  is determined, it is invoked () by the service engine . In one embodiment, the service engine  invokes the proper session manager  by way of the API .","In invoking a session manager , the service engine  calls one of two methods defined by the API  and implemented by the session manager . If the service engine  just generated a new session ID and, hence, needs a new session object to be created, then the service engine  calls the CreateSession method of the proper session manager . If the service engine  was provided a session ID with the client request, then the service engine  calls the GetSession method of the proper session manager  to get an already existing session object. With either call, the service engine  passes the session ID to the session manager .","In response to a CreateSession call, the proper session manager : (1) instantiates a new session object; (2) associates the session ID with the new session object; and (3) inserts into the new session object a pointer to itself (the proper session manager ). Once that is done, the session manager  provides a reference to the new session object to the service engine . In response to a GetSession call, the session manager : (1) determines which already existing session object is associated with the session ID; (2) determines whether that session object is still valid; and (3) if the session object is still valid, provides a reference to the session object to the service engine . In response to either call, an object reference is returned to the service engine  (unless the session object associated with the session ID is no longer valid).","Once the service engine  receives an object reference from the proper session manager , it passes the object reference on to the application instance . Thereafter, the application instance  interacts with the session object referenced by the object reference to access and to update session information relating to that session object. To add session information to the session object, the application instance  calls the PutValue method of the session object. To access session information from the session object, the application instance  calls the GetValue method of the session object. As noted previously, the PutValue and GetValue methods of the session object call the corresponding PutValue and GetValue methods of the proper session manager  (the session object knows which session manager  to call because it contains a pointer to the session manager  that created it, as discussed above). Thus, it is really the session manager  that accesses and updates the session information relating to a session object. Since each session manager  can provide a different implementation for the PutValue and GetValue methods, each session manager  can maintain session information differently. For example, one session manager  may write session information to a persistent storage whereas another may just store the session information in memory. These different implementations can be accommodated by the present invention.","This interaction between the application instance , the session object, and the session manager  may continue until the application instance  completes processing of the client request. At that point, the application instance  generates and provides a response page to the service engine . In turn, the service engine  provides () the response page, along with the session ID, to the client . The session ID may be provided to the client  either in the form of a \u201ccookie\u201d, as part of the URI, or both. This session ID is used by the client  in future related requests. In addition, the service engine  calls the update method of the proper session manager  to give the session manager  an opportunity to perform any final session management functions. With that done, processing of the client request is complete. Thereafter, the service engine  loops back to () to process another client request.","The process described above may be used to process different sets of related requests, with each set of requests involving a different application class  and a different session manager . For example, one set of requests may involve application class () and session manager (), while another set of requests may involve application class (n) and session manager (n). These and other uses are within the scope of the present invention.","At this point, it should be noted that the session management API  gives rise to several significant advantages. First, note that to change or to augment session manager functionality, all that needs to be done is to \u201cplug in\u201d and to register another session manager class . It is not necessary to change any of the core code of the server. Once registered, the new session manager class  can be invoked by the service engine . This ability to easily change session management functionality greatly increases the flexibility of the server . Also, note that the API  makes it possible to accommodate multiple session manager classes . Each class  can provide customized method implementations and functionality, and each class can be associated with different application classes . This ability to accommodate multiple session managers classes  significantly increases the flexibility and the scalability of the server . Hence, the present invention represents a significant improvement over the prior art.","Hardware Overview","In one embodiment, the present invention is implemented as a set of instructions executable by one or more processors. The invention may be implemented as part of an object oriented programming system, including but not limited to the Java\u2122 programming system manufactured by Sun Microsystems, Inc. of Mountain View, Calif.  shows a hardware block diagram of a computer system  in which an embodiment of the invention may be implemented. Computer system  includes a bus  or other communication mechanism for communicating information, and a processor  coupled with bus  for processing information. Computer system  also includes a main memory , such as a random access memory (RAM) or other dynamic storage device, coupled to bus  for storing information and instructions to be executed by processor . Main memory  may also be further used to store temporary variables or other intermediate information during execution of instructions by processor . Computer system  further includes a read only memory (ROM)  or other static storage device coupled to bus  for storing static information and instructions for processor . A storage device , such as a magnetic disk or optical disk, is provided and coupled to bus  for storing information and instructions.","Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","According to one embodiment, the functionality of the present invention is provided by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another computer-readable medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.","The term \u201ccomputer-readable medium\u201d as used herein refers to any medium that participates in providing instructions to processor  for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device . Volatile media includes dynamic memory, such as main memory . Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or electromagnetic waves, such as those generated during radio-wave, infra-red, and optical data communications.","Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.","Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer system , are exemplary forms of carrier waves transporting the information.","Computer system  can send messages and receive data, including program code, through the network(s), network link  and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface . The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution. In this manner, computer system  may obtain application code in the form of a carrier wave.","At this point, it should be noted that although the invention has been described with reference to a specific embodiment, it should not be construed to be so limited. Various modifications may be made by those of ordinary skill in the art with the benefit of this disclosure without departing from the spirit of the invention. Thus, the invention should not be limited by the specific embodiments used to illustrate it but only by the scope of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4","b":"1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
