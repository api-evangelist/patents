---
title: Stateless application notifications
abstract: Stateless application notifications are described that enable third parties to provide messages to client applications. A communication channel can be established between a notification service and an application. Upon request, the notification service can generate obfuscated routing data for the channel, which can be in the form of a channel handle or token. The routing data can be encrypted and digitally signed to obscure the content and format of the routing data from third parties. An application service possessing the obfuscated routing data can package a notification with the data and send the package to the notification service for delivery. The application service does so without knowing the channel particulars encoded by the obfuscated routing data. The notification service that produces the obfuscated routing data can decrypt and interpret the data, and deliver the notification on the channel to an appropriate endpoint application on behalf of the application service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09225538&OS=09225538&RS=09225538
owner: Microsoft Technology Licensing, LLC
number: 09225538
owner_city: Redmond
owner_country: US
publication_date: 20110901
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["In a client-server environment where a service provider implements a notification service on the server-side to deliver messages to clients, the service can be configured to process and deliver notification messages to clients on behalf of third parties. In some traditional approaches, the messaging can be based on client state data such as addresses, routing data, account data, authentication data and\/or other state data that is maintained persistently by a service provider on the server-side for numerous clients.","Maintaining such client state data for numerous clients, though, can be expensive because resources (e.g., memory and processing capacity) that could otherwise be enlisted by the service provider for other purposes are tied up for storage and management of the state data. Moreover, it is inefficient and wasteful to persistently store state data at the service provider for clients that may connect infrequently and\/or may connect one time and then never reconnect again. In addition, a centralized store can be a security risk as a target for hackers to obtain client data and notifications are dependent upon the reliability of a single centralized store.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Various embodiments provide stateless application notifications designed to enable third parties to provide notifications to client applications. In at least some embodiments, a notification service establishes a communication channel for a client application and generates obfuscated routing data that can be employed to direct notifications to the application on the channel. In some embodiments, the routing data can be configured as a channel handle that is derived as an abstraction of the channel pathway or address. The channel handle or other suitable routing data can also be encoded as a token that is encrypted and digitally signed, such that the content and format of the token is obscured from third parties and protected from tampering.","An application service possessing the obfuscated routing data in some form can package a notification with the data and send the package to the notification service for delivery. The application service can use the obfuscated routing data to direct notifications to the channel without understanding the obfuscated routing data or knowing the pathway\/address for the channel. The notification service that produces the obfuscated routing data can decrypt and interpret the obfuscated routing data, verify signatures contained within the data to prevent tampering, and deliver the notification on the channel to an appropriate endpoint application on behalf of the application service.","Overview","Stateless application notifications are described that enable third parties to provide messages to client applications. A communication channel can be established between a notification service and an application. Upon request, the notification service can generate obfuscated routing data for the channel, which can be in the form of a channel handle or token. The routing data can be encrypted and digitally signed to obscure the content and format of the routing data from third parties and prevent tampering. An application service possessing the obfuscated routing data can package a notification with the data and send the package to the notification service for delivery. The application service does so without knowing the channel particulars encoded by the obfuscated routing data. The notification service that produces the obfuscated routing data can decrypt and interpret the data, and deliver the notification on the channel to an appropriate endpoint application on behalf of the application service.","In the discussion that follows, a section titled \u201cOperating Environment\u201d is provided and describes one environment in which one or more embodiments can be employed. Following this, a section titled \u201cStateless Application Notification Examples\u201d describes example details of stateless application notifications in accordance with one or more embodiments. Next, a section titled \u201cExample Methods\u201d describes example techniques for stateless application notifications in accordance with one or more embodiments. Last, a section titled \u201cExample System\u201d describes example computing systems and devices that can be utilized to implement one or more embodiments.","Operating Environment",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 7"],"b":["100","100","102","104","106","108","110","102","102"]},"The computer-readable media can include, by way of example and not limitation, all forms of volatile and non-volatile memory and\/or storage media that are typically associated with a computing device. Such media can include ROM, RAM, flash memory, hard disk, removable media and the like. Computer-readable media can include both \u201ccomputer-readable storage media\u201d and \u201ccommunication media\u201d, examples of which can be found in the discussion of the example computing system of .","In addition, client  includes channel state data  that can be employed to facilitate stateless notifications as described above and below. The channel state data  relates to delivery pathways or \u201cchannels\u201d that can be established between a client  and a notification service to provide notifications for applications  of the client. The channel state data  can include identifiers, routing data, tokens, authorization data, and expiration data related to one or more channels, to name a few examples. Clients  can cache their own channel state data  to enable stateless processing on the server-side.","As further depicted in , the client  can be communicatively coupled over a network , such as the Internet, with one or more service providers  which provide various resources (e.g., content and services), as described above and below. By way of example, the client  can interact with the service provider  and exchange messages to create channels and employ the channels to obtain notifications.","The service providers  are each depicted as having one or more processors  and one or more computer-readable media . The service provider  is further depicted as including a resource manager . The resource manager  represents functionality operable by a service provider  to manage various resources  that may be made available over the network . For example, various resources  can be provided via web pages or other user interfaces that are communicated over the network for output by the client . The resource manager  can manage access to the resources , performance of the resources , configuration of user interfaces or data to provide the resources , and so on.","The service provider  can provide one or more web servers and\/or sites, which a client  can navigate to in order to access the resources . The resources  can include any suitable combination of services and\/or content typically made available over a network by one or more providers. Some examples of services include, but are not limited to, a search service, an email service to send and receive email, an instant messaging service to provide instant messages between clients , and a social networking service to facilitate connections and interactions between groups of users who share common interests and activities. Content may include various combinations of text, video, ads, audio, multi-media streams, animations, images, web pages, web applications, device applications, content for display by a browser or other device application, and the like.","In addition, the service provider  can include or otherwise make use of a notification service  that is representative of functionality operable to manage communication of notifications  between the client  and other entities. The notification service  can be operated alone and\/or in conjunction with other services to provide functionality for one or more different types of messaging. By way of example and not limitation, the multiple different types of messaging provided by the notification service can include email, text messages, application and\/or operating system notifications, in application content, social networking notices and invites, instant messaging, voice messages, peer-to-peer messaging, and so forth.","The notification service  is also operable to implement techniques for stateless application notifications described herein. In particular, the notification service  can be implemented to facilitate communication of notifications  to the client  on behalf of one or more application services . The notifications  can be configured as messages that are directed to applications  corresponding to the application services, such as promotions, application updates, alerts, in-app features, and so forth. The notification service  is responsible for routing and delivering the notifications  to clients . Channel state data  cached by a client  can be obtained on demand by the notification service  if necessary. However, the notification service  can perform \u201cstateless\u201d processing for channels and notifications on the server-side using obfuscated routing data that is provided with notification requests. The notification service  may temporarily store state information regarding clients when they are currently connected. The state data can include the currently-connected client's identifying information, information about what kinds\/types of notifications to allow or block, and so forth. When the client disconnects, though, temporary state data may be discarded by the Notification Service  and therefore the processing is considered \u201cstateless\u201d.","As discussed in greater detail below, notifications  can be delivered on a channel that is established between the client  and the service provider . Notifications can be sent over the channel by associating the notifications with obfuscated routing data, such as a channel handle or token that is provided through the notifications service . In one example approach to providing notifications via channels, the notification service  can employ tokens  configured to carry channel metadata . The channel metadata  can represent data used \u201cin process\u201d by the notification service  to process requests, establish channels, route notifications, and so forth. This can include various channel state data  that is obtained as needed from clients . The notification service , though, does not necessarily cache the channel metadata  on behalf of clients .","Various data related to channels can be included as part of channel metadata  including a channel ID, channel handles, and routing data. The channel ID uniquely identifies a channel and is maintained such that the channel ID is not exposed to third parties. The third parties, though, are able to employ channel handles generated for a channel and provided in a token or otherwise to direct messages through the notification service  to endpoints without interpreting the handle or knowing the corresponding channel ID. In particular, a channel handle can be derived as an abstraction of the channel ID to obscure the properties of the channel. Details regarding these and other aspects of channels, channel handles, and stateless application notifications are provided in relation to the following figures.","Having described an example operating environment, consider now a discussion of some stateless application notifications examples in accordance with one or more embodiments.","Stateless Application Notification Examples","This section describes example details regarding stateless application notifications in accordance with one or more embodiments. In the discussion that follows, first a sub-section titled \u201cChannels for Notification Delivery\u201d describes channels that can be established to facilitate application notifications. Next a sub-section titled \u201cStateless Tokens\u201d provides details regarding tokens that can be employed in some embodiments to carry routing data used for routing notifications to appropriate endpoints using the channels. Thereafter, example interactions between a service provider , a client , and an application service  to implement stateless application notifications are discussed in relation to example operational scenarios depicted in .","Channels for Notification Delivery","As introduced above, notifications can be delivered on a channel that is established between the client  and the service provider . Generally speaking, a channel is a representation of a delivery pathway (e.g., address) for notifications from an application service  to a particular endpoint. An endpoint as used herein corresponds to a unique combination of a particular user, device, and\/or application. In other words, a channel can be considered a communication pathway that is established for and associated with a particular application  installed on particular client  and used by a particular user of the client . The channels are a mechanism by which a globally unique address can be assigned to an endpoint application.","Each channel can have a corresponding channel identifier (ID). The channel ID is a persistent identifier uniquely identifying a delivery pathway to a corresponding endpoint. To secure a channel and prevent attackers from hijacking or misusing the channels, the channel ID can be kept obscured. In at least some embodiments, the channel ID is maintained securely by the client  and is not exposed to third parties. For instance, the channel IDs for one or more applications  can be configured as parameters\/objects that are internal to the operating system . The operating system  can make use of the channel ID in interactions with the notification service , but otherwise keeps the channel ID private.","Thus, to enable notifications on a channel, channel handles are created that can be issued to third parties in lieu of exposing and\/or using the channel ID itself. When notifications are activated for an application, such as upon installation or execution of the application, a channel can be established which can be used to update application specific content. In one approach, the application can request issuance of a channel handle through the operating system . For example, a request can be made through a local application programming interface (API). The operating system can in turn interact with the notification service  to cause the notification service  to issue a channel handle and return the channel handle to the application . The notification service  can also establish a new channel if a channel does not already exist. The application  can then distribute the channel handle to an application service  to enable corresponding notifications from the application service .","More particularly, a channel handle can be derived as an abstraction of the channel ID for distribution to applications and third parties. The channel handle can be constructed by the notification service  in response to a request from a client. The request from a client can be configured to contain a channel ID and other client state data  that is used by the notification service  to create a corresponding channel handle. The handle obfuscates the properties of the channel and can be encrypted to prevent modification of the handle. Digital signatures can also be used to prevent modification or tampering. The notification service  is responsible for creating the channel handle and also controls the format and content of the channel handle. Thus, the handle's format and content can be obscured from both the client  and\/or third party application service . In this manner, the channel handle can be configured such that the handle is interpretable by the notification service  and not interpretable by other parties.","Channel handles can be formatted in any suitable way. In general, the channel handle is configured to represent a pathway or address to an endpoint application. Thus, a channel handle can encode various routing data for a channel. By way of example and not limitation, the notification service  can create channel handles as uniform resource identifiers (URIs) that encode a combination of identifiers for a particular application, client device, and user of the client device. More generally, a channel handle can represent any combination of routing data that is sufficient to identify and route a notification to a corresponding endpoint. The handle can be created based on an underlying channel ID and therefore the notification service  is able to interpret the handles and deliver notifications sent using the handles on appropriate channels to corresponding endpoints.","Multiple channel handles can be issued for a particular channel ID. Thus, expired or compromised channel handles can be de-authorized without affecting the underlying channel ID. Channel handles can also be configured to have a limited lifetime by associating the channel handles with an expiration time. After the expiration time, the channel handle can no longer be used to deliver notifications. An application, though, can request issuance of a new channel handle on the same channel. Channel handles can also be renewed prior to expiration to provide uninterrupted delivery of notifications to a channel. When a channel handle is renewed, the notification service  provides a new handle that can be used as a replacement for the previous handle on the same channel. Multiple channel handles can be active for a channel at the same time. Further details regarding handle renewal are discussed in relation to the following example methods.","The channel itself can remain open indefinitely and many channel handles can be assigned to the channel over the lifetime of the channel. A channel can be explicitly closed, at which point any channel handles associated with the closed channel will no longer be usable for sending notifications. Data maintained by the client  controls such decommissioning of a channel. Decommissioning of a channel is a matter of removing the channel ID from the client  permanently, such that any use of a handle associated with that channel ID will be rejected by the client  since the channel ID no longer exists. A new channel ID would then be issued to represent a new channel established for a particular application . Accordingly, persistent channels can be established upon which multiple limited use channel handles can be issued to enable communications via the channels while protecting the channel from being attacked or otherwise compromised.","Stateless Tokens","As mentioned, the channel state data  cached by the client  can enable stateless delivery of notifications by the notification service  using the channels. Rather than storing state data on behalf of clients, the notification service  is able to \u201clook-up\u201d or otherwise be provided with channel state data  from the client  as needed. Therefore the service provider  can avoid costs associated with storing the state data. Thus, clients  can be configured to cache some or all of their own channel state data  and provide the data to the service provider  as needed. Data related to channels obtained from a client or otherwise is represented as channel metadata  in .","In operation, tokens  can be used to pass channel metadata  that is encrypted and digitally signed through the notification service . The tokens  can be considered stateless since the channel metadata  used to generate the tokens  can be \u201cin process\u201d data that is obtained by the notification service  from clients  as needed and may not actually be stored persistently by the service provider .","Tokens  can be configured in various ways. Generally, the token  includes routing data configured in a specific format that is interpretable by the notification service  and can be used to route notifications that use the tokens to corresponding endpoints. By way of example, a token  can be configured as BLOB (binary large object) that is packaged with select channel metadata  as a payload. A variety of other token configurations are also contemplated. A token  for example can be configured to include a URI or other suitable channel handle. Tokens  can also be configured to include security information such as versioning data, authentication data, expiration times, and\/or other security information used to control and verify the validity of tokens. The security information enables the use of different secret keys and\/or different formats for different token versions. Further, the token can be encrypted and\/or digitally signed to prevent tampering. In some embodiments, the notification service  alone is able to decrypt and interpret the token  and route notifications accordingly to an endpoint specified by channel metadata  (e.g., the channel handle or other routing data) contained in the token.","In some embodiments, channel metadata  encrypted within the token  can include routing data directly. The routing data enables the notification service  to statelessly process and route messages to endpoints using the self-contained information that is passed in a token . Routing data can include by way of example, version data, a channel handle, identifiers for a corresponding application , client , and\/or machine, a digital certificate, a public key used for encryption, and so forth. Because the notification service  issues the tokens, the notification service  is able to interpret messages sent using the tokens, decrypt tokens  to obtain channel metadata  (e.g., using a private key), verify routing data contained in the token, and route notifications to appropriate channels.","In some cases, notification routing can occur \u201cin process\u201d using a channel handle and\/or other suitable routing data that is contained within the token  itself. Additionally or alternatively, the notification service  can \u201clook-up\u201d an appropriate endpoint based on information contained in the token. For example, the notification service  can match a channel handle provided in a token to a channel ID and route the message to a corresponding endpoint. Thus, tokens  as just described provide one example mechanism by which a notification service  can statelessly deliver notifications to applications  on behalf of application services .","In the context of the forgoing discussion of channels and stateless tokens, consider now some example operational scenarios depicted in . In particular,  depicts a diagram  showing an example sequence of transactions to provide channel handles for stateless application notifications.  depicts a diagram  showing an example sequence of transactions involved in employing a channel handle to deliver a notification through a notification service .","Referring to the example of , an example scenario  illustrates acts involved in creation of channels and channel handles. At  an application  can initiate a channel request. For instance, the application can initiate the request when the application is installed or executed, when a user activates notification, or otherwise upon activation to obtain notifications. The request causes processing by a computing device  to provide an appropriate response having channel data that can be used by the application  to enable notifications. In some embodiments, the channel request and response can be processed through a local application programming interface (API) provided by the operating system .","In response to the request, at  the operating system  can look-up an existing channel ID for the application. If a channel exists, then the existing channel ID can be provided with the request. The operating system  can also decide based on a policy whether or not to request creation of a new channel handle or use an existing channel handle. If a channel does not already exist, a request can be made to create a new channel.","At , the operating system  packages application specific information and\/or the channel ID into a create channel message and sends the create channel message to the notification service . The application information can include routing data and\/or other channel state data  that can be used by the notification service  to create a channel handle and\/or issue a token  as discussed previously.","At , the notification service  can create the requested channel in response to the channel request if appropriate. Additionally or alternatively, the notification service  can create a new channel handle for the channel. In some embodiments, the notification service  forms a token  as discussed above to contain the channel handle and\/or routing data sufficient to direct notifications to the channel indicated by the channel ID in the request, or for a newly created channel. The token  can be encrypted and digitally signed by the notification service .","At , the notification service  returns channel data to the operating system  of the client . The channel data returned can include the channel handle, a token when tokens are employed, obfuscated routing data and\/or a new channel ID if appropriate. Because the returned channel data contains information to route notifications, the notification service  can discard the request and corresponding information without caching data on behalf of clients. Subsequent processing of a channel handle and\/or token can occur statelessly using channel data provided back in a notification message. Generally, this processing occurs \u201cin process\u201d using the provided channel data and without looking-up additional state data for a channel. However, the notification service  can look-up or request additional channel state data  from a client in some scenarios.","At , the operating system  caches the returned channel data. This can involve creating a mapping between channel IDs and application endpoints. As noted, the channel ID and the mapping can be kept private by the operating system . Accordingly, the operating system  can extract the channel ID and keep the channel ID and mapping secret. At , though, other channel data can be provided back to the application  to facilitate notifications. This can include providing a channel handle, a token having a handle, and\/or other channel data related to the channel back to the application .","To enable notifications on the channel, at  the application  provides appropriate channel data to a corresponding application service . Again this can include a channel handle, a token, and\/or other channel data that can be employed by the application service  to route messages back to the application. At , the application service can store the channel data for subsequent use to deliver notifications back to the application.","It should again be noted, that both the application , operating system , and application service  may be unaware of the format and content of the handle or token used for notifications. The application , operating system , and application service  may not be configured to interpret, decrypt, or otherwise process the handle or token. Rather, the application  and application service  are configured to understand that a given handle and\/or token can be used to deliver notifications to a corresponding endpoint through the notification service . In one approach, a notification is attached by the application service  as a payload to a handle\/token and communicated to the notification service  that performs processing to route and deliver the notification. Details regarding using a handle\/token to deliver notifications are discussed just below in relation to .","In particular,  depicts one example scenario  for employing a channel handle to deliver a notification through a notification service . The channel handle can be provided individually or be contained within a token . In either case the channel handle is protected by being encrypted and\/or signed digitally. In this example, the channel handle represents encoded routing data that can be interpreted by the notification service and used to deliver notifications to the correct endpoints. Such routing data can be contained within an encrypted and signed token as mentioned previously.","An application service  can produce a notification related to a particular application. The notification can be configured to provide an application update, in application content, a promotion or special offer, a warning, and so forth. The notification can be a global message that is directed to any endpoint having the particular application or a message targeted to one or more specific endpoints based on selection criteria such as device type, user criteria, platform, and so forth.","At , the application service looks-up a channel handle for a notification. For instance, the application service  can cache channel handles for one or more endpoints having the particular application (or selection criteria) and for which notifications are activated. Thus, the application service  can refer to the cached data to match the notification to appropriate channel handles.","At , the notification is sent to the notification service . The notification can be attached as a payload to the channel handle. In the case of delivery to multiple endpoints, the notification can be associated with multiple channel handles corresponding to the endpoints.","At , the notification service  processes the notification, which can include decrypting the channel handle and verifying the validity of the channel handle. For instance, the notification service  can decrypt the channel handle and\/or a token  containing the channel handle using a decryption key. This enables the notification service  to obtain encoded routing data sufficient to deliver the notification. The notification service  can also check to make sure the channel handle has not expired or been revoked and that the corresponding channel is still active.","Further, the notification service  can authenticate the application service  by requesting the application service  to sign-in with pre-determined credentials (e.g., a secret key, password\/ID, or other shared secret) before permitting notifications. The pre-determined credentials can be matched to credentials included within channel handles provided by the application service . A comparison is made and if the credentials do not match, the notification delivery may be rejected. In order to enable the credential comparison, the channel handles may be tied to a specific identity for authentication at the time the handles are created. This may be accomplished by the notification service  embedding credentials, provided from the client  by the operating system  or otherwise, into the handle at the time the handle is created.","Assuming the channel handle is valid, the notification service  interprets the channel handle to determine where to send the notifications. In particular, at  the notification service  determines a client endpoint and corresponding channel ID using the channel handle. For example, the channel handle can be processed by the notification service  to reconstruct the channel ID. In another approach, the channel handle can be used as a reference to look-up a corresponding channel ID. In the case of a token, routing data encoded within the token may be sufficient to directly route the notification after the token is decrypted and verified.","In any case, the notification service  identifies where to send the notification and at  communicates the notification to the client . For example, a communication referencing a channel ID can be directed to the operating system  of the client . At , the operating system  performs processing to ascertain an application  to which the notification is directed based on the channel ID. One way this can occur is through a local API of the operating system . When the appropriate application  is identified, the notification is delivered to the application  at . The application  can process the notification and perform any responsive actions dictated by the notification accordingly. For instance, the application  can present the notification for viewing within a user interface, perform or schedule an update, provide an alert and\/or visual indicator regarding the notification, store the notification, and so forth.","Having considered some examples of stateless application notifications, consider now example procedures for stateless application notifications in accordance with one or more embodiments.","Example Methods",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 4","FIG. 1"],"b":["114","124"]},"Step  obtains a request from a client for a token associated with a channel. For example, upon activation of an application to receive notifications, the application can send a channel request as described previously. The request can include client state data  that can be used to create a token for a particular application of a client . The notification service  can receive and process the request to create a channel and\/or obfuscated routing data that can be used to access an existing channel.","In particular, step  generates a token containing routing data for the client. The routing data can be in the form of a channel handle or other combination of client state data  that encodes the particulars of the channel. Effectively, the routing data encodes a delivery pathway or address for the channel that can be recovered later by the notification service  to route notifications . The routing data can be provided as part of a token produced by the notification service . The token can be created and employed statelessly using the client state data  provided in the request. The token can be configured to contain routing data sufficient to enable the notification service  to later determine a pathway or address for the channel \u201cin-process\u201d based on the token alone without looking-up data from a table, database, or external source. The token can also include an expiration time, security data, and other metadata.","Step  encrypts and signs the token. This protects the token and obfuscates the routing data from third parties. Step  returns the token to the client to enable the client to employ the channel for notifications. The token can be provided through the operating system  to an application , which can in turn distribute the token for use by an application service .","Step  obtains a notification for delivery to the client that uses the token. For instance, the notification service  can obtain a notification from an application service  that is packaged or otherwise associated with a token.","Step  decrypts the token to retrieve the routing data and verify the validity of the routing data. Because the notification service  issues the token and controls the security of the token, the notification service  is able to decrypt and interpret the token. The notification service  can also verify the validity of routing data by checking the expiration time, making sure that the channel is active, ensuring that notifications are enabled for the channel, and otherwise checking various security information.","An error handling process can be initiated if a problem with the routing data or token is discovered. An error message can be sent back to a sender of the notification and other corrective actions can be performed such as reissuing a token, sending an error notice to the client, locking a channel, de-authorizing the sender and so forth. Otherwise, when the routing data is valid, the notification service can process the decrypted routing data to reconstruct a channel ID or otherwise identify a channel described by the routing data. Then, step  delivers the notification to the client based on the routing data retrieved from the token.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 5","FIG. 1"],"b":["102","108"]},"Step  requests a channel handle for a channel from a notification service. A channel handle for a particular channel can be requested for an application at various times. This can occur when an application is initially installed, upon execution of the application, or when notifications are activated by a user or otherwise. The operating system  can process the application request through an API as discussed previously.","When an application calls the operating system  to obtain the channel handle, the operating system  can determine based on a policy whether to provide a previously cached handle (if available) or to request a new handle. A new handle can be requested for example when there is not an existing handle, when a cached handle has expired, when it is appropriate to obtain a new channel, and so forth.","A new handle can be requested to renew a handle before it expires. This can occur for example based on a policy that dictates timing for obtaining renewed handles (or tokens). For renewal, a handle is requested on a pre-existing channel. A new handle can be issued for the pre-existing channel. As mentioned multiple handles can be active for a channel at the same time. Thus, previously created handles for a channel can continued to be used after renewal so long as the handles have not expired, been revoked, or otherwise been deactivated. After renewal though, the application can distribute the newest handle for use with subsequent notifications.","It should be noted that renewal can also be initiated by an application service  to renew handles or tokens maintained by the application service  individually or as a group. This enables the application service  to periodically refresh routing data for channels to ensure continuity of notifications. The renewal occurs through the notification service  and the renewed data can be communicated back to the requesting application service . The notification service  can also provide the renewed handles or tokens to appropriate clients .","Step  obtains a response including a channel handle that obfuscates the channel. For example, notification service  can return the requested channel handle back to the client . The channel handle can incorporate obfuscated routing data that can be interpreted by the notification service . In addition, a channel ID can be included with the response. The client  can cache the returned data (e.g. handle, token, routing data, channel ID) for subsequent use.","Step  provides the channel handle to an application to enable activation of notifications from an application service. A cached channel handle or a newly created handle can be provided to an application upon request. The application can then communicate the channel handle to a corresponding application service  to activate notifications. An application service  that possesses the channel handle is able to direct notification to the corresponding channel through the notification service  without actually understanding the obfuscated routing data encoded by the channel handle as discussed above and below.","Step  receives notifications sent to the channel through the notification service using the channel handle. Notifications can be communicated to the client  from the notification service. The notifications can be received and processed by the operating system  and\/or a local API as discussed herein. In particular, the notification service  interprets and routes the notifications on behalf of the application service  using the channel handle. Clients  can therefore can receive various notifications through the notification service  on respective channels established for the clients . Notifications can be processed, stored, and\/or output at the client  in various way as described previously.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 6","FIG. 1"],"b":"128"},"Step  receives obfuscated routing data from a client to activate notifications to a corresponding application of the client. For instance, an application service  can obtain and store a channel handle, token, or other obfuscated routing data from an application . The obfuscated routing data enables the service to send notifications to the application  over a corresponding channel. The channel itself can be obscured from the application service  in the manner discussed herein.","Step  generates a notification for delivery to the application. Notifications can be configured as messages for delivery to a particular applications. The notifications can include program updates, in application content, promotions, alerts, links, rewards, achievement messages, and so forth.","Step  packages the notification with obfuscated routing data. In particular, the application service  can create a package that contains the notifications and is addressed to a channel by including the obfuscated routing data in the package. For example, an application update can be packaged with a channel URI, handle, token, or other routing data issued for a channel. The notification can be considered a payload that is attached to or otherwise associated with delivery instructions represented by the obfuscated routing data contained in the package.","Step  communicates the notification with the obfuscated routing data to cause a notification service to deliver the notification to the application as designated by the obfuscated routing data. Note again that the application service  can use the obfuscated routing data to direct messages to endpoints without necessarily knowing the details of the routing data or the actual address of the endpoint encoded therein. The package of a notification with obfuscated routing data is configured by the application service  to take advantage of the service provided by the notification service . The notification service  is responsible for decrypting the obfuscated routing data and delivering the notification accordingly. Thus, the application service  can simply make use of obfuscated routing data in various forms to direct notifications and turns processing over to the notification service  to identify the correct endpoints and route the notifications.","Having considered various example methods for stateless application notifications, consider now an example system that can be employed to implement various aspects of stateless application notifications in accordance with one or more embodiments.","Example System",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 7","b":["700","702","702","114","102","128"]},"The example computing device  includes one or more processors  or processing units, one or more computer-readable media  which may include one or more memory and\/or storage components , one or more input\/output (I\/O) interfaces  for input\/output (I\/O) devices, and a bus  that allows the various components and devices to communicate one to another. Computer-readable media  and\/or one or more I\/O devices may be included as part of, or alternatively may be coupled to, the computing device . The bus  represents one or more of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. The bus  may include wired and\/or wireless buses.","The one or more processors  are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example, processors may be comprised of semiconductor(s) and\/or transistors (e.g., electronic integrated circuits (ICs)). In such a context, processor-executable instructions may be electronically-executable instructions. The memory\/storage component  represents memory\/storage capacity associated with one or more computer-readable media. The memory\/storage component  may include volatile media (such as random access memory (RAM)) and\/or nonvolatile media (such as read only memory (ROM), Flash memory, optical disks, magnetic disks, and so forth). The memory\/storage component  may include fixed media (e.g., RAM, ROM, a fixed hard drive, etc.) as well as removable media (e.g., a Flash memory drive, a removable hard drive, an optical disk, and so forth).","Input\/output interface(s)  allow a user to enter commands and information to computing device , and also allow information to be presented to the user and\/or other components or devices using various input\/output devices. Examples of input devices include a keyboard, a touchscreen display, a cursor control device (e.g., a mouse), a microphone, a scanner, and so forth. Examples of output devices include a display device (e.g., a monitor or projector), speakers, a printer, a network card, and so forth.","Various techniques may be described herein in the general context of software, hardware (fixed logic circuitry), or program modules. Generally, such modules include routines, programs, objects, elements, components, data structures, and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer-readable media. The computer-readable media may include a variety of available medium or media that may be accessed by a computing device. By way of example, and not limitation, computer-readable media may include \u201ccomputer-readable storage media\u201d and \u201ccommunication media.\u201d","\u201cComputer-readable storage media\u201d may refer to media and\/or devices that enable persistent and\/or non-transitory storage of information in contrast to mere signal transmission, carrier waves, or signals per se. Thus, computer-readable storage media refers to non-signal bearing media. Computer-readable storage media also includes hardware elements having instructions, modules, and\/or fixed device logic implemented in a hardware form that may be employed in some embodiments to implement aspects of the described techniques.","The computer-readable storage media includes volatile and non-volatile, removable and non-removable media and\/or storage devices implemented in a method or technology suitable for storage of information such as computer readable instructions, data structures, program modules, logic elements\/circuits, or other data. Examples of computer-readable storage media may include, but are not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, hard disks, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, hardware elements (e.g., fixed logic) of an integrated circuit or chip, or other storage device, tangible media, or article of manufacture suitable to store the desired information and which may be accessed by a computer.","\u201cCommunication media\u201d may refer to a signal bearing medium that is configured to transmit instructions to the hardware of the computing device, such as via a network. Communication media typically may embody computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as carrier waves, data signals, or other transport mechanism. Communication media also include any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media.","Combinations of any of the above are also included within the scope of computer-readable media. Accordingly, software, hardware, or program modules, including the APIs, notification service , operating system , applications , and other program modules, may be implemented as one or more instructions and\/or logic embodied on some form of computer-readable media.","Accordingly, particular modules, functionality, components, and techniques described herein may be implemented in software, hardware, firmware and\/or combinations thereof. The computing device  may be configured to implement particular instructions and\/or functions corresponding to the software and\/or hardware modules implemented on computer-readable media. The instructions and\/or functions may be executable\/operable by one or more articles of manufacture (for example, one or more computing devices  and\/or processors ) to implement techniques for stateless application notifications, as well as other techniques. Such techniques include, but are not limited to, the example procedures described herein. Thus, computer-readable media may be configured to store or otherwise provide instructions that, when executed by one or more devices described herein, cause various techniques for stateless application notifications.","Stateless application notifications have been described by which obfuscated routing data in the form of a channel handle and\/or token can be employed to send notifications through a notification service. The routing data can be encrypted and digitally signed to obscure the content and format of the routing data from third parties. An application service possessing the obfuscated routing data can package a notification with the data and send the package to the notification service for delivery. The notification service is configured to decrypt and interpret the data, and deliver the notification to an appropriate endpoint on behalf of the application service.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like features.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
