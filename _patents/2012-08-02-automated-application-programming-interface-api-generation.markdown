---
title: Automated application programming interface (API) generation
abstract: Techniques are provided for automatically generating Application Programming Interfaces (APIs) in a computing device. In one example, a request for the addition of a first API to a software infrastructure of a computing device is received. An API coding table that includes one or more initial API parameters corresponding to the first API is generated and an API coding template stored in memory of the computing device is obtained. A compiler of the computing device generates functional codes for the first API based on the API coding template and the initial API parameters.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08516508&OS=08516508&RS=08516508
owner: Cisco Technology, Inc.
number: 08516508
owner_city: San Jose
owner_country: US
publication_date: 20120802
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DESCRIPTION OF EXAMPLE EMBODIMENTS","Overview","Example Embodiments"],"p":["The present disclosure relates generally to Application Program Interfaces (APIs).","A software component (application, program, etc.) of a computing device\/system will generally request other hardware\/software components to perform operations\/tasks on its behalf. To accomplish this, the requesting software component uses a set of standardized requests, collectively called an Application Programming Interface (API).","In general, an API is a mechanism that allows software components to communicate with one another. APIs may include specifications for routines, data structures, object classes, variables, etc., and may be defined in accordance with an international standard such as Portable Operating System Interface (POSIX) or may be specifically defined by a vendor. The term API may refer to a complete interface, a single function, a group of functions, etc.","Due to the widespread use of APIs, software development kits (SDKs) have been proposed and widely used. SDKs are, in essence, a set of software development tools that enables a programmer to create software for a specific platform (e.g., a software package, software framework, hardware platform, computer system, video game console, operating system, or similar platform). Typically, an SDK includes predefined APIs, programming tools, and supporting documentation.","Techniques are provided for automatically generating Application Programming Interfaces (APIs) in a computing device. In one example, a request for the addition of a first API to a software infrastructure of a computing device is received. An API coding table that includes one or more initial API parameters corresponding to the first API is generated and an API coding template stored in memory of the computing device is obtained. A compiler of the computing device generates functional codes for the first API based on the API coding template and the initial API parameters.","One of the traditional goals for developing a software development kit (SDK) is to provide a consistent Application Programming Interface (API) for communication (i.e., to enable other computing components to communicate with the software component). SDKs may be implemented on platforms that have hardware and software capabilities and, as such, the number of APIs defined for an SDK could increase after initial deployment. In certain examples, the number of APIs may be in the hundreds or even thousands as new features are introduced to a platform. This is problematic in traditional arrangements where a user (e.g., engineer or programmer) uses the SDK to generate new APIs that support the added functionality. Therefore, proposed herein is a scalable API infrastructure that is configured to support a large number of APIs and to facilitate automatic generation of new APIs with little or no user input, thereby providing a highly scalable software platform.","For ease of illustration, examples will be described herein with reference to use of the scalable API infrastructure in a system that includes an SDK. In these examples, applications communicate with one or more application specific integrated circuits (ASICs). It is to be appreciated that these examples are non-limiting and that the scalable API infrastructure described herein may be implemented in a number of different computing systems to support API-based software-to-software communication and may be used with an SDK.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":["10","15","10","20","1","20","25","1","25","30","35","40","42","1","42","45","1","45"],"i":["n","n","n"]},"Applications ()-() may comprise, for example, protocol applications (e.g., Open Shortest Path First (OSPF), IS-IS, etc.) or other applications such as access control list (ACL) applications or quality of service (QoS) applications. The hardware independent APIs ()-() are, in this example, SDK APIs that are used by applications ()-() to request programming of the hardware ASICs ()-(). More specifically, in this example an API () takes input parameters from application () and uses Inter-Process Communication (IPC) to pass these parameters to the user space device driver . These APIs ()-() are sometimes referred to herein as \u201cfront-end\u201d APIs or the \u201cfront-end\u201d of the communication process.","The user space device driver  receives the programming request parameters generated by application () from API () (via the IPC) and is configured to use the parameters for programming the hardware ASICs ()-(). That is, the user space device driver  is configured to invoke the API dispatcher  to dispatch (call) the programming request parameters to the corresponding API handler for the specific executed API ().","The API handlers ()-() reside in the hardware-control software layer . There is one API handler ()-() for each API ()-() (i.e., a one-one-correspondence between APIs and API handlers). The API handler () (corresponding to API ()) receives the programming request parameters and uses these parameters to program one or more of the hardware ASIC devices ()-(N) in accordance with the original request from the application (). The API dispatcher  and hardware-control software layer  are part of the \u201cback-end\u201d of the software-to-software communication process. In certain examples, the API handlers may be specific to an ASIC such that there could be multiple API handlers (i.e., one per ASIC) for the same front-end API. Because the ASICs may be designed to implement particular functions, the API handlers for each ASIC could also be different. In the SDK architecture, there are separate handlers among the ASICs.","The hardware-control software layer is a platform dependent layer that may, in this example, be a hardware abstraction layer (HAL). A HAL is implemented in software between the physical hardware ASICs ()-() of computer system  and the other software components. In general, the function of a HAL is to hide differences in hardware from the operating system kernel, so that most of the kernel-mode code does not need to be changed to run on systems with different hardware.","The foregoing describes the general operations of an API executed on the scalable API infrastructure . However, before APIs may be used, they are first generated for subsequent use. In this example, the scalable API infrastructure  uses a complier to automatically generate API program codes based on a stored coding template and predefined API parameters. In other words, one macro is initially defined and the compiler expands this macro to produce a functional API. Consistent naming conventions are used through the infrastructure to facilitate various operations, and a Type Length Value (TLV) is used to package API payloads to send parameters from API (front-end) to back-end API handlers. As a result, the scalable API infrastructure optimizes API dispatch time, provides precise API dispatching to appropriate API back-end handlers, and provides the ability to batch APIs (i.e., lump multiple APIs in one generic API call).",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 2","FIG. 3","FIG. 2","FIG. 3"],"b":["10","15","135","15"]},"Computing system  may be a server, computer (e.g., desktop, laptop, etc.), networking device (router, switch, firewall, etc.), or any other system in which software components communicate with other hardware or software components. Computing system  comprises ASIC devices ()-(N), processor , and memory . Memory  comprises applications ()-(N), user space device driver , hardware-control software layer , a compiler , and scalable API infrastructure . Scalable API infrastructure  includes one or more API coding tables  and one or more coding templates .","Memory  may comprise read only memory (ROM), random access memory (RAM), magnetic disk storage media devices, optical storage media devices, flash memory devices, electrical, optical, or other physical\/tangible memory storage devices. The processor  is, for example, a microprocessor or microcontroller that executes instructions for the applications ()-(), user space device driver , hardware control software layer , compiler , and scalable API infrastructure . Thus, in general, the memory  may comprise one or more tangible (non-transitory) computer readable storage media (e.g., a memory device) encoded with software comprising computer executable instructions and when the software is executed (by the processor ) it is operable to perform the operations described herein in connection with applications ()-(), user space device driver , hardware control software layer , compiler , and scalable API infrastructure .","The mechanism employed in the examples described herein is to utilize the compiler  to automatically generate (auto-generate) sections of functional API code when a new API is added. In order to have the compiler  auto-generate the sections of programming code, the scalable API infrastructure includes one or more pre-stored \u201ccode templates\u201d  that are used by the compiler . That is, the compiler  takes a code template  and compiles it with some user input API parameters in a manner that expands the template into a functional API. As such, the coding infrastructure provided herein allows for a growth in the number of supported APIs while minimizing coding errors. As used herein, automatically generating the functional code means that, after the initial API parameters are established, little or no further user coding occurs to generate the API codes.","In operation, the API parameters used in the scalable API infrastructure  include a Type-Length-Value (TLV). The \u201cType\u201d is unique to the API, the \u201cValue\u201d is the internal data structure used to carry API parameters from the API to the API's handler, and the \u201cLength\u201d is the bytes length of the \u201cValue.\u201d","As shown at  of , when a new API is to be created, an API coding table  is generated that corresponds to the new API. The API coding table  is generated to include a TLV for the new API as well as a unique keyword associated with the new API. The unique keyword may be an American Standard Code for Information Interchange (ASCII) string. As described below, these initial API parameters input into the API coding table  (i.e., TLV and unique keyword) form a macro that is subsequently expanded for different purposes by the complier .","In the example of , the new API relates to a virtual local area network (VLAN) and, as such, the coding table  is sometimes referred to below by the name \u201cTABLE_LIBSDK_VLAN.\u201d The coding table  may be generated based on information input by a user (i.e., a user defines the TLV and ASCII string) and\/or may be partially or fully automatically generated based on information from another software component or other computing system.","Next, at  of , the internal data structure (Value) used to communicate between the API and the API handler is defined. This internal data structure will include the unique ASCII string defined in the API coding table  (i.e., the ASCII string associated with the new API). In this example, the unique ASIC string is \u201cvlan_create\u201d and the internal data structure is \u201cstruct_libsdk_vlan_create_t\u201d for a VLAN API. These data structure form a payload to carry user input API parameters from the front-end to the back-end. These data structures include all the parameters provided by the caller and some additional fields. These structures are also defined when the APIs are defined and the caller is not aware of this data structure.","At , an API handler in the hardware-control software layer  is provided with an API name containing the unique ASCII string (\u201cvlan_create\u201d) in the format: \u201cint abc_vlan_create(struct_libsdk_vlan_create_t *v_p).\u201d","At , the API coding table  (TABLE_LIBSDK_VLAN) is used to define an enumeration (enum) for each TLV \u201cType.\u201d In this example, the enumeration definition has the format: \u201clibsdk_enum_t.\u201d The resulting enumeration code (later generated by the compiler ) is used for indexing into an array that provides API handler functions.","At , the API coding table  (TABLE_LIBSDK_VLAN) is used to create a first level API handler definition. In other words, a front-end API definition that (after compiling) takes the data, packages it, and passes it through the API to the back-end is created. In this example, the first level API handler definition has the format: \u201cint libasic_tlv_hdlr_vlan_create (void *p).\u201d It is to be noted that the \u201cdefinition\u201d will be generated by the compiler using the code template.","At , the API coding table  (TABLE_LIBSDK_VLAN) is used to create a second level API handler definition. That is, a back-end API handler definition is created that (after compiling) is used to dispatch the final API handler for each device to the hardware-control software layer , depending on the device(s) available on the hardware. As shown below, the unique ASCII string \u201cvlan_create\u201d is also used in this second level API handler definition, which has the format:","static_inline_int","asic_inline_vlan_create(struct_libsdk_vlan_create_t *v_p)","At , the final API handler definition for dispatch to the hardware control layer  is created. In the example of , the ASICs are identified as \u201cabc\u201d (for ASIC ()), and xyz (for ASIC ()), and the final API handler definitions are:","int abc_vlan_create(struct_libsdk_vlan_create_t *v_p); int xyz_vlan_create(struct_libsdk_vlan_create_t *v_p);","At , the compiler  auto-generates the functional API codes for the various definitions defined in , , , and .","As shown above, the TLV Type, internal data structure, API handlers, etc. are defined so as to follow a consistent naming convention and to utilize the unique ASCII string therein to assist in auto-generating functional codes by the compiler . To further illustrate this and other aspects, the example use of a new API to create a VLAN is described in further detail in conjunction with the generation of an API to destroy a VLAN. In this specific example, the keyword or ASCII string for the VLAN create API is \u201cvlan_create,\u201d while the keyword for the VLAN destroy API is \u201cvlan_destroy.\u201d","The TLV Type and ASCII string for the VLAN create and destroy APIs are defined in one or more coding tables  (\u201cTABLE_LIBSDK_VLAN\u201d). A macro (LIBSDK_TBL_ENTRY) to define the APIs (with a TLV Type and a unique ASCII) may have the format as shown below:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"#define TABLE_LIBSDK_VLAN","\\"]},{"entry":[{},{},"LIBSDK_TLV_ENTRY","\\"]},{"entry":[{},{},"(TLV_TYPE_LIBSDK_VLAN_CREATE, vlan_create) ",{}]},{"entry":[{},{},"LIBSDK_TLV_ENTRY",{}]},{"entry":[{},{},"(TLV_TYPE_LIBSDK_VLAN_DESTROY, vlan_destroy)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The internal data structure is defined with a substring of \u201cvlan_create\u201d and may have the format:","typedef struct struct_libsdk_vlan_create_s",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003int","dev_inst;","\/* IN : asic dev number, zero based","*\/"]},{"entry":["\u2003sdk_vlan_t","vlan;","\/* IN : VLAN to create","*\/"]},{"entry":["\u2003uint16","pad;","\/*\u2003: make structure 32-bit align","*\/"]},{"entry":["\u2003int","api_rv;","\/* OUT: API return codes","*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} PACKED struct_libsdk_vlan_create_t;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The ASCII be used in the API handler for an ASIC device, such as ASIC device (), is show below as:","int abc_vlan_create(struct_libsdk_vlan_create_t *v_p);","int abc_vlan_destroy(struct_libsdk_vlan_destroy_t *v_p);","As noted, an initial macro is defined to include the TLV Type and ASCII string (keyword). In the scalable API infrastructure, this macro may be redefined one or more times to behave in different manners, thereby facilitating the API generation and subsequent use. More specifically, the definition of TABLE_LIBSDK_VLAN is used and the behavior of the LIBSDK_TBL_ENTRY macro is changed. For example, the definition of the LIBSDK_TLV_ENTRY( ) macro may be redefined, as shown below, to create a list of enumerations:","typedef enum libsdk_enum_e","{","#undef LIBSDK_TLV_ENTRY","#define LIBSDK_TLV_ENTRY(tlv,handler) tlv,\n\n","} libsdk_enum_t;","When the compiler  compiles these definitions, it generates an enumeration array shown below:","typedef enum libsdk_enum_e","{\n\n","} libsdk_enum_t;","Another example of redefining macros is shown below where API handlers can be generated by using the same TABLE_LIBSDK_VLAN definition:",{"@attributes":{"id":"p-0056","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#undef LIBSDK_TLV_ENTRY"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define LIBSDK_TLV_ENTRY(tlv, handler)","\\"]},{"entry":[{},"int libasic_tlv_hdlr_ ##handler (void *p)","\\"]},{"entry":[{},"{ ","\\"]},{"entry":[{},"\u2003struct_libsdk_ ##handler## _t *v_p = ",{}]},{"entry":[{},"\u2003(struct_libsdk_ ##handler## _t *)p;\\",{}]},{"entry":[{},"\u2003v_p->api_rv = asic_inline_ ##handler(v_p);","\\"]},{"entry":[{},"\u2003return (v_p->api_rv);","\\"]},{"entry":[{},"}",{}]},{"entry":[{},"TABLE_LIBSDK_VLAN"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"When the compiler  compiles these functions, it generates two API handler functions:","int libasic_tlv_hdlr_vlan_create (void *p)","{\n\n","}","int libasic_tlv_hdlr_vlan_destroy (void *p)","{\n\n","}","Finally, the API may be dispatched to a specific handler for the ASIC devices (), (), or (), depending on the hardware platform on which the code is executed (i.e., the same set of APIs could have different implementations for each device on which it is running). The dispatch is shown as:",{"@attributes":{"id":"p-0065","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},"#undef LIBSDK_TLV_ENTRY"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"#define LIBSDK_TLV_ENTRY(tlv, handler)","\\"]},{"entry":[{},{},"static_inline_int","\\"]},{"entry":[{},{},"asic_inline_ #handler(struct_libsdk_ #handler##_t *v_p)","\\"]},{"entry":[{},{},"{","\\"]},{"entry":[{},{},"\u2003if (platform == abc)","\\"]},{"entry":[{},{},"\u2003\u2003return (abc_ ##handler(v_p));","\\"]},{"entry":[{},{},"\u2003else if (platform == xyz)","\\"]},{"entry":[{},{},"\u2003\u2003return (xyz_ ##handler(v_p));","\\"]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"TABLE_LIBSDK_VLAN"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"When the compiler  compiles these definitions, it generates the following:","static_inline_int","asic_inline_vlan_create(struct_libsdk_vlan_create_t *v_p)","{\n\n","}","static_inline_int","asic_inline_vlan_destroy(struct_libsdk_vlan_destroy_t *v_p)","{\n\n","}","With the infra structure above in place, now the actual correspondence handlers are realized through the following definitions (for ASICS () and ()):","int abc_vlan_create(struct_libsdk_vlan_create_t *v_p);","int abc_vlan_destroy(struct_libsdk_vlan_destroy_t *v_p);","int xyz_vlan_create(struct_libsdk_vlan_create_t *v_p);","int xyz_vlan_destroy(struct_libsdk_vlan_destroy_t *v_p);","An objective of the examples described herein is to provide a one time coding that allows for substantially automated addition of further APIs by simply defining the TLV Type and the unique ASCII string for each new API, such as, vlan_port_add or vlan_port_delete as shown below:",{"@attributes":{"id":"p-0081","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define TABLE_LIBSDK_VLAN",{},"\\"]},{"entry":["LIBSDK_TLV_ENTRY(TLV_TYPE_LIBSDK_VLAN_CREATE, vlan_create)",{},"\\"]},{"entry":["LIBSDK_TLV_ENTRY(TLV_TYPE_LIBSDK_VLAN_DESTROY, vlan_destroy)",{},"\\"]},{"entry":["LIBSDK_TLV_ENTRY(TLV_TYPE_LIBSDK_VLAN_PORT_ADD,vlan_port_add) ",{},"\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["LIBSDK_TLV_ENTRY(TLV_TYPE_LIBSDK_VLAN_PORT_DELETE,vlan_port_delete)",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct struct_libsdk_vlan_create_s"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003int","dev_inst;","\/* IN : asic dev number, zero based ","*\/"]},{"entry":["\u2003sdk_vlan_t","vlan;","\/* IN : VLAN to create","*\/"]},{"entry":["\u2003uintl6","pad;","\/*\u2003: make structure 32-bit align","*\/"]},{"entry":["\u2003int","api_rv;","\/* OUT: API return codes","*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} PACKED struct_libsdk_vlan_create_t;"},{"entry":"typedef struct struct_libsdk_vlan_destroy_s"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003int","dev_inst;","\/* IN : asic dev number, zero based ","*\/"]},{"entry":["\u2003sdk_vlan_t ","vlan;","\/* IN : VLAN to destroy","*\/"]},{"entry":["\u2003uint16","pad;","\/*\u2003: make structure 32-bit align","*\/"]},{"entry":["\u2003int","api_rv;","\/* OUT: API return codes","*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} PACKED struct_libsdk_vlan_destroy_t;"},{"entry":"typedef struct struct_libsdk_vlan_port_add_s"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003int","dev_inst;","\/* IN : 0-base asic instance number","*\/"]},{"entry":["\u2003sdk_vlan_t ","vlan;","\/* IN : VLAN ID","*\/"]},{"entry":["\u2003uint16","pad;","\/*\u2003: make structure 32-bit align","*\/"]},{"entry":["\u2003sdk_port_t ","front_port;","\/* IN : 1-base front port number","*\/"]},{"entry":["\u2003uint8","pad8[3];","\/*\u2003: make structure 32-bit align","*\/"]},{"entry":["\u2003int","api_flags;","\/* IN : used by SDK backend only","*\/"]},{"entry":["\u2003int","api_rv;","\/* OUT: API return codes","*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} PACKED struct_libsdk_vlan_port_add_t;"},{"entry":"typedef struct struct_libsdk_vlan_port_delete_s"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003int","dev_inst;","\/* IN : 0-base asic instance number","*\/"]},{"entry":["\u2003sdk_vlan_t ","vlan;","\/* IN : VLAN ID","*\/"]},{"entry":["\u2003uint16","pad;","\/*\u2003: make structure 32-bit align","*\/"]},{"entry":["\u2003sdk_port_t ","front_port;","\/* IN : 1-base front port number","*\/"]},{"entry":["\u2003uint8","pad8[3];","\/*\u2003: make structure 32-bit align","*\/"]},{"entry":["\u2003int","api_rv;","\/* OUT: API return codes","*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} PACKED struct_libsdk_vlan_port_delete_t;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In essence, the examples rely upon an infrastructure that allows the compiler  to automatically generate functional API codes with minimal user input.","Once a new API is written, an array may be defined to dispatch the API to the handler of that API. The dispatcher function also use the libsdk_enum_t defined earlier as index into this array. The array is generated from a different stored coding template  as shown below:","libasic_tlv_handler_t libasic_tlv_handlers [ ]=",{"@attributes":{"id":"p-0085","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"#undef LIBSDK_TLV_ENTRY"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define LIBSDK_TLV_ENTRY(tlv,handler)","\\"]},{"entry":[{},"\u2003{","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003.tlv_apiname","= #handler,","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003.tlv_type","= tlv,","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003.tlv_handler","= libasic_tlv_hdlr_ ##handler,","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003},"]},{"entry":[{},"\u2003TABLE_LIBSDK_VLAN"]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"When the compiler  compiles these definitions, it generates the following automatically:","libasic_tlv_handler_t libasic_tlv_handlers[ ]=",{"@attributes":{"id":"p-0088","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\u2003{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003.tlv_apiname ","= vlan_create,"]},{"entry":[{},"\u2003\u2003.tlv_type","= TLV_TYPE_LIBSDK_VLAN_CREATE,"]},{"entry":[{},"\u2003\u2003.tlv_handler ","= libasic_tlv_hdlr_vlan_create,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003},"]},{"entry":[{},"\u2003{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003.tlv_apiname ","= vlan_destroy,"]},{"entry":[{},"\u2003\u2003.tlv_type","= TLV_TYPE_LIBSDK_VLAN_DES TROY,"]},{"entry":[{},"\u2003\u2003.tlv_handler ","= libasic_tlv_hdlr_vlan_destroy,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003},"]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"From the enum libsdk_enum_t, it can be seen that TLV_TYPE_LIBSDK_VLAN_CREATE has a value of zero (0), and that TLV_TYPE_LIBSDK_VLAN_DESTROY has a value of one (1). These values can be used to index into libasic_tlv_handlers[ ] array to get the handler function for that API. Therefore, dispatching to the corresponding API handler is error free and fast.","In certain examples, once the first API coding template is created, then the subsequent templates are a modified copy of the first template that has the table at the end. This is shown in the following examples for VLAN and the L2 module:",{"@attributes":{"id":"p-0091","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* VLAN template *\/"},{"entry":"#undef LIBSDK_TLV_ENTRY"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["#define LIBSDK_TLV_ENTRY(tlv, handler)","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["int libasic_tlv_hdlr_ ##handler (void *p)","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["{","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct_libsdk_ ##handler## _t *v_p = "},{"entry":"(struct_libsdk_ ##handler## _t *)p; \\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["LIBASIC_BE_TRACE(\u201ccalled\u201d);","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["v_p->api_rv = asic_inline_ ##handler(v_p, tlv); ","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["LIBASIC_BE_TRACE(\u201cexit\u201d);","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["return (v_p->api_rv);","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"TABLE_LIBSDK_VLAN"},{"entry":"\/* L2 template *\/"},{"entry":"#undef LIBSDK_TLV_ENTRY"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["#define LIBSDK_TLV_ENTRY(tlv, handler)","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["int libasic_tlv_hdlr_ ##handler (void *p)","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["{","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct_libsdk_ ##handler## _t *v_p = "},{"entry":"(struct_libsdk_ ##handler##_t *)p; \\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["LIBASIC_BE_TRACE(\u201ccalled\u201d);","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["v_p->api_rv = asic_inline_ ##handler(v_p, tlv); ","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["LIBASIC_BE_TRACE(\u201cexit\u201d);","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["return (v_p->api_rv);","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"TABLE_LIBSDK_L2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As shown, the difference between these two templates is the tables (TABLE_LIBSDK_VLAN and TABLE_LIBSDK_L2).","An API used by an application to perform an operation may be referred to as a front-end API, and the handler for that API may be referred to as a back-end handler. For each front-end API, there is a corresponding TLV Value associated with it. Therefore, in the API function, that TLV is used as part of the payload passed to the back-end dispatcher. The back-end dispatcher extracts the TLV Value and uses it to index into the libasic_tlv_handlers[ ] to get the entry with the handler function in that API.","Described above is the infrastructure to help facilitate dispatching of an API to the correct API handler in the back-end. An example of a front-end API function to create a VLAN in the hardware (i.e., the API generated through the above infrastructure and which is called from the applications) is shown below:",{"@attributes":{"id":"p-0095","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* this is the front-end API to create a vlan in the hardware *\/"},{"entry":"int"},{"entry":"libsdk_vlan_create (int dev_inst, sdk_vlan_t vlan)"},{"entry":"{"},{"entry":"\u2003struct_libsdk_vlan_create_t vlan_create;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003libsdk_tlv_t ",{},"*libsdk_tlv_p;"]},{"entry":["\u2003uint32 ",{},"libsdk_tlv_sz;"]},{"entry":["\u2003char ",{},"data[sizeof(libsdk_tlv_t) + sizeof(tlv_t) +"]},{"entry":[{},{},"\u2003sizeof(struct_libsdk_vlan_create_t)];"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003int\u2003\u2003\u2003\u2003rc;"},{"entry":"\u2003libsdk_tlv_sz = sizeof(libsdk_tlv_t) + sizeof(tlv_t) +"},{"entry":"\u2003\u2003\u2003sizeof(struct_libsdk_vlan_create_t);"},{"entry":"\u2003libsdk_tiv_p = (libsdk_tlv_t *)data;"},{"entry":"\u2003\/* parameter checking *\/"},{"entry":"\u2003\/* packaging *\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003vlan_create.dev_inst ","= dev_inst;"]},{"entry":["\u2003vlan_create.vlan ","= vlan;"]},{"entry":["\u2003vlan_create.api_rv ","= LIBSDK_ERR_NONE;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\/* send to back-end *\/"},{"entry":"\u2003if ((rc = libsdk_tlv_fe_handler(libsdk_tlv_p, libsdk_tlv_sz ,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TLV_TYPE_LIBSDK_VLAN_CREATE,"]},{"entry":[{},"sizeof(struct_libsdk_vlan_create_t),"]},{"entry":[{},"(char *)&vlan_create\u2003)) !=LIBSDK_ERR_NONE)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003{"},{"entry":"\u2003\u2003return (rc);"},{"entry":"\u2003}"},{"entry":"\u2003return (vlan_create.api_rv);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0096","num":"0114"},"figref":"FIG. 4","b":["200","205","210","215","220"]},"In certain examples, two or more initial API parameters are used for generating the API coding table. These initial API parameters may comprise a unique ASCII string corresponding to the first API, and a TLV corresponding to the first API. Additionally, the initial API parameters may be entered by a user (i.e., the API coding table may be generated based on one or more user inputs identifying the one or more initial API parameters).","In certain examples, automatically generating the functional codes for the first API based on the API coding template and the initial API parameters comprises defining an internal data structure useable to communicate between the first API and an API handler in a back-end of the software infrastructure. Each API may have its own internal data structure and the name of the structure has the unique ASCII string embedded in it. This data structure contains front-end API parameters passed in by the caller. Some additional fields to be used by the SDK infra-structure and some fields could be defined to assist batching or other functions.","Automatically generating the functional codes for the first API may further include generating an enumeration definition for the TLV Type. This enumeration coding template is generated only once and more tables may be added, such as shown below.","typedef enum libsdk_enum_e",{"@attributes":{"id":"p-0100","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"#undef LIBSDK_TLV_ENTRY"]},{"entry":[{},"#define LIBSDK_TLV_ENTRY(tlv,handler)\u2003tlv,"]},{"entry":[{},"TABLE_LIBSDK_ALL"]},{"entry":[{},"LIBSDK_ENUM_MAX"]},{"entry":[{},"} libsdk_enum_t;"]},{"entry":[{},"Where TABLE_LIBSDK_ALL can look like below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#define TABLE_LIBSDK_ALL","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003TABLE_LIBSDK_VLAN","\\"]},{"entry":[{},"\u2003TABLE_LIBSDK_L2","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003TABLE_LIBSDK_L3"]},{"entry":[{},"\u2003Etc..."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Automatically generating the functional codes for the first API may further include receiving a front-end API handler definition, creating a back-end API handler definition, receiving a final API handler definition, and compiling the enumeration definition, the front-end API handler definition, the back-end API handler definition, and the final API handler definition with the compiler to generate functional codes for the first API. The front-end API handler definition may be manually coded. Similarly, the final API handler definition may also be manually coded based on the ASIC design. The back-end API handler definition is uses the template and is automatically created for all back-end handlers.","In summary of the above, an infrastructure is described that enables a method to substantially auto-generate programming codes from a coding template using a compiler. This helps eliminate coding errors and minimize coding from SDK software developers. That is, the infrastructure enables the compiler to expand the code template to obtain a desired function API. Throughout the infrastructure, the coding templates are used in conjunction with a unique ASCII string (e.g., \u201cvlan_create\u201d, \u201cvlan_destroy\u201d) that enables the auto-generation without user involvement. Additionally, to dispatch a generated API in the back-end, another coding template is used to generate an array of API handlers. Software operates on this array to invoke the handler by using TLV as index into this array.","Additionally, the use of the TLV data structure allows the batching of multiple TLVs into a single request payload send from applications to a user space device driver. This means that, through the described infrastructure, applications can bundle one or more APIs in one request and send the request to the user space device driver. The single message containing the batched APIs is decoded at the back-end. This batching mechanism keeps the amount of communication messages between the applications and the user space device driver at the minimum and thus reduces the overall CPU usage.","Described herein are techniques to efficiently dispatch large number of APIs to their handlers by providing an infra-structure to utilize the compiler to auto-generate codes in order to scale to unlimited number (hundred or thousand or more) of APIs as required in a HAL or SDK software development. It is to be appreciated that the described techniques are not limited to HAL or SDK development only, but rather may be used in any software-to-software implementation.","The above description is intended by way of example only."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
