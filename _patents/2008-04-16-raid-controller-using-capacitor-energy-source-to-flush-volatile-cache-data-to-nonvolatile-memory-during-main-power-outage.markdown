---
title: RAID controller using capacitor energy source to flush volatile cache data to non-volatile memory during main power outage
abstract: A write-caching RAID controller includes a CPU that manages transfers of posted-write data from host computers to a volatile memory and transfers of the posted-write data from the volatile memory to a redundant array of storage devices when a main power source is supplying power to the RAID controller. A memory controller transfers the posted-write data received from the host computers to the volatile memory and transfers the posted-write data from the volatile memory for transfer to the redundant array of storage devices as managed by the CPU. The memory controller flushes the posted-write data from the volatile memory to the non-volatile memory when main power fails, during which time capacitors provide power to the memory controller, volatile memory, and non-volatile memory, but not to the CPU, in order to reduce the energy storage requirements of the capacitors. During main power provision, the CPU programs the memory controller with information needed to perform the flush operation, such as the location and size of the posted-write data in the volatile memory and various flush operation characteristics.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07809886&OS=07809886&RS=07809886
owner: Dot Hill Systems Corporation
number: 07809886
owner_city: Longmont
owner_country: US
publication_date: 20080416
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION(S)","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation of pending U.S. Non-Provisional application Ser. No. 11\/226,825 filed Sep. 14, 2005, which a continuation-in-part of pending U.S. Non-Provisional application Ser. No. 11\/054,203 filed Feb. 9, 2005, which claims the benefit of expired U.S. Provisional Application Ser. No. 60\/581,556 filed Jun. 21, 2004, all of which are hereby incorporated by reference for all purposes.","Application Ser. No. 11\/226,825 claims the benefit of the following expired U.S. Provisional Applications, which are hereby incorporated by reference for all purposes.",{"@attributes":{"id":"p-0004","num":"0003"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Ser. No.","Filing",{}]},{"entry":["(Docket No.)","Date","Title"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["60\/691,853","Jun. 17, 2005","DATA BACKUP METHOD TO"]},{"entry":["(CHAP.0127)",{},"NON-VOLATILE MEMORY USING"]},{"entry":[{},{},"CAPACITOR ENERGY"]},{"entry":[{},{},"STORAGE"]},{"entry":["60\/705,997","Aug. 4, 2005","SUPER CAPACITOR-POWERED"]},{"entry":["(CHAP.0131)",{},"RAID CONTROLLER"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The present invention relates in general to the field of write-caching RAID controllers, and particularly to the preserving of write-cached data during the loss of main power.","Redundant Array of Inexpensive Disk (RAID) systems have become the predominant form of mass storage systems in most computer systems today that are used in applications that require high performance, large amounts of storage, and\/or high data availability, such as transaction processing, banking, medical applications, database servers, internet servers, mail servers, scientific computing, and a host of other applications. A RAID controller controls a group of multiple physical disk drives in such a manner as to present a single logical disk drive (or multiple logical disk drives) to a computer operating system. RAID controllers employ the techniques of data striping and data redundancy to increase performance and data availability.","An important characteristic of RAID controllers, particularly in certain applications such as transaction processing or real-time data capture of large data streams, is to provide fast write performance. In particular, the overall performance of the computer system may be greatly improved if the write latency of the RAID controller is relatively small. The write latency is the time the RAID controller takes to complete a write request from the computer system.","Many RAID controllers include a relatively large cache memory for caching user data from the disk drives. Caching the data enables the RAID controller to quickly return data to the computer system if the requested data is in the cache memory since the RAID controller does not have to perform the lengthy operation of reading the data from the disk drives. The cache memory may also be employed to reduce write request latency by enabling what is commonly referred to as posted-write operations. In a posted-write operation, the RAID controller reads the data specified by the computer system from the computer system into the RAID controller's cache memory and then immediately notifies the computer system that the write request is complete, even though the RAID controller has not yet written the data to the disk drives. Posted-writes are particularly useful in RAID controllers, since in some redundant RAID levels a read-modify-write operation to the disk drives must be performed in order to accomplish the system write request. That is, not only must the specified system data be written to the disk drives, but some of the disk drives may also have to be read before the user data and redundant data can be written to the disks, which, without the benefit of posted-writes, may make the write latency of a RAID controller even longer than a non-RAID controller.","However, posted-write operations make the system vulnerable to data loss in the event of a power failure. This is because the cache memory is a volatile memory that loses the user data when power is lost and the data has not yet been written to the disk drives.","To solve this problem, some RAID controllers include a battery to continue to provide power to the cache memory in the event of a loss of main power. Although the battery greatly reduces the likelihood that user data will be lost, because the energy stored in the battery is finite, the possibility still exists that the battery energy will run out before main power can be restored, in which case the user data will be lost. The minimum length of time the battery must supply power to the cache memory varies among users of RAID systems; however, many consumers require at least 72 hours in the event a power failure occurs on a weekend.","However, there are some well-known limitations associated with the use of batteries in this application. First, batteries are a relatively expensive component of the RAID controller. Second, for many of the relevant battery technologies the ability of the battery to hold a charge begins to degrade within two or three years, which is typically less than the expected lifetime of the RAID controller. Consequently, the RAID controller must be designed with the battery as a field-replaceable unit, and in many cases, as a hot-pluggable field-replaceable unit. This adds further cost to the RAID controller. Third, the operating temperature range of batteries outside of which their lifetime and performance degrade is relatively small. Fourth, after the battery has been drained due to a main power outage, the RAID controller must operate in lower performance write-through cache mode until the battery is re-charged, and the re-charge time of batteries is relatively long. Fifth, as the size of cache memories increases, so does the amount of energy the battery must provide during the main power outage. Given contemporary battery energy densities, the size of the battery required to provide the required amount of energy may exceed the available space within the RAID controller.","Therefore, what is needed is a RAID controller that employs an alternative solution for maintaining volatile posted-write data during a main power outage.","The present invention provides a RAID controller that uses capacitors rather than batteries to supply power in the event of a loss of main power. The RAID controller also includes a non-volatile memory, such as a FLASH memory, to which posted-write data can be flushed from cache memory when main power is lost. The RAID controller also includes a memory controller that is capable of performing the flush operation of the posted-write data. This reduces the amount of energy storage capacity requirement of the capacitors for at least two reasons: first, the capacitors do not have to supply power to the CPU of the RAID controller, since the CPU does not perform the flush operation; second, the memory controller performs the flush operation faster than the CPU would.","In one aspect, the present invention provides a write-caching redundant array of inexpensive disks (RAID) controller connected to host computers and to a redundant array of storage devices, including a volatile memory, a non-volatile memory, and a central processing unit (CPU). The CPU manages transfers of posted-write data received from the host computers to the volatile memory and transfers of the posted-write data from the volatile memory to the redundant array of storage devices when a main power source is supplying power to the RAID controller. The RAID controller also includes a memory controller, coupled to the volatile memory and the non-volatile memory. The memory controller transfers the posted-write data received from the host computers to the volatile memory and transfers the posted-write data from the volatile memory for transfer to the redundant array of storage devices as managed by the CPU. The memory controller, rather than the CPU, flushes the posted-write data from the volatile memory to the non-volatile memory when the main power source fails to supply power to the RAID controller. The RAID controller also includes at least one capacitor, coupled to provide power to the memory controller, the volatile memory, and the non-volatile memory when the main power supply fails to supply power to the RAID controller. The CPU is excluded from receiving power from the at least one capacitor when the main power supply fails to supply power to the RAID controller.","In another aspect, the present invention provides a method for preserving posted-write data in a write-caching redundant array of inexpensive disks (RAID) controller connected to host computers and to a redundant array of storage devices. The method includes supplying power, by at least one capacitor, to a volatile memory, a non-volatile memory, and a memory controller of the RAID controller, in response to a loss of main power to the RAID controller. The method also includes foregoing supplying power, by the at least one capacitor, to a central processing unit (CPU) of the RAID controller, in response to the loss of main power to the RAID controller. The CPU manages transfers of the posted-write data received from the host computers to the volatile memory and transfers of the posted-write data from the volatile memory to the redundant array of storage devices when main power is being supplied to the RAID controller prior to the loss thereof. The memory controller transfers the posted-write data received from the host computers to the volatile memory and transfers the posted-write data from the volatile memory for transfer to the redundant array of storage devices as managed by the CPU. The method also includes flushing posted-write data, by the memory controller rather than by the CPU, from the volatile memory to the non-volatile memory, in response to the loss of main power.","In another aspect, the present invention provides a write-caching redundant array of inexpensive disks (RAID) controller connected to host computers and to a redundant array of storage devices. The RAID controller includes a volatile memory, a non-volatile memory, and a central processing unit (CPU). The CPU manages transfers of posted-write data received from the host computers to the volatile memory and transfers of the posted-write data from the volatile memory to the redundant array of storage devices when a main power source is supplying power to the RAID controller. The RAID controller also includes a memory controller, coupled to the volatile memory and the non-volatile memory. The memory controller transfers the posted-write data received from the host computers to the volatile memory and transfers the posted-write data from the volatile memory for transfer to the redundant array of storage devices as managed by the CPU. The memory controller, rather than the CPU, flushes the posted-write data from the volatile memory to the non-volatile memory when the main power source fails to supply power to the RAID controller. The RAID controller also includes at least one battery, coupled to provide power to the memory controller, the volatile memory, and the non-volatile memory when the main power supply fails to supply power to the RAID controller. The CPU is excluded from receiving power from the at least one battery when the main power supply fails to supply power to the RAID controller.","An advantage of the embodiments employing the capacitors as a re-chargeable energy source is that capacitors are typically less expensive than comparable energy density batteries. Another advantage is that when main power is restored, the capacitors may be recharged much more quickly than batteries (typically on the order of minutes, in contrast to hours for batteries of comparable energy storage capacity); consequently, when main power is restored the capacitor-based RAID controller need not operate in write-through mode as long as a RAID controller that employs a battery. Another advantage is that the lifetime of capacitors is typically longer than batteries such that, unlike batteries, the capacitors may not need to be a field-replaceable unit. For example, some capacitors have approximately twice the lifetime of batteries. Furthermore, some capacitors tolerate a wider range of environmental conditions than batteries. For example, current Lithium-ion battery technologies are limited to an operating temperature range of approximately 45-60 degrees Celsius, whereas some capacitors can operate at up to 85 degrees Celsius.","An advantage of the embodiments employing the non-powered-CPU flush operation of cached data from the cache memory to non-volatile memory by the memory controller is that they require less energy consumption than a CPU-assisted flush operation. Consequently, the capacitors, battery, or other re-chargeable energy source employed on the RAID controller may be smaller, both in terms of volume and energy capacity, than required by a RAID controller that employs a relatively large power consuming CPU to perform the flush. Additionally, the memory controller is capable of performing the flush operation in a shorter amount of time than the CPU, which also reduces the energy capacity requirement of the re-chargeable energy source. Finally, the memory controller performing the flush operation greatly reduces the complexity of the software executing on the CPU since the software no longer must handle the non-graceful transition from normal processing during main power operation to a flush mode of operation in the event of a loss of main power.","Referring now to , a block diagram illustrating a RAID controller  according to the present invention is shown. In one embodiment, the RAID controller  may be one of a pair of active-active redundant fault-tolerant RAID controllers for providing high data availability. In the event of a failure of one RAID controller , such as the failure to flush posted-write data from volatile memory to non-volatile memory as described herein, the system may failover to the other RAID controller . Advantageously, the RAID controller  includes one or more capacitors for supplying power to selected portions of the RAID controller  circuits during the loss of main power for enabling a memory controller thereof to quickly and efficiently flush the posted-write data from a cache memory to a non-volatile memory without assistance from a CPU subsystem of the RAID controller , which is not powered by the capacitors, as described in detail herein.","The RAID controller  includes a host interface  for interfacing with host computers. In one embodiment, the RAID controller  is a local bus-based controller, such as a controller that plugs into, or is integrated into, a local I\/O bus of the host computer system, such as a PCI, PCI-X, CompactPCI, PCI-Express, PCI-X2, EISA, VESA, VME, RapidIO, AGP, ISA, 3GIO, HyperTransport, Futurebus, MultiBus, or any other local bus. In this type of embodiment, the host interface  comprises a local bus interface of the local bus type. In another embodiment, the RAID controller  is a standalone controller in a separate enclosure from the host computers that issue I\/O requests to the RAID controller . For example, the RAID controller  may be part of a storage area network (SAN). In this type of embodiment, the host interface  may comprise various interfaces such as Fibre Channel, Ethernet, InfiniBand, SCSI, HIPPI, Token Ring, Arcnet, FDDI, LocalTalk, ESCON, FICON, ATM, SAS, SATA, iSCSI, and the like.","The RAID controller  also includes a disk interface  for interfacing to disk drives or other mass storage devices, including but not limited to, tape drives, solid-state disks (SSD), and optical storage devices, such as CDROM or DVD drives. The disk drives store user data. The disk interface  may include, but is not limited to, the following interfaces: Fibre Channel, Small Computer Systems Interface (SCSI), Advanced Technology Attachment (ATA), Serial Attached SCSI (SAS), Serial Advanced Technology Attachment (SATA), Ethernet, Infiniband, HIPPI, ESCON, iSCSI, or FICON. The RAID controller  reads and writes data from or to the disk drives in response to I\/O requests received from host computers.","The RAID controller  also includes a volatile cache memory , or cache memory , or volatile memory . The volatile cache memory  is volatile because it ceases to store its data when it is not powered. In one embodiment, the volatile cache memory  comprises double-data-rate synchronous dynamic random access memory (DDR SDRAM), which includes a self-refresh mode. When the SDRAM is placed into self-refresh mode, the SDRAM consumes less power than when not operating in self-refresh mode. In other embodiments, the volatile cache memory  may include other types of volatile memory, including but not limited to static random access memory (SRAM). The amount of volatile cache memory  may be significant. Embodiments in which the volatile cache memory  comprises 512 MB, 1 GB, and 2 GB are contemplated; however, other embodiments are contemplated in which more or less volatile cache memory  is included on the RAID controller .","The volatile cache memory  is employed by the RAID controller  to buffer data transferred between the hosts and disks. When a host requests data to be written to the disks, the RAID controller  transfers the data from the host via the host interface  into the volatile cache memory  and subsequently transfers the data from the volatile cache memory  via the disk interface  to the disks. Conversely, when a host requests data to be read from the disks, the RAID controller  transfers the data from the disks via the disk interface  to the volatile cache memory  and subsequently transfers the data from the volatile cache memory  via the host interface  to the host.","As mentioned above, when a host requests data be written to the disks, the RAID controller  transfers the data from the host via the host interface  into the volatile cache memory  and subsequently transfers the data from the volatile cache memory  via the disk interface  to the disks. Normally, the RAID controller  does not indicate to the host that the write request is complete until the data is actually written to disk. However, if configured to do so, the RAID controller  may cache the data in the volatile cache memory  and indicate to the host that the write request is complete before the data is actually written to the disk, and then subsequently write, or flush, the data to disk. This operation is referred to as write-caching, or may also be referred to as a posted-write operation. The data associated with a posted-write operation is referred to as posted-write data, or write-cache data. That is, posted-write data is data stored in the volatile cache memory  that has not yet been written to disk but concerning which the RAID controller  has told the host that the write operation has completed. Additionally, the posted-write data as referred to herein may comprise metadata, which is used to refer to control information required to write the data to disk, including but not limited to, the logical block addresses and disk drive unit numbers to which the data must be written, and information specifying whether the data is part of a RAID array with a RAID level requiring redundant data to be generated based on the posted-write data that also must be written to disk.","The volatile cache memory  may also be used by the RAID controller  to perform read-caching of data, i.e., to provide requested data to the hosts from the volatile cache memory , rather than from the disks, if the requested data is already present in the volatile cache memory  because of a previous read request of the same data. Finally, the RAID controller  may use the volatile cache memory  for buffering redundant RAID data generated for writing to the disks.","The RAID controller  also includes a CPU subsystem  for fetching and executing program instructions to control the transfer of data between the disk drives and the hosts, such as described above. The CPU subsystem  may include any processor capable of executing stored programs, including but not limited to, for example, a processor and chipset, such as an x86 architecture processor and what are commonly referred to as a North Bridge or Memory Control Hub (MCH) and a South Bridge or I\/O Control Hub (ICH), which includes I\/O bus interfaces, such as an interface to an ISA bus or a PCI-family bus. In one embodiment, the CPU subsystem  comprises a Transmeta TM8800 processor that includes an integrated North Bridge and an ALi M1563S South Bridge. In another embodiment, the CPU subsystem  comprises an Intel Celeron M processor and an MCH and ICH. In one embodiment, the CPU subsystem  also includes RAM for storing program instructions that are fetched and executed by the microprocessor and a FLASH memory , coupled to the CPU subsystem , for storing the program instructions in a non-volatile manner and which is decompressed and written to the program RAM for execution by the microprocessor. In one embodiment, the FLASH memory  also stores information, such as a signature, for comparing with a signature written to a non-volatile memory  (described below) to indicate a successful flush of the cache memory  to the non-volatile memory , as described below.","The CPU subsystem  receives host computer I\/O requests from the host interface  and processes the requests. Processing the requests may include various functions. For example, the host I\/O request specifies a logical block number and number of blocks of data to be transferred to or from the redundant array; however, these logical blocks and number of blocks do not typically correspond to the appropriate physical block numbers and number of blocks on the physical disks comprising the redundant array. Therefore, the logical block number specified in the host I\/O request must be translated into the appropriate physical block number, number of blocks, and disk to be used in performing one or more data transfers between the RAID controller  and the disks comprising the redundant array. This translation function is performed by the CPU subsystem . In one embodiment, the CPU subsystem  performs the translation according to well-known RAID techniques. After performing the translation, the CPU subsystem  programs the disk interface  to perform the data transfers between the disks and the volatile cache memory . Additionally, the CPU subsystem  programs the host interface  to perform data transfers between the host computers and the volatile cache memory . Thus, when processing a host I\/O request to write data from a host computer to a redundant array, the CPU subsystem  programs the host interface  to transfer data from the host computer to the volatile cache memory ; after the data is received into the volatile cache memory , the CPU subsystem  programs the disk interface  to transfer the data from the volatile cache memory  to the translated appropriate physical block numbers of the disks comprising the redundant array. Conversely, when processing a host I\/O request to read data from a redundant array to a host computer, the CPU subsystem  programs the disk interface  to transfer the data to the volatile cache memory  from the translated appropriate physical block numbers of the disks comprising the redundant array; after the data is received into the volatile cache memory , the CPU subsystem  programs the host interface  to transfer the data to the host computer from the volatile cache memory . The CPU subsystem  also performs the function of managing allocation of portions of the volatile cache memory  for performing the data transfers, and in particular of cache management, i.e., managing the volatile cache memory  as a cache memory for caching portions of the data buffered in volatile cache memory  in order to improve I\/O performance between the redundant arrays and the host computers according to well-known caching techniques. In one embodiment, the CPU subsystem  performs exclusive-OR operations of the data required in certain RAID levels that employ parity data as the redundant data, such as RAID level 5, for example. In one embodiment, the CPU subsystem  programs a dedicated exclusive-OR circuit comprised within the memory controller  to perform the exclusive-OR operation on the user data to generate the redundant parity data.","The RAID controller  also includes a non-volatile memory . The non-volatile memory  is non-volatile because it continues to store its data when it is not powered. In one embodiment, the non-volatile memory  comprises a Compact FLASH memory device comprising NAND Flash devices and a controller that presents an ATA interface to a memory controller  (which is described below). Embodiments in which the non-volatile memory  comprises 256 MB, 512 MB, and 1 GB contemplated; however, other embodiments are contemplated in which more or less non-volatile memory  is included on the RAID controller . In one embodiment, the non-volatile memory  comprises a micro-disk drive. The non-volatile memory  is used by the RAID controller  to backup, or flush, the contents of the volatile cache memory , particularly the posted-write data, in response to a loss of main power so that when main power returns the posted-write data may be restored from the non-volatile memory  to the volatile cache memory .","The RAID controller  also includes a memory controller , coupled to the disk interface , host interface , cache memory , and non-volatile memory . The memory controller  controls accesses by the disk interface , host interface , and CPU subsystem  to the cache memory  and non-volatile memory . In one embodiment, the memory controller  also functions as a bus bridge for bridging communications between the volatile cache memory  bus, the non-volatile memory  bus, the CPU subsystem  bus, and the host interface  and disk interface  buses. In one embodiment, the memory controller  is a custom large scale integrated circuit. In one embodiment, the memory controller  comprises a custom programmable logic device. The memory controller  is described in more detail below with respect to .","During normal operation, the RAID controller  receives power from a main power source external to the RAID controller , including but not limited to a common commercially-supplied A\/C power source, as is well known in the art of power supplying. However, the RAID controller  also includes one or more capacitors  for supplying power to the RAID controller  in the event of a loss of main power, as described in more detail below. If some or all of the charge, or energy store, on the capacitors  is depleted because of a main power outage, the capacitors  are re-charged from the main power source once main power is restored. In one embodiment, the capacitors  employ Aerogel carbon technology as an active material and are configured as an array of parallel capacitors in a single package. In one embodiment, the capacitors  comprise four model B1860-2RS107 PowerStor B Series Aerogel Supercapacitors manufactured by Cooper Bussman of Boynton Beach, Fla., a division of Cooper Industries. However, other embodiments are contemplated, and the present invention is not limited to a particular capacitor model or capacitor technology.","The RAID controller  also includes a power regulator , coupled to receive power from both the capacitors  and the main power source. The power regulator  senses whether the main power source is supplying power, and if so, regulates the main power source to provide power to the various RAID controller  circuits. If the main power source is not supplying adequate power, the power regulator  regulates the capacitors  to provide power to a subset of the RAID controller  circuits, as described in more detail below.","The RAID controller  also includes a power manager , coupled to the power regulator  and to the memory controller . The power manager  also senses whether the main power source is supplying power. If the power manager  senses a loss of main power, the power manager  selectively instructs the memory controller  to flush the posted-write data from the cache memory  to the non-volatile memory , as described in detail below. In one embodiment, the power manager  comprises a micro-complex programmable logic device (CPLD) that consumes very low power. Additionally, other circuits may be employed to perform the functions described herein that are performed by the power manager , such as custom integrated circuits or discrete components.","In the embodiment of , when main power is lost, the capacitors  supply power only to the cache memory , the non-volatile memory , the memory controller , and power manager , and other circuits required to keep those circuits operational, such as bus terminators of the high-speed memory bus coupling the memory controller  to the cache memory . That is, the capacitors  supply power only to the circuits required to perform the flush operation of the posted-write data from the cache memory  to the non-volatile memory . Advantageously, the capacitors  do not supply power to the circuits not required to perform the flush, namely the CPU subsystem , disk interface , host interface , and unneeded portions of the memory controller , such as the portions for interfacing with the CPU subsystem , disk interface , and host interface .","In the present disclosure, a flush operation refers to a copying of data from the cache memory  to the non-volatile memory  in response to a loss of main power, whereas a restore operation refers to a copying of data from the non-volatile memory  to the cache memory  after main power is restored. The RAID controller  selectively performs a restore operation when main power is restored, as described below.","Referring now to , a block diagram illustrating in more detail the memory controller  of  according to the present invention is shown. The memory controller  includes control logic  for controlling various portions of the memory controller . In one embodiment, the control logic  includes a direct memory access controller (DMAC) that copies the data from the volatile cache memory  to the non-volatile memory  during the flush operation.","The control logic  receives a reset signal  from the power manager  of . When the power manager  asserts the reset signal , the memory controller  is reset. The power manager  is configured to selectively reset the cache memory  in such a manner that when the RAID controller  is reset or when main power is restored, if the contents of the cache memory  are still valid, the memory controller  does not invalidate the contents of the cache memory . For example, if the cache memory  is in the process of performing a flush operation, the power manager  does not reset the memory controller , thereby enabling the CPU subsystem  to gracefully abort the flush operation, as described below.","The control logic  also receives a pwr state signal  from the power manager . The power manager  instructs the memory controller  to perform actions via the pwr state signal  as described in Table 1 below. In particular, the power manager  instructs the memory controller  to flush the cache memory  contents to the non-volatile memory  with one value of the pwr state signal  and instructs the memory controller  to place the cache memory  into self-refresh mode with another value of the pwr state signal , in response to different events, such as a loss of main power or completion of a flush operation, as discussed below.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PWR_STATE Signal"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["00","Reserved."]},{"entry":["01","Flush cache memory to non-volatile memory."]},{"entry":[{},"Complete transactions on PCI-X buses then disable PCI-X operation."]},{"entry":[{},"Flush internal FIFOs to cache memory. Initiate DMA operation to"]},{"entry":[{},"flush cache memory data specified in CSRs to non-volatile memory"]},{"entry":[{},"via ATA interface."]},{"entry":["10","Place cache memory into self-refresh mode."]},{"entry":[{},"Complete transactions on PCI-X buses then disable PCI-X operation."]},{"entry":[{},"Flush internal FIFOs to cache memory then place the cache memory"]},{"entry":[{},"into self-refresh mode."]},{"entry":["11","Normal operation."]},{"entry":[{},"Allow normal data transfers on all buses."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The control logic  also provides a flush-status signal  to the power manager . The memory controller  provides the power manager  with the current cache memory  to non-volatile memory  flush state via the flush_status signal  as described in Table 2 below. In particular, the memory controller  indicates to the power manager  via the flush_status signal  whether or not a flush operation is in progress, and whether or not a flush operation has completed with or without errors.",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"FLUSH_STATUS Signal"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["00","Non-Flush Operation. Normal memory controller operation."]},{"entry":["01","Flush In-Progress."]},{"entry":["10","Flush Completed With Errors (ECC, ATA, or Aborted)."]},{"entry":["11","Flush Completed Successfully."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The memory controller  also includes a local bus interface  (such as a PCI-X interface) for interfacing the memory controller  to the disk interface ; another local bus interface  (such as a PCI-X interface) for interfacing the memory controller  to the host interface ; a memory bus interface  (such as a DDR SDRAM interface) for interfacing the memory controller  to the cache memory ; and an ATA interface  for interfacing the memory controller  to the non-volatile memory . The local bus interfaces  and , memory bus interface , and ATA interface  are all coupled to the control logic  and are also coupled to buffers  (such as first-in-first-out (FIFO) buffers) that buffer data transfers between the various interfaces and provide parallel high-speed data paths therebetween. In one embodiment, the ATA interface  supports ATA PIO Mode-4 and a data transfer rate of up to 16.7 MB\/second.","The memory controller  also includes a local bus interface , such as a PCI interface, coupled to the control logic , for interfacing the memory controller  to the CPU subsystem . The CPU subsystem  accesses the cache memory , non-volatile memory , disk interface , and host interface  via the PCI interface .","The memory controller  also includes control and status registers (CSRs) , coupled to the local bus interface  and to the control logic . The CSRs  are programmable by the CPU subsystem  of  to control the memory controller  and are readable by the CPU subsystem  for the memory controller  to provide status to the CPU subsystem . Among the CSRs  are control registers that enable the CPU subsystem  to specify the location and size of one or more regions of data, such as posted-write data, in the cache memory  which the memory controller  is to flush to the non-volatile memory  when main power is lost. The CSRs  are described in detail below with respect to .","Referring now to , a block diagram illustrating the CSRs  of  according to the present invention is shown. The various CSRs  and their contents are described in the text and Tables below.","The NVB_FLUSH_CTRL Register  provides the CPU subsystem  the ability to initiate a flush operation similar to the ability of the power manager  to initiate a flush operation via the pwr_state signal , and provides the CPU subsystem  the ability to read the status of a flush operation similar to the ability of the power manager  to read the flush operation status via the flush_status signal . When main power is restored and the CPU subsystem  software boots, a flush operation may still be in progress and the cache memory  contents may still be valid. Consequently, in one embodiment, the CPU subsystem  may command the memory controller  to abort an in-progress flush operation (since the cache memory  contents may still be valid) by writing a 0 to the FLUSH_START bit in the NVB_FLUSH_CTRL Register  as described in Table 3.",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_FLUSH_CTRL Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31:4\u2002","RO","0",{},"Reserved"]},{"entry":["3","RO",{},"AUTO_START","0 if Flush operation initiated by SW"]},{"entry":[{},{},{},{},"1 if Flush operation initiated by HW (pin)"]},{"entry":[{},{},{},{},"This bit is set when a flush is started and will remain set"]},{"entry":[{},{},{},{},"until a new flush is initiated."]},{"entry":["2:1","RO","0","FLUSH_STATUS","Provides status of data flush operation."]},{"entry":[{},{},{},{},"00 - No Data Flush"]},{"entry":[{},{},{},{},"01 - Data Flush in-progress"]},{"entry":[{},{},{},{},"10 - Data Flush Completed with Errors (ECC, ATA, or"]},{"entry":[{},{},{},{},"Aborted)"]},{"entry":[{},{},{},{},"11 - Data Flush Completed Successfully"]},{"entry":["0","RW","0","FLUSH_START","Writing \u201c1\u201d to this register initiates data flush operation."]},{"entry":[{},{},{},{},"The external PWR_STATE pins will also set this bit."]},{"entry":[{},{},{},{},"When the flush is complete, this bit will reset back to 0."]},{"entry":[{},{},{},{},"Writing \u201c0\u201d while the flush is going aborts the operation"]},{"entry":[{},{},{},{},"(aborts on next 512 byte boundary). After an abort the"]},{"entry":[{},{},{},{},"ATA device may need to be reset as it is left in an"]},{"entry":[{},{},{},{},"unknown state."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_RESTORE_CTRL Register  provides the CPU subsystem  the ability to initiate a restore operation from non-volatile memory  to cache memory , and provides the CPU subsystem  the ability to read the status of a restore operation.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_RESTORE_CTRL Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31:3\u2002","RO","0",{},"Reserved"]},{"entry":["2:1","RO","0","RESTORE_STATUS","Provides status of data restore operation."]},{"entry":[{},{},{},{},"00 - No Restore in progress"]},{"entry":[{},{},{},{},"01 - Data Restore in progress"]},{"entry":[{},{},{},{},"10 - Data Restore Completed with Errors (ECC,"]},{"entry":[{},{},{},{},"ATA, or Aborted)"]},{"entry":[{},{},{},{},"11 - Data Restore Completed without Errors"]},{"entry":["0","RW","0","RESTORE_START","Writing \u201c1\u201d to this register initiates data restore"]},{"entry":[{},{},{},{},"operation. When the restore is complete, this bit"]},{"entry":[{},{},{},{},"will reset back to 0. Writing \u201c0\u201d while the restore"]},{"entry":[{},{},{},{},"is going aborts the operation (aborts on next 512"]},{"entry":[{},{},{},{},"byte boundary). After an abort the ATA device"]},{"entry":[{},{},{},{},"may need to be reset as it is left in an unknown"]},{"entry":[{},{},{},{},"state."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_RAM_START_ADDR Register  specifies the starting address in the cache memory  of a first region of data that is the source or sink of a flush or restore operation, respectively.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_RAM_START_ADDR1 Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31","RO","0",{},"Reserved"]},{"entry":["30:9","RW","0","NVB_RAM_START_ADDR1","Starting cache"]},{"entry":[{},{},{},{},"memory"]},{"entry":[{},{},{},{},"address used"]},{"entry":[{},{},{},{},"for a flush or"]},{"entry":[{},{},{},{},"restore operation"]},{"entry":[{},{},{},{},"for Region 1."]},{"entry":["\u20028:0","RO","0",{},"Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_ATA_START_ADDR Register  specifies the starting address in the non-volatile memory  of the first region of data that is the sink or source of a flush or restore operation, respectively. In one embodiment, the memory controller  converts the non-volatile memory  address specified in the NVB_ATA_START_ADDR Register  to a sector number if the non-volatile memory  is a sectored ATA device.",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_ATA_START_ADDR1 Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31","RO","0",{},"Reserved"]},{"entry":["30:9","RW","0","NVB_ATA_START_ADDR1","Starting"]},{"entry":[{},{},{},{},"non-volatile"]},{"entry":[{},{},{},{},"memory address"]},{"entry":[{},{},{},{},"used for a flush"]},{"entry":[{},{},{},{},"or restore"]},{"entry":[{},{},{},{},"operation for"]},{"entry":[{},{},{},{},"Region 1."]},{"entry":["\u20028:0","RO","0",{},"Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_SIZE Register  specifies the total size, or length, of the first region of data that is to be copied by a flush or restore operation.",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_SIZE1 Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31","RO","0",{},"Reserved"]},{"entry":["30:9","RW","0","NVB_SIZE1","Total size (length) of a flush or"]},{"entry":[{},{},{},{},"restore operation of Region 1."]},{"entry":["\u20028:0","RO","0",{},"Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_RAM_START_ADDR Register  specifies the starting address in the cache memory  of a second region of data that is the source or sink of a flush or restore operation, respectively.",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_RAM_START_ADDR2 Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31","RO","0",{},"Reserved"]},{"entry":["30:9","RW","0","NVB_RAM_START_ADDR2","Starting cache"]},{"entry":[{},{},{},{},"memory address"]},{"entry":[{},{},{},{},"used for flush or"]},{"entry":[{},{},{},{},"restore operation"]},{"entry":[{},{},{},{},"for Region 2."]},{"entry":["\u20028:0","RO","0",{},"Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_ATA_START_ADDR Register  specifies the starting address in the non-volatile memory  of the second region of data that is the sink or source of a flush or restore operation, respectively. In one embodiment, the memory controller  converts the non-volatile memory  address specified in the NVB_ATA_START_ADDR Register  to a sector number if the non-volatile memory  is a sectored ATA device.",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_ATA_START_ADDR2 Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31","RO","0",{},"Reserved"]},{"entry":["30:9","RW","0","NVB_ATA_START_ADDR2","Starting"]},{"entry":[{},{},{},{},"non-volatile"]},{"entry":[{},{},{},{},"memory address"]},{"entry":[{},{},{},{},"used for a flush or"]},{"entry":[{},{},{},{},"restore operation"]},{"entry":[{},{},{},{},"for Region 2."]},{"entry":["\u20028:0","RO","0",{},"Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_SIZE Register  specifies the total size, or length, of the second region of data that is to be copied by a flush or restore operation.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_SIZE2 Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31","RO","0",{},"Reserved"]},{"entry":["30:9","RW","0","NVB_SIZE2","Total size (length) of a flush or"]},{"entry":[{},{},{},{},"restore operation of Region 2."]},{"entry":["\u20028:0","RO","0",{},"Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_SECTOR_COUNT Register  specifies the number of sectors to use for each write\/read command issued by the memory controller  to the non-volatile memory  ATA device. The NVB_SECTOR_COUNT Register  may be used to optimize the speed of the flush and restore operations to and from the non-volatile memory  ATA device. The NVB_SECTOR_COUNT Register  is used in conjunction with the NVB_SIZE Register \/. For example, the CPU subsystem  may program the NVB_SIZE Register \/ with a value of 256 KB and the NVB_SECTOR_COUNT Register  with a value of 32, resulting in the 256 KB of data being written as 16 write commands of 32 sectors (16 KB) each. The NVB_SIZE Register \/ must be programmed with a value that is a multiple of the NVB_SECTOR_COUNT Register  value.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_SECTOR_COUNT Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31:9","RO","0",{},"Reserved"]},{"entry":["\u20028:0","RW","1","NVB_SECTOR_COUNT","Non-volatile memory"]},{"entry":[{},{},{},{},"Sector Count. Number"]},{"entry":[{},{},{},{},"of sectors to use for"]},{"entry":[{},{},{},{},"each Write\/Read"]},{"entry":[{},{},{},{},"command issued to"]},{"entry":[{},{},{},{},"ATA device. The"]},{"entry":[{},{},{},{},"allowable values are:"]},{"entry":[{},{},{},{},"0x000 1 sector"]},{"entry":[{},{},{},{},"0x001 1 sector"]},{"entry":[{},{},{},{},"0x002 2 sectors"]},{"entry":[{},{},{},{},"0x004 4 sectors"]},{"entry":[{},{},{},{},"0x008 8 sectors"]},{"entry":[{},{},{},{},"0x010 16 sectors"]},{"entry":[{},{},{},{},"0x020 32 sectors"]},{"entry":[{},{},{},{},"0x040 64 sectors"]},{"entry":[{},{},{},{},"0x080 128 sectors"]},{"entry":[{},{},{},{},"0x100 256 sectors"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_PROGRESS Register  specifies the current address in the cache memory  being read from or written to during a flush operation or restore operation, respectively. The NVB_PROGRESS Register  is valid only when a flush or restore operation is in progress. The NVB_PROGRESS Register  enables the CPU subsystem  to assess the progress of a flush or restore operation. If the flush or restore operation generates an error, the NVB_PROGRESS Register  value specifies the approximate address where the error occurred. If a flush or restore operation is aborted, the NVB_PROGRESS Register  will have incremented to the next sector after the abort occurs.",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 12"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_PROGRESS Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31","RO","0",{},"Reserved"]},{"entry":["30:4","RO","0","NVB_PROGRESS","Current non-volatile memory"]},{"entry":[{},{},{},{},"flush or Restore Address."]},{"entry":[{},{},{},{},"This value is only valid during"]},{"entry":[{},{},{},{},"a flush or restore operation."]},{"entry":["\u20023:0","RO","0",{},"Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The ATA_INT_STATUS Register  may be read by the CPU subsystem  to determine whether the non-volatile memory  ATA device has generated an interrupt, such as upon the successful read or write of one or more sectors of data during a flush or restore operation, and to determine whether a flush or restore operation has completed. The ATA_INT_STATUS Register  also enables the CPU subsystem  to clear the interrupt source.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 13"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"T_STATUS Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31:3","RO","0",{},"Reserved"]},{"entry":["2","RO","0","ATA_DEVICE_INT","ATA Device Interrupt. This bit reflects the"]},{"entry":[{},{},{},{},"status of the non-volatile memory ATA"]},{"entry":[{},{},{},{},"device interrupt line (1 = asserted)."]},{"entry":["1","RW1C","0","RESTORE_DONE_INT","Restore Operation Done. This bit will be set"]},{"entry":[{},{},{},{},"to one when a Restore operation completes."]},{"entry":[{},{},{},{},"If the corresponding bit in the"]},{"entry":[{},{},{},{},"ATA_INT_ENABLE register is also set,"]},{"entry":[{},{},{},{},"then an ATA_IRQ will be generated."]},{"entry":[{},{},{},{},"Writing a one to this bit location will clear"]},{"entry":[{},{},{},{},"the bit (and interrupt) as will starting a new"]},{"entry":[{},{},{},{},"Restore operation."]},{"entry":["0","RW1C","0","FLUSH_DONE_INT","Flush Operation Done. This bit will be set to"]},{"entry":[{},{},{},{},"one when a flush operation completes. If the"]},{"entry":[{},{},{},{},"corresponding bit in the"]},{"entry":[{},{},{},{},"ATA_INT_ENABLE register is also set,"]},{"entry":[{},{},{},{},"then an ATA_IRQ will be generated."]},{"entry":[{},{},{},{},"Writing a one to this bit location will clear"]},{"entry":[{},{},{},{},"the bit (and interrupt) as will starting a new"]},{"entry":[{},{},{},{},"flush operation."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The ATA_INT_ENABLE Register  enables the CPU subsystem  to enable or disable interrupt sources specified by the ATA_INT_STATUS Register .",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":{"entry":"TABLE 14"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ATA_INT_ENABLE Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31:3","RO","0",{},"Reserved"]},{"entry":["2","RW","0","ATA_DEVICE_INT_EN","ATA Device Interrupt Enable. When"]},{"entry":[{},{},{},{},"set to one, the ATA Device interrupt"]},{"entry":[{},{},{},{},"will generate an ATA_IRQ interrupt."]},{"entry":["1","RW","0","RESTORE_DONE_INT_EN","Restore Operation Done Interrupt"]},{"entry":[{},{},{},{},"Enable. When set to one, the Restore"]},{"entry":[{},{},{},{},"Done interrupt will generate an"]},{"entry":[{},{},{},{},"ATA_IRQ interrupt"]},{"entry":["0","RW","0","FLUSH_DONE_INT_EN","Flush Operation Done Interrupt Enable."]},{"entry":[{},{},{},{},"When set to one, the Flush Done"]},{"entry":[{},{},{},{},"interrupt will generate an ATA_IRQ"]},{"entry":[{},{},{},{},"interrupt"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_ERROR_CODE Register  specifies the error type when a flush or restore operation completes if the NVB_FLUSH_CTRL Register  or NVB_RESTORE_CTRL Register  indicates a failure. When an ECC error is detected, the operation terminates at the next sector boundary. Consequently, up to 512 bytes may be transferred after the error occurs. In one embodiment, the CPU subsystem  has the ability to cause ECC errors to be ignored. Hardware detection of ATA device errors is performed by checking the contents of the ATA Device Status register, which is a Task File register in the ATA Direct Access Registers  discussed below. The memory controller  reads the ATA Device Status register after issuing the ATA command and after the transfer of each sector completes. Consequently, ATA device errors are detected and reported at the sector boundary where the error occurs, i.e., up to 512 bytes may transfer after the ATA error actually occurs. Likewise, ATA operations terminate only at a sector boundary.",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 15"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_ERROR_CODE Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31:9","RO","0",{},"Reserved"]},{"entry":["8","RO","0","NVB_ERROR_TYPE","0 = ATA Device Error"]},{"entry":[{},{},{},{},"(or no error if no failure)"]},{"entry":[{},{},{},{},"1 = DDR SDRAM"]},{"entry":[{},{},{},{},"uncorrectable error"]},{"entry":["7:0","RO","0","ATA_ERROR_CODE","ATA device status"]},{"entry":[{},{},{},{},"register"]},{"entry":[{},{},{},{},"Bit 7: BUSY"]},{"entry":[{},{},{},{},"Bit 6: RDY"]},{"entry":[{},{},{},{},"Bit 5: DWF - Write Fault"]},{"entry":[{},{},{},{},"occurred"]},{"entry":[{},{},{},{},"Bit 4: DSC"]},{"entry":[{},{},{},{},"Bit 3: DRQ"]},{"entry":[{},{},{},{},"Bit 2: CORR"]},{"entry":[{},{},{},{},"Bit 1: IDX (always 0)"]},{"entry":[{},{},{},{},"Bit 0: ERR - Command"]},{"entry":[{},{},{},{},"ended in error specified"]},{"entry":[{},{},{},{},"in ATA Device Error "]},{"entry":[{},{},{},{},"Task File register"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The NVB_CONFIG Register  enables the CPU subsystem  to configure aspects of a flush operation. In particular, the CPU subsystem  may enable the memory controller  to automatically perform a flush operation or may disable the memory controller  from automatically performing a flush operation. Additionally, the CPU subsystem  may selectively instruct the memory controller  via the NVB_CONFIG Register  to write to the non-volatile memory  information specifying the results of a flush operation when the flush operation ends, whether the flush was successful or was aborted or an error occurred, as described below. The memory controller  writes the flush results information to a predetermined flush results sector of the non-volatile memory  ATA device. In one embodiment, the flush results sector is the first sector of the non-volatile memory .",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":{"entry":"TABLE 16"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NVB_CONFIG_Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31:2","RO","0",{},"Reserved"]},{"entry":["1","R\/W","0","WR_FLUSH_RESULTS_EN","Enable bit to allow the results of the"]},{"entry":[{},{},{},{},"Flush Operation to be written back to"]},{"entry":[{},{},{},{},"the first sector of the NVB memory."]},{"entry":[{},{},{},{},"See below for format."]},{"entry":["0","R\/W","0","AUTO_FLUSH_EN","Enable bit for the Automatic Flush on"]},{"entry":[{},{},{},{},"power-down. 1 = enabled. 0 = disabled."]},{"entry":[{},{},{},{},"If enabled, when an auto"]},{"entry":[{},{},{},{},"flush operation completes (success, fail"]},{"entry":[{},{},{},{},"or aborted), this bit will be cleared."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The ATA_RESET Register  enables the CPU subsystem  to reset the non-volatile memory  ATA device.",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 17"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ATA_RESET Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31:1","RO","0",{},"Reserved"]},{"entry":["0","R\/W","0","ATA_RESET","When this bit is 1 the ATA device"]},{"entry":[{},{},{},{},"will be held in reset. 0 allows"]},{"entry":[{},{},{},{},"normal operation."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The ATA_CRC Register  contains the 32-bit CRC for the data when a flush or restore operation is completed. The CRC data is automatically written to the write results sector if the option is enabled. In one embodiment, a flush operation writes the CRC value to the write results sector and when a restore operation is performed, the CRC value is compared to the ATA_CRC Register  value to determine if any data corruption occurred during the flush or restore operation, indicated by a mismatch.",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":{"entry":"TABLE 18"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ATA_CRC_Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bits","R\/W","Reset","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["31:0","RO","0xFFFFFFFF","ATA_CRC","CRC of the last Flush or Restore operation. The"]},{"entry":[{},{},{},{},"CRC is a 32 bit CRC using 16 bit input. The"]},{"entry":[{},{},{},{},"starting value is 0xFFFFFFFF (preset). The"]},{"entry":[{},{},{},{},"polynomial is:"]},{"entry":[{},{},{},{},"x{circumflex over (\u2009)}32 + x{circumflex over (\u2009)}26 + x{circumflex over (\u2009)}23 + x{circumflex over (\u2009)}22 + x{circumflex over (\u2009)}16 + x{circumflex over (\u2009)}12 + x{circumflex over (\u2009)}11 +"]},{"entry":[{},{},{},{},"x{circumflex over (\u2009)}10 + x{circumflex over (\u2009)}8 + x{circumflex over (\u2009)}7 + x{circumflex over (\u2009)}5 + x{circumflex over (\u2009)}4 + x{circumflex over (\u2009)}2 + x + 1"]},{"entry":[{},{},{},{},"(IEEE 802.3 CRC-32 polynomial) however, the"]},{"entry":[{},{},{},{},"final result is not complemented."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The format of the flush results information written to the non-volatile memory  ATA device flush results sector is described in Table 19 below.",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 19"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Flush Results Sector Format"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{}]},{"entry":["Offset","Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","Completion Signature","0x13AC"]},{"entry":["2","Completion Status","0x0002 (if completion with errors or"]},{"entry":[{},{},"aborted)"]},{"entry":[{},{},"0x0003 (if successful completion)"]},{"entry":["4","Completion Error Code","Same value as"]},{"entry":[{},{},"NVB_ERROR_CODE Register"]},{"entry":["6","High Half of CRC","0xXXXX"]},{"entry":["8","Low Half of CRC","0xXXXX"]},{"entry":["10","Reserved","0x00000000"]},{"entry":["14","Sector Pad Bytes","0xFF"]},{"entry":[{},{},"(remainder of sector has this value)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The Completion Signature value is also stored in the code FLASH  so that the CPU subsystem  can compare it with the Completion Signature in the non-volatile memory  flush results sector to determine whether a flush operation was successful. Additionally, in one embodiment, the memory controller  computes a running cyclic redundancy code (CRC) of the data as it flushes the data to the non-volatile memory , and writes the final CRC value to the flush results sector at the offset shown in Table 19. This enables the CPU subsystem  to generate a CRC when reading the data during a restore operation to verify that the data is valid, i.e., that the data was accurately written to the non-volatile memory  by the flush operation, by comparing with the ATA_CRC Register  value.","The ATA Direct Access Registers  comprise control and status registers used by the CPU subsystem  to communicate with the non-volatile memory  ATA device. In one embodiment, the ATA Direct Access Registers  comprise a standard ATA register file, commonly known as a Task File, which is well-known in the art of disk drives. The memory controller  reads and writes the ATA Direct Access Registers  to perform ATA commands with the non-volatile memory  ATA device, such as writes of posted-write data during a flush operation and reads of the data during a restore operation. The CPU subsystem  may also directly access the ATA Direct Access Registers .","Referring now to , a flowchart illustrating operation of the RAID controller  of  to perform a flush operation according to the present invention is shown. Flow begins at block .","At block , the CPU subsystem  programs the memory controller  CSRs  of  with the information needed by the memory controller  to perform an automatic flush operation. Preferably, the CPU subsystem  software performs this function as part of its initialization sequence during boot up. In particular, the CPU subsystem  programs the NVB_FLUSH_CTRL Register , the NVB_RAM_START_ADDR Register , the NVB_ATA_START_ADDR Register , the NVB_SIZE Register , the NVB_RAM_START_ADDR Register , the NVB_ATA_START_ADDR Register , the NVB_SIZE Register , the NVB_SECTOR_COUNT Register , the ATA_INT_ENABLE Register , and the NVB_CONFIG Register  with the desired values to provide the memory controller  with the necessary information to perform a flush operation. In one embodiment, the CPU subsystem  programs the memory controller  to flush all cached data, i.e., posted-write data and read-cached data; however, in another embodiment, the CPU subsystem  programs the memory controller  to include only posted-write data, thereby reducing the amount of energy and time required to perform the flush operation. In addition, the CPU subsystem  may initialize the flush results sector to a predetermined value in order to enable the CPU subsystem  to determine whether the memory controller  successfully wrote the flush operation results information to the flush results sector at the end of a flush operation. For example, in one embodiment, the CPU subsystem  writes or erases the flush results sector with a value of 0xFF for each byte in the sector. The CPU subsystem  subsequently begins normal operation while the main power source supplies power to the RAID controller . Normal operation includes performing posted write operations, causing posted-write data to be stored into the volatile cache memory . Flow proceeds to block .","At block , the main power source fails to supply power to the RAID controller . In response, the capacitors  begin supplying power to the predetermined portions of the RAID controller , namely to the cache memory , the non-volatile memory , the memory controller , the power manager , and power regulator  and related circuitry. In particular, the capacitors  do not supply power to the CPU subsystem , disk interface , or host interface . Additionally, the PCI-X interfaces  and  and FIFOs  that are not needed because they are used only to interface with the disk interface  and host interface  are not powered by the capacitors . Consequently, advantageously, the CPU subsystem , disk interface , host interface  and unneeded portions of the memory controller  do not consume energy during the flush operation, thereby enabling the RAID controller  to employ capacitors  capable of storing less energy, which typically implies capacitors  that are less expensive and\/or require less space. Additionally, the fact that the CPU subsystem , disk interface , and host interface  do not consume energy stored in the capacitors  leaves more energy stored in the capacitors  once the flush operation is complete, which increases the likelihood that the capacitors  will continue to supply power to the cache memory  after the flush is complete thereby keeping the posted-write data intact, which may alleviate the need for a restore operation when the main power is restored, as described below. Flow proceeds to block .","At block , the power manager  detects the loss of main power and commands the memory controller  via the pwr_state signal  to begin a flush operation of data from the cache memory  to the non-volatile memory . Flow proceeds to block .","At block , if the AUTO_FLUSH_EN bit in the NVB_CONFIG Register  is set, then the memory controller  performs a flush operation based on the information previously programmed into the CSRs  at block . In particular, the memory controller  copies the data in the two regions specified by the NVB_RAM_START_ADDR Register \/NVB_SIZE Register  and NVB_RAM_START_ADDR Register \/NVB_SIZE Register  to the two locations in the non-volatile memory  specified by the NVB_ATA_START_ADDR Register  and NVB_ATA_START_ADDR Register , respectively, in a manner specified by the NVB_SECTOR_COUNT Register  and the ATA_INT_ENABLE Register . In one embodiment, the first region includes the portion of the posted-write data that includes the actual user data, and the second region includes the portion of the posted-write data that is metadata. In another embodiment, the first region includes the posted-write user data and associated metadata, and the second region includes read-cached user data and associated metadata. However, the use of the two regions is not limited to these embodiments. Furthermore, embodiments are contemplated in which the CSRs  include registers for specifying more or less than two data regions. Flow proceeds to block .","At block , if the WR_FLUSH_RESULTS_EN bit in the NVB_CONFIG Register  is set, then the memory controller  writes the flush results information specified in Table 19 above to the flush results sector of the non-volatile memory  at the end of the flush operation, whether the flush operation was successful, was aborted, or was terminated due to an error. If the CPU subsystem  aborts a flush (or restore) operation, or if the memory controller  detects an ECC or ATA error during the flush (or restore) operation, then the memory controller  will terminate the flush (or restore) operation at the next sector boundary. If the WR_FLUSH_RESULTS_EN bit in the NVB_CONFIG Register  is set, the memory controller  will write the flush results sector and post a Boolean  on the flush_status signal  and in the FLUSH_STATUS bits of the NVB_FLUSH_CTRL Register . If, while the memory controller  is writing the flush operation results to the flush results sector itself, the CPU subsystem  commands an abort or the memory controller  detects an error, the flush operation results may or may not be written successfully to the flush results sector, and if they are written, the flush results information may be unreliable. Flow proceeds to block .","At block , after the power manager  commands the memory controller  to initiate the flush operation, the power manager  monitors the progress of the flush operation via the flush_status signal . When the flush operation completes, the power manager  commands the memory controller  via the pwr state signal  to place the cache memory  into self-refresh mode, in order to reduce the amount of energy stored in the capacitors  that is consumed by the cache memory . Flow proceeds to block .","At block , the memory controller  places the cache memory  into self-refresh mode in response to the command performed by the power manager  at block . Flow proceeds to block .","At block , the power manager  causes the capacitors  to supply power to the cache memory  only. That is, the power manager  causes the capacitors  to no longer supply power to the non-volatile memory  and the memory controller , in order to reduce the amount of energy stored in the capacitors  that is consumed while waiting until main power is restored. Flow ends at block .","Referring now to , a flowchart illustrating operation of the RAID controller  of  in response to main power being restored after a failure of main power according to the present invention is shown. Flow begins at block .","At block , the main power source resumes supplying power to the RAID controller . Consequently, the CPU subsystem  software boots up and begins its initialization sequence. Flow proceeds to decision block .","At decision block , the CPU subsystem  determines whether the cache memory  contents is still valid. In one embodiment, the CPU subsystem  determines whether the cache memory  contents is still valid by examining a data good indicator in the power manager  that may be written by the memory controller . The power manager  is configured such that when it is powered up, the data good indicator resets to a predetermined value, such as a Boolean value of zero. Furthermore, the power-off threshold of the power manager  is at least as high as the power threshold at which the cache memory  begins to lose its data. When main power is lost, the memory controller  writes a value into the data good indicator different from the power-up reset value. Thus, if the capacitors  fail to supply power to the cache memory  (and therefore also fail to supply power to the data good indicator), when main power is restored, the CPU subsystem  will read the power-up reset value from the data good indicator rather than the value written by the memory controller . Consequently, the CPU subsystem  will determine that the cache memory  must be restored from the non-volatile memory , if the flush operation was successful. However, if the CPU subsystem  reads from the data good indicator the value written by the memory controller , then the CPU subsystem  will determine that it can forego restoring the cache memory  thereby making the user data available to the host computers sooner. If the cache memory  contents is still valid, flow proceeds to decision block ; otherwise, flow proceeds to decision block .","At decision block , the CPU subsystem  determines whether a flush operation performed according to  was successfully completed by examining the FLUSH_STATUS bits of the NVB_FLUSH_CTRL Register . In one embodiment, the CPU subsystem  additionally determines whether the flush operation completed successfully by examining the Completion Status in the flush results sector. In one embodiment, the CPU subsystem  additionally determines whether the flush operation completed successfully by comparing the Completion Signature in the flush results sector with the Completion Signature in the code FLASH . In one embodiment, the CPU subsystem  additionally determines whether the flush operation completed successfully by comparing the CRC in the flush results sector with the CRC computed by reading the data from the non-volatile memory . If the flush operation completed successfully, flow proceeds to block ; otherwise, flow proceeds to block .","At block , since the posted-write data has been lost, the RAID controller  fails over to the partner, i.e., redundant, RAID controller  in the system. In one embodiment, during normal operation when a host issues a write I\/O request to the RAID controller , the posted write data is also written to the partner RAID controller . Consequently, if one of the RAID controllers  fails, in particular if a flush operation fails on one RAID controller , there is a high probability that the flush operation succeeded on the partner RAID controller . If so, the partner RAID controller  can perform a restore of the posted-write data from its non-volatile memory  to the cache memory  and subsequently flush the posted-write data to disk. Flow ends at block .","At block , the CPU subsystem  commands the memory controller  to perform a restore operation to restore the data flushed from the cache memory  to the non-volatile memory  during the flush operation described in  back to the cache memory . Prior to commanding the memory controller  to perform the restore operation, the CPU subsystem  programs the appropriate values into the various CSRs  of the memory controller  needed to perform the restore operation. In one embodiment, the CPU subsystem  performs the restore operation, rather than commanding the memory controller  to perform the restore operation, by simply reading data from the non-volatile memory  and writing the data to the cache memory . Because the restore operation is performed while the main power source is supplying power, it is not as crucial that the memory controller  perform the restore operation at a lower power consumption level. However, this embodiment has the disadvantage that the CPU subsystem  may take longer than the memory controller  to complete the restore operation. Flow proceeds to block .","At block , the CPU subsystem  flushes the posted-write data from the cache memory  to disk. Flow ends at block .","At decision block , the CPU subsystem  determines whether a flush operation is in progress by reading the FLUSH_STATUS bits of the NVB_FLUSH_CTRL Register . If a flush operation is in progress, flow proceeds to decision block ; otherwise, flow proceeds to block .","At decision block , the CPU subsystem  examines the capacitors  voltage level to determine whether the voltage level is above a minimum threshold. In one embodiment, the minimum voltage threshold value is programmed into the CPU subsystem  software. In another embodiment, the minimum voltage threshold value is user-programmable via a user configuration program. If the capacitors  voltage level is above the minimum threshold, flow returns to decision block  to wait until either the flush operation completes or the capacitors  voltage reaches the minimum threshold; otherwise, flow proceeds to block .","At block , the CPU subsystem  aborts the flush operation by writing a Boolean 0 to the FLUSH_START bit in the NVB_FLUSH_CTRL Register . Flow proceeds to block .","The process of waiting to boot the RAID controller  and resume normal operations if the cache memory  is still good and a flush operation is in progress until either the flush completes or the capacitors  voltage level reaches the minimum threshold solves the problem which might exist without the benefit of the additional test at decision block , as exemplified by the following sequence of events. Assume the power manager  senses the loss of main power and commands the memory controller  to perform a flush operation. A significant amount of the capacitors  stored energy is consumed by the flush operation. Before the flush operation completes, main power is restored; consequently, the CPU subsystem  aborts the flush operation. The CPU subsystem  boots up and enables another flush operation in the event of another main power loss. Shortly thereafter, and significantly, while the capacitors  are less than fully re-charged, the power manager  senses another loss of main power and commands the memory controller  to perform another flush operation. The second flush operation consumes again a significant amount of the capacitors  stored energy, which began with less than a full charge. If this sequence continues, eventually the capacitors  will not have enough energy to complete a successful flush operation, resulting in potential loss of user data. The scenario described above may be induced by periodic brown-outs of the main power supply or possibly by a noisy power supply that cause the power manager  to sense that main power is being lost in a relatively periodic fashion in which the period is on the order of the flush operation time. However, advantageously, the additional test at decision block  potentially avoids this problem.","In one embodiment, the capacitors  comprise a 200 Farad package of four 50 Farad capacitors in series storing 336 Joules of usable energy when fully charged, assuming a 2.0 Volt charged voltage level of each capacitor and a 0.8 Volt cut off voltage, which defines the minimum working voltage for reliable FET gate thresholds and low drop out regulation. In one embodiment, the power consumption of the cache memory , non-volatile memory , memory controller , power manager , DDR-SDRAM bus interface termination circuitry, a clocking circuit, and other miscellaneous circuitry requiring power during the flush operation is approximately 4 Watts. The non-volatile memory  is capable of being written to at a sustained rate of approximately 10 MB\/second. In one embodiment, the size of the cache memory  is 1 GB, which comprises approximately 512 MB allocated to storage of posted-write data, and the size of the non-volatile memory  is 512 MB. Consequently, the flush operation takes approximately 50 seconds to complete and consumes approximately 200 Joules of energy. In another embodiment, the size of the cache memory  is 512 MB, which comprises approximately 256 MB allocated to storage of posted-write data, the size of the non-volatile memory  is 256 MB, and the non-volatile memory  is capable of being written to at a sustained rate of approximately 7.5 MB\/second. Consequently, the flush operation takes approximately 33 seconds to complete and consumes approximately 133 Joules of energy. This is in contrast to the relatively large amount of energy consumed by the CPU subsystem  in some embodiments. For example, in one embodiment the CPU subsystem  consumes approximately 15 Watts during normal operation; hence, if the CPU subsystem  was powered during the flush operation, the capacitors  embodiment described above would not be able to provide the required energy for either of the flush operations described above. However, the embodiments described above which do not provide power to the CPU subsystem  during the flush operation advantageously enable the flush operation to be performed within the energy storage capabilities of a cost-effective capacitor solution in many applications, such as the capacitors  of the embodiments described in this paragraph. However, the present invention is not limited to the capacitors  embodiments described herein, but may be adapted to employ capacitors  with more or less energy storage capacity and density as needed by the particular RAID controller application.","Although embodiments have been described in which the memory controller is employed to perform the posted-write data flush from volatile memory to non-volatile memory, embodiments are contemplated in which the CPU performs the flush from volatile memory to non-volatile memory, as illustrated in . The embodiment of  which use the CPU subsystem  to perform the flush operation may be a viable embodiment if one or more of the following in combination is true: the energy density of the capacitors  is sufficiently high to store the energy needed by the RAID controller , including the CPU subsystem , to perform the flush operation; the available space allocated for the capacitors  on the RAID controller  is sufficiently great to use enough capacitors  to store the energy needed by the RAID controller , including the CPU subsystem , to perform the flush operation; the CPU subsystem  consumes a small enough amount of power such that the capacitors  can store the energy needed by the RAID controller , including the CPU subsystem , to perform the flush operation. Although this embodiment may consume more energy than the embodiments described in , if the capacitors  are able to supply the required energy, then the RAID controller  would enjoy the benefits of capacitor technology over battery technology described herein, such as lower cost, higher reliability, less maintenance, and shorter re-charge time.","Referring now to , a block diagram illustrating a RAID controller  according to an alternate embodiment of the present invention is shown. The RAID controller  of  is similar to the RAID controller  of ; however, the power manager  is coupled to communicate with the CPU subsystem  with respect to flush operations rather than to the memory controller , as shown, and as described with respect to .","Referring now to , a flowchart illustrating operation of the RAID controller  of  to perform a flush operation according to an alternate embodiment of the present invention is shown. Flow begins at block .","At block , the main power source fails to supply power to the RAID controller . In response, the capacitors  begin supplying power to the predetermined portions of the RAID controller , namely to the cache memory , the non-volatile memory , the memory controller , the power manager , power regulator , CPU subsystem , and related circuitry. In particular, the capacitors  do not supply power to the disk interface , or host interface . Additionally, the PCI-X interfaces  and  and FIFOs  that are not needed because they are used only to interface with the disk interface  and host interface  are not powered by the capacitors . Consequently, advantageously, the disk interface , host interface  and unneeded portions of the memory controller  do not consume energy during the flush operation, thereby enabling the RAID controller  to employ capacitors  capable of storing less energy, which typically implies capacitors  that are less expensive and\/or require less space. Additionally, the fact that the disk interface  and host interface  do not consume energy stored in the capacitors  leaves more energy stored in the capacitors  once the flush operation is complete, which increases the likelihood that the capacitors  will continue to supply power to the cache memory  after the flush is complete thereby keeping the posted-write data intact, which may alleviate the need for a restore operation when the main power is restored, as described below. Flow proceeds to block .","At block , the power manager  detects the loss of main power and notifies the CPU subsystem  that a flush operation of data from the cache memory  to the non-volatile memory  is needed. Flow proceeds to block .","At block , the CPU subsystem  performs a flush operation by copying the data from the cache memory  to the non-volatile memory . Flow proceeds to block .","At block , the CPU subsystem  writes the flush results information specified in Table 19 above to the flush results sector of the non-volatile memory  upon completion of the flush operation, whether the flush operation was successful, was aborted, or was terminated due to an error. Flow proceeds to block .","At block , the CPU subsystem  places the cache memory  into self-refresh mode. Flow proceeds to block .","At block , the CPU subsystem  commands the power manager  to cause the capacitors  to supply power to the cache memory  only. That is, the power manager  causes the capacitors  to no longer supply power to the CPU subsystem , non-volatile memory  and the memory controller , in order to reduce the amount of energy stored in the capacitors  that is consumed while waiting until main power is restored. Flow ends at block .","Although  describe embodiments in which capacitors  supply power to the RAID controller  when main power fails and the CPU subsystem  is not involved with and is powered down during the flush operation, other embodiments are contemplated in which a battery or other re-chargeable power source is employed to supply power when main power fails, as illustrated in .","Referring now to , a block diagram illustrating a RAID controller  according to an alternate embodiment of the present invention is shown. The RAID controller  of  is similar to the RAID controller  of ; however, in the RAID controller  of  the capacitors  of  are replaced by a battery . The embodiment of  operates similarly to the embodiment of  as described in , except the battery  supplies power during the main power outage rather than the capacitors . That is, the memory controller  performs the flush operation, such that the battery  does not supply power to the CPU subsystem  during the flush operation. Consequently, the embodiment of  may enjoy the benefits of reduced energy consumption of the battery  or other re-chargeable power source achieved by having the memory controller  perform the flush operation rather than the CPU subsystem , such as requiring a smaller capacity and less expensive battery  or other re-chargeable power source.","Although the present invention and its objects, features, and advantages have been described in detail, other embodiments are encompassed by the invention. For example, although embodiments have been described in which the interface between the memory controller  and the non-volatile memory  is an ATA interface, other embodiments are contemplated in which the non-volatile memory  comprises a NAND Flash memory array to which the memory controller  writes directly. Preferably, each NAND Flash memory device in the array comprises an 8-bit wide data device and the devices are arranged such that the memory controller  performs 16-bit or 32-bit wide write accesses to the non-volatile memory  to increase the write rate, thereby further decreasing the flush operation time. Still further, although embodiments have been described in which the non-volatile memory  comprises FLASH or micro-disk technology, other embodiments may employ NVRAM or any other type of non-volatile storage technology, to which the data may be flushed from the cache memory  in a time-effective and power-effective manner.","Finally, those skilled in the art should appreciate that they can readily use the disclosed conception and specific embodiments as a basis for designing or modifying other structures for carrying out the same purposes of the present invention without departing from the scope of the invention as defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
