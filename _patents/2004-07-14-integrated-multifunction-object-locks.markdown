---
title: Integrated multi-function object locks
abstract: A single lock word comprises an identifier field for storing a thread identifier associated with a first thread obtaining a lock on an object; an inflation field for storing a fat lock bit upon inflation of the lock on the object; and a contention field for storing a contention bit in response to an attempt by a second thread to obtain a lock on the object. The values of the single lock word are verified with a single memory fetch instruction. When unlocking an object, a single memory fetch instruction can be used to read the lock word to: (1) determine whether thread T is still the current owner of the lock, and (2) determine the states of inflation and/or contention (i.e., determine whether the fat lock and/or contention bits have been set).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07447861&OS=07447861&RS=07447861
owner: International Business Machines Corporation
number: 07447861
owner_city: Armonk
owner_country: US
publication_date: 20040714
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention generally relates to object locks, and more particularly, to a locking method for Java objects that conserves computing resources by allowing various steps to be executed with a single memory fetch instruction.","A Java Virtual machine (JVM) (Java is a trademark of Sun Microsystems Corp.) is used to support a synchronization primitive known as a \u201cmonitor\u201d or \u201clock\u201d on each Java object allocated in a system. In general, a thread or the like will obtain a lock on an object in order to perform some type of command using the object. A lock is typically used to prevent a conflict from occurring when another thread attempts to use the object. With respect to object management, an efficient implementation of object locks allows for the optimal performance of a JVM implementation. A number of locking methods are cited in U.S. Patent Application Publication No. US 2001\/0014905 A1, which is herein incorporated by reference.","According to a first aspect of the present invention, a method for handling object locks comprises storing a thread identifier associated with a first thread in an identifier field of a lock word upon establishment of a lock on an object by the first thread, wherein the lock word further comprises an inflation field for storing a fat lock bit and a contention field for storing a contention bit, and verifying the thread identifier stored in the identifier field and determining a state inflation and a state of contention by reading the lock word.","According to another aspect of the present invention, a method for handling object locks in a Java Virtual Machine comprises storing a thread identifier associated with a first thread in an identifier field of a lock word upon establishment of a lock on a Java object by the first thread, wherein the lock word further comprises an inflation field for storing a fat lock bit and a contention field for storing a contention bit, setting a contention bit in the contention field of the lock word in response to an attempt by a second thread to establish a lock on the Java object, verifying the thread identifier stored in the identifier field and determining a state of the fat lock bit and the contention bit by reading the lock word, releasing the lock on the Java object by the first thread, and inflating the lock in response to determining that the contention bit has been set in the contention field.","According to yet another aspect of the present invention, a unitary lock structure comprises an identifier field for storing a thread identifier associated with a first thread obtaining a lock on an object, an inflation field for storing a fat lock bit upon inflation of the lock on the object, and a contention field for storing a contention bit in response to an attempt by a second thread to obtain a lock on the object.","According to a further aspect of the present invention, a system comprises a lock engagement system for storing a thread identifier associated with a first thread in an identifier field of a lock word upon establishment of a lock on an object by the first thread, wherein the lock word further comprises an inflation field for storing a fat lock bit and a contention field for storing a contention bit, a lock contention system for setting the contention bit in response to an attempt by a second thread to establish a lock on the object, and a verification system for reading the lock word to verify the thread identifier stored in the identifier field and to determine a state of the fat lock bit and the contention bit.","According to a still further aspect of the present invention, a computer program product for handling object locks comprises a computer readable medium having computer readable program code embodied therein. The computer readable program code comprises computer readable program code configured to store a thread identifier associated with a first thread in an identifier field of a lock word upon establishment of a lock on an object by the first thread, wherein the lock word further comprises an inflation field for storing a fat lock bit and a contention field for storing a contention bit, computer readable program code configured to set the contention bit in response to an attempt by a second thread to establish a lock on the object, and computer readable program code configured to read the lock word to verify the thread identifier stored in the identifier field and to determine a state of the fat lock bit and the contention bit.","According to another aspect of the present invention, a system for deploying an application comprises a computer infrastructure being operable to store a thread identifier associated with a first thread in an identifier field of a lock word upon establishment of a lock on an object by the first thread, wherein the lock word further comprises an inflation field for storing a fat lock bit and a contention field for storing a contention bit, set the contention in response to an attempt by a second thread to establish a lock on the object, and verify the thread identifier stored in the identifier field and determine a state of the fat lock bit and the contention bit by reading the lock word.","According to yet another aspect of the present invention, computer software is embodied in a propagated signal. The computer software comprises instructions to cause a computer system to store a thread identifier associated with a first thread in an identifier field of a lock word upon establishment of a lock on an object by the first thread, wherein the lock word further comprises an inflation field for storing a fat lock bit and a contention field for storing a contention bit, set the contention bit in response to an attempt by a second thread to establish a lock on the object, and verify the thread identifier stored in the identifier field and determine a state of the fat lock bit and the contention bit by reading the lock word.","Other aspects and features of the present invention, as defined solely by the claims, will become apparent to those ordinarily skilled in the art upon review of the following non-limited detailed description of the invention in conjunction with the accompanying figures.","Three possible locking methods include the: (1) spin lock; (2) queue lock; and (3) compound lock. In general, a spin locking system stores, into an object, the identifier of a thread that locks an object. According to the spin locking method, when a thread \u201cT\u201d fails to acquire a lock on an object \u201cA\u201d (i.e., when another thread \u201cS\u201d already has a lock on the object \u201cA\u201d), the locking procedure is repeated until it succeeds. Specifically, an atomic machine command (an indivisible command), such as \u201ccompare#and#swap,\u201d is employed to lock or unlock an object in the following manner:",{"@attributes":{"id":"p-0016","num":"0015"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"10 \/*lock*\/"]},{"entry":[{},"20 while (compare_and_swap(&obj->lock,0,thread_id( ))= =0)"]},{"entry":[{},"30\u2003\u2003yield( );"]},{"entry":[{},"40 \/*obj access*\/"]},{"entry":[{},"..."]},{"entry":[{},"50 \/*unlock*\/"]},{"entry":[{},"60 obj->lock=0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As is apparent from the above program code, locking is performed at the 20th and 30th lines, with \u201cyield( )\u201d being repeated until a lock is acquired. The purpose of \u201cyield( )\u201d is the halting of the execution of a current thread, and the shifting of control to a scheduler. Generally, the scheduler selects and operates one of the other executable threads. However, the scheduler eventually operates the original thread later, and until a lock is acquired, a \u201cwhile\u201d statement is repetitively executed.","The condition provided for the \u201cwhile\u201d statement on the 20th line (i.e., compare_and_swap) is the comparison of \u201c0\u201d with the contents of field \u201cobj.fwdarw.lock,\u201d which is prepared for the object \u201cobj,\u201d and the writing of the thread identifier \u201c(thread_id( ))\u201d to its field when the comparison result is true. Therefore, when \u201c0\u201d is stored in the field that is prepared for the object \u201cobj,\u201d the absence of a thread that has acquired a lock is indicated. Thus, when unlocking is performed with the 50th line, \u201c0\u201d is stored in the field \u201cobj.fwdarw.lock.\u201d This field is one word, for example, but in actuality, the number of bits that is required is only that which is needed to store a thread identifier.","A queue lock system employs a queue to manage the threads that access an object. According to the queue lock method, when a thread \u201cT\u201d fails to lock an object \u201cA,\u201d the thread \u201cT\u201d adds itself to the queue for \u201cA,\u201d and is suspended. The unlocking code includes code for examining a queue to determine whether it is empty, whereafter, if it is determined the queue is not empty, one thread is extracted and the processing is resumed. A queue lock is implemented together with the scheduling mechanism for an Operating System (OS), and is provided as the API (Application Programming Interface) for the OS. For example, a semaphore or a Mutex variable is a typical queue lock system.","In a queue lock system, one word for space overhead is no longer adequate, tk and something less than 20 bytes is normally required. Further, since a common resource (i.e., a queue) is operated inside the lock or the unlock function, it should be noted that a specific lock is acquired or released.","With a compound locking system, a program ready-for multiple threads is written while taking into account the fact that it is to be executed by multiple threads. Thus, when a common resource is accessed, such access is protected by a lock. However, a library ready for multiple threads may be used by a single-thread program, or lock contentions may seldom occur, even when a program is executed by multiple threads. Actually, according to a profile for the execution of Java programs, for many applications, contentions related to object accessing seldom occur. Therefore, the sequence \u201clocking an object which is not locked, accessing the object, and unlocking the object\u201d is considered to be an execution path that is frequently followed.","In general, the locking processing is performed as follows.","(1) Acquisition of a light lock is attempted by an atomic command (e.g., compare_and_swap). If the lock is acquired, then object access is initiated. When the lock acquisition attempt fails, however, it is ascertained that the locking process has already been shifted to the fat lock method, or that, while the lock is still light, another thread has obtained a lock on the object;","(2) If the lock is already fat, a fat lock is acquired; and","(3) When a contention occurs during the light lock process, a light lock is acquired, after which the process is shifted to the process for a fat lock, which is then acquired (in the following explanation, this process is performed by using an \u201cinflate\u201d function).","In general, there are multiple implementations for the compound lock system depending on whether or not \u201cyield\u201d is performed for \u201cacquisition of the light lock\u201d in step (3) above. It should be noted, however, that in most typical compound locking systems, the \u201cthread identifier\u201d and the \u201cfat lock identifier\u201d are usually even numbers other than 0, and that the \u201cthread identifier\u201d is stored when the least significant bit of the lock field is 0, while the \u201cfat lock identifier\u201d is stored when the least significant bit is 1.","Referring to , illustrative lock words  and  in accordance with previous (e.g., compound) locking methods are shown. Specifically,  depicts an illustrative diagram for explaining the shifting of modes, and the states of a lock field (including a fat lock bit) and a contention bit in each mode, with state: (1) showing the state where a lock has not been acquired; (2) showing a light lock mode where a contention has not occurred; (3) showing a light lock mode where a contention has occurred (i.e., when a second thread \u201cS\u201d attempts to obtain a lock on an object already locked by thread \u201cT\u201d); and (4) showing a fat lock mode. As can been seen, the previous method illustrated by  relies on two separate lock structures\/words  and .","The first lock word  includes fields  and  for storing a thread or monitor identifier, and a fat bit (also referred to as a shape bit or an inflation bit), while the second word  includes a field  for storing a contention bit. The use of two separate lock words  and  becomes of particular importance in situations such as where a first thread wishes to unlock an object. Specifically, before the first thread \u201cT\u201d can unlock the object, it will determine: (1) whether it is still the current owner of the lock; and (2) the current states of the shape bit and the contention bit. To do this, both words  and  must be examined, which requires two separate memory fetch instructions.","In accordance with one aspect of the present invention, a unitary lock structure\/word is provided. The lock word may include an identifier field for storing a thread identifier associated with a first thread obtaining a lock on an object; an inflation field for storing a fat lock bit upon inflation of the lock on the object; and a contention field for storing a contention bit in response to an attempt by a second thread to obtain a lock on the object. Storage of these values in a single lock word allows them to be verified with a single memory fetch instruction. For example, when unlocking an object, a single memory fetch instruction can be used to read the lock word to: (1) determine whether thread T is still the current owner of the lock, and (2) determine the states of inflation and\/or contention (i.e., determine whether the fat lock and\/or contention bits have been set).","It should be understood that the phraseology associated with a thread engaging or obtaining a \u201clock on an object,\u201d is also referred to throughout the art as the thread \u201centering the monitor\u201d for the object. It should also be understood that although a typical embodiment of the present invention is to optimize Java object locks in a Java Virtual machine (JVM), the teachings described herein could be used to optimize any type of object locks. Thus, the present invention is not intended to be limited to a Java environment. Still yet, it should also be understood that in an illustrative embodiment, the present invention may be implemented in conjunction with a compound locking method. Although a description of an illustrative method according to the present invention will be set forth below, additional background information on compound locking methods can be found in the above-incorporated patent application. To this extent, it should be appreciated that the present invention is not limited to a compound locking method, rather, the teachings recited herein could be implemented in conjunction with other locking methods now known or later developed.","Referring now to , a system  that may optimize object locks in a JVM is depicted. As depicted, system  includes computer system  that may be used to carry out the functions of the present invention. In general, computer system  is intended to represent any type of computer system that is capable of utilizing object locks. For example, computer system  could be a desktop computer, a laptop computer or a workstation. Moreover, the teachings recited herein could be implemented on a stand-alone computer system (as shown), or over a network. In the case of the latter, computer system  could be a client or a server. Also, the network could be any type of network such as the Internet, a local area network (LAN), a wide area network (WAN), a virtual private network (VPN), etc.","Communication throughout the network could occur via a direct hardwired connection (e.g., serial port), or via an addressable connection that may utilize any combination of wireline and\/or wireless transmission methods. Moreover, conventional network connectivity, such as Token Ring, Ethernet, WiFi or other conventional communications standards could be used. Still yet, connectivity could be provided by conventional TCP\/IP sockets-based protocol. In this instance, an Internet service provider could be used to establish interconnectivity.","As depicted, computer system  generally includes processing unit , memory , bus , input\/output (I\/O) interfaces , external devices\/resources  and storage unit . Processing unit  may comprise a single processing unit, or be distributed across one or more processing units in one or more locations, e.g., on a client and server. Memory  may comprise any known type of data storage and\/or transmission media, including magnetic media, optical media, random access memory (RAM), read-only memory (ROM), a data cache, a data object, etc. Moreover, similar to processing unit , memory  may reside at a single physical location, comprising one or more types of data storage, or be distributed across a plurality of physical systems in various forms.","I\/O interfaces  may comprise any system for exchanging information to\/from an external source. External devices\/resources  may comprise any known type of external device, including speakers, a CRT, LED screen, hand-held device, keyboard, mouse, voice recognition system, speech output system, printer, monitor\/display, facsimile, pager, etc. Bus  provides a communication link between each of the components in computer system  and likewise may comprise any known type of transmission link, including electrical, optical, wireless, etc.","Storage unit  can be any system (e.g., a database, etc.) capable of providing storage for information As such, storage unit  could include one or more storage devices, such as a magnetic disk drive or an optical disk drive. In another embodiment, storage unit  includes data distributed across, for example, a local area network (LAN), wide area network (WAN) or a storage area network (SAN) (not shown). Although not shown, additional components, such as cache memory, communication systems, system software, etc., may be incorporated into computer system .","Shown in memory  of computer system  are various programs\/systems. Operating System (OS)  can be constituted by a kernel area and a user area, and can include an Application Programming Interface (API) . OS  can also include a thread library  that has a function for enabling an operation performed between the hardware of computer system , and an object locking program . Thread library  may also provide a function for queue locking. Object locking program  will be described in further detail below, but generally includes a monitor function and a locking and unlocking function according to the invention. If a database language is employed, a database management system  may be provided above OS , and a database application program  may be executed by the system. When the Java language is employed, a JVM  may be provided above OS , and an applet or Java application  may be executed by JVM . The execution of applet or Java application  can be performed by multi-threads. For the Java language, the monitor function and the locking and unlocking function may be installed in JVM . Further, JVM  may be implemented as a part of OS .","As further shown in , object locking system  includes, lock word system , lock engagement system , lock contention system , verification system , lock release system , and lock inflation system . Each of these systems is shown to conceptually represent program code that carries out the locking method of the present invention. In general, lock word system  will provide a unitary object lock word\/structure that is used for the locking method of the present invention. Specifically, the unitary lock word provided by lock word system  according to one aspect of the present invention includes fields for storing a thread monitor identifier, a fat lock bit and a contention bit.","Referring to , an illustrative lock word  according to an aspect of the present invention is depicted. In general, the four states shown depict: (1) the state where a lock has not been acquired; (2) the state where a light lock mode where a contention has not occurred; (3) the state where a light lock mode where a contention has occurred (i.e., when a second thread S attempts to obtain a lock on an object already locked by thread T); and (4) the state where a fat lock mode (e.g., the monitor has been inflated) has occurred.","All fields , , and  are combined into a single, unitary lock word . That is, lock word  includes an identifier field  for storing a thread identifier  or monitor identifier , a fat lock field  for storing a fat lock bit , and a contention field  for storing a contention (e.g., FLC) bit . The combination of fields ,  and  into a single lock word provides numerous functions particularly when a thread holding a lock on an object seeks to unlock the object. Specifically, as will be further indicated below, because all three fields ,  and  are combined into a single lock word, only one word must be read. That is, a single memory fetch instruction can be used to verify that a current thread still owns the lock on the object, and to determine the states inflation and contention via the states of fat lock bit  and\/or contention bit .","It should be appreciated that although not shown, lock word  could also include bits that act as a recursion counter. The primary function of such a counter would be to allow a thread which owns the monitor to enter the monitor recursively a certain number of times without incurring the penalty associated with monitor inflation. On re-entering the monitor, the owner need only increment the value in the recursion field. Typically, a value of zero would be stored in the recursion counter to indicate that the monitor has only been entered once. On exiting the monitor, a single compare instruction which verifies ownership, flatness and absence of contention (as will be further described below) is also sufficient to verify absence of recursion.","In any event, once unitary lock word  has been provided, the other systems within object locking program  of  will facilitate the use thereof in conjunction with the locking method of the present invention.","Listed below is illustrative pseudo-code for the locking method of the present invention:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u200210","void lock(Object* obj) {"]},{"entry":["\u200220","\u2003\/* flat lock path *\/"]},{"entry":["\u200230","if (compare_and_swap(&obj->lock, 0, thread_id( )))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u200240","return;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u200250","\/* inflated lock & inflation path *\/"]},{"entry":["\u200260","MonitorID mon = obtain_monitor(obj);"]},{"entry":["\u200270","monitor_enter(mon);"]},{"entry":["\u200280","\/* inflation loop *\/"]},{"entry":["\u200290","Word lockword;"]},{"entry":["100","while (( (lockword = obj->lock) & SHAPE_BIT) == 0) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["100","if (lockword == 0) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["110","if (compare_and_swap(&obj->lock, 0, thread_id( )))"]},{"entry":["120","{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["130","\/* this thread now owns the flat lock *\/"]},{"entry":["140","monitor_exit(mon);"]},{"entry":["150","return;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["160","}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["170","} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["180","if (compare_and_swap(&obj->lock,"]},{"entry":[{},"lockword, lockword |"]},{"entry":[{},"FLC_BIT))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["190","monitor_wait(mon, TIMEOUT);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["200","}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["210","\u2003}"]},{"entry":["220","}"]},{"entry":["230","void unlock(Object* obj) {"]},{"entry":["240","\u2003\/* flat lock path *\/"]},{"entry":["250","\u2003if (obj->lock == thread_id( )) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["260","\/* expected case -- extremely fast *\/"]},{"entry":["270","obj->lock = 0;"]},{"entry":["280","return;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["290","\u2003}"]},{"entry":["300","\u2003if (obj->lock & FLC_BIT) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["310","MonitorId mon = obtain_monitor(obj);"]},{"entry":["320","monitor_enter(mon);"]},{"entry":["330","obj->lock = mon & SHAPE_BIT;"]},{"entry":["340","monitor_notify(mon);"]},{"entry":["350","monitor_exit(mon);"]},{"entry":["360","return;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["370","\u2003}"]},{"entry":["380","\u2003\/* inflated lock path *\/"]},{"entry":["390","\u2003if (obj->lock & SHAPE_BIT) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["400","Word lockword = obj->lock;"]},{"entry":["410","if (no thread waiting on obj)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["420","if (better to deflate)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["430","obj->lock = 0; \/* deflation *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["440","monitor_exit(lockword & ~SHAPE_BIT);"]},{"entry":["450","return;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["460","\u2003}"]},{"entry":["470","}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"This code will be explained with specific reference to . Under the above code, when a thread \u201cT\u201d seeks to establish a lock on an object  it must first be ensured that no other thread already holds a lock on that object . If lock word  appears as it is shown in state (1) of , it means that the object is unlocked and thread \u201cT\u201d is free to establish a lock thereon. When the lock is established, lock engagement system  will move lock word  to state (2). Specifically, a thread identifier associated with thread \u201cT\u201d will be stored in identifier field . This process is known as a establishing a light lock without contention and is shown in lines 10-40 of the above code. Moreover, obtaining the lock on object  and storing the thread identifier is typically accomplished with an atomic compare and swap command. Specifically, lock engagement system  examines the data elements in lock word  at stage (1) to ensure that object  is unlocked, and replace the same with the data elements shown in stage (2).","Now assume that a second thread \u201cS\u201d wishes to acquire a lock on object . State (2) of lock word  will show thread \u201cS\u201d that a lock on object  is already held by thread \u201cT.\u201d Accordingly, if thread \u201cS\u201d wishes to engage a lock on object , it must wait until thread \u201cT\u201d unlocks object . However, to express that thread \u201cS\u201d desires a lock on object , a contention will be registered. Specifically, according to lines 80-220 of the above code, lock contention system  will set contention (e.g., FLC) bit  in contention field . This is shown in stage (3) of lock word  and lets thread \u201cT\u201d know that another thread wishes to obtain a lock on object .","After thread \u201cT\u201d has finished performing any operations using object , it can release the lock. However, because the contention bit has been set, thread T will inflate the lock as shown in state (4). Under the present invention, the unitary structure of lock word  provides significant advantages during the lock release process. Specifically, when release of the lock is desired, lines 230-390 of the above code will be followed. To this extent, verification system  will first verify that thread \u201cT\u201d is still the current holder of the lock on object , and will check\/determine the states of fat lock bit  and\/or contention bit . Since the present invention utilizes a single lock word , these functions can be carried out with a single memory fetch instruction (i.e., only a single word must be read). Line 250 of the above code states \u201cif (obj->lock==thread_id( )) {.\u201d This line tests whether the: (1) current thread is the lock owner; (2) fat lock bit is clear; (3) contention bit is clear; and, although not shown, (4) thread T has not recursively \u201centered the monitor.\u201d","In any event, at stage (3), verification system  will detect that contention (FLC) bit  has been set in contention field , while fat lock bit  is clear (i.e., has not been set). Thus, a contention state will be recognized. Thereafter, lock release system  will release the lock for inflation. To inflate the lock, lock inflation system  will move lock word  to state (4), as shown by lines 300-360 of the above code. Specifically, the data elements shown in stage (3) will be replaced by those shown in stage (4). To this extent, lock inflation system  will store a monitor identifier  in identifier field , and set the fat lock bit  in inflation field . Thereafter, other threads desiring a lock on object  such as thread \u201cS\u201d can form a queue (e.g., in accordance with the queue locking method described above) to establish the desired locks.","It should be understood that since lock word  is a unitary structure, the present invention will also take steps to help ensure that the contention bit  shown in stage (3) is not dropped. Specifically, because some of the functions performed herein, such as the release of the lock by thread T could be performed using non-atomic techniques, there could be a chance the contention field  could be inadvertently cleared before the lock is inflated. This could cause lock word  to be accidentally reverted to stage (1) instead of being inflated to stage (4). To help avoid this, a thread that has set contention bit  (e.g., thread \u201cS) will periodically \u201cwake-up\u201d and verify that contention bit  is still set. This function could be managed\/performed by lock contention system .","It should also be understood that the teachings of the present invention could be used in conjunction with any type of locking method. Still yet, it should be appreciated that the teachings of the present invention could be offered as a business method on a subscription or fee basis. For example, computer system  could be created, maintained and\/or deployed by a service provider that offers the functions described herein for customers. That is, a service provider could offer to manage\/optimize object locks for a customer as describe above.","It should also be understood that the present invention can be realized in hardware, software, a propagated signal, or any combination thereof. Any kind of computer\/server system(s)\u2014or other apparatus adapted for carrying out the methods described herein\u2014is suited. A typical combination of hardware and software could be a general purpose computer system with a computer program that, when loaded and executed, carries out the respective methods described herein. Alternatively, a specific use computer, containing specialized hardware for carrying out one or more of the functional tasks of the invention, could be utilized. The present invention can also be embedded in a computer program product or a propagated signal, which comprises all the respective features enabling the implementation of the methods described herein, and which\u2014when loaded in a computer system\u2014is able to carry out these methods. Computer program, propagated signal, software program, program, or software, in the present context mean any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following: (a) conversion to another language, code or notation; and\/or (b) reproduction in a different material form.","The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises\u201d and\/or \u201ccomprising,\u201d when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.","The foregoing description has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed, and obviously, many modifications and variations are possible. Such modifications and variations that may be apparent to a person skilled in the art are intended to be included within the scope of this invention as defined by the accompanying claims. For example, the configuration of object locking system  of  is intended to be illustrative only. As such, object locking system  could be represented by a different configuration of systems."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
