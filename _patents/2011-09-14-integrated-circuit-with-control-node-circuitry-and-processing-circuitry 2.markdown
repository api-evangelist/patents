---
title: Integrated circuit with control node circuitry and processing circuitry
abstract: Traditionally, providing parallel processing within a multi-core system has been very difficult. Here, however, a system is provided where serial source code is automatically converted into parallel source code, and a processing cluster is reconfigured “on the fly” to accommodate the parallelized code based on an allocation of memory and compute resources. Thus, the processing cluster and its corresponding system programming tool provide a system that can perform parallel processing from a serial program that is transparent to a user. Generally, a control node connected to the address and data leads of a host processor uses messages to control the processing of data in a processing cluster. The cluster includes nodes of parallel processors, shared function memory, a global load/store, and hardware accelerators all connected to the control node by message busses. A crossbar data interconnect routes data to the cluster circuits separate from the message busses.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09552206&OS=09552206&RS=09552206
owner: Texas Instruments Incorporated
number: 09552206
owner_city: Dallas
owner_country: US
publication_date: 20110914
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority to:\n\n","The disclosure relates generally to a processor and, more particularly, to a processing cluster.","Generally, system-on-a-chip designs (SoCs) are based on a combination of programmable processors (central processing units (CPUs), microcontrollers (MCUs), or digital signals processors (DSPs)), application-specific integrated circuit (ASIC) functions, and hardware peripherals and interfaces. Typically, processors implement software operating environments, user interfaces, user applications, and hardware-control functions (e.g., drivers). ASICs implement complex, high-level functionality such as baseband physical-layer processing, video encode\/decode, etc. In theory, ASIC functionality (unlike physical-layer interfaces) can be implemented by a programmable processor; in practice, ASIC hardware is used for functionality that is generally beyond the capabilities of any actual processor implementation.","Compared to ASIC implementations, programmable processors provide a great deal of flexibility and development productivity, but with a large amount of implementation overhead. The advantages of processors, relative to ASICs are:\n\n","Not surprisingly, a motivation for ASICs (other than hardware interfaces or physical layers) is to overcome the weaknesses of processor-based solutions. However, ASIC-based designs also have weaknesses that mirror the advantages of processor-based designs. The advantages of ASICs, relative to processors are:\n\n","Parallel processing, though very simple in concept, is very difficult to use effectively. It is easy to draw analogies to real-world example of parallelism, but computing does not share the same underlying characteristics, even though superficially it might appear to. There are many obstacles to executing programs in parallel, particularly on a large number of cores.","Turning to , an example of a conversion of a conventional serial program  to a functionally equivalent parallel program  can be seen. As shown, the serial program  (and the corresponding parallel program ) are generally comprised of code sequences or subroutines  and  that each include a number of instructions. In particular for code sequence , a value for a variable x is defined by function , and this variable x is used to define a value for a variable z in function  of code sequence . When executed as serial program  on a single processor, the value for variable x is transmitted from definition (by function ) to use (in function ) in a processor register or memory (cache) location, taking no more than a few cycles.","However, when code sequences  and  are converter from serial program  to parallel program  so as to be executed on two processors, several issues arise. First, sequences  and  are controlled by two separate program counters so that if the sequences  and  are left \u201cas is\u201d there is generally no way to ensure that the value for variable x is valid on the attempted read in sequence . In fact, in the simplest case, assuming both code sequences  and  execute sequentially starting at the same time, the value for variable x is not defined in time, because there are many more instructions to the definition of variable x in sequence  than there are to the use of variable x in sequence . Second, the value for variable x cannot be transmitted through a register or local cache because, although code sequences  and  have a common view of the address for variable x, the local caches map these addresses to two, physically distinct memory locations. Third, although not shown directly in the , there can be a second update of the value in variable x in sequence , but this subsequent update of variable x by sequence  should not occur until the previous value has been read by sequence .","For at least these reasons, the serial program  should be extensively modified to achieve correct parallel execution. First, sequence  should wait until sequence  signals that variable x has been written, which causes code sequence  to incurs delay . Delay  is generally a combination the cycles that sequence  takes to write variable x and delay  (the cycles to generate and transmit the signal). This signal is usually a semaphore or similar mechanism using shared memory that incurs the delay of writing and reading shared memory along with delays incurred for exclusive access to the semaphore. The write of variable x in sequence  also is subject to a barrier in that sequence  cannot be enabled to read variable x until sequence  can obtain the correct value for variable x. Generally, there can be no ordering hazards between writing the value and signaling that it has been written, caused by buffering, caching, and so forth, which usually delays execution in sequence  some number of cycles (represented by delay ) compared to writes of unshared data directly into a local cache.","Second, sequence  generally cannot read its local cache directly to obtain variable x because the write of variable x by sequence  would have caused an invalidation of the cache line containing code sequence . Sequence  incurs additional delay  to obtain the correct value from level-2 (L2) cache for sequence  or from shared memory. Third, sequence  generally imposes additional delays (due in part to delay ) on sequence  before any subsequent write by sequence  so that all reads in sequence  are complete before sequence  changes the value of variable x. This not only can stall the progress of sequence  but can also delay the new value of variable x such that sequence  has to wait again for the new value. Because of the number of cycles that sequence  spends obtaining the value for variable x, sequence  could potentially be ahead in subsequent iterations even though it was behind in the first iteration, but synchronization between sequences  and  tends to serialize both programs so there is little, if any, overlap.","The operations used to synchronize and ensure exclusive access to shared variables normally are not safe to implement directly in application code because of the hazards that can be introduced (e.g., timing-dependent deadlock). Thus, these operations are usually implemented by system calls, which cases delays due to procedure call and return and, possibly, context switching. The net effect is that a simple operation in sequential code (i.e., serial program ) can be transformed into a much more complex set of operations in the \u201cparallel\u201d code (i.e., parallel program ), and have a much longer execution time. The result is that parallel programming is limited to applications that do not incur significant overhead for parallel execution. This implies that: 1) there is essentially no data interaction between programs (e.g., web servers); 2) the amount of data shared is a small portion of the datasets used in computing (e.g., finite-element analysis); or 3) the number of computing cycles is very large in proportion to the amount of data shared (e.g., graphics).","Even if the overhead of parallel execution is small enough to make it worthwhile, overhead can significantly limit the benefit. This is especially true for parallel execution on more than two cores. This limitation is captured in a simplified equation for the effect, known as Amdahl's Law, which compares the performance of single-core execution to that of multiple-core execution. According to Amdahl's Law, a certain percentage of single-core execution cannot feasibly be executed in parallel because the overhead is too high. Namely, the overhead incurred is the sum of the percentage of time spent without parallel execution and the percentage of time spent for synchronization and communication.","Turning to , a graph can be seen that depicts speedup in execution rate versus parallel overhead for a multi-core systems (ranging from 2 to 16 cores), where speedup is the single-processor execution time divided by the parallel-processor execution time. As can be seen, the parallel overhead has to be close to zero to obtain a significant benefit from large number of cores. But, since the overhead tends to be very high if there is any interaction between parallel programs, it is normally very difficult to efficiently use more than one or two processors for anything but completely decoupled programs.","Further limiting the applicability of parallel processing is the cost of multiple cores. In , the die areas of processors , , and  are compared. Processor  has 16 high-performance general-purpose cores , processor  has 16 moderate-performance general-purpose cores , and processor  has 16 high-performance custom cores . As can be seen, the high-performance general-purpose processor  uses the largest amount of area, and the application-specific processor  uses the least amount of area.","Turning to , the throughput of processors , , and  can be seen. The block for processor  illustrates die area assuming that throughput (results ) is determined only by the basic operation required by an application\u2014assuming that only the functional units determine throughput, thus maximizing the operations per cycle per mm(comparable to what could be accomplished with a hard-wired ASIC). The block for processor  illustrates the effect of including loads, stores, branches, and procedure calls into the mix of operations, where it can be assumed that these operations (in sum) to represent roughly two-third of the cycles taken, reducing throughput by a factor of 3. To achieve the same throughput as that determined by the basic functions, the number of cores should be increased by a factor of 3 to compensate. The block for processor  illustrates the effect of adding system calls, synchronization, context switches, and so forth, which reduces throughput by another factor of 3, requiring a factor of 3 increase in the number of cores to compensate.","There is another dimension to the difficulty of parallel computing; namely, it is the question of how the potential parallelism in an application is expressed by a programmer. Programming languages are inherently serial, text-based. Transforming a serial language into a large number of parallel processes is a well-studied problem that has yielded very little in actual results.","Turning to , an example of a conversion of serial source code  to parallel implementation  with conventional symmetric multiprocessing (SMP) using OPENMP\u00ae (which is a register trademark of OpenMP Architecture Review Board Corp., 1906 Fox Drive Champaign, Ill. 61820) can be seen. OPENMP\u00ae programming involves using a set of pre-defined \u201cpragmas\u201d or compiler directives that allow the programmer to aid the compiler in locating opportunities for parallel execution. These \u201cpragmas\u201d are ignored by compilers that do not implement OPENMP\u00ae, so the source code can be compiled to execute serially, with equivalent results to the parallel implementation (though the parallel implementation can introduce errors that do not appear in the serial implementation).","As shown, this example illustrates the use of several directives, which are embedded in the text following the headers (\u201c#pragma omp\u201d). Specifically, these directives include loops  and  and function , and each of loops  and  respectively employs functions  and . This source code  is shown as a parallel implementation  and is executed on four threads over four processors. Since these threads are created by serial operating-system code , the threads are not generally created at exactly the same time, and this lack of overlap increases the overall execution time. Also, the input and result vectors are shared. Reading the input vectors generally can require synchronization periods -, -, -, and - to ensure there are no writers updating the data (a relatively short operation). Writing the results in write periods , , , , , , , and  can require synchronization periods -, -, -, and - because one thread can be updating the result vectors at any given time (even though in this case the vector elements being updated are independent, serializing writes is a general operation that applies to shared variables). After another synchronization and communication period -, -, -, and -, the threads obtain multiple copies of the result vectors and compute function .","As shown, there can be significant overhead to parallel execution and a lack of parallel overlap, which is why parallel execution is made conditional on the vector length. It might be uncommon for the compiler to chose to implement the code in parallel, as a function of the system and the average vector length. However, when the code is implemented in parallel, there are a couple of subtle issues related to the way the code is written. To improve efficiency, the programmer should recognize that the expression for function  can be executed by multiple threads and obtain the same value and should explicitly declare function  as a private variable even though the expression that assigns function  contains only shared variables. Declaring function  as shared would result in four threads serializing to perform the same, lengthy computation to update the shared variable function  with the same value. This serialization time is on the order of four times the amount of time taken to complete the earlier, parallel vector adds, making it impossible to benefit from parallel execution and making vector length the wrong criteria for implementing the code in parallel since this serialization time is directly proportional to vector length. Furthermore, whether or not function  can be private is a function of the expression that assigns the value. For example, assume that function  is later changed to include a shared variable \u201coffset\u201d as follows:","(1) scale=sum(a,0,n)+sum(z,0,n)+offset++;","In this case, function  should be declared as shared, but it is insufficient. This change implies that the code should not be allowed to execute in parallel because of serialization overhead. Code development and maintenance not only includes the target functionality, but also how changes in the functionality affect and interact with the surrounding parallelism constructs.","There is another issue with the code  in this example, namely, an error introduced for the purpose of illustration. The loop termination variable n is declared as private, which is correct because variable n is effectively a constant in each thread. However, private variables are not initialized by default, so variable n should be declared as shared so that the compiler initializes the value for all threads. This example works well when the compiler chooses a serial implementation but fails for a parallel one. Since this code  is conditionally parallel, the error is not easy to test for.","This example is a very simple error because it will likely usually fail, assuming that the code can be forced to execute in parallel (depending on how uninitialized variables are handled). However, there are an almost infinite number of synchronization and communication errors that can be introduced with OpenMP directives (this example is a communication error)\u2014and many of these can result in intermittent failures depending on the relative timing and performance of the parallel code, as well as the execution order chosen by the scheduler.","Thus, there is a need for an improved processing cluster and associated tool chain.","An embodiment of the present disclosure, accordingly, provides a method. The method comprises receiving source code, wherein the source code includes an algorithm module that encapsulates an algorithm kernel within a class declaration; traversing the source code with a system programming tool to generate hosted application code from the source code for a hosted environment; allocating compute and memory resources of a processor based at least in part on the source code with the system programming tool, wherein the processor includes a plurality of processing nodes and a processing core; generating node application code for a processing environment based at least in part on the allocated compute and memory resources of the processor with the system programming tool; and creating a data structure in the processor based at least in part on the allocated compute and memory resources with the system programming tool.","An embodiment of the present disclosure, accordingly, provides an apparatus. The apparatus comprises address leads; data leads; a host processor coupled to the address leads and the data leads; memory circuits coupled to the address leads and the data leads; and processing cluster circuitry coupled to the address leads and the data leads, the processing cluster circuitry including: control node circuitry having address inputs coupled to the address leads, data inputs coupled to the data leads, and serial messaging leads; and parallel processing circuitry coupled to the serial messaging leads.","An embodiment of the present disclosure, accordingly, provides an apparatus. The apparatus comprises address leads; data leads; a host processor coupled to the address leads and the data leads; memory circuits coupled to the address leads and the data leads; and processing cluster circuitry coupled to the address leads and the data leads, the processing cluster circuitry including: global load store circuitry having external data inputs and outputs coupled to the data leads, and node data leads; and parallel processing circuitry coupled to the node data leads.","An embodiment of the present disclosure, accordingly, provides an apparatus. The apparatus comprises address leads; data leads; a host processor coupled to the address leads and the data leads; memory circuits coupled to the address leads and the data leads; and processing cluster circuitry coupled to the address leads and the data leads, the processing cluster circuitry including: shared function memory circuitry data inputs and outputs coupled with the data leads; and parallel processing circuitry coupled to the data leads.","An embodiment of the present disclosure, accordingly, provides an apparatus. The apparatus comprises address leads; data leads; a host processor coupled to the address leads and the data leads; memory circuits coupled to the address leads and the data leads; and processing cluster circuitry coupled to the address leads and the data leads, the processing cluster circuitry including node circuitry having parallel processing circuitry coupled to the data leads.","An embodiment of the present disclosure, accordingly, provides an apparatus. The apparatus comprises address leads; data leads; a host processor coupled to the address leads and the data leads; memory circuits coupled to the address leads and the data leads; and processing cluster circuitry coupled to the address leads and the data leads, the processing cluster circuitry including first circuitry, second circuitry, and third circuitry coupled to the data leads, serial messaging leads connected between the first circuitry, the second circuitry, and the third circuitry, and the first, second, and third circuitry each including messaging circuitry for sending and receiving messages.","An embodiment of the present disclosure, accordingly, provides an apparatus. The apparatus comprises address leads; data leads; a host processor coupled to the address leads and the data leads; memory circuits coupled to the address leads and the data leads; and processing cluster circuitry coupled to the address leads and the data leads, the processing cluster circuitry including reduced instruction set computing (RISC) processor circuitry for executing program instructions in a first context and a second context and the RISC processor circuitry executing an instruction to shift from the first context to the second context in one cycle.","The foregoing has outlined rather broadly the features and technical advantages of the present disclosure in order that the detailed description of the disclosure that follows may be better understood. Additional features and advantages of the disclosure will be described hereinafter which form the subject of the claims of the disclosure. It should be appreciated by those skilled in the art that the conception and the specific embodiment disclosed may be readily utilized as a basis for modifying or designing other structures for carrying out the same purposes of the present disclosure. It should also be realized by those skilled in the art that such equivalent constructions do not depart from the spirit and scope of the disclosure as set forth in the appended claims.","Refer now to the drawings in which depicted elements are, for the sake of clarity, not necessarily shown to scale and in which like or similar elements are designated by the same reference numeral through the several views.","1. Overview","Turning to , an example of a conversion of a serial program  to a parallel implementation  in accordance with an embodiment of the present disclosure can be seen. Here, the serial program  is emulated in a hosted environment (i.e., C++) such that for serial execution: (1) data dependencies are generally resolved using procedure call order; (2) there are true object instantiations; and (3) the objects are communicated using pointers to public input structures. To accomplish this, an iterator  and traverser  are employed to restructure the serial program  (which is generally comprise of a read thread  that receives system inputs , serial modules , , , and , and a write thread  that writes system outputs  to create parallel implementation .","However, the source code for the serial program  is structured for autogeneration. When structure for autogeneration, an interate-over-read thread module  is generated to perform system reads for parallel modules  (which is comprised of parallel iterations of serial module ), and the outputs from parallel module  are provided to parallel module  (which is generally comprised of parallel iterations of the serial modules  and ). This parallel module  can then use parallel modules  and  (which are generally comprised of parallel iterations of serial module ) to generate outputs for read thread .","With the parallel implementation , there are several desirable features. First, data dependencies are generally resolved by hardware. Second, there are no objects; instead standalone programs with \u201cglobal\u201d variables in private contexts are employed. Third, programs can communicate using hardware pointers and symbolic linkage of \u201cexterns\u201d in source programs. Fourth, there is variable allocation of computing resources, and sources can be merged (e.g. modules  and ) for efficiency.","In order to implement such a parallel processing environment, a new architecture is generally desired. In , a system  in accordance with an embodiment of the present disclosure can be seen. This system  employs software tools that can compile source code (from a user) into a parallel implementation on hardware . Namely, system  employs a compiler  and algorithm prototyping tool  to generate assembly  and binaries  from algorithm kernels  and data-movement kernels . These kernels  and  are typically written in a high-level language (i.e., C++) and are structured to be autogenerated into a parallel implementation. System programming tool  can provide controls to the compiler  and algorithm prototyping tool  (based at least in part on the system specifications ) to assist in generating the assembly  and binaries  for hardware  and can provide controls directly to hardware  to implement message, control, and configuration data structures. Debugging tool  can also be used to assist in implement message, control, and configuration data structures. Other applications  can also be implemented through dynamic links . Dynamic scheduling tool  and performance models  may also be implemented. Effectively, the system programming tool  and complier  (as well as other system tools) configure the hardware  to conform to a desired parallel implementation based on the application or algorithm kernel  and data-movement kernel .","In , a system interconnect diagram  for hardware  can be seen. As shown, the hardware  is generally comprised of three layers , , and . The first layer  generally includes nodes - to -N, which schedule programs, read input variables (input data), and write output variables (output data). Generally, these nodes - to -N perform operations. The second layer  is a messaging layer that includes wrappers or node wrappers - to -N, and the third layer  is an interconnect layer that uses data interconnect protocols - to -N (which are generally separate and independent of the messaging in layer ), and data interconnect  to link nodes - to -N together in the desired parallel implementation.","Preferably, dataflow for hardware  is designed to minimize the cost of data communication and synchronization. Input variables to a parallel program can be assigned directly by a program executing on another core. Synchronization operates such that an access of a variable implies both that the data is valid, and that it has been written only once, in order, by the most recent writer. The synchronization and communication operations require no delay. This is accomplished using a context-management state, which can introduce interlocks for correctness. However, dataflow is normally overlapped with execution and managed so that these stalls rarely, if ever, occur. Furthermore, techniques of system  generally minimize the hardware costs of parallelism by enabling nearly unlimited processor customization, to maximize the number of operations sustained per cycle, and by reducing the cost of programming abstractions\u2014both high-level language (HLL) and operating system (OS) abstractions\u2014to zero.","One limitation on processor customization is that the resulting implementation should remain an efficient target of a HLL (i.e. C++) optimizing compiler, which is generally incorporated into complier . The benefits typically associated with binary compatibility are obtained by having cores remain source-code compatible within a particular set of applications, as well as designing them to be efficient targets of a compiler (i.e. complier ). The benefits of generality are obtained by permitting any number of cores to have any desired features. A specific implementation has only the required subset of features, but across all implementations, any general set of features is possible. This can include unusual data types that are not normally associated with general-purpose processors.","Data and control flow are performed off \u201ccritical\u201d paths of the operations used by the application software. This uses superscalar techniques at the node level, and uses multi-tasking, dataflow techniques, and messaging at the system level. Superscalar techniques permit loads, stores, and branches to be performed in parallel with the operational data path, with no cycle overhead. Procedure calls are not required for the target applications, and the programming model supports extensive in-lining even though applications are written in a modular form. Loads and stores from\/to system memory and peripherals are performed by a separate, multi-threaded processor. This enables reading program inputs, and writing outputs, with no cycle overhead. The microarchitecture of nodes - to -N also supports fine-grained multi-tasking over multiple contexts with 0-cycle context switch time. OS-like abstractions, for scheduling, synchronization, memory management, and so forth are performed directly in hardware by messages, context descriptors, and sequencing structures.","Additionally, processing flow diagrams are normally developed as part of application development, whether programmed or implemented by an ASIC. Typically, however, these diagrams are used to describe the functionality of the software, the hardware, the software processes interacting in a host environment, or some combination thereof. In any case, the diagrams describe and document the operation of the hardware and\/or software. System , instead, directly implements specifications, without requiring users to see the underlying details. This also maintains a direct correspondence between the graphical representation and the implementation, in that nodes and arcs in the diagram have corresponding programs (or hardware functions) and dataflow in the implementation. This provides a large benefit to verification and debug.","2. Parallelism","Typically, \u201cparallelism\u201d refers to performing multiple operations at the same time. All useful applications perform a very large number of operations, but mainstream programming languages (such as C++) express these operations using a sequential model of execution. A given program statement is \u201cexecuted\u201d before the next, at least in appearance. Furthermore, even applications that are implemented by multiple \u201cthreads\u201d (separately executed binaries) are forced by an OS to conform to an execution model of time-multiplexing on a single processor, with a shared memory that is visible to all threads and which can be used for communication\u2014this fundamentally imposes some amount of serialization and resource contention on the implementation.","To achieve a high level of parallelism, it should be possible to overlap any operations expressed by the original application program or programs, regardless of where in the HLL source operations appear. The only useful measure of overlap counts only the operations that matter to the end result of the application, not those that are required for flow control, abstractions, or to achieve correctness in a parallel system. The correct measure of parallelism effectiveness is throughput\u2014the number of results produced per unit time\u2014not utilization, or the relative amount of time that resources are kept busy doing something.","Ideally, the degree of overlap should be determined only by two fundamental factors: data dependencies and resources. Data dependencies capture the constraint that operations cannot have correct results unless they have correct inputs, and that no operation can be performed in zero time. Resources capture the constraint of cost\u2014that it's not possible, in general, to provide enough hardware to execute all operations in parallel, so hardware such as functional units, registers, processors, and memories should be re-used. Ideally, the solution should permit the maximum amount of overlap permitted by a given resource allocation and a given degree of data interaction between operations. Parallel operations can be derived from any scope within an application, from small regions of code to the entire set of programs that implement the application. In rough terms, these correspond to the concepts of fine-, medium-, and coarse-grained parallelism.","\u201cInstruction parallelism\u201d generally refers to the overlapped execution of operations performed by instructions from a small region of a program. These instruction sequences are short\u2014generally not more than a few 10's of instructions. Moreover, an instruction normally executes in a small number of cycles\u2014usually a single cycle. And, finally, the operations are highly dependent, with at least one input of every operation, on average, depending on a previous operation within the region. As a result, executing instructions in parallel can require very high-bandwidth, low-latency data communication between operations: on the order of the number of parallel operations times the number of operands per operation, communicated in a single cycle via registers or direct forwarding. This data bandwidth makes it very expensive to execute a large number of instructions in parallel using this technique, which is the reason its scope is limited to a small region of the program.","Supporting a high degree of processor customization, to enable efficient multi-core systems, can reduce the effectiveness, or even feasibility, of compiler code generation. For a feature of the processor to be useful, the compiler  should be able to recognize a mapping from source code to the instruction set, to emit instructions using the feature. Furthermore, to the degree allowed by the processor resources, the compiler  should be able to generate code that has a high execution rate, or the number of desired operations per cycle.","Nodes - to -N are generally the basic target template for complier  for code generation. Typically, these nodes - to -N (which are discussed in greater detail below) include two processing units, arranged in a superscalar organization: a general-purpose, 32-bit reduced instruction set (RISC) processor; and a specialized operational data path customized for the application. An example of this RISC processor is described below. The RISC processor is typically the primary target for complier  but normally performs a very small portion of the application because it has the inefficiencies of any general-purpose processor. Its main purpose is to generally ensure correct operation regardless of source code (though not necessarily efficient in cycle count), to perform flow control (if any), and to maintain context desired by the operational data path.","Most of the customization for the application is in the operational data path. This has a dedicated operand data memory, with a variable number of read and write ports (accomplished using a variable number of banks), with loads to and stores from a register file with a variable number of registers. The data path has a number of functional units, in a very long instruction word (VLIW) organization\u2014up to an operation per functional unit per cycle. The operational data path is completely overlapped with the RISC processor execution and operand-memory loads and stores. Operations are executed at an upper limit of the rate permitted by data dependencies and the number of functional units.","The instruction packet for a node - to -N generally comprises a RISC processor instruction, a variable number of load\/store instructions for the operand memory, and a variable number of instructions for the functional units in the data path (generally one per functional unit). The compiler  schedules these instructions using techniques similar to those used for an in-order superscalar or VLIW microarchitecture. This can be based on any form of source code, but, in general, coding guidelines are used to assist the compiler in generating efficient code. For example, conditional branches should be used sparingly or not at all, procedures should be in-line, and so on. Also, intrinsics are used for operations that cannot be mapped well from standard source code.","There is also another dimension of instruction parallelism. It is possible to replicate the operational data path in a single input multiple data (SIMD) organization, if appropriate to the application, to support a higher number of operations per cycle. This dimension is generally hidden from the compiler  and is not usually expressed directly in the source code, allowing the hardware  to be sized for the application.","\u201cThread parallelism\u201d generally refers to the overlapped execution of operations in a relatively large span of instructions. The term \u201cthread\u201d refers to sequential execution of these instructions, where parallelism is accomplished by overlapping multiples of these instruction sequences. This is a broad classification, because it includes entire programs executed in parallel, code at different levels of program abstraction (applications, libraries, run-time calls, OS, etc.), or code from different procedures within the same level of abstraction. These all share the characteristic that only moderate data bandwidth is required between parallel operations (i.e., for function parameters or to communicate through shared data structures). However, thread parallelism is very difficult to characterize for the purposes of data-dependency analysis and resource allocation, and this introduces a lot of variation and uncertainty in the benefits of thread parallelism.","Thread parallelism is typically the most difficult type of parallelism to use effectively. The basic problem is that the term \u201cthread\u201d means nothing more than a sequence of instructions, and threads have no other, generalized characteristics in common with other threads. Typically, a thread can be of any length, but there is little advantage to parallel execution unless the parallel threads have roughly the same execution times. For example, overlapping a thread that executes in a million cycles with one that executes in a thousand cycles is generally pointless because there is a 0.1% benefit assuming perfect overlap and no interaction or interference.","Additionally, threads can have any type of dependency relationship, from very frequent access to shared, global variables, to no interaction at all. Threads also can imply exclusion, as when one thread calls another as a procedure, which implies that the caller does not resume execution until the callee is complete. Furthermore, there is not necessarily anything in the thread itself to describe these dependencies. The dependencies should be detected by the threads' address sequences, or the threads should perform explicit operations such as using lock mechanisms to generally provide correct ordering and dependency resolution.","Finally, a thread can be any sequence of any instructions, and all instructions have resource dependencies of some sort, often at several levels in the system such as caches and shared memories. It is impossible, in general, to schedule thread overlap so there is no resource contention. For example, sharing a cache between two threads increases the conflict misses in the cache, which has an effect similar to reducing the size of the cache for a single thread by a factor of four, so what is overlapped consists of a much higher percentage of cache reload time due both to higher conflict misses and to an increase reload time resulting from higher demand on system memory. This is one of the reasons that \u201cutilization\u201d is a poor measure of the effectiveness of overlapped execution, as opposed to throughput. Overlapped stalls increase utilization but do nothing for throughput, which is what users care about.","System , however, uses a specific form of \u201cthread\u201d parallelism, which is based on objects, that avoids these difficulties, as illustrated in . This generalized execution sequence  shows a memory-to-memory operation, which is structured in the form of three object instances: (1) a read thread  that accesses memory  and places data into an input data structure that is a public variable of a second object; (2) an execution module  that operates on this data and produces results into the input variable of a third object; and (3) a write thread  that writes the results of the execution module back into memory . Sequential execution is maintained by calling the member functions of these objects , , and  in sequence from left to right. Structuring programs in this way provides several advantages.","Objects serve as a basic unit for scheduling overlapped execution because each object module (i.e., , , and ) can be characterized by execution time and resource utilization. Objects implement specific functionality, instead of control flow, and execution time can be determined from parameters such as buffer size and\/or the degree of loop iteration. As a result, objects (i.e., , , and ) can be scheduled onto available resources with a high degree of control over the effectiveness of overlapped execution.","Objects also typically have well-defined data dependencies given directly by the pointers to input data structures of other objects. Inputs are typically read-only. Outputs are typically write-only, and general read\/write access is generally only allowed to variables contained within the objects (i.e., , , and ). This provides a very well-structured mechanism for dependency analysis. It has benefits to parallelism similar to those of functional languages (where functional languages can communicate through procedure parameters and results) and closures (where closures are similar to functional languages except that a closure can have local state that is persistent from one call to the next, whereas in functional languages local variables are lost at the end of a procedure). However, there are advantages to using objects for this purpose instead of parameter-passing to functions, namely\n\n","\u201cData Parallelism\u201d generally refers to the overlapped execution of operations which have very few (or no) data dependencies, or which have data dependencies that are very well structured and easy to characterize. To the degree that data communication is required at all, performance is normally sensitive only to data bandwidth, not latency. As a side effect, the overlapped operations are typically well balanced in terms of execution time and resource requirements. This category is sometimes referred to as \u201cembarrassingly parallel.\u201d Typically, there are four types of data parallelism that can be employed: client-server, partitioned-data, pipelined, and streaming.","In client-server systems, computing and memory resources are shared for generally unrelated applications for multiple clients (a client can be a user, a terminal, another computing system, etc.). There are few data dependencies between client applications, and resources can be provided to minimize resource conflicts. The client applications typically require different execution times, but all clients together can present a roughly constant load to the system that, combined with OS scheduling, permits efficient use of parallelism.","In partitioned-data systems, computing operates on large, fixed-size datasets that are mostly contained in private memory. Data can be shared between partitions, but this sharing is well structured (for example, leftmost and rightmost columns of arrays in adjacent datasets), and is a small portion of the total data involved in the computation. Computing is naturally overlapped, since all compute nodes perform the same operations on the same amount of data.","In pipelined systems, there is a large amount of data sharing between computations, but the application can be divided into long phases that operate on large amounts of data and that are independent of each other for the duration of the phase. At the end of a phase, data is passed to the next phase. This can be accomplished either by copying data directly, by exchanging pointers to the data, or by leaving the data in place and swapping to the program for the next phase to operate on the data. Overlap is accomplished by designing the phases, and the resource allocation, so that each phase can require approximately the same execution time.","In streaming systems, there is a large amount of data sharing between computations, but the application can be divided into short phases that operate on small amounts of input data. Data dependencies are satisfied by overlapping data transmission with execution, usually with a small amount of buffering between phases. Overlap is accomplished by matching each phase to the overall requirements of end-to-end throughput.","The framework of system  generally encompasses all of these levels of parallel execution, enabling them to be utilized in any combination to increase throughput for a given application (the suitability of a particular granularity depends on the application). This uses a structured, uniform set of techniques for rapid development, characterization, robustness, and re-use.","Turning now to , a generalized form of a streaming system can be seen. This generalized object-based sequential execution sequence  enables point-to-point communication of any set of data, of any types, between any source-destination pairs. In sequence or use-case graph , there are numerous modules , , , , , , and , and hardware elements , , , and . The execution sequence is defined by a user. Because the execution sequence  is sequential, no parallelism primitives are exposed to the programmer. Instead, parallelism is implemented by the system , mapping this sequential model to a \u201ccorrect\u201d parallel execution model.","Even though this example in  generally conforms to a serial execution model, it also can be mapped almost directly onto a parallel execution model over multi-core processor  shown in . Object instances (and hardware accelerators) can execute using read-only input and read\/write internal state with write-only outputs through pointers to external state (with no local memory allocated for outputs). This results in the possibility that execution can be completely overlapped, with some additional requirement that there be a mechanism to resolve dependencies between sources and destinations. Parallel readers and writers of state are explicitly and clearly defined, and there is a writer for any shared state.","The dependency mechanism generally ensures that destination objects do not execute until all input data is valid and that sources do not over-write input data until it is no longer desired. In system , this mechanism is implemented by the dataflow protocol. This protocol operates in the background, overlapped with execution, and normally adds no cycles to parallel operation. It depends on compiler support to indicate: 1) the point in execution in which a source has provided all output data, so that destinations can begin execution; and 2) the point in execution where a destination no longer can require input data, so it can be over-written by sources. Since programs generally behave such that inputs are consumed early in execution, and outputs are provided late, this permits the maximum amount of overlap between sources and destinations\u2014destinations are consuming previous inputs while sources are computing new inputs.","The dataflow protocol results in a fully general streaming model for data parallelism. There is no restriction on the types of, or the total size of, transferred data. Streaming is based on variables declared in source code (i.e., C++), which can include any user-defined type. This allows execution modules to be executed in parallel, for example modules  and , and also allows overall system throughput to be limited by the block that has the longest latency between successive outputs (the longest cycle time from one iteration to the next). With one exception, this permits the mapping of any data-parallel style onto a system .","An exception to mapping data-parallel systems arises in partitioned-data parallelism as shown in . Here, the same execution module is replicated multiple times to operate on different portions of the same dataset. System  includes mechanisms for extensive data sharing between multiple instances of the same object class executing the same program (this is described as local context management). In this case, multiple objects executing in parallel can be considered, logically, as a single instance of the object operating on a large context.","As already mentioned, data parallelism is not effective unless the overlapped threads have roughly the same execution time. This problem is overcome in system  using static scheduling to balance execution time within throughput requirements (assuming there are sufficient resources). This scheduling increases the throughput of long threads (with the same effect as reducing execution time) by replicating objects and partitioning data, and increases the effective execution time of short threads by having them share computing resources\u2014either multi-tasking on a shared compute node, or by physically combining source code into a single thread.","3. General Processor Architecture","3.1. Example Application","An example of application for an SOC that performs parallel processing can be seen in . In this example, an imaging device  is shown, and this imaging device  (which can, for example, be a mobile phone or camera) generally comprises an image sensor , an SOC , a dynamic random access memory (DRAM) , a flash memory , display , and power management integrated circuit (PMIC) . In operation, the image sensor  is able to capture image information (which can be a still image or video) that can be processed by the SOC  and DRAM  and stored in a nonvolatile memory (namely, the flash memory ). Additionally, image information stored in the flash memory  can be displayed to the use over the display  by use of the SOC  and DRAM . Also, imaging devices  are oftentimes portable and include a battery as a power supply; the PMIC  (which can be controlled by the SOC ) can assist in regulating power use to extend battery life.","There are a variety of processing operations that can be performed by the SOC  (as employed in imaging device . In , an example of image processing can be seen. In this example, a still image or picture is \u201cdigitally refocused.\u201d Specifically, SOC  is able to process the image information (for a single image) so as to change the focus from the first person to the third person.","3.2. SOC","In , an example of a system-on-chip or SOC  is depicted in accordance with an embodiment of the present disclosure. This SOC  (which is typically an integrated circuit or IC, such as an OMAP\u2122 integrated circuit) generally comprises a processing cluster  (which generally performs the parallel processing described above) and a host processor  that provides the hosted environment (described and referenced above). The host processor  can be wide (i.e., 32 bits, 64 bits, etc.) RISC processor (such as an ARM Cortex-A9) and that communicates with the bus arbitrator , buffer , bus bridge  (which allows the host processor  to access the peripheral interface  over interface bus or Ibus ), hardware application programming interface (API) , and interrupt controller  over the host processor bus or HP bus . Processing cluster  typically communicates with functional circuitry  (which can, for example, be a charged coupled device or CCD interface and which can communicate with off-chip devices), buffer , bus arbitrator , and peripheral interface  over the processing cluster bus or PC bus . With this configuration, the host processor  is able to provide information (i.e., configure the processing cluster  to conform to a desired parallel implementation) through API , while both the processing cluster  and host processor  can directly access the flash memory  (through flash interface ) and DRAM  (through memory controller ). Additionally, test and boundary scan can be performed through Joint Test Action Group (JTAG) interface .","3.3. Processing Cluster","Turning to , an example of the parallel processing cluster  is depicted in accordance with an embodiment of the present disclosure. Typically, processing cluster  corresponds to hardware . Processing cluster  generally comprises partitions - to -R which include nodes - to -N, node wrappers - to -N, instruction memories - to -R, and bus interface units or (BIUs) - to -R (which are discussed in detail below). Nodes - to -N are each coupled to data interconnect  (through its respectively BIU - to -R and the data bus ), and the controls or messages for the partitions - to -R are provided from the control node  through the message bus . The global load\/store (LS) unit  and shared function-memory  also provide additional functionality for data movement (as described below). Additionally, a level 3 or L3 cache , peripherals  (which are generally not included within the IC), memory  (which is typically flash memory  and\/or DRAM  as well as other memory that is not included within the SOC ), and hardware accelerators (HWA) unit  are used with processing cluster . An interface  is also provided so as to communicate data and addresses to control node .","In , the data movement through processing cluster  can be seen. The read threads fetch data from memory  or peripherals  and write into the data memory for nodes - to -N or to hardware accelerators units . These read threads are generally controlled by the GLS unit . The write threads are outputs from nodes - to -N written to memory  or peripherals  or from hardware accelerators unit , which is also generally controlled by the GLS unit . Node-to-node writes transmit data from one node (i.e., -) to another node (i.e., -), based on a node (i.e., -) executing an output instruction. Node-to-HWA writes transmit data from a node (i.e., -) to the hardware-accelerator wrapper (within hardware accelerators unit ). From a node's (i.e., -) perspective, these node-to-HWA writes appear as a node-to-node write but are treated differently by the destination. HWA-to-node writes transmit data from a hardware accelerator to a destination node (i.e., -). At the destination node (i.e., -), it is treated as a node-to-node write.","Multi-cast threads are also possible. Multi-cast threads are generally any combination of the above types, with the limitation that the same source data is sent to all destinations. If the source data is not homogeneous for all destinations, then the multiple-output capability of the destination descriptors is used instead, and output-instruction identifiers are used to distinguish destinations. Destination descriptors can have mixed types of destinations, including nodes, hardware accelerators, write threads, and multi-cast threads.","Processing cluster  generally uses a \u201cpush\u201d model for data transfers. The transfers generally appear as posted writes, rather than request-response types of accesses. This has the benefit of reducing occupation on global interconnect (i.e., data interconnect ) by a factor of two compared to request-response accesses because data transfer is one-way. There is generally no desire to route a request through the interconnect , followed by routing the response to the requestor, resulting in two transitions over the interconnect . The push model generates a single transfer. This is important for scalability because network latency increases as network size increases, and this invariably reduces the performance of request-response transactions.","The push model, along with the dataflow protocol (i.e., - to -N), generally minimize global data traffic to that used for correctness, while also generally minimizing the effect of global dataflow on local node utilization. There is normally little to no impact on node (i.e., -) performance even with a large amount of global traffic. Sources write data into global output buffers (discussed below) and continue without requiring an acknowledgement of transfer success. The dataflow protocol (i.e., - to -N) generally ensures that the transfer succeeds on the first attempt to move data to the destination, with a single transfer over interconnect . The global output buffers (which are discussed below) can hold up to 16 outputs (for example), making it very unlikely that a node (i.e., -) stalls because of insufficient instantaneous global bandwidth for output. Furthermore, the instantaneous bandwidth is not impacted by request-response transactions or replaying of unsuccessful transfers.","Finally, the push model more closely matches the programming model, namely programs do not \u201cfetch\u201d their own data. Instead, their input variables and\/or parameters are written before being invoked. In the programming environment, initialization of input variables appears as writes into memory by the source program. In the processing cluster , these writes are converted into posted writes that populate the values of variables in node contexts.","The global input buffers (which are discussed below) are used to receive data from source nodes. Since the data memory for each node - to -N is single-ported, the write of input data might conflict with a read by the local SIMD. This contention is avoided by accepting input data into the global input buffer, where it can wait for an open data memory cycle (that is, there is no bank conflict with the SIMD access). The data memory can have 32 banks (for example), so it is very likely that the buffer is freed quickly. However, the node (i.e., -) should have a free buffer entry because there is no handshaking to acknowledge the transfer. If desired, the global input buffer can stall the local node (i.e., -) and force a write into the data memory to free a buffer location, but this event should be extremely rare. Typically, the global input buffer is implemented as two separate random access memories (RAMs), so that one can be in a state to write global data while the other is in a state to be read into the data memory. The messaging interconnect is separate from the global data interconnect but also uses a push model.","At the system level, nodes - to -N are replicated in processing cluster  analogous to SMP or symmetric multi-processing with the number of nodes scaled to the desired throughput. The processing cluster  can scale to a very large number of nodes. Nodes - to -N are grouped into partitions - to -R, with each having one or more nodes. Partitions - to -R assist scalability by increasing local communication between nodes, and by allowing larger programs to compute larger amounts of output data, making it more likely to meet desired throughput requirements. Within a partition (i.e., -), nodes communicate using local interconnect, and do not require global resources. The nodes within a partition (i.e., -) also can share instruction memory (i.e., -), with any granularity: from each node using an exclusive instruction memory to all nodes using common instruction memory. For example, three nodes can share three banks of instruction memory, with a fourth node having an exclusive bank of instruction memory. When nodes share instruction memory (i.e., -), the nodes generally execute the same program synchronously.","The processing cluster  also can support a very large number of nodes (i.e., -) and partitions (i.e., -). The number of nodes per partition, however, is usually limited to 4 because having more than 4 nodes per partition generally resembles a non-uniform memory access (NUMA) architecture. In this case, partitions are connected through one (or more) crossbars (which are described below with respect to interconnect ) that have a generally constant cross-sectional bandwidth. Processing cluster  is currently architected to transfer one node's width of data (for example, 64, 16-bit pixels) every cycle, segmented into 4 transfers of 16 pixels per cycle over 4 cycles. The processing cluster  is generally latency-tolerant, and node buffering generally prevents node stalls even when the interconnect  is nearly saturated (note that this condition is very difficult to achieve except by synthetic programs).","Typically, processing cluster  includes global resources that are shared between partitions:\n\n","Because nodes - to -N can be targeted to scan-line-based, pixel-processing applications, the architecture of the node processors  (described below) can have many features that address this type of processing. These include features that are very unconventional, for the purpose of retaining and processing large portions of a scan-line.","In , an example of the first two stages of processing on Bayer image input. Node processors (i.e., ) generally do not operate on Bayer data directly, but instead on de-interleaved data. Bayer data is shown for illustration. The first processing stage is defective pixel correction (DPC). This stage for this example takes 312 pixels as input to generate two lines of 32 corrected output pixels: the locations of these pixels correspond to the hashed region of the input data, and inputs outside of the bordered region are input-only without corresponding output. The next processing stage is a 2-dimensional noise filter. This stage processes 160 pixels from the output of the DPC stage (after 2\u00bd iterations of DPC, each iteration generating 64 pixels) to generate 28 corrected and filtered pixels.","As shown in this example, each processing stage operates on a region of the image. For a given computed pixel, the input data is a set of pixels in the neighborhood of that pixel's position. For example, the right-most Gb pixel result from the 2D noise filter is computed using the 5\u00d75 region of input pixels surrounding that pixel's location. The input dataset for each pixel is unique to that pixel, but there is a large amount of re-use of input data between neighboring pixels, in both the horizontal and vertical directions. In the horizontal direction, this re-use implies sharing data between the memories used to store the data, in both left and right directions. In the vertical direction, this re-use implies retaining the content of memories over large spans of execution.","In this example, 28 pixels are output using a total of 780 input pixels (2.5\u00d7312), with a large amount of re-use of input data, arguing strongly for retaining most of this context between iterations. In a steady state, 39 pixels of input are required to generate 28 pixels of output, or, stated another way, output is not valid in 11 pixel positions with respect to the input, after just two processing stages. This invalid output is recovered by recomputing the output using a slightly different set of input data, offset so that the re-computed output data is contiguous with the output of the first computed output data. This second pass provides additional output, but can require additional cycles, and, overall, the computation is around 72% efficient in this example.","This inefficiency directly affects pixel throughput, because invalid outputs create the desire for additional computing passes. The inefficiency is directly proportional to the width of the input dataset, because the number of invalid output pixels depends on the algorithms. In this example, tripling the output width to 84 pixels (input width 95 pixels) increases efficiency from 72% to 87% (over 2\u00d7 reduction in inefficiency\u201428% to 13%). Thus, efficient use of resources is directly related to the width of the image that these resources are processing. The hardware should be capable of storing wide regions of the image, with nearly unrestricted sharing of pixel contexts both in the horizontal and vertical directions within these regions.","4. Application Programming Model","\u201cTop-level programming\u201d refers to a program that describes the operation of an entire use-case at the system level, including input from memory  and\/or peripherals . Namely, top-level programming generally defines a general input\/output topology of algorithm modules, possibly including intermediate system memory buffers and hardware accelerators, and output to memory  and\/or peripherals .","A very simple, conceptual example, for a memory-to-memory operation using a single algorithm module is shown in . This example excludes many details, and is not functionally correct, but is simplified for illustration. This also is not how the program is actually structured for system , but simply shows the logical flow. For example, the read and write threads are not shown as distinct objects in the example.","In this example, the top-level program source code  generally corresponds to flow graph . As shown, code  includes an outer FOR loop that iterates over an image in the vertical direction, reading from de-interleaved system frame buffers (R[i], Gr[i], Gb[i], B[i]) and writing algorithm module inputs. The inputs are four circular buffers in the algorithm object's input structure, containing the red (R), green near red (Gr), green near blue (Gb), and blue (B) pixels for the iteration. Circular buffers are used to retain state in the vertical direction from one invocation to the next, using a fixed amount of statically-allocated memory. Circular addressing is expressed explicitly in this example, but nodes (i.e., -) directly support circular addressing, without the modulus function, for example. After the algorithm inputs are written, the algorithm kernel is called though the procedure \u201crun\u201d defined for the algorithm class. This kernel iterates single-pixel operations, for all input pixels, in the horizontal direction. This horizontal iteration is part of the implementation of the \u201cLine\u201d class. Multiple instances of the class (not relevant to this example) can be used to distinguish their contexts. Execution of the algorithm writes algorithm outputs into the input structure of the write thread (Wr_Thread_input). In this case, the input to the write thread is a single circular buffer (Pixel_Out). After completion of the algorithm, the write thread copies the new line of from its input buffer to an output frame buffer in memory (G_Out[i]).","Turning to , a more detailed abstract representation of a top-level program  can be seen. The read thread , execution module , and write thread  are all instances of objects, using object declarations provided by the programmer. The iterator  is also provided by the programmer, describing the sequencing for the top-level program . In this example the iterator is a FOR loop, but can be any style of sequencing, such as following linked lists, command parsing, and so forth. The iterator  sequences the top-level program by calling traverser  that is provided by system programming tool , which (as shown and for example) simply calls the \u201crun\u201d procedures in each object, in a correct order. This permits a clean separation between the iteration method and the instances of objects that implement the top-level program, allowing these to be re-used in other configurations for other use-cases.","4.1. Source Code in a Hosted Environment","Looking now to , an example of an autogenerated source code template  can be seen. System programming tool  generates source code by traversing the use-case diagram (i.e., ) as a graph and emitting source text strings within sections of a code template. This example includes several sections which are algorithm class declarations , object declarations , a set of initialization procedure declarations , a traverse function  that the system programming tool  generates for the use-case, and the declaration of a function that implements the use-case . This hosted-program function , in turn, generally comprises a number of sub-sections, which are create object instances , setup object state  and  (which includes dataflow pointers, circular-buffer addressing context, and parameter initialization), create and call the iterator with a pointer to the traverse function , and delete the objects after execution is completed . The hosted-program function  is intended to be called by user-supplied \u201cmain\u201d program that serves as a test bench for software development.","A foundation for the programming abstractions of system , object-based thread parallelism, and resource allocation is the algorithm module , which is shown in . An example of an algorithm module  that encapsulates an algorithm kernel  (which is written by a user) can be seen. The object instance  generally comprises public variables  and a member function . Here, object instance  cleanly separates algorithm kernels (i.e., ) from specific instances deployed in a particular use-case, and member function(s)  iterate the kernel  for a particular use-case (parameterized).","Turning to , a more detailed example of the source code for algorithm kernel  can be seen. This algorithm kernel  is an example of an algorithm kernel for the third processing stage of a simple image pipeline (\u201csimple_ISP\u201d). For brevity, some of the code is omitted, and the example excludes variable and type declarations that are described later. For efficiency, the kernel  is written using a subset of C++, with intrinsics, instead of fully general, standard C++. This kernel  describes the operations that the algorithm performs to output a pair of pixels (these pixels are produced in the same data path, which supports both paired and unpaired operations). The methods for expanding on this primitive operation to perform entire use-cases on entire images are described in later example.","The kernel  is written as a standalone procedure and can include other procedures to implement the algorithm. However, these other procedures are not intended to be called from outside the kernel , which is called through the procedure \u201csimple_ISP.\u201d The keyword SUBROUTINE is defined (using the #define keyword elsewhere in the source code) depending on whether the source-code compilation is targeted to a host. For this example, SUBROUTINE is defined as \u201cstatic inline.\u201d The compiler  can expand these procedures in-line for pixel processing when architecture (i.e., processing cluster ) may not provide for procedure calls, due to cost in cycles and hardware (memory). In other host environments, the keyword SUBROUTINE is blank and has no effect on compilation. The included file \u201csimple_ISP_def.h\u201d is also described below.","Intrinsics are used to provide direct access to pixel-specific data types and supported operations. For example, the data type \u201cuPair\u201d is an unsigned pair of 16-bit pixels packed into 32 bits, and the intrinsic \u201c_pcmv\u201d is a conditional move of this packed structure to a destination structure based on a specific condition tested for each pixel. These intrinsics enable the compiler  to directly emit the appropriate instructions, instead of having to recognize the use from generalized source code matching complex machine descriptions for the operations. This generally can require that the programmer learn the specialized data types and operations, but hides all other details such as register allocation, scheduling, and parallelism. General C++ integer operations can also be supported, using 16-bit short and 32-bit long integers.","An advantage of this programming style is that the programmer does not deal with: (1) the parallelism provided by the SIMD data paths; (2) the multi-tasking across multiple contexts for efficient execution in the presence of dependencies on a horizontal scan line (for image processing); or (3) the mechanics of parallel execution across multiple nodes (i.e., -). Furthermore, the programs (which are generally written in C++) can be used in any general development environment, with full functional equivalence. The application code can be used in outside environment for development and testing, with little knowledge of the specifics of system  and without requiring the use of simulators. This code also can be used in a SystemC model to achieve cycle-approximate behavior without underlying processor models","Inputs to algorithm modules are defined as structures\u2014declared using the \u201cstruct\u201d keyword\u2014containing all the input variables for the module. Inputs are not generally passed as procedure parameters because this implies that there is a single source for inputs (the caller). To map to ASIC-style data flows, there should be a provision for multiple source modules to provide input to a given destination, which implies that object inputs are independent public variables that can be written independently. However, these variables are not declared independently, but instead are placed in an input data structure. This is to avoid naming conflicts, as described below.","The input and output data structures for the application are defined by the programmer in a global file (global for the application) that contains the structure declarations. An example of an input\/output (IO) structure , which shows the definitions of these structures for the \u201csimple_ISP\u201d example image pipeline, can be seen in . The structures can be given any name meaningful to the application, and, even though the name of this file is \u201csimple_ISP_struct.h,\u201d the file name does not desire to follow a convention. The structures can be considered as providing naming scopes analogous to application programming interface (API) parameters for the applications modules (i.e., ).","An API generally documents a set of uniquely-named procedures whose parameter names are not necessarily unique because the procedures may appear within the scope of the uniquely-named procedure. As discussed above, algorithm modules (i.e. ) cannot generally use procedure-call interfaces, but structures provide a similar scoping mechanism. Structures allow inputs to have the scope of public variables but encapsulate the names of member variables within the structure, similar to procedure declarations encapsulating parameter names. This is generally not an issue in the hosted environment because the public variables (i.e., ) are also encapsulated in an object instance that has a unique name. Instead, as explained below, this is an issue related to potential name conflicts because system programming tool  removes the object encapsulation in order to provide an opportunity to generally optimize the resource allocation. The programming abstractions provided by objects are preserved, but the implementation allows algorithm code to share memory usage with other, possibly unrelated, code. This results in public variables having the scope of global variables, and this introduces the requirement for public variables (i.e., ) to have globally-unique names between object instances. This is accomplished by placing these variables into a structure variable that has a globally unique name. It should also be noted that using structures to avoid name conflicts in this way does not generally have all the benefits of procedure parameters. A source of data has to use the name of the structure member, whereas a procedure parameter can pass a variable of any name, as long as it has a compatible type.","Nodes - to -N also have two different destination memories: the processor data memory (discussed in detail below) and the SIMD data memory (which is discussed in detail below). The processor data memory generally contains conventional data types, such as \u201cshort\u201d and \u201cint\u201d (named in the environment as \u201cshorts\u201d and \u201cintS\u201d to denote abstract), scalar data memory data in nodes - to -N (which is generally used to distinguish this data from other conventional data types and to associate the data with a unique context identifier). There can also a special 32-bit (for example) data type called \u201cCirc\u201d that is used to control the addressing of circular buffers (which is discussed in detail below). SIMD data memory generally contains what can be considered either vectors of pixels (\u201cLine), using image processing as an example, or words containing two signed or unsigned values (\u201cPair\u201d and \u201cuPair\u201d). Scalar and vector inputs have to be declared in two separate structures because the associated memories are addressed independently, and structure members are allocated in contiguous addresses.","To autogenerate source code for a use-case, it is strongly preferred that system programming tool  can instantiate instances of objects, and form associations between object outputs and inputs, without knowing the underlying class variables, member functions, and datatypes. It is cumbersome to maintain this information in system programming tool  because any change in the underlying implementation by the programmer should generally reflected in system programming tool . This is avoided using naming conventions in the source code, for public variables, functions, and types that are used for autogeneration. Other, internal variables and so on can be named by the programmer.","Turning to , IO data type module  can be seen. The contents of module  generally define input and output data types for the algorithm \u201csimple_ISP,\u201d called \u201csimple_ISP_io.h\u201d (which is an example of a naming convention used by the system programming tool ). The code of module  generally contains type definitions for input and output variables of an instance of this class. There are two type names for input and output. One name is meaningful to the application programmer (for example, \u201cycc\u201d) and is generally intended to be hidden from the system programming tool , which is defined in \u201csimple_ISP_struct.h\u201d. It should also be noted that \u201csimple_ISP_struct.h\u201d is not a convention because it is included in other \u201c*_io.h\u201d files provided by the programmer. The other type name (\u201csimple_ISP_INV\u201d) follows the naming convention for the system programming tool , using the name of the class. These types are generally equivalent to each other\u2014the \u201ctypedef\u201d generally provides a way to use the type in the system programming tool , which derived from the object-class name known by system programming tool , in a way that is independent of the programming view of the type. For example, tying the application type name to the class name would remove the association with luma and chroma pixels (Y, Cr, Cb), and would prevent re-using this structure definition for other algorithm modules in the same application\u2014each one would have to be given a different name even if the member variables are the same.","Both input and output types are defined by the same naming convention, appending the algorithm name with \u201c_INS\u201d for scalar input to processor data memory, \u201c_INV\u201d for vector input to SIMD data memory, and \u201c_OUT\u201d for output. If a module has multiple inputs (which can vary by use-case), input variables\u2014different members of the input structure\u2014can be set independently by source objects.","If a module has multiple output types, each is defined separately, appending the algorithm name with \u201c_OUT,\u201d \u201c_OUT,\u201d and so forth, as shown in the IO data type module  of . In this example, the algorithm provides two types of outputs based on the same input data and common intermediate results. It would be cumbersome to require that this algorithm be divided into two parts, each with a single output, which would cause a loss of the commonality between input and intermediate state and would increase resource requirements. Instead, the module can declare multiple output types, which is reflected in the use-case diagram (i.e., ) that is described below. It is also possible, based on the use-case, for a single module output to provide data to multiple destinations, which is called a multi-cast transfer. Any module output can be multi-cast, and the use-case diagram (i.e., ) specifies what outputs are multi-cast, and to what destinations, again as described below.","Turning now to , an example of an input declaration  can be seen. In this example, the declarations are in a file named \u201csimple_ISP_input.h\u201d by convention, and inputs are declared for the two forms of input data: one for the processor data memory, and another for the SIMD data memory. Each of these declarations is preceded by the statement \u201c#pragma DATA_ATTRIBUTE(\u201cinput\u201d).\u201d This informs the compiler  that the variable is for read-only input, which is information the compiler  uses to mark dependency boundaries in the generated code. This information is used, in turn, to implement the dataflow protocol. Each input data structure follows a naming convention so that the system programming tool  can form pointer to the structure (which is logically a pointer to all input variables in the structure) for use by one or more source modules.","Typically, the processor data memory input associated with the algorithm contains configuration variables, of any general type\u2014with the exception of the \u201cCirc\u201d type to control the addressing of circular buffers in the SIMD data memory (which is described below). This input data structure follows a naming convention, appending the algorithm name with \u201c_inputS\u201d to indicate the scalar input structure to processor data memory. The SIMD data memory input is a specified type, for example \u201cLine\u201d variables in the \u201csimple_ISP_input\u201d structure (type \u201cycc\u201d). This input data structure follows a similar naming convention, appending the algorithm name with \u201c_inputV\u201d to indicate the vector input structure to SIMD data memory. Additionally, the processor data memory context is associated with the entire vector of input pixels, whatever width is configured. Here, this width can span multiple physical contexts, possibly in multiple nodes - to -N. For example, each associated processor data memory context contains a copy of the same scalar data, even though the vector data is different (since it is logically different elements of the same vector). The GLS unit  provides these copies of scalar parameters and maintains the state of \u201cCirc\u201d variables. The programming model provides a mechanism for software to signal the hardware to distinguish different types of data. Any given scalar or vector variable is placed at the same address offsets in all contexts, in the associated data memory.","Turning to , an example of a constants declaration or file  can be seen. In particular, constants declaration  is an example of a sample of a file for \u201csimple_ISP\u201d used to define constants used in the application. This declaration  generally permits constants to be referenced by text that has a meaning for the application. For example, lookup tables are identified by immediate values. In this example, the lookup table containing gamma values has a LUT ID of 2, but instead of using the value 2, this LUT is referenced by the defined constant \u201cIPIPELUT_GAMMA_VAL\u201d. Typically, this declaration  is not used by system programming tool  directly, but is included in the algorithm kernels (i.e., ) associated with the application. Additionally, there is no naming convention.",{"@attributes":{"id":"p-0385","num":"0415"},"figref":"FIG. 30","b":["2500","3","2500","2500","718"]},"Turning now to , an example of a module-class declaration  is provided. This declaration  follows a standard template, with naming conventions, to permit system programming tool  to create instances of the module, to configure them as required, to form source-destination pairs through pointers, and to invoke the execution of each instance. The class is declared using the name of the algorithm followed by \u201c_c\u201d (in this case, simple_ISP_c) as show with declaration . The system programming tool  uses this name to create instances of the algorithm object, and the name of the object is tied to a named component (block) in the use-case diagram (i.e., ), since there can be multiple instances, and each should have a unique name. Private variables (such as \u201csimd_size\u201d and \u201cctx_id\u201d) are set by the object constructor  when an object is instantiated. These provide \u201chandles\u201d, for example, to the width of the \u201cLine\u201d variables in the instance and an identifier for the \u201cLine\u201d context (e.g., implemented by the \u201csimd\u201d and \u201cLine\u201d classes that are defined for the hosted environment defined in \u201ctmcdecls_hosted.h\u201d). These settings can be based on static variables in the \u201csimd\u201d class. A conventional destructor  is also declared, to de-allocate memory associated with the instance when it is no longer desired. A public variable, named \u201coutput_ptr\u201d, is declared as a pointer to the output type, in this case a pointer  to the type \u201csimple_ISP_OUT\u201d, for example.\u201d If there is more than one output, these pointers are typically named \u201coutput_ptr\u201d, \u201coutput_ptr\u201d, and so on. These are the variables set by system programming tool  to define the destination of the output data for this instance.","The file \u201csimple_ISP_input.h\u201d, for example, is included as declaration  to define the public input variables of the object. This is a somewhat unusual place to include a header file, but it provides a convenient way to define inputs in both multiple environments using a single source file. Otherwise, additional maintenance would be required to keep multiple copies of these declarations consistent between the multiple environments. A public function  is declared, named \u201crun\u201d, that is used to invoke the algorithm instance. This hides the details of the calling sequence to the algorithm kernel (i.e., ), in this case the number of output pointers that are passed to the kernel (i.e., ). The calls \u201c_set_simd_size(simd_size)\u201d and \u201c_set_ctx_id(ctx_id)\u201d, for example, define the width of \u201cLine\u201d variables and uniquely identify the SIMD data memory variable contexts for the object instance. These are used during the execution of the algorithm kernel (i.e., ) for this instance. Finally, the algorithm kernel \u201csimple_ISP.\u201d or  is included as member function . This is also somewhat unconventional, including a \u201c.cpp\u201d file in a header file instead of vice versa, but is done for reasons already described\u2014to permit common, consistent source code between multiple environments.","4.2. Autogeneration from Source Code in a Hosted Environment","In , a detailed example of autogenerated code or hosted application code , which generally conforms to template , can be seen. This autogenerated code or hosted application code  is generated by the system programming tool . Typically, the system programming tool also allocating compute and memory resources in the in processing cluster , builds application source code for compilation by node-specific compilers (which is described below) based on the resource allocation using the meta-data provided by compiling algorithm modules separately, and creates the data structures, in system memory, for the use-case(s), which is fetched by a configuration-read thread in the GLS unit  and distributed throughout the processing cluster .","As show, the algorithm class and instance declarations  and  are generally are straightforward cases. The first section (class declarations) includes the files that declare the algorithm object classes for each component on the use-case diagram (i.e., ), using the naming conventions of the respective classes to locate the included files. The second section (instance declarations) declares pointers to instances of these objects, using the instance names of the components. The code  in this example also shows the inclusion of the file , which is \u201csimple_ISP_def.h\u201d that defines constant values. This file is normally\u2014but not necessarily\u2014included in algorithm kernel code . It is included here for completeness, and the file \u201csimple_ISP_def.h\u201d includes a \u201c#ifndef\u201d pre-processor directive to generally ensure that the file is included once. This is a conventional programming practice, and many pre-processor directives have been omitted from these examples for clarity.","The initialization section  includes the initialization code for each programmable node. The included files are named by the corresponding components in the use-case diagram (i.e.,  and described below). Programmable nodes are typically initialized in following order: iterators.fwdarw.read threads.fwdarw.write threads are passed parameters, similar to function calls, to control their behavior. Programmable nodes do not generally support a procedure-call interface; instead, initialization is accomplished by writing into the respective object's scalar input data structure, similar to other input data.","In this example, most of the variables set during initialization are based on variables and values determined by the programmer. An exception is the circular-buffer state. This state is set by a call to \u201c_init_circ\u201d. The parameters passed to \u201c_init_circ\u201d, in the order shown, are:","(1) a pointer to the \u201ccirc_s\u201d structure for this buffer;","(2) the initial pointer into the buffer, which depends on \u201cdelay_offset\u201d and the buffer size;","(3) the size of the buffer in number of entries;","(4) the size of an entry in number of elements;","(5) \u201cdelay_offset\u201d, which determines how many iterations are required before the buffer generates valid outputs;","(6) a bit to protect against invalid output (initialized to 1); and","(7) the offset from the top boundary for the first data received (initialized to 0).","This approach permits both the programmer and system programming tool  to determine buffer parameters, and to populate the \u201cc_s\u201d array so that the read thread can manage all circular buffers in the use-case, as a part of data transfer, based on frame parameters. It also permits multiple buffers within the same algorithm class to have independent settings depending on the use-case.","The traverse function  is generally the inner loop of the iterator , created by code autogeneration. Typically, it updates circular-buffer addressing states for the iteration, and then calls each algorithm instance in an order that satisfies data dependencies. Here, the traverse function  is shown for \u201csimple_ISP\u201d. This function  is passed four parameters:","(1) an index (idx) indicating the vertical scan line for the iteration;","(2) the height of the frame division;","(3) the number of circular buffers in the use-case (\u201ccirc_no\u201d); and","(4) the array of circular-buffer addressing state for the use-case, \u201cc_s\u201d.","Before calling the algorithm instances, traverse function  calls the function \u201c_set_circ\u201d for each element in the \u201cc_s\u201d array, passing the height and scan-line number (for example). The \u201c_set_circ\u201d function updates the values of all \u201cCirc\u201d variables in all instances, based on this information, and also updates the state of array entries for the next iteration. After the circular-buffer addressing state has been set, traverse function  calls the execution member functions (\u201crun\u201d) in each algorithm instance. The read thread (i.e., ) is passed a parameter (i.e., the index into the current scan-line).","The hosted-program function  is called by a user-supplied testbench (or other routine) to execute to use case on an entire frame (or frame division) of user-supplied data. This can be used to verify the use-case and to determine quality metrics for algorithms. As shown in this example, the hosted-function  is used for \u201csimple_ISP\u201d. This function  is passed two parameters indicating the \u201cheight\u201d and width (\u201csimd_size\u201d) of the frame, for example. The function  is also passed a variable number of parameters that are pointers to instances of the \u201cFrame\u201d class, which describe system-memory buffers or other peripheral input. The first set of parameters is for the read thread(s) (i.e., ), and the second is for the write thread(s) (i.e., ). The number of parameters in each set depends on the input and output data formats, including information such as whether or not system data is interleaved. In this example, the input format is interleaved Bayer, and the output is de-interleaved YCbCr. Parameters are declared in the order of their declarations in the respective threads. The corresponding system data is provided in data structures provided by the user in the surrounding testbench, with pointers passed to the hosted function.","Hosted-program function  also includes creation of object instances . The first statement in this example is a call to the function \u201c_set_simd_size\u201d, which defines the width of the SIMD contexts (normally, an entire scan-line). This is used by \u201cFrame\u201d and \u201cLine\u201d objects to determine the degree of iteration within the objects (in the horizontal direction). This is followed by an instantiation of the read thread (i.e., ). This thread is constructed with a parameter indicating the height and width of the frame. Here, the width is expressed as \u201csimd_size\u201d, and the third parameter is used in frame-division processing. It might appear that the iterator (i.e., ) has to know the height, since iteration is over all scan-lines. However, number of iterations is generally somewhat higher than the number of scan-lines, to take into account the delays caused by dependent circular buffers. The total number of iterations is sufficient to fill and all buffers and provide all valid outputs. However, the read thread (i.e., ) should not iterate beyond the bottom of the frame, so it should know the height in order to conditionally disable the system access. Following this, there is a series of paired statements, where the first sets a unique value for the context identifier of the object that is about to be instantiated and where the second instantiates the object. The context identifier is used in the implementation of the \u201cLine\u201d class to differentiate the contexts of different SIMD instantiation. A unique identifier is associated with all \u201cLine\u201d variables that are created as part of an object instance. The read thread (i.e. ) does not generally desire a context identifier because it reads directly from the system to the context(s) of other objects. The write thread (i.e., ) does generally desire a context identifier because it has the equivalent of a buffer to store outputs from the use-case before they are stored into the system.","After the algorithm objects have been instantiated, their output pointers can be set according to the use-case diagram . This relies on all objects consistently naming the output pointers. It also relies on the algorithm modules defining type names for input structures according to the class name, rather than a meaningful name for the underlying type (the meaningful name can still be used in algorithm coding). Otherwise, the association of component outputs to inputs directly follows the connectivity in the use-case graph (i.e., ).","Additionally, the hosted-program function  includes the object initialization section  for the \u201csimple_ISP\u201d use-case, for example. The first statement creates the array of \u201ccirc_s\u201d values, one array element per circular buffer, and initializes the elements (this array is local to the hosted function, and passed to other functions as desired). The initialization values relevant here are the pointers to the \u201cCirc\u201d variables in the object instances. These pointers are used during execution to update the circular-addressing state in the instances. Following this, the initialization function provided (and named by) the programmer is called for each instance. The initialization functions are passed:","(1) a pointer to the scalar input structure of the instance;","(2) a pointer to the \u201cc_struct\u201d array entry for the corresponding circular buffer; and","(3) the relative \u201cdelay_offset\u201d of the instance.","An initiation  of an instance of the iterator \u201cframe_loop\u201d can be seen. This initiation  uses the name from the use-case diagram. The constructor for this instance sets the height of the frame, a parameter indicating the number of circular buffers (four buffers in this case), and a pointer to the \u201cc_struct\u201d array. This array is not used directly by the iterator (i.e., ), but is passed to the traverse function , along with the number of circular buffers. The number of circular buffers is also used to increase the number of iterations; for example, four buffers would require three additional iterations to generate all valid outputs. The read and write thread (i.e.,  and , respectively) are constructed with the height of the frame, so the correct amount of system data is read and written despite the additional iterations. The remaining statements create a pointer to the traverse function  and call the iterator (i.e., ) with this pointer. The pointer is used to call traverse function  within the main body of the iterator (i.e., ).","Finally, the hosted-program function  in includes a delete object instances function . This function  simply de-allocates the object instances and frees the memory associated with them, preventing memory leaks for repeated calls to the hosted function.",{"@attributes":{"id":"p-0415","num":"0445"},"figref":"FIG. 33","b":["2800","3","3","2800","1808","3","1808"]},"4.3. Use-Case Diagrams","As can be seen in , the use-case diagram  is a diagram illustrating an application program. The diagram is generally intended to:\n\n","A read thread  or write thread  is specified by thread name, the class name, and the input or output format. The thread name is used as the name of the instance of the given class in the source code, and the input or output format is used to configure the GLS unit  to convert the system data format (for example, interleaved pixels) into the de-interleaved formats required by SIMD nodes (i.e., -). Messaging supports passing a general set of parameters to a read thread  or write thread . In most cases, the thread class determines basic characteristics such as buffer addressing patterns, and the instances are passed parameters to define things such as frame size, system address pointers, system pixel formats, and any other relevant information for the thread  or . These parameters are specified as input parameters to the thread's member function and are passed to the thread by the host processor based on application-level information. Multiple instance of multiple thread classes can be used for different addressing patterns, system data types, an so forth.","An iterator  is generally defined by iterator name and class name. As with read threads  and write threads , the iterator  can be passed parameters, specified in the iterator's function declaration. These parameters are also passed by the host processor based on application information. An iterator  can be logically considered an \u201couter loop\u201d surrounding an instance of a read thread . In hardware, other execution is data-driven by the read thread , so the iterator  effectively is the \u201couter loop\u201d for all other instances that are dependent on the read thread\u2014either directly or indirectly, including write threads . There is typically one iterator  per read thread . Different read threads  can be controlled by different instances of the same iterator class, or by instances of different iterator classes, as long as the iterators  are compatible in terms of causing the read threads  to provide data used by the use-case.","An algorithm-module instance (i.e., ), associated with a programmable node module , is specified by module instance name, the class name, and the name of the initialization header file. These names are used to locate source files, instantiate objects, to form pointers to inputs for source objects, and to initialize object instances. These all rely on the naming conventions described above. Each algorithm class has associated meta-data, shown in the  but not directly specified by the programmer. This meta-data is determined by information from the compiler , based on compiling an instance of the object as a stand-alone program. This is information, such as cycle count for one iteration of execution, the amount of instruction and data memory (both scalar and vector), and a table listing the number of cycles taken by each task boundary inserted by the compiler to resolve side-context dependencies. This information is stored with the class files, based on the interfaces defined between system programming tool  and the compiler , and is used by system programming tool  to construct the actual source files that are compiled for the use-case. The actual source files depend on the resources available and throughput requirements, and the system programming tool  controls the structure of source code to achieve an optimum or near-optimum allocation.","Accelerators (from ) are identified by accelerator name in accelerator module . The system programming tool  cannot allocate these resources, but can create the desired hardware configuration for dataflow into and out of any accelerators. It is assumed that the accelerators can support the throughput.","Multi-cast modules  permit any object's outputs to be routed to multiple destinations. There is generally no associated software; it provides connectivity information to system programming tool  for setting up multi-cast threads in the GLS unit . Multi-cast threads can be used in particular use-cases, so that an algorithm can be completely independent of various dataflow scenarios. Multi-cast threads also can be inserted temporarily into a use-case, for example so that an output can be \u201cprobed\u201d by multi-casting to a write thread , where it can be inspected in memory , as well as to the destination required by the use-case.","Turning to , an example use-case diagram  for the \u201csimple_ISP\u201d application can be seen. This is a very simple example of dataflow, corresponding to the autogenerated source code  generated by the system programming tool , from this use-case. Here, the node programs or stages , , , and  are implemented as described below, but these programs, by themselves, contain no provision for system-level data and control flow, and no provision for variable initialization and parameter passing. These are provided by the programs that execute as global LS threads.","Here, diagram  shows two types each of data and control flow. Explicit dataflow is represented by solid arrows. Implicit or user-defined dataflow, including passing parameters and initialization, is represented by dashed arrows. Direct control flow, determined by the iterator , is represented by the arrow marked \u201cDirect Iteration (outer loop).\u201d Implied control flow, determined by data-driven execution, is represented by dashed arrows. Internal data and control flow, from stage  output to  input, is accomplished by the node programming flow (as described below). All other data and control flow is accomplished by the global LS threads.","Additionally, the source code that is converted to autogenerated source code (i.e., ) by system programming tool  is generally free-form, C++ code, including procedure calls and objects. The overhead in cycle count is usually acceptable because iterations typically result in the movement of a very large amount of data relative to the number of cycle spent in the iteration. For example, consider a read thread (i.e., ) that moves interleaved Bayer data into three node contexts. In each context, this data is represented as four lines of 64 pixels each\u2014one line each for R, Gr, B, and Gb. Across the three contexts, this is twelve, 64-pixels lines total, or 768 pixels. Assuming that all 16 threads are active and presenting roughly equivalent execution demand (this is very rarely the case), and a throughput of one pixel per cycle (a likely upper limit), each iteration of a thread can use 768\/16=48 cycles. Setting up the Bayer transfer can require on the order of six instructions (three each for R-Gr and Gb-B), so there are 42 cycles remaining in this extreme case for loop overhead, state maintenance, and so forth.","4.5. Complier","Turning to , an example of the operation of the complier  can be seen. Typically, compiler  is comprised of two or more separate compilers: one for the host environment and one for the nodes (i.e., -) and\/or the GLS unit . As shown, source code  is converted to assembly pseudo-code  by compiler  (for GLS unit , which is described in greater detail below. In this example, the load of R[i] on the first line associates the system address(es) for the Frame line R[i] with the register tmpA. The Frame format corresponding to object R[i] can have, and normally does have, a very different size and organization compared to the corresponding Line object R_In[i %3]\u2014for example, being in a packed format instead of on 16-bit, short-integer alignments, and having the width of an entire frame instead of the width of a horizontal group. One of the functions of the GLS unit  is to generally implement functional equivalence between the original source code\u2014as compiled and executed on any host\u2014and the code as compiled and executed as binaries on the GLS unit processor (or GLS processor , which is described in greater detail below) and\/or node processor  (which is described in greater detail below). Namely, for the GLS processor , this can be a function of the Request Queue and associated control  (which is described in greater detail below.","5. System Programming (Generally)","Turning to , a conceptual arrangement  for how the \u201csimple_ISP\u201d application is executed in parallel. Since this is a monolithic program (a memory-to-memory operation), with simple dataflow, it can be parallelized by replicating (in concept) instances of algorithm modules. The read thread distributes input data to the instances, and the outputs are re-assembled at the write thread to be written as sequential output to the system.","5.1. Parallel Object Execution Example","In , an example of the execution of an application for systems  and  can be seen. Here, in this case twelve \u201cinstances\u201d - to - are executed in six contexts - - on two nodes -and -(1). Each context - - is 64 pixels wide, and contexts - - are linked as a horizontal group of 768 continuous pixels on four scan-lines (vertical direction). The read thread (i.e., ) provides scan-line data sequentially, into these contiguous contexts. The contexts - - execute using multi-tasking (execution of tasks - to -, - to -, - to -, and - to -) on each node -and -(1) (to satisfy dependencies on pixels in contexts to the left and right), with parallel execution between nodes -and -(1) (also subject to data dependencies in the horizontal direction). The parallelism between nodes -and -(1) is the \u201ctrue\u201d parallelism, but multiple contexts - - support data parallelism by permitting streaming of pixel data into and out processing cluster , overlapped with execution. Pixel throughput is determined by the number of cycles from the input to stage  to the output of stage , the number of parallel nodes (i.e., -), and the node frequency of the nodes (i.e., -). In this example, two nodes - and -(1) generate 128 pixels per iteration. If the end-to-end latency is 600 cycles, at 400 MHz, the throughput is (128 pixels)*(400 Mcycle\/sec)\u00f7(600 cycles), or 85 Mpixel\/sec. This form of parallelism, however, is too restrictive because it is a monolithic program, using partitioned-data parallelism.","5.2. Example Uses of Circular Buffers","Circular buffers can be used extensively in pixel and signal processing, to manage local data contexts such as a region of scan lines or filter-input samples. Circular buffers are typically used to retain local pixel context (for example), offset up or down in the vertical direction from a given central scan line. The buffers are programmable, and can be defined to have an arbitrary number of entries, each entry of arbitrary size, in any contiguous set of data memory locations (the actual location is determined by compiler data-structure layout). In some respects, this functionality is similar to circular addressing in the C6x.","However, there are a few issues introduced by the application of circular buffers here. Pixel processing (for example) can require boundary processing at the top and bottom edges of the frame. This provides data in place of \u201cmissing\u201d data beyond the frame boundary. The form of this processing, and the number of \u201cmissing\u201d scan lines provided, depends on the algorithm. The implementation provided here of a circular buffer is generally independent of the actual location of the buffer in the dataflow. Dependent buffers are generally \u201cfilled\u201d at the top of a frame and \u201cdrained\u201d at the bottom. The actual state of any particular buffer depends on where it is located in the dataflow relative to other buffers.","Turning to , there are three circular buffers - -, and - in three stages of the processing chain . This processing is embedded in an iteration loop that provides data one scan-line at a time to buffer -, which in turn provides data to buffer -, and so on. Each iteration of the loop increments the index into the circular buffer at each stage, starting with the indexes as shown; these relative locations are generally used to properly manage the relative dataflow delays between the buffers.","The first iteration provides input data at the first scan-line of the frame (top) to buffer -. In this example, this is not sufficient for buffer - to generate valid output. The circular buffers - to - have three entries each, implying that entries from three scan-lines are used to calculate an output value. At this point, the buffer index points to the entry that is logically one line before the first scan-line (above the frame). Neither buffer - nor buffer - has valid input at this point. The second iteration provides data at the second scan-line (top+1) to buffer -, and the index points to the first scan-line. In this example, boundary processing can provide the equivalent of three scan-lines of data because the second scan-line is logically reflected above the top boundary. The entry after the index generally serves two purposes, providing data to represent a value at top\u22121 (above the boundary), and actual data at top+1 (the second scan-line). This is sufficient to provide output data to buffer -, but this data is not sufficient for buffer - to generate valid output so that buffer - has no input. The third iteration provides three scan-line inputs to buffer -, which provides a second input to buffer -. At this point, buffer - uses boundary processing to generate output to buffer -. On the fifth iteration, all stages - to - have valid datasets for generating output, but each is offset by a scan-line due to the delays in filling the buffers through the processing stages. For example, in the fifth iteration, buffer - generates output at top+3, buffer - at top+2, and buffer - at top+1.","Generally, it is not possible for algorithm kernels (i.e., ) to completely specify initial settings or the behavior of their circular buffers (i.e., -) because, among other things, this depends on how many stages removed they are from input data. This information is available from the system programming tool , based on the use-case diagram. However, the system programming tool  also does not completely specify the behavior of circular buffers (i.e., -) because, for example, the size of the buffers and the specifics of boundary processing depend on the algorithm. Thus, the behavior of circular buffers (i.e., -) is determined by a combination of information known to the application and to system programming tool . Furthermore, the behavior of a circular buffer (i.e., -) also depends on the position of the buffer relative to the frame, which is information known to the read thread (i.e., ), at run time.","5.3. Contexts and Mapping of Programs to Nodes","5.3.1 Contexts and Descriptors (Generally)","SIMD data memory and node processor data memory (i.e.,  and which is described below in detail) are partitioned into a variable number of contexts, of variable size. Data in the vertical frame direction is retained and re-used within the context itself, using circular buffers. Data in the horizontal frame direction is shared by linking contexts together into a horizontal group (in the programming model, this is represented by the datatype Line). It is important to note that the context organization is mostly independent of the number of nodes involved in a computation and how they interact with each other. A purpose of contexts is to retain, share, and re-use image data, regardless of the organization of nodes that operate on this data.","Turning to , a memory diagram  cab be seen. In this memory diagram  contexts - to - are located in memory  and generally correspond to a data set (such as the public variables - for object instances or algorithm module -) to perform tasks (such as those set forth by member function - and seen in member function diagram ). As shown, there are several sets of contexts - to -, - to -, - to -, and - to -, which correspond to object instances - to -. Object instances (i.e., -) can share node computing and memory resources depending on throughput requirements, and object instances (i.e., -) can be modeled using independent contexts, where contexts can encapsulate public and private variables.","Variable allocation is provided for the number of contexts, and sizes of contexts, to object instances in which contexts (i.e., -) allocated to the same object class can be considered separate object instances. Also, context allocation can includes both scalar and vector (i.e., SIMD) data, where scalar data can include parameters, configuration data, and circular-buffer state. Additionally, there are several ways of overlapping data transfer with computation: (1) using 2 contexts (or more) for double-buffering (or more); (2) compiler flags when input state is no longer desired\u2014next transfer in parallel with completing execution; and (3) addressing modes permit the implementation of circular buffers (e.g. first-in-first-out buffers or FIFOs). Data transfer at the system level can look like variable assignment in the programming model with the system  matching context offsets during a \u201clinking\u201d phase. Moreover, multi-tasking can be used to most efficiently schedule node resources so as to run whatever contexts are ready with system-level dependency checking that enforces a correct task order and registers that can be saved and restored in a single cycle\u2014no overhead for multi-tasking","Turning to , an example of the memory  can be seen in greater detail. As shown, each context - to - includes a left side context , center context , and right side context , and there is a descriptor - to - associated with each context - to -. The descriptors specify the context base address in data memory, segment node identifiers, context base number of the center context destination (for the \u201cOutput\u201d instruction), segment node identifiers and context base numbers of the next context to receive data, and how data flows are distributed and merged. Typically, context descriptors are organized as a circular buffer (i.e., -) in linear memory, with the end marked by the Bk bit. Additionally, descriptors are generally contained in a \u201chidden\u201d area of memory and not accessible by software, but an entire descriptor can be fetched in one cycle. Additionally, hardware maintains copies of this information as used for control (i.e., active tasks, task iteration control, routing of inputs to contexts and offsets, routing of outputs to destination nodes, contexts, and offsets). Descriptors (i.e., -) are also initialized along with the global program data in data memory, which is derived from system programming tool .","Typically, a variable number of contexts (i.e., -), of variable sizes, are allocated to a variable number of programs. For a given program, all contexts are generally the same size, as provided by the system programming tool . SIMD data memory not allocated to contexts is available for access from all contexts, using a negative offset from the bottom of the data memory. This area is used as a compiler  spill\/fill area  for data that does not desire to be preserved across task boundaries, which generally avoids the requirement that this memory be allocated to each context separately.","Each descriptor  for node processor data memory ( and which is described below in detail) can contains a field (i.e., - and -) that specifies the base address of the associated context (which can be seen in ). Fields can be aligned on halfword boundaries. The base addresses in node processor data memory, for contexts 0-15 (for example), can be contained in locations 00\u2032h-08\u2032h, respectively, in the node processor data memory, with even contexts at even halfword locations. Each descriptor  can contains a base address for the first location of the corresponding context.","Turning to , a format for a SIMD data memory context descriptor  can be seen. Each descriptor  for SIMD data memory can contains a field  that specifies the base address of the associated context in SIMD data memory. These descriptors  can also contain information to describe task iteration over related contexts and to describe system dataflow. The descriptors are usually stored the context-state RAM or context-state memory (i.e., , which is described below in detail), a wide, dedicated memory supporting quick access of all information for multiple descriptors, because these descriptors are used to control concurrent task sequencing and system-dataflow operations. Since the node processor data memory descriptor generally indicates the base address of the local area for the context and, typically, has no other control function, the term \u201cdescriptor\u201d with regard to node contexts generally refers to the SIMD data memory descriptor.","SIMD data memory descriptors  are usually organized as linear lists, with a bit in the descriptor indicating that it is the last entry in the list for the associated program. When a program is scheduled, part of the scheduling message indicates the base context number of the program. For example, the message scheduling program B (object instance -) in the  would indicate that its base context descriptor is descriptor . Program B executes in three contexts described by descriptors -; these contexts correspond to three different areas of the image. Programs normally multi-task between their contexts, as described later.","5.3.2. Side-Context Pointers","Turning to , an example of how side-context pointers are used to link segments of the horizontal scan-line into horizontal groups can be seen. As shown, there are four nodes (labeled node -through node -) with each node having four contexts. For an example application of image processing, adjacent horizontal pixels are generally within contiguous contexts on the same node, except for the last context on that node, which links, on the right, to the left side of the first context in an adjacent node. Because of dependencies on data provided using side-context pointers, this organization of horizontal groups can cause contexts executing the same program to be in different stages of execution. Since a context can begin execution while others are still receiving input, this maximizes the overlap of program input and output with execution, and minimizes the demand that nodes place on shared resources such as data interconnect .","Typically, the horizontal group begins on the left at a left boundary, and terminates on the right at a right boundary. Boundary processing applies to these contexts for any attempt to access left-side or right-side context. Boundary processing is valid at the actual left and right boundaries of the image. However, if an entire scan-line does not fit into the horizontal group, the left- and right-boundary contexts can be at intermediate points in the scan-line, and boundary processing does not produce correct results. This means that any computation using this context generates an invalid result, and this invalid data propagates for every access of side context. This is compensated for by fetching horizontal groups with enough overlap to create valid final results. This reflects the inefficiency discussed earlier that is partially compensated for by wide horizontal groups (relatively small overlap is required, compared to the total number of pixels in the horizontal group).","Note that the side-context pointers generally permit the right boundary to share side context with the left boundary. This is valid for computing that progresses horizontally across scan lines. However, since in this configuration contexts are used for multiple horizontal segments, this does not permit sharing of data in the vertical direction. If this data is required, this implies a large amount of system-level data movement to save and restore these contexts.","A context (i.e., -) can be set so that it is not linked to a horizontal group, but instead is a standalone context providing outputs based on inputs. This is useful for operations that span multiple regions of the frame, such as gathering statistics, or for operations that don't depend specifically on a horizontal location and can be shared by a horizontal group. A standalone context is threaded, so that input data from sources, and output data to destinations, is provided in scan-line order.","5.3.3. SIMD Data Memory Descriptor","Turning back to , SIMD data memory descriptors are organized as linear lists, with a bit  in the descriptor indicating that it is the last entry in the list for the associated program. When a program is scheduled, part of the scheduling message indicates the base context number of the program. For example, a message scheduling program (object instance - of ) would indicate that its base context descriptor is descriptor -. Program (object instance - of ) executes in three contexts - to - described by descriptors - to -; these contexts correspond to three different areas of (for example) an image, which may not necessarily be contiguous.","Node addresses are generally structures of two identifiers. One part of the structure is a \u201cSegment_ID\u201d, and the second part is a \u201cNode_ID\u201d. This permits nodes (i.e., -) with similar functionality to be grouped into a segment, and to be addressed with a single transfer using multi-cast to the segment. The \u201cNode_ID\u201d selects the node within the segment. Null connections are indicated by Segment_ID.Node_ID=00.0000\u00b0b. Valid bits are not required because invalid descriptors are not referenced. The first word of the descriptor indicates the base address of the context in SIMD data memory. The next word contains bits  and  indicating the last descriptor on the list of descriptors allocated to a program (Bk=1 for the last descriptor) and whether the context is a standalone, threaded context (Th=1). The second word also specifies horizontal position from the left boundary (field ), whether the context depends on input data (field ), and the number of data inputs in field , with values 0-7 representing 1-8 inputs, respectively (input data can be provided by up to four sources, but each source can provide both scalar and vector data). The third and fourth words contain the segment, node, and context identifiers for the contexts sharing data on the left and right sides, respectively, called the left-context pointer and right-context pointer in fields  to .","5.3.4. Center-Context Pointers","The context-state RAM or memory also has up to four entries describing context outputs, in a structure called a destination descriptor (the format of which can be seen in  and is described in detail below). Each output is described by a center-context pointer, similar in content to the side-context pointers, except that the pointer describes the destination of output from the context. In , center-context pointers describe an example of how one context's outputs are routed to another context's inputs (a partial set of pointers is shown for clarity\u2014other pointers follow the same pattern). In the example of , eight nodes (labeled node -through node -and node -through node -) are shown, with each having four contexts. As with side-context pointers, related contexts can reside either on different nodes or the same node. Input and output between nodes is usually between related horizontal groups\u2014that is, those that represent the same position in the frame. For this reason, the four contexts on the first node output to the first contexts on four destination nodes and so on. The number of source nodes is generally independent of the number of destination nodes, but the number of contexts should be the same in order to share data properly.","5.3.5. Destination Descriptors","In , an example of a format for a destination descriptor  can be seen. The destination descriptors  generally have a bit  (ThDst) indicating that the destination is a thread (input is ordered), and a two-bit field  (Src_Tag) used to identify this source to the destination. Each context can receive input from up to four sources, and the Src_Tag value is usually unique for each source at the receiving context (they are not necessarily unique in the destination descriptor). Data output uses fields  to  (which respectively include Seg_ID, Node_ID, and Node Dest_Cntx\/Thread_ID) to route the data to the destination, and also sends Src_Tag with the data to identify the source. Invalid descriptors are indicated by Seg_ID=Node_ID=0.","A context (i.e., -) normally has at least one destination for output data, but it is also possible that a single program in a context (i.e., -) can output several different sets of data, of different types, to different destinations. The capability for multiple outputs is generally employed in two situations:\n\n","Destination descriptors support a generalized system dataflow and can be seen in . In , four nodes (labeled node -through node -) are shown with each having four contexts. The destination descriptor entries are in four words of the context-state entry. The descriptor contains a table of four center-context pointers for four different destinations. The limit is four outputs because a numbered output is identified by a 2-bit field (described later; this is a design limitation, not architectural). Word numbers in the table refer to words in a line of the context-state RAM. A node \u201coutput\u201d instruction identifies which descriptor entry is associated with the instruction. The identifier directly indexes the destination descriptor.","5.4. Task Balancing","In basic node (i.e., -) allocation, throughput is met by adjusting and balancing the effective cycle counts so that data sources produce output at the required rate. This is determined by true dependencies between source and destination programs. For example, scan-based pixel processing has a much more complex set of dependencies than those between serially-connected sources and destinations, and the potential stalls introduced should be analyzed by system programming tool . As discussed in this section, this can be done after resource allocation, because it depends on context configurations, but has to occur before compiling source code, because the compiler uses information from system programming tool  to avoid these stalls.","In scan-based processing, data is shared not only between outputs and inputs, but also between contexts that are co-coordinating on different segments of a horizontal group. This sharing is essential to meet throughput, so that the number of pixels output by a program can be adjusted according to the cycle count (increasing cycles implies increasing pixels output, to maintain the required throughput in terms of pixels per cycle). To accomplish this, the program executes in multiple contexts, either in parallel or multi-tasked, and these contexts should logically appear as a single program operating on the total width of allocated contexts. Input and intermediate data associated with the scan lines are shared across the co-coordinating contexts, in both left-to-right and right-to-left directions.","To meet throughput for scan-line-based applications, all dependencies should be considered, including those reflected through shared side-contexts. Nodes (i.e., -) use task and program pre-emption (i.e., , , and ) to reduce the impact of these dependencies, but this is not generally sufficient to prevent all dependency stalls, as shown in . As shown, the pre-emption  (which is discussed below) of task - (the 3program task in the 6context) on node -cannot be guaranteed to prevent a stall; in this case, there is a stall on task -. This stall is caused by the imbalance of node utilization by tasks, the difference in time between path \u201cA\u201d and path \u201cB\u201d (assuming, for example, that task - is the last one in the program and cannot be pre-empted to schedule around the stall).","These side-context stalls are a complex function of task sizes (cycles between task boundaries, determined by the source code and code generation), the task sequence in the presence of task pre-emption, the number of tasks, the number of contexts, and the context organization (intra-node or inter-node). There is no closed-form expression that can predict whether or not stalls can occur. Instead, the system programming tool  builds the dependency graph, as shown in the figure, to determine whether or not there is a likelihood of side-context dependency stalls. The meta-data that the compiler  provides, as a result of compiling algorithm modules as stand-alone programs, includes a table of the tasks and their relative cycle counts. The system programming tool  uses this information to construct the graph, after resource allocation determines the number of contexts and their organizations. This graph also comprehends task pre-emption (but not program pre-emption, for simplicity).","If the graph does indicate the possibility of one or more dependency stalls, system programming tool  can eliminate the stalls by introducing artificial task boundaries to balance dependencies with resource utilization. In this example, the problem is the size of tasks - to - (for node -) with respect to subsequent, dependent tasks; an outlier in terms of task size is usually the cause since it causes the node -to be occupied for a length of time that does not satisfy the dependencies of contexts in previous nodes (i.e., -(1)), which are dependent on right-side context from subsequent nodes. The stall is removed by splitting each of tasks - to - into two sub-tasks. This task boundary has to be communicated to the compiler  along with the source files (concatenating task tables for merged programs). The compiler  inserts the task boundary because SIMD registers are not live across these boundaries, and so the compiler  allocates registers and spill\/fill accordingly. This can alter the cycle count and the relative location of the task boundary, but task balancing is not very sensitive to the actual placement of the artificial boundary. After compilation, the system programming tool  reconstructs the dependency graph as a check on the results.","5.5. Context Management","5.5.1. Context Management Terminology","Dependency checking can be complex, given the number of contexts across all nodes that possibly share data, the fact that data is shared both though node input\/output (I\/O) and side-context sharing, and the fact that node I\/O can include system memory, peripherals, and hardware accelerators. Dependency checking should properly handle: 1) true dependencies, so that program execution does not proceed unless all required data is valid; and 2) anti-dependencies, so that a source of data does not over-write a data location until it is no longer desired by the local program. There are no output dependencies\u2014outputs are usually in strict program and scan-line order.","Since there are many styles of sharing data, terminology is introduced to distinguish the types of sharing and the protocols used to generally ensure that dependency conditions are met. The list below defines the terminology in the , and also introduces other terminology used to describe dependency resolution:\n\n","Local context management controls dataflow and dependency checking between local shared contexts on the same node (i.e., -) or logically adjacent nodes. This concerns shared left side contexts  or right side contexts , copied into the left-side or right-side context RAMs or memories","5.5.1.1. Task Switching to Break Circular Side-Context Dependencies","Contexts that are shared in the horizontal direction have dependencies in both the left and right directions. A context (i.e., -) receives Llc and Rlc data from the contexts on its left and right, and also provides Rlc and Llc data to those contexts. This introduces circularity in the data dependencies: a context should receive Llc data from the context on its left before it can provide Rlc data to that context, but that context desires Rlc data from this context, on its right, before it can provide the Llc context.","This circularity is broken using fine-grained multi-tasking. For example, tasks - to - (from ) can be an identical instruction sequence, operating in six different contexts. These contexts share side-context data, on adjacent horizontal regions of the frame. The figure also shows two nodes, each having the same task set and context configuration (part of the sequence is shown for node -(1)). Assume that task - is at the left boundary for illustration, so it has no Llc dependencies. Multi-tasking is illustrated by tasks executing in different time slices on the same node (i.e., -); the tasks - to - are spread horizontally to emphasize the relationship to the horizontal position in the frame.","As task - executes, it generates left local context data for task -. If task - reaches a point where it can require right local context data, it cannot proceed, because this data is not available. Its Rlc data is generated by task - executing in its own context, using the left local context data generated by task - (if required). Task - has not executed yet because of hardware contention (both tasks execute on the same node -). At this point, task - is suspended, and task - executes. During the execution of task -, it provides left local context data to task -, and also Rlc data to task -, where task - is simply a continuation of the same program, but with valid Rlc data. This illustration is for intra-node organizations, but the same issues apply to inter-node organizations. Inter-node organizations are simply generalized intra-node organizations, for example replacing node -with two or more nodes.","A program can begin executing in a context (i.e., -) when all Lin, Cin, and Rin data is valid for that context (if required), as determined by the Lvin, Cvin, and Rvin states. During execution, the program creates results using this input context, and updates Llc and Clc data\u2014this data can be used without restriction. The Rlc context is not valid, but the Rvlc state is set to enable the hardware to use Rin context without stalling. If the program encounters an access to Rlc data, it cannot proceed beyond that point, because this data may not have been computed yet (the program to compute it cannot necessarily execute because the number of nodes is smaller than the number of contexts, so not all contexts can be computed in parallel). On the completion of the instruction before Rlc data is accessed, a task switch occurs, suspending the current task and initiating another task. The Rvlc state is reset when the task switch occurs.","The task switch is based on an instruction flag set by the compiler , which recognizes that right-side intermediate context is being accessed for the first time in the program flow. The compiler  can distinguish between input variables and intermediate context, and so can avoid this task switch for input data, which is valid until no longer desired. The task switch frees up the node to compute in a new context, normally the context whose Llc data was updated by the first task (exceptions to this are noted later). This task executes the same code as the first task, but in the new context, assuming Lvin, Cvin, and Rvin are set\u2014Llc data is valid because it was copied earlier into the left-side context RAM. The new task creates results which update Llc and Clc data, and also update Rlc data in the previous context. Since the new task executes the same code as the first, it will also encounter the same task boundary, and a subsequent task switch will occur. This task switch signals the context on its left to set the Rvlc state, since the end of the task implies that all Rlc data is valid up to that point in execution.","At the second task switch, there are two possible choices for the next task to schedule. A third task can execute the same code in the next context to the right, as just described, or the first task can resume where it was suspended, since it now has valid Lin, Cin, Rin, Llc, Clc, and Rlc data. Both tasks should execute at some point, but the order generally does not matter for correctness. The scheduling algorithm normally attempts to chose the first alternative, proceeding left-to-right as far as possible (possibly all the way to the right boundary). This satisfies more dependencies, since this order generates both valid Llc and Rlc data, whereas resuming the first task would generate Llc data as it did before. Satisfying more dependencies maximizes the number of tasks that are ready to resume, making it more likely that some task will be ready to run when a task switch occurs.","It is important to maximize the number of tasks ready to execute, because multi-tasking is used also to optimize utilization of compute resources. Here, there are a large number of data dependencies interacting with a large number of resource dependencies. There is no fixed task schedule that can keep the hardware fully utilized in the presence of both dependencies and resource conflicts. If a node (i.e., -) cannot proceed left-to-right for some reason (generally because dependencies are not satisfied yet), the scheduler will resume the task in the first context\u2014that is, the left-most context on the node (i.e., -). Any of the contexts on the left should be ready to execute, but resuming in the left-most context maximizes the number of cycles available to resolve those dependencies that caused this change in execution order, because this enables tasks to execute in the maximum number of contexts. As a result, pre-empt (i.e., pre-empt ), which are times during which the task schedule is modified, can be used.","Turning to , examples of pre-emption can be seen. Here, task - cannot execute immediately after task -, but tasks - through - are ready to execute. Task - is not ready to execute because it depends on task -. The node scheduling hardware (i.e., node wrapper -) on node -recognizes that task - is not ready because Rvlc is not set, and the node scheduling hardware (i.e., node wrapper -) starts the next task, in the left-most context, that is ready (i.e., task -). It continues to execute that task in successive contexts until task - is ready. It reverts to the original schedule as soon as possible\u2014for example, only task - pre-empts -. It still is important to prioritize executing left-to-right.","To summarize, tasks start with the left-most context with respect to their horizontal position, proceed left-to-right as far as possible until encountering either a stall or the right-most context, then resume in the left-most context. This maximizes node utilization by minimizing the chance of a dependency stall (a node, like node -, can have up to eight scheduled programs, and tasks from any of these can be scheduled).","The discussion on side-context dependencies so far has focused on true dependencies, but there is also an anti-dependency through side contexts. A program can write a given context location more than once, and normally does so to minimize memory requirements. If a program reads Llc data at that location between these writes, this implies that the context on the right also desires to read this data, but since the task for this context hasn't executed yet, the second write would overwrite the data of the first write before the second task has read it. This dependency case is handled by introducing a task switch before the second write, and task scheduling ensures that the task executes in the context on the right, because scheduling assumes that this task has to execute to provide Rlc data. In this case, however, the task boundary enables the second task to read Llc data before it is modified a second time.","5.5.1.2. Left-Side Local Context Management","The left-side context RAM is typically read-only with respect to a program executing in a local context. It is written by two write buffers which receive data from other sources, and which are used by the local node to perform dependency checking. One write buffer is for global input data, Lin, based on data written as Cin data in the context on the left. The Lin buffer has a single entry. The second buffer is for Llc data supplied by operations within the same context on the left. The Llc buffer has 6 entries, roughly corresponding to the 2 writes per cycle that can be executed by a SIMD instruction, with a 3-entry queue for each of the 2 writes (this is conceptual\u2014the actual organization is more general). These buffers are managed differently, though both perform the function of separating data transfer from RAM write cycles and providing setup time for the RAM write.","The Lin buffer stores input data sent from the context on the left, and holds this data for an available write cycle into the left-side context RAM. The left-side context RAM is typically a single-port RAM and can read or write in a cycle (but not both). These cycles are almost always available because they are unavailable in the case of a left-side context access within the same bank (on one of the 4 read ports, 32 banks), which is statistically very infrequent. This is why there is usually one buffer entry\u2014it is very unlikely that the buffer is occupied when a second Lin transfer happens, because at the system level there are at least four cycles between two Cin transfers, and usually many more than four cycles. The hardware checks this condition, and forces the buffer to empty if desired, but this is to generally ensure correctness\u2014it is nearly impossible to create this condition in normal operation.","An example of a format for the Lin buffer  can be seen in , but since the Lin buffer is generally a hardware structure, to write an entry from the Lin buffer , the Dest_Context# (field ) is used to access the associated context descriptor (which may be held in a small cache for performance, since the context is persistent during execution). The Context_Offset (field ) is added to the Context_Base_Address in the descriptor to obtain the absolute SIMD data memory address for the write. Since a SIMD can (for example) write the upper 16 bits, lower 16 bits, or both, there can be separate enables for the two halves of the 32-bit data word. Typically, the buffer  also includes fields , , , , and , which, respectively, are the entry valid bit, high write bit, low write bit, high data, and low data.","Dependency checking on the Lin buffer  can be based on the signal sent by the context on the left when it has received Set_Valid signals from all of its sources (i.e., sources which have not signaled Input_Done). This sets the Lvin state. If Lvin is not set for a context, and the SIMD instruction attempts to access left-side context, the node (i.e., -) stalls until the Lvin state is set. The Lvin state is ignored if there is no left-side context access. Also, as will be discussed below, there is a system-level protocol that prevents anti-dependencies on Lin data, so there is almost no situation where the context on the left will attempt to overwrite Lin data before it has been used.","The Llc write buffer stores local data from the context on the left, to wait for available RAM cycles. The format and use of an Llc buffer entry is similar to the Lin buffer entry and can be a hardware-only structure. Some differences with the Lin buffer are that there are multiple entries\u2014six instead of one\u2014and the context offset field, in addition to specifying the offset for writing the left-side RAM, is used also to detect hits on entries in the buffer and forward from the buffer if desired. This bypasses the left-side context RAM, so that the data can be used with virtually no delay.","As described above, Llc data is updated in the left-side context RAMs in advance of a task switch to compute Rlc data using\u2014or to ensure that Llc data is used in\u2014the context on the right. Llc data can be used immediately by the node on the right, though the nodes are not necessarily executing a synchronous instruction sequence. In almost all cases, these nodes are physically adjacent: within a partition, this is true by definition; between partitions, this can be guaranteed by node allocation with the system programming tool . In these cases, data is copied into the Llc write buffers feeding the left-side context RAMs quickly enough that data can be used without stalls, which can be an important property for performance and correctness of synchronous nodes.","Llc data can be transferred from source to destination contexts in a single cycle, and there is no penalty between update and use. Llc dependency checking can be done concurrently with execution, to properly locate and forward data as described below, and to check for stall conditions. The design goal is to transmit Llc data within one cycle for adjacent contexts, either on the same node or a physically adjacent node.","Forwarding from the Llc write buffer can be performed when the buffer is written with data destined for the current context (that is, a task is executing in the context concurrently with data transfer from the source). Concurrent contexts arise when the last context on one node is sharing data concurrently with the first context on the adjacent node to the right (for example, in  on node -can be a concurrent source for - on node -(1)). This distinction can be used since dependency checking and forwarding are not correct when data is being written to a context that will be used by a future task, rather than one executing concurrently. For example, in , task - on node -provides Llc data to task - on node -(1) during the execution of task - on node -(1), and this should not cause dependency checking or forwarding to task -.","For a given configuration of context descriptors, the right-context pointer of a source context forms a fixed relationship with its destination context. Thus each destination context has static association with the source, for the duration of the configuration. This static property can be important because, even if the source context is potentially concurrent, the source node can be executing ahead of, synchronously with, behind, or non-concurrently with, the destination context, since different nodes can have private program counters or PCs and private instruction memories. The detection of potential concurrency is based on static context relationships, not actual task states. For example, a task switch can occur into a potentially concurrent context from a non-concurrent one and should be able to perform dependency checking even if the source context has not yet begun execution.","If the source context is not concurrent with the destination, then there is no dependency checking or forwarding in the Llc buffer. An entry is allocated for each write from the source, and the information in the entry used to write the left-side context RAM. The order of writes from the source is generally unimportant with respect to writes into the destination context. These writes simply populate the destination context with data that will be used later, and the source cannot write a given location twice without a context switch that permits the destination to read the value first. For this reason, the Llc buffer can allocate any entries, in any order, for any writes from the source.","Also, regardless of the order in which they were allocated, the buffer can empty any two entries which target non-accessed banks (that is, when there are no left-side context accesses to the banks). Six entries are provided (compared to the single entry for the Lin buffer) because SIMD writes are much more frequent than global data writes. Despite this, there statistically are still many available write cycles, since any two entries can be written in any order to any set of available banks, and since the left-side RAM banks are available more frequently that center RAM banks, because they are free except when the SIMD reads left-side context (in contrast to the center context which is usually accessed on a read). It is very unlikely that the write buffer will encounter an overflow condition, though the hardware does check for this and forces writes if desired. For example, six entries can be specified so that the Llc buffer can be managed as a first-in-first-out (FIFO) of two writes per cycle, over three cycles, if this simplifies the implementation. Another alternative can be to reduce the number of entries and using random allocation and de-allocation.","When the non-concurrent source task suspends, this is signaled to the destination context and sets the Lvlc state in that context. This state indicates that the context should not use the dependency checking mechanism for concurrent contexts. It also is used for anti-dependency checking. The source context cannot again write into the destination context until it has been processed and its task has ended, resetting the Lvlc state. This condition is checked because task pre-emption can re-order execution, so that the source node resumes execution before the destination node has used the Llc data. This is a stall condition that the scheduler attempts to work around by further pre-emption.","Since adjacent nodes (i.e., -and -(1)) can use different program counters or PCs and instruction memories and since these adjacent nodes have different dependencies and resource conflicts, a source of Llc data does not necessarily execute synchronously with its destination, even if it is potentially concurrent. Potentially concurrent tasks might or might not execute at the same time, and their relative execution timing changes dynamically, based on system-level scheduling and dependencies. The source task may: 1) have executed and suspended before the destination context executes; 2) be any number of instructions ahead of\u2014or exactly synchronous with\u2014the destination context; 3) be any number of instructions behind the destination context; or 4) execute after the destination context has completed. The latter case occurs when the destination task does not access new Llc context from the source, but instead is supplying Rlc context to a future task and\/or using older Llc context.","The Llc dependency checking generally operates correctly regardless of the actual temporal relationship of the source and destination tasks. If the source context executes and suspends before the destination, the Llc buffer effectively operates as described above for non-concurrent tasks, and this situation is detected by the Lvlc state being set when the destination task begins. If the Lvlc state is not set when a concurrent task begins execution, Llc buffer dependency checking should provide correct data (or stall the node) even though the source and destination nodes are not at the same point in execution. This is referred to as real-time Llc dependency checking","Real-time Llc dependency checking generally operates in one of two modes of operation, depending on whether or not the source is ahead of the destination. If the source is ahead of the destination (or synchronous with it), source data is valid when the destination accesses it, either from the Llc write buffer or the left-side context RAM. If the destination is ahead of the source, it should stall and wait on source data when it attempts to read data that has not yet been provided by the source. It cannot stall on just any Llc access, because this might be an access for data that was provided by some previous task, in which case it is valid in the left-side RAM and will not be written by the source. Dependency checking should be precise, to provide correct data and also prevent a deadlock stall waiting for data that will never arrive, or to avoid stalling a potentially large number of cycles until the source task completes and sets the Lvlc state, which releases the stall, but very inefficiently.","To understand how real-time dependencies are resolved, note that, though the source and destination contexts can be offset in time, the contexts are executing the same instruction sequence and generating the same SIMD data memory write sequence. To some degree, the temporal relationship does not matter because there is a lot of information available to the destination about what the source will do, even if the source is behind: 1) writes appear at the same relative locations in the instruction sequence; 2) write offsets are identical for corresponding writes; and 3) a write to a dependent Llc location can occur once within the task.","For real-time dependency checking, the temporal relationship of the source and destination is determined by a relative count of the number of active write cycles\u2014that is, cycles in which one or more writes occur (the number of writes per cycle is generally unimportant). For example, there can be two, 16-bit counters in each node (i.e., -), associated with Llc dependency checking. One counter, the source write count, is incremented for an active write cycle received from a source context, regardless of the source or destination contexts. When a source task completes, the counter is reset to 0, and begins counting again when the next source task begins. The second counter, the destination write counter, is incremented for an active write cycle in the destination context, but when the source task has not completed when the destination task is executing (determined by the Lvlc state). These counters, along with other information, determine the temporal relationship of source and destination and how dependency checking is accomplished.","When a destination task begins and Lvlc state is not set, this indicates that the source task has not completed (and may not have begun). The destination task can execute as long as it does not depend on source data that has not been provided, and it should stall if it is actually dependent on the source. Furthermore, this dependency checking should operate correctly even in extreme cases such as when the source has not begun execution when the destination does, but does start at a later point in time and then moves ahead of the destination. The destination generally checks the following conditions:\n\n","It is relatively easy for the destination to detect that the source is active, because the contexts have a fixed relationship. The source context can signal when it is in execution, because its context descriptor is currently active. If the source is active, whether or not it is ahead is determined by the relationship of the source and destination write counters. If the source counter is greater than the destination counter, the source is ahead. If the source counter is less than the destination counter, it is behind. If the source counter is equal to the destination counter, the source and destination contexts are executing synchronously (at least temporarily). If a destination context is behind or synchronous with the source context, then it accesses valid data either from the left-side RAM or the Llc write buffer. If the destination context is ahead of the source context, it should keep track of future source context writes and stall on an Llc access to a location that hasn't been written yet. This is accomplished by writing into the left-side RAM (the value is unimportant), and resetting a valid bit in the written location. Because dependent writes are unique, any number of locations can be written in this way to indicate true dependencies, and there are no output dependencies (i.e. there are no multiple writes to be ordered for destination reads).","So Llc real-time dependency checking generally operates as follows:\n\n","As described above, Rlc data is provided by task sequencing. There will usually be a task switch between the write and the read, and, in most cases, the next task will not desire this Rlc data, because task scheduling prefers tasks that generate both Llc data and Rlc data, rather than a previous task that uses Rlc data.","Rlc dependencies cannot generally be checked in real time because the source and destination tasks do not execute the same instructions (the code is sequential, not concurrent), and this is a key property enabling real-time dependency checking for Llc data. It is required that the source task has suspended, setting the Rvlc state, before the destination task can access right-side context (it stalls on an attempted access of this context if Rvlc is reset). This can stall a task unnecessarily, because it does not detect that the read is actually dependent on a recent write, but there is no way to detect this condition. This is one reason for providing task pre-emption, so that the SIMD can be used efficiently even though tasks are not allowed to execute until it is known that all right-side source data should have been written. When the destination tasks suspends, it resets the Rvlc state, so it should be set again by the source after it provides a new set of Rlc context. There are write buffers for Rin and Rlc data, to avoid contention for RAM banks on the right-side context RAM. These buffers have the same entry format and size as the Lin and Llc write buffers. However, the Rlc write buffer is not used for forwarding as the Llc write buffer is.","5.5.2. Global Context Management","Global context management relates to node input and output at the system level. It generally ensures that data transfer into and out of nodes is overlapped as much as possible with execution, ideally completely overlapped so there are no cycles spent waiting on data input or stalled for data output. A feature of processing cluster  is that no cycles are spent, in the critical path of computation, to perform loads or stores, or related synchronization or communication. This can be important, for example, for pixel processing, which is characterized by very short programs (a few hundred instructions) having a very large amount of data interaction both between nodes whose contexts relate through horizontal groups, and between nodes that communicate with each other for various stages of the processing chain. In nodes (i.e., -), loads and stores are performed in parallel with SIMD operations, and the cycles do not appear in series with pixel operations. Furthermore, global-context management operates so that these loads and stores also imply that the data is globally coherent, without any cycles taken for synchronization and communication. Coherency handles both true and anti-dependencies, so that valid data is usually used correctly and retained until it is no longer desired.","5.5.2.1. Context-Coherency Protocols","In general, input data is provided by a system peripheral or memory, flows into node contexts, is processed by the contexts, possibly including dataflow between nodes and hardware accelerators, and results are output to system peripherals and memory. Contexts can have multiple inputs sources, and can output to multiple destinations, either independently to different destinations or multi-casting the same data to multiple destinations. Since there are possibly many contexts on many nodes, some contexts are normally receiving inputs, while other contexts are executing and producing results. There is a large amount of potential overlap of these operations, and very likely that node computing resources can approach full utilization, because nodes execute on one set of contexts at a time out of the many contexts available. The system-coherency protocols guarantee correct operation at all times. Even though hardware can be kept fully busy in steady state, this cannot always be guaranteed, especially during startup phases or transitions between different use-cases or system configurations.","Data into and out of the processing cluster  is under control of the GLS unit , which generates read accesses from the system into the node contexts, and writes context output data to the system. These accesses are ultimately determined by a program (from a hosted environment) whose data types reflect system and data which is compiled onto the GLS processor  (described in detail below). The program copies system variables into node program-input variables, and invokes the node program by asserting Set_Valid. The node program computes using input and retained private variables, producing output which writes to other processing cluster  contexts and\/or to the system. The programs are structured so that they can be compiled in a cross-hosted development (i.e., C++) environment, and create correct results when executed sequentially. When the target is the processing cluster , these programs are compiled as separate GLS processor  (described below) and node programs, and executed in parallel, with fine-grained multi-tasking to achieve the most efficient use of resources and to provide the maximum overlap between input\/output and computation.","Because context-input data is contained in program variables, the input is fully general, representing any data types with any layout in data memory. The GLS processor  program marks the point at which the code performs the last output to the node program. This in turn marks the final transfer into the node with a Set_Valid signal (either scalar data to node processor data memory, vector data to SIMD data memory, or both). Output is conditional on program flow, so different iterations of the GLS processor  program can output different combinations of vector and scalar data, to different combinations of variables and types.","The context descriptor indicates the number of input sources, from one to four sources. There is usually one Set_Valid for every unique input\u2014scalar and\/or vector input from each source. The context should receive an expected number of Set_Valid signals from each source before the program can begin execution. The maximum number of Set_Valid signals can (for example) be eight, representing both scalar and vector from four sources. The minimum number of Set_Valid signals can (for example) be zero, indicating that no new input is expected for the next program invocation.","Set_Valid signals can (for example) be recorded using a two-bit valid-input flag, ValFlag, for each source: the MSB of this flag is set to indicate that a vector Set_Valid is expected from the source, and the LSB is set to indicate that scalar Set_Valid is expected. When a context is enabled to receive input (described below), valid-flag bits are set according to the number of source: one pair if set if there is one source, two pairs if there are two source, and so on, indicating the maximal dependency on each source. Before input is received from a source, that source sends a Source Notification message (described below) indicating that the source is ready to provide data, and indicating whether its type is scalar, vector, both, or none (for the current input set): the type is determined by the DataType field in the source's destination descriptor, and updates the ValFlag field from its initial value (the initial value is set to record a dependency before the nature of the dependency is known). As Set_Valid signals are received from a source (synchronous with data), the corresponding ValFlag bits are reset. The receipt of all Set_Valid signals is indicated by all ValFlag bits being zero.","When the desired number of Set_Valid signals has been received, the context can set Cvin and also can use side-context pointers to set Rvin and Lvin of the contexts shared to the left and right (, which shows typical states). When the context sets Rvin and Lvin of side contexts, it can also set its local copies of these bits, LRvin and RLvin. Note that this normally does not enable the context for execution because it should have its own Lvin and Rvin bits set to begin execution. Since inputs are normally provided left-to-right, input to the local context normally enables execution in the left-side context (by setting its Rvin). Execution in the local context is generally enabled by input to the right-side context (setting the local context's Rvin\u2014Lvin is already set by input to the left-side context). Normally the Set_Valid signals are received well in advance of execution, overlapped with other activity on the node. Hardware attempts to schedule tasks to accomplish this.","A similar process for transfer of input data from GLS unit  can be used for input from other nodes. Nodes output data using an instruction which transfers data to the Global Output buffer. This instruction indicates which of the destination-descriptor entries is to be used to specify the destination of the data. Based on a compiler-generated flag in the instruction which performs the final output, the node signals Set_Valid with this output. The compiler can detect which variables represent output, and also can determine at what point in the program there is no more output to a given destination. The destination does not generally distinguish between data sent by the GLS UNIT  and data sent by another node; both are treated the same, and affect the count of inputs in the same way. If a program has multiple outputs to multiple destinations, the compiler  marks the final output data for each output in the same way, both scalar and vector output as applicable.","Because of conditional program flow, it is possible that the initial Source Notification message indicates expected data that is not generally provided, because the data is output under program conditions that are not satisfied. In this case, the source signals Input_Done in a scalar data transfer, indicating that all input has been provided from the source despite the initial notification: the data in this transfer is not valid, and is not written into data memory. The Input_Done signal resets both ValFlag bits, indicating valid data from the corresponding source. In this case, data that was previously provided is used instead of new input data.","The compiler  marks the final output depending on the program flow-control that generates the output to a given destination. If the output does not depend on flow-control, there is no Input_Done signal, since the Set_Valid is usually signaled with the final data transfer. If the output does depend on flow-control, Input_Done follows the last output in the union of all paths that perform output, of either scalar or vector data. This uses an encoding of the instruction that normally outputs scalar data, but the accompanying data is not valid. The use of this encoding can be to signal to the destination that there is no more current output from the source.","As mentioned previously, context input data can be of any type, in any location, and accessed randomly by the node program. The point at which the hardware, without assistance, can detect that input data is no longer desired is when the program ends (all tasks have executed in the context). However, most programs generally read input data relatively early in execution, so that waiting until the program ends makes it likely that there are a significant number of cycles that could be used for input which go unused instead.","This inefficiency can be avoided using a compiler-generated flag, Release_Input, to indicate the point in the program where input data is no longer desired. This is similar in concept to the detection of the Set_Valid point, except that it is based on compiler recognizing at what point in the code input variables will not generally be accessed again. This is the earliest point at which new inputs can be accepted, maximizing potential overlap of data transfer and computation.","The Release_Input flag resets the Cvin, Lvin, and Rvin of the local context ( which shows typical states). When the context resets Lvin and Rvin, it also resets the copies of these bits, RLvin and LRvin, in the left-side and right-side contexts. Note that this normally doesn't enable the context to receive input, because inputs should be released in all three contexts (left, center, and right) before it can be overwritten by data received as Cin data to the local context. Since execution is normally left-to-right, a Release_Input in the local context normally enables input to the left-side context (by resetting its RLvin). Input to the local context is enabled by a Release_Input in the right-side context (resetting the local context's RLvin\u2014LRvin is already reset by a Release_Input in the left-side context). The local copies of valid-input bits (LRvin and RLvin) are provided to simplify the implementation, so that decisions to enable input can be based entirely on local state (Cvin=LRvin=RLvin=0), instead of having to \u201cfetch\u201d state from other contexts. Input is enabled by setting the Input Enabled (InEn) bit.","Once a context receives all required Set_Valid signals indicating that all input data is valid, it cannot receive any more input data until the program indicates that input data is no longer desired. It is undesirable to stall the source node using in-band handshaking signals during an unwanted transfer, since this would tie up global interconnect resources for an extended period of time\u2014potentially with hundreds of rejected transfers before an accepted one. Considering the number of source and destination contexts that can be in this situation, it is very likely that global interconnect  would be consumed by repeated attempts to transfer, with a large, undesired use of global resources and power consumption.","Instead, processing cluster  implements a dataflow protocol that uses out-of-band messages to send permissions to source contexts, based on the availability of destination contexts to receive inputs. This protocol also enables ordering of data to and from threads, which includes transfers to and from system memory, peripherals, hardware accelerators, and threaded node contexts\u2014the term thread is used to indicate that the dataflow should have sequential ordering. The protocol also enables discovery of source-destination pairs, because it is possible for these to change dynamically. For example, a fetch sequence from system memory by the GLS unit  is distributed to a horizontal group of contexts, though neither the program for the GLS processor (discussed below) nor the GLS unit  has any knowledge of the destination context configuration. The context configuration is reflected in distributed context descriptors, programmed by Tsys based on memory-allocation requirements. This configuration can vary from one use-case to another even for the same set of programs.","For node contexts, source and destination associations are formed by the sources' destination descriptors, indicating for each center-context pointer where that output is to be sent. For example, the left-most source context is configured to send to a left-most destination context (it can be either on the same node or another). This abstracts input\/output from the context configurations, and distributes the implementation, so there is no centralized point of control for dependencies and dataflow, which would likely be a bottleneck limiting scalability and throughput.","In , an example of how center contexts are associated regardless of organization can be seen. Here, Here, four nodes (labeled node -through node -), with three contexts each, output to three nodes (labeled node -through node -), with four contexts each. These contexts in turn output to two nodes (labeled node -through node -), with six contexts each.","Image context (for example) generally cannot be retained and re-used in a frame unless there is an equivalent number of node contexts at all stages of processing. There is a one-to-one relationship between the width of the frame and the width of the contexts, and data cannot be retained for re-use unless this relationship is preserved. For this reason, the figure shows all node groups implementing twelve contexts. Since the number of contexts is constant, the association of contexts is fixed for the duration of the configuration.",{"@attributes":{"id":"p-0509","num":"0576"},"figref":"FIG. 54","b":["808","808","808","808","808","808","808","808","808","808","808","808","718","808","808"],"i":["a ","d","g","h","f ","h","m","n","a ","d ","g ","h","d","a"]},"The dataflow protocol operates by source and destination contexts exchanging messages in advance of actual data transfer.  illustrates the operation of the dataflow protocol for node-to-node transfers. After initialization, transfers are assumed to be enabled, and the first set of outputs from sources to destinations can occur without any prior enabling. However, once a Set_Valid has been sent from a source context, the context cannot send subsequent data until the destination contexts have released input (LRvin, Cvin, RLvin reset), referred to as input enabled (InEn=1). This is signaled by exchanging messages as shown in . Additionally,  shows the operation of the dataflow protocol on a partial set of source and destination contexts. Message transfers and the data transfers are shown by the arcs, where both message and data transfers are uni-directional. The arrows indicate right-context pointers (not relevant here but important for later discussion). The sequence of the dataflow protocol in this example is as follows.","The center-context pointer for node -, context 0, points to node -, context 4, and the center-context pointer for node a (the same node, though shown separately), context 1, points to node -(also the same destination node shown separately), context 5. When each context is ready to begin execution, its pointer is used to send a Source Notification (SN) message to the destination context, indicating that the source is ready to transmit data. Nodes become ready to execute independently, and there is no guaranteed order to these messages. The SN message is addressed to the destination context using its Segment_ID.Node_ID and context number, collectively called the destination identifier (ID). The message also contains the same information for the source context, called the source identifier (ID). When the destination context is ready to accept data, it replies with a Source Permission (SP) message, enabling the source context to generate outputs. The source context also updates the destination descriptor with the destination ID received in the SP message: there are cases, described later, where the SP is received from a context different than the one to which the SN was sent, and in this case the SP is received from the actual intended destination.","Once the source output is set valid, the source context can no longer transmit data to the destination (note that normally the node does not stall, but instead executes other tasks and\/or programs in other contexts). When the source context becomes ready to execute again, it sends a second SN message to the destination context. The destination context responds to the SN message with an SP message when InEn is set. This enables the source context to send data, up to the point of the next Set_Valid, at which point the protocol should be used again for every set of data transfers, up to the point of program termination in the source context.","A context can output to several destinations and also receive data from multiple sources. The dataflow protocol is used for every combination of source-destination pairs. Sources originate SN messages for every destination, based on destination IDs in the context descriptor. Destinations can receive multiples of these messages and should respond to every one with an SP message to enable input. The SN message contains a destination tag field (Dst_Tag) identifying the corresponding destination descriptor: for example, a context with three outputs has three values for the Dst_Tag field, numbered 0-2, corresponding to the first, second, and third destination descriptors. The SP uses this field to indicate to the source which of its destinations is being enabled by the message. The SN message also contains a source tag field (Src_Tag) to uniquely identify the source to the destination. This enables the destination to maintain state information for each source.","Both the Src_Tag and the Dst_Tag fields should be assigned sequential values, starting with 0. This maintains a correspondence between the range of these values and fields that specify the number of sources and\/or destinations. For example, if a context has three sources, it can be inferred that the Src_Tag values have the values 0-2.","Destinations can maintain source state for each source, because source SN messages and input data are not synchronized among sources. In the extreme, a source can send an SN, the destination can respond with an SP message, and the source provide input, up to the point of Set_Valid, before any other source has sent even an SN message (this is not common, but cannot be prevented). Under these conditions, the source can provide a second SN message for a subsequent input, and this should be distinguished from SN messages that will be received for current input. This is accomplished by keeping two bits of state information for each source, as shown in . Here, SN[n] indicates a Source Notification for Src_Tag=n (the tag for the source at the destination), and SP[n] indicates the corresponding Source Permission to that source. From the idle state (00\u2032b), an SN results in an immediate SP if InEn=1, and the state transitions to 11\u2032b; if InEn=0, the SN is recorded, and the state transitions to 01\u2032b. When InEn is set in the state 01\u2032b, an SP is sent for the recorded SN, and the state transitions to 11\u2032b. In the state 11\u2032b, there are two possibilities:\n\n","As a result of the dataflow protocol, contexts can output data in any order, there is no timing relationship between them, and transfers are known to be successful ahead of time. There are no stalls or retransmissions on interconnect. A single exchange of dataflow message enables all transfers from source to destination, over the entire span of execution in the context, so the frequency of these messages is very low compared to the amount of data-exchange that is enabled. Since there is no retransmission, the interconnect is occupied for the minimum duration required to transfer data. It is especially important not to occupy the interconnect for exchanges that are rejected because the receiving context is not ready\u2014this would quickly saturate the available bandwidth. Also, because data transfers between contexts have no particular ordering with other contexts, and because the nodes provide a larger amount of buffering in the global input and global output buffers, it is possible to operate the interconnect at very high utilization without stalling the nodes. Because it enables execution to be dataflow-driven, the dataflow protocol tends to distribute data traffic evenly at the processing cluster  level. This is because, in steady state, transfers between nodes tend to throttle to the level of input data from the system, meaning that interconnect traffic will relate to the relatively small portion of the image data received from the system at any given time. This is an additional benefit permitting efficient utilization of the interconnect.","Data transfer between node contexts has no ordering with respect to transfers between other contexts. From a conceptual, programming standpoint: 1) input variables of a program are set to their correct values before a program is invoked; 2) both the writer and the reader are sequential programs; and 3) the read order does not matter with respect to the write order. In the system, inputs to different contexts are distributed in time, but the Set_Valid signal achieves functionality that is logically equivalent to the programming view of a procedure call invoking the destination program. Data is sent as a set of random accesses to destinations, similar to writing function input parameters, and the Set_Valid signal marks the point at which the program would have been \u201ccalled\u201d in a sequential order of execution.","The out-of-order nature of data transfer between nodes cannot be maintained for data involving transfers to and from system memory, peripherals, hardware accelerators, and threaded node (standalone) contexts. Outside of the processing cluster , data transfers are normally highly ordered, for example tied to a sequential address sequence that writes a memory buffer or outputs to a display. Within the processing cluster , data transfer can be ordered to accommodate a mismatch between node context organizations. For example, ordering provides a means for data movement between horizontal groups and single, standalone contexts or hardware accelerators.","It can be difficult and costly to reconstruct the ordering expected and supplied by system devices using the dataflow mechanisms that transfer data out-of-order between nodes, because this could require a very large amount of buffering to re-order data (roughly the number of contexts times the amount of input and output data per context). Instead, it is much simpler to use the dataflow protocol to keep node input\/output in order when communicating with these devices. This reduces complexity and hardware requirements.","To understand how ordering can be imposed, consider context outputs that are being sent to a hardware accelerator. The accelerator wrapper that interfaces the processing cluster  to hardware accelerators can be designed specifically to adapt to that set of accelerators, to permit re-use of existing hardware. Accelerators often operate sequentially on a small amount of context, very different than nodes operating in parallel on large contexts. For node-to-node transfers, exchanges of dataflow messages set up context associations and impose flow control to satisfy dependencies for entire programs in all contexts. For an accelerator, the flow control should be on a per-context, per-node basis so that the accelerator can operate on data in the expected order.","The term thread is used to describe ordered data transfer to and from system memory , peripherals, hardware accelerators, and standalone node contexts, referring to the sequential nature of the transfer. Horizontal groups contain information related to the ordering required by threads, because contexts are ordered through right-context pointers from the left boundary to the right boundary. However, this information is distributed among the contexts and is not available in one particular location. As a result, contexts should transmit information through the right-context pointers, in co-operation with the dataflow protocol, to impose the proper ordering.","Data received from a thread into a horizontal group of contexts is written starting at the left boundary. Conceptually, data is written into this context before transfers occur to the next context on its right (in reality, these can occur in parallel and still retain the ordering information). That context, in turn, receives data from the thread before transfers occur to the context on its right. This continues up to the right boundary, at which point the thread is notified to sequence back to the left boundary for subsequent input.","Analogously, data output from a horizontal group of contexts to a thread begins at the left boundary. Conceptually, data is sent from this context before output occurs from the context on its right (though, again, in reality these can occur in parallel). That context, in turn, sends data to the thread before transfers occur from the context on its right. This continues up to the right boundary, at which point the output sequences back to the left boundary for subsequent output.",{"@attributes":{"id":"p-0524","num":"0593"},"figref":"FIG. 57"},"When the thread is ready to provide input data, it sends an SN message to the left-boundary context (which is identified by a static entry in its destination descriptor). This SN indicates that the source is a thread (setting a bit in the message, Th=1). The SN message normally enables the destination context to indicate that it is ready for input, but a node context is ready by definition after initialization. In response to the SN message, the destination sends an SP message to the thread. This enables output to the context, and also provides the destination ID for this data (in general, the data is transferred to a context other than the one that receives the original SN message, as described below, though at start-up both the message and the data are sent to the left-boundary context). The thread records the destination ID in the destination descriptor, and uses this for transmitting data.","When the thread is ready to transmit data to the next ordered context, it sends a second SN to the left-boundary context (this occurs, at the latest, after the Set_Valid point, as shown in the figure, but can occur earlier as described below). This message has a bit set (Rt), indicating that the receiving context should forward the SN message to the next ordered context. This is accomplished by the receiving context notifying the context given by the right-context pointer that this context is going to receive data from a thread, including the thread source ID (segment, node, and thread IDs) and Src_Tag. This uses local interconnect, using the same path to the right-side context that is used to transmit side-context data.","The context to the right of the left boundary responds to this notification by sending its own SP to the thread, containing its own destination ID. This information, and the fact that the permission has been received, is stored in the thread's destination descriptor, replacing the destination ID of the left-boundary context (which is now either unused or stored in a private data buffer).","For read threads that access the system, the forwarded SN message can be transmitted before the Set_Valid point, in order to overlap system transfers and mitigate the effects of system latency (node thread sources cannot overlap because they execute sequential programs). If sufficient local buffering is available and system accesses are independent (e.g. no de-interleaving is required), the thread can initiate a transfer to the next context using the forwarded SP message, up to the point of having all reads pending for all contexts. The thread sends a number of SN messages to the sequence of destination contexts, depending on buffer availability. When all input to a context is complete, with Set_Valid, buffers are freed, and the transfer for the next destination ID can begin using the available buffers.","This process repeats up to the right-boundary context. The SP message contains a bit to indicate that the responding context is at the right boundary (Rt=1), and this indicates to the read thread the location of the boundary. At this point, the thread normally increments to the next vertical scan-line (a constant offset given by the width of the image frame, and independent of the context organization). It then repeats the protocol starting with an SN message, except in this case the SP messages are used to indicate that the destination contexts (center and side) are ready to receive data, in addition to notifying the thread of the context order. If a context receives a forwarded SN message and is not enabled for input, it records the SN message, and responds when it is ready.","When the thread is ready to transmit data for the next line, it repeats the protocol starting with an SN message, except in this case the SN message is sent to the right-boundary context with Rt=1. This is forwarded to the left-boundary context. Even though the right-boundary context does not provide side-context data to the left-boundary context, its right-context pointer points back to the left-boundary context, so that the thread can use an SN message to the right-boundary context to enable forwarding back to the left boundary.","Node thread contexts should have two destination descriptors for any given set of destination contexts. The first of these contains destination ID the left-boundary context, and doesn't change during operation. The second contains the destination ID for the current output, and is updated during operation according to information received in SP messages. Since a node has four destination descriptors, this allows usually two outputs for thread contexts. The left-boundary destination IDs are contained in the first two words, and the destination IDs for the current output are in the second two words. A Dst_Tag value of 0 selects the first and third words, and a Dst_Tag value of 1 selects the second and fourth words.",{"@attributes":{"id":"p-0532","num":"0601"},"figref":"FIG. 58"},"When the source outputs the final data, with Set_Valid, if forwards the SN message to the context given by the right-context pointer, indicating that the context should send an SN message to the thread, including the thread's destination ID and Dst_Tag (these are used to update destination descriptor, because a previous value may be stale). This uses local interconnect, using the same path to the right-side context that is used to transmit side-context data. This context then sends an SN message to the thread when it is ready to output, with its own source ID, and the thread responds with an SP message when it is ready. As with all SP message responses, this contains a destination ID that the source places in its destination descriptor\u2014the responding destination can be different than the one the original SN message is sent to (destinations can be re-routed). This SP message enables output from the source, also including a P_Incr value.","When the context at the right boundary sends an SN message to the thread, it indicates that the source context is at a right boundary (the Rt bit is set). This can cause the thread to sequence to the next scan-line, for example. Furthermore, the right-context pointer of the right-boundary context points back to the left-boundary context. This is not used for side-context data transfer, but instead permits the right-boundary context to forward the SN message for the thread to the left-boundary context.","Unlike thread sources, which can enable multiple contexts to receive data to mitigate system latency, thread destinations can be enabled for one source at a time. As long as the destination thread has sufficient input bandwidth, it should not affect performance of processing cluster . Threads that output to the system should provide enough buffering to ensure that performance is generally not affected by instantaneous system bandwidth. Buffer availability is communicated using P_Incr, so the buffer can be less than the total transfer size.","If a program attempts to output to a destination that is not enabled for output, it is undesirable to stall, because this could consume execution resources for a long period of time. Instead, there is a special form of task-switch instruction that tests for the output being enabled for a particular Dst_Tag (this is executed on the scalar core and is very unlikely to affect performance). The node processor (i.e., ) compiler generates this instruction before any output with the given Dst_Tag, and this causes a task switch if output is not enabled, so that the scheduler can attempt to execute another program. This task switch usually cannot be implemented by hardware-only, because SIMD registers are not preserved across the task boundary, and the compiler should allocate registers accordingly.","The combination of dependencies and ordering restrictions creates a potential deadlock condition that is avoided by special treatment during code generation. When a program attempts to access right-side context, and the data is not valid, there is a task switch so that the context on the right can execute and produce this data. However, one of these contexts can be enabled for output to a thread, normally the one on the left (or neither). If the context on the right attempts output, it cannot make progress because output is not enabled, but the context on the left cannot be enabled to execute until the one on the right produces right-context data and sets Rvlc.","To avoid this, code generation collects all output to a particular destination within the same task interval, the interval with the final output (Set_Valid). This permits the context on the left to forward the SN and enable output for the context on the right, avoiding this deadlock. The context on the right also produces output in the same task interval, so all such side-context deadlock is avoided within the horizontal group.","Note that there are two task-switch instructions involved in this case: the one begins the task interval for the side-context dependency and the one that tests for output being enabled. These usually cannot be the same instruction because the test for output enables is conditional on the output being enabled. The output-enable test and output instructions should be grouped as closely as possible, ideally in sequence. This provides the maximum time for the context on the right to receive the forwarded SN, exchange SN-SP messages with the destination, and enable output before the output-enable test. The round trip from SN to SP is typically 6-10 cycles, so this benefits all but very short task intervals.","Delaying the outputs to occur in the same interval usually does not affect performance, because the final output is the one that enables the destination, and the timing of this instruction is not changed by moving the others (if required) to occur in the same task interval. However, there is a slight cost in memory and register pressure, because output values have to be preserved until the corresponding output instructions can be executed, except when the instructions already naturally occur in the same interval.","Dataflow in processing cluster  programs can initiated at system inputs and terminates at system outputs. There can be any number of programs, in any number of contexts, operating between the system input and output: the relative delay of a program output from system inputs is given by the OutputDelay field in the context descriptor(s) for that program (this field is set by the system programming tool ). In addition to feed-forward dataflow paths from system input to output, there can also be feedback paths from a program to another program that precedes it in the feed-forward path (the OutputDelay of the feedback source is larger than the OutputDelay of the destination). A simple example of program feedback is illustrated in . In this example, the OutDelay value for programs A and B is 0001\u2032b, and for programs C and D is 0010\u2032b and 0011\u2032b, respectively. Feedback is represented by the blue arrow from C output to B input.","The intent in this case is for A and B to execute after the first set of inputs from the system. It is generally impossible for the output of C to be provided to B for this first set of inputs, because C depends on input from B before it can execute. Instead of operating on input from C, B should use some initial value for this input, which can be provided by the same program that provides system input: it can write any variable in B at any point in execution, so during initialization it can write data that's normally written as feedback from C. However, B has to ignore the dependency on C up to the point where C can provide data.","It is usually sufficient for correctness for B to ignore the dependency on C the first time it executes, but this is undesirable from a performance standpoint. This would permit B (and A) to execute, providing input to C, but then B would be waiting for C to complete its feedback output before executing again. This has the effect of serializing the execution of B with C: B executes and provides input to C, then waits for C to provide feedback output before it executes again (this also serializes A, because C permits input from A when it is enabled to receive new input).","The desired behavior, for performance, is to execute A and B in parallel, pipelined with C and D. To accomplish this, B should ignore the lack of input from C until the third set of input from the system, which is received along with valid data from C. At this point, all four programs can execute in parallel: A and B on new system input, and C and D pipelined using the results of previous system input.","The feedback from C to B is indicated by FdBk=1 bit in C's destination descriptor for B. This enables C to satisfy the dependencies of B without actually providing valid data. Normally, C sends an SN message to B after it begins execution. However, if FdBk is set, C sends an SN to B as soon as it is scheduled to execute (all contexts scheduled for C send SNs to their feedback destinations). These SNs indicate a data type of \u201cnone\u201d (00\u2032b), which has the effect of resetting both ValFlag bits for this input to B, enabling it for execution once it receives system input.","The SP from B in response to the SN enables C to transmit another SN, with type set to 00\u2032b, for the next set of inputs. The total number of these initial SNs is determined by the OutputDelay field in the context descriptor for C. C maintains a DelayCount field to track the number of initial SN-SP exchanges that have occurred. When DelayCount is equal to OutputDelay, C is enabled to execute using valid inputs by definition, and the SN messages reflect the actual output of C given by the destination-descriptor DataType field.","This technique supports any number of feedback paths from any program to any previous program. In all almost cases, the OutputDelay is determined by the number of program stages from system input to the context's program output, regardless of the number and span of feedback paths from the program. The value of OutputDelay determines how many sets of system inputs are required before the feedback data is valid.","Source contexts maintain output state for each destination to control the enabling of outputs to the destination, and to order outputs to thread destinations. There are two bits of state for each output: one bit is used for output to non-threads (ThDst=0), and both bits are used for outputs to threads (ThDst=1). Outputs to threads are more complex because of the desire to both forward SNs and to hold back SNs to the thread until ordering restrictions are met. To simplify the discussion, these are presented as separate state sequences.","The output-state transitions for ThDst=0 are shown in  (both state bits are shown even though one is meaningful in this case). In the figure, SN[n] indicates a Source Notification for Dst_Tag=n (the tag for the destination descriptor), and SP[n] indicates the corresponding Source Permission from the destination. The SN message to all non-thread destinations are triggered in the idle state (00\u2032b, also the initialization state) when the program begins execution, at which point it is known that there will be output, but which is normally well in advance that output. The SP message response contains the Dst_Tag, and places the corresponding output into a state where the output is enabled (01\u2032b). Outputs remain enabled until the program executes an END instruction, at which point the output state transitions back to idle.","If the output is feedback, this triggers an SN message with Type=00\u2032b as long as the value of DelayCount is less than OutputDelay. DelayCount is incremented for every SP received, until it reaches the value OutputDelay. At this point, the output state is 01\u2032b, which enables output for normal execution (the final SP is a valid SP even though it's a response to a feedback output). By the definition of OutputDelay, the context receives valid input at this point and is enabled to execute. The program has to execute an END instruction before it is enabled to send a subsequent SN, which occurs when the program executes again.","The output-state transitions for ThDst=1 are shown in . In this case, the SN message cannot be sent until two conditions are satisfied: that ordering restrictions have been met (a forwarded SN has been received) and the program has begun execution. After initialization, to meeting ordering restrictions, the left-boundary context can be enabled to output, so if Lf=1, the state is initialized to 00\u2032b, which enables an SN when the context begins execution. All other contexts, with Lf=0, are initialized to the state 11\u2032b, where they wait to receive a forwarded SN, indicating that their output is the next in order. For the state 00\u2032b, an SN is sent when the context begins execution, and the SP response enables input (01\u2032b). When outputs are enabled, additional SPs can be received to update the number of permitted outputs with P_Incr.","When the final vector output occurs, with Set_Valid the context forwards the SN message for the Dst_Tag using the right-context pointer. In most cases, the next event is that the program executes an END instruction, and the output state transitions back into the state where it is waiting for a forwarded SN message. However, the forwarded SN message enables other contexts to output and also forward SNs, so there is nothing to prevent a race condition where the context that just forwarded the SN receives a subsequent SN while it is still executing. This SN message should be recorded and wait for subsequent execution. This is accomplished by the state 10\u2032b, which records the forwarded SN message and waits until the program executes an END instruction before entering the state \u203200b, where the SN is sent when the program begins execution again.","If the output to the thread is feedback, this triggers an SN message with Type=00\u2032b as long as the value of DelayCount is less than OutputDelay. Since the output is to a thread destination, all dependencies for the horizontal group can be released by the left-most context, so this is the context that transmits feedback SN messages. DelayCount is incremented for every SP message received in the state 00\u2032b, until it reaches the value OutputDelay. At this point, the output state is 01\u2032b, which enables left-most context output for normal execution (the final SP message is a valid SP even though it is a response to a feedback output). By the definition of OutputDelay, the context receives valid input at this point and is enabled to execute. When the final vector output occurs, with Set_Valid, the context forwards the SN message, and normal operation begins.",{"@attributes":{"id":"p-0554","num":"0623"},"figref":"FIG. 62"},"The output-state transitions for Th=1, ThDst=0 are shown in . The SN to the first context of a non-thread destination is triggered in the idle state (00\u2032b, also the initialization state) when the program begins execution. The SP message response contains the Dst_Tag, and places the corresponding output into a state where the output is enabled (01\u2032b). Outputs remain enabled until the program signals a Set_Valid to this context, at which point the output state transitions back to idle (00\u2032b). If the program is still executing (normally in an iteration loop), it sends an SN message with Rt=1 to enable the first destination context to forward to the next destination context, to satisfy ordering restrictions. This results in an SP message from the new destination (with a new destination ID that updates the destination descriptor).","If the output is feedback, this triggers an SN message with Type=00\u2032b as long as the value of DelayCount is less than OutputDelay. However, in this case the SN message has to be forwarded to all destination contexts, and the DelayCount value has to reflect an SN message to all of these context contexts. Since the context isn't executing, it cannot distinguish, in the state 00\u2032b, whether or not the SN message should have Rt set or not. Instead, the state 10\u2032b is used in the feedback case to send the SN message with Rt=1, at which point the state transitions to 11\u2032b and the context waits for the SP message from the next context: in this state, if Rt=1 in the previous SP message, indicating the right-boundary context, DelayCount is incremented. The next SP message causes a transition to the 01\u2032b state. The transition 01\u2032b.fwdarw.10\u2032b.fwdarw.11\u2032b.fwdarw.01\u2032b continues until an SN message with RT=1 has been sent to the right-boundary context, and DelayCount has then been incremented to the value OutputDelay. At this point, the output state is 01\u2032b, which enables output for normal execution (the final SP message is a valid SP message, from the left-boundary context, even though it is a response to a feedback output). By the definition of OutputDelay, the context receives valid input at this point and is enabled to execute. When the program signals Set_Valid it transitions to the state 00\u2032b and normal operation resumes.","The output-state transitions for Th=1, ThDst=1 are shown in  (both state bits are shown even though one is meaningful in this case). The SN message to the destination is triggered in the idle state (00\u2032b, also the initialization state) when the program begins execution. The SP message response enables input (01\u2032b) up to the number of transfers determined by P_Incr. When output is enabled, additional SP messages can be received to update the number of permitted outputs with P_Incr. Outputs remain enabled until the program executes an END instruction, at which point the output state transitions back to idle.","If the output to the thread is feedback, this triggers an SN message with Type=00\u2032b as long as the value of DelayCount is less than OutputDelay. DelayCount is incremented for every SP message received in the state 00\u2032b, until it reaches the value OutputDelay. At this point, the output state is 01\u2032b, which enables context output for normal execution (the final SP message is a valid SP message even though it's a response to a feedback output). By the definition of OutputDelay, the context receives valid input at this point and is enabled to execute. The program has to execute an END instruction before it's enabled to send a subsequent SN message, which occurs when the program executes again.","Programs can be configured to iterate on dataflow, in that they continue to execute on input datasets as long as these datasets are provided. This eliminates the burden of explicitly scheduling the program for every new set of inputs, but creates the requirement for data sources to signal the termination of source data, which in turn terminates the destination program. To support this, the dataflow protocol includes Output Termination messages that are used to signal the termination of a source program or a GLS read thread.","Output Termination (OT) messages are sent to the output destinations of a terminating context, at the point of termination, to indicate to the destination that the source will generate no more data. These messages are transmitted by contexts in turn as they terminate, in order to terminate all dataflow between contexts. Messages are distributed in time, as successive contexts terminate, and terminated contexts are freed as early as possible for new programs or inputs. For example, a new scan-line at the top of a frame boundary can be fetched into left-most contexts as right-side contexts are finishing execution at the bottom boundary of the previous frame.",{"@attributes":{"id":"p-0561","num":"0630"},"figref":"FIG. 64","ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":{"@attributes":{"id":"ul0023-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":["An OT from a thread is sent to the left-boundary context that is a destination of the thread (this was the first output destination from the thread, which is static information available to the thread). All other possible destinations of the read thread should be notified. This is accomplished by the left-boundary context, when it terminates due to the original message, signaling the termination to the context given by its right-context pointer: this is similar to the signaling used to order thread transfers. This local signaling indicates that the terminating source is a thread, so that this context in turn can notify its right-side context upon termination. This action repeats up to the right-boundary context, but it generally occurs as each context terminates, not immediately. When all program contexts have terminated on a node, the node sends a Node Program Termination message to the Control Node , and can be scheduled for new sets of input data or new programs as other contexts in the horizontal group terminate.","If an OT is received from a non-thread context, and an output or outputs are to other non-thread contexts, an OT is sent to all such destination contexts when the receiving context terminates. These messages indicate that the source is not a thread, so the receiving contexts desire not propagate the termination through right-context pointers as they do for a thread.","If any destination context is a thread (ThDst=1), the OT cannot be sent to the destination until it is known that all associated contexts in the horizontal group have terminated (until this is true, the thread should remain active and cannot terminate). When a left-boundary context terminates, it signals this event to the context given by its right-context pointer (at the same time, it can be sending an OT to other non-thread contexts). The right-side context takes the same action upon termination, following the right-context pointers to the right-boundary context. Generally, the right-boundary context sends an OT to the thread(s), one message for each thread destination (there can be more than one).","A node program should terminate in all contexts on the node, and transmit all OTs, before it sends a Node Program Termination message to the Control Node. This is required so that dependent events (such as reconfiguration, or scheduling a new set of programs) can assume that all resources associated with the program are freed on the node. These message sequences serialize in the Control Node (which implements the messaging distribution), so there are no race conditions between OT and Node Program Termination messages."]}}}},"Typically, dataflow termination is ultimately determined by a software condition, for example the termination of a FOR loop that moves data from a system buffer. Software execution is usually highly decoupled from data transfer, but the termination condition is detected after the final data transfer in hardware. Normally, the GLS processor  (which is discussed in detail below) task that initiates the transfer is suspended while hardware completes the transfer, to enable other tasks to execute for other transfers. The task is re-scheduled when all hardware transfers are complete, and after being re-scheduled can the termination condition be detected, resulting in OT messages.","When the destination receives the OT, it can be in one of two states: either still executing on previous input, or finished execution by executing an END instruction and waiting on new input. In the first case, the OT is recorded in a context-state bit called Input Termination (InTm), and the program terminates when it executes an END instruction. In the second case, the execution of the END instruction is recorded in a context-state bit called End, and the program terminates when it receives an OT. To properly detect the termination condition, the context should reset End at the earliest indication that it is going to execute at least one more time: this is when it receives any input data, either scalar or vector, from the interconnect, and before any local data buffering. This generally cannot be based on receiving an SN, which is usually an earlier indication that data is going to be received, because it's possible to receive an SN from a program that does not provide output due to program conditions that cause it to terminate before outputting data.","It also should not matter whether a source producing data is also the one that sends the OT. All sources terminate at the same logical point in execution, and all are required to hold their OT until after they complete output for the final transfer and terminate. Thus, at least one input arrives before any OT.","Receipt of any termination signal is sufficient to terminate a program in the receiving context when it executes an END instruction. Other termination signals can be received by the context before or after termination, but they are ignored after the first one has been received.","Turning to , another example of a dataflow protocol can be seen. This protocol is performed in the background using messaging. Transfers are generally enabled in advance of the actual transfer. There are generally three cases: (1) ordered input from system distributed to contexts; (2) out-of-order flow between contexts; and (3) ordered output from contexts to system. Also, this protocol allows program dataflow to be abstracted from the system configuration. There are independent of the number of source and destination contexts, ordering, and context configurations where the hardware \u201cdiscovers\u201d the topology automatically. Data is buffered and transmitted independently of this protocol. Transfers are also generally known to succeed ahead of time.","Additionally, the dataflow protocol can be implemented using information stored in the context-state RAM. An example for a program allocated five contexts is shown in . The structure of the context descriptors (\u201cContext Descr\u201d in the figure) and the destination descriptors (\u201cDest Descr\u201d) were described above.  also shows shadow copies of the destination descriptors, that are used to retain the initial values of these descriptors. These are required because the dataflow protocol updates destination descriptors with the context of SP messages, but the initial values are still required, for two purposes. The first use is for a thread context to be able to locate the left-boundary context of a non-thread destination, in order to send an OT to this destination. The second use is to re-initialize the destination descriptors upon termination. This permits the context to be re-scheduled to execute the same program, without requiring further steps to set the destination descriptors back to their initial values","The remaining entries of the context-state RAM are used to buffer information related to the dataflow protocol and to control operation in the context. The first of these entries is a table of pending SP messages, which are to be sent once the context is free for new input, in a pending permission table. The second is a set of control information related to context dependencies and the dataflow protocol, called the dataflow state.","In , the dataflow protocol is typically implemented using information stored in the context-state RAM (within a Context Save Memory, which is described below). Typically, the context-state RAM is a large, wide RAM, which can, for example, have 16 lines by 256 bits per context. The context state for each context generally includes four groups of fields: a context descriptor (described above), a destination descriptor (described above), pending permissions table, and dataflow state table. Each of these four groups can, for example, be about 64 bits each (with each group having 16 bits). The pending permissions table and dataflow state table are generally used to buffer information related to the dataflow protocol and to control operation in the context.","Looking first to the pending permissions , which can be seen in , it is a table of pending Source Permission messages, which are to be sent once the context is free for new input. As shown, has four entries, storing the information received in Source Notification messages:\n\n","Now looking to the dataflow state , which can be seen in , it is a set of control information related to context dependencies and the dataflow protocol. As shown, there are the formats of words (i.e., words 12-15), containing the dataflow state. As shown, it can, for example, includes the following information:\n\n","The node wrapper (i.e., -), which is described below, schedules active, resident programs on the node (i.e., -) using a form of pre-emptive multi-tasking. This generally optimizes node resource utilization in the presence of unresolved dependencies on input or output data (including side contexts). In effect, the execution order of tasks is determined by input and output dataflow. Execution can be considered data-driven, although scheduling decisions are usually made at instruction-specified task boundaries, and tasks cannot be pre-empted at any other point in execution.","The node wrapper (i.e., -) can include an 8-entry queue, for example, for active resident programs scheduled by a Schedule Node Program message. This queue , which can be seen in , stores information for scheduled programs, in the order of message receipt, and is used to schedule execution on the node. Typically, this queue  is a hardware-structure, so the actual format is not generally relevant. The table shown in  is shown to illustrate the information used to schedule program execution.","Scheduling decisions are usually made at task boundaries because SIMD-register context is not preserved across these boundaries and the compiler  allocates registers and spill\/fill accordingly. However, the system programming tool  can force the insertion of task boundaries to increase the possibility of optimum task-scheduling decisions, by increasing the opportunities for the node wrapper to make scheduling decisions.","Real-time scheduling typically prioritizes programs in queue order (mostly round-robin), but actual execution is data-dependent. Based on dependency stalls known to exist in the next sequential task to be scheduled, the scheduler can pre-empt this task to execute the same program (a subsequent task) in an earlier context, and can also pre-empt a program to execute another program further down in the program queue. Pre-empted tasks or programs are resumed at the earliest opportunity once the dependencies are resolved.","Tasks are generally maintained in queue order as long as they have not terminated. Normally, the wrapper (i.e., -) schedules a program to execute all tasks in all contexts before scheduling the next entry on the queue. At this point, the program that has just completed all tasks in all contexts can either remain resident on the queue or can terminate, based on a bit in the original scheduling message (Te). If the program remains resident, it is terminated eventually by an Output Termination message\u2014this allows the same program to iterate based on dataflow rather than constantly being rescheduled. If it terminates early, based the Te bit, this can be used to perform finer-grained scheduling of task sequences using the control node  for event ordering.","Generally, hardware maintains, in the context-state RAM, an identifier of the program-queue entry associated with the context. Program-queue entries are assigned by hardware as a result of scheduling messages. This identifier is generally used by hardware to remove the program-queue entry when all execution has terminated in all contexts. This is indicated by Bk=1 in the descriptor of the context that encounters termination. The End bit in the program queue is a hint that a previous context has encountered an END instruction, and it used to control scheduling decisions for the final context (where Bk=1), when the program is possibly about to be removed from the queue . Each context transmits its own set of Output Termination messages when the context terminates, but a Node Program Termination message is not sent to the control node  until all associated contexts have completed execution.","When a program is scheduled, the base context number is used to detect whether or not any output of the program is a feedback output, and the queue-entry FdBk bit is set if and destination descriptor has FdBk set. This indicates that all associated context descriptors should be used to satisfy feedback dependencies before the program executes. When there is no feedback, the dataflow protocol doesn't start operating until the program begins execution.","Assuming no dependency stalls, program execution begins at the first entry of the task queue, at the initial program counter or PC and base context given by this entry (received in the original scheduling message). When the program encounters a task boundary, the program uses the initial PC to begin execution in the next sequential context (the previous task's PC is stored in the context save area of processor data memory, since it is part of the context for the previous task). This proceeds until the context with the Bk bit set is executed\u2014at this point, execution resumes in the base context, using the PC from that context save area (along with other processor data memory context). Execution normally proceeds in this fashion, until all contexts have ended execution. At this point, if the Te bit is set, the program terminates and is removed from the program queue\u2014otherwise it remains on the queue. In the latter case, new inputs are received into the program's contexts, and scheduling at some point will return to this program in the updated contexts.","As just described, tasks normally execute contexts from left to right, because this is the order of context allocation in the descriptors and implemented by the dataflow protocol. As explained above, this is a better match to the system dataflow for input and outputs, and satisfies the largest set of side-context dependencies. However, at the boundaries between nodes (i.e., between nodes -and -(1)), it is possible that the task which provides Rlc data, in an adjacent node, has not begun execution yet. It is also possible, for example, because of data rates at the system level, that a context has not received a Set_Valid or a Source Permission message to allow it to begin execution. The scheduler first uses task pre-emption to attempt to schedule around the dependency, then, in a more general case, uses program pre-emption to attempt to schedule around the dependency. Task and program pre-emption are described below.","Now, referring back to , task execution can be modified by task pre-emption. If the next sequential context is not ready\u2014either because Rlc source data is not yet valid, Llc destination context is not available to be written, input context is not yet valid, or the context is not yet enabled for output (assuming a non-zero number of inputs and\/or outputs)\u2014the scheduler first attempts to schedule a continuation task for the same program in the base context. Starting in the base context provides the maximum amount of time for the pre-empted context to satisfy its dependency. The context number of the pre-empted task is left in the Next_Ctx# field of the program-queue entry, the base context number is set into the Pre-empt_Ctx# field, and the Pre bit set to indicate that this context has been scheduled out-of-order (it is called the pre-emptive context). The program continues execution using pre-emptive context numbers, executing sequential contexts, until either the pre-empted context has its dependency satisfied, or the pre-empted context becomes the next sequential context and the dependency is still not resolved. If the pre-empted context becomes ready, it is scheduled to execute at the next task boundary. At this point, if the pre-empted context is not the next sequential context in the pre-emptive sequence, then the next sequential (unexecuted) pre-emptive context number is left in the Pre-empt_Ctx# field, and the Pre bit remains set. This indicates that, when the execution reaches the last sequential context, execution should resume with the context in the Pre-empt_Ctx# field. At this point, the pre-emptive context number is copied into the Next_Ctx# field, and the Pre bit is reset. From this point, normal sequential execution resumes (but pre-emption can occur again later on). If the pre-empted context becomes ready and it is also the next context to execute in the pre-emptive sequence, the Pre bit is simply reset and sequential execution resumes.","There is usually one entry on the program queue to track pre-emptive contexts, so task pre-emption is effectively nested one-deep. If a stalled context is encountered when there is a valid entry in the Pre-empt_Ctx# field (the Pre bit is set), the scheduler cannot use task pre-emption to schedule around the stall, and uses program pre-emption instead. In this case, the program-queue entry remains in its current state, so that it can be properly resumed when the dependency is resolved.","If the scheduler cannot avoid stalls using task pre-emption, it attempts to use program pre-emption instead. The scheduler searches the program queue, in order, for another program that is ready to execute, and schedules the first program that has a ready task. Analogous to task pre-emption, the scheduler will schedule the pre-empted program at the earliest task boundary after the pre-empted program becomes ready. At this point, execution returns to round-robin order within the program queue until the next point of program pre-emption.","To summarize, the schedule prefers scheduling tasks in context order given by the descriptors, until all contexts have completed execution, followed by scheduling programs in program-queue order. However, it can schedule tasks or programs out-of-order\u2014first attempting tasks and then programs\u2014but restoring the original order as soon as possible. Data dependencies keep programs in a correct order, so actual order doesn't matter for correctness. However, preferring this scheduling order is likely the most efficient in terms of matching system-level input and output.","The scheduler uses pointers into the program queue that indicate both the next program in sequential order and the pre-emptive program. It is possible that all programs are executed in the pre-emptive sequence without the pre-empted program becoming ready, and in this case the pre-emptive pointer is allowed to wrap across the sequential program (but the sequential program retains priority whenever it becomes ready). This wrapping can occur any number of times. This case arises because system programming tool  sometimes has to increase the node allocation for a program to provide sufficient SIMD data memory, rather than because of throughput requirements. However, increasing the node allocation also increases throughput for the program (i.e., more pixels per iteration than required)\u2014by a factor determined by the number of additional nodes (i.e., using three nodes instead of one triples the potential throughput of this program). This means that the program can consume input and produce output much faster than it can be provided or consumed, and the execution rate is throttled by data dependencies. Pre-emption has the effect in this case of allowing the node allocation to make progress around the stalled program, effectively bringing the pre-empted program back down to the overall throughput for the use-case.","The scheduler also implements pre-emption at task boundaries, but makes scheduling decisions in advance of these boundaries. It is important that scheduling add no overhead cycles, and so scheduling cannot wait until the task boundary to determine the next task or program to execute\u2014this can take multiple accesses of the context-state RAM. There are two concurrent algorithms used to decide between task pre-emption and program pre-emption. Since task boundaries are generally imperative\u2014determined by the program code\u2014and since the same code executes in multiple contexts, the scheduler can know the interval between task boundaries in the current execution sequence. The left-most context determines this value, and enables the hardware to count the number of cycles between the beginning of a task in this context and the next task switch. This value is placed in the program queue (it varies from task to task).","During execution in the current context, the scheduler can also inspect other entries on the program queue in the background, assuming that the context-state RAM is not desired for other purposes. If either the base, next, or pre-emptive context is ready in another program, the task-queue entry for that program is set ready (Rdy=1). At that point, this background scheduling operation returns to the next sequential program, and repeats the search: this keeps ready tasks in roughly round-robin order. By counting down the current task interval, the scheduler can determine when it is several cycles in advance of the next task boundary. At this point it can inspect the next task in the current program, and, if that task is not ready, it can decide on task pre-emption, if there is a pre-emptive task that can be run, or it can decide to schedule the next ready program in the program queue. In this manner, the scheduling decision is known with reasonably high accuracy by the time the task boundary is encountered. This also provides sufficient time to prepare for the task switch by fetching the program counter or PC for the next task from the context save area.","6. Node Architecture","6.1. Overview","Turning to , an example of a node -can be seen in greater detail. Node -is the computing element in processing cluster , while the basic element for addressing and program flow-control is RISC processor or node processor . Typically, this node processor  can have a 32-bit data path with 20-bit instructions (with the possibility of a 20-bit immediate field in a 40-bit instruction). Pixel operations, for example, are performed in a set of 32 pixel functional units, in a SIMD organization, in parallel with four loads (for example) to, and two stores (for example) from, SIMD registers from\/to SIMD data memory (the instruction-set architecture of node processor  is described in section 7 below). An instruction packet describes (for example) one RISC processor core instruction, four SIMD loads, and two SIMD stores, in parallel with a 3-issue SIMD instruction that is executed by all SIMD functional units - to -M.","Typically, loads and stores (from load store unit -) move data between SIMD data-memory locations and SIMD local registers, which can, for example, represent up to 64, 16-bit pixels. SIMD loads and stores use shared registers -for indirect addressing (direct addressing is also supported), but SIMD addressing operations read these registers: addressing context is managed by the core . The core  has a local memory  for register spill\/fill, addressing context, and input parameters. There is a partition instruction memory -provided per node, where it is possible for multiple nodes to share partition instruction memory -, to execute larger programs on datasets that span multiple nodes.","Node -also incorporates several features to support parallelism. The global input buffer -and global output buffer -(which in conjunction with Lf and Rt buffers -and -generally comprise input\/output (IO) circuitry for node -) decouple node -input and output from instruction execution, making it very unlikely that the node stalls because of system IO. Inputs are normally received well in advance of processing (by SIMD data memory - to -M and functional units - to -M), and are stored in SIMD data memory - to -M using spare cycles (which are very common). SIMD output data is written to the global output buffer -and routed through the processing cluster  from there, making it unlikely that a node (i.e., -) can stalls even if the system bandwidth approaches its limit (which is also unlikely). SIMD data memories - to -M and the corresponding SIMD functional unit - to -M are each collectively referred as a \u201cSIMD units\u201d","SIMD data memory - to -M is organized into non-overlapping contexts, of variable size, allocated either to related or unrelated tasks. Contexts are fully shareable in both horizontal and vertical directions. Sharing in the horizontal direction uses read-only memories -and -, which are typically read-only for the program but writeable by the write buffers -and -, load\/store (LS) unit -, or other hardware. These memories -and -can also be about 512\u00d72 bits in size. Generally, these memories -and -correspond to pixel locations to the left and right relative to the central pixel locations operated on. These memories -and -use a write-buffering mechanism (i.e. write buffers -and -) to schedule writes, where side-context writes are usually not synchronized with local access. The buffer -generally maintains coherence with adjacent pixel (for example) contexts that operate concurrently. Sharing in the vertical direction uses circular buffers within the SIMD data memory - to -M; circular addressing is a mode supported by the load and store instructions applied by the LS unit -. Shared data is generally kept coherent using system-level dependency protocols described above.","Context allocation and sharing is specified by SIMD data memory - to -M context descriptors, in context-state memory , which is associated with the node processor . This memory  can, for example, 16\u00d716\u00d732 bit or 2\u00d716\u00d7256 bit RAM. These descriptors also specify how data is shared between contexts in a fully general manner, and retain information to handle data dependencies between contexts. The Context Save\/Restore memory  is used to support 0-cycle task switching (which is described above), by permitting registers -to be saved and restored in parallel. SIMD data memory - to -M and processor data memory  contexts are preserved using independent context areas for each task.","SIMD data memory - to -M and processor data memory  are partitioned into a variable number of contexts, of variable size. Data in the vertical frame direction is retained and re-used within the context itself. Data in the horizontal frame direction is shared by linking contexts together into a horizontal group. It is important to note that the context organization is mostly independent of the number of nodes involved in a computation and how they interact with each other. The primary purpose of contexts is to retain, share, and re-use image data, regardless of the organization of nodes that operate on this data.","Typically, SIMD data memory - to -M contains (for example) pixel and intermediate context operated on by the functional units - top -M. SIMD data memory - to -M is generally partitioned into (for example) up to 16 disjoint context areas, each with a programmable base address, with a common area accessible from all contexts that is used by the compiler for register spill\/fill. The processor data memory  contains input parameters, addressing context, and a spill\/fill area for registers -. Processor data memory  can have (for example) up to 16 disjoint local context areas that correspond to SIMD data memory - to -M contexts, each with a programmable base address.","Typically, the nodes (i.e., node -), for example, have three configurations: 8 SIMD registers (first configuration); 32 SIMD registers (second configuration); and 32 SIMD registers plus three extra execution units in each of the smaller functional unit (third configuration).","As an example,  shown an example of SIMD unit (namely, SIMD data memory - and SIMD functional unit -), node processor , and LS unit -in greater detail can be seen. As shown in this example, SIMD functional unit -is generally comprised of eight, smaller functional units - to - uses the third configuration.","Looking first to the processor core, the node processor  generally executes all the control related instructions and holds all the address register values and special register values for SIMD units shown in register files  and  (respectively). Up to six (for example) memory instructions can be calculated in a cycle. For address register values, the address source operands are sent to node processor  from the SIMD unit shown, and the node processor  sends back the register values, which are then used by SIMD unit for address calculation. Similarly, for special register values, the special register source operands are sent to node processor  from the SIMD unit shown, and the node processor  sends back the register values.","Node processor  can have (for example) 15 read ports and six write ports for SIMD. Typically, the 15 read ports include (for example) 12 read ports that accommodate two operands (i.e., lssrc and lssrc2) for each of six memory instructions and three ports for special register file . Typically, special register file  include two registers named RCLIPMIN and RCLIPMAX, which should be provided together and which are generally restricted to the lower four registers of the 16 entry register file . RCLIPMAX and RCLIPMIN registers are then specified directly in the instruction. The other special registers RND and SCL are specified by a 4-bit register identifier and can be located anywhere in the 16 entry register file . Additionally, node processor  includes a program counter execution unit , which can update the instruction memory -","Turning now to the LS unit -and SIMD unit, the general structure for each can be seen in . As shown, the LS unit -generally comprises LS decoder , LS execution unit , logic unit , multiply unit , right execution unit , and LS data memory ; however the details regarding the data path for LS unit -are provided below. Each of the smaller functional units - through - generally (and respectively) comprises SIMD register files - to - (which can each include  registers, for example), left logic units - to -, multiply units - to -, and right logic units - to -. These left logic units - to -, multiply units - to -, and right logic units - to - are generally duplications of left, middle, and right units , , and , respectively. Additionally, similar to the LS unit -, the data path for each functional unit - to - is described below.","Additionally, for the three example configurations for a node (i.e., node -), the sizes of some components (i.e., logic unit -) or the corresponding instruction may vary, while others may remain the same. The LS data memory , lookup table, and histogram remain relatively the same. Preferably, the LS data memory  can be about 512*32 bits with the first 16 locations holding the context base addresses and the remaining locations being accessible by the contexts. The lookup table or LUT (which is generally within the PC execution unit ) can have up to 12 tables with a memory size of 16 Kb, wherein four bits can be used to select table and 14 bits can be used for addressing. Histograms (which are also generally located in the PC execution unit ) can have 4 tables, where the histogram shares the 4-bit ID with LUT to select a table and uses 8 bits for addressing. In Table 1 below, the instructions sizes for each of the three example configurations can be seen, which can correspond to the sizes of various components.",{"@attributes":{"id":"p-0601","num":"0699"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"First","Second","Third"]},{"entry":["Component","Configuration","Configuration","Configuration"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Instruction","Four sets of","Four sets of","Four sets of"]},{"entry":["memory","1024 \u00d7 182 bits","1024 \u00d7 252 bits","1024 \u00d7 318 bits"]},{"entry":"(i.e., 1404-i),"},{"entry":"which is assumed"},{"entry":"to be shared"},{"entry":"with four nodes"},{"entry":"(i.e., 808-i)"},{"entry":["Round unit (i.e.,","\u200216 bits","\u200222 bits","\u200222 bits"]},{"entry":"3450) instruction"},{"entry":["Multiply unit","\u200216 bits","\u200224 bits","\u200224 bits"]},{"entry":"(i.e., 4348)"},{"entry":"instruction"},{"entry":["Logic unit (i.e.,","\u200216 bits","\u200224 bits","\u200224 bits"]},{"entry":"4346) instruction"},{"entry":["LS unit","132 bits","160 bits","156 bits"]},{"entry":"instructions"},{"entry":["Node processor","\u20030 bits","\u200220 bits for","\u200220 bits"]},{"entry":"4322 instruction"},{"entry":["Context switch","\u20032 bits for","\u20032 bits","\u20032 bits"]},{"entry":"indication"},{"entry":["arrangement of","Context:C:LS1:","Context:C:LS1:","Context:C:LS1:"]},{"entry":["instruction line","LS2:LS3:LS4:LS5:","T20:LS2:LS3:","T20:LS2:LS3:"]},{"entry":["(Instruction","LS6:LU:MU:RU","LS4:LS5:LS6:","LS4:LS5:LS6:"]},{"entry":["Packet Format)",{},"LU:MU:RU","LU:MU:RU"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0602","num":"0700"},"figref":"FIGS. 70 and 71","b":["4306","1","4306","4306","1","4306","4306","1","4306"]},"Looking first to , this example of a SIMD data memory (i.e., -) employs two banks  and  with a single decoder  that communicates with each bank  and . Each of the banks  and  is multiplexed by multiplexers  and , respectively. The outputs from multiplexers  and  are then merged to generate the output from the SIMD data memory. As an example, this SIMD data memory can be 256\u00d796 bits, with each bank  and  being 64\u00d7192 bits and each multiplexer outputting 48 bits.","Turning to , in this example of SIMD data memory (i.e., -), two separate decoders  and  are used. Each decoder  and  is associated with banks  and , respectively. The outputs from each bank  and  are then merged. As an example, this SIMD data memory can be 128\u00d7192 bits, with each bank  and  being 64\u00d7192 bits.","6.4. SIMD Functional Unit Example","As shown in , each of SIMD functional units - to -M is comprised of many, smaller functional units (i.e., - to -) that can perform compute operations.","In , an example data path for one of the many, smaller functional units (i.e., - to -) can be seen. The SIMD data paths all generally execute the same 3-issue, Very Long Instruction Word (VLIW) instruction on different, neighboring sets of pixels (for example). A data path contains three functional units: one multiplier (Munit) and two for arithmetic, logical, and shift operations (Lunit and Runit). The latter two functional units can operate on packed data types containing two, 16-bit pixels, so the peak pixel operational throughput is five operations per SIMD data path per cycle, or  operations per node per cycle overlapped with up to four loads and two stores per cycle. Further parallelism is possible by operating multiple nodes in parallel, each executing up to 160 pixel operations per cycle. The node and system architectures are oriented around achieving a significant portion of this peak rate.","As shown, the functional unit (referred to here as ) includes a multiplexer or mux , register file (referred to here as ), execution unit , and mux . Mux  (which can be referred to as a pixel mux for imaging applications) includes muxes  and  (which are each, for example, 7:1 muxes). As shown, the register file  generally comprises muxes , , , and  (which are each, for example, 4:1 muxes) and registers , , , and . Execution unit  generally comprises muxes , , , , , , , , and , (which are each, for example, one of a 2:1, 4:1, or 5:1 mux), multiply unit (referred to here as ), left logic unit (referred to here as ), and right logic unit (referred to here as ). Muxes  and  (which can, for example be 4:1 muxes) are also included. Typically, the mux  can perform pixel selection (for example) based on an address that is provided. In Table 2 below, an example of pixel selection and pixel address can be seen.",{"@attributes":{"id":"p-0608","num":"0706"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Pixel",{}]},{"entry":[{},"Address","Pixel select"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"000","Center lane pixel"]},{"entry":[{},"001","+1 pixel (right)"]},{"entry":[{},"010","+2 pixel (right)"]},{"entry":[{},"011","Not select any pixel"]},{"entry":[{},"111","\u22121 pixel (left)"]},{"entry":[{},"110","\u22122 pixel (left)"]},{"entry":[{},"101","Not select any pixel"]},{"entry":[{},"100*","Select pre-set value (0 to F) depending on position"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In operation, functional unit  performs operations in several stages. In the first stage, instructions are loaded from instruction memory (i.e., -) to an instruction register (i.e., LS register file ). These instructions are then decoded (by LS decoder , for example). In the next few stages, there are typically pipeline delays that are one or more cycles in length. During this delay, several of the special register from file  (such as CLIP, RND) can be read. Following the pipeline delays, the register file (i.e., register file ) is read, while the operands are muxed, and execution and write back to functional unit registers (i.e., SIMD register file ), with the result being forwarded to a parallel store instruction.","As an example (which is shown in ), when for the lower 16 bits, the pixel address is 001, it means, the neighboring pixel immediately to its right desires to get loaded into the lower 16 bits. Similarly when the pixel address is 010, the second neighboring pixel or 2 away from the central pixel lane desires to get loaded into the lower 16 bits. Similarly for the high portion of the register. These can be left neighboring pixels as well. To make this possible every load accesses the entire center context memory\u2014all 512 bits so that any of the 6 pixels can be loaded into the SIMD register. When the pixel mux indicates that left or right neighboring pixels desire to be accessed and we are at the boundary\u2014then the left and right context memories are also accessed\u2014else they are not accessed. For Pixel address=100, following value gets preloaded into registers: {8\u2032h pixel_position, 1\u2032b simd_number, 4\u2032h func_number} where func_number=4\u2032hf for F0.lo pixel and 4\u2032he for F0.hi pixel etc\u2014F7.lo is 4\u2032hl and F7.hi is 4\u2032h0 where F7 is left most functional unit in a SIMD and F0 is the right most functional unit in a SIMD\u2014this functional unit numbering is repeated for each SIMD. In other words the two SIMD are called simd_left (f7, f6 . . . f0) and simd_right (f7, f6 . . . f0). F7.hi is 4\u2032h0 as that is how images are processed\u2014left most pixel is the first pixel we process. There is position dependent processing that takes place and software desires to know the pixel position which it determines using this option. The simd_number is 0 for left most SIMD, 1 for right most SIMD. Pixel_position comes from descriptor and identifies the 32 pixels for pixel position dependent software.","6.5. SIMD Pipeline","Generally, SIMD pipeline for the nodes (i.e., -) is an eight stage pipeline. In the first stage, an Instruction Packet is fetched from instruction memory (i.e., -) by the node processor (i.e., ). This Instruction Packet is then decoded in the second stage (where addresses are calculated and registers for address are read). In the third stage, bank conflicts are resolved and addresses are sent to the bank (i.e., SIMD data memory - to -M). In the fourth stage, data is loaded to the banks (i.e., SIMD data memory - to -M). A cycle can then be introduces (in the fifth stage) to provide flexability to the placement of data into the banks (i.e., SIMD data memory - to -M). SIMD execution is performed in the sixth stage, and data is stored in stages seven and eight.","The addresses for SIMD loads and SIMD stores are calculated using registers -. These registers -are read in decode stage, while address calculation are also performed. The address calculation can be either immediate address or register plus immediate or circular buffer addressing. The circular buffer addressing can also do boundary processing for loads. No boundary processing takes place for stores. Also, SIMD loads can indicate if the functional unit is accessing its central pixels or its neighboring pixels. The neighboring pixels can be its immediate 2 pixels on the left and right. Thus a SIMD register can (for example) receive 6 pixels\u20142 central pixels, 2 pixels on the left of the 2 central pixels and 2 pixels on the right of the 2 central pixels. The pixel mux is then used to steer the appropriate pixels into the low and high portion of the SIMD register. The address can be the same for the entire centre context and side context memories\u2014that is all 512 bits of center context, 32 bits of left context and 32 bits of right context memory are accessed using this address\u2014and there are 4 such loads. The data that gets loaded into the 16 functional units can be different as the data in SIMD DMEM's are different.","All addresses generated by SIMD and processor  are offsets and are relative. They are made absolute by the addition of a base. SIMD data memory's base is called Context base and this is provided by node_wrapper which is added to the offset generated by SIMD. This absolute address is what is used to access SIMD data memory. The context base is stored in the context descriptors as described above and is maintained by node wrapper based -on which context is executing. Similarly all processor  addresses as well go through this transformation. The base address is kept in the top 8 locations of the data memory  and again node wrapper -provides the appropriate base to processor  so that all addresses processor  provides has this base added to its offset.","There is also a global area reserved for spills in SIMD data memory. Following instructions can be used to access the global area:","LD *uc9, ua6, dst","ST dst, *uc9, ua6","Where uc9 is from uc9[8:0]. When uc9[8] is set, then the context base from node wrapper is not added to calculate the address\u2014the address is simply uc9[8:0]. If uc[8] is 0, then context base from wrapper is added. Using this support, variables can be stored from SIMD DMEM top address and grow downward like a stack by manipulating uc9.\n\n6.6. VIP Register and Boundary Processing\n","SIMD loads\/SIMD stores, scalar output, vector output instructions have 3 different addressing modes\u2014immediate mode, register plus immediate mode, and circular buffer addressing mode. The circular buffer addressing mode is controlled by the Vertical Index Parameter (VIP) that is held in one of the registers -and has the following format shown in . The pointer and buffer size is 4 bits for node (i.e., -). Top and Bottom boundary processing are performed when Top flag  or Bottom flag  is set. There is also a store disable  (which is one bit), a mode  (which is which is two bits that indicates a block, mirror boundary, a repeat boundary, and a maximum value), a TBOffset  (which is three bits), a pointer  (which is eight bits), a buffer size  (which is eight bits), and an HG_Size\/Block_Width  (which is eight bits). The VIP register usually valid for circular buffer addressing mode\u2014for the other 2 addressing modes, SD  is set to 0. In SIMD, circular buffer addressing instructions are decoded as unique operations. The VIP register is the lssrc2 register and the various fields as shown above are extracted. A SIMD load instruction with circular buffer addressing mode is shown below:","LD .LS-.LS *lssrc(lssrc2),sc4, ua6, dst","Circular buffer address calculation is done as follows:",{"@attributes":{"id":"p-0620","num":"0718"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if ((sc4 > 0( & BF & (sc4 > TBOffset))"]},{"entry":[{},"\u2003\u2003if (mode==2\u2032b01)"]},{"entry":[{},"\u2003\u2003\u2003\u2003m = (2* TBOffset)\u2212sc4"]},{"entry":[{},"\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003\u2003m = TBOffset"]},{"entry":[{},"else if ((sc4 < 0) & TF & ((\u2212sc4) > TBOffset))"]},{"entry":[{},"\u2003\u2003if (mode==2\u2032b01)"]},{"entry":[{},"\u2003\u2003\u2003\u2003m = (\u22122*TBOffset)\u2212sc4"]},{"entry":[{},"\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003\u2003m = \u2212TBOffset"]},{"entry":[{},"else"]},{"entry":[{},"\u2003\u2003m = sc4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0621","num":"0719"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (buffer_size == 0)"]},{"entry":[{},"\u2003\u2003Addr = lssrc + pointer + m"]},{"entry":[{},"else if ((pointer + m >)= buffer_size"]},{"entry":[{},"\u2003\u2003Addr = lssrc + pointer + m \u2212 buffer_size"]},{"entry":[{},"else if ((pointer + m) < 0)"]},{"entry":[{},"\u2003\u2003Addr = lssrc + pointer + m + buffer_size"]},{"entry":[{},"else"]},{"entry":[{},"\u2003\u2003Addr = lssrc + pointer + m"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"When the frame is at the left or right edge, the descriptor will have Lf or Rt bits set. At the edges, the side context memories do not have valid data and hence the data from center context is either mirrored or repeated. Mirroring or repeating is indicated by mode bits in VIP","register where: Mirror when mode bits=01; and Repeat when mode bits=10. Pixels at the left and right edges are mirrored\/repeated as shown below in . Boundaries are at pixel 0 and N\u22121 Here as can be seen, if side context pixel \u22121 is accessed, pixel at location 1 or B is returned. Similarly for side context pixels \u22122, N and N+1.","When Max_mode is indicated and (TF=1) or (BF=1), then register gets loaded with max value of 16\u2032h 7FFF. When Lf=1 or Rt=1 and max_mode is indicated, then again if side pixels are being accessed, the register gets loaded with max value of 16\u2032h 7FFF. Note that both horizontal boundary processing (Lf=1 or Rt=1) and vertical boundary processing (TF=1 or BF=1 and mode!=2\u2032b00) can happen at same time. Addresses do not matter when max_mode is indicated.","6.6. Partitions","6.6.1. Generally","Now, looking to the node wrapper -, it used to schedule programs that reside in partition instruction memory -, signal events on the node -, initialize the node configuration, and support node debug. The node wrapper -has been described above with respect to scheduling, using its program queue -. Here, however, the hardware structure for the node wrapper -is generally described.","In , a partition can be seen in greater detail. Typically, there can be multiple partitions for a system (i.e., processing cluster ). Each partition -to -R can include one or more nodes (i.e., -); preferable, each partition (i.e., -) has between one and four nodes. Each node (i.e., -) can communicate with one or more instruction memory (i.e., -) subsets.","As shown in , example partition -includes nodes - to -(1+m), a remote context buffer -, a remote right context buffer -, and a bus interface unit (BIU) -. BIU -(which typically comprises a crossbar) generally provides an interface between the nodes - to -(1+M) and other components (i.e., control node ) using (for example) regular, ad-hoc signaling. Additionally, BIU -can perform the local interconnect, which routes traffic between nodes within a partition, and holds staging flops for all the interconnects.","In , an example of the local interconnect within partition -can be seen (between nodes - to -(+3). Generally, the global data interconnect is hierarchical in that there is a local interconnect inside the partition which arbitrates between the various nodes (i.e., - to -(+4)) before communicating with the data interconnect . Data from the nodes - to -(+4) can be written into global IO buffers (which are generally 16\u00d7768 bits) in each node - to -(+3). When a node (i.e., -) wins arbitration, it can send data (i.e., 768 bits for 64 pixels) in several (i.e., 4) beats of bit (i.e., 256 bits for 16 pixels) to the data interconnect . Arbitration will be left node to right node with left node having the highest priority. Incoming data from data interconnect  will generally be placed in the global IO buffer from where it will update SIMD data memory for the respective node (i.e., -) when there are free cycles. If global IO buffer is full and SIMD is accessing SIMD data memory relatively constantly, which is preventing global IO buffer from updating SIMD data memory and there is incoming data for global IO buffer, node wrapper (i.e., -) will stall SIMD to accept the data from interconnect . The local interconnect (through Bus Interface Unit BUI -) in the partition -can also forward data between nodes (i.e., -) in the partition -without using data interconnect .","6.6.2 Node Wrapper","Now, looking to the node wrapper -, it used to schedule programs that reside in partition instruction memory -, signal events on the node -, initialize the node configuration, and support node debug. The node wrapper -has been described above with respect to scheduling, using its program queue -. Here, however, the hardware structure for the node wrapper -is generally described. Node wrapper -generally comprises buffers for messaging, descriptor memory (which can be about 16\u00d7256 bits), and program queue -. Generally, node wrapper -interprets messages and interacts with the SIMDs (SIMD data memories and functional units) for input\/outputs as well as performing the task scheduling and PC to node processor .","Within node wrapper -is a message wrapper. This message wrapper has a several level entry (i.e., 2-entry) buffer that is used to hold messages, and when this buffer becomes full and the target is busy, the target can be stalled to empty the buffer. If the target is busy and then buffer is not full, then the buffer holds on to the message waiting for an empty cycle to update target.","Typically, the control node  provides messages to the node wrapper -. The messages from control node can follow this example pipeline:\n\n","Turning to , an example of data endianism can be seen. Here, the GLS unit  fetches the first 64 pixels from left side of frame , where left most 16 pixels are at address 0, the next 16 pixels are at address 20 (after 256 bits or 32 bytes), and so forth. After fetching the data, the GLS unit  fetches data and returns data to SIMD's with lower most address and then increasing addresses. The first packet of data is associated with the left most SIMD and not the right most one as one might expect.","Within a SIMD, the left most pixels are associated with functional units, with F7 being the left most functional unit, then higher addresses going to F6, F5, etc. The SIMD pre-set value which identifies the functional unit and SIMD are set with the following values\u2014pixel_position is an 8 bit value that is in the descriptor context, preset_simd is 4 bit number identifying SIMD number and the least significant 4 bits are the functional unit number\u2014ranging from 0 through f:","f0_preset0_data={pixel_position, preset_simd, 4\u2032hf};","f0_preset1_data={pixel_position, preset_simd, 4\u2032hc};","f1_preset0_data={pixel_position, preset_simd, 4\u2032hd};","f1_preset1_data={pixel_position, preset_simd, 4\u2032hc};","f2_preset0_data={pixel_position, preset_simd, 4\u2032hb};","f2_preset1_data={pixel_position, preset_simd, 4\u2032ha};","f3_preset0_data={pixel_position, preset_simd, 4\u2032h9};","f3_preset1_data={pixel_position, preset_simd, 4\u2032h8};","f4_preset0_data={pixel_position, preset_simd, 4\u2032h7};","f4_preset1_data={pixel_position, preset_simd, 4\u2032h6};","f5_preset0_data={pixel_position, preset_simd, 4\u2032h5};","f5_preset1_data={pixel_position, preset_simd, 4\u2032h4};","f6_preset0_data={pixel_position, preset_simd, 4\u2032h3};","f6_preset1_data={pixel_position, preset_simd, 4\u2032h2};","f7_preset0_data={pixel_position, preset_simd, 4\u2032h1};","f7_preset1_data={pixel_position, preset_simd, 4\u2032h0};",{"@attributes":{"id":"p-0650","num":"0767"},"figref":"FIG. 84","b":["4902","4904","1416","1412","1408","1408","4910"]},"6.6.4. IO Management","The global IO buffer (i.e., -and -) is generally comprised of two parts: a data structure (which is generally a 16\u00d7256 bit structure) and control structure (which is kept generally 4\u00d718 bit structure). Generally, four entries are used for the data structure, since the data structure is 16 entries deep and each line of data occupies four entries. The control structure can be updated in two bursts with the first sets of data and, for example, can have the following fields:\n\n","Typically, the data structure of the global IO buffer (i.e., -and -) can, for example, be made up of six of 16\u00d7256 bit buffers. When input data is received from data interconnect , the input data is placed in, for example, 4 entries of the first buffer. Once the first buffer is written, the next input will be placed in the second buffer. This way, when first buffer is being read to update SIMD data memory (i.e., -), the second buffer can receive data. The third through sixth buffers are used (for example) for outputs, lookup tables, and miscellaneous operations like Scalar output and node state read data. The third through sixth buffers are generally operated as one entity and data is loaded horizontally into one entry while the first and second buffers use takes 4 entries. The third through sixth buffers are generally designed to be width of the 4 SIMD's to reduce the time it takes to push output values or a lookup table value into the output buffers to one cycle rather than four cycles it would have taken if there had been one buffer that was loaded vertically like the first and second buffers.","An example of the write pipeline for the example arrangement described above is as follows. On the first clock cycle, a command and data (i.e., burst) are presented, which are accepted on the rising edge of the second clock cycle. In third clock cycle, the data is sent to the all of the nodes (i.e., ) nodes of the partition (i.e., -). On the rising edge of the fourth clock cycle, the first entry of the first buffer from the global IO buffer (i.e., -and -) is updated. Thereafter, the remaining three entries are updated during the successive three clock cycles. Once entries for the first buffer are written, subsequent writes can be performed for the second buffer. There is a 2-bit (for example) counter that points to the appropriate buffer (i.e., first through sixth) to be written into, which is, for example, cycle seven for the second buffer, and twelve for the third buffer. Typically, four of the buffers can be unified into (for example) a 16\u00d737 bit structure with the following fields:\n\n","Turning now to the communication between global IO buffer (i.e., -and -) and the SIMD data structures of the nodes (i.e., -). Global IO buffer read and update of SIMD generally has three phases, which are as follows: (1) center context update; (2) right side context update; and (3) left side context update. To do this, the descriptor is first read using context number that is stored in the control structure, which can be performed in the first two clock cycles (for example). If the descriptor is busy, then read of descriptor is stalled till descriptor can be read. When the descriptor is read in a third clock cycle (for example), the following examples information can be obtained from descriptor:","(1) a 4-bit Right Context;","(2) a 4-bit Right node;","(3) a 4-bit Left Context;","(4) a 4-bit Left node;","(5) a Context Base; and","(6) Lf and Rt bits to see if side context updates should be done.","Typically, the context base is also added to SIMD data memory in this third cycle, and above information is stored on in a fourth cycle. Additionally, in the third clock cycle, a read for a buffer within global IO buffer (i.e., -and -) is setup, and the read is performed in the fourth cycle, reading, for example 256, bits of data. This data is then muxed and flopped in a fifth clock cycle, and the center context can be setup to be updated in a sixth clock cycle. If there is a bank conflict, then it can be stalled. At the same time, the right most two pixels can be sent for update using right context pointer (which generally consists of context number and node number). The right context pointer can be examined to see if there is a direct update to neighboring node (if the node number of current node+1=right context node number\u2212then it is a direct update), a local update to itself (if the node number of current node=right context node number, then it is a local update to its own memories), or remote update to a node that is not a neighbor (if it is not direct or local, then it is a remote update).","Looking first to direct\/local updates, in the fifth clock cycle described above, there are various pieces of information are sent out on the bus (which can be 115 bits wide). This bus is generally wide enough to carry two stores worth of information for the two stores that are possible in each cycle. Typically, the composition of the bus is as follows:","[3:0]\u2014DIR_CONT (content number);","[7:4]\u2014DIR_CNTR (counter value used for dependency checking);","[16:8]\u2014DIR_ADDR0 (address);","[48:17]\u2014DIR_DATA0 (data);","[49]\u2014DIR_EN0 (enable);","[51:50]\u2014DIR_LOHI0;","[60:52]\u2014DIR_ADDR1 (address);","[92:61]\u2014DIR_DATA1 (data);","[93]\u2014DIR_EN1 (enable);","[95:94]\u2014DIR_LOHI1;","[96]\u2014DIR_FWD_NOT_EN (forwarded notification enable);","[97]\u2014DIR_INP_EN (input initiated side context updates);","[98]\u2014SET_VIN (set_valid of right or left side contexts);","[99]\u2014RST_VIN (reset state bits);","[100]\u2014SET_VLC (set Valid Local state);","[101]\u2014SN_FWD_BUSY;","[102]\u2014INP_KILLED;","[103]\u2014INP_BUF_FULL (indication of a full buffer);","[104]\u2014OE_FWD_BUSY;","[105]\u2014OT_FWD_BUSY;","[106]\u2014SV_TH_BUSY;","[107]\u2014SV_SNRT_BUSY;","[108]\u2014WB_FULL;","[109]\u2014REM_R_FULL;","[110]\u2014REM_L_FULL;","[111]\u2014LOC_LBUF_FULL;","[112]\u2014LOC_RBUF_FULL;","[113]\u2014LOC_RST_BUSY;","[114]\u2014LOC_LST_BUSY;","[118:115]-ACT_CONT; and","[119]\u2014ACT_CONT_VAL","Turning to , partition -(which is shown in ) can be seen, showing the busses for the direct paths (- to -) and remote paths (- to -). Typically, these buses - to - and - to - can be 115 bits wide. As shown, there are direct paths between nodes - and -(1+1) (as well as other nodes within partition -), which are used for inputs and store updates when information is sent using right or left context pointers. Additionally, there are remote paths available through BIU -","When data is made available through data interconnect , the data can include a Set_Valid flag on the thirteen bit ([12]), as detailed above. A program can be dependent on several inputs, which are recorded in the descriptor, namely the In and #Inp bits. The In bit indicates that this program may desire input data and the #In bit indicates the number of streams. Once all the streams are received, the program can begin executing. It is important to remember that for a context to begin executing, Cvin, Rvin and Lvin should be set to 1. When Set Valid is received, the descriptor is checked to see if the number of Set_Valid's received is equal to number of inputs. If the number of Set_Valid's is not equal to number of inputs, then the SetValC field (two bit fields that indicates how many Set_Valid's have been received) is updated. When the number of Set_Valid's is equal to number of inputs, then the Cvin state of descriptor memory is set to 1. When the center context data memory is updated, this will spawn side context updates on the left and right using the left and right context pointers. The side contexts will obtain a context number, which will be used to read the descriptor to obtain the context base to be added to the data memory offset. At about the same point, the side context will obtain the #Inputs and SetValR, SetValL and update Rvin and Lvin in a similar manner to Cvin.","Turning now to remote updates of side contexts, remote updates are sent through a partition's BUI (i.e., -). For remote paths (as shown in ), there are no buffers in node wrapper (i.e., -); the buffers are located in the BIU (i.e., -). Data is typically captured in a 2 entry buffer in BIU (i.e., -), which can be forwarded to context interconnect (i.e., ). Remote updates through left context pointer use left context interconnect , while the right pointer uses the right context interconnect . Generally, the interconnects  and  carry data on a 128-bit data bus. For data received by a partition (i.e., -), remotely, the data is received in a buffer in receiving partition's BIU (-), which can then be forwarded to the appropriate node.","Typically, there are two types of remote transactions: master transactions and slave transactions. For master transactions, the buffer in BIU (i.e., -) is generally two entries deep, where each entry is the full bus width wide. For example, each entry can be 115 entries as this buffer can be used for side context update for stores, which can be two every cycles. For slave transaction, however, the buffer in the BIU (i.e., -) is generally three entries deep, being about two stores wide each (for example, 115 bits).","Additionally, each partition does interact with the shared function-memory , but this interaction is described below.","6.6.5. Properties of Dependency Checking for Stores","The dependency checking is based on address (typically 9 bits) match and context (typically 4 bits) match. All addresses are offsets for address comparison. Once the write buffer is read, the context base is added to offset from write buffer and then used for bank conflict detection with other accesses like loads.","When performing dependency, though, there are several properties that are to be considered. The first property is that real time dependency checking should to be done for left contexts. A reason is that sharing is typically performed in real-time using left contexts. When a right context is to be accessed, then a task switch should take place so that a different context can produce the right context data. The second property is that one write can be performed for a memory location\u2014that is two writes should not be performed in a context to same address. If there is a necessity to perform two writes, then a task switch should take place. A reason is that the destination can be behind the source. If the source performs a write followed successively a read and a write again, then at the destination, the read will see the second write's value rather than the first write's value. Using the one write property, the dependency checking relies on the fact that matches will be unique in the write buffers, and no prioritization is required as there are no multiple matches. The right context memory write buffers generally serve as a holding place before the context memory is updated; no forwarding is provided. By design when a right context load executes, the data is already in side context memory. For inputs, both left and right side contexts can be accessed any time.","6.6.6. Left Context Dependency Checking","When center context stores are updated, the side context pointers are used update the left and right contexts. The stores pointed to by right context pointer go and update the left context memory pointed to by the right context pointer. These stores enter a, for example, a six entry Source Write Buffer at the destination. Two stores can enter this buffer every cycle, and two stores can be read out to update left context memory. The source node is sending these stores and updating Source Write Buffer at destination.","As described above, dependency checking is related to the relative location of the destination node with respect to source node. If the Lvlc bit is set, it means that source node is done, and all the data destination desires have been computed. When node executes store, these stores update the left context memory of destination node, and this is the data that should to be provided when side context loads access the left context memory at destination. The left context memory is not updated by destination node; it is updated by source node. If the source node is ahead, then data has already been produced, and destination can readily access this data. If the source node is behind, then data is not ready; therefore, the destination node stalls. This is done by using counters, which are described above. The counters indicate whether source or destination is ahead or behind.","The source and destination node both can execute two stores in a cycle. The counters should to count at the right time in order to determine the dependency checking. For example, if both the counters are at 0, the destination node can execute the stores (source has not started or is synchronous), and after two delay slots, the destination node can execute a left side context load. To implement this scheme, destination node writes a 0 into left context memory (33bit or valid bit) so that when load executes, it will see a 0 on valid bit, which should stall the load. Since the store indication from source takes few of cycles to reach its destination, it is difficult to synchronize the source and destination write counters. Therefore, the stores at destination node enter a Destination Write buffer from where the stores will update a 0 into the left context memory. Note that normally a node does not update its left context memory; it is usually updated by a different node that is sharing the left context. But, to implement dependency checking, the destination node writes a 0 into the valid bit or 33bit of the left context memory. When a load now matches against the destination write buffer, the load is stalled. The stalling destination counter value is saved and when the source counter is equal or greater than the saved stalled destination counter, then load is unstalled.","Now, if the source begins producing stores with same address, then, when stores enter the source write buffer with good data, the stores are compared against the destination write buffer, and if stores match, the \u201ckill\u201d bit is set in the destination write buffer which will prevent the store from updating side context memory with 0 valid bit as source write buffer has good data and it desires to update the side context memory with good data. If the source store does not come from source, the write at destination will update the left side context memory with a 0 into the valid bit or 33bit. If a load accesses that address, then it will see a 0 and stall (note it is no longer in the destination write buffer). Thus a load can either stall due to: (1) matching against destination write buffer without the kill bit set (if the kill bit is set, then most likely the data is in source write buffer from where it can forward); or (2) does not match the destination write buffer\u2014but finds a valid bit of 0 from side context load data. As mentioned, loads at destination node can forward from source write buffer or take data from side context memory provided the 33bit or valid bit is 1. If the source write counter is greater than or equal to the destination counter, then the stores will not enter the destination write buffer.","6.6.7. Load Stall in SIMD","It should be noted that, in operation, loads first generate addresses, followed by accessing data memory (namely, SIMD data memory) and an update of the register file with the subsequent results. However, stalls can occur, and when a stall occurs, it occurs during between the accessing of data memory and the update of the register file. Generally, this stall can be due to: (1) a match against the destination write buffer; or (2) no match against the destination write buffer, but load result has its valid bit set as 0. This stall also generally coincides with address generation from subsequence packet of loads. For this load, which has stalled, its information saved so as to be recycled and once the load is successfully completed, and any following loads can proceed ahead of the stalled load. Typically, the save information generally comprises information used to restart the load, such as an address (i.e., an offset and context base), offset alone, pixel address, and so forth.","Following the update of the register file, data memory can be updates. Initially, indicators (i.e., dmem6_sten and dmem7_sten) can be used indicate stores are being set up to update data memory, and if the write buffers are full, then the stores will not be sent in following cycle. However, if the write buffers are not full, the stores can be sent to direct neighboring node, and the write buffer can be updated at the end of this cycle. Additionally, addresses can be compares against write buffers\u2014node wrappers (i.e., -) from two nodes are generally close to each other\u2014not more than 1000 \u03bcm route as an example. A new counter value is also reflected in this cycle, for example, a \u201c2\u201d if two stores are present.","Typically, there are two local buffers (for example) which are filled from the write buffers when empty. For example, if there is one entry in write buffer, one gets filled. Since, for example, there are two write buffers, the write buffers can be read in a round-robin fashion if destination write buffer is valid; otherwise, the source write buffer is read every time the local buffer is empty. During a write buffer read so as to provide entries for the local buffers, an offset can be added to the context base. If a local buffer contains data, bank conflict detection can be performed with 4 loads. If there are no bank conflicts, both can set up the side context memories.","For the left side context memory, there is one more write buffer used for local and remote stores. Both remote and local stores can happen at about same time, but local stores are given higher priority compared to remote stores. To accommodate this feature, local stores follow same pipeline as direct stores, namely:\n\n","For the left side context, there can, for example, be three buffers: left source write buffer, a left destination write buffer, and a left local-remote write buffer. Each of these buffers can, for example, be six entries deep. Typically, the left source write buffer includes data, address offset, context base, lo_hi, and context number, where the context number and offset can be used for dependency checking. Additionally, forwarding of data can be provided with this left source write buffer. The left destination write buffer generally includes an address offset, context number, and context base, which can be used for dependency checking for concurrent tasks. The left local-remote write buffer generally includes data, address offset, context base, and lo_hi, but no forwarding is provided because the left local-remote write buffer is generally shared between local and remote paths. Round-robin filling occurs between the 3 write buffers, with a left destination write buffer, and a left local-remote write buffer sharing the round robin bit. Typically, there is one round robin bit; whenever destination write buffer or left local-remote write buffers are occupied then the round robin bit is 0. These buffers can update SIMD data memory, and every cycle the round robin bit can be flips between 0 and 1.","For the right side context, there can, for example, be are two write buffers: a direct traffic write buffer and a right local-remote write buffer. Each of these write buffers can, for example, be six entries deep. Typically, the direct traffic write buffer includes data, address offset, context base, lo_hi, and context number, while the right local-remote write buffer can include data, address offset, context base, and lo_hi. These buffers do not generally have dependency checking or forwarding. Write and read of these buffers is similar to left context write buffer. Generally, the priority between right context write buffer and input write buffer is similar to left side context memory\u2014input write buffer updates go on the second port of the two write ports. Additionally, a separate round robin-bit is used to decide between the two write buffers on the right side.","A reason for a separate local-remote write buffers is that there can be concurrent traffic between direct and local, between direct and remote, and between local and remote. Managing all of this concurrent traffic becomes difficult without having the ability to update write buffer with several (i.e., 4 to 6) stores in one cycle. Building a write buffer that can update these stores in one cycle is difficult from a timing standpoint, and such a write buffer will generally have an area of a size similar to that of separate write buffers.","6.6.9. Write Buffers Stalls","Anytime there is any write buffer stall, other writes can be stalled. For example, if a node (i.e., -) is updating direct traffic on the left and right side contexts and one of the buffers become full, traffic on both paths would be stalled. A reason is that, when the SIMD unstalls, the SIMD re-issues stores. It is generally important, though, to ensure that stores are not re-issued again to a write buffer. Due to the pipeline of write buffer allocation, full is indicated when there are several (i.e., 4) writes in the write buffer\u2014that is even though two entries are available as they are empty. This way if there are two stores coming in, they can skid into the available write buffers. Using exact full detection would have required eight write buffers with two buffers for skid. Also note that when there is a stall, the stall does not see if the stall is due to one write buffer available or two write buffers available\u2014it just stalls assuming that two stores were coming from core and two entries were not available.","6.6.10. Context Base Cache and Task Switches","The write buffers should maintain context numbers so that context bases can be added to offsets received from other nodes for updating SIMD data memory. The write buffers generally maintain context bases so that, when there is a task switch, to generally ensure that write buffers are not flushed, as this will be detrimental to performance. Also, it is possible that there could be stores from several different contexts in a write buffer, which would mean that the ability to either store all these multiple context bases or read the descriptor after reading them out of the write buffer (which can also be bad as the pipeline for emptying write buffers becomes longer) is desirable. In order to make sure we do not stall the write buffer allocation because we do not have the context base, descriptors desire to be read for the various paths as soon as tasks are ready to execute\u2014this is done speculatively and the architectural copy is updated in various parts of the pipeline.","6.6.11. Speculative and Architectural States","As soon as a program has been updated, the program counter or PC is available as well as the base context. The base context can be used to: (1) fetch a SIMD context base from a descriptor; (2) fetch a processor data memory context base from a processor data memory; and (3) save side context pointers. This is done speculatively, and, once the program begins executing, the speculative copies are updated into architectural copies.","Architectural copies are updated as follows:\n\n","Speculative copies are updated at two points:\n\n","Task switches are indicated by software using (for example) a 2-bit flag. The task switches can indicate nop, release input context, set valid for outputs, or task switches. The 2-bit flag is decoded in a stage of instruction memory (i.e., -). For example, it can be assume that for a first clock cycle of Task 1 can then result in a task switch in a second clock cycle, and in the second clock cycle, a new instruction from instruction memory (i.e., -) is fetched for Task 2. The 2-bit flag is on a bus called cs_instr. Additionally, the PC can generally originate from two places: (1) from node wrapper (i.e., -) from a program if the tasks have not encountered the BK bit; and (2) from context save memory if BK has been seen and task execution has wrapped back.","6.6.12. Task Preemption","Task pre-emption can be explained using two nodes -and -(1) of . Node -in this example has three contexts (context0, context1, and context2) assigned to program. Also, in this example, nodes -and -(1) operate in an intra-node configuration, and node -(1), and the left context pointer for context 0 of node -(1) points to the right context2 of node -","There are relationships between the various contexts in node -and reception of set_valid. When set_valid is received for context0, it sets Cvin for context0 and sets Rvin for context1. Since Lf=1 indicates left boundary, nothing should to be done for left context; similarly, if Rf is set, no Rvin should to be propagated. Once context1 receives Cvin, it propagates Rvin to context0, and since Lf=1, context0 is ready to execute. Context should generally that Rvin, Cvin and Lvin are set to 1 before execution, and, similarly, the same should be true for context2. Additionally, for context2, Rvin can be set to 1 when node -(1) receives a set_valid.","Rvlc and Lvlc are generally not examined until Bk=1 is reached after which task execution wraps around and at this point Rlvc and Lvlc should be examined. Before Bk=1 is reached, the PC originates from another program, and, afterward, PC originates from context save memory. Concurrent tasks can resolve left context dependencies through write buffers, which have been described above, and right context dependencies can be resolved using programming rules described above.","The valid locals are treated like stores and can be paired with stores as well. The valid local are transmitted to the node wrapper (i.e., -), and, from there, the direct, local or remote path can be taken to update Valid locals. These bits can be implemented in flip-flops, and the bit that is set is SET_VLC in the bus described above. The context num is carried on DIR_CONT. The resetting of VLC bits are done locally using previous context number that was saved away prior to the task switch\u2014using a one cycle delayed version of CS_INSTR control.","As described above, there are various parameters that are checked to determine whether a task is ready. For now task pre-emption will be explained using input valids and local valids. But, this can be expanded to other parameters as well. Once Cvin, Rvin and Lvin are 1, a task is ready to execute (if Bk=1 has not been seen). Once task execution wraps around, in addition to Cvin, Rvin and Lvin, Rvlc and Lvlc can be checked. For concurrent tasks, Lvlc can be ignored as real time dependency checking takes over.","Also, when transitioning from between tasks (i.e., Task1 and Task2), the Lvlc for Task1 can be set when Task0 encounters context switch. At this point when the descriptor for Task1 is examined just before Task0 is about to complete using Task Interval counter, Task1 will not be ready as Lvlc is not set. However, Task1 is assumed to ready knowing that current task is 0 and next task is 1. Similarly when Task2 is, say, returning to Task 1, then again Rvlc for Task1 can be set by Task2; Rvlc can be set when context switch indication is present for Task2. Therefore, when Task1 is examined before Task2 is to be complete, Task1 will not be ready. Here again, Task1 is assumed to be ready knowing that current context is 2 and the next context to execute is 1. Of course, all the other variables (like input valids and the valid locals) should be set.","Task interval counter indicates the number of cycles a task is executing, and this data can be captured when the base context completes execution. Using Task0 and Task1 again in this example, when Task0 executes, the task interval counter is not valid. Therefore, after Task0 executes (during stage 1 of Task0 execution), speculative reads of descriptor, processor data memory are setup. The actual read happens in a subsequence stage of Task0 execution, and the speculative valid bits are set in anticipation of a task switch. During the next task switch, the speculative copies update the architectural copies as described earlier. Accessing the next context's information is not as ideal as using the task interval counter as checking whether the next context is valid or not immediately may result in a not ready task while waiting until the end of task completion may actually ready the task as more time has been given for task readiness checks. But, since counter is not valid, nothing else can be done. If there is a delay due to waiting for the task switch before checking to see if a task is ready, then task switch is delayed. It is generally important that all decisions\u2014like which task to execute and so forth are made before the task switch flags are seen and when seen, task switch can occur immediately. Of course, there are cases where after the flag is seen, task switch cannot happen as the next task is waiting for input, and there is no other task\/program to go to.","Once counter is valid, several (i.e. 10) cycles before the task is to be completed, the next context to execute is checked to whether it is ready. If it is not ready, then task pre-emption can be considered. If task pre-emption cannot be done as task pre-emption has already been done (one level of task pre-emption can be done), then program pre-emption can be considered. If no other program is ready, then current program can wait for the task to become ready.","When a task is stalled, then it can be awakened by valid inputs or local valid for context numbers that are in Nxt context number as described above. The Nxt context number can be copied with Base Context number when the program is updated. Also, when program pre-emption takes place, the pre-empted context number is stored in Nxt context number. If Bk has not been seen and task pre-emption takes place, then again Nxt context number has the next context that should execute. The wakeup condition initiates the program, and the program entries are checked one by one starting fromentry-0 until a ready entry is detected. If no entry is ready, then the process continues until a readyentry is detected which will then cause a program switch. The wakeup condition is a condition which can be used for detecting program pre-emption. When the task interval counter is several (i.e., 22) cycles (programmable value) before the task is going to complete, each programentry is checked to see if it is ready or not. If ready, then ready bits are set in the program which can be used if there are no ready tasks in current program.","Looking to task preemption, a program can be written as a first-in-first-out (FIFO) and can be read out in any order. The order can be determined by which program is ready next. The program readiness is determined several (i.e., 22) cycles before the currently executing task is going to complete. The program probes (i.e., 22 cycles) should complete before the final probe for the selected program\/task is made (i.e., 10 cycles). If no tasks or programs are ready, then anytime a valid input or valid local comes in, the probe is re-started to figure out whichentry is ready.","The PC value to the node processor  is several (i.e., 17) bits, and this value is obtained by shifting the several (i.e., 16) bits from Program left by (for example) 1 bit. When performing task switches using PC from context save memory\u2014no shifting is required.","6.6.13. Outputs","When a context begins executing, the context first sends Source Notification to see if destination is a thread or not, which is indicated by a Source Permission. The reasoning behind the first mode of operation\u2014out of reset is that when first starting, a node does not know if the output is to a thread (ordering required) or node (no ordering required). Therefore, it starts out by sending a SN message. The Lf=1 node generally does this. It will get back a SP message indicating it is not a thread. The SN and SP messages are tied together by a two bit src_tag when it comes to nodes. The Lf=1 node sends out SN message after it examines the output enables\u2014which is most significant bit of the output destination descriptor. For every destination descriptor, a SN is sent. Note that destination can be changed in SP from what was indicated in destination descriptor\u2014therefore usually take the destination information from SP message. Pipeline for this is as follows:\n\n","Assuming this program had 1-0, 1-1 and 1-2 tasks with Bk=1 set on 1-2. Then Lf=1 context which is 1-0 sends SN for say two outputs enabled. Then SP message comes in for 1-0\u2014which then forwards the \u201cenable\u201d to 1-1. When SP comes in for 1-1, OE for 1-1 is set to 1. Now that SP messages have been sent, outputs can be executed. If outputs are encountered before OE's are set, then we stall the SIMDs. This stall is like a bank conflict stall encountered in stage 3. Once the OEs are set, then stall goes away.","The program can then issue a set_valid using the 2 bit compiler flag which will reset the OE. Once the OE has been reset and we go back to executing 1-0, 1-1 etc, all contexts will now know that they are not a thread and hence can send a SN message. That is 1-0 which is Lf=1 context plus 1-1 and 1-2 will now send a SN message for outputs enabled. They will each receive a SP which will set their OE's and this time around they will not forward their SP messages like out of reset described earlier.","If the SP message indicates it is threaded, then OE is updated and data is provided to destination. Note that destination can be changed in SP message from what was indicated in destination descriptor\u2014therefore usually take the destination information from SP message. When set_valid is executed by node, it will then forward the SP message it received to the right context pointer which will then send the SN to destination. The forwarding takes place when the output is read from the output buffer\u2014this is so that we can avoid stalls in SIMD when there are back to back set_valid's. The set_valid for vector outputs is what causes the forwarding to happen. Scalar vector outputs do not do the forwarding\u2014however both will reset the OE's.","The ua6[5:0] field (for scalar and vector outptuus) carries the following information:","Ua6[5]: set_valid","Ua6[4:3]: indicates size for scalar output\n\n","Ua6[2:0]: output number (for nodes\/SFM\u2014bits 1:0 are used)","Scalar outputs are also sent on message bus  and send set_valid etc on following MReqInfo bits: (1) Bit : set_valid (internally remapped to bit  of message bus); and (2) Bit : output_killed (internally rem-mapped to bit  of message bus).","An SP messages is sent when CVIN, LRVIN and RLVIN are all 0's in addition to looking at the states for InSt. SN messages sends a 2 bit dst_tag field on bits 5:4 of payload data. These bits are from the destination descriptors\u2014bits 14:13 which have been initialized by the TSys tool\u2014these are static. The InSt bits are 2 bits wide and since we can have 4 outputs\u2014there are 8 such bits and these occupy 15:8 of word 13 and replace the older pending permission bits and source thread bits. When the SN message comes in, dst_tag is used to index the 4 destination descriptors\u2014if Dst_tag is 00\u2014then InSt0 bits are read out\u2014if pending permissions desires to be updated, word 8 is updated. InSt0 bits are 9:8 and InSt1 bits are 11:10 and so on. If the InSt bits are 00, then SP is sent and SP set 11. If now a SN message comes to same dst_tag, then InSt bits are moved to 10 and no SP message is sent. When CVIN is being set to 1, the InSt bits are checked\u2014if they are 11, they are moved to 00. If they are 10, they are moved to 01. State 01 is equivalent to having a pending permission. When release_input comes, the SP is sent (provided CVIN, LRVIN and RLVIN are all 0's) and state bits are moved to 11 and the process repeats. Note that when release input comes and LRVIN and\/or RLVIN are not 0, then when other contexts execute a release input, LRVIN and RLVIN will get locally reset when other contexts forward the release_input to reset LRVIN\/RLVIN\u2014at that point we check again if the 3 bits will be 0. If they are going to be 0\u2014then pending permissions will be sent. When InSt=00 and CVIN, LRVIN and RLVIN are not 0's, then InSt bits move to 01 from where pending permissions are sent when release input is executed.","6.6.14. SIMD Stalls","Following are sources of stalls in SIMD:\n\n",{"@attributes":{"id":"p-0739","num":"0955"},"figref":["FIGS. 86 to 91","FIG. 86","FIG. 87","FIG. 88","FIG. 89","FIG. 90","FIG. 91"],"b":["0","0"]},{"@attributes":{"id":"p-0740","num":"0956"},"figref":["FIGS. 92 to 99","FIG. 92","FIG. 93","FIG. 94","FIG. 95","FIG. 96","FIG. 97","FIGS. 98 and 99"],"b":["0","0"]},"6.6.16. Task Switch Examples","A task within a node level program (that describes an algorithm) is a collection of instructions that start from side context of input being valid and task switch when the side context of a variable computed during the task is desired or desired. Below is an example of a node level program:",{"@attributes":{"id":"p-0742","num":"0958"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* A_dumb_algorithm.c *\/"]},{"entry":[{},"Line A, B, C; \/*input*\/"]},{"entry":[{},"Line D, E, F;G \/*some temps*\/"]},{"entry":[{},"Line S; \/*output*\/"]},{"entry":[{},"D=A.center + A.left + A.right;"]},{"entry":[{},"D=C.left \u2212 D.center + C.right;"]},{"entry":[{},"E=B.left+2*D.center+B.right;"]},{"entry":[{},"<task switch>"]},{"entry":[{},"F=D.left+B.center+D.right;"]},{"entry":[{},"F=2*F.center+A.center;"]},{"entry":[{},"G=E.left + F.center + E.right;"]},{"entry":[{},"G=2*G.center;"]},{"entry":[{},"<task switch>"]},{"entry":[{},"S=G.left + G.right;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}],"figref":["FIG. 100","FIG. 101","FIG. 102","FIG. 103","FIG. 104","FIG. 105","FIG. 106","FIGS. 107 to 109"]},"Turning to , an example of a data path  for LS unit (i.e., -) can be seen in greater detail. This data path  generally includes the LS decoder , LS execution unit , LS data memory , LS register file , special register file , and PC execution unit  of . In operation, instruction address path  (which generally includes mux  and , incrementer , and add\/subtract unit ) generates an instruction address from data contained within instruction memory (i.e., -). Mux  (which can be a 4:1 mux) generates data for register file , portion  of special register file  (which uses registers RRND , RCMIN , RCMAX, and RCSL  to store ROUNDVALUE, CLIPMINVALUE, CLIPMAXVALUE, SCALEVALUE, and SIMDVALUE) from data in the LS data memory  and the instruction memory (i.e., -). The control path  (which uses muxes  and , and add\/subtract unit  to generate selection signals for mux  and an address. Additionally, there may be multiple control paths . Instructions (except load\/store to SIMD data memory) operates according to the following pipeline:","(1) Load from instruction memory to instruction register;","(2) Decode;","(3) Send request and address to LS data memory  for and SIMD register files (i.e., -);","(4) Access LS data memory  and route data to SIMD register files (i.e., -);","(5) Read register file or forwarded SIMD result for store instruction, send request, address, and data to SIMD register files (i.e., -) for store instructions; and","(6) SIMD register files (i.e., -) is updated for stores. Load\/store to SIMD data memory (i.e., -) operates according to the following pipeline:","(1) Load from IMEM to instruction register","(2) Decode (first half of address calculation).","(3) Decode (second half of address calculation), bank conflict resolution for load, address compare for store to load forwarding;","(4) Access SIMD data memory (i.e., -) and update register file end of this cycle for load results;","(5) Read register file, address calculation and bank conflict resolution for stores, sending request, address, and data to SIMD data memory for store instructions; and","(6) SIMD data memory is updated.","6.8. Instruction Set","6.8.1. Internal Number Representation","Nodes (i.e., -) in this example can use two's complement representation for signed values and targets ISP functionality. A difference between ISP and ISP functionalities is the width of operators. For ISP, the width is generally 24 bits, and for ISP, the width may change to 26 bits. For packed instructions some registers can be accessed in two halves, <register>.lo and <register>.hi, these halves are generally 12 bits wide.","6.8.2. Register Set","Each functional unit (i.e., -) has 32 registers each of which is 32 bits wide, which can be accessed as 16 bit values (unpacked) or 32 bit values (packed).","6.8.3. Multiple Instruction Issue","Nodes (i.e., -) is typically a 10-instruction issue machine, with the 11 units each capable of issuing a single instruction in parallel. The eleven units are labeled as follows: .LS, .LS, .LS, .LS, .LS, .LS, .LS, and .LS for node processor ; .M for multiply unit ; .L for logic unit ; and .R1 for round unit . The instruction set is partitioned across these 10 units, with instruction types assigned to a particular unit. In some cases a provision has been made to allow more than one unit to execute the same instruction type. For example, ADD may be executed on either .L or .R1, or both. The unit designators (.LS, .LS, .LS, .LS, .LS, .LS, .LS, .LS, .M, .L, and .R1), which follow the mnemonic, indicate to the assembler what unit is executing the instruction type. An example is as follows:",{"@attributes":{"id":"p-0759","num":"0975"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ADD .R1 RA, RB, RC"]},{"entry":[{},"\u2225 ADD .L1 RB, RC, RD"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}],"b":["4350","4346"]},"Since the nodes (i.e., -) are VLIW machines, the compiler  should move independent instructions into the delay slots for branch instruction. The hardware is set up for SIMD instructions with direct load\/store data from LS data memory . The compiler  will see LS data memory  as a large register file for data, for example:",{"@attributes":{"id":"p-0761","num":"0977"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ADD","*(reg_bank+1), *(reg_bank + 2), *reg_bank"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"which is generally equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"LD .LS1 *(reg_bank+1), RA"]},{"entry":[{},"\u2225","LD .LS2 *(reg_bank+2), RB"]},{"entry":[{},"\u2225","ST .LS3 *reg_bank,\u2003RC"]},{"entry":[{},"\u2225","LD .LS4 *(reg_bank+3), RD"]},{"entry":[{},"\u2225","ADD .L1 RA, RB, RC"]},{"entry":[{},"\u2225","ADD .R1 RA, RD, RE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"b":["4612","4618","4339"]},"The pipeline is set up so that the compiler  can see banks of SIMD data memory (i.e., -) as a huge register file. There is no store to load forwarding\u2014loads will usually take data from the SIMD data memory (i.e., -). There should to be two delay slots between store and a dependent load.","6.8.5. Store Instruction, Blocking of Stores","Output instruction is executed as a store instruction. The constant ua6 can be recoded to do the following:","Ua6[5:4]=00 will indicate Store\n\n","Vector output instructions output the lower 16 SIMD registers to a different node\u2014it can be shared function-memory  (described below) as well. All 32 bits can be updated.","Scalar outputs output a register value on the message interconnect bus (to control node ). Lower 16, upper 16, or entire 32 bits of data can be updated in the remote processor data memory . The sizes are indicated on ua6[3:2], where 01 is the lower 16 bits, 10 is upper 16 bits, 11 is all 32 bits, and 00 is reserved. Additionally, there can be four output destination descriptors. Output instructions use ua6[1:0] to indicate which destination descriptor to use. The most significant bit of ua6 can be used to perform a set_valid indication which signals completion of all data transfers for a context from a particular input, which can trigger execution of a context in the remote node. Address offsets can be 16 bits wide when outputs are to shared function-memory \u2014else node to node offsets are 9 bits wide.","6.8.7. SIMD Data Memory Intra Task Spill Line Support","There is a global area reserved for spills in SIMD data memory (i.e., 4306-1). The following instructions can to be used to access the global area:","LD *uc9, ua6, dst","ST dst, *uc9, ua6","where uc9 is from variable uc9[8:0]. When uc9[8] is set, then the context base from node wrapper (i.e., -) is not added to calculate the address\u2014the address is simply uc9[8:0]. If uc[8] is 0, then context base from wrapper (i.e., -) is added. Using this support, variables can be stored from SIMD data memory (i.e., -) top address and grow downward like a stack by manipulating uc9.\n\n6.8.8. Mirroring and Repeating for Side Context Loads\n","When the frame is at the left or right edge, the descriptor will have Lf or Rt bits set. At the edges, the side context memories do not have valid data, and, hence, the data from center context is either mirrored or repeated. Mirroring or repeating can be indicated by bit lssrc2[13] (circular buffer addressing mode).","Mirror when lssrc2[13]=","Repeat when lssrc2[13]=","Pixels at the left and right edges are mirrored\/repeated. Boundaries are at pixel 0 and N. For example, if side context pixel \u22121 is accessed, pixel at location 1 or B is returned. Similarly for side context pixels \u22122, N and N+1.","6.8.9. LS Data Memory Address Calculation","The LS data memory  (which can have a size of about 256\u00d712 bit) can have the following regions:\n\n","Instructions that can move data between node processor  and SIMD (i.e., SIMD unit including SIMD data memory - and functional unit -) are indicated in Table 3 below:",{"@attributes":{"id":"p-0776","num":"1000"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Instruction","Explanation"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MTV","Moves data from node processor 4322 register to a SIMD"]},{"entry":[{},"register (i.e., within SIMD register file 4318-1) in all"]},{"entry":[{},"functional units (i.e., 4338-1)"]},{"entry":["MFVVR","Moves data from left most SIMD functional unit (i.e., 4338-1)"]},{"entry":[{},"to register file within node processor 4322."]},{"entry":["MTVRE","Expand register in node processor 4322 to functional units"]},{"entry":[{},"(i.e., 4338-1)"]},{"entry":[{},"take a T20 register and expand it to the 32 functional units"]},{"entry":["MFVRC","Compress the functional unit registers in SIMD to one 32-bit"]},{"entry":[{},"(for example)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"4322"},"6.8.10. LDSFMEM and STFMEM","The instructions LDSDMEM and STFMEM can access shared function-memory . LDSFMEM reads a SIMD register (i.e., within -) for address and sends this over several cycles (i.e., 4) to shared function-memory . Shared function-memory  will return (for example) 64 pixels of data over 4 cycles which is then written into SIMD register 16 pixels at a time. These loads for instructions LDSDMEM have a latency of, typically, 10 cycles, but are pipelined so (for example) results for the second LDSFMEM should come immediately after the first one completes. To obtain high performance, four LDSFMEM instructions should be issued well ahead of its usage. Both LDSFMEM and STFMEM will stall if the IO buffers (i.e., within -and -) become full in node wrapper (i.e., -).","6.8.11. Assembly Syntax","The assembler syntax for the nodes (i.e., -) can be seen in Table 4 below:",{"@attributes":{"id":"p-0780","num":"1004"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type","Syntax","Explanation"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Comments",";","a single line comment"]},{"entry":["Section",".text","Indicates a block of executable"]},{"entry":["Directives",{},"instructions"]},{"entry":[{},".data","Specifies a block of constants"]},{"entry":[{},{},"or location reserved for"]},{"entry":[{},{},"constants"]},{"entry":[{},".bss","Specifies blocks of allocated"]},{"entry":[{},{},"memory which are not"]},{"entry":[{},{},"initialized"]},{"entry":["Constants","010101b","Binary Constant"]},{"entry":["(examples)","0777q","Octal Constant"]},{"entry":[{},"0FE7h","Hexadecimal"]},{"entry":[{},"1.2","Decimal Constant"]},{"entry":[{},"\u2018A\u2019","Character Constant"]},{"entry":[{},"\u201cMy string\u201d","String Constant"]},{"entry":["Equate and","<symbol>","String, which begins with an"]},{"entry":["Set",{},"alpha character, then"]},{"entry":["Directives",{},"containing a set of"]},{"entry":[{},{},"alphanumeric characters,"]},{"entry":[{},{},"underscores \u201c_\u201d or dollar signs"]},{"entry":[{},{},"\u201c$\u201d"]},{"entry":[{},"<value>","Well-defined expression, that"]},{"entry":[{},{},"is all symbols in the"]},{"entry":[{},{},"expression should be"]},{"entry":[{},{},"previously defined in the"]},{"entry":[{},{},"current source code, or it"]},{"entry":[{},{},"should be a known constant"]},{"entry":[{},"<symbol> .set <value>","Used to assign a symbol to a"]},{"entry":[{},"<symbol> .equ <value>","constant value"]},{"entry":["Parallel","||","indicate parallel instructions"]},{"entry":["Instruction",".LS# (i.e., .LS1)","LS unit designator"]},{"entry":["Syntax",".M# (i.e., .M1)","Multiply unit designator"]},{"entry":[{},".L# (i.e., .L1)","Logic unit designator"]},{"entry":[{},".R# (i.e., .R1)","Round unit designator"]},{"entry":[{},"LD .LS1 03fh, R0","Example of a load and a"]},{"entry":[{},"|| OR .L1 RC, RB, RD","parallel logic OR executed in"]},{"entry":[{},{},"the same cycle"]},{"entry":["Explicitly or","NOP","NOPs can be issued for either"]},{"entry":["Implied","LNOP","the load-store unit or the"]},{"entry":["NOPs",{},".L1\/M1\/.R1 units. The"]},{"entry":[{},{},"assembler syntax allows for"]},{"entry":[{},{},"implied or explicit NOPs."]},{"entry":["Labels","<string>:","Used to name a memory"]},{"entry":[{},{},"location, branch target or to"]},{"entry":[{},{},"indicate the start of a code"]},{"entry":[{},{},"block; <string> should begin"]},{"entry":[{},{},"with a letter"]},{"entry":["Load and","LD <des> <smem>,","Load; <des> is a unit"]},{"entry":["Store","<dmem>","descriptor; <semem> is the"]},{"entry":["Instructions",{},"source; <dmem> is the"]},{"entry":[{},{},"destination"]},{"entry":[{},"ST <des> <smem>,","Store; <des> is a unit"]},{"entry":[{},"<dmem>","descriptor; <semem> is the"]},{"entry":[{},{},"source; <dmem> is the"]},{"entry":[{},{},"destination"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Abbreviations used for instructions can be seen in Table 5 below:",{"@attributes":{"id":"p-0782","num":"1006"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Abbreviation","Explanation"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lssrc, lsdst","Specify the operands for address registers for LS units."]},{"entry":["Sdst","Specify the operands for special registers for LS units. The"]},{"entry":[{},"valid values for special registers include RCLIPMAX,"]},{"entry":[{},"RCLIPMIN, RRND, and RSCL"]},{"entry":["Src1, src2,","Specify the operands for functional unit registers (i.e.,"]},{"entry":["dst","4612)."]},{"entry":["sr1, sr2","Special register identifiers. sr1 and sr2 are two bit numbers"]},{"entry":[{},"for RCLIPMAX and RCLIPMIN while one indemnifier sr1"]},{"entry":[{},"is used for RND and SCL and is 4 bits wide."]},{"entry":["uc<number>","Specifies an unsigned constant of width <number>"]},{"entry":["p2","Specifies packed, unpacked information for SFMEM"]},{"entry":[{},"operations aka LUT\/HIS instructions."]},{"entry":["sc<number>","Specifies a signed constant of width <number>"]},{"entry":["uk<number>","Specifies an unsigned constant of width <number> for"]},{"entry":[{},"modulo value of circular addressing"]},{"entry":["uc<number>","Specifies an unsigned constant of width <number> for pixel"]},{"entry":[{},"select address from SIMD data memory"]},{"entry":["Unit","The valid values for <Unit> are LU1\/RU1\/MU1"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"An example instruction set for each node (i.e., -) can be seen in Table 6 below.",{"@attributes":{"id":"p-0784","num":"1008"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Instruction\/Pseudocode","Issuing Unit","Comments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ABS src2, dst","round unit","Absolute value"]},{"entry":["Dst = |src2|","(i.e., 4350)"]},{"entry":["ADD src1, src2, dst","logic unit (i.e.,","Signed and Unsigned"]},{"entry":["Register form:","4346)\/round","Addition"]},{"entry":["Dst = src1 + src2","unit (i.e.,"]},{"entry":["Immediate form:","4350)"]},{"entry":"Dst = src1 + uc4"},{"entry":["ADDU src1, uc5, dst","logic unit (i.e.,","Bitwise AND"]},{"entry":["Register form:","4346)\/round"]},{"entry":["Dst = src1 & src2","unit (i.e.,"]},{"entry":["Immediate form:","4350)"]},{"entry":"Dst = src1 & uc4"},{"entry":["AND src1, src2, dst","logic unit (i.e.,","Bitwise AND"]},{"entry":["Register form:","4346)"]},{"entry":"Dst = src1 & src2"},{"entry":"Immediate form:"},{"entry":"Dst = src1 & uc4"},{"entry":["ANDU src1, uc5, dst","logic unit (i.e.,","Bitwise AND"]},{"entry":["Register form:","4346)"]},{"entry":"Dst = src1 & src2"},{"entry":"Immediate form:"},{"entry":"Dst = src1 & uc4"},{"entry":["CEQ src1, src2, dst","round unit","Compare Equal"]},{"entry":["Register forms:","(i.e., 4350)"]},{"entry":"dst.lo = dst.hi = (src1 == src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"CEQ: dst.lo = dst.hi = (src1 == sc4) ? 1 : 0"},{"entry":["CEQ src1, sc5, dst","round unit","Compare Equal"]},{"entry":["Register forms:","(i.e., 4350)"]},{"entry":"dst.lo = dst.hi = (src1 == src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"CEQ: dst.lo = dst.hi = (src1 == sc4) ? 1 : 0"},{"entry":["CEQU src1, uc4, dst","round unit","Unsigned Compare"]},{"entry":["dst.lo = dst.hi = unsigned (src1 == uc4) ? 1 : 0","(i.e., 4350)","Equal"]},{"entry":["CGE src1, sc4, dst","round unit","Compare Greater Than"]},{"entry":["dst.lo = dst.hi = (src1 >= sc4) ? 1 : 0","(i.e., 4350)","or Equal To"]},{"entry":["CGEU src1, uc4, dst","round unit","Unsigned Compare"]},{"entry":[{},"(i.e., 4350)","Greater Than or Equal"]},{"entry":[{},{},"To"]},{"entry":"dst.lo = dst.hi = unsigned (src1 >= uc4) ? 1 : 0"},{"entry":["CGT src1, sc4, dst","round unit","Compare Greater Than"]},{"entry":["dst.lo = dst.hi = (src1 > sc4) ? 1 : 0","(i.e., 4350)"]},{"entry":["CGTU src1, uc4, dst","round unit","Unsigned Compare"]},{"entry":["dst.lo = dst.hi = unsigned (src1 > uc4) ? 1 : 0","(i.e., 4350)","Greater Than"]},{"entry":["CLE src1, src2, dst","round unit","Compare Less Than"]},{"entry":["Register forms:","(i.e., 4350)"]},{"entry":"dst.lo = dst.hi = (src1 <= src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"dst.lo = dst.hi = (src1 <= sc4) ? 1 : 0"},{"entry":["CLE src1, sc4, dst","round unit","Compare Less Than"]},{"entry":["Register forms:","(i.e., 4350)"]},{"entry":"dst.lo = dst.hi = (src1 <= src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"dst.lo = dst.hi = (src1 <= sc4) ? 1 : 0"},{"entry":["CLEU src1, src2, dst","round unit","Unsigned Compare"]},{"entry":["Register forms:","(i.e., 4350)","Less Than"]},{"entry":"dst.lo = dst.hi = unsigned (src1 <= src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"dst.lo = dst.hi = unsigned (src1 <= uc4) ? 1 : 0"},{"entry":["CLEU src1, uc4, dst","round unit","Unsigned Compare"]},{"entry":["Register forms:","(i.e., 4350)","Less Than"]},{"entry":"dst.lo = dst.hi = unsigned (src1 <= src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"dst.lo = dst.hi = unsigned (src1 <= uc4) ? 1 : 0"},{"entry":["CLIP src2, dst, sr1, sr2","round unit","Min\/Max Clip"]},{"entry":["If (src2 < RCLIPMIN) dst = RCLIPMIN","(i.e., 4350)"]},{"entry":"Else if (src2 >= RCLIPMAX) dst = RCLIPMAX"},{"entry":"Else dst = src2"},{"entry":["CLIPU src2, dst, sr1, sr2","round unit","Unsigned Min\/Max"]},{"entry":["If (src2 < RCLIPMIN) dst = RCLIPMIN","(i.e., 4350)","Clip"]},{"entry":"Else if (src2 >= RCLIPMAX) dst = RCLIPMAX"},{"entry":"Else dst = src2"},{"entry":["CLT src1, src2, dst","round unit","Compare Less Than"]},{"entry":["Register forms:","(i.e., 4350)"]},{"entry":"dst.lo = dst.hi = (src1 < src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"dst.lo = dst.hi = (src1 < sc4) ? 1 : 0"},{"entry":["CLT src1, sc5, dst","round unit","Compare Less Than"]},{"entry":["Register forms:","(i.e., 4350)"]},{"entry":"dst.lo = dst.hi = (src1 < src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"dst.lo = dst.hi = (src1 < sc4) ? 1 : 0"},{"entry":["CLTU src1, src2, dst","round unit","Unsigned Compare"]},{"entry":["Register forms:","(i.e., 4350)","Less Than"]},{"entry":"dst.lo = dst.hi = unsigned (src1 < src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"dst.lo = dst.hi = unsigned (src1 < uc4) ? 1 : 0"},{"entry":["CLTU src1, uc4, dst","round unit","Unsigned Compare"]},{"entry":["Register forms:","(i.e., 4350)","Less Than"]},{"entry":"dst.lo = dst.hi = unsigned (src1 < src2) ? 1 : 0"},{"entry":"Immediate forms:"},{"entry":"dst.lo = dst.hi = unsigned (src1 < uc4) ? 1 : 0"},{"entry":["LADD lssrc, sc9, lsdst","LS unit (i.e.,","Load Address Add"]},{"entry":[{},"4318-i)"]},{"entry":"Lsdst[8:0] = lssrc[8:0] + sc9"},{"entry":"Lsdst[31:9] = 0"},{"entry":["LD *lssrc(lssrc2),sc4, ua6, dst","LS unit (i.e.,","Load"]},{"entry":["Register form (circular addressing):","4318-i)"]},{"entry":"\u2002\u2002if (sc4 > 0 & bottom_flag & sc4 > bottom_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = 2*bottom_offset-sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = bottom_offset"},{"entry":"\u2002\u2002else if (sc4 < 0 & top_flag & (\u2212sc4) > top_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u22122*top_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u2212top_offset"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002m = sc4"},{"entry":"\u2002if lssrc2[7:4]==0"},{"entry":"\u2002\u2002\u2002Addr = lssrc + (lssrc2[3:0]+m)"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m >= lssrc2[7:4])"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m \u2212 lssrc2[7:4]"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m < 0)"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m + lssrc2[7:4]"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m"},{"entry":"\u2002\u2002Temp_Dst = *Addr"},{"entry":"Register form (non-circular addressing):"},{"entry":"\u2002\u2002Temp_Dst = *(lssrc + sc6)"},{"entry":"Immediate form:"},{"entry":"\u2002\u2002Temp_Dst = *uc9"},{"entry":"Dst_hi = Temp_Dst[ua[5:3]]"},{"entry":"Dst_lo = Temp_Dst[ua[2:0]]"},{"entry":["LD *lssrc(sc6), ua6, dst","LS unit (i.e.,","Load"]},{"entry":["Register form (circular addressing):","4318-i)"]},{"entry":"\u2002\u2002if (sc4 > 0 & bottom_flag & sc4 > bottom_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = 2*bottom_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = bottom_offset"},{"entry":"\u2002\u2002else if (sc4 < 0 & top_flag & (\u2212sc4) > top_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u22122*top_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u2212top_offset"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002m = sc4"},{"entry":"\u2002if lssrc2[7:4]==0"},{"entry":"\u2002\u2002\u2002Addr = lssrc + (lssrc2[3:0]+m)"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m >= lssrc2[7:4])"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m \u2212 lssrc2[7:4]"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m < 0)"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m + lssrc2[7:4]"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m"},{"entry":"\u2002\u2002Temp_Dst = *Addr"},{"entry":"Register form (non-circular addressing):"},{"entry":"\u2002\u2002Temp_Dst = *(lssrc + sc6)"},{"entry":"Immediate form:"},{"entry":"\u2002\u2002Temp_Dst = *uc9"},{"entry":"Dst_hi = Temp_Dst[ua[5:3]]"},{"entry":"Dst_lo = Temp_Dst[ua[2:0]]"},{"entry":["LD *uc9, ua6, dst","LS unit (i.e.,","Load"]},{"entry":["Register form (circular addressing):","4318-i)"]},{"entry":"\u2002\u2002if (sc4 > 0 & bottom_flag & sc4 > bottom_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = 2*bottom_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = bottom_offset"},{"entry":"\u2002\u2002else if (sc4 < 0 & top_flag & (\u2212sc4) > top_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u22122*top_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u2212top_offset"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002m = sc4"},{"entry":"\u2002if lssrc2[7:4]==0"},{"entry":"\u2002\u2002\u2002Addr = lssrc + (lssrc2[3:0]+m)"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m >= lssrc2[7:4])"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m \u2212 lssrc2[7:4]"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m < 0)"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m + lssrc2[7:4]"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m"},{"entry":"\u2002\u2002Temp_Dst = *Addr"},{"entry":"Register form (non-circular addressing):"},{"entry":"\u2002\u2002Temp_Dst = *(lssrc + sc6)"},{"entry":"Immediate form:"},{"entry":"\u2002\u2002Temp_Dst = *uc9"},{"entry":"Dst_hi = Temp_Dst[ua[5:3]]"},{"entry":"Dst_lo = Temp_Dst[ua[2:0]]"},{"entry":["LDU *lssrc(lssrc2),sc4, ua6, dst","LS unit (i.e.,","Load Unsigned"]},{"entry":["Register form (circular addressing):","4318-i)"]},{"entry":"\u2002\u2002if (sc4 > 0 & bottom_flag & sc4 > bottom_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = 2*bottom_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = bottom_offset"},{"entry":"\u2002\u2002else if (sc4 < 0 & top_flag & (\u2212sc4) > top_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u22122*top_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u2212top_offset"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002m = sc4"},{"entry":"\u2002if lssrc2[7:4]==0"},{"entry":"\u2002\u2002\u2002Addr = lssrc + (lssrc2[3:0]+m)"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m >= lssrc2[7:4])"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m \u2212 lssrc2[7:4]"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m < 0)"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m + lssrc2[7:4]"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m"},{"entry":"\u2002\u2002Temp_Dst = *Addr"},{"entry":"Register form (non-circular addressing):"},{"entry":"\u2002\u2002Temp_Dst = *(lssrc + sc6)"},{"entry":"Immediate form:"},{"entry":"\u2002\u2002Temp_Dst = *uc9"},{"entry":"Dst_hi = Temp_Dst[ua[5:3]]"},{"entry":"Dst_lo = Temp_Dst[ua[2:0]]"},{"entry":["LDU *lssrc(sc6), ua6, dst","LS unit (i.e.,","Load Unsigned"]},{"entry":["Register form (circular addressing):","4318-i)"]},{"entry":"\u2002\u2002if (sc4 > 0 & bottom_flag & sc4 > bottom_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = 2*bottom_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = bottom_offset"},{"entry":"\u2002\u2002else if (sc4 < 0 & top_flag & (\u2212sc4) > top_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u22122*top_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u2212top_offset"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002m = sc4"},{"entry":"\u2002if lssrc2[7:4]==0"},{"entry":"\u2002\u2002\u2002Addr = lssrc + (lssrc2[3:0]+m)"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m >= lssrc2[7:4])"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m \u2212 lssrc2[7:4]"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m < 0)"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m + lssrc2[7:4]"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m"},{"entry":"\u2002\u2002Temp_Dst = *Addr"},{"entry":"Register form (non-circular addressing):"},{"entry":"\u2002\u2002Temp_Dst = *(lssrc + sc6)"},{"entry":"Immediate form:"},{"entry":"\u2002\u2002Temp_Dst = *uc9"},{"entry":"Dst_hi = Temp_Dst[ua[5:3]]"},{"entry":"Dst_lo = Temp_Dst[ua[2:0]]"},{"entry":["LDU *uc9, ua6, dst","LS unit (i.e.,","Load Unsigned"]},{"entry":["Register form (circular addressing):","4318-i)"]},{"entry":"\u2002\u2002if (sc4 > 0 & bottom_flag & sc4 > bottom_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = 2*bottom_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = bottom_offset"},{"entry":"\u2002\u2002else if (sc4 < 0 & top_flag & (\u2212sc4) > top_offset)"},{"entry":"\u2002\u2002\u2002\u2002if (!mode)"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u22122*top_offset\u2212sc4"},{"entry":"\u2002\u2002\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002\u2002\u2002m = \u2212top_offset"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002\u2002m = sc4"},{"entry":"\u2002if lssrc2[7:4]==0"},{"entry":"\u2002\u2002\u2002Addr = lssrc + (lssrc2[3:0]+m)"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m >= lssrc2[7:4])"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m \u2212 lssrc2[7:4]"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + m < 0)"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m + lssrc2[7:4]"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + m"},{"entry":"\u2002\u2002Temp_Dst = *Addr"},{"entry":"Register form (non-circular addressing):"},{"entry":"\u2002\u2002Temp_Dst = *(lssrc + sc6)"},{"entry":"Immediate form:"},{"entry":"\u2002\u2002Temp_Dst = *uc9"},{"entry":"Dst_hi = Temp_Dst[ua[5:3]]"},{"entry":"Dst_lo = Temp_Dst[ua[2:0]]"},{"entry":["LDSFMEM *src1, uc4, dst, p2","LS unit (i.e.,","Load from Look Up"]},{"entry":["Dst = *[src1]uc4","4318-i)","Table"]},{"entry":["LDK *lssrc, dst","LS unit (i.e.,","Load Half-word from"]},{"entry":["Register Form:","4318-i)","LS Data Memory to"]},{"entry":["dst = 0",{},"Functional Unit"]},{"entry":["dst[31:0] = *lssrc",{},"Register"]},{"entry":"Immediate Form:"},{"entry":"dst = 0"},{"entry":"dst[31:0] = *uc9"},{"entry":["LDK *uc9, dst","LS unit (i.e.,","Load Half-word from"]},{"entry":["Register Form:","4318-i)","LS Data Memory to"]},{"entry":["dst = 0",{},"Functional Unit"]},{"entry":["dst[31:0] = *lssrc",{},"Register"]},{"entry":"Immediate Form:"},{"entry":"dst = 0"},{"entry":"dst[31:0] = *uc9"},{"entry":["LDKLH *lssrc, dst","LS unit (i.e.,","Load Half-word from"]},{"entry":["Register Form:","4318-i)","LS Data Memory to"]},{"entry":["dst[31:0] = (*lssrc << 16) | *lssrc",{},"Functional Unit"]},{"entry":["Immediate Form:",{},"Register"]},{"entry":"dst[31:0] = (*uc9 << 16) | *uc9"},{"entry":["LDKLH *uc9, dst","LS unit (i.e.,","Load Half-word from"]},{"entry":["Register Form:","4318-i)","LS Data Memory to"]},{"entry":["dst[31:0] = (*lssrc << 16) | *lssrc",{},"Functional Unit"]},{"entry":["Immediate Form:",{},"Register"]},{"entry":"dst[31:0] = (*uc9 << 16) | *uc9"},{"entry":["LDKHW .LS1 *lssrc, dst","LS unit (i.e.,","Load Half-word from"]},{"entry":["Register Form:","4318-i)","LS Data Memory to"]},{"entry":["tmp_dst[31:0] = *lssrc[9:1]",{},"Functional Unit"]},{"entry":["dst[15:0] = lssrc[0] ? tmp_dst[31:16] : tmp_dst[15:0]",{},"Register"]},{"entry":"dst[31:16] = {16{dst[15]}}"},{"entry":"Immediate Form:"},{"entry":"dst[31:0] = (*uc10[9:1] << 16) | *uc9"},{"entry":["LDKHW .LS1 *uc10, dst","LS unit (i.e.,","Load Half-word from"]},{"entry":["Register Form:","4318-i)","LS Data Memory to"]},{"entry":["tmp_dst[31:0] = *lssrc[9:1]",{},"Functional Unit"]},{"entry":["dst[15:0] = lssrc[0] ? tmp_dst[31:16] : tmp_dst[15:0]",{},"Register"]},{"entry":"dst[31:16] = {16{dst[15]}}"},{"entry":"Immediate Form:"},{"entry":"tmp_dst[31:0] = *uc10[9:1]"},{"entry":"dst[15:0] \u2003= \u2003uc10[0] \u2003? \u2003tmp_dst[31:16] \u2003\u2003:"},{"entry":"tmp_dst[15:0]"},{"entry":"dst[31:16] = {16{dst[15]}}"},{"entry":["LDKHWU .LS1 *lssrc, dst","LS unit (i.e.,","Load Half-word from"]},{"entry":["Register Form:","4318-i)","LS Data Memory to"]},{"entry":["tmp_dst[31:0] = *lssrc[9:1]",{},"Functional Unit"]},{"entry":["dst[15:0] = lssrc[0] ? tmp_dst[31:16] : tmp_dst[15:0]",{},"Register"]},{"entry":"dst[31:16] = {16{1\u2032b0}}"},{"entry":"Immediate Form:"},{"entry":"tmp_dst[31:0] = *uc10[9:1]"},{"entry":"dst[15:0] \u2003= \u2003uc10[0] \u2003? \u2003tmp_dst[31:16] \u2003\u2003:"},{"entry":"tmp_dst[15:0]"},{"entry":"dst[31:16] = {16{1\u2032b0}}"},{"entry":["LDKHWU .LS1 *uc10, dst","LS unit (i.e.,","Load Half-word from"]},{"entry":["Register Form:","4318-i)","LS Data Memory to"]},{"entry":["tmp_dst[31:0] = *lssrc[9:1]",{},"Functional Unit"]},{"entry":["dst[15:0] = lssrc[0] ? tmp_dst[31:16] : tmp_dst[15:0]",{},"Register"]},{"entry":"dst[31:16] = {16{1\u2032b0}}"},{"entry":"Immediate Form:"},{"entry":"tmp_dst[31:0] = *uc10[9:1]"},{"entry":"dst[15:0] \u2003= \u2003uc10[0] \u2003? \u2003tmp_dst[31:16] \u2003\u2003:"},{"entry":"tmp_dst[15:0]"},{"entry":"dst[31:16] = {16{1\u2032b0}}"},{"entry":["LMVK uc9, lsdst","LS unit (i.e.,","Load Immediate Value"]},{"entry":["Lsdst[8:0] = uc9","4318-i)","to Load\/Store Register"]},{"entry":"Lsdst[31:9] = 0"},{"entry":["LMVKU .LS1-.LS6 uc16, lsdst","LS unit (i.e.,","Load Immediate Value"]},{"entry":["Lsdst[15:0] = uc16","4318-i)","to Load\/Store Register"]},{"entry":"Lsdst[31:16] = 0"},{"entry":["LNOP","LS unit (i.e.,","Load-Store Unit NOP"]},{"entry":["N\/A","4318-i)"]},{"entry":["MVU uc5, dst","multiply unit","Move Unsigned"]},{"entry":["Dst = uc5","(i.e.,","Constant to Register"]},{"entry":[{},"4346)\/logic"]},{"entry":[{},"unit (i.e.,"]},{"entry":[{},"4346)"]},{"entry":["MVL src1, dst","multiply unit","Move Half-Word to"]},{"entry":["Dst = src1[11:0]","(i.e.,","Register"]},{"entry":[{},"4346)\/logic"]},{"entry":[{},"unit (i.e.,"]},{"entry":[{},"4346)"]},{"entry":["MVLU src1, dst","multiply unit","Move Half-Word to"]},{"entry":["Dst = src1[11:0]","(i.e.,","Register"]},{"entry":[{},"4346)\/logic"]},{"entry":[{},"unit (i.e.,"]},{"entry":[{},"4346)"]},{"entry":["NEG src2, dst","logic unit (i.e.,","2's complement"]},{"entry":["Dst = \u2212src2","4346)\/round"]},{"entry":[{},"unit (i.e.,"]},{"entry":[{},"4350)"]},{"entry":["NOP","logic unit (i.e.,","SIMD NOP"]},{"entry":["N\/A","4346)\/round"]},{"entry":[{},"unit (i.e.,"]},{"entry":[{},"4350)\/multiply"]},{"entry":[{},"unit (i.e.,"]},{"entry":[{},"4346)"]},{"entry":["NOT src2, dst","logic unit (i.e.,","Bitwise Invert"]},{"entry":["Dst = ~src2","4346)"]},{"entry":["OR src1, src2, dst","logic unit (i.e.,","Bitwise OR"]},{"entry":["Register form:","4346)"]},{"entry":"Dst = src1 | src2"},{"entry":"Immediate form:"},{"entry":"Dst = src1 | uc5;"},{"entry":["ORU src1, uc5, dst","logic unit (i.e.,","Bitwise OR"]},{"entry":["Register form:","4346)"]},{"entry":"Dst = src1 | src2"},{"entry":"Immediate form:"},{"entry":"Dst = src1 | uc5;"},{"entry":["PABS src2, dst","round unit","Packed Absolute Value"]},{"entry":["Dst.lo = |src2.lo|","(i.e., 4350)"]},{"entry":"Dst.hi = |src2.hi|"},{"entry":["PACKHH src1, src2, dst","multiply unit","Pack Register, low"]},{"entry":["Dst = (src1.hi << 12) | src2.hi","(i.e., 4346)","halves"]},{"entry":["PACKHL src1, src2, dst","multiply unit","Pack Register,"]},{"entry":["Dst = (src1.hi << 12) | src2.lo","(i.e., 4346)","low\/high halves"]},{"entry":["PACKLH src1, src2, dst","multiply unit","Pack Register,"]},{"entry":["Dst = (src1.lo << 12) | src2.hi","(i.e., 4346)","high\/low halves"]},{"entry":["PACKLL src1, src2, dst","multiply unit","Pack Register, high"]},{"entry":["Dst = (src1.lo << 12) | src2.lo","(i.e., 4346)","halves"]},{"entry":["PADD src1, src2, dst","logic unit (i.e.,","Packed Signed"]},{"entry":["Dst.lo = src1.lo + src2.lo","4346)\/round","Addition"]},{"entry":["Dst.hi = src1.hi + src2.hi","unit (i.e.,"]},{"entry":[{},"4350)"]},{"entry":["PADDU src1, uc5, dst","logic unit (i.e.,","Packed Signed"]},{"entry":["Dst.lo = src1.lo + uc5","4346)\/round","Addition"]},{"entry":["Dst.hi = src1.hi + uc5","unit (i.e.,"]},{"entry":[{},"4350)"]},{"entry":["PADDU2 src1, src2, dst","logic unit (i.e.,","Packed Signed"]},{"entry":["Dst.lo = (src1.lo + src2.lo) >> 1","4346)\/round","Addition with Divide"]},{"entry":["Dst.hi = (src1.hi + src2.hi) >> 1","unit (i.e.,","by 2"]},{"entry":[{},"4350)"]},{"entry":["PADD2 src1, src2, dst","logic unit (i.e.,","Packed Signed"]},{"entry":["Dst.lo = (src1.lo + src2.lo) >> 1","4346)\/round","Addition with Divide"]},{"entry":["Dst.hi = (src1.hi + src2.hi) >> 1","unit (i.e.,","by 2"]},{"entry":[{},"4350)"]},{"entry":["PADDS src1, src2, uc5, dst","logic unit (i.e.,","Packed Signed"]},{"entry":["Dst.lo = (src1.lo + src2.lo) << uc2","4346)\/round","Addition with Post-"]},{"entry":["Dst.hi = (src1.hi + src2.hi) << uc2","unit (i.e.,","Shift Left"]},{"entry":[{},"4350)"]},{"entry":["PCEQ src1, src2, dst","round unit","Packed Compare Equal"]},{"entry":["Register form:","(i.e., 4350)"]},{"entry":"dst.lo = (src1.lo == src2.lo) ? 1 : 0"},{"entry":"dst.hi = (src1.hi == src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = (src1.lo == sc4) ? 1 : 0"},{"entry":"dst.hi = (src1.hi == sc4) ? 1 : 0"},{"entry":["PCEQ src1, sc4, dst","round unit","Packed Compare Equal"]},{"entry":["Register form:","(i.e., 4350)"]},{"entry":"dst.lo = (src1.lo == src2.lo) ? 1 : 0"},{"entry":"dst.hi = (src1.hi == src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = (src1.lo == sc4) ? 1 : 0"},{"entry":"dst.hi = (src1.hi == sc4) ? 1 : 0"},{"entry":["PCEQU src1, uc4, dst","round unit","Unsigned Packed"]},{"entry":["dst.lo = unsigned (src1.lo == uc4) ? 1 : 0","(i.e., 4350)","Compare Equal"]},{"entry":"dst.hi = unsigned (src1.hi == uc4) ? 1 : 0"},{"entry":["PCGE src1, sc4, dst","round unit","Packed Greater Than"]},{"entry":["Register form:","(i.e., 4350)","or Equal To"]},{"entry":"dst.lo = (src1.lo >= sc4) ? 1 : 0"},{"entry":"dst.hi = (src1.hi >= sc4) ? 1 : 0"},{"entry":["PCGEU src1, uc4, dst","round unit","Unsigned Packed"]},{"entry":["Register form:","(i.e., 4350)","Greater Than or Equal"]},{"entry":["dst.lo = unsigned (src1.lo <= src2.lo) ? 1 : 0",{},"To"]},{"entry":"dst.hi = unsigned (src1.hi <= src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = unsigned (src1.lo <= uc4) ? 1 : 0"},{"entry":"dst.hi = unsigned (src1.hi <= uc4) ? 1 : 0"},{"entry":["PCGT src1, sc4, dst","round unit","Packed Greater Than"]},{"entry":["dst.lo = (src1.lo > sc4) ? 1 : 0","(i.e., 4350)"]},{"entry":"dst.hi = (src1.hi > sc4) ? 1 : 0"},{"entry":["PCGTU src1, uc4, dst","round unit","Unsigned Packed"]},{"entry":["dst.lo = unsigned (src1.lo > uc4) ? 1 : 0","(i.e., 4350)","Greater Than"]},{"entry":"dst.hi = unsigned (src1.hi > uc4) ? 1 : 0"},{"entry":["PCLE src1, src2, dst","round unit","Packed Less Than or"]},{"entry":["Register form:","(i.e., 4350)","Equal to"]},{"entry":"dst.lo = (src1.lo <= src2.lo) ? 1 : 0"},{"entry":"dst.hi = (src1.hi <= src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = (src1.lo <= sc4) ? 1 : 0"},{"entry":"dst.hi = (src1.hi <= sc4) ? 1 : 0"},{"entry":["PCLE src1, sc4, dst","round unit","Packed Less Than or"]},{"entry":["Register form:","(i.e., 4350)","Equal to"]},{"entry":"dst.lo = (src1.lo <= src2.lo) ? 1 : 0"},{"entry":"dst.hi = (src1.hi <= src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = (src1.lo <= sc4) ? 1 : 0"},{"entry":"dst.hi = (src1.hi <= sc4) ? 1 : 0"},{"entry":["PCLEU src1, src2, dst","round unit","Unsigned Packed Less"]},{"entry":["Register form:","(i.e., 4350)","Than or Equal to"]},{"entry":"dst.lo = unsigned (src1.lo <= src2.lo) ? 1 : 0"},{"entry":"dst.hi = unsigned (src1.hi <= src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = unsigned (src1.lo <= uc4) ? 1 : 0"},{"entry":"dst.hi = unsigned (src1.hi <= uc4) ? 1 : 0"},{"entry":["PCLEU src1, uc4, dst","round unit","Unsigned Packed Less"]},{"entry":["Register form:","(i.e., 4350)","Than or Equal to"]},{"entry":"dst.lo = unsigned (src1.lo <= src2.lo) ? 1 : 0"},{"entry":"dst.hi = unsigned (src1.hi <= src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = unsigned (src1.lo <= uc4) ? 1 : 0"},{"entry":"dst.hi = unsigned (src1.hi <= uc4) ? 1 : 0"},{"entry":["PCLIP src2, dst, sr1, sr2","round unit","Packed Min\/Max Clip,"]},{"entry":["If (src2.lo < RCLIPMIN.lo) dst.lo = RCLIPMIN.lo","(i.e., 4350)","Low and High Halves"]},{"entry":"Else\u2003if\u2003(src2.lo\u2003>= \u2002RCLIPMAX.lo) dst.lo\u2003="},{"entry":"RCLIPMAX.lo"},{"entry":"Else dst.lo = src2.lo"},{"entry":"If (src2.hi < RCLIPMIN.hi) dst.hi = RCLIPMIN.hi"},{"entry":"Else\u2003if\u2003(src2.hi\u2003>= \u2002RCLIPMAX.hi) dst.hi\u2003="},{"entry":"RCLIPMAX.hi"},{"entry":"Else dst.hi = src2.hi"},{"entry":["PCLIPU src2, dst, sr1, sr2","round unit","Packed Unsigned"]},{"entry":["If (src2.lo < RCLIPMIN.lo) dst.lo = RCLIPMIN.lo","(i.e., 4350)","Min\/Max Clip, Low"]},{"entry":["Else\u2003if\u2003(src2.lo\u2003>= \u2002RCLIPMAX.lo) dst.lo\u2003=",{},"and High Halves"]},{"entry":"RCLIPMAX.lo"},{"entry":"Else dst.lo = src2.lo"},{"entry":"If (src2.hi < RCLIPMIN.hi) dst.hi = RCLIPMIN.hi"},{"entry":"Else\u2003if\u2003(src2.hi\u2003>= \u2002RCLIPMAX.hi) dst.hi\u2003="},{"entry":"RCLIPMAX.hi"},{"entry":"Else dst.hi = src2.hi"},{"entry":["PCLT src1, src2, dst","round unit","Packed Less Than"]},{"entry":["Register form:","(i.e., 4350)"]},{"entry":"dst.lo = (src1.lo < src2.lo) ? 1 : 0"},{"entry":"dst.hi = (src1.hi < src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = (src1.lo < sc4) ? 1 : 0"},{"entry":"dst.hi = (src1.hi < sc4) ? 1 : 0"},{"entry":["PCLT src1, sc4, dst","round unit","Packed Less Than"]},{"entry":["Register form:","(i.e., 4350)"]},{"entry":"dst.lo = (src1.lo < src2.lo) ? 1 : 0"},{"entry":"dst.hi = (src1.hi < src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = (src1.lo < sc4) ? 1 : 0"},{"entry":"dst.hi = (src1.hi < sc4) ? 1 : 0"},{"entry":["PCLTU src1, src2, dst","round unit","Unsigned Packed Less"]},{"entry":["Register form:","(i.e., 4350)","Than"]},{"entry":"dst.lo = unsigned (src1.lo < src2.lo) ? 1 : 0"},{"entry":"dst.hi = unsigned (src1.hi < src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = unsigned (src1.lo < uc4) ? 1 : 0"},{"entry":"dst.hi = unsigned (src1.hi < uc4) ? 1 : 0"},{"entry":["PCLTU src1, uc4, dst","round unit","Unsigned Packed Less"]},{"entry":["Register form:","(i.e., 4350)","Than"]},{"entry":"dst.lo = unsigned (src1.lo < src2.lo) ? 1 : 0"},{"entry":"dst.hi = unsigned (src1.hi < src2.hi) ? 1 : 0"},{"entry":"Immediate form:"},{"entry":"dst.lo = unsigned (src1.lo < uc4) ? 1 : 0"},{"entry":"dst.hi = unsigned (src1.hi < uc4) ? 1 : 0"},{"entry":["PCMV src1, src2, src3, dst","multiply unit","Packed Conditional"]},{"entry":["Register form:","(i.e.,","Move"]},{"entry":["Dst.lo = src3.lo ? src1.lo : src2.lo","4346)\/logic"]},{"entry":["Dst.hi = src3.hi ? src1.hi : src2.hi","unit (i.e.,"]},{"entry":["Immediate form:","4346)"]},{"entry":"Dst.lo = src3.lo ? src1.lo : uc5"},{"entry":"Dst.hi = src3.hi ? src1.hi : uc5"},{"entry":["PCMVU src1, uc5, src3, dst","multiply unit","Packed Conditional"]},{"entry":["Register form:","(i.e.,","Move"]},{"entry":["Dst.lo = src3.lo ? src1.lo : src2.lo","4346)\/logic"]},{"entry":["Dst.hi = src3.hi ? src1.hi : src2.hi","unit (i.e.,"]},{"entry":["Immediate form:","4346)"]},{"entry":"Dst.lo = src3.lo ? src1.lo : uc5"},{"entry":"Dst.hi = src3.hi ? src1.hi : uc5"},{"entry":["PMAX src1, src2, dst","round unit","Packed Maximum"]},{"entry":["Dst.hi = (src1.hi>=src2.hi) ? src1.hi : src2.hi","(i.e., 4350)"]},{"entry":"Dst.lo = (src1.lo>=src2.lo) ? src1.lo : src2.lo"},{"entry":["PMAX2 src1, src2, dst","round unit","Packed Maximum,"]},{"entry":["tmp.hi = (src1.hi>=src2.hi) ? src1.hi : src2.hi","(i.e., 4350)","with 2Reorder"]},{"entry":"tmp.lo = (src1.lo>=src2.lo) ? src1.lo : src2.lo"},{"entry":"dst.hi = (tmp.hi>=tmp.lo) ? tmp1.hi : tmp1.lo"},{"entry":"dst.lo = (tmp.hi>=tmp.lo) ? tmp1.lo : tmp1.hi"},{"entry":["PMAXU src1, src2, dst","round unit","Unsigned Packed"]},{"entry":["Dst.hi = (src1.hi>=src2.hi) ? src1.hi : src2.hi","(i.e., 4350)","Maximum"]},{"entry":"Dst.lo = (src1.lo>=src2.lo) ? src1.lo : src2.lo"},{"entry":["PMAX2U src1, src2, dst","round unit","Unsigned Packed"]},{"entry":["tmp.hi = (src1.hi>=src2.hi) ? src1.hi : src2.hi","(i.e., 4350)","Maximum, with 2"]},{"entry":["tmp.lo = (src1.lo>=src2.lo) ? src1.lo : src2.lo",{},"Reorder"]},{"entry":"dst.hi = (tmp.hi>=tmp.lo) ? tmp1.hi : tmp1.lo"},{"entry":"dst.lo = (tmp.hi>=tmp.lo) ? tmp1.lo : tmp1.hi"},{"entry":["PMAXMAX2 src1, src2, dst","round unit","Packed Maximum and"]},{"entry":["tmp.hi = (src1.lo>=src2.hi) ? src1.lo : src2.hi","(i.e., 4350)","2Maximum"]},{"entry":"tmp.lo = (src1.hi>=src2.lo) ? src1.hi : src2.lo"},{"entry":"dst.hi = (src1.hi>=src2.hi) ? src1.hi : src2.hi"},{"entry":"dst.lo = (src1.hi>=src2.hi) ? tmp.hi : tmp.lo"},{"entry":["PMAXMAX2U src1,src2, dst","round unit","Unsigned Packed"]},{"entry":["tmp.hi = (src1.lo>=src2.hi) ? src1.lo : src2.hi","(i.e., 4350)","Maximum and 2"]},{"entry":["tmp.lo = (src1.hi>=src2.lo) ? src1.hi : src2.lo",{},"Maximum"]},{"entry":"dst.hi = (src1.hi>=src2.hi) ? src1.hi : src2.hi"},{"entry":"dst.lo = (src1.hi>=src2.hi) ? tmp.hi : tmp.lo"},{"entry":["PMIN src1, src2, dst","round unit","Packed Minimum"]},{"entry":["Dst.hi = (src1.hi<src2.hi) ? src1.hi : src2.hi","(i.e., 4350)"]},{"entry":"Dst.lo = (src1.lo<src2.lo) ? src1.lo : src2.lo"},{"entry":["PMIN2 src1, src2, dst","round unit","Packed Minimum, with"]},{"entry":["tmp.hi = (src1.hi<src2.hi) ? src1.hi : src2.hi","(i.e., 4350)","2Reorder"]},{"entry":"tmp.lo = (src1.lo<src2.lo) ? src1.lo : src2.lo"},{"entry":"dst.hi = (tmp.hi<tmp.lo) ? tmp1.hi : tmp1.lo"},{"entry":"dst.lo = (tmp.hi<tmp.lo) ? tmp1.lo : tmp1.hi"},{"entry":["PMINU src1, src2, dst","round unit","Unsigned Packed"]},{"entry":["Dst.hi = (src1.hi<src2.hi) ? src1.hi : src2.hi","(i.e., 4350)","Minimum"]},{"entry":"Dst.lo = (src1.lo<src2.lo) ? src1.lo : src2.lo"},{"entry":["PMIN2U src1, src2, dst","round unit","Unsigned Packed"]},{"entry":["tmp.hi = (src1.hi<src2.hi) ? src1.hi : src2.hi","(i.e., 4350)","Minimum, with 2"]},{"entry":["tmp.lo = (src1.lo<src2.lo) ? src1.lo : src2.lo",{},"Reorder"]},{"entry":"dst.hi = (tmp.hi<tmp.lo) ? tmp1.hi : tmp1.lo"},{"entry":"dst.lo = (tmp.hi<tmp.lo) ? tmp1.lo : tmp1.hi"},{"entry":["PMINMIN2 src1, src2, dst","round unit","Packed Minimum"]},{"entry":["tmp.hi = (src1.lo<src2.hi) ? src1.lo : src2.hi","(i.e., 4350)","and 2Minimum"]},{"entry":"tmp.lo = (src1.hi<src2.lo) ? src2.hi : src1.hi"},{"entry":"dst.hi = (src1.hi<src2.hi) ? src1.hi : src2.hi"},{"entry":"dst.lo = (src1.hi<src2.hi) ? tmp.hi : tmp.lo"},{"entry":["PMINMIN2U src1, src2, dst","round unit","Unsigned Packed"]},{"entry":["tmp.hi = (src1.lo<src2.hi) ? src1.lo : src2.hi","(i.e., 4350)","Minimum and 2"]},{"entry":["tmp.lo = (src1.hi<src2.lo) ? src2.hi : src1.hi",{},"Minimum"]},{"entry":"dst.hi = (src1.hi<src2.hi) ? src1.hi : src2.hi"},{"entry":"dst.lo = (src1.hi<src2.hi) ? tmp.hi : tmp.lo"},{"entry":["PMPYHH src1, src2, dst","multiply unit","Packed Multiply, high"]},{"entry":["Dst = src1.hi * src2.hi","(i.e., 4346)","halves"]},{"entry":["PMPYHHU src1, src2, dst","multiply unit","Unsigned Packed"]},{"entry":["Dst = src1.hi * src2.hi","(i.e., 4346)","Multiply, high halves"]},{"entry":["PMPYHHXU src1, src2, dst","multiply unit","Mixed Unsigned"]},{"entry":["Dst = src1.hi * src2.hi","(i.e., 4346)","Packed Multiply, high"]},{"entry":[{},{},"halves"]},{"entry":["PMPYHL src1, src2, dst","multiply unit","Packed Multiply,"]},{"entry":["Register forms:","(i.e., 4346)","high\/low halves"]},{"entry":"Dst = src1.hi * src2.lo"},{"entry":"Immediate forms:"},{"entry":"Dst = src1.hi * uc5"},{"entry":["PMPYHL src1, uc4, dst","multiply unit","Packed Multiply,"]},{"entry":["Register forms:","(i.e., 4346)","high\/low halves"]},{"entry":"Dst = src1.hi * src2.lo"},{"entry":"Immediate forms:"},{"entry":"Dst = src1.hi * uc5"},{"entry":["PMPYHLU src1, src2, dst","multiply unit","Unsigned Packed"]},{"entry":["Register forms:","(i.e., 4346)","Multiply, high\/low"]},{"entry":["Dst = src1.hi * src2.lo",{},"halves"]},{"entry":"Immediate forms:"},{"entry":"Dst = src1.hi * uc5"},{"entry":["PMPYHLXU src1, src2, dst","multiply unit","Mixed Unsigned"]},{"entry":["Register forms:","(i.e., 4346)","Packed Multiply,"]},{"entry":["Dst = src1.hi * src2.lo",{},"high\/low halves"]},{"entry":"Immediate forms:"},{"entry":"Dst = src1.hi * uc5"},{"entry":["PMPYLHXU src1, src2, dst","multiply unit","Mixed Unsigned"]},{"entry":["Register forms:","(i.e., 4346)","Packed Multiply,"]},{"entry":["Dst = src1.hi * src2.lo",{},"low\/high halves"]},{"entry":"Immediate forms:"},{"entry":"Dst = src1.hi * uc5"},{"entry":["PMPYLL src1, src2, dst","multiply unit","Packed Multiply, low"]},{"entry":["Register forms:","(i.e., 4346)","halves"]},{"entry":"Dst = src1.lo * src2.lo"},{"entry":"Immediate forms:"},{"entry":"Dst = src1.lo * uc5"},{"entry":["PMPYLL src1, uc4, dst","multiply unit","Packed Multiply, low"]},{"entry":["Register forms:","(i.e., 4346)","halves"]},{"entry":"Dst = src1.lo * src2.lo"},{"entry":"Immediate forms:"},{"entry":"Dst = src1.lo * uc5"},{"entry":["PMPYLLU src1, src2, dst","multiply unit","Unsigned Packed"]},{"entry":["Register forms:","(i.e., 4346)","Multiply, low halves"]},{"entry":"Dst = src1.lo * src2.lo"},{"entry":"Immediate forms:"},{"entry":"Dst = src1.lo * uc5"},{"entry":["PMPYLLXU src1, src2, dst","multiply unit","Mixed Unsigned"]},{"entry":["Register forms:","(i.e., 4346)","Packed Multiply, low"]},{"entry":["Dst = src1.lo * src2.lo",{},"halves"]},{"entry":"Immediate forms:"},{"entry":"Dst = src1.lo * uc5"},{"entry":["PNEG src2, dst","logic unit (i.e.,","Packed 2's"]},{"entry":["Dst.lo = \u2212src2.lo","4346)\/R1","complement"]},{"entry":"Dst.hi = \u2212src2.hi"},{"entry":["PRND src2, dst, sr1","logic unit i.e.,","Packed Round"]},{"entry":["If RRND.lo[3] = 1, Shift_value = 4","4346)"]},{"entry":"Else if RRND.lo[2] = 1, Shift value = 3"},{"entry":"Else if RRND.lo[1] = 1, Shift value = 2"},{"entry":"Else Shift value = 1"},{"entry":"If RRND.hi[3] = 1, Shift_value = 4"},{"entry":"Else if RRND.hi[2] = 1, Shift value = 3"},{"entry":"Else if RRND.hi[1] = 1, Shift value = 2"},{"entry":"Else Shift value = 1"},{"entry":"Dst.lo = (src2.lo + RRND.lo) >> Shift_value.lo"},{"entry":"Dst.hi = (src2.hi + RRND.hi) >> Shift_value.hi"},{"entry":["PRNDU src2, dst, sr1","logic unit (i.e.,","Unsigned Packed"]},{"entry":["If RRND.lo[3] = 1, Shift_value = 4","4346)","Round"]},{"entry":"Else if RRND.lo[2] = 1, Shift value = 3"},{"entry":"Else if RRND.lo[1] = 1, Shift value = 2"},{"entry":"Else Shift value = 1"},{"entry":"If RRND.hi[3] = 1, Shift_value = 4"},{"entry":"Else if RRND.hi[2] = 1, Shift value = 3"},{"entry":"Else if RRND.hi[1] = 1, Shift value = 2"},{"entry":"Else Shift value = 1"},{"entry":"Dst.lo = (src2.lo + RRND.lo) >> Shift_value.lo"},{"entry":"Dst.hi = (src2.hi + RRND.hi) >> Shift_value.hi"},{"entry":["PSCL src1, dst, sr1","logic unit (i.e.,","Packed Scale"]},{"entry":["If(RSCL[4])","4346)"]},{"entry":"\u2002Dst.lo = src1.lo >> RSCL[3:0])"},{"entry":"Else"},{"entry":"\u2002Dst.lo = src1.lo << RSCL[3:0])"},{"entry":"If(RSCL[9])"},{"entry":"\u2002Dst.hi = src1.hi >> RSCL[8:5])"},{"entry":"Else"},{"entry":"\u2002Dst.hi = src1.hi << RSCL[8:5])"},{"entry":["PSCLU src1, dst, sr1","logic unit (i.e.,","Unsigned Packed Scale"]},{"entry":["If(RSCL[4])","4346)"]},{"entry":"\u2002Dst.lo = src1.lo >> RSCL[3:0])"},{"entry":"Else"},{"entry":"\u2002Dst.lo = src1.lo << RSCL[3:0])"},{"entry":"If(RSCL[9])"},{"entry":"\u2002Dst.hi = src1.hi >> RSCL[8:5])"},{"entry":"Else"},{"entry":"\u2002Dst.hi = src1.hi << RSCL[8:5])"},{"entry":["PSHL src1, src2, dst","multiply unit","Packed Shift Left"]},{"entry":["Register form:","(i.e.,"]},{"entry":["Dst.lo = src1.lo << src2[3:0]","4346)\/logic"]},{"entry":["Dst.hi = src1.hi << src2[15:12]","unit (i.e.,"]},{"entry":["Immediate form:","4346)"]},{"entry":"Dst.lo = src1.lo << uc4"},{"entry":"Dst.hi = src1.hi << uc4"},{"entry":["PSHL src1, uc4, dst","multiply unit","Packed Shift Left"]},{"entry":["Register form:","(i.e.,"]},{"entry":["Dst.lo = src1.lo << src2[3:0]","4346)\/logic"]},{"entry":["Dst.hi = src1.hi << src2[15:12]","unit (i.e.,"]},{"entry":["Immediate form:","4346)"]},{"entry":"Dst.lo = src1.lo << uc4"},{"entry":"Dst.hi = src1.hi << uc4"},{"entry":["PSHRU src1, src2, dst","multiply unit","Packed Shift Right,"]},{"entry":["Register form:","(i.e.,","Logical"]},{"entry":["Dst.lo = src1.lo >> src2[3:0]","4346)\/logic"]},{"entry":["Dst.hi = src1.hi >> src2[15:12]","unit (i.e.,"]},{"entry":["Immediate form:","4346)"]},{"entry":"Dst.lo = src1.lo >> uc4"},{"entry":"Dst.hi = src1.hi >> uc4"},{"entry":["PSHRU src1, uc4, dst","multiply unit","Packed Shift Right,"]},{"entry":["Register form:","(i.e.,","Logical"]},{"entry":["Dst.lo = src1.lo >> src2[3:0]","4346)\/logic"]},{"entry":["Dst.hi = src1.hi >> src2[15:12]","unit (i.e.,"]},{"entry":["Immediate form:","4346)"]},{"entry":"Dst.lo = src1.lo >> uc4"},{"entry":"Dst.hi = src1.hi >> uc4"},{"entry":["PSHR src1, src2, dst","multiply unit","Packed Shift Right,"]},{"entry":["Register form:","(i.e.,","Arithmetic"]},{"entry":["Dst.lo = $unsigned(src1.lo) >> src2[3:0]","4346)\/logic"]},{"entry":["Dst.hi = $unsigned(src1.hi) >> src2 [15 :12]","unit (i.e.,"]},{"entry":["Immediate form:","4346)"]},{"entry":"Dst.lo = $unsigned(src1.lo) >> uc4"},{"entry":"Dst.hi = $unsigned(src1.hi) >> uc4"},{"entry":["PSHR src1, uc4, dst","multiply unit","Packed Shift Right,"]},{"entry":["Register form:","(i.e.,","Arithmetic"]},{"entry":["Dst.lo = $unsigned(src1.lo) >> src2[3:0]","4346)\/logic"]},{"entry":["Dst.hi = $unsigned(src1.hi) >> src2 [15:12]","unit (i.e.,"]},{"entry":["Immediate form:","4346)"]},{"entry":"Dst.lo = $unsigned(src1.lo) >> uc4"},{"entry":"Dst.hi = $unsigned(src1.hi) >> uc4"},{"entry":["PSIGN src1, src2, dst","round unit","Packed Change Sign"]},{"entry":["Dst.hi = (src1.hi < 0) ? \u2212src2.hi : src2.hi","(i.e., 4350)"]},{"entry":"Dst.lo = (src1.lo < 0) ? \u2212src2.lo : src2.lo"},{"entry":["PSUB src1, src2, dst","logic unit (i.e.,","Packed Subtract"]},{"entry":["Dst.hi = src1.hi \u2212 src2.hi","4346)\/round"]},{"entry":["Dst.lo = src1.lo \u2212 src2.lo","unit (i.e.,"]},{"entry":[{},"4350)"]},{"entry":["PSUBU src1, uc5, dst","logic unit (i.e.,","Packed Subtract"]},{"entry":["Dst.hi = src1.hi \u2212 uc5","4346)\/round"]},{"entry":["Dst.lo = src1.lo \u2212 uc5","unit (i.e.,"]},{"entry":[{},"4350)"]},{"entry":["PSUB2 src1, src2, dst","logic unit (i.e.,","Packed Subtract with"]},{"entry":["Dst.hi = (src1.hi \u2212 src2.hi) >> 1","4346)\/round","Divide by 2"]},{"entry":["Dst.lo = (src1.lo \u2212 src2.lo) >> 1","unit (i.e.,"]},{"entry":[{},"4350)"]},{"entry":["PSUBU2 src1, src2, dst","logic unit (i.e.,","Packed Subtract with"]},{"entry":["Dst.hi = (src1.hi \u2212 src2.hi) >> 1","4346)\/round","Divide by 2"]},{"entry":["Dst.lo = (src1.lo \u2212 src2.lo) >> 1","unit (i.e.,"]},{"entry":[{},"4350)"]},{"entry":["RND src2, dst, sr1","logic unit (i.e.,","Round"]},{"entry":["If RRND[3] = 1, Shift_value = 4","4346)"]},{"entry":"Else if RRND[2] = 1, Shift value = 3"},{"entry":"Else if RRND[1] = 1, Shift value = 2"},{"entry":"Else Shift value = 1"},{"entry":"Dst = (src2 + RRND[3:0]) >> Shift_value"},{"entry":["RNDU src2, dst, sr1","logic unit (i.e.,","Round, with Unsigned"]},{"entry":["If RRND[3] = 1, Shift_value = 4","4346)","Extension"]},{"entry":"Else if RRND[2] = 1, Shift value = 3"},{"entry":"Else if RRND[1] = 1, Shift value = 2"},{"entry":"Else Shift value = 1"},{"entry":"Dst = (src2 + RRND[3:0]) >> Shift_value"},{"entry":["SCL src1, dst, sr1","logic unit (i.e.,","Scale"]},{"entry":["shft = RSCL[4:0]","4346)"]},{"entry":"If(!RSCL[5]) dst = src1 << shft"},{"entry":"If(RSCL[5]) dst = src1 >> shft"},{"entry":["SCLU src1, dst, sr1","logic unit (i.e.,","Unsigned Scale"]},{"entry":["shft = RSCL[4:0]","4346)"]},{"entry":"If(!RSLC[5]) dst = src1 << shft"},{"entry":"If(RSCL[5]) dst = $unsigned(src1) >> shft"},{"entry":["SHL src1, src2, dst","multiply unit","Shift Left"]},{"entry":["Register form:","(i.e.,"]},{"entry":["dst = src1 << src2[4:0]","4346)\/logic"]},{"entry":["Immediate form:","unit (i.e.,"]},{"entry":["Dst = src1 << uc5","4346)"]},{"entry":["SHL src1, uc5, dst","multiply unit","Shift Left"]},{"entry":["Register form:","(i.e.,"]},{"entry":["dst = src1 << src2[4:0]","4346)\/logic"]},{"entry":["Immediate form:","unit (i.e.,"]},{"entry":["Dst = src1 << uc5","4346)"]},{"entry":["SHRU src1, src2, dst","multiply unit","Shift Right, Logical"]},{"entry":["Register forms:","(i.e.,"]},{"entry":["dst = $unsigned(src1) >> src2[4:0]","4346)\/logic"]},{"entry":["Immediate forms:","unit (i.e.,"]},{"entry":["dst = $unsigned(src1) >> uc5","4346)"]},{"entry":["SHRU src1, uc5, dst","multiply unit","Shift Right, Logical"]},{"entry":["Register forms:","(i.e.,"]},{"entry":["dst = $unsigned(src1) >> src2[4:0]","4346)\/logic"]},{"entry":["Immediate forms:","unit (i.e.,"]},{"entry":["dst = $unsigned(src1) >> uc5","4346)"]},{"entry":["SHR src1, src2, dst","multiply unit","Shift Right, Arithmetic"]},{"entry":["Register forms:","(i.e.,"]},{"entry":["dst = src1 >> src2[4:0]","4346)\/logic"]},{"entry":["Immediate forms:","unit (i.e.,"]},{"entry":["dst = src1 >> uc5","4346)"]},{"entry":["SHR src1, uc5, dst","multiply unit","Shift Right, Arithmetic"]},{"entry":["Register forms:","(i.e.,"]},{"entry":["dst = src1 >> src2[4:0]","4346)\/logic"]},{"entry":["Immediate forms:","unit (i.e.,"]},{"entry":["dst = src1 >> uc5","4346)"]},{"entry":["ST *lssrc(lssrc2),sc4, ua6, dst","LS unit (i.e.,","Store"]},{"entry":["Register form (circular addressing):","4318-i)"]},{"entry":"\u2002\u2002if lssrc2[7:4]==0"},{"entry":"\u2002\u2002\u2002Addr = lssrc + (lssrc2[3:0]+sc4)"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + sc4 >= lssrc2[7:4])"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + sc4 \u2212 lssrc2[7:4]"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + sc4 < 0)"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + sc4 + lssrc2[7:4]"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + sc4"},{"entry":"*Addr = dst"},{"entry":"Register form (non-circular addressing):"},{"entry":"*(lssrc + sc6) = dst"},{"entry":"Immediate form:"},{"entry":"*uc9 = dst"},{"entry":["ST *lssrc(sc6), ua6, dst","LS unit (i.e.,","Store"]},{"entry":["Register form (circular addressing):","4318-i)"]},{"entry":"\u2002\u2002if lssrc2[7:4]==0"},{"entry":"\u2002\u2002\u2002Addr = lssrc + (lssrc2[3:0]+sc4)"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + sc4 >= lssrc2[7:4])"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + sc4 \u2212 lssrc2[7:4]"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + sc4 < 0)"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + sc4 + lssrc2[7:4]"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + sc4"},{"entry":"*Addr = dst"},{"entry":"Register form (non-circular addressing):"},{"entry":"*(lssrc + sc6) = dst"},{"entry":"Immediate form:"},{"entry":"*uc9 = dst"},{"entry":["ST *uc9, ua6, dst","LS unit (i.e.,","Store"]},{"entry":["Register form (circular addressing):","4318-i)"]},{"entry":"\u2002\u2002if lssrc2[7:4]==0"},{"entry":"\u2002\u2002\u2002Addr = lssrc + (lssrc2[3:0]+sc4)"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + sc4 >= lssrc2[7:4])"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + sc4 \u2212 lssrc2[7:4]"},{"entry":"\u2002\u2002else if (lssrc2[3:0] + sc4 < 0)"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + sc4 + lssrc2[7:4]"},{"entry":"\u2002\u2002else"},{"entry":"\u2002\u2002\u2002Addr = lssrc + lssrc2[3:0] + sc4"},{"entry":"*Addr = dst"},{"entry":"Register form (non-circular addressing):"},{"entry":"*(lssrc + sc6) = dst"},{"entry":"Immediate form:"},{"entry":"*uc9 = dst"},{"entry":["STFMEMI *src1, uc4, p2","LS unit (i.e.,","Store to Shared"]},{"entry":["*uc4[src1]++","4318-i)","function-memory"]},{"entry":[{},{},"Increment"]},{"entry":["STFMEMW *src1, uc4, src2, p2","LS unit (i.e.,","Store to Shared"]},{"entry":["temp\u2002= \u2002*uc4[src1]++;\u2002temp1\u2002= \u2002temp\u2002+ \u2002src2;","4318-i)","function-memory"]},{"entry":["*uc4[src1]++ = temp1;",{},"Weighted"]},{"entry":["STFMEM *src1, uc4, src2, p2","LS unit (i.e.,","Store to Shared"]},{"entry":["*uc4[src1]++ = src2;","4318-i)","function-memory"]},{"entry":["STK *lssrc, dst","LS unit (i.e.,","Store Data to LS Data"]},{"entry":["Register form:","4318-i)","Memory"]},{"entry":"STK"},{"entry":"*lssrc = dst[31:0]"},{"entry":"Immediate form:"},{"entry":"STK"},{"entry":"*uc9 = dst[31:0]"},{"entry":["STK *uc9, dst","LS unit (i.e.,","Store Data to LS Data"]},{"entry":["Register form:","4318-i)","Memory"]},{"entry":"STK"},{"entry":"*lssrc = dst[31:0]"},{"entry":"Immediate form:"},{"entry":"STK"},{"entry":"*uc9 = dst[31:0]"},{"entry":["SUB src1, src2, dst","logic unit (i.e.,","Subtract"]},{"entry":["Register form:","4346)\/round"]},{"entry":["Dst = src1 \u2212 src2","unit (i.e.,"]},{"entry":["Immediate form:","4350)"]},{"entry":"Dst = src1 \u2212 uc5"},{"entry":["SUBU src1, uc5, dst","logic unit (i.e.,","Subtract"]},{"entry":["Register form:","4346)\/round"]},{"entry":["Dst = src1 \u2212 src2","unit (i.e.,"]},{"entry":["Immediate form:","4350)"]},{"entry":"Dst = src1 \u2212 uc5"},{"entry":["XOR src1, src2, dst","logic unit i.e.,","Bitwise XOR"]},{"entry":["Register form:","4346)"]},{"entry":"Dst = src1 {circumflex over (\u2009)} src2"},{"entry":"Immediate form:"},{"entry":"Dst = src1 {circumflex over (\u2009)} uc5"},{"entry":["XORU src1, uc5, dst","logic unit (i.e.,","Bitwise XOR"]},{"entry":["Register form:","4346)"]},{"entry":"Dst = src1 {circumflex over (\u2009)} src2"},{"entry":"Immediate form:"},{"entry":"Dst = src1 {circumflex over (\u2009)} uc5"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Within processing cluster , general-purpose RISC processors serve various purposes. For example, node processor  (which can be a RISC processor) can be used for program flow control. Below examples of RISC architectures are described.","7.1. Overview","Turning to , a more detailed example of RISC processor  (i.e., node processor ) can be seen. The pipeline used by processor  generally provides support for general high level language (i.e., C\/C++) execution in processing cluster . In operation, processor  employs a three stage pipeline of fetch, decode, and execute. Typically, context interface  and LS port  provide instructions to the program cache , and the instructions can be fetched from the program cache  by instruction fetch . The bus between the instruction fetch  and the program cache  can, for example, be 40 bits wide, allowing the processor  to support dual issue instructions (i.e., instructions can be 40 bits or 20 bits wide). Generally, \u201cA-side\u201d and \u201cB-side\u201d functional units (within processing unit ) execute the smaller instructions (i.e., 20-bit instructions), while the \u201cB-side\u201d functional units execute the larger instructions (i.e., 40-bit instructions). To execution the instructions provided, processing unit can use register file  as a \u201cscratch pad\u201d; this register file  can be (for example) a 16-entry, 32-bit register file that is shared between the \u201cA-side\u201d and \u201cB-side.\u201d Additionally, processor  includes a control register file  and a program counter . Processor  can also be access through boundary pins; an example of each is described in Table 7 (with \u201cz\u201d denoting active low pins).",{"@attributes":{"id":"p-0787","num":"1011"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Pin Name","Width","Dir","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Context Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cmem_wdata","609","Output","Context memory write data"]},{"entry":["cmem_wdata_valid","1","Output","Context memory read data"]},{"entry":["cmem_rdy","1","Input","Context memory ready"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Data Memory Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["dmem_enz","1","Output","Data memory select"]},{"entry":["dmem_wrz","1","Output","Data memory write enable"]},{"entry":["dmem_bez","4","Output","Data memory write byte enables"]},{"entry":["dmem_addr","16\/32","Output","Data memory address (32 bits for GLS processor"]},{"entry":[{},{},{},"5402)"]},{"entry":["dmem_wdata","32","Output","Data memory write data"]},{"entry":["dmem_addr_no_base","16\/32","Output","Data memory address, prior to context base"]},{"entry":[{},{},{},"address adjust (32 bits for GLS processor 5402)"]},{"entry":["dmem_rdy","1","Input","Data memory ready"]},{"entry":["dmem_rdata","32","Input","Data memory read data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Instruction Memory Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["imem_enz","1","Output","Instruction memory select"]},{"entry":["imem_addr","16","Output","Instruction memory address"]},{"entry":["imem_rdy","1","Input","Instruction memory ready"]},{"entry":["imem_rdata","40","Input","Instruction memory read data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Program Control Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["force_pcz","1","Input","Program counter write enable"]},{"entry":["new_pc","17","Input","Program counter write data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Context Control Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["force_ctxz","1","Input","Force context write enable which:"]},{"entry":[{},{},{},"writes the value on new_ctx to the internal"]},{"entry":[{},{},{},"machine state; and"]},{"entry":[{},{},{},"schedules a context save."]},{"entry":["write_ctxz","1","Input","Write context enable which writes the value on"]},{"entry":[{},{},{},"new_ctx to the internal machine state."]},{"entry":["save_ctxz","1","Input","Save context enable which schedules a context"]},{"entry":[{},{},{},"save."]},{"entry":["new_ctx","592","Input","Context change write data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Context Base Address"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["ctx_base","11","Input","Context change write address"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Flag and Strapping Pins"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["risc_is_idle","1","Output","Asserted in decode stage 5308 when an IDLE"]},{"entry":[{},{},{},"instruction is decoded."]},{"entry":["risc_is_end","1","Output","Asserted in decode stage 5308 when an END"]},{"entry":[{},{},{},"instruction is decoded."]},{"entry":["risc_is_output","1","Output","Decode flag asserted in decode stage 5308 on"]},{"entry":[{},{},{},"decode of an OUTPUT instruction"]},{"entry":["risc_is_voutput","1","Output","Decode flag asserted in decode stage 5308 on"]},{"entry":[{},{},{},"decode of a VOUTPUT instruction"]},{"entry":["risc_is_vinput","1","Output","Decode flag asserted in decode stage 5308 on"]},{"entry":[{},{},{},"decode of a VINPUT instruction"]},{"entry":["risc_is_mtv","1","Output","Asserted in decode stage 5308 when an MTV"]},{"entry":[{},{},{},"instruction is decoded. (move to vector or SIMD"]},{"entry":[{},{},{},"register from processor 5200, with replicate)"]},{"entry":["risc_is_mtvvr","1","Output","Asserted in decode stage 5308 when an MTVVR"]},{"entry":[{},{},{},"instruction is decoded. (move to vector or SIMD"]},{"entry":[{},{},{},"register from processor 5200)"]},{"entry":["risc_is_mfvvr","1","Output","Asserted in decode stage 5308 when an MFVVR"]},{"entry":[{},{},{},"instruction is decoded (move from vector or SIMD"]},{"entry":[{},{},{},"register to processor 5200)"]},{"entry":["risc_is_mfvrc","1","Output","Asserted in decode stage 5308 when an MFVRC"]},{"entry":[{},{},{},"instruction is decoded."]},{"entry":[{},{},{},"(move to vector or SIMD register from processor"]},{"entry":[{},{},{},"5200, with collapse)"]},{"entry":["risc_is_mtvre","1","Output","Asserted in decode stage 5308 when an MTVRE"]},{"entry":[{},{},{},"instruction is decoded. (move to vector or SIMD"]},{"entry":[{},{},{},"register from processor 5200, with expand)"]},{"entry":["risc_is_release","1","Output","Asserted in decode stage 5308 when a RELINP"]},{"entry":[{},{},{},"(Release Input) instruction is decoded."]},{"entry":["risc_is_task_sw","1","Output","Asserted in decode stage 5308 when a TASKSW"]},{"entry":[{},{},{},"(Task Switch) instruction is decoded."]},{"entry":["risc_is_taskswtoe","1","Output","Asserted in decode stage 5308 when a"]},{"entry":[{},{},{},"TASKSWTOE instruction is decoded."]},{"entry":["risc_taskswtoe_opr","2","Output","Asserted in execution stage 5310 when a"]},{"entry":[{},{},{},"TASKSWTOE instruction is decoded. This bus"]},{"entry":[{},{},{},"contains the value of the U2 immediate operand."]},{"entry":["risc_mode","2","Input","Statically strapped input pins to define reset"]},{"entry":[{},{},{},"behavior."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Value","Behavior"]},{"entry":[{},"00","Exiting reset causes processor 5200 to"]},{"entry":[{},{},"fetch instruction memory address zero"]},{"entry":[{},{},"and load this into the program counter"]},{"entry":[{},{},"5218"]},{"entry":[{},"01","Exiting reset causes processor 5200 to"]},{"entry":[{},{},"remain idle until the assertion of"]},{"entry":[{},{},"force_pcz"]},{"entry":[{},"10\/11","Reserved"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["risc_estate0","1","Input","External state bit 0. This pin is directly mapped to"]},{"entry":[{},{},{},"bit 11 of the Control Status Register (described"]},{"entry":[{},{},{},"below)"]},{"entry":["wrp_terminate","1","Input","Termination message status flag sourced by"]},{"entry":[{},{},{},"external logic (typically the wrapper)"]},{"entry":[{},{},{},"This pin readable via the CSR."]},{"entry":["wrp_dst_output_en","8","Input","Asserted by the SFM wrapper to control OUTPUT"]},{"entry":[{},{},{},"instructions based on wrapper enabled dependency"]},{"entry":[{},{},{},"checking."]},{"entry":["wrp_dst_voutput_en","8","Input","Asserted by the SFM wrapper to control"]},{"entry":[{},{},{},"VOUTPUT instructions based on wrapper enabled"]},{"entry":[{},{},{},"dependency checking."]},{"entry":["risc_out_depchk_failed","1","Output","Flag asserted in D0 on failure of dependency"]},{"entry":[{},{},{},"checking during decode of an OUTPUT"]},{"entry":[{},{},{},"instruction."]},{"entry":["risc_vout_depchk_failed","1","Output","Flag asserted in D0 on failure of dependency"]},{"entry":[{},{},{},"checking during decode of a VOUTPUT"]},{"entry":[{},{},{},"instruction."]},{"entry":["risc_inp_depchk_failed","1","Output","Flag asserted in D0 on failure of dependency"]},{"entry":[{},{},{},"checking during decode of a VINPUT instruction."]},{"entry":["risc_fill","1","Output","Asserted in execution stage 5310."]},{"entry":[{},{},{},"Typically, valid for the circular form of"]},{"entry":[{},{},{},"VOUTPUT (which is the 5 operand form of"]},{"entry":[{},{},{},"VOUTPUT)."]},{"entry":[{},{},{},"See the P-code description for OPC_VOUTPUT_40b_235"]},{"entry":[{},{},{},"for details."]},{"entry":["risc_branch_valid","1","Output","Flag asserted in E0 when processing a branch"]},{"entry":[{},{},{},"instruction."]},{"entry":[{},{},{},"At present this flag does not assert for CALL and"]},{"entry":[{},{},{},"RET. This may change based on feedback from"]},{"entry":[{},{},{},"SDO."]},{"entry":["risc_branch taken","1","Output","Flag asserted in E0 when a branch is taken."]},{"entry":[{},{},{},"At present this flag does not assert for CALL and"]},{"entry":[{},{},{},"RET. This may change based on feedback from"]},{"entry":[{},{},{},"SDO."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"OUTPUT Instruction Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["risc_output_wd","32","Output","Contents of the data register for an OUTPUT or"]},{"entry":[{},{},{},"VOUTPUT instruction. This is driven in execution"]},{"entry":[{},{},{},"stage 5310."]},{"entry":["risc_output_wa","16","Output","Contents of the address register for an OUTPUT or"]},{"entry":[{},{},{},"VOUTPUT instruction."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_output_disable","1","Output","Value of the SD (Store disable) bit of the circular"]},{"entry":[{},{},{},"addressing control register used in an OUTPUT or"]},{"entry":[{},{},{},"VOUTPUT instruction. See Section [00704] for a"]},{"entry":[{},{},{},"description of the circular addressing control"]},{"entry":[{},{},{},"register format."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_output_pa","6","Output","Value of the pixel address immediate constant of"]},{"entry":[{},{},{},"an OUTPUT instruction."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":[{},{},{},"(U6, below, is the 6 bit unsigned immediate value"]},{"entry":[{},{},{},"of an OUTPUT instruction)"]},{"entry":[{},{},{},"6\u2032b000000"]},{"entry":[{},{},{},"word store"]},{"entry":[{},{},{},"6\u2032b001100"]},{"entry":[{},{},{},"Store lower half word of U6 to lower"]},{"entry":[{},{},{},"center lane"]},{"entry":[{},{},{},"6\u2032b001110"]},{"entry":[{},{},{},"Store lower half word of U6 to upper"]},{"entry":[{},{},{},"center lane"]},{"entry":[{},{},{},"6\u2032b000011"]},{"entry":[{},{},{},"Store upper half word of U6 to upper"]},{"entry":[{},{},{},"center lane"]},{"entry":[{},{},{},"6\u2032b000111"]},{"entry":[{},{},{},"Store upper half word of U6 to lower"]},{"entry":[{},{},{},"center lane"]},{"entry":[{},{},{},"All other values are illegal and result in"]},{"entry":[{},{},{},"unspecified behavior"]},{"entry":["risc_output_vra","4","Output","The vector register address of the VOUTPUT"]},{"entry":[{},{},{},"instruction"]},{"entry":["risc_vip_size","8","Output","This is the driven by the lower 8 bits"]},{"entry":[{},{},{},"(Block_Width\/HG_SIZE) of Vertical Index"]},{"entry":[{},{},{},"Parameter register. The VIP is specified as an"]},{"entry":[{},{},{},"operand for some instructions."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"General Purpose Register to Vector\/SIMD Register Transfer Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["risc_vec_ua","5","Output","Vector (or SIMD) unit (aka \u2018lane\u2019) address for"]},{"entry":[{},{},{},"MTVVR and MFVVR instructions"]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_vec_wa","5","Output","For MTV, MTVRE and MTVVR instructions:"]},{"entry":[{},{},{},"Vector (or SIMD) register file write address."]},{"entry":[{},{},{},"For MFVVR and MFVRC instructions:"]},{"entry":[{},{},{},"Contains the address of the T20 GPR which is to"]},{"entry":[{},{},{},"receive the requested vector data."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_vec_wd","32","Output","Vector (or SIMD) register file write data."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_vec_hwz","2","Output","Vector (or SIMD) register file write half word"]},{"entry":[{},{},{},"select"]},{"entry":[{},{},{},"00 = write both"]},{"entry":[{},{},{},"10 = write lower"]},{"entry":[{},{},{},"01 = write upper"]},{"entry":[{},{},{},"11= read"]},{"entry":[{},{},{},"Gated with vec_regf_enz assertion."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_vec_ra","5","Output","Vector (or SIMD) register file read address."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["vec_risc_wrz","1","Input","Register file write enable. Driven by Vector (or"]},{"entry":[{},{},{},"SIMD) when it is returning write data as a result of"]},{"entry":[{},{},{},"a MFVVR or MFVRC instruction."]},{"entry":["vec_risc_wd","32","Output","Vector (or SIMD) register file write data."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["vec_risc_wa","4","Input","The General purpose register file 5206 address that"]},{"entry":[{},{},{},"is the destination for vector data returning as a"]},{"entry":[{},{},{},"result of a MFVVR or MFVRC instruction."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Node Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["node_regf_wr[0:5]z","1bx6","Input","Register file write port write enable"]},{"entry":["node_regf_wa[0:5]","4bx6","Input","Register file write port address. There are 6 write"]},{"entry":[{},{},{},"ports into general purpose register file 5206 for"]},{"entry":[{},{},{},"node support"]},{"entry":["node_regf_wd[0:5]","32bx6","Input","Register file write port data."]},{"entry":["node_regf_rd","512","Output","Register file read data."]},{"entry":["node_regf_rdz","1","Input","General purpose register file 5206 contents read"]},{"entry":[{},{},{},"enable."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Global LS Interface"},{"entry":"(which can be used for GLS processor 5402)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["gls_is_stsys","1","Output","Attribute interface flag. Asserted in decode stage"]},{"entry":[{},{},{},"5308 when an STSYS instruction is decoded."]},{"entry":["gls_is_ldsys","1","Output","Attribute interface flag. Asserted in decode stage"]},{"entry":[{},{},{},"5308 when an LDSYS instruction is decoded."]},{"entry":["gls_posn","3","Output","Attribute value. Asserted in decode stage 5308,"]},{"entry":[{},{},{},"represents the immediate constant value of the"]},{"entry":[{},{},{},"LDATTR, STSYS, LDSYS instructions"]},{"entry":["gls_sys_addr","32","Output","Attribute interface system address. Asserted in"]},{"entry":[{},{},{},"decode stage 5308, represents the contents of the"]},{"entry":[{},{},{},"register specified on attr_regf_addr."]},{"entry":["gls_vreg","4","Output","Attribute interface register file address. Asserted in"]},{"entry":[{},{},{},"decode stage 5308, this is the value (address) of the"]},{"entry":[{},{},{},"last operand (virtual GPR register address) in the"]},{"entry":[{},{},{},"LDATTR, STSYS, LDSYS instructions"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Interrupt Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["nmi","1","Input","Level triggered non-mask-able interrupt"]},{"entry":["int0","1","Input","Level triggered mask-able interrupt"]},{"entry":["int1","1","Input","Level triggered externally managed interrupt"]},{"entry":["iack","1","Output","Interrupt acknowledge"]},{"entry":["inum","3","Output","Acknowledged interrupt identifier"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Debug Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["dbg_rd","32","Output","Debug register read data"]},{"entry":["risc_brk_trc_match","1","Output","Asserted when the processor 5200 debug module"]},{"entry":[{},{},{},"detects either a break-point or trace-point match"]},{"entry":["risc_trc_pt_match","1","Output","Asserted when the processor 5200 debug module"]},{"entry":[{},{},{},"detects a trace-point match"]},{"entry":["risc_trc_pt_match_id","2","Output","The ID of the break\/trace point register which"]},{"entry":[{},{},{},"detected a match."]},{"entry":["dbg_req","1","Input","Debug module access request"]},{"entry":["dbg_addr","5","Input","Debug module register address"]},{"entry":["dbg_wrz","1","Input","Debug module register write enable."]},{"entry":["dbg_mode_enable","1","Input","Debug module master enable"]},{"entry":["wp_cur_cntx","4","Input","Wrapper driven current context number"]},{"entry":["wp_events","16","Input","User defined event input bus"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Clocking and Reset"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ck0","1","Input","Primary clock to the CPU core"]},{"entry":["ck1","1","Input","Primary clock to the debug module"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Turning to , an example  of the pipeline for processor  can be seen. As shown, this pipeline  has three principal stages: fetch , decode , and execute . In operation, an address is received by flip-flops -, which allows the fetch to occur in the fetch stage . The result of the fetch stage is provided to flip-flop -, so that the decode stage  can decode the instruction received during the fetch stage . The results from the decode stage can then be provided to flip-flops -, -, -, and -. Namely, decode stage  can provide a processor data memory (i.e., ) read address to flip-flop -, allowing the processor data memory stage  to load data to flip-flop - from processor data memory (i.e., ). Additionally, decode stage  can provide a general purpose register (GPR) write address to flip-flop - (through flip-flop -) and GPR read adder to GPR\/control register file stage  (through flip-flop -). The execute stage can then used date provided through flip-flops -, - and forward stage  to generate write address and write data for flip-flop - so that the write address and write data can be written to processor data memory (i.e., ) in processor data memory stage . Upon completion, the execution stage  indicates to program counter next stage  to provide the next address to flip-flop -.","There are typically two executable delay slots for instructions which modify the program counter. Instructions which exhibit branching behavior are not permitted in either delay slot of a branch. Instructions which are illegal in the delay slot of a branch may be identified by tooling using ProfAPI. If an instruction record's action field contains the keyword \u201cBR\u201d, this instruction is illegal in either of the two delay slots of a branch. Load instructions can exhibit a one cycle load use delay. This delay is generally managed by software (i.e., there is no hardware interlock to enforce the associated stall). An example is:",{"@attributes":{"id":"p-0790","num":"1014"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SUB .SB R4,R2"]},{"entry":[{},"LDW .SB *+R1,R2"]},{"entry":[{},"ADD .SB R2,R3"]},{"entry":[{},"MUL .SB R2,R4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["4328","5310","4328","5308","5310","706","4328"]},"Primary input rose mode[1:0] controls T20's behavior on exit from reset. When risc_mode is set to 2\u2032b00 and after the completion of reset processor  will perform a data memory (i.e., ) load from address 0, the reset vector. The value contained there is loaded into the PC. Causing an effective absolute branch to the address contained in the reset vector. When risc_mode is set to 2\u2032b01 the processor  remains stalled until the assertion of force_pcz. The reset vector is not loaded in this case.","Boundary pins, however, can also indicate stall conditions. Generally, there are four stall conditions signaled by entity boundary pins: instruction memory stall; data memory stall, context memory stall, and function-memory stall. De-assertion of any of these pins will stall processor  under the following conditions:","(1) Instruction memory stall (imem_rdy)\n\n","(2) Data memory stall (dmem_rdy)\n\n","(3) Context memory stall (cmem_rdy)\n\n","(4) vector-memory stall (vmem_rdy)\n\n","Turning to , the processor  can be seen in greater detail shown with the pipeline . Here, the instruction fetch  (which corresponds to the fetch stage ) is divided into an A-side and B-side, where the A-side receives the first 20-bits (i.e, [19:0]) of a \u201cfetch packet\u201d (which can be a 40-bit wide instruction word having one 40-bit instruction or two 20-bit instructions) and the B-side receives the last 20-bits (i.e., [39:20]) of a fetch packet. Typically, the instruction fetch  determines the structure and size of the instruction(s) in the fetch packet and dispatches the instruction(s) accordingly (which is discussed in section 7.3 below).","A decoder  (which is part of the decode stage  and processing unit ) decodes the instruction(s) from the instruction fetch . The decoder  generally includes a operator format circuit - and - (to generate intermediates) and a decode circuit - and - for the B-side and A-side, respectively. The output from the decoder  is then received by the decode-to-execution unit  (which is also part of the decode stage  and processing unit ). The decode-to-execution unit  generates command(s) for the execution unit  that correspond to the instruction(s) received through the fetch packet.","The A-side and B-side of the execution unit  is also subdivided. Each of the B-side and A-side of the execution unit  respectively includes a multiply unit -\/-, a Boolean unit -\/-, a add\/subtract unit -\/-, and a move unit -\/-. The B-side of the execution unit  also includes a load\/store unit  and a branches unit . The multiply unit -\/-, a Boolean unit -\/-, a add\/subtract unit -\/-, and a move unit -\/- can then, respectively, perform a multiply operation, a logical Boolean operation, add\/subtract operation, and a data movement operation on data loaded into the general purpose register file  (which also includes read addresses for each of the A-side and B-side). Move operations can also be performed in the control register file .","The load\/store unit  can load and store data to processor data memory (i.e., ). In Table 8 below, loads for bytes, halfwords, and words and stores for bytes, unsigned bytes, halfwords, unsigned halfwords, and words can be seen.",{"@attributes":{"id":"p-0801","num":"1037"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["stores for bytes, unsigned","STx .SB *+SBR[s1(R4 or U4)], s2(R4)"]},{"entry":["bytes, halfwords, unsigned","STx .SB *SBR++[s1(R4 or U4)], s2(R4)"]},{"entry":["halfwords, and words","STx .SB *+s1(R4), s2(R4)"]},{"entry":[{},"STx .SB *s1(R4)++, s2(R4)"]},{"entry":[{},"STx .SB *+s1[s2(U20)], s3(R4)"]},{"entry":[{},"STx .SB *s1(R4)++[s2(U20)], s3(R4)"]},{"entry":[{},"STx .SB *+SBR[s1(U24)], s2(R4)"]},{"entry":[{},"STx .SB *SBR++[s1(U24)], s2(R4)"]},{"entry":[{},"STx .SB *s1(U24), s2(R4)"]},{"entry":[{},"STx .SB *+SP[s1(U24)], s2(R4)"]},{"entry":["loads for bytes, halfwords,","LDy .SB *+LBR[s1(R4 or U4)], s2(R4)"]},{"entry":["and words","LDy .SB *LBR++[s1(R4 or U4)], s2(R4)"]},{"entry":[{},"LDy .SB *+s1(R4), s2(R4)"]},{"entry":[{},"LDy .SB *s1(R4)++, s2(R4)"]},{"entry":[{},"LDy .SB *+s1[s2(U20)], s3(R4)"]},{"entry":[{},"LDy .SB *s1(R4)++[s2(U20)], s3(R4)"]},{"entry":[{},"LDy .SB *+SBR[s1(U24)], s2(R4)"]},{"entry":[{},"LDy .SB *SBR++[s1(U24)], s2(R4)"]},{"entry":[{},"LDy .SB *s1(U24), s2(R4)"]},{"entry":[{},"LDy .SB *+SP[s1(U24)], s2(R4)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The branch unit  executed branch operations in instruction memory (i.e., -). The branch unit instructions are typically Bcc, CALL, DCBNZ, and RET, where RET generally has three executable delay slots and the remaining generally have two. Additionally, a load or store cannot generally be in the first delay slot during read of an RET.","Tuning now to , the add\/subtract units - and - (hereinafter ) can be seen in greater detail. As shown, the add\/subtract unit  is circuitry that performs hardwired computations on data stored within the general purpose register file  and generally comprises XOR circuits - and -, multiplexers - and -, and Han-Carlson (HC) trees - and - (hereinafter ) to form a cascaded HC arithmetic unit that supports word and half-word operations. These trees - and - (hereinafter ) are generally 16-bit that employs buffers , logic units  (in the upper half), and logic units  (in the lower half).","7.3. Instruction Fetch and Dispatch","For processor , there can be a single scalar instruction slot, therefore \u2018unaligned\u2019 has no relevance. Alternatively, aligned instructions can be provided for processor . However, the benefit of unaligned instruction support on code size is reduced by new support for branches to the middle of fetch packets containing two twenty bit instructions. The additional branch support potentially provides both improved loop performance and code size reduction. The additional support for unaligned instructions potentially marginalizes the performance gain and has minimal benefit to code size.","20-bit instructions may also be executed serially. Generally, bit  of the fetch packet functions as the P-bit or parallel bit. This bit, when set (i.e. set to \u201c1\u201d), can indicate that the two 20-bit instructions form an execute packet. Non-parallel 20 bit instructions may also be placed on either half of the fetch packet, which is reflected in the setting of the P-bit or bit  of the fetch packet. Additionally, for a 40-bit instruction, the P-bit cannot be set, so either hardware or the system programming tool  can enforce this condition.","Turning to , an example of an execution of three non-parallel instructions can be seen. The equivalent assembly source code for the example of  is:",{"@attributes":{"id":"p-0807","num":"1043"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"LDW .SB *+R5,R0"]},{"entry":[{},{},"NOP .SA"]},{"entry":[{},"||","NOP .SB"]},{"entry":[{},{},"NOP.SA"]},{"entry":[{},"||","ADD .SB R1,R0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["5206","5306","5306","5306","5308"]},"Since load (and store) instructions often calculate the effective RAM address, the RAM address is sent to the RAM in the execute stage . A full cycle is usually allowed for RAM access, creating a 1 cycle penalty (which can be seen in ). Additionally, the load instruction causes location R0 to be updated in the early part of the ADD instruction's execute phase. The add instruction's decode phase sets up the register file  read ports with the register addresses of R0 and R1 in it's decode phase. These register addresses are flopped. This makes the register contents available in the execute phase.","Additionally, the GLS processor  supports branches whose target is the high side of a fetch packet. An example is shown below:",{"@attributes":{"id":"p-0810","num":"1046"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LOOP:"]},{"entry":[{},"\u2003\u2003\u2003ADD .SA R0,R1 \u2002; Line 1A"]},{"entry":[{},"\u2003\u2003\u2003|| ADD .SB R2,R3 \u2002; Line 1B"]},{"entry":[{},"...more code..."]},{"entry":[{},"\u2003\u2003\u2003BR .SB &(LOOP+1)"]},{"entry":[{},"\u2003\u2003\u2003NOP .SA\u2002; Delay slot 1"]},{"entry":[{},"\u2003\u2003\u2003|| NOP .SB"]},{"entry":[{},"\u2003\u2003\u2003NOP .SA \u2002; Delay slot 2"]},{"entry":[{},"\u2003\u2003\u2003|| NOP .SB"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"5402"},"There is also a small set of loads which do not usually require an address computation since the load address is completely specified by an immediate operand, and these loads are specified to have a zero load use penalty. Using these loads it is not desired to insert a NOP for the load use penalty (the NOP shown is not in place to enforce a load use delay, the NOP is to simply disable the A-side for the purposes of explanation):",{"@attributes":{"id":"p-0812","num":"1048"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LDW .SB *+U24, R0"]},{"entry":[{},"NOP .SA"]},{"entry":[{},"||\u2002 ADD .SB \u2003R1, R0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["5308","5200","5402","5200","5310"]},"Turning now to , a non-parallel execution example for a Load with load use equal to zero is shown. Contention will occur if loads with zero cycle load-use penalties which use the data memory interface in decode stage  are scheduled to execute immediately after an instruction which uses the data memory interface in execution stage . This sequence will create contention:","LDW .SB *+R5, R0; 1 cycle load use, uses data memory in execution stage ","LDW .SB *+U24, R1; 0 cycle load use, uses data memory in decode stage ","Contention can occur since the second load's decode stage  cycle overlaps the first load's execution stage  cycle these instructions attempt to use the data memory interface in the same clock cycle. Replacing the first load with a store, CALL, RET, LDRF, STRF, LDSYS or STSYS will cause the same situation, and in , a data memory interface conflict can be seen.","On execution of a CALL instruction the computed return address is written to the address contained in the stack pointer. The computed return address is a fixed positive offset from the current PC. The fixed offset is usually 3 fetch packets from the PC value of the CALL instruction.","Additionally, branch instructions or instructions which exhibit branch behavior, like CALL, have two executable delay slots before the branch occurs. The RET instruction has 3 executable delay slots. The delay slot count is usually measured in execution cycles. Serial instructions in the delay slots of a branch count as one delay slot per serial instruction. An example is shown below",{"@attributes":{"id":"p-0819","num":"1055"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002\u2009CALL .SB <xyz>","; F#1 Ex#1 40b call instruction"]},{"entry":[{},"\u2002\u2009ADD .SA 0x1,R0","; F#2 Ex#2 20b serial instruction"]},{"entry":[{},"\u2002\u2009SUB .SB 0x2,R1","; F#2 Ex#3 20b serial"]},{"entry":[{},"\u2002\u2009MUL .SA 0x3,R2","; F#3 Ex#4 20b parallel"]},{"entry":[{},"|| SHL .SB 0x3,R2","; F#3 Ex#4 20b parallel"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0820","num":"1056"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002\u2009CALL .SB <xyz>","; F#1 Ex#1 40b call instruction"]},{"entry":[{},"\u2002\u2009ADD .SA 0x1,R0","; F#2 Ex#2 20b"]},{"entry":[{},"|| NOP .SB","; F#2 Ex#2 20b"]},{"entry":[{},"\u2002\u2009NOP .SA","; F#3 Ex#3 20b"]},{"entry":[{},"|| SUB .SB 0x2,R1","; F#3 Ex#3 20b serial"]},{"entry":[{},"\u2002\u2009MUL .SA 0x3,R2","; F#4 Ex#4 20b parallel"]},{"entry":[{},"|| SHL .SB 0x3,R2","; F#4 Ex#4 20b parallel"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Below is another example of non-parallel instructions, this time where the branch is located on the low side of the packet.",{"@attributes":{"id":"p-0822","num":"1058"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"; Fetch packet boundary"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002\u2009B .SB R0","; F#1 Ex#1 20b serial instruction"]},{"entry":[{},"\u2002\u2009ADD .SA 0x1,R0","; F#1 Ex#2 20b serial instruction"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"; Fetch packet boundary"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002\u2009SUB .SA 0x2,R1","; F#2 Ex#3 20b parallel"]},{"entry":[{},"|| MUL .SB 0x3,R2","; F#2 Ex#3 20b parallel"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0823","num":"1059"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"; Fetch packet boundary"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"B .SB R0","; F#1 Ex#1 20b serial instruction"]},{"entry":[{},"ADD .SA 0x1,R0","; F#1 Ex#2 20b serial instruction"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"; Fetch packet boundary"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SUB .SA 0x2,R1","; F#2 Ex#3 20b serial"]},{"entry":[{},"MUL .SB 0x3,R2","; F#2 Not executed, 20b serial"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"As stated above, the general purpose resister file  can be a 16-entry by 32-bit general purpose register file. The widths of the general purpose registers (GPRs) can be parameterized. Generally, when processor  is used for nodes (i.e., -), there are 4+15 (15 are controlled by boundary pins) read ports and 4+6 (6 are controlled by boundary pins) write ports, while processor  used for GLS unit  has 4 read ports and 4 write ports.","7.5. Control Register File","Generally, all registers within the control register file  are conventionally 16 bits wide; however, not all bits in each register are implemented and parameterization exists to extend or reduce the width of most registers. Twelve registers can be implemented in the control register file . Address space is made available in the instruction set for processor  (in the MVC instructions) for up to 32 control registers for future extensions. Generally, when processor  is used for nodes (i.e., -), there are 2 read ports and 2 write ports, while processor  used for GLS unit  has 4 read ports and 4 write ports. In the general case, the control register file is accessed by using the MVC instruction. MVC is generally the primary mechanism for moving the contents of registers between the register file  and the control register file. MVC instructions are generally single cycle instructions which complete in the execute stage . The register access is similar to that of a register file with by-passing for read-after-write dependency. Direct modification of the control register file entries is generally limited to a few special case instructions. For example, forms of the ADD and SUB instructions can directly modify the stack pointer to improve code execution performance (i.e., other instructions modify the condition code bits, etc.). In Table 9 below, the registers that can be included in control register file  are described.",{"@attributes":{"id":"p-0826","num":"1062"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Mnemonic","Register Name","Description","Width","Address"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CSR","Control status","Contains global","12","0x00"]},{"entry":[{},"register","interrupt enable",{},{}]},{"entry":[{},{},"bit, and",{},{}]},{"entry":[{},{},"additional",{},{}]},{"entry":[{},{},"control\/status",{},{}]},{"entry":[{},{},"bits",{},{}]},{"entry":["IER","Interrupt enable","Allows manual","4","0x01"]},{"entry":[{},"register","enable\/disable of",{},{}]},{"entry":[{},{},"individual",{},{}]},{"entry":[{},{},"interrupts",{},{}]},{"entry":["IRP","Interrupt return","Interrupt return","16","0x02"]},{"entry":[{},"pointer","address.",{},{}]},{"entry":["LBR","Load base","Contains the","16","0x03"]},{"entry":[{},"register","global data",{},{}]},{"entry":[{},{},"address pointer,",{},{}]},{"entry":[{},{},"used for some",{},{}]},{"entry":[{},{},"load instructions",{},{}]},{"entry":["SBR","Store base","Contains the","16","0x04"]},{"entry":[{},"register","global data",{},{}]},{"entry":[{},{},"address pointer,",{},{}]},{"entry":[{},{},"used for some",{},{}]},{"entry":[{},{},"store instructions",{},{}]},{"entry":["SP","Stack Pointer","Contains the next","16","0x05"]},{"entry":[{},{},"available address",{},{}]},{"entry":[{},{},"in the stack",{},{}]},{"entry":[{},{},"memory region.",{},{}]},{"entry":[{},{},"This is a byte",{},{}]},{"entry":[{},{},"address."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The stack pointer generally specifies a byte address in processor data memory (i.e., ). By convention the stack pointer can contain the next available address in processor data memory (i.e., ) for temporary storage. The LDRF instruction (which is pre-incremented) and the STRF instructions (which is post-decremented) can indirectly modify this register, storing or retrieving register file contents. The CALL instruction (which is post-decremented) and RET instructions (which is pre-incremented) indirectly modify this register, storing and retrieving the program counter or PC . The stack pointer may be directly updated by software using the MVC instruction. The programmer is generally responsible for ensuring the correct alignment of the SP. Other instructions can be used to directly modify the stack pointer.","7.5.2. Control Status Register (CSR)","The control status register can contains control and status bits. Processor  generally defines (for example) two sets of status bits, one set for each issue slot (i.e., A and B). As shown in the example for in Table 7 above, instructions which execute on the A-side update and read status bits CSR [4:0]. Instructions which execute on the B-side update and read status bits CSR [9:5]. All bits can be directly readable or writeable from either side using the MVC instructions. In Table 10 below, the bits for the control status register illustrated in Table 8 above are described.",{"@attributes":{"id":"p-0829","num":"1065"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit",{},{},{}]},{"entry":["Position","Width","Field","Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["15:11","16","RSV","Reserved"]},{"entry":["11\u2002","1","ES0","External state bit 0. This reflects the"]},{"entry":[{},{},{},"unflopped value of the boundary pin"]},{"entry":[{},{},{},"estate0."]},{"entry":["10\u2002","1","GIE","Global interrupt enable"]},{"entry":["9","1","SAT (B)","B-side saturation bit, arithmetic operations"]},{"entry":[{},{},{},"whose results have been saturated set this"]},{"entry":[{},{},{},"bit. See individual instruction descriptions"]},{"entry":[{},{},{},"for instructions which modify the SAT bit."]},{"entry":["8","1","C (B)","B-side carry bit, arithmetic operations"]},{"entry":[{},{},{},"which results in carry out, or borrow set"]},{"entry":[{},{},{},"this bit. See individual instruction"]},{"entry":[{},{},{},"descriptions for instructions which"]},{"entry":[{},{},{},"modify the C bit."]},{"entry":["7","1","GT (B)","B-side greater-than bit, this bit is set or"]},{"entry":[{},{},{},"cleared based on the result of a CMP"]},{"entry":[{},{},{},"instruction. (i.e. GT = 1 if Rx > Ry else"]},{"entry":[{},{},{},"GT = 0) See individual instruction"]},{"entry":[{},{},{},"descriptions for instructions which"]},{"entry":[{},{},{},"modify the GT bit."]},{"entry":["6","1","LT (B)","B-side less-than bit, this bit is set or"]},{"entry":[{},{},{},"cleared based on the result of a CMP"]},{"entry":[{},{},{},"instruction. (i.e. LT = 1 if Rx < Ry"]},{"entry":[{},{},{},"else LT = 0) See individual instruction"]},{"entry":[{},{},{},"descriptions for instructions which modify"]},{"entry":[{},{},{},"the LT bit."]},{"entry":["5","1","EQ (B)","B-side equal(or zero) bit, this bit is set to 1"]},{"entry":[{},{},{},"if the result of instruction execution results"]},{"entry":[{},{},{},"in a zero result or the result of a CMP"]},{"entry":[{},{},{},"instruction returns equality. (i.e. EQ = 1 if"]},{"entry":[{},{},{},"Rx == Ry else EQ = 0) See individual"]},{"entry":[{},{},{},"instruction descriptions for instructions"]},{"entry":[{},{},{},"which modify the EQ bit."]},{"entry":["4","1","SAT (A)","A-side saturation bit, see above"]},{"entry":["3","1","C (A)","A-side carry bit, see above"]},{"entry":["2","1","GT (A)","A-side greater-than bit, see above"]},{"entry":["1","1","LT (A)","A-side less-than bit, see above"]},{"entry":["0","1","EQ (A)","A-side equal(or zero) bit, see above"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"This register is generally responds to register moves but has no effect on interrupts. The interrupt enable register (which can be about 16 bits) generally combines the functions of an interrupt status register, interrupt set register, interrupt clear register and interrupt mask register into a single register. The interrupt enable register's \u201cE\u201d bits can control individual enable and disable (masking) of interrupts. A one written to an interrupt enable bit (i.e., execution stage  at [0] for int0 and E at [2] for int1) enables that interrupt. The interrupt enable register's \u201cC\u201d bits can provide status and control for the associated interrupts (i.e., C at [1] for int0 and C1 at [3] for int1). When an interrupt has been accepted the associated C bit is set and the remaining C bits are cleared. On execution of a RETI instruction all C bit values are cleared. The C bits can also be used to mimic the initiation of an interrupt. A 1 written to a C bit that is currently cleared initiates interrupt processing as if the associated interrupt pin had been asserted. All other processing steps and restrictions can the same as a pin asserted interrupt (GIE should be set, associated E bit should be set, etc). It should also be noted that if software wishes to use bit C1 (associated with int1) for this purpose external hardware should generally ensure that a valid value is driven onto new_pc and the force_pcz signal is held high, before writing to bit C1.","7.5.4. Interrupt Return Pointer (IRP)","This register (which can also be 16 bits) generally responds to register moves but has no effect on interrupts. The interrupt return pointer can contains the address of the first instruction in the program flow that was not executed due to occurrence of an interrupt. The value contained in the interrupt return pointer can be copied directly to the PC  upon execution of a BIRP instruction.","7.5.5. Load Base Register (LBR)","The load base register (which can also be 16 bits) can contain a base address used in some load instruction types. This register generally contains a 16 bit base address which when combined with general purpose register contents or immediate values, provides a flexible method to access global data.","7.5.6. Store Base Register (SBR)","The store base register can contain a base address used in some store instruction types. This register generally contains a 16 bit base address which when combined with general purpose register contents or immediate values, provides a flexible method to access global data.","7.6. Program Counter","The program counter or PC  is generally an architectural register (i.e., having contains machine state or execution unit , but is not directly accessible through the instruction set). Instruction execution has an effect on the PC , but the current PC value can not be read or written explicitly. The PC  is (for example) 16 bits wide, representing the instruction word address of the current instruction. Internally, the PC  can contain an extra LSB, the half word instruction address bit. This bit indicates (for example) the high or low half of an instruction word for 20-bit serially executed instructions (i.e. p-bit=0). This extra LSB is generally not visible nor is can it be manipulates the state of this bit through program or external pin control. For example, a force_pcz event implicitly clears the half word instruction address bit.","7.7. Circular Addressing","Processor  generally includes instructions which use a circular addressing mode to access buffers in memory. These instructions can be the six forms of OUTPUT and the CIRC instruction, which can, for example, include:","(1) (V)OUTPUT .SB R4, R4, S8, U6, R4","(2) (V)OUTPUT .SB R4, S14, U6, R4","(3) (V)OUTPUT .SB U18, U6, R4","(4) CIRC .SB R4, S8, R4","These instructions are generally 40 bits wide, and the VOUTPUT instructions are generally the vector\/SIMD equivalent of the scalar OUTPUT instructions. Circular addressing instructions generally use a buffer control register to determine the results of a circular address calculation, and an example of the register format can be seen in Table 11 below.",{"@attributes":{"id":"p-0841","num":"1077"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit",{},{},{}]},{"entry":["Position","Width","Field","Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["31:24","8","SIZE OF",{}]},{"entry":[{},{},"BUFFER",{}]},{"entry":["23:16","8","POINTER",{}]},{"entry":["15","1","TF","Top Flag"]},{"entry":[{},{},{},"0 = no boundary"]},{"entry":[{},{},{},"1 = boundary"]},{"entry":["14","1","BF","Bottom Flag"]},{"entry":[{},{},{},"0 = no boundary"]},{"entry":[{},{},{},"1 = boundary"]},{"entry":["13","1","Md","Mode"]},{"entry":[{},{},{},"0 = mirror boundary"]},{"entry":[{},{},{},"1 = repeat boundary"]},{"entry":["12","1","SD","Store disable"]},{"entry":[{},{},{},"0 = normal"]},{"entry":[{},{},{},"1 = disable write"]},{"entry":[{},{},{},"(Not used in RISC_SFM, used by"]},{"entry":[{},{},{},"RISC_TMC control logic and"]},{"entry":[{},{},{},"appears as an output pin in that"]},{"entry":[{},{},{},"variant of T20.)"]},{"entry":["11","1","RSV","Reserved"]},{"entry":["10:8\u2002","3","BLOCK SIZE",{}]},{"entry":["7:4","4","TOP OFFSET",{}]},{"entry":["3:0","4","BOTTOM",{}]},{"entry":[{},{},"OFFSET"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The boundary pins new_ctx_data and cmem_wdata can be used to move machine state to and from the processor  core. This movement is initiated by the assertion of force_ctxz. External logic can initiate a context switch by driving force_ctxz low and simultaneously driving new_ctx_data with the new machine state. Processor  detects force_ctxz on the rising edge of the clock. Assertion of force_ctxz can cause processor  to begin saving its current state and load the data driven on new_ctx_data into the internal processor  registers. Subsequently processor  can assert the signal cmem_wdata_valid and drive the previous state onto the cmem_wdata bus. While the context switch can occur immediately, there can be a two cycle delay between detection of force_ctxz assertion, and the assertion by processor  of cmem_wdata_valid and cmem_wdata. These two cycles generally allow instructions in the decode stage  and execute stage  at the assertion of force_ctxz, to properly update the machine state before this machine state is written to the context memories. Processor  can continue to assert cmem_wdata_valid and cmem_wdata until the assertion of cmem_rdy. Typically, cmem_rdy is asserted, but this allows external control logic to determine how long processor  should keep cmem_wdata_valid and cmem_wdata valid. The format of the new_ctx_data and cmem_wdata buses is shown in Table 12 below.",{"@attributes":{"id":"p-0843","num":"1079"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Bit",{},"Register",{}]},{"entry":["Position","Width","Name","Comment"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["608:592","17","PC","These bits are generally used in"]},{"entry":[{},{},{},"cmem_wdata. New context data separately"]},{"entry":[{},{},{},"drives the new PC contents onto the"]},{"entry":[{},{},{},"new_pc bus."]},{"entry":["591:576","16","SP","Control Register File 5216"]},{"entry":["575:560","16","SBR",{}]},{"entry":["559:544","16","LBR",{}]},{"entry":["543:528","16","IRP",{}]},{"entry":["527:524","4","IER",{}]},{"entry":["523:512","12","CSR",{}]},{"entry":["511:480","32","R15","General Purpose Register (i.e., within"]},{"entry":["479:448","32","R14","register file 5206)"]},{"entry":["447:416","32","R13",{}]},{"entry":["415:384","32","R12",{}]},{"entry":["383:352","32","R11",{}]},{"entry":["351:320","32","R10",{}]},{"entry":["319:288","32","R9",{}]},{"entry":["287:256","32","R8",{}]},{"entry":["255:224","32","R7",{}]},{"entry":["223:192","32","R6",{}]},{"entry":["191:160","32","R5",{}]},{"entry":["159:128","32","R4",{}]},{"entry":["127:96\u2002","32","R3",{}]},{"entry":["95:64","32","R2",{}]},{"entry":["63:32","32","R1",{}]},{"entry":["31:0\u2002","32","R0"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Nodes (i.e., -) can require access to the general purpose registers of processor  as part of the SIMD instruction set. A pin is provided which will cause processor  to drive the general purpose register contents onto cmem_wdata, which is normally held at a constant value to reduce switching power consumption and is active during write back of the machine state of processor  as a side effect of a context switch (force_ctxz assertion). The input pin cmem_gpr_renz is generally provided to allow external logic to read the current value of the register file . This input pin is used combinatorially by processor  to drive the register file  onto bits cmem_wdata[511:0].","7.9. Interrupts","Processor  can support four externally signaled interrupts: reset (rst0z), a non-maskable interrupt (nmi), a maskable interrupt (int0) and an externally managed maskable interrupt (int1). int1 is typically the output of an external interrupt controller. In addition to reset, other events can be treated as interrupts by the hardware, namely and for example, Execution of a SWI (software interrupt) instruction and detection by the hardware of an undefined instruction. Table 13 below illustrates a summary of example interrupts for processor , and the logical timings for these interrupts can be seen in .",{"@attributes":{"id":"p-0846","num":"1082"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":[{},{},"Instruction Word",{},{},{}]},{"entry":["Interrupt","Input Pin","Address","Comment","Priority","inum[2:0]"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Reset","rst0z","0x0000","generally enabled","1","0x0"]},{"entry":["NMI","nmi","0x0001","Enabled if GIE is","2","0x1"]},{"entry":[{},{},{},"set",{},{}]},{"entry":["SWI","No pin,","0x0002","generally enabled","3","0x2"]},{"entry":[{},"decode of SWI",{},{},{},{}]},{"entry":[{},"instruction",{},{},{},{}]},{"entry":["UNDEF","No pin,","0x0003","generally enabled","4","0x3"]},{"entry":[{},"detection of",{},{},{},{}]},{"entry":[{},"undefined",{},{},{},{}]},{"entry":[{},"instruction",{},{},{},{}]},{"entry":["INT0","int0","0x0004","Enabled if GIE is","5","0x4"]},{"entry":[{},{},{},"set",{},{}]},{"entry":["INT1","int1","0x0005","Enabled if GIE is","6","0x5"]},{"entry":[{},{},"(reserved but not","set",{},{}]},{"entry":[{},{},"used by INT1)","Externally",{},{}]},{"entry":[{},{},{},"managed interrupt,",{},{}]},{"entry":[{},{},{},"ISR entry point is",{},{}]},{"entry":[{},{},{},"specified through",{},{}]},{"entry":[{},{},{},"the Program",{},{}]},{"entry":[{},{},{},"control interface.",{},{}]},{"entry":["RSV1","No pin,","0x0006","generally disabled","N\/A","0x6"]},{"entry":[{},"reserved",{},{},{},{}]},{"entry":["RSV2","No pin,","0x0007","generally disabled","N\/A","0x7"]},{"entry":[{},"reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The debug module for the processor  (which is a part of the processing unit ) utilizes the wrapper interface (i.e., node wrapper -) to simplify the design of the debug module. The boundary pins for debug support are listed in above in Table 7. The debug register set is summarized below in Table 14.",{"@attributes":{"id":"p-0848","num":"1084"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":[{},{},{},{},{},"Bit"]},{"entry":["Register Name","Description","Field","Function","Width","Position"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DBG_CNTRL","Global debug",{},{},"\u20021","\u20021"]},{"entry":[{},"mode control",{},{},{},{}]},{"entry":[{},"Address: 0x00",{},{},{},{}]},{"entry":["RSRV0","Not","N\/A","N\/A","N\/A","N\/A"]},{"entry":[{},"implemented,",{},{},{},{}]},{"entry":[{},"reads",{},{},{},{}]},{"entry":[{},"0x00000000",{},{},{},{}]},{"entry":[{},"Address: 0x01",{},{},{},{}]},{"entry":["BRK0","Break\/trace","RSRV","Reserved, not implemented,","\u20023","31:29"]},{"entry":[{},"point register 0",{},"reads 0x0",{},{}]},{"entry":[{},"Address: 0x02","EN","Enable, =1 enables","\u20021","28"]},{"entry":[{},{},{},"break\/trace point",{},{}]},{"entry":[{},{},{},"comparisons",{},{}]},{"entry":[{},{},"TM","Trace mode, =1 trace mode, =0","\u20021","27"]},{"entry":[{},{},{},"breakpoint mode",{},{}]},{"entry":[{},{},"ID","Trace\/breakpoint ID, this is","\u20022","26:25"]},{"entry":[{},{},{},"asserted on",{},{}]},{"entry":[{},{},{},"risc_trc_pt_match_id",{},{}]},{"entry":[{},{},"CNTX","When context comparison","\u20024","24:21"]},{"entry":[{},{},{},"is enabled (CC = 1, below)",{},{}]},{"entry":[{},{},{},"this field is compared to the",{},{}]},{"entry":[{},{},{},"input pins wp_cur_cntx, to",{},{}]},{"entry":[{},{},{},"further qualify the match.",{},{}]},{"entry":[{},{},{},"When CC = 1 both the",{},{}]},{"entry":[{},{},{},"instruction memory address",{},{}]},{"entry":[{},{},{},"and the wp_cur_cntx value",{},{}]},{"entry":[{},{},{},"are compared to determine a",{},{}]},{"entry":[{},{},{},"match. When CC = 0",{},{}]},{"entry":[{},{},{},"wp_cur_cntx is ignored",{},{}]},{"entry":[{},{},{},"when determining a match.",{},{}]},{"entry":[{},{},"CC","Context compare enable, =1","\u20021","20"]},{"entry":[{},{},{},"enabled",{},{}]},{"entry":[{},{},"RSRV","Reserved, not implemented,","\u20024","19:16"]},{"entry":[{},{},{},"reads 0x0",{},{}]},{"entry":[{},{},"IA","Instruction memory address","16","15:0\u2002"]},{"entry":[{},{},{},"for the trace\/breakpoint.",{},{}]},{"entry":[{},{},{},"This is compared to",{},{}]},{"entry":[{},{},{},"imem_addr to determine a",{},{}]},{"entry":[{},{},{},"potential match",{},{}]},{"entry":["BRK1","Break\/trace","RSRV","Reserved, not implemented,","\u20023","31:29"]},{"entry":[{},"point register 1",{},"reads 0x0",{},{}]},{"entry":[{},"Address: 0x03","EN","Enable, =1 enables","\u20021","28"]},{"entry":[{},{},{},"break\/trace point",{},{}]},{"entry":[{},{},{},"comparisons",{},{}]},{"entry":[{},{},"TM","Trace mode, =1 trace mode, =0","\u20021","27"]},{"entry":[{},{},{},"breakpoint mode",{},{}]},{"entry":[{},{},"ID","Trace\/breakpoint ID, this is","\u20022","26:25"]},{"entry":[{},{},{},"asserted on",{},{}]},{"entry":[{},{},{},"risc_trc_pt_match_id",{},{}]},{"entry":[{},{},"CNTX","When context comparison","\u20024","24:21"]},{"entry":[{},{},{},"is enabled (CC = 1, below)",{},{}]},{"entry":[{},{},{},"this field is compared to the",{},{}]},{"entry":[{},{},{},"input pins wp_cur_cntx, to",{},{}]},{"entry":[{},{},{},"further qualify the match.",{},{}]},{"entry":[{},{},{},"When CC = 1 both the",{},{}]},{"entry":[{},{},{},"instruction memory address",{},{}]},{"entry":[{},{},{},"and the wp_cur_cntx value",{},{}]},{"entry":[{},{},{},"are compared to determine a",{},{}]},{"entry":[{},{},{},"match. When CC = 0",{},{}]},{"entry":[{},{},{},"wp_cur_cntx is ignored",{},{}]},{"entry":[{},{},{},"when determining a match.",{},{}]},{"entry":[{},{},"CC","Context compare enable, =1","\u20021","20"]},{"entry":[{},{},{},"enabled",{},{}]},{"entry":[{},{},"RSRV","Reserved, not implemented,","\u20024","19:16"]},{"entry":[{},{},{},"reads 0x0",{},{}]},{"entry":[{},{},"IA","Instruction memory address","16","15:0\u2002"]},{"entry":[{},{},{},"for the trace\/breakpoint.",{},{}]},{"entry":[{},{},{},"This is compared to",{},{}]},{"entry":[{},{},{},"imem_addr to determine a",{},{}]},{"entry":[{},{},{},"potential match",{},{}]},{"entry":["BRK2","Break\/trace","RSRV","Reserved, not implemented,","\u20023","31:29"]},{"entry":[{},"point register 2",{},"reads 0x0",{},{}]},{"entry":[{},"Address: 0x04","EN","Enable, =1 enables","\u20021","28"]},{"entry":[{},{},{},"break\/trace point",{},{}]},{"entry":[{},{},{},"comparisons",{},{}]},{"entry":[{},{},"TM","Trace mode, =1 trace mode, =0","\u20021","27"]},{"entry":[{},{},{},"breakpoint mode",{},{}]},{"entry":[{},{},"ID","Trace\/breakpoint ID, this is","\u20022","26:25"]},{"entry":[{},{},{},"asserted on",{},{}]},{"entry":[{},{},{},"risc_trc_pt_match_id",{},{}]},{"entry":[{},{},"CNTX","When context comparison","\u20024","24:21"]},{"entry":[{},{},{},"is enabled (CC = 1, below)",{},{}]},{"entry":[{},{},{},"this field is compared to the",{},{}]},{"entry":[{},{},{},"input pins wp_cur_cntx, to",{},{}]},{"entry":[{},{},{},"further qualify the match.",{},{}]},{"entry":[{},{},{},"When CC = 1 both the",{},{}]},{"entry":[{},{},{},"instruction memory address",{},{}]},{"entry":[{},{},{},"and the wp_cur_cntx value",{},{}]},{"entry":[{},{},{},"are compared to determine a",{},{}]},{"entry":[{},{},{},"match. When CC = 0",{},{}]},{"entry":[{},{},{},"wp_cur_cntx is ignored",{},{}]},{"entry":[{},{},{},"when determining a match.",{},{}]},{"entry":[{},{},"CC","Context compare enable, =1","\u20021","20"]},{"entry":[{},{},{},"enabled",{},{}]},{"entry":[{},{},"RSRV","Reserved, not implemented,","\u20024","19:16"]},{"entry":[{},{},{},"reads 0x0",{},{}]},{"entry":[{},{},"IA","Instruction memory address","16","15:0\u2002"]},{"entry":[{},{},{},"for the trace\/breakpoint.",{},{}]},{"entry":[{},{},{},"This is compared to",{},{}]},{"entry":[{},{},{},"imem_addr to determine a",{},{}]},{"entry":[{},{},{},"potential match",{},{}]},{"entry":["BRK3","Break\/trace","RSRV","Reserved, not implemented,","\u20023","31:29"]},{"entry":[{},"point register 3",{},"reads 0x0",{},{}]},{"entry":[{},"Address: 0x05","EN","Enable, =1 enables","\u20021","28"]},{"entry":[{},{},{},"break\/trace point",{},{}]},{"entry":[{},{},{},"comparisons",{},{}]},{"entry":[{},{},"TM","Trace mode, =1 trace mode, =0","\u20021","27"]},{"entry":[{},{},{},"breakpoint mode",{},{}]},{"entry":[{},{},"ID","Trace\/breakpoint ID, this is","\u20022","26:25"]},{"entry":[{},{},{},"asserted on",{},{}]},{"entry":[{},{},{},"risc_trc_pt_match_id",{},{}]},{"entry":[{},{},"CNTX","When context comparison","\u20024","24:21"]},{"entry":[{},{},{},"is enabled (CC = 1, below)",{},{}]},{"entry":[{},{},{},"this field is compared to the",{},{}]},{"entry":[{},{},{},"input pins wp_cur_cntx, to",{},{}]},{"entry":[{},{},{},"further qualify the match.",{},{}]},{"entry":[{},{},{},"When CC = 1 both the",{},{}]},{"entry":[{},{},{},"instruction memory address",{},{}]},{"entry":[{},{},{},"and the wp_cur_cntx value",{},{}]},{"entry":[{},{},{},"are compared to determine a",{},{}]},{"entry":[{},{},{},"match. When CC = 0",{},{}]},{"entry":[{},{},{},"wp_cur_cntx is ignored",{},{}]},{"entry":[{},{},{},"when determining a match.",{},{}]},{"entry":[{},{},"CC","Context compare enable, =1","\u20021","20"]},{"entry":[{},{},{},"enabled",{},{}]},{"entry":[{},{},"RSRV","Reserved, not implemented,","\u20024","19:16"]},{"entry":[{},{},{},"reads 0x0",{},{}]},{"entry":[{},{},"IA","Instruction memory address","16","15:0\u2002"]},{"entry":[{},{},{},"for the trace\/breakpoint.",{},{}]},{"entry":[{},{},{},"This is compared to",{},{}]},{"entry":[{},{},{},"imem_addr to determine a",{},{}]},{"entry":[{},{},{},"potential match",{},{}]},{"entry":["ECC0","Event counter","EN","Event count enable","\u20021","\u20027"]},{"entry":[{},"control register 0","SEL","Event select","\u20027","6:0"]},{"entry":[{},"Address: 0x06",{},"SEL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Value","Event"]},{"entry":[{},{},{},"0x00","Instruction"]},{"entry":[{},{},{},{},"memory stall"]},{"entry":[{},{},{},"0x01","Data memory"]},{"entry":[{},{},{},{},"stall"]},{"entry":[{},{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x04","40b instruction"]},{"entry":[{},{},{},{},"valid"]},{"entry":[{},{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x06","CALL"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x07","RET instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x08","Branch"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"decoded"]},{"entry":[{},{},{},"0x09","Branch taken"]},{"entry":[{},{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},{},"side NOP"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x0b-","User events,"]},{"entry":[{},{},{},"1a","0x0b selects"]},{"entry":[{},{},{},{},"wp_events[0],"]},{"entry":[{},{},{},{},"etc"]},{"entry":[{},{},{},"0x01b-","unused"]},{"entry":[{},{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC1","Event counter","EN","Event count enable","\u20021","\u20027"]},{"entry":[{},"control register 1","SEL","Event select","\u20027","6:0"]},{"entry":[{},"Address: 0x07",{},"SEL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Value","Event"]},{"entry":[{},{},{},"0x00","Instruction"]},{"entry":[{},{},{},{},"memory stall"]},{"entry":[{},{},{},"0x01","Data memory"]},{"entry":[{},{},{},{},"stall"]},{"entry":[{},{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x04","40b instruction"]},{"entry":[{},{},{},{},"valid"]},{"entry":[{},{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x06","CALL"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x07","RET instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x08","Branch"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"decoded"]},{"entry":[{},{},{},"0x09","Branch taken"]},{"entry":[{},{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},{},"side NOP"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x0b-","User events,"]},{"entry":[{},{},{},"1a","0x0b selects"]},{"entry":[{},{},{},{},"wp_events[0],"]},{"entry":[{},{},{},{},"etc"]},{"entry":[{},{},{},"0x01b-","unused"]},{"entry":[{},{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC2","Event counter","EN","Event count enable","\u20021","\u20027"]},{"entry":[{},"control register 2","SEL","Event select","\u20027","6:0"]},{"entry":[{},"Address: 0x08",{},"SEL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Value","Event"]},{"entry":[{},{},{},"0x00","Instruction"]},{"entry":[{},{},{},{},"memory stall"]},{"entry":[{},{},{},"0x01","Data memory"]},{"entry":[{},{},{},{},"stall"]},{"entry":[{},{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x04","40b instruction"]},{"entry":[{},{},{},{},"valid"]},{"entry":[{},{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x06","CALL"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x07","RET instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x08","Branch"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"decoded"]},{"entry":[{},{},{},"0x09","Branch taken"]},{"entry":[{},{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},{},"side NOP"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x0b-","User events,"]},{"entry":[{},{},{},"1a","0x0b selects"]},{"entry":[{},{},{},{},"wp_events[0],"]},{"entry":[{},{},{},{},"etc"]},{"entry":[{},{},{},"0x01b-","unused"]},{"entry":[{},{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC3","Event counter","EN","Event count enable","\u20021","\u20027"]},{"entry":[{},"control register 3","SEL","Event select","\u20027","6:0"]},{"entry":[{},"Address: 0x09",{},"SEL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Value","Event"]},{"entry":[{},{},{},"0x00","Instruction"]},{"entry":[{},{},{},{},"memory stall"]},{"entry":[{},{},{},"0x01","Data memory"]},{"entry":[{},{},{},{},"stall"]},{"entry":[{},{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x04","40b instruction"]},{"entry":[{},{},{},{},"valid"]},{"entry":[{},{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x06","CALL"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x07","RET instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x08","Branch"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"decoded"]},{"entry":[{},{},{},"0x09","Branch taken"]},{"entry":[{},{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},{},"side NOP"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x0b-","User events,"]},{"entry":[{},{},{},"1a","0x0b selects"]},{"entry":[{},{},{},{},"wp_events[0],"]},{"entry":[{},{},{},{},"etc"]},{"entry":[{},{},{},"0x01b-","unused"]},{"entry":[{},{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC4","Event counter","EN","Event count enable","\u20021","\u20027"]},{"entry":[{},"control register 4","SEL","Event select","\u20027","6:0"]},{"entry":[{},"Address: 0xa",{},"SEL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Value","Event"]},{"entry":[{},{},{},"0x00","Instruction"]},{"entry":[{},{},{},{},"memory stall"]},{"entry":[{},{},{},"0x01","Data memory"]},{"entry":[{},{},{},{},"stall"]},{"entry":[{},{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x04","40b instruction"]},{"entry":[{},{},{},{},"valid"]},{"entry":[{},{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x06","CALL"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x07","RET instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x08","Branch"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"decoded"]},{"entry":[{},{},{},"0x09","Branch taken"]},{"entry":[{},{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},{},"side NOP"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x0b-","User events,"]},{"entry":[{},{},{},"1a","0x0b selects"]},{"entry":[{},{},{},{},"wp_events[0],"]},{"entry":[{},{},{},{},"etc"]},{"entry":[{},{},{},"0x01b-","unused"]},{"entry":[{},{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC5","Event counter","EN","Event count enable","\u20021","\u20027"]},{"entry":[{},"control register 5","SEL","Event select","\u20027","6:0"]},{"entry":[{},"Address: 0xb",{},"SEL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Value","Event"]},{"entry":[{},{},{},"0x00","Instruction"]},{"entry":[{},{},{},{},"memory stall"]},{"entry":[{},{},{},"0x01","Data memory"]},{"entry":[{},{},{},{},"stall"]},{"entry":[{},{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x04","40b instruction"]},{"entry":[{},{},{},{},"valid"]},{"entry":[{},{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x06","CALL"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x07","RET instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x08","Branch"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"decoded"]},{"entry":[{},{},{},"0x09","Branch taken"]},{"entry":[{},{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},{},"side NOP"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x0b-","User events,"]},{"entry":[{},{},{},"1a","0x0b selects"]},{"entry":[{},{},{},{},"wp_events[0],"]},{"entry":[{},{},{},{},"etc"]},{"entry":[{},{},{},"0x01b-","unused"]},{"entry":[{},{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC6","Event counter","EN","Event count enable","\u20021","\u20027"]},{"entry":[{},"control register 6","SEL","Event select","\u20027","6:0"]},{"entry":[{},"Address: 0xc",{},"SEL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Value","Event"]},{"entry":[{},{},{},"0x00","Instruction"]},{"entry":[{},{},{},{},"memory stall"]},{"entry":[{},{},{},"0x01","Data memory"]},{"entry":[{},{},{},{},"stall"]},{"entry":[{},{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x04","40b instruction"]},{"entry":[{},{},{},{},"valid"]},{"entry":[{},{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x06","CALL"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x07","RET instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x08","Branch"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"decoded"]},{"entry":[{},{},{},"0x09","Branch taken"]},{"entry":[{},{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},{},"side NOP"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x0b-","User events,"]},{"entry":[{},{},{},"1a","0x0b selects"]},{"entry":[{},{},{},{},"wp_events[0],"]},{"entry":[{},{},{},{},"etc"]},{"entry":[{},{},{},"0x01b-","unused"]},{"entry":[{},{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC7","Event counter","EN","Event count enable","\u20021","\u20027"]},{"entry":[{},"control register 7","SEL","Event select","\u20027","6:0"]},{"entry":[{},"Address: 0xd",{},"SEL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Value","Event"]},{"entry":[{},{},{},"0x00","Instruction"]},{"entry":[{},{},{},{},"memory stall"]},{"entry":[{},{},{},"0x01","Data memory"]},{"entry":[{},{},{},{},"stall"]},{"entry":[{},{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x04","40b instruction"]},{"entry":[{},{},{},{},"valid"]},{"entry":[{},{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},{},"instruction valid"]},{"entry":[{},{},{},"0x06","CALL"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x07","RET instruction"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x08","Branch"]},{"entry":[{},{},{},{},"instruction"]},{"entry":[{},{},{},{},"decoded"]},{"entry":[{},{},{},"0x09","Branch taken"]},{"entry":[{},{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},{},"side NOP"]},{"entry":[{},{},{},{},"executed"]},{"entry":[{},{},{},"0x0b-","User events,"]},{"entry":[{},{},{},"1a","0x0b selects"]},{"entry":[{},{},{},{},"wp_events[0],"]},{"entry":[{},{},{},{},"etc"]},{"entry":[{},{},{},"0x01b-","unused"]},{"entry":[{},{},{},"7f",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["EC0","Event counter",{},{},{},"16","15:0\u2002"]},{"entry":[{},"register 0",{},{},{},{},{}]},{"entry":[{},"Address 0xe",{},{},{},{},{}]},{"entry":["EC1","Event counter",{},{},{},"16","15:0\u2002"]},{"entry":[{},"register 1",{},{},{},{},{}]},{"entry":[{},"Address 0xf",{},{},{},{},{}]},{"entry":["EC2","Event counter",{},{},{},"16","15:0\u2002"]},{"entry":[{},"register 2",{},{},{},{},{}]},{"entry":[{},"Address 0x10",{},{},{},{},{}]},{"entry":["EC3","Event counter",{},{},{},"16","15:0\u2002"]},{"entry":[{},"register 3",{},{},{},{},{}]},{"entry":[{},"Address 0x11",{},{},{},{},{}]},{"entry":["EC4","Event counter",{},{},{},"16","15:0\u2002"]},{"entry":[{},"register 4",{},{},{},{},{}]},{"entry":[{},"Address 0x12",{},{},{},{},{}]},{"entry":["EC5","Event counter",{},{},{},"16","15:0\u2002"]},{"entry":[{},"register 5",{},{},{},{},{}]},{"entry":[{},"Address 0x13",{},{},{},{},{}]},{"entry":["EC6","Event counter",{},{},{},"16","15:0\u2002"]},{"entry":[{},"register 6",{},{},{},{},{}]},{"entry":[{},"Address 0x14",{},{},{},{},{}]},{"entry":["EC7","Event counter",{},{},{},"16","15:0\u2002"]},{"entry":[{},"register 7",{},{},{},{},{}]},{"entry":[{},"Address 0x15"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},"Generally, the DBG_CNTRL register implements a single bit which re-enables event capture after the detection of an IDLE instruction. Processor  indicates that it is in the IDLE state by the assertion of boundary pin risc_is_idle. To avoid counting irrelevant events event capture and counting is halted when the processor  is in the idle state. DBG_CNTRL[0] is a sticky-bit which indicates an IDLE state has been detected. A write of 0x0 to DBG_CNTRL can be used to clear this bit. Once the processor  has been moved out of the IDLE state, DBG_CNTRL[0]=0 will re-enable event counting.","There are also four instruction memory address break- or trace-point registers. A break- or trace-point match is indicated by assertion of the risc_brk_trc_match pin. A trace-point match is indicated by further assertion of risc_trc_pt_match. External logic can detect a break point by:","break point match=risc_brk_trc_match & !risc_trc_pt_match.","In cases where multiple BRKx registers are programmed identically, the BRKx register with the lowest address will control assertion of the risc_trc_pt_match_id, BRK0 will have precedence over BRK1, etc. Behavior is undetermined when two or more BRKx registers are identical with the exception of the TM bit. This is considered an illegal condition and should be avoided.","There are also 8 event counters and 8 associated event counter control registers. Each event counter can be programmed to count one type. There are 11 internal event types and 16 user defined event types. User events are supplied to the debug model via the pins wp_events. User defined events are expected to be single cycle per event and active high on the wp_events bus. The ECC0-ECC7 registers consist of a mux select field [6:0] and an enable bit [7]. The event count register EC0-EC7 simply contain the count values for the events programmed by the associated ECC0-ECC7 registers. EC0-EC7 are 16 bit registers which are cleared on reset. The upper 16 bits are not writeable and read as zeros.","7.11. Instruction Set Architecture Example","Table 15 below illustrates an example of an instruction set architecture for processor , where:\n\n",{"@attributes":{"id":"p-0855","num":"1095"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Syntax\/Pseudocode","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ABS .(SA,SB) s1(R4)","ABSOLUTE"]},{"entry":["void ISA::OPC_ABS_20b_9 (Gpr &s1,Unit &unit)","VALUE"]},{"entry":["{",{}]},{"entry":["\u2003s1 = s1 < 0 ? \u2212s1 : s1;",{}]},{"entry":["\u2003Csr.setBit(EQ,unit,s1.zero( ));",{}]},{"entry":["}",{}]},{"entry":["ADD .(SA,SB) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_ADD_20b_106 (Gpr &s1, Gpr &s2,Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 + s1;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.carryout( );",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ADD .(SA,SB) s1(U4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_ADD_20b_107 (U4 &s1, Gpr &s2,Unit &unit)","ADDITION, U4"]},{"entry":["{","IMM"]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 + s1;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.carryout( );",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ADD .(SB) s1(S28),SP(R5)","SIGNED"]},{"entry":["void ISA::OPC_ADD_40b_210 (S28 &s1)","ADDITION, SP,"]},{"entry":["{","S28 IMM"]},{"entry":["\u2003Sp += s1;",{}]},{"entry":["}",{}]},{"entry":["ADD .(SB) s1(S24), SP(R5), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_ADD_40b_211 (U24 &s1, Gpr &s2)","ADDITION, SP,"]},{"entry":["{","S24 IMM, REG"]},{"entry":["\u2003s2 = Sp + s1;","DEST"]},{"entry":["}",{}]},{"entry":["ADD .(SB) s1(S24),s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_ADD_40b_212 (U24 &s1, Gpr &s2,Unit &unit)","ADDITION, S24"]},{"entry":["\u2003{","IMM"]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 + s1;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.carryout( );",{}]},{"entry":["}",{}]},{"entry":["ADD2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_ADD2_20b_363 (Gpr &s1, Gpr &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2"]},{"entry":["\u2003s2.range(0,15) =",{}]},{"entry":["\u2003\u2003(s1.range(0,15) + s2.range(0,15)) >> 1;",{}]},{"entry":["\u2003s2.range(16,31) =",{}]},{"entry":["\u2003\u2003(s1.range(16,31) + s2.range(16,31)) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2 .(SA,SB) s1(U4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_ADD2_20b_364 (U4 &s1, Gpr &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2"]},{"entry":["\u2003s2.range(0,15) = (s1.value( ) + s2.range(0,15)) >> 1;",{}]},{"entry":["\u2003s2.range(16,31) = (s1.value( ) + s2.range(16,31)) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_ADD2U_20b_365 (Gpr &s1, Gpr &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2,"]},{"entry":["\u2003s2.range(0,15) =","UNSIGNED"]},{"entry":["\u2003\u2003(_unsigned(s1.range(0,15)) + _unsigned(s2.range(0,15))) >> 1;",{}]},{"entry":["\u2003s2.range(16,31) =",{}]},{"entry":["\u2003\u2003(_unsigned(s1.range(16,31)) + _unsigned(s2.range(16,31))) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2U .(SA,SB) s1(U4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_ADD2U_20b_366 (U4 &s1, Gpr &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2,"]},{"entry":["\u2003s2.range(0,15) =","UNSIGNED"]},{"entry":["\u2003\u2003(s1.value( ) + _unsigned(s2.range(0,15))) >> 1;",{}]},{"entry":["\u2003s2.range(16,31) =",{}]},{"entry":["\u2003\u2003(s1.value( ) + _unsigned(s2.range(16,31))) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADDU .(SA,SB) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_ADDU_20b_123 (Gpr &s1, Gpr &s2, Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = _unsigned(s2) + _unsigned(s1);",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.overflow( );",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ADDU .(SA,SB) s1(U4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_ADDU_20b_124 (U4 &s1, Gpr &s2, Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = _unsigned(s2) + s1;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.overflow( );",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["AND .(SA,SB) s1(R4), s2(R4)","BITWISE AND"]},{"entry":["void ISA::OPC_AND_20b_88 (Gpr &s1, Gpr &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2003s2 &= s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["AND .(SA,SB) s1(U4), s2(R4)","BITWISE AND, U4"]},{"entry":["void ISA::OPC_AND_20b_89 (U4 &s1, Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2003s2 &= s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["AND .(SB) s1(S3), s2(U20), s3(R4)","BITWISE AND,"]},{"entry":["void ISA::OPC_AND_40b_213 (U3 &s1, U20 &s2, Gpr &s3,Unit &unit)","U20 IMM, BYTE"]},{"entry":["{","ALIGNED"]},{"entry":["\u2003s3 &= (s2 << (s1*8));",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["B .(SB) s1(R4)","UNCONDITIONAL"]},{"entry":["void ISA::OPC_B_20b_0 (Gpr &s1)","BRANCH, REG,"]},{"entry":["{","ABSOLUTE"]},{"entry":["\u2003Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["B .(SB) s1(S8)","UNCONDITIONAL"]},{"entry":["void ISA::OPC_B_20b_138 (S8 &s1)","BRANCH, S8"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2003Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["B .(SB) s1(S28)","UNCONDITIONAL"]},{"entry":["void ISA::OPC_B_40b_216 (S28 &s1)","BRANCH, S28"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2003Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BEQ .(SB) s1(R4)","BRANCH EQUAL,"]},{"entry":["void ISA::OPC_BEQ_20b_2 (Gpr &s1,Unit &unit)","REG, ABSOLUTE"]},{"entry":["{",{}]},{"entry":["\u2003if(Csr.bit(EQ,unit)) Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["BEQ .(SB) s1(S8)","BRANCH EQUAL,"]},{"entry":["void ISA::OPC_BEQ_20b_140 (S8 &s1,Unit &unit)","S8 IMM, PC REL"]},{"entry":["{",{}]},{"entry":["\u2003if(Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BEQ .(SB) s1(S28)","BRANCH EQUAL,"]},{"entry":["void ISA::OPC_BEQ_40b_218 (S28 &s1,Unit &unit)","S28 IMM, PC REL"]},{"entry":["{",{}]},{"entry":["\u2003if(Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BGE .(SB) s1(R4)","BRANCH"]},{"entry":["void ISA::OPC_BGE_20b_6 (Gpr &s1,Unit &unit)","GREATER OR"]},{"entry":["{","EQUAL, REG,"]},{"entry":["\u2003if(Csr.bit(GT,unit) || Csr.bit(EQ,unit))","ABSOLUTE"]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003Pc = s1;",{}]},{"entry":["\u2003}",{}]},{"entry":["}",{}]},{"entry":["BGE .(SB) s1(S8)","BRANCH"]},{"entry":["void ISA::OPC_BGE_20b_144 (S8 &s1,Unit &unit)","GREATER OR"]},{"entry":["{","EQUAL, S8 IMM,"]},{"entry":["\u2003if(Csr.bit(GT,unit) || Csr.bit(EQ,unit)) Pc += s1;","PC REL"]},{"entry":["}",{}]},{"entry":["BGE .(SB) s1(S28)","BRANCH"]},{"entry":["void ISA::OPC_BGE_40b_222 (S28 &s1,Unit &unit)","GREATER OR"]},{"entry":["{","EQUAL, S28 IMM,"]},{"entry":["\u2003if(Csr.bit(GT,unit) || Csr.bit(EQ,unit)) Pc += s1;","PC REL"]},{"entry":["}",{}]},{"entry":["BGT .(SB) s1(R4)","BRANCH"]},{"entry":["void ISA::OPC_BGT_20b_4 (Gpr &s1,Unit &unit)","GREATER, REG,"]},{"entry":["{","ABSOLUTE"]},{"entry":["\u2003if(Csr.bit(GT,unit)) Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["BGT .(SB) s1(S8)","BRANCH"]},{"entry":["void ISA::OPC_BGT_20b_142 (S8 &s1,Unit &unit)","GREATER, S8"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2003if(Csr.bit(GT,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BGT .(SB) s1(S28)","BRANCH"]},{"entry":["void ISA::OPC_BGT_40b_220 (S28 &s1,Unit &unit)","GREATER, S28"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2003if(Csr.bit(GT,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BKPT .(SB)","BREAK POINT"]},{"entry":["void ISA::OPC_BKPT_20b_12 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2003\/\/This instruction effectively halts",{}]},{"entry":["\u2003\/\/instruction issue until intervention",{}]},{"entry":["\u2003\/\/by the debug system",{}]},{"entry":["\u2003Pc = Pc;",{}]},{"entry":["}",{}]},{"entry":["BLE .(SB) s1(R4)","BRANCH LESS"]},{"entry":["void ISA::OPC_BLE_20b_5 (Gpr &s1,Unit &unit)","OR EQUAL, REG,"]},{"entry":["{","ABSOLUTE"]},{"entry":["\u2003if(Csr.bit(LT,unit) || Csr.bit(EQ,unit))",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003Pc = s1;",{}]},{"entry":["\u2003}",{}]},{"entry":["}",{}]},{"entry":["BLE .(SB) s1(S8)","BRANCH LESS"]},{"entry":["void ISA::OPC_BLE_20b_143 (S8 &s1,Unit &unit)","OR EQUAL, S8"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2003if(Csr.bit(LT,unit) || Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BLE .(SB) s1(S28)","BRANCH LESS"]},{"entry":["void ISA::OPC_BLE_40b_221 (S28 &s1,Unit &unit)","OR EQUAL, S28"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2003if(Csr.bit(LT,unit) || Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BLT .(SB) s1(R4)","BRANCH LESS,"]},{"entry":["void ISA::OPC_BLT_20b_1 (Gpr &s1,Unit &unit)","REG, ABSOLUTE"]},{"entry":["{",{}]},{"entry":["\u2003if(Csr.bit(LT,unit)) Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["BLT .(SB) s1(S8)","BRANCH LESS, S8"]},{"entry":["void ISA::OPC_BLT_20b_139 (S8 &s1,Unit &unit)","IMM, PC REL"]},{"entry":["{",{}]},{"entry":["\u2003if( Csr.bit(LT,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BLT .(SB) s1(S28)","BRANCH LESS,"]},{"entry":["void ISA::OPC_BLT_40b_217 (S28 &s1,Unit &unit)","S28 IMM, PC REL"]},{"entry":["{",{}]},{"entry":["\u2003if(Csr.bit(LT,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BNE .(SB) s1(R4)","BRANCH NOT"]},{"entry":["void ISA::OPC_BNE_20b_3 (Gpr &s1,Unit &unit)","EQUAL, REG,"]},{"entry":["{","ABSOLUTE"]},{"entry":["\u2003if(!Csr.bit(EQ,unit)) Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["BNE .(SB) s1(S8)","BRANCH NOT"]},{"entry":["void ISA::OPC_BNE_20b_141 (S8 &s1,Unit &unit)","EQUAL, S8 IMM,"]},{"entry":["{","PC REL"]},{"entry":["\u2003if(!Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BNE .(SB) s1(S28)","BRANCH NOT"]},{"entry":["void ISA::OPC_BNE_40b_219 (S28 &s1,Unit &unit)","EQUAL, S28 IMM,"]},{"entry":["{","PC REL"]},{"entry":["\u2003if(!Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["CALL .(SB) s1(R4)","CALL"]},{"entry":["void ISA::OPC_CALL_20b_7 (Gpr &s1)","SUBROUTINE,"]},{"entry":["{","REG, ABSOLUTE"]},{"entry":["\u2003dmem->write(Sp,Pc+3);",{}]},{"entry":["\u2003Sp \u2212= 4;",{}]},{"entry":["\u2003Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["CALL .(SB) s1(S8)","CALL"]},{"entry":["void ISA::OPC_CALL_20b_145 (S8 &s1)","SUBROUTINE, S8"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2003dmem->write(Sp.value( ),Pc+3);",{}]},{"entry":["\u2003Sp \u2212= 4;",{}]},{"entry":["\u2003Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["CALL .(SB) s1(S28)","CALL"]},{"entry":["void ISA::OPC_CALL_40b_223 (S28 &s1)","SUBROUTINE,"]},{"entry":["{","S28 IMM, PC REL"]},{"entry":["dmem->write(Sp.value( ),Pc+3);",{}]},{"entry":["\u2003Sp \u2212= 4;",{}]},{"entry":["\u2003Pc += s1;",{}]},{"entry":["\u2003}",{}]},{"entry":["CIRC .(SB) s1(R4), s2(S8), s3(R4)","CIRCULAR"]},{"entry":["void ISA::OPC_CIRC_40b_260 (Gpr &s1,S8 &s2,Gpr &s3)",{}]},{"entry":["{",{}]},{"entry":["\u2003int imm_cnst = s2.value( );",{}]},{"entry":["\u2003int bot_off = s1.range(0,3);",{}]},{"entry":["\u2003int top_off = s1.range(4,7);",{}]},{"entry":["\u2003int blk_size = s1.range(8,10);",{}]},{"entry":["\u2003int str_dis = s1.bit(12);",{}]},{"entry":["\u2003int repeat = s1.bit(13);",{}]},{"entry":["\u2003int bot_flag = s1.bit(14);",{}]},{"entry":["\u2003int top_flag = s1.bit(15);",{}]},{"entry":["\u2003int pntr\u2003\u2003= s1.range(16,23);",{}]},{"entry":["\u2003int size\u2003\u2003= s1.range(24,31);",{}]},{"entry":["\u2003int tmp,addr;",{}]},{"entry":["\u2003if(imm_cnst > 0 && bot_flag && imm_cnst > bot_off)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003if(!repeat)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003tmp = (bot_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003\u2003else",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003tmp = bot_off;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003if(imm_cnst < 0 && top_flag && \u2212imm_cnst > top_off)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003if(!repeat)",{}]},{"entry":["\u2003\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003\u2003tmp = \u2212(top_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003\u2003\u2003}",{}]},{"entry":["\u2003\u2003\u2003else",{}]},{"entry":["\u2003\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003\u2003tmp = \u2212top_off;",{}]},{"entry":["\u2003\u2003\u2003}",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003\u2003else",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003tmp = imm_cnst;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003pntr = pntr << blk_size;",{}]},{"entry":["\u2003if(size == 0)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003addr = pntr + tmp;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003if((pntr + tmp) >= size)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003addr = pntr + tmp \u2212 size;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003\u2003else",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003if(pntr + tmp < 0)",{}]},{"entry":["\u2003\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003\u2003addr = pntr + tmp + size;",{}]},{"entry":["\u2003\u2003\u2003}",{}]},{"entry":["\u2003\u2003\u2003else",{}]},{"entry":["\u2003\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003\u2003addr = pntr + tmp;",{}]},{"entry":["\u2003\u2003\u2003}",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s3 = addr;",{}]},{"entry":["}",{}]},{"entry":["CLRB .(SA,SB) s1(U2), s2(U2), s3(R4)","CLEAR BYTE"]},{"entry":["void ISA::OPC_CLRB_20b_86 (U2 &s1,U2 &s2,Gpr &s3,Unit &unit)","FIELD"]},{"entry":["{",{}]},{"entry":["\u2003s3.range(s1*8,((s2+1)*8)\u22121) = 0;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["CMP .(SA,SB) s1(S4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_CMP_20b_78 (S4 &s1, Gpr &s2,Unit &unit)","COMPARE, S4"]},{"entry":["{","IMM"]},{"entry":["\u2003Csr.bit(EQ,unit) = s2 == sign_extend(s1);",{}]},{"entry":["\u2003Csr.bit(LT,unit) = s2 < sign_extend(s1);",{}]},{"entry":["\u2003Csr.bit(GT,unit) = s2 > sign_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["CMP .(SA,SB) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_CMP_20b_109 (Gpr &s1, Gpr &s2,Unit &unit)","COMPARE"]},{"entry":["{",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2003Csr.bit(LT,unit) = s2 < s1;",{}]},{"entry":["\u2003Csr.bit(GT,unit) = s2 > s1;",{}]},{"entry":["}",{}]},{"entry":["CMP .(SB) s1(S24),s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_CMP_40b_225 (S24 &s1, Gpr &s2,Unit &unit)","COMPARE, S24"]},{"entry":["{","IMM"]},{"entry":["\u2003Csr.bit(EQ,unit) = s2 == sign_extend(s1);",{}]},{"entry":["\u2003Csr.bit(LT,unit) = s2 < sign_extend(s1);",{}]},{"entry":["\u2003Csr.bit(GT,unit) = s2 > sign_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["CMPU .(SA,SB) s1(U4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_CMPU_20b_77 (U4 &s1, Gpr &s2,Unit &unit)","COMPARE, U4"]},{"entry":["{","IMM"]},{"entry":["\u2003Csr.bit(EQ,unit) = _unsigned(s2) == zero_extend(s1);",{}]},{"entry":["\u2003Csr.bit(LT,unit) = _unsigned(s2) < zero_extend(s1);",{}]},{"entry":["\u2003Csr.bit(GT,unit) = _unsigned(s2) > zero_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["CMPU .(SA,SB) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_CMPU_20b_108 (Gpr &s1, Gpr &s2,Unit &unit)","COMPARE"]},{"entry":["{",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = _unsigned(s2) == _unsigned(s1);",{}]},{"entry":["\u2003Csr.bit(LT,unit) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2003Csr.bit(GT,unit) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["}",{}]},{"entry":["CMPU .(SB) s1(U24),s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_CMPU_40b_224 (U24 &s1, Gpr &s2,Unit &unit)","COMPARE, U24"]},{"entry":["{","IMM"]},{"entry":["\u2003Csr.bit(EQ,unit) = _unsigned(s2) == zero_extend(s1);",{}]},{"entry":["\u2003Csr.bit(LT,unit) = _unsigned(s2) < zero_extend(s1);",{}]},{"entry":["\u2003Csr.bit(GT,unit) = _unsigned(s2) > zero_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["CMVEQ .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVEQ_20b_149 (Gpr &s1, Gpr &s2,Unit &unit)","MOVE, EQUAL"]},{"entry":["{",{}]},{"entry":["\u2003s2 = Csr.bit(EQ,unit) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVGE .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVGE_20b_155 (Gpr &s1, Gpr &s2, Unit &unit)","MOVE, GREATER"]},{"entry":["{","THAN OR EQUAL"]},{"entry":["\u2003s2 = (Csr.bit(EQ,unit) | Csr.bit(GT,unit)) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVGT .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVGT_20b_148 (Gpr &s1, Gpr &s2,Unit &unit)","MOVE, GREATER"]},{"entry":["{","THAN"]},{"entry":["\u2003s2 = Csr.bit(GT,unit) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVLE .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVLE_20b_151 (Gpr &s1, Gpr &s2, Unit &unit)","MOVE, LESS"]},{"entry":["{","THAN OR EQUAL"]},{"entry":["\u2003s2 = (Csr.bit(EQ,unit) | Csr.bit(LT,unit)) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVLT .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVLT_20b_147 (Gpr &s1, Gpr &s2,Unit &unit)","MOVE, LESS"]},{"entry":["{","THAN"]},{"entry":["\u2003s2 = Csr.bit(LT,unit) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVNE .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVNE_20b_150 (Gpr &s1, Gpr &s2,Unit &unit)","MOVE, NOT"]},{"entry":["{","EQUAL"]},{"entry":["\u2003s2 = !Csr.bit(EQ,unit) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["DCBNZ .(SB) s1(R4), s2(R4)","DECREMENT,"]},{"entry":["void ISA::OPC_DCBNZ_20b_152 (Gpr &s1, Gpr &s2)","COMPARE,"]},{"entry":["{","BRANCH NON-"]},{"entry":["\u2003\u2212\u2212s1;","ZERO"]},{"entry":["\u2003if(s1 != 0)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003Pc = s2;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003Pc = (cregs[aPC]+1)>>1;",{}]},{"entry":["\u2003}",{}]},{"entry":["}",{}]},{"entry":["DCBNZ .(SB) s1(R4),s2(U16)","DECREMENT,"]},{"entry":["void ISA::OPC_DCBNZ_40b_247 (Gpr &s1,U16 &s2)","COMPARE,"]},{"entry":["{","BRANCH NON-"]},{"entry":["\u2003\u2212\u2212s1;","ZERO"]},{"entry":["\u2003if(s1 != 0) Pc = s2;",{}]},{"entry":["}",{}]},{"entry":["END .(SA,SB)","END OF THREAD"]},{"entry":["void ISA::OPC_END_20b_10 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2003\/\/This instruction asserts the is_end flag",{}]},{"entry":["\u2003\/\/in execution stage 5310 and then performs repeated",{}]},{"entry":["\u2003\/\/nops until an external force PC event",{}]},{"entry":["\u2003\/\/occurs.",{}]},{"entry":["\u2003risc_is_end._assert(1);",{}]},{"entry":["\u2003Pc = Pc;",{}]},{"entry":["}",{}]},{"entry":["EXTB .(SA,SB) s1(U2), s2(U2), s3(R4)","EXTRACT"]},{"entry":["void ISA::OPC_EXTB_20b_122 (U2 &s1,U2 &s2,Gpr &s3,Unit &unit)","SIGNED BYTE"]},{"entry":["{","FIELD"]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp = s3;",{}]},{"entry":["\u2003s3.clear( );",{}]},{"entry":["\u2003s3.range(0,s2*8) = sign_extend(tmp.range(s1*8,((s2+1)*8)\u22121));",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["EXTBU .(SA,SB) s1(U2), s2(U2), s3(R4)","EXTRACT"]},{"entry":["void ISA::OPC_EXTBU_20b_87 (U2 &s1,U2 &s2,Gpr &s3,Unit &unit)","UNSIGNED BYTE"]},{"entry":["{","FIELD"]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp = s3;",{}]},{"entry":["\u2003s3.clear( );",{}]},{"entry":["\u2003s3 = tmp.range(s1*8,((s2+1)*8)\u22121);",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["EXTU .(SB) s1(U6), s2(U6), s3(R4)","EXTRACT"]},{"entry":["void ISA::OPC_EXTU_40b_282 (U6 &s1, U6 &s2,Gpr &s3,Unit &unit)","UNSIGNED BIT"]},{"entry":["{","FIELD"]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp = s3;",{}]},{"entry":["\u2003s3.clear( );",{}]},{"entry":["\u2003s3 = tmp.range(s1,s2);",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["IDLE .(SB)","REPETITIVE NOP"]},{"entry":["void ISA::OPC_IDLE_20b_13 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2003\/\/This instruction effectively halts",{}]},{"entry":["\u2003\/\/instruction issue until an external",{}]},{"entry":["\u2003\/\/event occurs.",{}]},{"entry":["\u2003Pc = Pc;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+LBR[s1(U4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_50 (U4 &s1,Gpr &s2)","BYTE, LBR, +U4"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->byte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+LBR[s1(R4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_55 (Gpr &s1, Gpr &s2)","BYTE, LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->byte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *LBR++[s1(U4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_60 (U4 &s1, Gpr &s2)","BYTE, LBR, +U4"]},{"entry":["{","OFFSET POST"]},{"entry":["\u2003s2 = dmem->byte(Lbr);","ADJ"]},{"entry":["\u2003Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *LBR++[s1(R4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_65 (Gpr &s1, Gpr &s2)","BYTE, LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2 = dmem->byte(Lbr);","ADJ"]},{"entry":["\u2003Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+s1(R4), s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_70 (Gpr &s1, Gpr &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->byte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *s1(R4)++, s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_75 (Gpr &s1, Gpr &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2 = dmem->byte(s1);","INC"]},{"entry":["\u2003++s1;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+s1[s2(U20)], s3(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_188 (Gpr &s1, U20 &s2, Gpr &s3)","BYTE, +U20"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s3 = dmem->byte(s1+s2);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *s1++[s2(U20)], s3(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_193 (Gpr &s1, U20 &s2, Gpr &s3)","BYTE, +U20"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s3 = dmem->byte(s1);","ADJ"]},{"entry":["\u2003s1 += s2;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+LBR[s1(U24)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_198 (U24 &s1, Gpr &s2)","BYTE, LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->byte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *LBR++[s1(U24)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_203 (U24 &s1, Gpr &s2)","BYTE, LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2 = dmem->byte(Lbr+s1);","ADJ"]},{"entry":["\u2003++Lbr;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *s1(U24),s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_208 (U24 &s1, Gpr &s2)","BYTE, U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2003s2 = dmem->byte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+SP[s1(U24)], s2(R4)","LOAD BYTE, SP,"]},{"entry":["void ISA::OPC_LDB_40b_258 (U24 &s1, Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003s2 = sign_extend(dmem->byte(Sp+s1));",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+LBR[s1(U4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_47 (U4 &s1,Gpr &s2)","BYTE, LBR, +U4"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2 = dmem->ubyte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+LBR[s1(R4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_52 (Gpr &s1, Gpr &s2)","BYTE, LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2 = dmem->ubyte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *LBR++[s1(U4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_57 (U4 &s1, Gpr &s2)","BYTE, LBR, +U4"]},{"entry":["{","OFFSET POST"]},{"entry":["\u2003s2.clear( );","ADJ"]},{"entry":["\u2003s2 = dmem->ubyte(Lbr);",{}]},{"entry":["\u2003Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *LBR++[s1(R4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_62 (Gpr &s1, Gpr &s2)","BYTE, LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2.clear( );","ADJ"]},{"entry":["\u2003s2 = dmem->ubyte(Lbr);",{}]},{"entry":["\u2003Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+s1(R4), s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_67 (Gpr &s1, Gpr &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2 = dmem->ubyte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *s1(R4)++, s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_72 (Gpr &s1, Gpr &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2.clear( );","INC"]},{"entry":["\u2003s2 = dmem->ubyte(s1);",{}]},{"entry":["\u2003++s1;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+s1[s2(U20)], s3(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_185 (Gpr &s1, U20 &s2, Gpr &s3)","BYTE, +U20"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s3.clear( );",{}]},{"entry":["\u2003s3.byte(0) = dmem->ubyte(s1+s2);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *s1++[s2(U20)], s3(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_190 (Gpr &s1, U20 &s2, Gpr &s3)","BYTE, +U20"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s3.clear( );","ADJ"]},{"entry":["\u2003s3.byte(0) = dmem->ubyte(s1+s2);",{}]},{"entry":["\u2003s1+= s2;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+LBR[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_195 (U24 &s1, Gpr &s2)","BYTE, LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2.byte(0) = dmem->ubyte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *LBR++[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_200 (U24 &s1, Gpr &s2)","BYTE, LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2.clear( );","ADJ"]},{"entry":["\u2003s2.byte(0) = dmem->ubyte(Lbr);",{}]},{"entry":["\u2003Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *s1(U24),s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_205 (U24 &s1, Gpr &s2)","BYTE, U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2.byte(0) = dmem->ubyte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+SP[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_255 (U24 &s1,Gpr &s2)","BYTE, SP, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2.byte(0) = dmem->ubyte(Sp+s1);",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+LBR[s1(U4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_51 (U4 &s1,Gpr &s2)","HALF, LBR, +U4"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->half(Lbr+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+LBR[s1(R4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_56 (Gpr &s1, Gpr &s2)","HALF, LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->half(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *LBR++[s1(U4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_61 (U4 &s1, Gpr &s2)","HALF, LBR, +U4"]},{"entry":["{","OFFSET POST"]},{"entry":["\u2003s2 = dmem->half(Lbr);","ADJ"]},{"entry":["\u2003Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *LBR++[s1(R4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_66 (Gpr &s1, Gpr &s2)","HALF, LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2 = dmem->half(Lbr);","ADJ"]},{"entry":["\u2003Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+s1(R4), s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_71 (Gpr &s1, Gpr &s2)","HALF, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->half(s1);",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *s1(R4)++, s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_76 (Gpr &s1, Gpr &s2)","HALF, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2 = dmem->half(s1);","INC"]},{"entry":["\u2003s1 += 2;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+s1[s2(U20)], s3(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_189 (Gpr &s1, U20 &s2, Gpr &s3)","HALF, +U20"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s3 = dmem->half(s1+(s2<<1));",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *s1++[s2(U20)], s3(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_194 (Gpr &s1, U20 &s2, Gpr &s3)","HALF, +U20"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s3 = dmem->half(s1);","ADJ"]},{"entry":["\u2003s1 += s2<<1;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+LBR[s1(U24)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_199 (U24 &s1, Gpr &s2)","HALF, LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->half(Lbr+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *LBR++[s1(U24)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_204 (U24 &s1, Gpr &s2)","HALF, LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2 = dmem->half(Lbr);","ADJ"]},{"entry":["\u2003Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *s1(U24),s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_209 (U24 &s1, Gpr &s2)","HALF, U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2003s2 = dmem->half(s1<<1);",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+SP[s1(U24)], s2(R4)","LOAD HALF, SP,"]},{"entry":["void ISA::OPC_LDH_40b_259 (U24 &s1, Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003s2 = sign_extend(dmem->half(Sp+(s1<<1)));",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+LBR[s1(U4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_48 (U4 &s1,Gpr &s2)","HALF, LBR, +U4"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2 = dmem->uhalf(Lbr+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+LBR[s1(R4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_53 (Gpr &s1, Gpr &s2)","HALF, LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2 = dmem->uhalf(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *LBR++[s1(U4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_58 (U4 &s1, Gpr &s2)","HALF, LBR, +U4"]},{"entry":["{","OFFSET POST"]},{"entry":["\u2003s2.clear( );","ADJ"]},{"entry":["\u2003s2 = dmem->uhalf(Lbr);",{}]},{"entry":["\u2003Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *LBR++[s1(R4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_63 (Gpr &s1, Gpr &s2)","HALF, LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2.clear( );","ADJ"]},{"entry":["\u2003s2 = dmem->uhalf(Lbr);",{}]},{"entry":["\u2003Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+s1(R4), s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_68 (Gpr &s1, Gpr &s2)","HALF, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2 = dmem->uhalf(s1);",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *s1(R4)++, s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_73 (Gpr &s1, Gpr &s2)","HALF, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2.clear( );","INC"]},{"entry":["\u2003s2 = dmem->uhalf(s1);",{}]},{"entry":["\u2003s1 += 2;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+s1[s2(U20)], s3(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_186 (Gpr &s1, U20 &s2, Gpr &s3)","HALF, +U20"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s3.clear( );",{}]},{"entry":["\u2003s3.half(0) = dmem->uhalf(s1+(s2<<1));",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *s1++[s2(U20)], s3(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_191 (Gpr &s1, U20 &s2, Gpr &s3)","HALF, +U20"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s3.clear( );","ADJ"]},{"entry":["\u2003s3.half(0) = dmem->uhalf(s1);",{}]},{"entry":["\u2003s1 += s2<<1;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+LBR[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_196 (U24 &s1, Gpr &s2)","HALF, LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2.half(0) = dmem->uhalf(Lbr+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *LBR++[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_201 (U24 &s1, Gpr &s2)","HALF, LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2.clear( );","ADJ"]},{"entry":["\u2003s2.half(0) = dmem->uhalf(Lbr);",{}]},{"entry":["\u2003Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *s1(U24),s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_206 (U24 &s1, Gpr &s2)","HALF, U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2.half(0) = dmem->uhalf(s1<<1);",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+SP[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_256 (U24 &s1,Gpr &s2)","HALF, SP, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2.half(0) = dmem->uhalf(Sp+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDRF .SB s1(R4), s2(R4)","LOAD REGISTER"]},{"entry":["void ISA::OPC_LDRF_20b_80 (Gpr &s1, Gpr &s2)","FILE RANGE"]},{"entry":["{",{}]},{"entry":["\u2003if(s1 <= s2)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003for(int r=s2.address( );r<s1.address( );\u2212\u2212r)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003Sp += 4;",{}]},{"entry":["\u2003\u2003\u2003gprs[r] = dmem->read(Sp.value( ));",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["}",{}]},{"entry":["LDSYS .(SB) s1(R4), s2(R4)","LOAD SYSTEM"]},{"entry":["void ISA::OPC_LDSYS_20b_162 (Gpr &s1, Gpr &s2)","ATTRIBUTE"]},{"entry":["{","(GLS)"]},{"entry":["\u2003gls_is_load._assert(1);",{}]},{"entry":["\u2003gls_attr_valid._assert(1);",{}]},{"entry":["\u2003gls_is_ldsys._assert(1);",{}]},{"entry":["\u2003gls_regf_addr._assert(s2.address( ));",{}]},{"entry":["\u2003gls_sys_addr._assert(s1);",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+LBR[s1(U4)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_49 (U4 &s1,Gpr &s2)","LBR, +U4 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2 = dmem->word(Lbr+(s1<<2));",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+LBR[s1(R4)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_54 (Gpr &s1, Gpr &s2)","LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->word(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *LBR++[s1(U4)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_59 (U4 &s1, Gpr &s2)","LBR, +U4 OFFSET"]},{"entry":["{","POST ADJ"]},{"entry":["\u2003s2 = dmem->half(Lbr);",{}]},{"entry":["\u2003Lbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *LBR++[s1(R4)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_64 (Gpr &s1, Gpr &s2)","LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2 = dmem->word(Lbr);","ADJ"]},{"entry":["\u2003Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+s1(R4), s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_69 (Gpr &s1, Gpr &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003s2 = dmem->word(s1);",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *s1(R4)++, s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_74 (Gpr &s1, Gpr &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2003s2 = dmem->word(s1);",{}]},{"entry":["\u2003s1 += 4;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+s1[s2(U20)], s3(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_40b_187 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003s3 = dmem->word(s1+(s2<<2));",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *s1++[s2(U20)], s3(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_40b_192 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2003s3 = dmem->word(s1);",{}]},{"entry":["\u2003s1 += s2<<2;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+LBR[s1(U24)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_40b_197 (U24 &s1, Gpr &s2)","LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003s2 = dmem->word(Lbr+(s1<<2));",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *LBR++[s1(U24)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_40b_202 (U24 &s1, Gpr &s2)","LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003s2 = dmem->word(Lbr);","ADJ"]},{"entry":["\u2003Lbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *s1(U24),s2(R4)","LOAD WORD, U24"]},{"entry":["void ISA::OPC_LDW_40b_207 (U24 &s1, Gpr &s2)","IMM ADDRESS"]},{"entry":["{",{}]},{"entry":["\u2003s2 = dmem->word(s1<<2);",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+SP[s1(U24)], s2(R4)","LOAD WORD, SP,"]},{"entry":["void ISA::OPC_LDW_40b_257 (U24 &s1, Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003s2.word(0) = dmem->word(Sp+(s1<<2));",{}]},{"entry":["}",{}]},{"entry":["LMOD .(SA,SB) s1(R4), s2(R4)","LEFT MOST ONE"]},{"entry":["void ISA::OPC_LMOD_20b_82 (Gpr &s1, Gpr &s2, Unit &unit)","DETECT"]},{"entry":["{",{}]},{"entry":["\u2003int test = 1;",{}]},{"entry":["\u2003int width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2003int i;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["LMODC .(SA,SB) s1(R4), s2(R4)","LEFT MOST ONE"]},{"entry":["void ISA::OPC_LMODC_20b_83 (Gpr &s1, Gpr &s2, Unit &unit)","DETECT W\/"]},{"entry":["{","CLEAR"]},{"entry":["\u2003int test = 1;",{}]},{"entry":["\u2003int width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2003int i;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003if(s1.bit(width\u2212i) == test)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003s1.bit(width\u2212i) = !(test&0x1);",{}]},{"entry":["\u2003\u2003\u2003break;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["LMZD .(SA,SB) s1(R4), s2(R4)","LEFT MOST ZERO"]},{"entry":["void ISA::OPC_LMZD_20b_84 (Gpr &s1, Gpr &s2, Unit &unit)","DETECT"]},{"entry":["{",{}]},{"entry":["\u2003int test = 0;",{}]},{"entry":["\u2003int width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2003int i;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2003Csr.bi",{}]},{"entry":["LMZDS .(SA,SB) s1(R4), s2(R4)","LEFT MOST ZERO"]},{"entry":["void ISA::OPC_LMZDS_20b_85 (Gpr &s1, Gpr &s2, Unit &unit)","DETECT W\/ SET"]},{"entry":["{",{}]},{"entry":["\u2003int test = 0;",{}]},{"entry":["\u2003int width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2003int i;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003if(s1.bit(width\u2212i) == test)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003s1.bit(width\u2212i) = !(test&0x1);",{}]},{"entry":["\u2003\u2003\u2003break;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["MAX .(SA,SB) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_MAX_20b_121 (Gpr &s1, Gpr &s2,Unit &unit)","MAXIMUM"]},{"entry":["{",{}]},{"entry":["\u2003Csr.bit(LT,unit) = s2 < s1;",{}]},{"entry":["\u2003Csr.bit(GT,unit) = s2 > s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2003if(Csr.bit(LT,unit)) s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MAX2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAX2_20b_133 (Gpr &s1, Gpr &s2)","MAXIMUM w\/"]},{"entry":["{","REORDER"]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp.range( 0,15) = s1.range(16,31) > s2.range( 0,15)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s1.range(16,31) : s2.range( 0,15);",{}]},{"entry":["\u2003tmp.range(16,31) = s1.range( 0,15) > s2.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s1.range( 0,15) : s2.range(16,31);",{}]},{"entry":["\u2003s2.range(16,31) = s1.range(16,31) > s2.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s1.range(16,31) : s2.range(16,31);",{}]},{"entry":["\u2003s2.range( 0,15) = s1.range(16,31) > s2.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? tmp.range(16,31) : tmp.range( 0,15);",{}]},{"entry":["}",{}]},{"entry":["MAX2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAX2U_20b_156 (Gpr &s1, Gpr &s2)","MAXIMUM w\/"]},{"entry":["{","REORDER,"]},{"entry":["\u2003Result tmp;","UNSIGNED"]},{"entry":["\u2003tmp.range(0,15) = (s1.range(0,15) >=s2.range(0,15)) ? s1.range(0,15):",{}]},{"entry":["s2.range(0,15);",{}]},{"entry":["\u2003tmp.range(16,31) = (s1.range(16,31) >=s2.range(16,31)) ? s1.range(16,",{}]},{"entry":["31):s2.range(16,31);",{}]},{"entry":["\u2003s2.range(0,15) = (tmp.range(16,31)>=tmp.range(0,15)) ? tmp.range(16,",{}]},{"entry":["31):tmp.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = (tmp.range(16,31)>=tmp.range(0,15)) ? tmp.range(0,",{}]},{"entry":["15):tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MAXH .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAXH_20b_131 (Gpr &s1, Gpr &s2)","MAXIMUM"]},{"entry":["{",{}]},{"entry":["\u2003s2.range( 0,15) = s2.range( 0,15) > s1.range( 0,15)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range( 0,15) : s1.range( 0,15);",{}]},{"entry":["\u2003s2.range(16,31) = s2.range(16,31) > s1.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MAXHU .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAXHU_20b_132 (Gpr &s1, Gpr &s2)","MAXIMUM,"]},{"entry":["{","UNSIGNED"]},{"entry":["\u2003s2.range( 0,15) = _unsigned(s2.range( 0,15)) > _unsigned(s1.range( 0,",{}]},{"entry":["15))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range( 0,15) : s1.range( 0,15);",{}]},{"entry":["\u2003s2.range(16,31) = _unsigned(s2.range(16,31)) > _unsigned(s1.range(16,",{}]},{"entry":["31))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MAXMAX2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAXMAX2_20b_157 (Gpr &s1, Gpr &s2)","MAXIMUM AND"]},{"entry":["{","2nd MAXIMUM"]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp.range(16,31) = (s1.range(0,15)>=s2.range(16,31)) ? s1.range(0,15):",{}]},{"entry":["\u2003s2.range(16,31);",{}]},{"entry":["\u2003tmp.range(0,15) = (s1.range(16,31)>=s2.range(0,15)) ? s1.range(16,31):",{}]},{"entry":["\u2003s2.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = (s1.range(16,31)>=s2.range(16,31)) ? s1.range(16,31):",{}]},{"entry":["s2.range(16,31);",{}]},{"entry":["\u2003s2.range(0,15) = (s1.range(16,31)>=s2.range(16,31)) ? tmp.range(16,31) :",{}]},{"entry":["tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MAXMAX2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAXMAX2U_20b_158 (Gpr &s1, Gpr &s2)","MAXIMUM AND"]},{"entry":["{","2nd MAXIMUM,"]},{"entry":["\u2003Result tmp;","UNSIGNED"]},{"entry":["\u2003tmp.range(16,31) = (_unsigned(s1.range(0,15)) >=_unsigned(s2.range(16,",{}]},{"entry":["31))) ? s1.range(0,15) : s2.range(16,31);",{}]},{"entry":["\u2003tmp.range(0,15) = (_unsigned(s1.range(16,31))>=_unsigned(s2.range(0,",{}]},{"entry":["15))) ? s1.range(16,31) : s2.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = (_unsigned(s1.range(16,31))>=_unsigned(s2.range(16,",{}]},{"entry":["31))) ? s1.range(16,31) : s2.range(16,31);",{}]},{"entry":["\u2003s2.range(0,15) = (_unsigned(s1.range(16,31))>=_unsigned(s2.range(16,",{}]},{"entry":["31))) ? tmp.range(16,31) : tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MAXU .(SA,SB) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_MAXU_20b_120 (Gpr &s1, Gpr &s2,Unit &unit)","MAXIMUM"]},{"entry":["{",{}]},{"entry":["\u2003Csr.bit(LT,unit) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2003Csr.bit(GT,unit) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2003if(Csr.bit(LT,unit)) s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MFVRC .(SB) s1(R5),s2(R4)","MOVE VREG TO"]},{"entry":["void ISA::OPC_MFVRC_40b_266 (Vreg &s1, Gpr &s2)","GPR, COLLAPSE"]},{"entry":["{",{}]},{"entry":["\u2003Event initiate,complete;",{}]},{"entry":["\u2003Reg s2Save;",{}]},{"entry":["\u2003\u2003risc_is_mfvrc._assert(1);",{}]},{"entry":["\u2003\u2003vec_regf_enz._assert(0);",{}]},{"entry":["\u2003\u2003vec_regf_hwz._assert(0x3);",{}]},{"entry":["\u2003\u2003vec_regf_ra._assert(s1);",{}]},{"entry":["\u2003\u2003s2Save = s2.address( );",{}]},{"entry":["\u2003\u2003initiate.live(true);",{}]},{"entry":["\u2003\u2003complete.live(vec_wdata_wrz.is(0));",{}]},{"entry":["}",{}]},{"entry":["MFVVR .(SB) s1(R5), s2(R5), s3(R4)","MOVE"]},{"entry":["void ISA::OPC_MFVVR_40b_264 (Vunit &s1, Vreg &s2,Gpr &s3)","VUNIT\/VREG TO"]},{"entry":["{","GPR"]},{"entry":["\u2003Event initiate,complete;",{}]},{"entry":["\u2003Reg s3Save;",{}]},{"entry":["\u2003risc_is_mfvvr._assert(1);",{}]},{"entry":["\u2003vec_regf_ua._assert(s1);",{}]},{"entry":["\u2003vec_regf_hwz._assert(0x3);",{}]},{"entry":["\u2003vec_regf_enz._assert(0);",{}]},{"entry":["\u2003vec_regf_ra._assert(s2);",{}]},{"entry":["\u2003s3Save = s3.address( );",{}]},{"entry":["\u2003initiate.live(true);\u2003\u2003\/\/this is an modeling artifact",{}]},{"entry":["\u2003complete.live(vec_wdata_wrz.is(0)); \/\/ditto",{}]},{"entry":["\u2003}",{}]},{"entry":["MFVVR .SB s1(R5), s2(R5), s3(R4)","MOVE"]},{"entry":["void ISA::OPC_MFVVR_40b_264 (Vunit &s1, Vreg &s2,Gpr &s3)","VUNIT\/VREG TO"]},{"entry":["{","GPR"]},{"entry":["\u2003Reg s3Save;",{}]},{"entry":["\u2003risc_is_mfvvr._assert(1);",{}]},{"entry":["\u2003risc_vec_ua._assert(s1);",{}]},{"entry":["\u2003risc_vec_ra._assert(s2);",{}]},{"entry":["\u2003s3Save = s3.address( );",{}]},{"entry":["\u2003initiate.live(true);",{}]},{"entry":["\u2003vec_risc_wa._assert(s3);",{}]},{"entry":["vec_risc_wd gets value of Vreg(risc_vec_ra);",{}]},{"entry":["\u2003complete.live(vec_risc_wrz.is(0)); \/\/ditto",{}]},{"entry":["}",{}]},{"entry":["MIN .(SA,SB) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_MIN_20b_119 (Gpr &s1, Gpr &s2,Unit &unit)","MINIMUM"]},{"entry":["{",{}]},{"entry":["\u2003Csr.bit(LT,unit) = s2 < s1;",{}]},{"entry":["\u2003Csr.bit(GT,unit) = s2 > s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2003if(Csr.bit(GT,unit)) s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MIN2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MIN2_20b_166 (Gpr &s1, Gpr &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM"]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp.range(0,15) = (s1.range(0,15) <s2.range(0,15)) ? s1.range(0,15):",{}]},{"entry":["s2.range(0,15);",{}]},{"entry":["\u2003tmp.range(16,31) = (s1.range(16,31) <s2.range(16,31)) ? s1.range(16,",{}]},{"entry":["31):s2.range(16,31);",{}]},{"entry":["\u2003s2.range(0,15) = (tmp.range(16,31)<tmp.range(0,15)) ? tmp.range(16,",{}]},{"entry":["31):tmp.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = (tmp.range(16,31)<tmp.range(0,15)) ? tmp.range(0,",{}]},{"entry":["15):tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MIN2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MIN2U_20b_167 (Gpr &s1, Gpr &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM,"]},{"entry":["\u2003Result tmp;","UNSIGNED"]},{"entry":["\u2003tmp.range(0,15) = (_unsigned(s1.range(0,15)) <_unsigned(s2.range(0,",{}]},{"entry":["15))) ? s1.range(0,15):s2.range(0,15);",{}]},{"entry":["\u2003tmp.range(16,31) = (_unsigned(s1.range(16,31)) <_unsigned(s2.range(16,",{}]},{"entry":["31))) ? s1.range(16,31):s2.range(16,31);",{}]},{"entry":["\u2003s2.range(0,15) = (_unsigned(tmp.range(16,31))<_unsigned(tmp.range(0,",{}]},{"entry":["15))) ? tmp.range(16,31):tmp.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = (_unsigned(tmp.range(16,31))<_unsigned(tmp.range(0,",{}]},{"entry":["15))) ? tmp.range(0,15):tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MINH .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MINH_20b_160 (Gpr &s1, Gpr &s2, Unit &unit)","MINIMUM"]},{"entry":["{",{}]},{"entry":["\u2003s2.range( 0,15) = s2.range( 0,15) < s1.range( 0,15)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range( 0,15) : s1.range( 0,15);",{}]},{"entry":["\u2003s2.range(16,31) = s2.range(16,31) < s1.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MINHU .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MINHU_20b_161 (Gpr &s1, Gpr &s2, Unit &unit)","MINIMUM,"]},{"entry":["{","UNSIGNED"]},{"entry":["\u2003s2.range( 0,15) = _unsigned(s2.range( 0,15)) < _unsigned(s1.range( 0,",{}]},{"entry":["15))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range( 0,15) : s1.range( 0,15);",{}]},{"entry":["\u2003s2.range(16,31) = _unsigned(s2.range(16,31)) < _unsigned(s1.range(16,",{}]},{"entry":["31))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MINMIN2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MINMIN2_20b_168 (Gpr &s1, Gpr &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM"]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp.range(16,31) = s1.range(0,15) <s2.range(16,31) ? s1.range(0,15) :",{}]},{"entry":["s2.range(16,31);",{}]},{"entry":["\u2003tmp.range(0,15) = s1.range(16,31)<s2.range(0,15) ? s2.range(16,31) :",{}]},{"entry":["s1.range(16,31);",{}]},{"entry":["\u2003s2.range(16,31) = s1.range(16,31)<s2.range(16,31) ? s1.range(16,31) :",{}]},{"entry":["s2.range(16,31);",{}]},{"entry":["\u2003s2.range(0,15) = s1.range(16,31)<s2.range(16,31) ? tmp.range(16,31):",{}]},{"entry":["tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MINMIN2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MINMIN2U_20b_169 (Gpr &s1, Gpr &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM,"]},{"entry":["\u2003Result tmp;","UNSIGNED"]},{"entry":["\u2003tmp.range(16,31) = _unsigned(s1.range(0,15) )<_unsigned(s2.range(16,",{}]},{"entry":["31)) ? s1.range(0,15) : s2.range(16,31);",{}]},{"entry":["\u2003tmp.range(0,15) = _unsigned(s1.range(16,31))<_unsigned(s2.range(0,",{}]},{"entry":["15) ) ? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["\u2003s2.range(16,31) = _unsigned(s1.range(16,31))<_unsigned(s2.range(16,",{}]},{"entry":["31)) ? s1.range(16,31) : s2.range(16,31);",{}]},{"entry":["\u2003s2.range(0,15) = _unsigned(s1.range(16,31))<_unsigned(s2.range(16,",{}]},{"entry":["31)) ? tmp.range(16,31): tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MINU .(SA,SB) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_MINU_20b_118 (Gpr &s1, Gpr &s2,Unit &unit)","MINIMUM"]},{"entry":["{",{}]},{"entry":["\u2003Csr.bit(LT,unit) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2003Csr.bit(GT,unit) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2003if(Csr.bit(GT,unit)) s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MPY .(SA,SB) s1(R4), s2(R4)","SIGNED 16b"]},{"entry":["void ISA::OPC_MPY_20b_115 (Gpr &s1, Gpr &s2,Unit &unit)","MULTIPLY"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2.range(0,15)*s1.range(0,15);",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["MPYH .(SA,SB) s1(R4), s2(R4)","SIGNED 16b"]},{"entry":["void ISA::OPC_MPYH_20b_116 (Gpr &s1, Gpr &s2,Unit &unit)","MULTIPLY, HIGH"]},{"entry":["{","HALF WORDS"]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2.range(16,31)*s1.range(16,31);",{}]},{"entry":["\u2003s1 = r1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["MPYLH .(SA,SB) s1(R4), s2(R4)","SIGNED 16b"]},{"entry":["void ISA::OPC_MPYLH_20b_117 (Gpr &s1, Gpr &s2,Unit &unit)","MULTIPLY, LOW"]},{"entry":["{","HALF TO HIGH"]},{"entry":["\u2003Result r1;","HALF"]},{"entry":["\u2003r1 = s2.range(16,31)*s1.range(0,15);",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["MPYU .(SA,SB) s1(R4), s2(R4)","UNSIGNED 16b"]},{"entry":["void ISA::OPC_MPYU_20b_159 (Gpr &s1, Gpr &s2,Unit &unit)","MULTIPLY"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = ((unsigned)s2.range(0,15)) * ((unsigned)s1.range(0,15));",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = r1.zero( );",{}]},{"entry":["}",{}]},{"entry":["MTV .(SA,SB) s1(R4), s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTV_20b_164 (Gpr &s1, Vreg &s2)","VREG,"]},{"entry":["{","REPLICATED"]},{"entry":["\u2003Result r1;","(LOW VREG)"]},{"entry":["\u2003r1.clear( );",{}]},{"entry":["\u2003r1 = s1.range(0,15);",{}]},{"entry":["\u2003risc_is_mtv._assert(1);",{}]},{"entry":["\u2003vec_regf_enz._assert(0);",{}]},{"entry":["\u2003vec_regf_wa._assert(s2);",{}]},{"entry":["\u2003vec_regf_wd._assert(r1);",{}]},{"entry":["\u2003vec_regf_hwz._assert(0x0); \/\/active low, write both halves",{}]},{"entry":["}",{}]},{"entry":["MTV .(SA,SB) s1(R4), s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTV_20b_165 (Gpr &s1, Vreg &s2)","VREG,"]},{"entry":["{","REPLICATED"]},{"entry":["\u2003Result r1;","(HIGH VREG)"]},{"entry":["\u2003r1.clear( );",{}]},{"entry":["\u2003r1.range(16,31) = s1.range(16,31);",{}]},{"entry":["\u2003risc_is_mtv._assert(1);",{}]},{"entry":["\u2003vec_regf_enz._assert(0);",{}]},{"entry":["\u2003vec_regf_wa._assert(s2);",{}]},{"entry":["\u2003vec_regf_wd._assert(r1);",{}]},{"entry":["\u2003vec_regf_hwz._assert(0x0); \/\/active low, write both halves",{}]},{"entry":["}",{}]},{"entry":["MTVRE .(SB) s1(R4),s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTVRE_40b_265 (Gpr &s1, Vreg &s2)","VREG, EXPAND"]},{"entry":["{",{}]},{"entry":["\u2003risc_is_mtvre._assert(1);",{}]},{"entry":["\u2003vec_regf_enz._assert(0);",{}]},{"entry":["\u2003vec_regf_wa._assert(s2);",{}]},{"entry":["\u2003vec_regf_wd._assert(s1);",{}]},{"entry":["\u2003vec_regf_hwz._assert(0x0); \/\/active low, both halves",{}]},{"entry":["}",{}]},{"entry":["MTVVR .(SB) s1(R4), s2(R5), s3(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTVVR_40b_263 (Gpr &s1,Vunit &s2,Vreg &s3)","VUNIT\/VREG"]},{"entry":["{",{}]},{"entry":["\u2003risc_is_mtvvr._assert(1);",{}]},{"entry":["\u2003vec_regf_ua._assert(s2);",{}]},{"entry":["\u2003vec_regf_enz._assert(0);",{}]},{"entry":["\u2003vec_regf_wa._assert(s3);",{}]},{"entry":["\u2003vec_regf_wd._assert(s1);",{}]},{"entry":["\u2003vec_regf_hwz._assert(0x0); \/\/active low, both halves",{}]},{"entry":["}",{}]},{"entry":["MTVVR .SB s1(R4), s2(R5), s3(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTVVR_40b_263 (Gpr &s1,Vunit &s2,Vreg &s3)","VUNIT\/VREG"]},{"entry":["{",{}]},{"entry":["\u2003risc_is_mtvvr._assert(1);",{}]},{"entry":["\u2003risc_vec_ua._assert(s2);",{}]},{"entry":["\u2003risc_vec_wa._assert(s3);",{}]},{"entry":["\u2003risc_vec_wd._assert(s1);",{}]},{"entry":["\u2003risc_vec_hwz._assert(0x0); \/\/active low, both halves",{}]},{"entry":["}",{}]},{"entry":["MV .(SA,SB) s1(R4), s2(R4)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MV_20b_110 (Gpr &s1, Gpr &s2)","GPR"]},{"entry":["{",{}]},{"entry":["\u2003s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MVC .(SA,SB) s1(R5), s2(R4)","MOVE (LOW)"]},{"entry":["void ISA::OPC_MVC_20b_134 (Creg &s1, Gpr &s2)","CONTROL"]},{"entry":["{","REGISTER TO"]},{"entry":["\u2003\u2003s2 = s1;","GPR"]},{"entry":["}",{}]},{"entry":["MVC .(SA,SB) s1(R5), s2(R4)","MOVE (HIGH)"]},{"entry":["void ISA::OPC_MVC_20b_135 (Creg &s1, Gpr &s2)","CONTROL"]},{"entry":["{","REGISTER TO"]},{"entry":["\u2003s2 = s1;","GPR"]},{"entry":["}",{}]},{"entry":["MVC .(SA,SB) s1(R4), s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MVC_20b_136 (Gpr &s1, Creg &s2)","(LOW) CONTROL"]},{"entry":["{","REGISTER"]},{"entry":["\u2003\u2003s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MVC .(SA,SB) s1(R4), s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MVC_20b_137 (Gpr &s1, Creg &s2)","(HIGH) CONTROL"]},{"entry":["{","REGISTER"]},{"entry":["\u2003s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MVCSR .(SA,SB) s1(R4),s2(U4)","MOVE GPR BIT"]},{"entry":["void ISA::OPC_MVCSR_20b_45 (Gpr &s1, U4 &s2)","TO CSR"]},{"entry":["{",{}]},{"entry":["\u2003\/\/Copy bit 0 of s1 to the CSR bit defined",{}]},{"entry":["\u2003\/\/by s2(U4), CSR[s2]",{}]},{"entry":["\u2003Csr.setBit(s2.value( ),s1.bit(0));",{}]},{"entry":["}",{}]},{"entry":["MVCSR .(SA,SB) s1(U4),s2(R4)","MOVE CSR BIT"]},{"entry":["void ISA::OPC_MVCSR_20b_46 (U4 &s1, Gpr &s2)","TO GPR"]},{"entry":["{",{}]},{"entry":["\u2003\/\/Copy the CSR bit defined by s1(U4), CSR[U4]",{}]},{"entry":["\u2003\/\/to bit 0 of s2",{}]},{"entry":["\u2003s2.clear( );",{}]},{"entry":["\u2003s2.bit(0) = Csr.bit(s1.value( ));",{}]},{"entry":["}",{}]},{"entry":["MVK .(SA,SB) s1(S4), s2(R4)","MOVE S4 IMM TO"]},{"entry":["void ISA::OPC_MVK_20b_112 (S4 &s1, Gpr &s2)","GPR"]},{"entry":["{",{}]},{"entry":["\u2003s2 = sign_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["MVK .(SB) s1(S24),s2(R4)","MOVE S24 IMM"]},{"entry":["void ISA::OPC_MVK_40b_229 (S24 &s1,Gpr &s2)","TO GPR"]},{"entry":["{",{}]},{"entry":["\u2003s2 = sign_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["MVKA .(SB) s1(S16), s2(U3), s3(R4)","MOVE S16 IMM"]},{"entry":["void ISA::OPC_MVKA_40b_227 (S16 &s1, U3 &s2, Gpr &s3)","TO GPR,"]},{"entry":["{","ALIGNED"]},{"entry":["\u2003s3 = s1 << (s2*8);",{}]},{"entry":["}",{}]},{"entry":["MVKAU .(SB) s1(U16), s2(U3), s3(R4)","MOVE U16 IMM"]},{"entry":["void ISA::OPC_MVKAU_40b_226 (U16 &s1, U3 &s2, Gpr &s3)","TO GPR,"]},{"entry":["{","ALIGNED"]},{"entry":["\u2003s3.clear( );",{}]},{"entry":["\u2003s3 = (s1 << (s2*8));",{}]},{"entry":["}",{}]},{"entry":["MVKCHU .(SB) s1(U32),s2(R5)","MOVE IMM TO"]},{"entry":["void ISA::OPC_MVKCHU_40b_250 (U32 &s1,Creg &s2)","CREG, HIGH"]},{"entry":["{","HALF"]},{"entry":["\u2003s2.range(16,31) = s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MVKCLHU .(SB) s1(U32),s2(R5)","MOVE IMM TO"]},{"entry":["void ISA::OPC_MVKCLHU_40b_251 (U32 &s1,Creg &s2)","CREG, LOW TO"]},{"entry":["{","HIGH HALF"]},{"entry":["\u2003s2.range(16,31) = s1.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MVKCLU .(SB) s1(U32),s2(R5)","MOVE IMM TO"]},{"entry":["void ISA::OPC_MVKCLU_40b_249 (U32 &s1,Creg &s2)","CREG, LOW HALF"]},{"entry":["{",{}]},{"entry":["\u2003s2.range(0,15) = s1.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MVKHU .(SB) s1(U32),s2(R4)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKHU_40b_242 (U32 &s1,Gpr &s2)","GPR, HIGH HALF"]},{"entry":["{",{}]},{"entry":["\u2003s2.range(16,31) = s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MVKLHU .(SB) s1(U32),s2(R4)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKLHU_40b_243 (U32 &s1,Gpr &s2)","GPR, LOW TO"]},{"entry":["{","HIGH HALF"]},{"entry":["\u2003s2.range(16,31) = s1.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MVKLU .(SB) s1(U32),s2(R4)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKLU_40b_241 (U32 &s1,Gpr &s2)","GPR, LOW HALF"]},{"entry":["{",{}]},{"entry":["\u2003s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MVKU .(SA,SB) s1(U4), s2(R4)","MOVE U4 IMM"]},{"entry":["void ISA::OPC_MVKU_20b_111 (U4 &s1,Gpr &s2)","TO GPR"]},{"entry":["{",{}]},{"entry":["\u2003s2 = zero_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["MVKU .(SB) s1(U24),s2(R4)","MOVE U24 IMM"]},{"entry":["void ISA::OPC_MVKU_40b_228 (U24 &s1,Gpr &s2)","TO GPR"]},{"entry":["{",{}]},{"entry":["\u2003s2 = zero_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["MVKVRHU .(SB) s1(U32), s2(R5), s3(R5)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKVRHU_40b_268 (U16 &s1, Vunit &s2, Vreg &s3)","VUNIT\/VREG,"]},{"entry":["{","HIGH HALF"]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = _unsigned(s1.range(16,31));",{}]},{"entry":["\u2003risc_is_mtvvr._assert(1);",{}]},{"entry":["\u2003vec_regf_ua._assert(s2);",{}]},{"entry":["\u2003vec_regf_enz._assert(0);",{}]},{"entry":["\u2003vec_regf_wa._assert(s3);",{}]},{"entry":["\u2003vec_regf_wd._assert(r1);",{}]},{"entry":["\u2003vec_regf_hwz._assert(0x1); \/\/active low, high half",{}]},{"entry":["}",{}]},{"entry":["MVKVRLU .(SB) s1(U32), s2(R5), s3(R5)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKVRLU_40b_267 (U16 &s1, Vunit &s2, Vreg &s3)","VUNIT\/VREG,"]},{"entry":["{","LOW HALF"]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1.clear( );",{}]},{"entry":["\u2003r1 = _unsigned(s1);",{}]},{"entry":["\u2003risc_is_mtvvr._assert(1);",{}]},{"entry":["\u2003vec_regf_ua._assert(s2);",{}]},{"entry":["\u2003vec_regf_enz._assert(0);",{}]},{"entry":["\u2003vec_regf_wa._assert(s3);",{}]},{"entry":["\u2003vec_regf_wd._assert(r1);",{}]},{"entry":["\u2003vec_regf_hwz._assert(0x0); \/\/active low, both halves",{}]},{"entry":["}",{}]},{"entry":["NOP .(SA,SB)","NO OPERATION"]},{"entry":["void ISA::OPC_NOP_20b_17 (void)",{}]},{"entry":["{",{}]},{"entry":["}",{}]},{"entry":["NOT .(SA,SB) s1(R4)","BITWISE"]},{"entry":["void ISA::OPC_NOT_20b_8 (Gpr &s1,Unit &unit)","INVERSION"]},{"entry":["{",{}]},{"entry":["\u2003s1 = ~s1;",{}]},{"entry":["\u2003Csr.setBit(EQ,unit,s1.zero( ));",{}]},{"entry":["}",{}]},{"entry":["OR .(SA,SB) s1(R4), s2(R4)","BITWISE OR"]},{"entry":["void ISA::OPC_OR_20b_90 (Gpr &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2003s2 |= s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["OR .(SA,SB) s1(U4), s2(R4)","BITWISE OR, U4"]},{"entry":["void ISA::OPC_OR_20b_91 (U4 &s1,Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2003s2 |= s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["OR .(SB) s1(S3), s2(U20), s3(R4)","BITWISE OR, U20"]},{"entry":["void ISA::OPC_OR_40b_214 (U3 &s1, U20 &s2, Gpr &s3,Unit &unit)","IMM, BYTE"]},{"entry":["{","ALIGNED"]},{"entry":["\u2003s3 |= (s2 << (s1*8));",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["OUTPUT .(SB) *+s1[s2(R4)], s3(S8), s4(U6), s5(R4)","OUTPUT, 5"]},{"entry":["void ISA::OPC_OUTPUT_40b_238 (Gpr &s1,Gpr &s2,S8 &s3,U6 &s4,","operand"]},{"entry":["Gpr &s5)",{}]},{"entry":["{",{}]},{"entry":["\u2003int imm_cnst = s3.value( );",{}]},{"entry":["\u2003int bot_off = s2.range(0,3);",{}]},{"entry":["\u2003int top_off = s2.range(4,7);",{}]},{"entry":["\u2003int blk_size = s2.range(8,10);",{}]},{"entry":["\u2003int str_dis = s2.bit(12);",{}]},{"entry":["\u2003int repeat\u2003= s2.bit(13);",{}]},{"entry":["\u2003int bot_flag = s2.bit(14);",{}]},{"entry":["\u2003int top_flag = s2.bit(15);",{}]},{"entry":["\u2003int pntr\u2003\u2003= s2.range(16,23);",{}]},{"entry":["\u2003int size\u2003\u2003= s2.range(24,31);",{}]},{"entry":["\u2003int tmp,addr;",{}]},{"entry":["\u2003if(imm_cnst > 0 && bot_flag && imm_cnst > bot_off)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003if(!repeat)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003tmp = (bot_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003\u2003else",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003tmp = bot_off;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003if(imm_cnst < 0 && top_flag && \u2212imm_cnst > top_off)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003if(!repeat)",{}]},{"entry":["\u2003\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003\u2003tmp = \u2212(top_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003\u2003\u2003}",{}]},{"entry":["\u2003\u2003\u2003else",{}]},{"entry":["\u2003\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003\u2003tmp = \u2212top_off;",{}]},{"entry":["\u2003\u2003\u2003}",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003\u2003else",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003tmp = imm_cnst;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003pntr = pntr << blk_size;",{}]},{"entry":["\u2003if(size == 0)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003addr = pntr + tmp;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003if((pntr + tmp) >= size)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003addr = pntr + tmp \u2212 size;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003\u2003else",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003if(pntr + tmp < 0)",{}]},{"entry":["\u2003\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003\u2003addr = pntr + tmp + size;",{}]},{"entry":["\u2003\u2003\u2003}",{}]},{"entry":["\u2003\u2003\u2003else",{}]},{"entry":["\u2003\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003\u2003addr = pntr + tmp;",{}]},{"entry":["\u2003\u2003\u2003}",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003addr = addr + s1.value( );",{}]},{"entry":["\u2003risc_is_output._assert(1);",{}]},{"entry":["\u2003risc_output_wd._assert(s5);",{}]},{"entry":["\u2003risc_output_wa._assert(addr);",{}]},{"entry":["\u2003risc_output_pa._assert(s4);",{}]},{"entry":["\u2003risc_output_sd._assert(str_dis);",{}]},{"entry":["}",{}]},{"entry":["OUTPUT .(SB) *+s1[s2(S14)], s3(U6), s4(R4)","OUTPUT, 4"]},{"entry":["void ISA::OPC_OUTPUT_40b_239 (Gpr &s1,S14 &s2,U6 &s3,Gpr &s4)","operand"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s1 + s2;",{}]},{"entry":["\u2003risc_is_output._assert(1);",{}]},{"entry":["\u2003risc_output_wd._assert(s4);",{}]},{"entry":["\u2003risc_output_wa._assert(r1);",{}]},{"entry":["\u2003risc_output_pa._assert(s3);",{}]},{"entry":["\u2003risc_output_sd._assert(s1.bit(12));",{}]},{"entry":["}",{}]},{"entry":["OUTPUT .(SB) *s1(U18), s2(U6), s3(R4)","OUTPUT, 3"]},{"entry":["void ISA::OPC_OUTPUT_40b_240 (S18 &s1,U6 &s2,Gpr &s3)","operand"]},{"entry":["{",{}]},{"entry":["\u2003risc_is_output._assert(1);",{}]},{"entry":["\u2003risc_output_wd._assert(s3);",{}]},{"entry":["\u2003risc_output_wa._assert(s1);",{}]},{"entry":["\u2003risc_output_pa._assert(s2);",{}]},{"entry":["\u2003risc_output_sd._assert(0);",{}]},{"entry":["}",{}]},{"entry":["PACKHH (.SA,.SB) s1(R4, s2(R4)","PACK REGISTER,"]},{"entry":["void ISA::OPC_PACKHH_20b_372 (Gpr &s1, Gpr &s2)","HIGH\/HIGH"]},{"entry":["{",{}]},{"entry":["\u2003s2 = (s1.range(16,31) << 16) | s2.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["PACKHL (.SA,.SB) s1(R4, s2(R4)","PACK REGISTER,"]},{"entry":["void ISA::OPC_PACKHL_20b_371 (Gpr &s1, Gpr &s2)","HIGH\/LOW"]},{"entry":["{",{}]},{"entry":["\u2003s2 = (s1.range(16,31) << 16) | s2.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["PACKLH (.SA,.SB) s1(R4, s2(R4)","PACK REGISTER,"]},{"entry":["void ISA::OPC_PACKLH_20b_370 (Gpr &s1, Gpr &s2)","LOW\/HIGH"]},{"entry":["{",{}]},{"entry":["\u2003s2 = (s1.range(0,15) << 16) | s2.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["PACKLL (.SA,.SB) s1(R4, s2(R4)","PACK REGISTER,"]},{"entry":["void ISA::OPC_PACKLL_20b_369 (Gpr &s1, Gpr &s2)","LOW\/LOW"]},{"entry":["{",{}]},{"entry":["\u2003s2 = (s1.range(0,15) << 16) | s2.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["RELINP .(SA,SB)","Release Input"]},{"entry":["void ISA::OPC_RELINP_20b_18 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2003risc_is_release._assert(1);",{}]},{"entry":["}",{}]},{"entry":["REORD .(SA,SB) s1(U5), s2(R4)","REORDER WORD"]},{"entry":["void ISA::OPC_REORD_20b_330 (U5 &s1, Gpr &s2)",{}]},{"entry":["{",{}]},{"entry":["\u2003\/\/ U5 is used to reorder the bytes in",{}]},{"entry":["\u2003\/\/ s2 in one of the 24 possible combinations",{}]},{"entry":["\u2003\/\/",{}]},{"entry":["\u2003\/\/ Macros and functions are defined to",{}]},{"entry":["\u2003\/\/ reduce the amount of text is in this",{}]},{"entry":["\u2003\/\/ p-code",{}]},{"entry":["\u2003\/\/",{}]},{"entry":["\u2003\/\/RORD is a macro function defined as",{}]},{"entry":["\u2003\/\/ RORD(w,x,y,z) {",{}]},{"entry":["\u2003\/\/\u2003s2.range(0 ,7) = w;",{}]},{"entry":["\u2003\/\/\u2003s2.range(8 ,15) = x;",{}]},{"entry":["\u2003\/\/\u2003s2.range(16,23) = y;",{}]},{"entry":["\u2003\/\/\u2003s2.range(24,31) = z;",{}]},{"entry":["\u2003\/\/ }",{}]},{"entry":["\u2003\/\/",{}]},{"entry":["\u2003\/\/RO_A-D are macros defined as",{}]},{"entry":["\u2003\/\/\u2003RO_A => s2.range(0,7)",{}]},{"entry":["\u2003\/\/\u2003RO_B => s2.range(8,15)",{}]},{"entry":["\u2003\/\/\u2003RO_C => s2.range(16,23)",{}]},{"entry":["\u2003\/\/\u2003RO_D => s2.range(24,31)",{}]},{"entry":["#define RORD(w,x,y,z) { \\",{}]},{"entry":["\u2003\u2003s2.range(0 ,7) = w; \\",{}]},{"entry":["\u2003\u2003s2.range(8 ,15) = x; \\",{}]},{"entry":["\u2003\u2003s2.range(16,23) = y; \\",{}]},{"entry":["\u2003\u2003s2.range(24,31) = z; \\",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003int sw = s1.value( );",{}]},{"entry":["\u2003switch(sw)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003case 0x01: RORD(RO_A,RO_B,RO_D,RO_C); break;",{}]},{"entry":["\u2003\u2003case 0x02: RORD(RO_A,RO_C,RO_B,RO_D); break;",{}]},{"entry":["\u2003\u2003case 0x03: RORD(RO_A,RO_C,RO_D,RO_B); break;",{}]},{"entry":["\u2003\u2003case 0x04: RORD(RO_A,RO_D,RO_B,RO_C); break;",{}]},{"entry":["\u2003\u2003case 0x05: RORD(RO_A,RO_D,RO_C,RO_B); break;",{}]},{"entry":["\u2003\u2003case 0x06: RORD(RO_B,RO_A,RO_C,RO_D); break;",{}]},{"entry":["\u2003\u2003case 0x07: RORD(RO_B,RO_A,RO_D,RO_C); break;",{}]},{"entry":["\u2003\u2003case 0x08: RORD(RO_B,RO_C,RO_A,RO_D); break;",{}]},{"entry":["\u2003\u2003case 0x09: RORD(RO_B,RO_C,RO_D,RO_A); break;",{}]},{"entry":["\u2003\u2003case 0x0a: RORD(RO_B,RO_D,RO_A,RO_C); break;",{}]},{"entry":["\u2003\u2003case 0x0b: RORD(RO_B,RO_D,RO_C,RO_A); break;",{}]},{"entry":["\u2003\u2003case 0x0c: RORD(RO_C,RO_A,RO_B,RO_D); break;",{}]},{"entry":["\u2003\u2003case 0x0d: RORD(RO_C,RO_A,RO_D,RO_B); break;",{}]},{"entry":["\u2003\u2003case 0x0e: RORD(RO_C,RO_B,RO_A,RO_D); break;",{}]},{"entry":["\u2003\u2003case 0x0f: RORD(RO_C,RO_B,RO_D,RO_A); break;",{}]},{"entry":["\u2003\u2003case 0x10: RORD(RO_C,RO_D,RO_A,RO_B); break;",{}]},{"entry":["\u2003\u2003case 0x11: RORD(RO_C,RO_D,RO_B,RO_A); break;",{}]},{"entry":["\u2003\u2003case 0x12: RORD(RO_D,RO_A,RO_B,RO_C); break;",{}]},{"entry":["\u2003\u2003case 0x13: RORD(RO_D,RO_A,RO_C,RO_B); break;",{}]},{"entry":["\u2003\u2003case 0x14: RORD(RO_D,RO_B,RO_A,RO_C); break;",{}]},{"entry":["\u2003\u2003case 0x15: RORD(RO_D,RO_B,RO_C,RO_A); break;",{}]},{"entry":["\u2003\u2003case 0x16: RORD(RO_D,RO_C,RO_A,RO_B); break;",{}]},{"entry":["\u2003\u2003case 0x17: RORD(RO_D,RO_C,RO_B,RO_A); break;",{}]},{"entry":["\u2003}",{}]},{"entry":["}",{}]},{"entry":["RET .(SB)","RETURN FROM"]},{"entry":["void ISA::OPC_RET_20b_15 (void)","SUBROUTINE"]},{"entry":["{",{}]},{"entry":["\u2003Sp +=4;",{}]},{"entry":["\u2003Pc = dmem->read(Sp);",{}]},{"entry":["}",{}]},{"entry":["REV .(SB) s1(U6), s2(U6), s3(R4)","REVERSE BIT"]},{"entry":["void ISA::OPC_REV_40b_283 (U6 &s1, U6 &s2,Gpr &s3,Unit &unit)","FIELD"]},{"entry":["{",{}]},{"entry":["\u2003Reg tmp = s3;",{}]},{"entry":["\u2003int j = s2.value( );",{}]},{"entry":["\u2003for(int i=s1.value( );i<=s2.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003s3.bit(j\u2212\u2212) = tmp.bit(i);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["REVB .(SA,SB) s1(U2), s2(U2), s3(R4)","REVERSE BITS"]},{"entry":["void ISA::OPC_REVB_20b_92 (U2 &s1, U2 &s2,Gpr &s3,Unit &unit)","WITHIN BYTE"]},{"entry":["{","FIELD"]},{"entry":["\u2003int istart = s1.value( ) *8;",{}]},{"entry":["\u2003int iend = (s2.value( )+1)*8;",{}]},{"entry":["\u2003int j = iend\u22121;",{}]},{"entry":["\u2003Reg tmp = s3;",{}]},{"entry":["\u2003for(int i=istart;i<iend;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003s3.bit(j\u2212\u2212) = tmp.bit(i);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["ROT .(SA,SB) s1(R4), s2(R4)","ROTATE"]},{"entry":["void ISA::OPC_ROT_20b_93 (Gpr &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003int bit = s2.bit(0);",{}]},{"entry":["\u2003\u2003unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003\u2003s2 = (bit<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ROT .(SA,SB) s1(U4), s2(R4)","ROTATE, U4 IMM"]},{"entry":["void ISA::OPC_ROT_20b_94 (U4 &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003int bit = s2.bit(0);",{}]},{"entry":["\u2003\u2003unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003\u2003s2 = (bit<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ROTC .(SA,SB) s1(R4), s2(R4)","ROTATE THRU"]},{"entry":["void ISA::OPC_ROTC_20b_95 (Gpr &s1, Gpr &s2,Unit &unit)","CARRY"]},{"entry":["{",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003int bit = s2.bit(0);",{}]},{"entry":["\u2003\u2003unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003\u2003s2 = (Csr.bit(C,unit)<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003\u2003Csr.bit(C,unit) = bit;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ROTC .(SA,SB) s1(U4), s2(R4)","ROTATE THRU"]},{"entry":["void ISA::OPC_ROTC_20b_96 (U4 &s1, Gpr &s2,Unit &unit)","CARRY, U4 IMM"]},{"entry":["{",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003int bit = s2.bit(0);",{}]},{"entry":["\u2003\u2003unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003\u2003s2 = (Csr.bit(C,unit)<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003\u2003Csr.bit(C,unit) = bit;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["RSUB .(SA,SB) s1(U4), s2(R4)","REVERSE"]},{"entry":["void ISA::OPC_RSUB_20b_125 (U4 &s1, Gpr &s2,Unit &unit)","SUBTRACT"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s1 \u2212 s2;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SADD .(SA,SB) s1(R4), s2(R4)","SATURATING"]},{"entry":["void ISA::OPC_SADD_20b_127 (Gpr &s1, Gpr &s2,Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 + s1;",{}]},{"entry":["\u2003if(r1.overflow( ))\u2003\u2003s2 = 0xFFFFFFFF;",{}]},{"entry":["\u2003else if(r1.underflow( )) s2 = 0;",{}]},{"entry":["\u2003else\u2003\u2003\u2003\u2003\u2003\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2003Csr.bit(EQ, unit) = s2.zero( );",{}]},{"entry":["\u2003Csr.bit(SAT,unit) = r1.overflow( ) | r1.underflow( );",{}]},{"entry":["}",{}]},{"entry":["SETB .(SA,SB) s1(U2), s2(U2), s3(R4)","SET BYTE FIELD"]},{"entry":["void ISA::OPC_SETB_20b_97 (U2 &s1,U2 &s2,Gpr &s3,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2003s3.range(s1*8,((s2+1)*8)\u22121) = 1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["SEXT .(SA,SB) s1(U3), s2(R4)","SIGN EXTEND"]},{"entry":["void ISA::OPC_SEXT_20b_79 (U3 &s1, Gpr &s2)",{}]},{"entry":["{",{}]},{"entry":["\u2003switch(s1.value( ))",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003case 0: s2 = sign_extend(s2.range(0,7));",{}]},{"entry":["\u2003\u2003case 1: s2 = sign_extend(s2.range(0,15));",{}]},{"entry":["\u2003\u2003case 2: s2 = sign_extend(s2.range(0,23));",{}]},{"entry":["\u2003\u2003case 3: s2 = s2.undefined(true); \/\/future expansion",{}]},{"entry":["\u2003}",{}]},{"entry":["}",{}]},{"entry":["SHL .(SA,SB) s1(R4), s2(R4)","SHIFT LEFT"]},{"entry":["void ISA::OPC_SHL_20b_98 (Gpr &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2003s2 = s2 << s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHL .(SA,SB) s1(U4), s2(R4)","SHIFT LEFT, U4"]},{"entry":["void ISA::OPC_SHL_20b_99 (U4 &s1,Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2003s2 = s2 << s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHR .(SA,SB) s1(R4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPC_SHR_20b_102 (Gpr &s1, Gpr &s2,Unit &unit)","SIGNED"]},{"entry":["{",{}]},{"entry":["\u2003s2 = s2 >> s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHR .(SA,SB) s1(U4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPC_SHR_20b_103 (U4 &s1, Gpr &s2,Unit &unit)","SIGNED, U4 IMM"]},{"entry":["{",{}]},{"entry":["\u2003s2 = s2 >> s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHRU .(SA,SB) s1(R4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPC_SHRU_20b_100 (Gpr &s1, Gpr &s2,Unit &unit)","UNSIGNED"]},{"entry":["{",{}]},{"entry":["\u2003s2 = (_unsigned(s2)) >> s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHRU .(SA,SB) s1(U4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPC_SHRU_20b_101 (U4 &s1, Gpr &s2,Unit &unit)","UNSIGNED, U4"]},{"entry":["{","IMM"]},{"entry":["\u2003s2 = (_unsigned(s2)) >> s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SSUB .(SA,SB) s1(R4), s2(R4)","SATURATING"]},{"entry":["void ISA::OPC_SSUB_20b_128 (Gpr &s1, Gpr &s2,Unit &unit)","SUBTRACTION"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 \u2212 s1;",{}]},{"entry":["\u2003if(r1 > 0xFFFFFFFF) s2 = 0xFFFFFFFF;",{}]},{"entry":["\u2003else if(r1 < 0)\u2003\u2003s2 = 0;",{}]},{"entry":["\u2003else\u2003\u2003\u2003\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2003Csr.bit(EQ, unit) = s2.zero( );",{}]},{"entry":["\u2003Csr.bit(SAT,unit) = r1.overflow( ) | r1.underflow( );",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+SBR[s1(U4)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_26 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003\u2003dmem->byte(Sbr+s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+SBR[s1(R4)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_29 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2003dmem->byte(Sbr+s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *SBR++[s1(U4)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_32 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2003dmem->byte(Sbr) = s2.byte(0);",{}]},{"entry":["\u2003Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *SBR++[s1(R4)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_35 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003dmem->byte(Sbr) = s2.byte(0);","ADJ"]},{"entry":["\u2003Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+s1(R4), s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_38 (Gpr &s1, Gpr &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->byte(s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *s1(R4)++, s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_41 (Gpr &s1, Gpr &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2003dmem->byte(s1) = s2.byte(0);",{}]},{"entry":["\u2003++s1;",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+s1[s2(U20)], s3(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_40b_170 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->byte(s1+s2) = s3.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *s1++[s2(U20)], s3(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_40b_173 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2003dmem->byte(s1) = s3.byte(0);",{}]},{"entry":["\u2003s1 += s2;",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+SBR[s1(U24)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_40b_176 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003dmem->byte(Sbr+s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *SBR++[s1(U24)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_40b_179 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["dmem->byte(Sbr) = s2.byte(0);","ADJ"]},{"entry":["\u2003Sbr += s1;",{}]},{"entry":["\u2003}",{}]},{"entry":["STB .(SB) *s1(U24),s2(R4)","STORE BYTE, U24"]},{"entry":["void ISA::OPC_STB_40b_182 (U24 &s1, Gpr &s2)","IMM ADDRESS"]},{"entry":["{",{}]},{"entry":["\u2003dmem->byte(s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+SP[s1(U24)], s2(R4)","STORE BYTE, SP,"]},{"entry":["void ISA::OPC_STB_40b_252 (U24 &s1,Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->byte(Sp+s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+SBR[s1(U4)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_27 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->half(Sbr+(s1<<1)) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+SBR[s1(R4)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_30 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2003dmem->half(Sbr+(s1<<1)) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *SBR++[s1(U4)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_33 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2003dmem->half(Sbr) = s2.half(0);",{}]},{"entry":["\u2003Sbr += (s1<<1);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *SBR++[s1(R4)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_36 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003dmem->half(Sbr) = s2.half(0);","ADJ"]},{"entry":["\u2003Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+s1(R4), s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_39 (Gpr &s1, Gpr &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->half(s1) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *s1(R4)++, s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_42 (Gpr &s1, Gpr &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2003dmem->half(s1) = s2.half(0);",{}]},{"entry":["\u2003s1 += 2;",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+s1[s2(U20)], s3(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_40b_171 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->half(s1+(s2<<1)) = s3.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *s1++[s2(U20)], s3(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_40b_174 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2003dmem->half(s1) = s3.half(0);",{}]},{"entry":["\u2003s1 += s2<<1;",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+SBR[s1(U24)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_40b_177 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003dmem->half(Sbr+(s1<<1)) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *SBR++[s1(U24)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_40b_180 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003dmem->half(Sbr) = s2.half(0);","ADJ"]},{"entry":["\u2003Sbr += 2;",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *s1(U24),s2(R4)","STORE HALF, U24"]},{"entry":["void ISA::OPC_STH_40b_183 (U24 &s1, Gpr &s2)","IMM ADDRESS"]},{"entry":["{",{}]},{"entry":["\u2003dmem->half(s1<<1) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+SP[s1(U24)], s2(R4)","STORE HALF, SP,"]},{"entry":["void ISA::OPC_STH_40b_253 (U24 &s1, Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->half(Sp+(s1<<1)) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STRF .SB s1(R4), s2(R4)","STORE REGISTER"]},{"entry":["void ISA::OPC_STRF_20b_81 (Gpr &s1, Gpr &s2)","FILE RANGE"]},{"entry":["{",{}]},{"entry":["\u2003if(s1 >= s2)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2003for(int r=s2.address( );r<s1.address( );++r)",{}]},{"entry":["\u2003\u2003{",{}]},{"entry":["\u2003\u2003\u2003dmem->write(Sp,r);",{}]},{"entry":["\u2003\u2003\u2003Sp \u2212= 4;",{}]},{"entry":["\u2003\u2003}",{}]},{"entry":["\u2003}",{}]},{"entry":["}",{}]},{"entry":["STSYS .(SB) s1(R4), s2(R4)","STORE SYSTEM"]},{"entry":["void ISA::OPC_STSYS_20b_163 (Gpr &s1, Gpr &s2)","ATTRIBUTE"]},{"entry":["{","(GLS)"]},{"entry":["\u2003gls_is_load._assert(0);",{}]},{"entry":["\u2003gls_attr_valid._assert(1);",{}]},{"entry":["\u2003gls_is_stsys._assert(1);",{}]},{"entry":["\u2003gls_regf_addr._assert(s2.address( )); \/\/reg addr of s2",{}]},{"entry":["\u2003gls_sys_addr._assert(s1); \/\/contents of s1",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+SBR[s1(U4)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_28 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->word(Sbr+(s1<<2)) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+SBR[s1(R4)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_31 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2003dmem->word(Sbr+(s1<<2)) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *SBR++[s1(U4)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_34 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2003dmem->word(Sbr) = s2.word( );",{}]},{"entry":["\u2003Sbr += (s1<<2);",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *SBR++[s1(R4)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_37 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003dmem->word(Sbr) = s2.word( );","ADJ"]},{"entry":["\u2003Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+s1(R4), s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_40 (Gpr &s1, Gpr &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->word(s1) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *s1(R4)++, s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_43 (Gpr &s1, Gpr &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2003dmem->word(s1) = s2.word( );",{}]},{"entry":["\u2003s1 += 4;",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+s1[s2(U20)], s3(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_172 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->word(s1+(s2<<2)) = s3.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *s1++[s2(U20)], s3(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_175 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2003dmem->word(s1) = s3.word( );",{}]},{"entry":["\u2003s1 += s2<<2;",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+SBR[s1(U24)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_178 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2003dmem->word(Sbr+(s1<<2)) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *SBR++[s1(U24)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_181 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2003dmem->word(Sbr) = s2.word( );","ADJ"]},{"entry":["\u2003Sbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *s1(U24),s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_184 (U24 &s1, Gpr &s2)","U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2003dmem->word(s1<<2) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+SP[s1(U24)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_254 (U24 &s1,Gpr &s2)","SP, +U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->word(Sp+(s1<<2)) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["SUB .(SA,SB) s1(R4), s2(R4)","SUBTRACT"]},{"entry":["void ISA::OPC_SUB_20b_113 (Gpr &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 \u2212 s1;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SUB .(SA,SB) s1(U4), s2(R4)","SUBTRACT, U4"]},{"entry":["void ISA::OPC_SUB_20b_114 (U4 &s1, Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 \u2212 s1;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SUB .(SB) s1(U28),SP(R5)","SUBTRACT, SP,"]},{"entry":["void ISA::OPC_SUB_40b_231 (U28 &s1)","U28 IMM"]},{"entry":["{",{}]},{"entry":["\u2003Sp \u2212= s1;",{}]},{"entry":["}",{}]},{"entry":["SUB .(SB) s1(U24), SP(R5), s3(R4)","SUBTRACT, SP,"]},{"entry":["void ISA::OPC_SUB_40b_232 (U24 &s1, Gpr &s3)","U24 IMM, REG"]},{"entry":["{","DEST"]},{"entry":["\u2003s3 = Sp\u2212s1;",{}]},{"entry":["}",{}]},{"entry":["SUB .(SB) s1(U24),s2(R4)","SUBTRACT, U24"]},{"entry":["void ISA::OPC_SUB_40b_233 (U24 &s1,Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 \u2212 s1;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["\u2003Csr.bit( C,unit) = r1.carryout( );",{}]},{"entry":["}",{}]},{"entry":["SUB2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_SUB2_20b_367 (Gpr &s1, Gpr &s2)","SUBTRACTION"]},{"entry":["{","WITH DIVIDE BY 2"]},{"entry":["\u2003s2.range(0,15) =",{}]},{"entry":["\u2003\u2003(s2.range(0,15) \u2212 s1.range(0,15)) >> 1;",{}]},{"entry":["\u2003s2.range(16,31) =",{}]},{"entry":["\u2003\u2003(s2.range(16,31) \u2212 s1.range(16,31)) >> 1;",{}]},{"entry":["}",{}]},{"entry":["SUB2 .(SA,SB) s1(U4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_SUB2_20b_368 (U4 &s1, Gpr &s2)","SUBTRACTION"]},{"entry":["{","WITH DIVIDE BY 2"]},{"entry":["\u2003s2.range(0,15) = (s2.range(0,15) \u2212 s1.value( )) >> 1;",{}]},{"entry":["\u2003s2.range(16,31) = (s2.range(16,31) \u2212 s1.value( )) >> 1;",{}]},{"entry":["}",{}]},{"entry":["SWAP .(SA,SB) s1(R4), s2(R4)","SWAP"]},{"entry":["void ISA::OPC_SWAP_20b_146 (Gpr &s1, Gpr &s2)","REGISTERS"]},{"entry":["{",{}]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp = s1;",{}]},{"entry":["\u2003s1\u2002= s2;",{}]},{"entry":["\u2003s2\u2002= tmp;",{}]},{"entry":["}",{}]},{"entry":["SWAPBR .(SA,SB)","SWAP LBR and"]},{"entry":["void ISA::OPC_SWAPBR_20b_11 (void)","SBR"]},{"entry":["{",{}]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp = Lbr;",{}]},{"entry":["\u2003Lbr = Sbr;",{}]},{"entry":["\u2003Sbr = tmp;",{}]},{"entry":["}",{}]},{"entry":["SWIZ .(SA,SB) s1(R4), s2(R4)","SWIZZLE,"]},{"entry":["void ISA::OPC_SWIZ_20b_44 (Gpr &s1, Gpr &s2)","ENDIAN"]},{"entry":["{","CONVERSION"]},{"entry":["\u2003\/\/This should be defined as a p-op, it overlaps",{}]},{"entry":["\u2003\/\/one form of REORD",{}]},{"entry":["\u2003s2.range(0,7) = s1.range(24,31);",{}]},{"entry":["\u2003s2.range(8,15) = s1.range(16,23);",{}]},{"entry":["\u2003s2.range(16,23) = s1.range(8,15);",{}]},{"entry":["\u2003s2.range(24,31) = s1.range(0,7);",{}]},{"entry":["}",{}]},{"entry":["TASKSW .(SA,SB)","TASK SWITCH"]},{"entry":["void ISA::OPC_TASKSW_20b_19 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2003risc_is_task_sw._assert(1);",{}]},{"entry":["}",{}]},{"entry":["TASKSWTOE .(SA,SB) s1(U2)","TASK SWITCH"]},{"entry":["void ISA::OPC_TASKSWTOE_20b_126 (U2 &s1)","TEST OUTPUT"]},{"entry":["{","ENABLE"]},{"entry":["\u2003risc_is_taskswtoe._assert(1);",{}]},{"entry":["\u2003risc_is_taskswtoe_opr._assert(s1);",{}]},{"entry":["}",{}]},{"entry":["VIDX .SB s1(R4), s2(S8), s3(R4)","VERTICAL INDEX"]},{"entry":[{},"CALCULATION"]},{"entry":["VINPUT (SB) *+s1(R4)[s2(R4)], s3(R4), s4(R4)","VINPUT, 4"]},{"entry":["void ISA::OPC_VINPUT_40b_244 (Gpr &s1, Gpr &s2, Gpr &s3)","OPERAND,"]},{"entry":["{","REGISTER FORM"]},{"entry":["\u2003gls_is_vinput._assert(1);",{}]},{"entry":["\u2003Result r1 = s1+s2;",{}]},{"entry":["\u2003gls_sys_addr._assert(r1.value( ));",{}]},{"entry":["\u2003gls_vreg._assert(s3.address( ));",{}]},{"entry":["}",{}]},{"entry":["VINPUT .SB *+s1(R4)[s2(U16)], s3(R4), s4(R4)","VINPUT, 4"]},{"entry":["void ISA::OPC_VINPUT_40b_245 (Gpr &s1, U16 &s2, Gpr &s3, Vreg","OPERAND,"]},{"entry":["&s4)","IMMEDIATE"]},{"entry":["{","FORM"]},{"entry":["\u2003\/\/S1 is base address",{}]},{"entry":["\u2003\/\/S2 is address offset",{}]},{"entry":["\u2003\/\/S3 is vertical index parameter",{}]},{"entry":["\u2003\/\/S4 is virtual register",{}]},{"entry":["\u2003Result r1 = _unsigned(s1)+_unsigned(s2);",{}]},{"entry":["\u2003risc_is_vinput._assert(1); \/\/instruction flag",{}]},{"entry":["\u2003gls_sys_addr._assert(r1.value( )); \/\/calculated address",{}]},{"entry":["\u2003risc_vip_size._assert(s3.range(0,7)); \/\/size field from VIP",{}]},{"entry":["\u2003risc_vip_valid._assert(1); \/\/size field valid",{}]},{"entry":["\u2003gls_vreg._assert(s3.address( )); \/\/virtual register address",{}]},{"entry":["}",{}]},{"entry":["VOUTPUT .SB *+s1(R4)[s2(S10)], s3(R4), s4(U6), s5(R4)","VOUTPUT, 5"]},{"entry":["void ISA::OPC_VOUTPUT_40b_235 (Gpr &s1,S10 &s2,Gpr &s3,U6 &","operand"]},{"entry":["s4,Vreg &s5)",{}]},{"entry":["{",{}]},{"entry":["\u2003\/\/s1 is the \u2018base\u2019 address",{}]},{"entry":["\u2003\/\/s2 is the \u2018offset\u2019 address",{}]},{"entry":["\u2003\/\/s3 is the vertical index parameter register",{}]},{"entry":["\u2003int buffer_size =\u2002s3.range(8,15);",{}]},{"entry":["\u2003int store_disable = s3.bit(27);",{}]},{"entry":["\u2003int pointer =\u2003\u2003s3.range(16,23);",{}]},{"entry":["\u2003\/\/hg_size aka Block_Width",{}]},{"entry":["\u2003int hg_size =\u2003\u2003s3.range( 0, 7);",{}]},{"entry":["\u2003int imm_cnst =\u2003\u2003sign_extend(s2.value( ));",{}]},{"entry":["\u2003int addr = pointer + imm_cnst;",{}]},{"entry":["\u2003if(addr >= buffer_size) addr \u2212= buffer size;",{}]},{"entry":["\u2003else if(addr < 0)\u2003\u2003addr += buffer_size;",{}]},{"entry":["\u2003bool has_mul_shft = s4.bit(4); \/\/MSB of the data_type from U6 operand",{}]},{"entry":["\u2003if(has_mul_shft) addr = (addr*hg_size)<<5;",{}]},{"entry":["\u2003addr = addr + s1.value( );",{}]},{"entry":["\u2003risc_is_voutput._assert(1); \/\/instruction flag",{}]},{"entry":["\u2003risc_output_vra._assert(s5.address( )); \/\/virtual register address",{}]},{"entry":["\u2003risc_output_wa._assert(addr); \/\/calculated cir address",{}]},{"entry":["\u2003risc_output_pa._assert(s4); \/\/\u2018pixel\u2019 address",{}]},{"entry":["\u2003risc_vip_size._assert(s3.range(0,7)); \/\/size field from VIP",{}]},{"entry":["\u2003risc_vip_valid._assert(1); \/\/size field valid",{}]},{"entry":["\u2003risc_store_disable._assert(store_disable); \/\/store disable",{}]},{"entry":["\u2003bool sfm_block = (s3.range(28,29) == SFM_BLK);",{}]},{"entry":["\u2003bool buf_eq_pntr = (s3.range(16,23) == (s3.range(8,15)\u22121));",{}]},{"entry":["\u2003if(buf_eq_pntr && !sfm_block) risc_fill._assert(1);",{}]},{"entry":["\u2003else\u2003\u2003\u2003\u2003\u2003\u2003\u2003risc_fill._assert(0);",{}]},{"entry":["}",{}]},{"entry":["VOUTPUT .(SB) *+s1[s2(S14)], s3(U6), s4(R4)","VOUTPUT, 4"]},{"entry":["void ISA::OPC_VOUTPUT_40b_236 (Gpr &s1,S14 &s2,U6 &s3,Vreg4","operand"]},{"entry":["&s4)",{}]},{"entry":["{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s1 + s2;",{}]},{"entry":["\u2003risc_is_voutput._assert(1);",{}]},{"entry":["\u2003risc_output_wd._assert(s4);",{}]},{"entry":["\u2003risc_output_wa._assert(r1);",{}]},{"entry":["\u2003risc_output_pa._assert(s3);",{}]},{"entry":["\u2003risc_output_sd._assert(s1.bit(12));",{}]},{"entry":["}",{}]},{"entry":["VOUTPUT .(SB) *s1(U18), s2(U6), s3(R4)","VOUTPUT, 3"]},{"entry":["void ISA::OPC_VOUTPUT_40b_237 (S18 &s1,U6 &s2,Vreg4 &s3)","operand"]},{"entry":["{",{}]},{"entry":["\u2003risc_is_voutput._assert(1);",{}]},{"entry":["\u2003risc_output_wd._assert(s3);",{}]},{"entry":["\u2003risc_output_wa._assert(s1);",{}]},{"entry":["\u2003risc_output_pa._assert(s2);",{}]},{"entry":["\u2003risc_output_sd._assert(0);",{}]},{"entry":["}",{}]},{"entry":["XOR .(SA,SB) s1(R4), s2(R4)","BITWISE"]},{"entry":["void ISA::OPC_XOR_20b_104 (Gpr &s1, Gpr &s2,Unit &unit)","EXCLUSIVE OR"]},{"entry":["{",{}]},{"entry":["\u2003s2 {circumflex over (\u2009)}= s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["XOR .(SA,SB) s1(U4), s2(R4)","BITWISE"]},{"entry":["void ISA::OPC_XOR_20b_105 (U4 &s1, Gpr &s2,Unit &unit)","EXCLUSIVE OR,"]},{"entry":["{","U4 IMM"]},{"entry":["\u2003s2 {circumflex over (\u2009)}= s1;",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["XOR .(SB) s1(S3), s2(U20), s3(R4)","BITWISE"]},{"entry":["void ISA::OPC_XOR_40b_215 (U3 &s1, U20 &s2, Gpr &s3,Unit &unit)","EXCLUSIVE OR,"]},{"entry":["{","U20 IMM, BYTE"]},{"entry":["\u2003s3 {circumflex over (\u2009)}= (s2 << (s1*8));","ALIGNED"]},{"entry":["\u2003Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"A RISC processor with a vector processing module is generally used with shared function-memory . This RISC processor is largely the same as the RISC processor used for processor  but it includes a vector processing module to extend the computation and load\/store bandwidth. This module can contain 16 vector units that are each capable of executing a 4-operation execute packet per cycle. A typical execute packet generally includes a data load from the vector memory array, two register-to-register operations, and a result store to the vector memory array. This type of RISC processor generally uses an instruction word that is 80 bits wide or 120 bits wide, which generally constitutes a \u201cfetch packet\u201d and which may include unaligned instructions. A fetch packet can contain a mixture of 40 bit and 20 bit instructions, which can include vector unit instructions and scalar instructions similar to those used by processor . Typically, vector unit instructions can be 20 bits wide, while other instructions can be 20 bits or 40 bits wide (similar to processor ). Vector instructions can also be presented on all lanes of the instruction fetch bus, but, if the fetch packet contains both scalar and vector unit instructions the vector instructions are presented (for example) on instruction fetch bus bits [39:0] and the scalar instruction(s) are presented (for example) on instruction fetch bus bits [79:40]. Additionally, unused instruction fetch bus lanes are padded with NOPs.","An \u201cexecute packet\u201d can then be formed from one or more fetch packets. Partial execute packets are held in the instruction queue until completed. Typically, complete execute packets are submitted to the execute stage (i.e., ). Four vector unit instructions (for example), two scalar instructions (for example), or a combination of 20-bit and 40-bit instructions (for example) may execute in a single cycle. Back-to-back 20-bit instructions may also be executed serially. If bit  of the current 20 bit instruction is set, this indicates that the current instruction, and the subsequent 20-bit instruction form an execute packet. Bit  can be generally referred to as the P-bit or parallel bit. If the P-bit is not set this indicates the end of an execute packet. Back-to-back 20 bit instructions with the P-bit not set cause serial execution of the 20 bit instructions. It should also be noted that this RISC processor (with a vector processing module) may include any of the following constraints:\n\n","Turning to , an example of a vector module can be seen. The vector module includes a vector decoder , decode-to-execution unit , and an execution unit . The vector decoder includes slot decoders - to - that receive instructions from the instruction fetch . Typically, slot decoders - and - operate in a similar manner to one another, while slot decoders - and - include load\/store decoding circuitry. The decode-to-execution unit  can then generate instructions for the execution unit  based on the decoded output of vector decoder . Each of the slot decoders can generate instruction that can be used by the multiply unit , add\/subtract unit , move unit , and Boolean unit  (that each use data and addresses in the general purpose register ). Additionally slot decoders - and - can generate load and store instructions for load\/store units  and .","This RISC processor (which includes processor  and a vector module) can also be accessed through boundary pins; an example of each is described in Table 16 (with \u201cz\u201d denoting active low pins).",{"@attributes":{"id":"p-0860","num":"1106"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Pin Name","Width","Dir","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Context Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cmem_wdata","609","Output","Context memory write data"]},{"entry":["cmem_wdata_valid","1","Output","Context memory read data"]},{"entry":["cmem_rdy","1","Input","Context memory ready"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Data Memory Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["dmem_enz","1","Output","Data memory select"]},{"entry":["dmem_wrz","1","Output","Data memory write enable"]},{"entry":["dmem_bez","4","Output","Data memory write byte enables"]},{"entry":["dmem_addr","16","Output","Data memory address"]},{"entry":["dmem_addr_no_base","32","Output","Data memory address, prior to context base"]},{"entry":[{},{},{},"address adj."]},{"entry":["dmem_wdata","32","Output","Data memory write data"]},{"entry":["dmem_rdy","1","Input","Data memory ready"]},{"entry":["dmem_rdata","32","Input","Data memory read data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Instruction Memory Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["imem_enz","1","Output","Instruction memory select"]},{"entry":["imem_addr","16","Output","Instruction memory address"]},{"entry":["imem_rdy","1","Input","Instruction memory ready"]},{"entry":["imem_rdata","40","Input","Instruction memory read data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Program Control Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["force_pcz","1","Input","Program counter write enable"]},{"entry":["new_pc","17","Input","Program counter write data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Context Control Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["force_ctxz","1","Input","Force context write enable which:"]},{"entry":[{},{},{},"writes the value on new_ctx to the internal"]},{"entry":[{},{},{},"machine state; and"]},{"entry":[{},{},{},"schedules a context save."]},{"entry":["write_ctxz","1","Input","Write context enable which writes the value on"]},{"entry":[{},{},{},"new_ctx to the internal machine state."]},{"entry":["save_ctxz","1","Input","Save context enable which schedules a context"]},{"entry":[{},{},{},"save."]},{"entry":["new_ctx","592","Input","Context change write data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Context Base Address"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["ctx_base","11","Input","Context change write address"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Flag and Strapping Pins"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["risc_is_idle","1","Output","Asserted in decode stage 5308 when an IDLE"]},{"entry":[{},{},{},"instruction is decoded."]},{"entry":["risc_is_end","1","Output","Asserted in decode stage 5308 when an END"]},{"entry":[{},{},{},"instruction is decoded."]},{"entry":["risc_is_output","1","Output","Decode flag asserted in decode stage 5308 on"]},{"entry":[{},{},{},"decode of an OUTPUT instruction"]},{"entry":["risc_is_voutput","1","Output","Decode flag asserted in decode stage 5308 on"]},{"entry":[{},{},{},"decode of a VOUTPUT instruction"]},{"entry":["risc_is_vinput","1","Output","Decode flag asserted in decode stage 5308 on"]},{"entry":[{},{},{},"decode of a VINPUT instruction"]},{"entry":["risc_is_mtv","1","Output","Asserted in decode stage 5308 when an MTV"]},{"entry":[{},{},{},"instruction is decoded. (move to vector or SIMD"]},{"entry":[{},{},{},"register from processor 5200, with replicate)"]},{"entry":["risc_is_mtvvr","1","Output","Asserted in decode stage 5308 when an MTVVR"]},{"entry":[{},{},{},"instruction is decoded. (move to vector or SIMD"]},{"entry":[{},{},{},"register from processor 5200)"]},{"entry":["risc_is_mfvvr","1","Output","Asserted in decode stage 5308 when an MFVVR"]},{"entry":[{},{},{},"instruction is decoded (move from vector or SIMD"]},{"entry":[{},{},{},"register to processor 5200)"]},{"entry":["risc_is_mfvrc","1","Output","Asserted in decode stage 5308 when an MFVRC"]},{"entry":[{},{},{},"instruction is decoded."]},{"entry":[{},{},{},"(move to vector or SIMD register from processor"]},{"entry":[{},{},{},"5200, with collapse)"]},{"entry":["risc_is_mtvre","1","Output","Asserted in decode stage 5308 when an MTVRE"]},{"entry":[{},{},{},"instruction is decoded. (move to vector or SIMD"]},{"entry":[{},{},{},"register from processor 5200, with expand)"]},{"entry":["risc_is_release","1","Output","Asserted in decode stage 5308 when a RELINP"]},{"entry":[{},{},{},"(Release Input) instruction is decoded."]},{"entry":["risc_is_task_sw","1","Output","Asserted in decode stage 5308 when a TASKSW"]},{"entry":[{},{},{},"(Task Switch) instruction is decoded."]},{"entry":["risc_is_taskswtoe","1","Output","Asserted in decode stage 5308 when a"]},{"entry":[{},{},{},"TASKSWTOE instruction is decoded."]},{"entry":["risc_taskswtoe_opr","2","Output","Asserted in execution stage 5310 when a"]},{"entry":[{},{},{},"TASKSWTOE instruction is decoded. This bus"]},{"entry":[{},{},{},"contains the value of the U2 immediate operand."]},{"entry":["risc_mode","2","Input","Statically strapped input pins to define reset"]},{"entry":[{},{},{},"behavior."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Value","Behaviour"]},{"entry":[{},"00","Exiting reset causes processor 5200 to"]},{"entry":[{},{},"fetch instruction memory address zero"]},{"entry":[{},{},"and load this into the program counter"]},{"entry":[{},{},"5218"]},{"entry":[{},"01","Exiting reset causes processor 5200 to"]},{"entry":[{},{},"remain idle until the assertion of"]},{"entry":[{},{},"force pcz"]},{"entry":[{},"10\/11","Reserved"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["risc_estate0","1","Input","External state bit 0. This pin is directly mapped to"]},{"entry":[{},{},{},"bit 11 of the Control Status Register (described"]},{"entry":[{},{},{},"below)"]},{"entry":["wrp_terminate","1","Input","Termination message status flag sourced by"]},{"entry":[{},{},{},"external logic (typically the wrapper)"]},{"entry":[{},{},{},"This pin readable via the CSR."]},{"entry":["wrp_dst_output_en","8","Input","Asserted by the SFM wrapper to control OUTPUT"]},{"entry":[{},{},{},"instructions based on wrapper enabled dependency"]},{"entry":[{},{},{},"checking"]},{"entry":["risc_out_depchk_failed","1","Output","Flag asserted in D0 on failure of dependency"]},{"entry":[{},{},{},"checking during decode of an OUTPUT"]},{"entry":[{},{},{},"instruction."]},{"entry":[{},{},{},"See section Error! Reference source not found."]},{"entry":[{},{},{},"for a description."]},{"entry":["risc_vout_depchk_failed","1","Output","Flag asserted in D0 on failure of dependency"]},{"entry":[{},{},{},"checking during decode of a VOUTPUT"]},{"entry":[{},{},{},"instruction."]},{"entry":[{},{},{},"See section Error! Reference source not found."]},{"entry":[{},{},{},"for a description."]},{"entry":["risc_inp_depchk_failed","1","Output","Flag asserted in D0 on failure of dependency"]},{"entry":[{},{},{},"checking during decode of a VINPUT instruction."]},{"entry":["risc_fill","1","Output","Asserted in E1."]},{"entry":[{},{},{},"This is valid for the circular form of VOUTPUT"]},{"entry":[{},{},{},"(which is the 5 operand form of VOUTPUT)."]},{"entry":["risc_branch_valid","1","Output","Flag asserted in E0 when processing a branch"]},{"entry":[{},{},{},"instruction."]},{"entry":[{},{},{},"At present this flag does not assert for CALL and"]},{"entry":[{},{},{},"RET. This may change based on feedback from"]},{"entry":[{},{},{},"SDO."]},{"entry":["risc_branch_taken","1","Output","Flag asserted in E0 when a branch is taken."]},{"entry":[{},{},{},"At present this flag does not assert for CALL and"]},{"entry":[{},{},{},"RET. This may change based on feedback from"]},{"entry":[{},{},{},"SDO."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"OUTPUT Instruction Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["risc_output_wd","32","Output","Contents of the data register for an OUTPUT or"]},{"entry":[{},{},{},"VOUTPUT instruction. This is driven in execution"]},{"entry":[{},{},{},"stage 5310."]},{"entry":["risc_output_wa","16","Output","Contents of the address register for an OUTPUT or"]},{"entry":[{},{},{},"VOUTPUT instruction."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_output_disable","1","Output","Value of the SD (Store disable) bit of the circular"]},{"entry":[{},{},{},"addressing control register used in an OUTPUT or"]},{"entry":[{},{},{},"VOUTPUT instruction. See Section [00704] for a"]},{"entry":[{},{},{},"description of the circular addressing control"]},{"entry":[{},{},{},"register format."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_output_pa","6","Output","Value of the pixel address immediate constant of"]},{"entry":[{},{},{},"an OUTPUT instruction."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":[{},{},{},"(U6, below, is the 6 bit unsigned immediate value"]},{"entry":[{},{},{},"of an OUTPUT instruction)"]},{"entry":[{},{},{},"6\u2032b000000"]},{"entry":[{},{},{},"word store"]},{"entry":[{},{},{},"6\u2032b001100"]},{"entry":[{},{},{},"Store lower half word of U6 to lower"]},{"entry":[{},{},{},"center lane"]},{"entry":[{},{},{},"6\u2032b001110"]},{"entry":[{},{},{},"Store lower half word of U6 to upper"]},{"entry":[{},{},{},"center lane"]},{"entry":[{},{},{},"6\u2032b000011"]},{"entry":[{},{},{},"Store upper half word of U6 to upper"]},{"entry":[{},{},{},"center lane"]},{"entry":[{},{},{},"6\u2032b000111"]},{"entry":[{},{},{},"Store upper half word of U6 to lower"]},{"entry":[{},{},{},"center lane"]},{"entry":[{},{},{},"All other values are illegal and result in"]},{"entry":[{},{},{},"unspecified behavior"]},{"entry":["risc_output_vra","4","Output","The vector register address of the VOUTPUT"]},{"entry":[{},{},{},"instruction"]},{"entry":["risc_vip_size","8","Output","This is the driven by the lower 8 bits"]},{"entry":[{},{},{},"(Block_Width\/HG_SIZE) of Vertical Index"]},{"entry":[{},{},{},"Parameter register. The VIP is specified as an"]},{"entry":[{},{},{},"operand for some instructions. See Section [00704]"]},{"entry":[{},{},{},"for a description of the VIP."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"General Purpose Register to Vector\/SIMD Register Transfer Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["risc_vec_ua","5","Output","Vector (or SIMD) unit (aka \u2018lane\u2019) address for"]},{"entry":[{},{},{},"MTVVR and MFVVR instructions"]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_vec_wa","5","Output","For MTV, MTVRE and MTVVR instructions:"]},{"entry":[{},{},{},"Vector (or SIMD) register file write address."]},{"entry":[{},{},{},"For MFVVR and MFVRC instructions:"]},{"entry":[{},{},{},"Contains the address of the T20 GPR which is to"]},{"entry":[{},{},{},"receive the requested vector data."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_vec_wd","32","Output","Vector (or SIMD) register file write data."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_vec_hwz","2","Output","Vector (or SIMD) register file write half word"]},{"entry":[{},{},{},"select"]},{"entry":[{},{},{},"00 = write both"]},{"entry":[{},{},{},"10 = write lower"]},{"entry":[{},{},{},"01 = write upper"]},{"entry":[{},{},{},"11 = read"]},{"entry":[{},{},{},"Gated with vec_regf_enz assertion."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["risc_vec_ra","5","Output","Vector (or SIMD) register file read address."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["vec_risc_wrz","1","Input","Register file write enable. Driven by Vector (or"]},{"entry":[{},{},{},"SIMD) when it is returning write data as a result of"]},{"entry":[{},{},{},"a MFVVR or MFVRC instruction."]},{"entry":["vec_risc_wd","32","Output","Vector (or SIMD) register file write data."]},{"entry":[{},{},{},"This is driven in execution stage 5310."]},{"entry":["vec_risc_wa","4","Input","The General purpose register file 5206 address that"]},{"entry":[{},{},{},"is the destination for vector data returning as a"]},{"entry":[{},{},{},"result of a MFVVR or MFVRC instruction."]},{"entry":["vec_risc_wa","4","Input","The GPR address that is the destination for vector"]},{"entry":[{},{},{},"data returning as a result of a MFVVR or MFVRC"]},{"entry":[{},{},{},"instruction."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Shared Function-Memory Interface"},{"entry":"(which can be used for processor with Shared Function-Memory 1410)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vmem_rdy","1","Input","Vector memory ready."]},{"entry":[{},{},{},"Usually present, strapped high when not in use."]},{"entry":["risc_vec_valid","1","Output","Indicates that the SFM instruction lanes are valid."]},{"entry":[{},{},{},"This normally asserted but is de-asserted when the"]},{"entry":[{},{},{},"processor 5200 is executing the second half of a"]},{"entry":[{},{},{},"non-parallel 20-bit instruction pair."]},{"entry":["risc_fmem_addr","20","Output","Vector implied load\/store address bus"]},{"entry":["risc_fmem_bez","4","Output","Vector implied load\/store byte enables"]},{"entry":["risc_vec_opr","4","Output","This bus represents the vector unit source register"]},{"entry":[{},{},{},"for vector implied stores, or the vector unit"]},{"entry":[{},{},{},"destination register for vector implied loads."]},{"entry":["risc_is_vild","1","Output","Vector implied signed load flag."]},{"entry":["risc_is vildu","1","Output","Vector implied unsigned load flag."]},{"entry":["risc_is_vist","1","Output","Vector implied store flag"]},{"entry":["risc_hg_posn","8","Output","Reflects the current contents of the processor 5200"]},{"entry":[{},{},{},"HG_POSN control register"]},{"entry":["risc_regf_ra[1:0]","\u20024b \u00d7 2","Input","Register file read address ports. There are two"]},{"entry":[{},{},{},"ports. These pins are driven by lane 0 (left most)"]},{"entry":[{},{},{},"vector unit. Allows the vector unit to read one of"]},{"entry":[{},{},{},"the lower 4 registers in the GPR file."]},{"entry":["risc_regf_rd[1:0]z","\u20021b \u00d7 2","Input","When de-asserted gates off switching on the"]},{"entry":[{},{},{},"risc_regf_rdata0\/1 buses. Should be driven low to"]},{"entry":[{},{},{},"read valid data on risc_regf_rdata."]},{"entry":["risc_regf_rdata[1:0]","32b \u00d7 2","Output","Register file read data ports. There are two ports."]},{"entry":[{},{},{},"These pins are driven by lane 0 (left most) vector"]},{"entry":[{},{},{},"unit. These are the read data buses associated with"]},{"entry":[{},{},{},"risc_regf_ra."]},{"entry":["risc_inc_hg_posn","1","Output","Asserted in D0 when a BHGNE instruction is"]},{"entry":[{},{},{},"decoded."]},{"entry":["wrp_hgposn_ne_hgsize","1","Input","Asserted by the SFM wrapper. Indicates whether"]},{"entry":[{},{},{},"the wrappers copy of HG_POSN and HG_SIZE are"]},{"entry":[{},{},{},"not equal."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Interrupt Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["nmi","1","Input","Level triggered non-mask-able interrupt"]},{"entry":["int0","1","Input","Level triggered mask-able interrupt"]},{"entry":["int1","1","Input","Level triggered externally managed interrupt"]},{"entry":["iack","1","Output","Interrupt acknowledge"]},{"entry":["inum","3","Output","Acknowledged interrupt identifier"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Debug Interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["dbg_rd","32","Output","Debug register read data"]},{"entry":["risc_brk_trc_match","1","Output","Asserted when the processor 5200 debug module"]},{"entry":[{},{},{},"detects either a break-point or trace-point match"]},{"entry":["risc_trc_pt_match","1","Output","Asserted when the processor 5200 debug module"]},{"entry":[{},{},{},"detects a trace-point match"]},{"entry":["risc_trc_pt_match_id","2","Output","The ID of the break\/trace point register which"]},{"entry":[{},{},{},"detected a match."]},{"entry":["dbg_req","1","Input","Debug module access request"]},{"entry":["dbg_addr","5","Input","Debug module register address"]},{"entry":["dbg_wrz","1","Input","Debug module register write enable."]},{"entry":["dbg_mode_enable","1","Input","Debug module master enable"]},{"entry":["wp_events","16","Input","User defined event input bus"]},{"entry":["wp_cur_cntx","4","Input","Wrapper driven current context number"]},{"entry":["wp_event","15:0","Input","User defined event input bus"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Clocking and Reset"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ck0","1","Input","Primary clock to the CPU core"]},{"entry":["ck1","1","Input","Primary clock to the debug module"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Within the vector units up to (for example) four instructions can execute simultaneously. This set of four instructions includes at most one load and one store and up to other instructions. Alternatively, up to four non-load and non-store instructions (for example) can be executed. All vector units can execute the same execute packet (the same set of up to four vector instructions, for example), but do so using their local register files.","8.3. General Purpose Register File","The general purpose register file is similar to register file  described above.","8.4. Control Register File","The control register file here is similar to the control register file  described above; however, the control register file here includes several more registers. In Table 17 below, the registers that can be included in this control register file are described, and the additional registers are described in the following sections.",{"@attributes":{"id":"p-0864","num":"1110"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 17"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Mnemonic","Register Name","Description","Width","Address"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CSR","Control status","Contains global","12","0x00"]},{"entry":[{},"register","interrupt enable",{},{}]},{"entry":[{},{},"bit, and additional",{},{}]},{"entry":[{},{},"control\/status bits",{},{}]},{"entry":["IER","Interrupt enable","Allows manual","4","0x01"]},{"entry":[{},"register","enable\/disable of",{},{}]},{"entry":[{},{},"individual",{},{}]},{"entry":[{},{},"interrupts",{},{}]},{"entry":["IRP","Interrupt return","Interrupt return","16","0x02"]},{"entry":[{},"pointer","address.",{},{}]},{"entry":["LBR","Load base","Contains the","16","0x03"]},{"entry":[{},"register","global data",{},{}]},{"entry":[{},{},"address pointer,",{},{}]},{"entry":[{},{},"used for some",{},{}]},{"entry":[{},{},"load instructions",{},{}]},{"entry":["SBR","Store base","Contains the","16","0x04"]},{"entry":[{},"register","global data",{},{}]},{"entry":[{},{},"address pointer,",{},{}]},{"entry":[{},{},"used for some",{},{}]},{"entry":[{},{},"store instructions",{},{}]},{"entry":["SP","Stack Pointer","Contains the next","16","0x05"]},{"entry":[{},{},"available address",{},{}]},{"entry":[{},{},"in the stack",{},{}]},{"entry":[{},{},"memory region.",{},{}]},{"entry":[{},{},"This is a byte",{},{}]},{"entry":[{},{},"address.",{},{}]},{"entry":["HG_SIZE","Horizontal Size","The value of this","8","0x07"]},{"entry":[{},"register","register is",{},{}]},{"entry":[{},{},"available on the",{},{}]},{"entry":[{},{},"risc_hg_size[7:0]",{},{}]},{"entry":[{},{},"boundary pins.",{},{}]},{"entry":[{},{},"This register adds",{},{}]},{"entry":[{},{},"8 bits to the",{},{}]},{"entry":[{},{},"context",{},{}]},{"entry":[{},{},"save\/write",{},{}]},{"entry":[{},{},"infomation.",{},{}]},{"entry":[{},{},"This register is",{},{}]},{"entry":[{},{},"accessible via the",{},{}]},{"entry":[{},{},"processor 5200",{},{}]},{"entry":[{},{},"debug interface.",{},{}]},{"entry":["HG_POSN","Horizontal","The value of this","8","0x08"]},{"entry":[{},"Position register","register is",{},{}]},{"entry":[{},{},"available on the",{},{}]},{"entry":[{},{},"risc_hg_posn[7:0]",{},{}]},{"entry":[{},{},"boundary pins.",{},{}]},{"entry":[{},{},"This register adds",{},{}]},{"entry":[{},{},"8 bits to the",{},{}]},{"entry":[{},{},"context",{},{}]},{"entry":[{},{},"save\/write",{},{}]},{"entry":[{},{},"information.",{},{}]},{"entry":[{},{},"Note:",{},{}]},{"entry":[{},{},"reads\/writes to",{},{}]},{"entry":[{},{},"this register are",{},{}]},{"entry":[{},{},"through the",{},{}]},{"entry":[{},{},"conventional",{},{}]},{"entry":[{},{},"MVC instruction.",{},{}]},{"entry":[{},{},"HG_POSN has a",{},{}]},{"entry":[{},{},"special condition,",{},{}]},{"entry":[{},{},"if the value being",{},{}]},{"entry":[{},{},"written to",{},{}]},{"entry":[{},{},"HG_POSN is",{},{}]},{"entry":[{},{},"larger than the",{},{}]},{"entry":[{},{},"current value of",{},{}]},{"entry":[{},{},"HG_SIZE then",{},{}]},{"entry":[{},{},"HG_POSN is",{},{}]},{"entry":[{},{},"written with 0.",{},{}]},{"entry":[{},{},"This register is",{},{}]},{"entry":[{},{},"accessible via the",{},{}]},{"entry":[{},{},"processor 5200",{},{}]},{"entry":[{},{},"debug interface."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The HG_SIZE register can be written by external logic using the debug interface. HG_SIZE can be used as an implied operand in some instructions.","8.6. Horizontal Position Register (HG_POSN)","The HG_POSN register can be written by external logic using the debug interface. HG_POSN can be used as an implied operand in some instructions. It should also be noted that HG_POSN has a special property, if the value to be written to HG_POSN is larger than the current value of the HG_SIZE register then HG_POSN is written with zero.","8.7. Interrupt Behavior","In conjunction with the interrupt behavior described with respect to node processor  above, this RISC processor also includes a GIE bit or global interrupt enable bit. If GIE bit is cleared assertions on pins nmi, int0 and int1 are ignored. In addition, pins int0 and int1 each have an associated enable bit in the interrupt enable register, which individually masks the associated input. The \u201creset interrupt\u201d (input pin rstz0) software interrupts (SWI instruction) and UNDEF interrupts (detection of an undefined instruction) are usually enabled. Theses interrupts are generally not effected by the GIE bit and do not have entries in the interrupt enable register.","Reset is generally considered the highest priority interrupt and can be used to halt the processing unit (i.e., ) and return it to a known state. Some of the characteristics of reset interrupt can be:\n\n","Here, two maskable interrupts (i.e., int0) and int1) can be supported. Assuming that a maskable interrupt does not occur during the delay slot of a branch, the following conditions should be met to process a maskable interrupt:\n\n","For maskable interrupts the IRP register is loaded with the return address of the next instruction to execute after the maskable interrupt service routine terminates. To exit a maskable interrupt service routine the BIRP instruction is used. (Note BIRP has a 2 cycle delay slot which is also executed before returning control.) Execution of BIRP causes T80 to copy the contents of the IRP register to the PC. For int0 and int1, assuming the GIE bit is set, and the associated interrupt enable register bit is also set, the following actions can be performed:\n\n","A non-maskable Interrupt or NMI is generally considered the second-highest priority interrupt and is generally used to alert of a serious hardware problem. For NMI processing to occur, the global interrupt enable (GIE) bit in the interrupt enable register (IER) should be set to 1. This simplifies external control logic typically desired to block NMI's during power on or reset. Processing of an NMI is similar to maskable interrupt processing, except for the requirement that the appropriate IER bit be set, (NMI has no such bit). Otherwise the same steps are taken forentry and exit from the interrupt service routines.","The software interrupt or SWI instruction is used to trigger the software interrupt. Decoding of SWI instruction generally causes the SWI ISTentry to be loaded into the program counter (i.e., ). Control can returned to the instruction immediately following the SWI instruction on the execution of a BIRP within the software interrupt service routine. Decode of an SWI instructions causes a store to the interrupt register pointer register with the return address of the next instruction to execute after the SWI service routine is complete. To exit a SWI service routine the BIRP instruction is used.","An UNDEF interrupt is triggered by decode stage (i.e., ) whenever an undefined instruction is detected. Detection of an undefined instruction causes the UNDEF ISTentry to be loaded into the program counter (i.e., ). Control is returned to the instruction immediately following the UNDEF on the execution of a BIRP within the UNDEF interrupt service routine. Decode of an undefined instruction causes a load of the interrupt enable register with the return address of the next instruction to execute after the UNDEF service routine is complete. For the purposes of next instruction address calculations, UNDEF instructions are treated as narrow instructions, where narrow instruction occupy a single instruction word and where as wide instructions occupy two instruction words. In many cases the UNDEF interrupt is an indication of a severe problem in the contents of the instruction memory; however, provisions are available to recover from an UNDEF interrupt.","8.8. Vector Implied Loads\/Stores","A processor  that includes a vector module (such as the processor for the shared function memory , which is discussed in detail below) can support scalar initiated loads and stores to the function-memory (discussed below), these instructions used vector implied addressing. Address calculation and assertion of function-memory control signals are handled by instruction executing on the processor . The source data (for vector implied stores) and the destination register (for vector implied loads) are sourced\/received by the vector units. A handshake interface is present in processor  (with a vector module) between the processor  and the vector units. This interface provides operand information to the vector units. An example of a vector implied load can be seen in . Additionally, Table 18 below illustrates the boundary pins for processor  that are associated with vector implied loads and stores.",{"@attributes":{"id":"p-0876","num":"1139"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 18"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Pin","Width","Dir","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vmem_rdy","1","Input","Function memory ready."]},{"entry":["risc_vmem_addr","20","Output","Vector implied load\/store address"]},{"entry":[{},{},{},"bus"]},{"entry":["risc_vmem_bez","4","Output","Vector implied load\/store byte"]},{"entry":[{},{},{},"enables"]},{"entry":["risc_vec_opr","4","Output","This bus represents the vector unit"]},{"entry":[{},{},{},"source register for vector implied "]},{"entry":[{},{},{},"stores, or the vector unit"]},{"entry":[{},{},{},"destination register for vector"]},{"entry":[{},{},{},"implied loads."]},{"entry":["risc_is_vild","1","Output","Vector implied load flag"]},{"entry":["risc_is_vist","1","Output","Vector implied store flag"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The debug module for the processor  (which is a part of the processing unit ) utilizes the wrapper interface (i.e., node wrapper -) to simplify the design of the debug module. The boundary pins for debug support are listed in above in Table 16. The debug register set is summarized below in Table 19.",{"@attributes":{"id":"p-0878","num":"1141"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 19"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":[{},{},{},{},{},"Bit"]},{"entry":["Registger Name","Description","Field","Function","Width","Position"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DBG_CNTRL","Global debug",{},{},"1",{}]},{"entry":[{},"mode control",{},{},{},{}]},{"entry":[{},"Address: 0x00",{},{},{},{}]},{"entry":["RSRV0","Not","N\/A","N\/A","N\/A","N\/A"]},{"entry":[{},"implemented,",{},{},{},{}]},{"entry":[{},"reads",{},{},{},{}]},{"entry":[{},"0x00000000",{},{},{},{}]},{"entry":[{},"Address: 0x01",{},{},{},{}]},{"entry":["BRK0","Break\/trace","RSRV","Reserved, not implemented,","3","31:29"]},{"entry":[{},"point register 0",{},"reads 0x0",{},{}]},{"entry":[{},"Address: 0x02","EN","Enable, =1 enables","1","28"]},{"entry":[{},{},{},"break\/trace point",{},{}]},{"entry":[{},{},{},"comparisons",{},{}]},{"entry":[{},{},"TM","Trace mode, =1 trace mode,","1","27"]},{"entry":[{},{},{},"=0 breakpoint mode",{},{}]},{"entry":[{},{},"ID","Trace\/breakpoint ID, this is","2","26:25"]},{"entry":[{},{},{},"asserted on",{},{}]},{"entry":[{},{},{},"risc_trc_pt_match_id",{},{}]},{"entry":[{},{},"CNTX","When context comparison","4","24:21"]},{"entry":[{},{},{},"is enabled (CC = 1, below)",{},{}]},{"entry":[{},{},{},"this field is compared to the",{},{}]},{"entry":[{},{},{},"input pins wp_cur_cntx, to",{},{}]},{"entry":[{},{},{},"further qualify the match.",{},{}]},{"entry":[{},{},{},"When CC = 1 both the",{},{}]},{"entry":[{},{},{},"instruction memory address",{},{}]},{"entry":[{},{},{},"and the wp_cur_cntx value",{},{}]},{"entry":[{},{},{},"are compared to determine a",{},{}]},{"entry":[{},{},{},"match. When CC = 0",{},{}]},{"entry":[{},{},{},"wp_cur_cntx is ignored",{},{}]},{"entry":[{},{},{},"when determining a match.",{},{}]},{"entry":[{},{},"CC","Context compare enable, =1","1","20"]},{"entry":[{},{},{},"enabled",{},{}]},{"entry":[{},{},"RSRV","Reserved, not implemented,","4","19:16"]},{"entry":[{},{},{},"reads 0x0",{},{}]},{"entry":[{},{},"IA","Instruction memory address","16","15:0\u2002"]},{"entry":[{},{},{},"for the trace\/breakpoint.",{},{}]},{"entry":[{},{},{},"This is compared to",{},{}]},{"entry":[{},{},{},"imem_addr to determine a",{},{}]},{"entry":[{},{},{},"potential match",{},{}]},{"entry":["BRK1","Break\/trace","RSRV","Reserved, not implemented,","3","31:29"]},{"entry":[{},"point register 1",{},"reads 0x0",{},{}]},{"entry":[{},"Address: 0x03","EN","Enable, =1 enables","1","28"]},{"entry":[{},{},{},"break\/trace point",{},{}]},{"entry":[{},{},{},"comparisons",{},{}]},{"entry":[{},{},"TM","Trace mode, =1 trace mode,","1","27"]},{"entry":[{},{},{},"=0 breakpoint mode",{},{}]},{"entry":[{},{},"ID","Trace\/breakpoint ID, this is","2","26:25"]},{"entry":[{},{},{},"asserted on",{},{}]},{"entry":[{},{},{},"risc_trc_pt_match_id",{},{}]},{"entry":[{},{},"CNTX","When context comparison","4","24:21"]},{"entry":[{},{},{},"is enabled (CC = 1, below)",{},{}]},{"entry":[{},{},{},"this field is compared to the",{},{}]},{"entry":[{},{},{},"input pins wp_cur_cntx, to",{},{}]},{"entry":[{},{},{},"further qualify the match.",{},{}]},{"entry":[{},{},{},"When CC = 1 both the",{},{}]},{"entry":[{},{},{},"instruction memory address",{},{}]},{"entry":[{},{},{},"and the wp_cur_cntx value",{},{}]},{"entry":[{},{},{},"are compared to determine a",{},{}]},{"entry":[{},{},{},"match. When CC = 0",{},{}]},{"entry":[{},{},{},"wp_cur_cntx is ignored",{},{}]},{"entry":[{},{},{},"when determining a match.",{},{}]},{"entry":[{},{},"CC","Context compare enable, =1","1","20"]},{"entry":[{},{},{},"enabled",{},{}]},{"entry":[{},{},"RSRV","Reserved, not implemented,","4","19:16"]},{"entry":[{},{},{},"reads 0x0",{},{}]},{"entry":[{},{},"IA","Instruction memory address","16","15:0\u2002"]},{"entry":[{},{},{},"for the trace\/breakpoint.",{},{}]},{"entry":[{},{},{},"This is compared to",{},{}]},{"entry":[{},{},{},"imem_addr to determine a",{},{}]},{"entry":[{},{},{},"potential match",{},{}]},{"entry":["BRK2","Break\/trace","RSRV","Reserved, not implemented,","3","31:29"]},{"entry":[{},"point register 2",{},"reads 0x0",{},{}]},{"entry":[{},"Address: 0x04","EN","Enable, =1 enables","1","28"]},{"entry":[{},{},{},"break\/trace point",{},{}]},{"entry":[{},{},{},"comparisons",{},{}]},{"entry":[{},{},"TM","Trace mode, =1 trace mode,","1","27"]},{"entry":[{},{},{},"=0 breakpoint mode",{},{}]},{"entry":[{},{},"ID","Trace\/breakpoint ID, this is","2","26:25"]},{"entry":[{},{},{},"asserted on",{},{}]},{"entry":[{},{},{},"risc_trc_pt_match_id",{},{}]},{"entry":[{},{},"CNTX","When context comparison","4","24:21"]},{"entry":[{},{},{},"is enabled (CC = 1, below)",{},{}]},{"entry":[{},{},{},"this field is compared to the",{},{}]},{"entry":[{},{},{},"input pins wp_cur_cntx, to",{},{}]},{"entry":[{},{},{},"further qualify the match.",{},{}]},{"entry":[{},{},{},"When CC = 1 both the",{},{}]},{"entry":[{},{},{},"instruction memory address",{},{}]},{"entry":[{},{},{},"and the wp_cur_cntx value",{},{}]},{"entry":[{},{},{},"are compared to determine a",{},{}]},{"entry":[{},{},{},"match. When CC = 0",{},{}]},{"entry":[{},{},{},"wp_cur_cntx is ignored",{},{}]},{"entry":[{},{},{},"when determining a match.",{},{}]},{"entry":[{},{},"CC","Context compare enable, =1","1","20"]},{"entry":[{},{},{},"enabled",{},{}]},{"entry":[{},{},"RSRV","Reserved, not implemented,","4","19:16"]},{"entry":[{},{},{},"reads 0x0",{},{}]},{"entry":[{},{},"IA","Instruction memory address","16","15:0\u2002"]},{"entry":[{},{},{},"for the trace\/breakpoint.",{},{}]},{"entry":[{},{},{},"This is compared to",{},{}]},{"entry":[{},{},{},"imem_addr to determine a",{},{}]},{"entry":[{},{},{},"potential match",{},{}]},{"entry":["BRK3","Break\/trace","RSRV","Reserved, not implemented,","3","31:29"]},{"entry":[{},"point register 3",{},"reads 0x0",{},{}]},{"entry":[{},"Address: 0x05","EN","Enable, =1 enables","1","28"]},{"entry":[{},{},{},"break\/trace point",{},{}]},{"entry":[{},{},{},"comparisons",{},{}]},{"entry":[{},{},"TM","Trace mode, =1 trace mode,","1","27"]},{"entry":[{},{},{},"=0 breakpoint mode",{},{}]},{"entry":[{},{},"ID","Trace\/breakpoint ID, this is","2","26:25"]},{"entry":[{},{},{},"asserted on",{},{}]},{"entry":[{},{},{},"risc_trc_pt_match_id",{},{}]},{"entry":[{},{},"CNTX","When context comparison","4","24:21"]},{"entry":[{},{},{},"is enabled (CC = 1, below)",{},{}]},{"entry":[{},{},{},"this field is compared to the",{},{}]},{"entry":[{},{},{},"input pins wp_cur_cntx, to",{},{}]},{"entry":[{},{},{},"further qualify the match.",{},{}]},{"entry":[{},{},{},"When CC = 1 both the",{},{}]},{"entry":[{},{},{},"instruction memory address",{},{}]},{"entry":[{},{},{},"and the wp_cur_cntx value",{},{}]},{"entry":[{},{},{},"are compared to determine a",{},{}]},{"entry":[{},{},{},"match. When CC = 0",{},{}]},{"entry":[{},{},{},"wp_cur_cntx is ignored",{},{}]},{"entry":[{},{},{},"when determining a match.",{},{}]},{"entry":[{},{},"CC","Context compare enable, =1","1","20"]},{"entry":[{},{},{},"enabled",{},{}]},{"entry":[{},{},"RSRV","Reserved, not implemented,","4","19:16"]},{"entry":[{},{},{},"reads 0x0",{},{}]},{"entry":[{},{},"IA","Instruction memory address","16","15:0\u2002"]},{"entry":[{},{},{},"for the trace\/breakpoint.",{},{}]},{"entry":[{},{},{},"This is compared to",{},{}]},{"entry":[{},{},{},"imem_addr to determine a",{},{}]},{"entry":[{},{},{},"potential match",{},{}]},{"entry":["ECC0","Event counter","EN","Event count enable","1","7"]},{"entry":[{},"control register 0","SEL","Event select","7","6:0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Address: 0x06","SEL",{}]},{"entry":[{},{},"Value","Event"]},{"entry":[{},{},"0x00","Instruction"]},{"entry":[{},{},{},"memory stall"]},{"entry":[{},{},"0x01","Data memory"]},{"entry":[{},{},{},"stall"]},{"entry":[{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x04","40b instruction"]},{"entry":[{},{},{},"valid"]},{"entry":[{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x06","CALL"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x07","RET instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x08","Branch"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"decoded"]},{"entry":[{},{},"0x09","Branch taken"]},{"entry":[{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},"side NOP"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x0b-","User events,"]},{"entry":[{},{},"1a","0x0b selects"]},{"entry":[{},{},{},"wp_events[0],"]},{"entry":[{},{},{},"etc"]},{"entry":[{},{},"0x01b-","unused"]},{"entry":[{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC1","Event counter","EN","Event count enable","1","7"]},{"entry":[{},"control register 1","SEL","Event select","7","6:0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Address: 0x07","SEL",{}]},{"entry":[{},{},"Value","Event"]},{"entry":[{},{},"0x00","Instruction"]},{"entry":[{},{},{},"memory stall"]},{"entry":[{},{},"0x01","Data memory"]},{"entry":[{},{},{},"stall"]},{"entry":[{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x04","40b instruction"]},{"entry":[{},{},{},"valid"]},{"entry":[{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x06","CALL"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x07","RET instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x08","Branch"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"decoded"]},{"entry":[{},{},"0x09","Branch taken"]},{"entry":[{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},"side NOP"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x0b-","User events,"]},{"entry":[{},{},"1a","0x0b selects"]},{"entry":[{},{},{},"wp_events[0],"]},{"entry":[{},{},{},"etc"]},{"entry":[{},{},"0x01b-","unused"]},{"entry":[{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC2","Event counter","EN","Event count enable","1","7"]},{"entry":[{},"control register 2","SEL","Event select","7","6:0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Address: 0x08","SEL",{}]},{"entry":[{},{},"Value","Event"]},{"entry":[{},{},"0x00","Instruction"]},{"entry":[{},{},{},"memory stall"]},{"entry":[{},{},"0x01","Data memory"]},{"entry":[{},{},{},"stall"]},{"entry":[{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x04","40b instruction"]},{"entry":[{},{},{},"valid"]},{"entry":[{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x06","CALL"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x07","RET instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x08","Branch"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"decoded"]},{"entry":[{},{},"0x09","Branch taken"]},{"entry":[{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},"side NOP"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x0b-","User events,"]},{"entry":[{},{},"1a","0x0b selects"]},{"entry":[{},{},{},"wp_events[0],"]},{"entry":[{},{},{},"etc"]},{"entry":[{},{},"0x01b-","unused"]},{"entry":[{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC3","Event counter","EN","Event count enable","1","7"]},{"entry":[{},"control register 3","SEL","Event select","7","6:0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Address: 0x09","SEL",{}]},{"entry":[{},{},"Value","Event"]},{"entry":[{},{},"0x00","Instruction"]},{"entry":[{},{},{},"memory stall"]},{"entry":[{},{},"0x01","Data memory"]},{"entry":[{},{},{},"stall"]},{"entry":[{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x04","40b instruction"]},{"entry":[{},{},{},"valid"]},{"entry":[{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x06","CALL"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x07","RET instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x08","Branch"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"decoded"]},{"entry":[{},{},"0x09","Branch taken"]},{"entry":[{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},"side NOP"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x0b-","User events,"]},{"entry":[{},{},"1a","0x0b selects"]},{"entry":[{},{},{},"wp_events[0],"]},{"entry":[{},{},{},"etc"]},{"entry":[{},{},"0x01b-","unused"]},{"entry":[{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC4","Event counter","EN","Event count enable","1","7"]},{"entry":[{},"control register 4","SEL","Event select","7","6:0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Address: 0xa","SEL",{}]},{"entry":[{},{},"Value","Event"]},{"entry":[{},{},"0x00","Instruction"]},{"entry":[{},{},{},"memory stall"]},{"entry":[{},{},"0x01","Data memory"]},{"entry":[{},{},{},"stall"]},{"entry":[{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x04","40b instruction"]},{"entry":[{},{},{},"valid"]},{"entry":[{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x06","CALL"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x07","RET instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x08","Branch"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"decoded"]},{"entry":[{},{},"0x09","Branch taken"]},{"entry":[{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},"side NOP"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x0b-","User events,"]},{"entry":[{},{},"1a","0x0b selects"]},{"entry":[{},{},{},"wp_events[0],"]},{"entry":[{},{},{},"etc"]},{"entry":[{},{},"0x01b-","unused"]},{"entry":[{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC5","Event counter","EN","Event count enable","1","7"]},{"entry":[{},"control register 5","SEL","Event select","7","6:0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Address: 0xb","SEL",{}]},{"entry":[{},{},"Value","Event"]},{"entry":[{},{},"0x00","Instruction"]},{"entry":[{},{},{},"memory stall"]},{"entry":[{},{},"0x01","Data memory"]},{"entry":[{},{},{},"stall"]},{"entry":[{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x04","40b instruction"]},{"entry":[{},{},{},"valid"]},{"entry":[{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x06","CALL"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x07","RET instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x08","Branch"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"decoded"]},{"entry":[{},{},"0x09","Branch taken"]},{"entry":[{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},"side NOP"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x0b-","User events,"]},{"entry":[{},{},"1a","0x0b selects"]},{"entry":[{},{},{},"wp_events[0],"]},{"entry":[{},{},{},"etc"]},{"entry":[{},{},"0x01b-","unused"]},{"entry":[{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC6","Event counter","EN","Event count enable","1","7"]},{"entry":[{},"control register 6","SEL","Event select","7","6:0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Address: 0xc","SEL",{}]},{"entry":[{},{},"Value","Event"]},{"entry":[{},{},"0x00","Instruction"]},{"entry":[{},{},{},"memory stall"]},{"entry":[{},{},"0x01","Data memory"]},{"entry":[{},{},{},"stall"]},{"entry":[{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x04","40b instruction"]},{"entry":[{},{},{},"valid"]},{"entry":[{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x06","CALL"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x07","RET instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x08","Branch"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"decoded"]},{"entry":[{},{},"0x09","Branch taken"]},{"entry":[{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},"side NOP"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x0b-","User events,"]},{"entry":[{},{},"1a","0x0b selects"]},{"entry":[{},{},{},"wp_events[0],"]},{"entry":[{},{},{},"etc"]},{"entry":[{},{},"0x01b-","unused"]},{"entry":[{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ECC7","Event counter","EN","Event count enable","1","7"]},{"entry":[{},"control register 7","SEL","Event select","7","6:0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Address: 0xd","SEL",{}]},{"entry":[{},{},"Value","Event"]},{"entry":[{},{},"0x00","Instruction"]},{"entry":[{},{},{},"memory stall"]},{"entry":[{},{},"0x01","Data memory"]},{"entry":[{},{},{},"stall"]},{"entry":[{},{},"0x02","Scalar a-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x03","Scalar b-side"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x04","40b instruction"]},{"entry":[{},{},{},"valid"]},{"entry":[{},{},"0x05","Non-parallel"]},{"entry":[{},{},{},"instruction valid"]},{"entry":[{},{},"0x06","CALL"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x07","RET instruction"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x08","Branch"]},{"entry":[{},{},{},"instruction"]},{"entry":[{},{},{},"decoded"]},{"entry":[{},{},"0x09","Branch taken"]},{"entry":[{},{},"0x0a","Scalar a- or b-"]},{"entry":[{},{},{},"side NOP"]},{"entry":[{},{},{},"executed"]},{"entry":[{},{},"0x0b-","User events,"]},{"entry":[{},{},"1a","0x0b selects"]},{"entry":[{},{},{},"wp_events[0],"]},{"entry":[{},{},{},"etc"]},{"entry":[{},{},"0x01b-","unused"]},{"entry":[{},{},"7F",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["EC0","Event counter","16","15:0\u2002"]},{"entry":[{},"register 0",{},{}]},{"entry":[{},"Address: 0xe",{},{}]},{"entry":["EC1","Event counter","16","15:0\u2002"]},{"entry":[{},"register 1",{},{}]},{"entry":[{},"Address: 0xf",{},{}]},{"entry":["EC2","Event counter","16","15:0\u2002"]},{"entry":[{},"register 2",{},{}]},{"entry":[{},"Address: 0x10",{},{}]},{"entry":["EC3","Event counter","16","15:0\u2002"]},{"entry":[{},"register 3",{},{}]},{"entry":[{},"Address: 0x11",{},{}]},{"entry":["EC4","Event counter","16","15:0\u2002"]},{"entry":[{},"register 4",{},{}]},{"entry":[{},"Address: 0x12",{},{}]},{"entry":["EC5","Event counter","16","15:0\u2002"]},{"entry":[{},"register 5",{},{}]},{"entry":[{},"Address: 0x13",{},{}]},{"entry":["EC6","Event counter","16","15:0\u2002"]},{"entry":[{},"register 6",{},{}]},{"entry":[{},"Address: 014",{},{}]},{"entry":["EC7","Event counter","16","15:0\u2002"]},{"entry":[{},"register 7",{},{}]},{"entry":[{},"Address: 0x15",{},{}]},{"entry":["HG_SIZE","This address","8","7:0"]},{"entry":[{},"allows direct",{},{}]},{"entry":[{},"read\/write by",{},{}]},{"entry":[{},"the messaging",{},{}]},{"entry":[{},"wrapper to the",{},{}]},{"entry":[{},"control register",{},{}]},{"entry":[{},"HG_SIZE.",{},{}]},{"entry":[{},"Address: 0x16",{},{}]},{"entry":["HG_POSN","This address","8","7:0"]},{"entry":[{},"allows direct",{},{}]},{"entry":[{},"read\/write by",{},{}]},{"entry":[{},"the messaging",{},{}]},{"entry":[{},"wrapper to the",{},{}]},{"entry":[{},"control register",{},{}]},{"entry":[{},"HG_POSN.",{},{}]},{"entry":[{},"Address: 0x17",{},{}]},{"entry":["V_RANGE","This address","8","7:0"]},{"entry":[{},"allows direct",{},{}]},{"entry":[{},"read\/write by",{},{}]},{"entry":[{},"the messaging",{},{}]},{"entry":[{},"wrapper to the",{},{}]},{"entry":[{},"control register",{},{}]},{"entry":[{},"V_RANGE.",{},{}]},{"entry":[{},"Address: 0x18"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Table 20 below illustrates an example of an instruction set architecture for a RISC processor having a vector processing module:",{"@attributes":{"id":"p-0880","num":"1143"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 20"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Syntax\/Pseudocode","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ABS .(SA,SB) s1(R4)","ABSOLUTE"]},{"entry":["void ISA::OPC_ABS_20b_9 (Gpr &s1,Unit &unit)","VALUE"]},{"entry":["{",{}]},{"entry":["\u2002s1 = s < 0 ? \u2212s1 : s1;",{}]},{"entry":["\u2002Csr.setBit(EQ,unit,s1.zero( ));",{}]},{"entry":["}",{}]},{"entry":["ABS .(V,VP) s1(R4)","ABSOLUTE"]},{"entry":["void ISA::OPCV_ABS_20b_2 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","VALUE"]},{"entry":["{",{}]},{"entry":["if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s1.range(LSBL,MSBL) = s1.range(LSBL,MSBL) < 0 ? \u2212",{}]},{"entry":["s1.range(LSBL,MSBL) : s1.range(LSBL,MSBL);",{}]},{"entry":["\u2003s1.range(LSBU,MSBU) = s1.range(LSBU,MSBU) < 0 ? \u2212",{}]},{"entry":["s1.range(LSBU,MSBU) : s1.range(LSBU,MSBU);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s1.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s1.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s1 = s1 < 0 ? \u2212s1 : s1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s1.zero( );",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ABSD .(VBx,VPx) s1(R4), s2(R4)","ABSOLUTE"]},{"entry":["void ISA::OPCV_ABSD_20b_50 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","DIFFERENCE"]},{"entry":["{",{}]},{"entry":["\u2002if(isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(24,31) = _abs(s2.range(24,31)) \u2212 s1.range(24,31);",{}]},{"entry":["\u2003s2.range(16,23) = _abs(s2.range(16,23)) \u2212 s1.range(16,23);",{}]},{"entry":["\u2003s2.range(8, 15) = _abs(s2.range(8, 15)) \u2212 s1.range(8,15);",{}]},{"entry":["\u2003s2.range(0, 7) = _abs(s2.range(0, 7)) \u2212 s1.range(0,7);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(16,31) = _abs(s2.range(16,31)) \u2212 s1.range(16,31);",{}]},{"entry":["\u2003s2.range(0, 15) = _abs(s2.range(0, 15)) \u2212 s1.range(0,15);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ABSDU .(VBx,VPx) s1(R4), s2(R4)","ABSOLUTE"]},{"entry":["void ISA::OPCV_ABSDU_20b_51 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","DIFFERENCE,"]},{"entry":["{","UNSIGNED"]},{"entry":["\u2002if(isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(24,31) =",{}]},{"entry":["\u2003\u2002_abs(_unsigned(s2.range(24,31))) \u2212 _unsigned(s1.range(24,31));",{}]},{"entry":["\u2003s2.range(16,23) =",{}]},{"entry":["\u2003\u2002_abs(_unsigned(s2.range(16,23))) \u2212 _unsigned(s1.range(16,23));",{}]},{"entry":["\u2003s2.range(8, 15) =",{}]},{"entry":["\u2003\u2002_abs(_unsigned(s2.range(8, 15))) \u2212 _unsigned(s1.range(8,15));",{}]},{"entry":["\u2003s2.range(0, 7) =",{}]},{"entry":["\u2003\u2002_abs(_unsigned(s2.range(0, 7))) \u2212 _unsigned(s1.range(0,7));",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(16,31) =",{}]},{"entry":["\u2003\u2002_unsigned(_abs(s2.range(16,31))) \u2212 _unsigned(s1.range(16,31));",{}]},{"entry":["\u2003s2.range(0, 15) =",{}]},{"entry":["\u2003\u2002_unsigned(_abs(s2.range(0, 15))) \u2212 _unsigned(s1.range(0,15));",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ADD .(SA,SB) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_ADD_20b_106 (Gpr &s1, Gpr &s2,Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2 + s1;",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.carryout( );",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ADD .(SA,SB) s1(U4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_ADD_20b_107 (U4 &s1, Gpr &s2,Unit &unit)","ADDITION, U4"]},{"entry":["{","IMM"]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2 + s1;",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.carryout( );",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ADD .(SB) s1(S28),SP(R5)","SIGNED"]},{"entry":["void ISA::OPC_ADD_40b_210 (S28 &s1)","ADDITION, SP,"]},{"entry":["{","S28 IMM"]},{"entry":["\u2002Sp += s1;",{}]},{"entry":["}",{}]},{"entry":["ADD .(SB) s1(S24), SP(R5), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_ADD_40b_211 (U24 &s1, Gpr &s2)","ADDITION, SP,"]},{"entry":["{","S28 IMM, REG"]},{"entry":["\u2002s2 = Sp + s1;","DEST"]},{"entry":["}",{}]},{"entry":["ADD .(SB) s1(S24),s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_ADD_40b_212 (U24 &s1, Gpr &s2,Unit &unit)","ADDITION, S24"]},{"entry":["{","IMM"]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2 + s1;",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.carryout( );",{}]},{"entry":["}",{}]},{"entry":["ADD .(V,VP) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPCV_ADD_20b_57 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s1lo = s1.range(LSBL,MSBL);",{}]},{"entry":["\u2003Reg s2lo = s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003Reg resultlo = s1lo + s2lo;",{}]},{"entry":["\u2003Reg s1hi = s1.range(LSBU,MSBU);",{}]},{"entry":["\u2003Reg s2hi = s2.range(LSBU,MSBU);",{}]},{"entry":["\u2003Reg resulthi = s1hi + s2hi;",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = resultlo.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = resulthi.range(LSBU,MSBU);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1lo,s2lo,resultlo);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1hi,s2hi,resulthi);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg result = s2 + s1;",{}]},{"entry":["\u2003s2 = result;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,result);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ADD .(V,VP) s1(U4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPCV_ADD_20b_58 (U4 &s1, Vreg4 &s2, Unit &unit)","ADDITION, U4"]},{"entry":["{","IMM"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s2lo = s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003Reg resultlo = zero_extend(s1) + s2lo;",{}]},{"entry":["\u2003Reg s2hi = s2.range(LSBU,MSBU);",{}]},{"entry":["\u2003Reg resulthi = zero_extend(s1) + s2hi;",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = resultlo.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = resulthi.range(LSBU,MSBU);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1,s2lo,resultlo);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1,s2hi,resulthi);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg result = s2 + zero_extend(s1);",{}]},{"entry":["\u2003s2 = result;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,result);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ADD2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_ADD2_20b_363 (Gpr &s1, Gpr &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2"]},{"entry":["\u2002s2.range(0,15) =",{}]},{"entry":["\u2003(s1.range(0,15) + s2.range(0,15)) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) =",{}]},{"entry":["\u2003(s1.range(16,31) + s2.range(16,31)) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2 .(SA,SB) s1(U4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_ADD2_20b_364 (U4 &s1, Gpr &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2"]},{"entry":["\u2002s2.range(0,15) = (s1.value( ) + s2.range(0,15)) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) = (s1.value( ) + s2.range(16,31)) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2 .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_ADD2_20b_26 (Vreg4 &s1, Vreg4 &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2"]},{"entry":["\u2002s2.range(0,15) =",{}]},{"entry":["\u2003(s1.range(0,15) + s2.range(0,15)) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) =",{}]},{"entry":["\u2003(s1.range(16,31) + s2.range(16,31)) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2 .(VPx) s1(U4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_ADD2_20b_27 (U4 &s1, Vreg4 &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2"]},{"entry":["\u2002s2.range(0,15) = (s1.value( ) + s2.range(0,15)) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) = (s1.value( ) + s2.range(16,31)) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_ADD2U_20b_365 (Gpr &s1, Gpr &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2,"]},{"entry":["\u2002s2.range(0,15) =","UNSIGNED"]},{"entry":["\u2003(_unsigned(s1.range(0,15)) + _unsigned(s2.range(0,15))) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) =",{}]},{"entry":["\u2003(_unsigned(s1.range(16,31)) + _unsigned(s2.range(16,31))) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2U .(SA,SB) s1(U4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_ADD2U_20b_366 (U4 &s1, Gpr &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2,"]},{"entry":["\u2002s2.range(0,15) =","UNSIGNED"]},{"entry":["\u2003(s1.value( ) + _unsigned(s2.range(0,15))) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) =",{}]},{"entry":["\u2003(s1.value( ) + _unsigned(s2.range(16,31))) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2U .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_ADD2U_20b_28 (Vreg4 &s1, Vreg4 &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2,"]},{"entry":["\u2002s2.range(0,15) =","UNSIGNED"]},{"entry":["\u2003(_unsigned(s1.range(0,15)) + _unsigned(s2.range(0,15))) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) =",{}]},{"entry":["\u2003(_unsigned(s1.range(16,31)) + _unsigned(s2.range(16,31))) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADD2U .(VPx) s1(U4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_ADD2U_20b_29 (U4 &s1, Vreg4 &s2)","ADDITION WITH"]},{"entry":["{","DIVIDE BY 2,"]},{"entry":["\u2002s2.range(0,15) =","UNSIGNED"]},{"entry":["\u2003(s1.value( ) + _unsigned(s2.range(0,15))) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) =",{}]},{"entry":["\u2003(s1.value( ) + _unsigned(s2.range(16,31))) >> 1;",{}]},{"entry":["}",{}]},{"entry":["ADDU .(SA,SB) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_ADDU_20b_123 (Gpr &s1, Gpr &s2, Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = _unsigned(s2) + _unsigned(s1);",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.overflow( );",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ADDU .(SA,SB) s1(U4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_ADDU_20b_124 (U4 &s1, Gpr &s2, Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = _unsigned(s2) + s1;",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.overflow( );",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ADDU .(Vx,VPx,VBx) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPCV_ADDU_20b_123 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s1lo = _unsigned(s1.range(0,15));",{}]},{"entry":["\u2003Reg s2lo = _unsigned(s2.range(0,15));",{}]},{"entry":["\u2003Reg resultlo = s1lo + s2lo;",{}]},{"entry":["\u2003Reg s1hi = _unsigned(s1.range(16,31));",{}]},{"entry":["\u2003Reg s2hi = _unsigned(s2.range(16,31));",{}]},{"entry":["\u2003Reg resulthi = s1hi + s2hi;",{}]},{"entry":["\u2003s2.range(0,15) = resultlo.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = resulthi.range(16,31);",{}]},{"entry":["\u2003Vr15.bit(tEQA) = s2.range(0,15)==0;",{}]},{"entry":["\u2003Vr15.bit(tEQB) = s2.range(16,31)==0;",{}]},{"entry":["\u2003Vr15.bit(tCB) = isCarry(s1lo,s2lo,resultlo);",{}]},{"entry":["\u2003Vr15.bit(tCA) = isCarry(s1hi,s2hi,resulthi);",{}]},{"entry":["\u2002} else if (isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s1byte0 = _unsigned(s1.range(0,7));",{}]},{"entry":["\u2003Reg s2byte0 = _unsigned(s2.range(0,7));",{}]},{"entry":["\u2003Reg resultbyte0 = s1byte0 + s2byte0;",{}]},{"entry":["\u2003Reg s1byte1 = _unsigned(s1.range(8,15));",{}]},{"entry":["\u2003Reg s2byte1 = _unsigned(s2.range(8,15));",{}]},{"entry":["\u2003Reg resultbyte1 = s1byte1 + s2byte1;",{}]},{"entry":["\u2003Reg s1byte2 = _unsigned(s1.range(16,23));",{}]},{"entry":["\u2003Reg s2byte2 = _unsigned(s2.range(16,23));",{}]},{"entry":["\u2003Reg resultbyte2 = s1byte2 + s2byte2;",{}]},{"entry":["\u2003Reg s1byte3 = _unsigned(s1.range(24,31));",{}]},{"entry":["\u2003Reg s2byte3 = _unsigned(s2.range(24,31));",{}]},{"entry":["\u2003Reg resultbyte3 = s1byte3 + s2byte3;",{}]},{"entry":["\u2003s2.range(0,7) = resultbyte0.range(0,7);",{}]},{"entry":["\u2003s2.range(8,15) = resultbyte1.range(8,15);",{}]},{"entry":["\u2003s2.range(16,23) = resultbyte2.range(16,23);",{}]},{"entry":["\u2003s2.range(31,23) = resultbyte3.range(31,23);",{}]},{"entry":["\u2003Vr15.bit(tEQA) = s2.range(0,7)==0;",{}]},{"entry":["\u2003Vr15.bit(tEQB) = s2.range(8,15)==0;",{}]},{"entry":["\u2003Vr15.bit(tEQC) = s2.range(16,23)==0;",{}]},{"entry":["\u2003Vr15.bit(tEQD) = s2.range(24,31)==0;",{}]},{"entry":["\u2003Vr15.bit(tCA) = isCarry(s1byte0,s2byte0,resultbyte0);",{}]},{"entry":["\u2003Vr15.bit(tCB) = isCarry(s1byte1,s2byte1,resultbyte1);",{}]},{"entry":["\u2003Vr15.bit(tCC) = isCarry(s1byte2,s2byte2,resultbyte2);",{}]},{"entry":["\u2003Vr15.bit(tCD) = isCarry(s1byte3,s2byte3,resultbyte3);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg result = _unsigned(s2) + _unsigned(s1);",{}]},{"entry":["\u2003s2 = result;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,result);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ADDU .(Vx,VPx,VBx) s1(U4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPCV_ADDU_20b_124 (U4 &s1, Vreg4 &s2, Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s2lo = _unsigned(s2.range(0,15));",{}]},{"entry":["\u2003Reg resultlo = zero_extend(s1) + s2lo;",{}]},{"entry":["\u2003Reg s2hi = _unsigned(s2.range(16,31));",{}]},{"entry":["\u2003Reg resulthi = zero_extend(s1) + s2hi;",{}]},{"entry":["\u2003s2.range(0,15) = resultlo.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = resulthi.range(16,31);",{}]},{"entry":["\u2003Vr15.bit(tEQA) = s2.range(0,15)==0;",{}]},{"entry":["\u2003Vr15.bit(tEQB) = s2.range(16,31)==0;",{}]},{"entry":["\u2003Vr15.bit(tCB) = isCarry(s1,s2lo,resultlo);",{}]},{"entry":["\u2003Vr15.bit(tCA) = isCarry(s1,s2hi,resulthi);",{}]},{"entry":["\u2002} else if (isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s2byte0 = _unsigned(s2.range(0,7));",{}]},{"entry":["\u2003Reg resultbyte0 = zero_extend(s1) + s2byte0;",{}]},{"entry":["\u2003Reg s2byte1 = _unsigned(s2.range(8,15));",{}]},{"entry":["\u2003Reg resultbyte1 = zero_extend(s1) + s2byte1;",{}]},{"entry":["\u2003Reg s2byte2 = _unsigned(s2.range(16,23));",{}]},{"entry":["\u2003Reg resultbyte2 = zero_extend(s1) + s2byte2;",{}]},{"entry":["\u2003Reg s2byte3 = _unsigned(s2.range(24,31));",{}]},{"entry":["\u2003Reg resultbyte3 = zero_extend(s1) + s2byte3;",{}]},{"entry":["\u2003s2.range(0,7) = resultbyte0.range(0,7);",{}]},{"entry":["\u2003s2.range(8,15) = resultbyte1.range(8,15);",{}]},{"entry":["\u2003s2.range(16,23) = resultbyte2.range(16,23);",{}]},{"entry":["\u2003s2.range(31,23) = resultbyte3.range(31,23);",{}]},{"entry":["\u2003Vr15.bit(tEQA) = s2.range(0,7)==0;",{}]},{"entry":["\u2003Vr15.bit(tEQB) = s2.range(8,15)==0;",{}]},{"entry":["\u2003Vr15.bit(tEQC) = s2.range(16,23)==0;",{}]},{"entry":["\u2003Vr15.bit(tEQD) = s2.range(24,31)==0;",{}]},{"entry":["\u2003Vr15.bit(tCA) = isCarry(s1,s2byte0,resultbyte0);",{}]},{"entry":["\u2003Vr15.bit(tCB) = isCarry(s1,s2byte1,resultbyte1);",{}]},{"entry":["\u2003Vr15.bit(tCC) = isCarry(s1,s2byte2,resultbyte2);",{}]},{"entry":["\u2003Vr15.bit(tCD) = isCarry(s1,s2byte3,resultbyte3);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg result = _unsigned(s2) + zero_extend(s1);",{}]},{"entry":["\u2003s2 = result;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,result);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["AHLDHU .(VP3,VP4) s1(R4), s2(R4), s3(R4","LOAD HALF"]},{"entry":["void ISA::OPCV_AHLDHU_20b_281 (Vreg4 &s1, Vreg4 &s2, Vreg4 &","UNSIGNED,"]},{"entry":["s3)","ABSOLUTE"]},{"entry":["{","HORIZONTAL"]},{"entry":["\u2002Result addrlo,addrhi;","ACCESS"]},{"entry":["\u2002addrlo.range(0,19) =",{}]},{"entry":["\u2003_unsigned((s1.range(0,12)<<6)) + _unsigned(s2.range(0,13));",{}]},{"entry":["\u2002addrhi.range(0,19) =",{}]},{"entry":["\u2003_unsigned((s1.range(16,28)<<6)) + _unsigned(s2.range(16,29));",{}]},{"entry":["\u2002s3.range(0,15) = fmem0->uhalf(addrlo);",{}]},{"entry":["\u2002s3.range(16,31) = fmem1->uhalf(addrhi);",{}]},{"entry":["}",{}]},{"entry":["AHLDHU .(VP3,VP4) s1(R4), s2(U6), s3(R4)","LOAD HALF"]},{"entry":["void ISA::OPCV_AHLDHU_40b_315 (Vreg4 &s1, U6 &s2, Vreg4 &s3)","UNSIGNED,"]},{"entry":["{","ABSOLUTE"]},{"entry":["\u2002Result addrlo,addrhi;","HORIZONTAL"]},{"entry":["\u2002addrlo.range(0,19) =","ACCESS"]},{"entry":["\u2003_unsigned((s1.range(0,12)<<6)) + _unsigned(s2);",{}]},{"entry":["\u2002addrhi.range(0,19) =",{}]},{"entry":["\u2003_unsigned((s1.range(16,28)<<6)) + _unsigned(s2);",{}]},{"entry":["\u2002s3.range(0,15) = fmem0->uhalf(addrlo);",{}]},{"entry":["\u2002s3.range(16,31) = fmem1->uhalf(addrhi);",{}]},{"entry":["}",{}]},{"entry":["AHSTH .(VP3,VP4) s1(R4), s2(R4), s3(R4)","STORE HALF,"]},{"entry":["void ISA::OPCV_AHSTH_20b_282 (Vreg4 &s1, Vreg4 &s2, Vreg4 &s3","ABSOLUTE"]},{"entry":[")","HORIZONTAL"]},{"entry":["{","ACCESS"]},{"entry":["\u2002Result addrlo,addrhi;",{}]},{"entry":["\u2002addrlo.range(0,19) =",{}]},{"entry":["\u2003_unsigned((s1.range(0,12)<<6)) + _unsigned(s2.range(0,13));",{}]},{"entry":["\u2002addrhi.range(0,19) =",{}]},{"entry":["\u2003_unsigned((s1.range(16,28)<<6)) + _unsigned(s2.range(16,29));",{}]},{"entry":["\u2002fmem0->half(addrlo) = s3.range(0,15);",{}]},{"entry":["\u2002fmem1->half(addrhi) = s3.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["AHSTH .(VP3,VP4) s1(R4), s2(U6), s3(R4)","STORE HALF,"]},{"entry":["void ISA::OPCV_AHSTH_40b_316 (Vreg4 &s1, U6 &s2, Vreg4 &s3)","ABSOLUTE"]},{"entry":["{","HORIZONTAL"]},{"entry":["\u2002Result addrlo,addrhi;","ACCESS"]},{"entry":["\u2002addrlo.range(0,19) =",{}]},{"entry":["\u2003_unsigned((s1.range(0,12)<<6)) + _unsigned(s2);",{}]},{"entry":["\u2002addrhi.range(0,19) =",{}]},{"entry":["\u2003_unsigned((s1.range(16,28)<<6)) + _unsigned(s2);",{}]},{"entry":["\u2002fmem0->half(addrlo) = s3.range(0,15);",{}]},{"entry":["\u2002fmem1->half(addrhi) = s3.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["ALD .V4 *+s1(R2)[s2(U6)], s3(R2), s4(R4)","ABSOLUTE"]},{"entry":["void ISA::OPCV_ALD_20b_405 (Gpr2 &s1, U6 &s2, Vreg2 &s3, Vreg","LOAD, IMM"]},{"entry":["&s4)","FORM"]},{"entry":["{",{}]},{"entry":["\u2002risc_regf_ra1._assert(D0,s1.address( ));",{}]},{"entry":["\u2002risc_regf_rd1z._assert(D0,0);",{}]},{"entry":["\u2002Result rBase = risc_regf_rd1.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002int u_offset = _unsigned(s2);",{}]},{"entry":["\u2002int addr_lo = rBase.range( 0,15) + s3.range( 0,15) + u_offset;",{}]},{"entry":["\u2002int addr_hi = rBase.range( 0,15) + s3.range(16,31) + u_offset;",{}]},{"entry":["\u2002s4.range( 0,15) = vmemLo->uhalf(addr_lo);",{}]},{"entry":["\u2002s4.range(16,31) = vmemHi->uhalf(addr_hi);",{}]},{"entry":["}",{}]},{"entry":["ALD .V4 *+s1(R2)[s2(R4)], s3(R2), s4(R4)","ABSOLUTE"]},{"entry":["void ISA::OPCV_ALD_20b_407 (Gpr2 &s1, Vreg &s2, Vreg2 &s3, Vreg","LOAD, REG"]},{"entry":["&s4)","FORM"]},{"entry":["{",{}]},{"entry":["\u2003risc_regf_ra1._assert(D0,s1.address( ));",{}]},{"entry":["\u2002risc_regf_rd1z._assert(D0,0);",{}]},{"entry":["\u2002Result rBase = risc_regf_rd1.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002int u_offset_lo = s2.range( 0,15);",{}]},{"entry":["\u2002int u_offset_hi = s2.range(16,15);",{}]},{"entry":["\u2002int addr_lo = rBase.range( 0,15) + s3.range( 0,15) + u_offset_lo;",{}]},{"entry":["\u2002int addr_hi = rBase.range( 0,15) + s3.range(16,31) + u_offset_hi;",{}]},{"entry":["\u2002s4.range( 0,15) = vmemLo->uhalf(addr_lo);",{}]},{"entry":["\u2002s4.range(16,31) = vmemHi->uhalf(addr_hi);",{}]},{"entry":["}",{}]},{"entry":["AND .(SA,SB) s1(R4), s2(R4)","BITWISE AND"]},{"entry":["void ISA::OPC_AND_20b_88 (Gpr &s1, Gpr &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002s2 &= s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["AND .(SA,SB) s1(U4), s2(R4)","BITWISE AND, U4"]},{"entry":["void ISA::OPC_AND_20b_89 (U4 &s1, Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2002s2 &= s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["AND .(SB) s1(S3), s2(U20), s3(R4)","BITWISE AND,"]},{"entry":["void ISA::OPC_AND_40b_213 (U3 &s1, U20 &s2, Gpr &s3,Unit &unit)","U20 IMM, BYTE"]},{"entry":["{","ALIGNED"]},{"entry":["\u2002s3 &= (s2 << (s1*8));",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["AND .(V) s1(R4), s2(R4)","BITWISE AND"]},{"entry":["void ISA::OPCV_AND_20b_41 (U4 &s1, Vreg4 &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL)&=zero_extend(s1);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU)&=zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL) == 0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU) == 0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2&=zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["AND .(V,VP) s1(U4), s2(R4)","BITWISE AND, U4"]},{"entry":["void ISA::OPCV_AND_20b_41 (U4 &s1, Vreg4 &s2, Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL)&=zero_extend(s1);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU)&=zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL) == 0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU) == 0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2&=zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["AST .V4 *+s1(R2)[s2(U6)], s3(R2), s4(R4)","ABSOLUTE"]},{"entry":["void ISA::OPCV_AST_20b_406 (Gpr2 &s1, U6 &s2, Vreg2 &s3, Vreg","STORE, IMM"]},{"entry":["&s4)","FORM"]},{"entry":["{",{}]},{"entry":["\u2002risc_vsr_rdz._assert(D0,0);",{}]},{"entry":["\u2002risc_vsr_ra._assert(D0,s3.address( ));",{}]},{"entry":["\u2002Result rVSR = risc_vsr_rdata.read( );",{}]},{"entry":["\u2002bool store_disable = rVSR.bit(8);",{}]},{"entry":["\u2002if(store_disable) return;",{}]},{"entry":["\u2002risc_regf_ra1._assert(D0,s1.address( ));",{}]},{"entry":["\u2002risc_regf_rd1z._assert(D0,0);",{}]},{"entry":["\u2002Result rBase = risc_regf_rd1.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002int u_offset = _unsigned(s2);",{}]},{"entry":["\u2002int addr_lo = rBase.range( 0,15) + s3.range( 0,15) + u_offset;",{}]},{"entry":["\u2002int addr_hi = rBase.range( 0,15) + s3.range(16,31) + u_offset;",{}]},{"entry":["\u2002vmemLo->uhalf(addr_lo) = s4.range( 0,15);",{}]},{"entry":["\u2002vmemHi->uhalf(addr_hi) = s4.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["AST .V4 *+s1(R2)[s2(R4)], s3(R2), s4(R4)","ABSOLUTE"]},{"entry":["void ISA::OPCV_AST_20b_408 (Gpr2 &s1, Vreg &s2, Vreg2 &s3, Vreg","STORE, REG"]},{"entry":["&s4)","FORM"]},{"entry":["{",{}]},{"entry":["\u2002risc_vsr_rdz._assert(D0,0);",{}]},{"entry":["\u2002risc_vsr_ra._assert(D0,s3.address( ));",{}]},{"entry":["\u2002Result rVSR = risc_vsr_rdata.read( );",{}]},{"entry":["\u2002bool store_disable = rVSR.bit(8);",{}]},{"entry":["\u2002if(store_disable) return;",{}]},{"entry":["\u2002risc_regf_ra1._assert(D0,s1.address( ));",{}]},{"entry":["\u2002risc_regf_rd1z._assert(D0,0);",{}]},{"entry":["\u2002Result rBase = risc_regf_rd1.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002int u_offset_lo = s2.range( 0,15);",{}]},{"entry":["\u2002int u_offset_hi = s2.range(16,31);",{}]},{"entry":["\u2002int addr_lo = rBase.range( 0,15) + s3.range( 0,15) + u_offset_lo;",{}]},{"entry":["\u2002int addr_hi = rBase.range( 0,15) + s3.range(16,31) + u_offset_hi;",{}]},{"entry":["\u2002vmemLo->uhalf(addr_lo) = s4.range( 0,15);",{}]},{"entry":["\u2002vmemHi->uhalf(addr_hi) = s4.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["B .(SB) s1(R4)","UNCONDITIONAL"]},{"entry":["void ISA::OPC_B_20b_0 (Gpr &s1)","BRANCH, REG,"]},{"entry":["{","ABSOLUTE"]},{"entry":["\u2002Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["B .(SB) s1(S8)","UNCONDITIONAL"]},{"entry":["void ISA::OPC_B_20b_138 (S8 &s1)","BRANCH, S8"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2002Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["B .(SB) s1(S28)","UNCONDITIONAL"]},{"entry":["void ISA::OPC_B_40b_216 (S28 &s1)","BRANCH, S28"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2002Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BEQ .(SB) s1(R4)","BRANCH EQUAL,"]},{"entry":["void ISA::OPC_BEQ_20b_2 (Gpr &s1,Unit &unit)","REG, ABSOLUTE"]},{"entry":["{",{}]},{"entry":["\u2002if(Csr.bit(EQ,unit)) Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["BEQ .(SB) s1(S8)","BRANCH EQUAL,"]},{"entry":["void ISA::OPC_BEQ_20b_140 (S8 &s1,Unit &unit)","S8 IMM, PC REL"]},{"entry":["{",{}]},{"entry":["\u2002if(Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BEQ .(SB) s1(S28)","BRANCH EQUAL,"]},{"entry":["void ISA::OPC_BEQ_40b_218 (S28 &s1,Unit &unit)","S28 IMM, PC REL"]},{"entry":["{",{}]},{"entry":["\u2002if(Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BGE .(SB) s1(R4)","BRANCH"]},{"entry":["void ISA::OPC_BGE_20b_6 (Gpr &s1,Unit &unit)","GREATER OR"]},{"entry":["{","EQUAL, REG,"]},{"entry":["\u2002if(Csr.bit(GT,unit) || Csr.bit(EQ,unit))","ABSOLUTE"]},{"entry":["\u2002{",{}]},{"entry":["\u2003Pc = s1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["BGE .(SB) s1(S8)","BRANCH"]},{"entry":["void ISA::OPC_BGE_20b_144 (S8 &s1,Unit &unit)","GREATER OR"]},{"entry":["{","EQUAL, S8 IMM,"]},{"entry":["\u2002if(Csr.bit(GT,unit) || Csr.bit(EQ,unit)) Pc += s1;","PC REL"]},{"entry":["}",{}]},{"entry":["BGE .(SB) s1(S28)","BRANCH"]},{"entry":["void ISA::OPC_BGE_40b_222 (S28 &s1,Unit &unit)","GREATER OR"]},{"entry":["{","EQUAL, S28 IMM,"]},{"entry":["\u2002if(Csr.bit(GT,unit) || Csr.bit(EQ,unit)) Pc += s1;","PC REL"]},{"entry":["}",{}]},{"entry":["BGT .(SB) s1(R4)","BRANCH"]},{"entry":["void ISA::OPC_BGT_20b_4 (Gpr &s1,Unit &unit)","GREATER, REG,"]},{"entry":["{","ABSOLUTE"]},{"entry":["\u2002if(Csr.bit(GT,unit)) Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["BGT .(SB) s1(S8)","BRANCH"]},{"entry":["void ISA::OPC_BGT_20b_142 (S8 &s1,Unit &unit)","GREATER, S8"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2002if(Csr.bit(GT,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BGT .(SB) s1(S28)","BRANCH"]},{"entry":["void ISA::OPC_BGT_40b_220 (S28 &s1,Unit &unit)","GREATER, S28"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2002if(Csr.bit(GT,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BHGNE .{SA|SB} s1(R4)","BRANCH ON"]},{"entry":["void ISA::OPC_BHGNE_20b_115 (Gpr &s1)","HG_POSN NOT"]},{"entry":["{","EQUAL HG_SIZE"]},{"entry":["\u2002Result r1 = wrp_hgposn_ne_hgsize.read( );",{}]},{"entry":["\u2002if(r1.value( )) PC = s1;",{}]},{"entry":["\u2002risc_inc_hg_posn._assert(1);",{}]},{"entry":["}",{}]},{"entry":["BKPT .(SB)","BREAK POINT"]},{"entry":["void ISA::OPC_BKPT_20b_12 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2002\/\/This instruction effectively halts",{}]},{"entry":["\u2002\/\/instruction issue until intervention",{}]},{"entry":["\u2002\/\/by the debug system",{}]},{"entry":["\u2002Pc = Pc;",{}]},{"entry":["}",{}]},{"entry":["BLE .(SB) s1(R4)","BRANCH LESS"]},{"entry":["void ISA::OPC_BLE_20b_5 (Gpr &s1,Unit &unit)","OR EQUAL, REG,"]},{"entry":["{","ABSOLUTE"]},{"entry":["\u2002if(Csr.bit(LT,unit) || Csr.bit(EQ,unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Pc = s1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["BLE .(SB) s1(S8)","BRANCH LESS"]},{"entry":["void ISA::OPC_BLE_20b_143 (S8 &s1,Unit &unit)","OR EQUAL, S8"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2002if(Csr.bit(LT,unit) || Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BLE .(SB) s1(S28)","BRANCH LESS"]},{"entry":["void ISA::OPC_BLE_40b_221 (S28 &s1,Unit &unit)","OR EQUAL, S28"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2002if(Csr.bit(LT,unit) || Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BLT .(SB) s1(R4)","BRANCH LESS,"]},{"entry":["void ISA::OPC_BLT_20b_1 (Gpr &s1,Unit &unit)","REG, ABSOLUTE"]},{"entry":["{",{}]},{"entry":["\u2002if(Csr.bit(LT,unit)) Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["BLT .(SB) s1(S8)","BRANCH LESS, S8"]},{"entry":["void ISA::OPC_BLT_20b_139 (S8 &s1,Unit &unit)","IMM, PC REL"]},{"entry":["{",{}]},{"entry":["\u2002if( Csr.bit(LT,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BLT .(SB) s1(S28)","BRANCH LESS,"]},{"entry":["void ISA::OPC_BLT_40b_217 (S28 &s1,Unit &unit)","S28 IMM, PC REL"]},{"entry":["{",{}]},{"entry":["\u2002if(Csr.bit(LT,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BNE .(SB) s1(R4)","BRANCH NOT"]},{"entry":["void ISA::OPC_BNE_20b_3 (Gpr &s1,Unit &unit)","EQUAL, REG,"]},{"entry":["{","ABSOLUTE"]},{"entry":["\u2002if(!Csr.bit(EQ,unit)) Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["BNE .(SB) s1(S8)","BRANCH NOT"]},{"entry":["void ISA::OPC_BNE_20b_141 (S8 &s1,Unit &unit)","EQUAL, S8 IMM,"]},{"entry":["{","PC REL"]},{"entry":["\u2002if(!Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["BNE .(SB) s1(S28)","BRANCH NOT"]},{"entry":["void ISA::OPC_BNE_40b_219 (S28 &s1,Unit &unit)","EQUAL, S28 IMM,"]},{"entry":["{","PC REL"]},{"entry":["\u2002if(!Csr.bit(EQ,unit)) Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["CALL .(SB) s1(R4)","CALL"]},{"entry":["void ISA::OPC_CALL_20b_7 (Gpr &s1)","SUBROUTINE,"]},{"entry":["{","REG, ABSOLUTE"]},{"entry":["\u2002dmem->write(Sp,Pc+3);",{}]},{"entry":["\u2002Sp \u2212= 4;",{}]},{"entry":["\u2002Pc = s1;",{}]},{"entry":["}",{}]},{"entry":["CALL .(SB) s1(S8)","CALL"]},{"entry":["void ISA::OPC_CALL_20b_145 (S8 &s1)","SUBROUTINE, S8"]},{"entry":["{","IMM, PC REL"]},{"entry":["\u2002dmem->write(Sp.value( ),Pc+3);",{}]},{"entry":["\u2002Sp \u2212= 4;",{}]},{"entry":["\u2002Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["CALL .(SB) s1(S28)","CALL"]},{"entry":["void ISA::OPC_CALL_40b_223 (S28 &s1)","SUBROUTINE,"]},{"entry":["{","S28 IMM, PC REL"]},{"entry":["\u2002dmem->write(Sp.value( ),Pc+3);",{}]},{"entry":["\u2002Sp \u2212= 4;",{}]},{"entry":["\u2002Pc += s1;",{}]},{"entry":["}",{}]},{"entry":["CIRC .(SB) s1(R4), s2(S8), s3(R4)","CIRCULAR"]},{"entry":["void ISA::OPC_CIRC_40b_260 (Gpr &s1,S8 &s2,Gpr &s3)",{}]},{"entry":["{",{}]},{"entry":["\u2002int imm_cnst = s2.value( );",{}]},{"entry":["\u2002int bot_off = s1.range(0,3);",{}]},{"entry":["\u2002int top_off = s1.range(4,7);",{}]},{"entry":["\u2002int blk_size = s1.range(8,10);",{}]},{"entry":["\u2002int str_dis \u2002= s1.bit(12);",{}]},{"entry":["\u2002int repeat \u2003= s1.bit(13);",{}]},{"entry":["\u2002int bot_flag = s1.bit(14);",{}]},{"entry":["\u2002int top_flag = s1.bit(15);",{}]},{"entry":["\u2002int pntr \u2003= s1.range(16,23);",{}]},{"entry":["\u2002int size \u2003= s1.range(24,31);",{}]},{"entry":["\u2002int tmp,addr;",{}]},{"entry":["\u2002if(imm_cnst > 0 && bot_flag && imm_cnst > bot_off)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(!repeat)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002tmp = (bot_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002tmp = bot_off;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(imm_cnst < 0 && top_flag && \u2212imm_cnst > top_off)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(!repeat)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003tmp = \u2212(top_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003\u2002else",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003tmp = \u2212top_off;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002tmp = imm_cnst;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002pntr = pntr << blk_size;",{}]},{"entry":["\u2002if(size == 0)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003addr = pntr + tmp;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2002\u2002if((pntr + tmp) >= size)",{}]},{"entry":["\u2002\u2002{",{}]},{"entry":["\u2002\u2002\u2002addr = pntr + tmp \u2212 size;",{}]},{"entry":["\u2002\u2002}",{}]},{"entry":["\u2002\u2002else",{}]},{"entry":["\u2002\u2002{",{}]},{"entry":["\u2002\u2002\u2002if(pntr + tmp < 0)",{}]},{"entry":["\u2002\u2002\u2002{",{}]},{"entry":["\u2002\u2002\u2002\u2002addr = pntr + tmp + size;",{}]},{"entry":["\u2002\u2002\u2002}",{}]},{"entry":["\u2002\u2002\u2002else",{}]},{"entry":["\u2002\u2002\u2002{",{}]},{"entry":["\u2002\u2002\u2002\u2002addr = pntr + tmp;",{}]},{"entry":["\u2002\u2002\u2002}",{}]},{"entry":["\u2002\u2002}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002s3 = addr;",{}]},{"entry":["}",{}]},{"entry":["CLRB .(SA,SB) s1(U2), s2(U2), s3(R4)","CLEAR BYTE"]},{"entry":["void ISA::OPC_CLRB_20b_86 (U2 &s1,U2 &s2,Gpr &s3,Unit &unit)","FIELD"]},{"entry":["{",{}]},{"entry":["\u2002s3.range(s1*8,((s2+1)*8)\u22121) = 0;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["CLRB .(V) s1(U2), s2(U2), s3(R4)","CLEAR BYTE"]},{"entry":["void ISA::OPCV_CLRB_20b_39 (Vreg4 &s1, Vreg4 &s2, Vreg4 &s3)","FIELD"]},{"entry":["{",{}]},{"entry":["\u2002s3.range(s1*8,((s2+1)*8)\u22121) = 0;",{}]},{"entry":["}",{}]},{"entry":["CMP .(SA,SB) s1(S4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_CMP_20b_78 (S4 &s1, Gpr &s2,Unit &unit)","COMPARE, S4"]},{"entry":["{","IMM"]},{"entry":["\u2002Csr.bit(EQ,unit) = s2 == sign_extend(s1);",{}]},{"entry":["\u2002Csr.bit(LT,unit) = s2 < sign_extend(s1);",{}]},{"entry":["\u2002Csr.bit(GT,unit) = s2 > sign_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["CMP .(SA,SB) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_CMP_20b_109 (Gpr &s1, Gpr &s2,Unit &unit)","COMPARE"]},{"entry":["{",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2002Csr.bit(LT,unit) = s2 < s1;",{}]},{"entry":["\u2002Csr.bit(GT,unit) = s2 > s1;",{}]},{"entry":["}",{}]},{"entry":["CMP .(SB) s1(S24),s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_CMP_40b_225 (S24 &s1, Gpr &s2,Unit &unit)","COMPARE, S24"]},{"entry":["{","IMM"]},{"entry":["\u2002Csr.bit(EQ,unit) = s2 == sign_extend(s1);",{}]},{"entry":["\u2002Csr.bit(LT,unit) = s2 < sign_extend(s1);",{}]},{"entry":["\u2002Csr.bit(GT,unit) = s2 > sign_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["CMP .(V,VP) s1(S4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPCV_CMP_20b_60 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","COMPARE, S4"]},{"entry":["{","IMM"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL) == s1;",{}]},{"entry":["\u2003Vr15.bit(LTA) = s2.range(LSBL,MSBL) < s1;",{}]},{"entry":["\u2003Vr15.bit(GTA) = s2.range(LSBL,MSBL) > s1;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU) == s1;",{}]},{"entry":["\u2003Vr15.bit(LTB) = s2.range(LSBU,MSBU) < s1;",{}]},{"entry":["\u2003Vr15.bit(GTB) = s2.range(LSBU,MSBU) > s1;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2 == s1;",{}]},{"entry":["\u2003Vr15.bit(LT) = s2 < s1;",{}]},{"entry":["\u2003Vr15.bit(GT) = s2 > s1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["CMP .(V,VP) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPCV_CMP_20b_60 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","COMPARE"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL) == s1;",{}]},{"entry":["\u2003Vr15.bit(LTA) = s2.range(LSBL,MSBL) < s1;",{}]},{"entry":["\u2003Vr15.bit(GTA) = s2.range(LSBL,MSBL) > s1;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU) == s1;",{}]},{"entry":["\u2003Vr15.bit(LTB) = s2.range(LSBU,MSBU) < s1;",{}]},{"entry":["\u2003Vr15.bit(GTB) = s2.range(LSBU,MSBU) > s1;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2 == s1;",{}]},{"entry":["\u2003Vr15.bit(LT) = s2 < s1;",{}]},{"entry":["\u2003Vr15.bit(GT) = s2 > s1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["CMPU .(SA,SB) s1(U4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_CMPU_20b_77 (U4 &s1, Gpr &s2,Unit &unit)","COMPARE, U4"]},{"entry":["{","IMM"]},{"entry":["\u2002Csr.bit(EQ,unit) = _unsigned(s2) == zero_extend(s1);",{}]},{"entry":["\u2002Csr.bit(LT,unit) = _unsigned(s2) < zero_extend(s1);",{}]},{"entry":["\u2002Csr.bit(GT,unit) = _unsigned(s2) > zero_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["CMPU .(SA,SB) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_CMPU_20b_108 (Gpr &s1, Gpr &s2,Unit &unit)","COMPARE"]},{"entry":["{",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = _unsigned(s2) == _unsigned(s1);",{}]},{"entry":["\u2002Csr.bit(LT,unit) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2002Csr.bit(GT,unit) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["}",{}]},{"entry":["CMPU .(SB) s1(U24),s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_CMPU_40b_224 (U24 &s1, Gpr &s2,Unit &unit)","COMPARE, U24"]},{"entry":["{","IMM"]},{"entry":["\u2002Csr.bit(EQ,unit) = _unsigned(s2) == zero_extend(s1);",{}]},{"entry":["\u2002Csr.bit(LT,unit) = _unsigned(s2) < zero_extend(s1);",{}]},{"entry":["\u2002Csr.bit(GT,unit) = _unsigned(s2) > zero_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["CMPU .(V) s1(U4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPCV_CMPU_20b_59 (Vreg4 &s1, Vreg4 &s2)","COMPARE, U4"]},{"entry":["{","IMM"]},{"entry":["\u2002Vr15.bit(EQ) = _unsigned(s2) == _unsigned(s1);",{}]},{"entry":["\u2002Vr15.bit(LT) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2002Vr15.bit(GT) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["}",{}]},{"entry":["CMPU .(V) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPCV_CMPU_20b_59 (Vreg4 &s1, Vreg4 &s2)","COMPARE"]},{"entry":["{",{}]},{"entry":["\u2002Vr15.bit(EQ) = _unsigned(s2) == _unsigned(s1);",{}]},{"entry":["\u2002Vr15.bit(LT) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2002Vr15.bit(GT) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["}",{}]},{"entry":["CMVEQ .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVEQ_20b_149 (Gpr &s1, Gpr &s2,Unit &unit)","MOVE, EQUAL"]},{"entry":["{",{}]},{"entry":["\u2002s2 = Csr.bit(EQ,unit) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVEQ .(V,VP) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["oid ISA::OPCV_CMVEQ_20b_85 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MOVE, EQUAL,"]},{"entry":["{","R15"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = Vr15.bit(EQA) ? s1.range(LSBL,MSBL) :",{}]},{"entry":["s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = Vr15.bit(EQB) ? s1.range(LSBU,MSBU) :",{}]},{"entry":["s2.range(LSBU,MSBU);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = Vr15.bit(EQ) ? s1 : s2;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["CMVGE .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVGE_20b_155 (Gpr &s1, Gpr &s2, Unit &unit)","MOVE, GREATER"]},{"entry":["{","THAN OR EQUAL"]},{"entry":["\u2002s2 = (Csr.bit(EQ,unit) | Csr.bit(GT,unit)) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVGE .(Vx,VPx,VBx) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPCV_CMVGE_20b_152 (Vreg4 &s1, Vreg4 &s2, Unit","MOVE, GREATER"]},{"entry":["&unit)","THAN OR EQUAL"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(0,15) = (Vr15.bit(tEQA) | Vr15.bit(tGTA)) ? s1.range(0,15)",{}]},{"entry":[": s2.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = (Vr15.bit(tEQB) | Vr15.bit(tGTB)) ? s1.range(16,31)",{}]},{"entry":["\u2002: s2.range(16,31);",{}]},{"entry":["\u2002} else if (isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(0,7) = (Vr15.bit(tEQA) | Vr15.bit(tGTA)) ? s1.range(0,7) :",{}]},{"entry":["s2.range(0,7);",{}]},{"entry":["\u2003s2.range(8,15) = (Vr15.bit(tEQB) | Vr15.bit(tGTB)) ? s1.range(8,15) :",{}]},{"entry":["\u2009s2.range(8,15);",{}]},{"entry":["\u2003s2.range(16,23) = (Vr15.bit(tEQC) | Vr15.bit(tGTC)) ? s1.range(16,23)",{}]},{"entry":["\u2009: s2.range(16,23);",{}]},{"entry":["\u2003s2.range(24,31) = (Vr15.bit(tEQD) | Vr15.bit(tGTD)) ? s1.range(24,31",{}]},{"entry":[") : s2.range(24,31);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = (Vr15.bit(EQ) | Vr15.bit(GT)) ? s1 : s2;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["CMVGT .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVGT_20b_148 (Gpr &s1, Gpr &s2,Unit &unit)","MOVE, GREATER"]},{"entry":["{","THAN"]},{"entry":["\u2002s2 = Csr.bit(GT,unit) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVGT .(V,VP) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPCV_CMVGT_20b_84 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MOVE, GREATER"]},{"entry":["{","THAN, R15,"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = Vr15.bit(GTA) ? s1.range(LSBL,MSBL) :",{}]},{"entry":["s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = Vr15.bit(GTB) ? s1.range(LSBU,MSBU) :",{}]},{"entry":["\u2009s2.range(LSBU,MSBU);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = Vr15.bit(GT) ? s1 : s2;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["CMVLE .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVLE_20b_151 (Gpr &s1, Gpr &s2, Unit &unit)","MOVE, LESS"]},{"entry":["{","THAN OR EQUAL"]},{"entry":["\u2002s2 = (Csr.bit(EQ,unit) | Csr.bit(LT,unit)) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVLE .(Vx,VPx,VBx) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPCV_CMVLE_20b_151 (Vreg4 &s1, Vreg4 &s2, Unit","MOVE, LESS"]},{"entry":["&unit)","THAN OR EQUAL"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(0,15) = (Vr15.bit(tEQA) | Vr15.bit(tLTA)) ? s1.range(0,15) :",{}]},{"entry":["\u2009s2.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = (Vr15.bit(tEQB) | Vr15.bit(tLTB)) ? s1.range(16,31)",{}]},{"entry":["\u2002: s2.range(16,31);",{}]},{"entry":["\u2002} else if (isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(0,7) = (Vr15.bit(tEQA) | Vr15.bit(tLTA)) ? s1.range(0,7) :",{}]},{"entry":["s2.range(0,7);",{}]},{"entry":["\u2003s2.range(8,15) = (Vr15.bit(tEQB) | Vr15.bit(tLTB)) ? s1.range(8,15) :",{}]},{"entry":["\u2009s2.range(8,15);",{}]},{"entry":["\u2003s2.range(16,23) = (Vr15.bit(tEQC) | Vr15.bit(tLTC)) ? s1.range(16,23)",{}]},{"entry":["\u2009: s2.range(16,23);",{}]},{"entry":["\u2003s2.range(24,31) = (Vr15.bit(tEQD) | Vr15.bit(tLTD)) ? s1.range(24,31)",{}]},{"entry":["\u2009: s2.range(24,31);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = (Vr15.bit(EQ) | Vr15.bit(LT)) ? s1 : s2;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["CMVLT .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVLT_20b_147 (Gpr &s1, Gpr &s2,Unit &unit)","MOVE, LESS"]},{"entry":["{","THAN"]},{"entry":["\u2002s2 = Csr.bit(LT,unit) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVLT .(V,VP) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPCV_CMVLT_20b_83 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MOVE, LESS"]},{"entry":["{","THAN, R15"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = Vr15.bit(LTA) ? s1.range(LSBL,MSBL) :",{}]},{"entry":["s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = Vr15.bit(LTB) ? s1.range(LSBU,MSBU) :",{}]},{"entry":["s2.range(LSBU,MSBU);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = Vr15.bit(LT) ? s1 : s2;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["CMVNE .(SA,SB) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPC_CMVNE_20b_150 (Gpr &s1, Gpr &s2,Unit &unit)","MOVE, NOT"]},{"entry":["{","EQUAL"]},{"entry":["\u2002s2 = !Csr.bit(EQ,unit) ? s1 : s2;",{}]},{"entry":["}",{}]},{"entry":["CMVNE .(V,VP) s1(R4), s2(R4)","CONDITIONAL"]},{"entry":["void ISA::OPCV_CMVNE_20b_86 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MOVE, NOT"]},{"entry":["{","EQUAL, R15"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = !Vr15.bit(EQA) ? s1.range(LSBL,MSBL) :",{}]},{"entry":["s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = !Vr15.bit(EQB) ? s1.range(LSBU,MSBU)",{}]},{"entry":[": s2.range(LSBU,MSBU);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = !Vr15.bit(EQ) ? s1 : s2;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["CONS .{V1|V2|V3|V4} s1(R4), s2(R4), s3(R4)","CONCATENATE"]},{"entry":["void ISA::OPCV_CONS_20b_398 (Vreg &s1, Vreg &s2, Vreg &s3)","AND SHIFT"]},{"entry":["{",{}]},{"entry":["\u2002s3.range(24,31) = s2.range(0,7);",{}]},{"entry":["\u2002s3.range(0,23) = s1.range(8,31);",{}]},{"entry":["}",{}]},{"entry":["DCBNZ .(SB) s1(R4), s2(R4)","DECREMENT,"]},{"entry":["void ISA::OPC_DCBNZ_20b_152 (Gpr &s1, Gpr &s2)","COMPARE,"]},{"entry":["{","BRANCH NON-"]},{"entry":["\u2002\u2212\u2212s1;","ZERO"]},{"entry":["\u2002if(s1 != 0)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Pc = s2;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Pc = (cregs[aPC]+1)>>1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["DCBNZ .(SB) s1(R4),s2(U16)","DECREMENT,"]},{"entry":["void ISA::OPC_DCBNZ_40b_247 (Gpr &s1,U16 &s2)","COMPARE,"]},{"entry":["{","BRANCH NON-"]},{"entry":["\u2002\u2212\u2212s1;","ZERO"]},{"entry":["\u2002if(s1 != 0) Pc = s2;",{}]},{"entry":["}",{}]},{"entry":["END .(SA,SB)","END OF THREAD"]},{"entry":["void ISA::OPC_END_20b_10 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2002risc_is_end._assert(1);",{}]},{"entry":["\u2002Pc = Pc;",{}]},{"entry":["}",{}]},{"entry":["EXTB .(SA,SB) s1(U2), s2(U2), s3(R4)","EXTRACT"]},{"entry":["void ISA::OPC_EXTB_20b_122 (U2 &s1,U2 &s2,Gpr &s3,Unit &unit)","SIGNED BYTE"]},{"entry":["{","FIELD"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp = s3;",{}]},{"entry":["\u2002s3.clear( );",{}]},{"entry":["\u2002s3.range(0,s2*8) = sign_extend(tmp.range(s1*8,((s2+1)*8)\u22121));",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["EXTB .(V) s1(U2), s2(U2), s3(R4)","EXTRACT"]},{"entry":["void ISA::OPCV_EXTB_20b_73 (U2 &s1, U2 &s2, Vreg4 &s3)","SIGNED BYTE"]},{"entry":["{","FIELD"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp = s3;",{}]},{"entry":["\u2002s3.clear( );",{}]},{"entry":["\u2002s3.range(0,s2*8) = sign_extend(tmp.range(s1*8,((s2+1)*8)\u22121));",{}]},{"entry":["}",{}]},{"entry":["EXTBU .(SA,SB) s1(U2), s2(U2), s3(R4)","EXTRACT"]},{"entry":["void ISA::OPC_EXTBU_20b_87 (U2 &s1,U2 &s2,Gpr &s3,Unit &unit)","UNSIGNED BYTE"]},{"entry":["{","FIELD"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp = s3;",{}]},{"entry":["\u2002s3.clear( );",{}]},{"entry":["\u2002s3 = tmp.range(s1*8,((s2+1)*8)\u22121);",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["EXTBU .(V) s1(U2), s2(U2), s3(R4)","EXTRACT"]},{"entry":["void ISA::OPCV_EXTBU_20b_40 (U2 &s1, U2 &s2, Vreg4 &s3)","UNSIGNED BYTE"]},{"entry":["{","FIELD"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp = s3;",{}]},{"entry":["\u2002s3.clear( );",{}]},{"entry":["\u2002s3 = tmp.range(s1*8,((s2+1)*8)\u22121);",{}]},{"entry":["}",{}]},{"entry":["EXTHH.(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_EXTHH_20b_294 (Vreg4 &s1, Vreg4 &s2)","EXTRACT,"]},{"entry":["{","HIGH\/HIGH"]},{"entry":["\u2002s2.range(16,31) = _unsigned(s1.range(24,31));",{}]},{"entry":["\u2002s2.range(0,15) = _unsigned(s1.range(8,15));",{}]},{"entry":["}",{}]},{"entry":["EXTHL .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_EXTHL_20b_293 (Vreg4 &s1, Vreg4 &s2)","EXTRACT,"]},{"entry":["{","HIGH\/LOW"]},{"entry":["\u2002s2.range(16,31) = _unsigned(s1.range(24,31));",{}]},{"entry":["\u2002s2.range(0,15) = _unsigned(s1.range(0,7));",{}]},{"entry":["}",{}]},{"entry":["EXTLH .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_EXTLH_20b_292 (Vreg4 &s1, Vreg4 &s2)","EXTRACT,"]},{"entry":["{","LOW\/HIGH"]},{"entry":["\u2002s2.range(16,31) = _unsigned(s1.range(16,23));",{}]},{"entry":["\u2002s2.range(0,15) = _unsigned(s1.range(8,15));",{}]},{"entry":["}",{}]},{"entry":["EXTLL .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_EXTLL_20b_291 (Vreg4 &s1, Vreg4 &s2)","EXTRACT,"]},{"entry":["{","LOW\/LOW"]},{"entry":["\u2002s2.range(16,31) = _unsigned(s1.range(16,23));",{}]},{"entry":["\u2002s2.range(0,15) = _unsigned(s1.range(0,7));",{}]},{"entry":["}",{}]},{"entry":["IDLE .(SB)","REPETITIVE NOP"]},{"entry":["void ISA::OPC_IDLE_20b_13 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2002\/\/This instruction effectively halts",{}]},{"entry":["\u2002\/\/instruction issue until an external",{}]},{"entry":["\u2002\/\/event occurs.",{}]},{"entry":["\u2002Pc = Pc;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+LBR[s1(U4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_50 (U4 &s1,Gpr &s2)","BYTE, LBR, +U4"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->byte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+LBR[s1(R4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_55 (Gpr &s1, Gpr &s2)","BYTE, LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->byte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *LBR++[s1(U4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_60 (U4 &s1, Gpr &s2)","BYTE, LBR, +U4"]},{"entry":["{","OFFSET POST"]},{"entry":["\u2002s2 = dmem->byte(Lbr);","ADJ"]},{"entry":["Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *LBR++[s1(R4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_65 (Gpr &s1, Gpr &s2)","BYTE, LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2 = dmem->byte(Lbr);","ADJ"]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+s1(R4), s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_70 (Gpr &s1, Gpr &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->byte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *s1(R4)++, s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_20b_75 (Gpr &s1, Gpr &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2 = dmem->byte(s1);","INC"]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+s1[s2(U20)], s3(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_188 (Gpr &s1, U20 &s2, Gpr &s3)","BYTE, +U20"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s3 = dmem->byte(s1+s2);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *s1++[s2(U20)], s3(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_193 (Gpr &s1, U20 &s2, Gpr &s3)","BYTE, +U20"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s3 = dmem->byte(s1);","ADJ"]},{"entry":["\u2002s1 += s2;",{}]},{"entry":["}",{}]},{"entry":["LDB .(V3) *+s1(R4), s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPCV_LDB_20b_25 (Vreg4 &s1, Vreg4 &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->byte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(V3) *s1(R4)++, s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPCV_LDB_20b_30 (Vreg4 &s1, Vreg4 &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","INC"]},{"entry":["\u2002s2 = dmem->byte(s1);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+LBR[s1(U24)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_198 (U24 &s1, Gpr &s2)","BYTE, LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->byte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *LBR++[s1(U24)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_203 (U24 &s1, Gpr &s2)","BYTE, LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2 = dmem->byte(Lbr+s1);","ADJ"]},{"entry":["\u2002++Lbr;",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *s1(U24),s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDB_40b_208 (U24 &s1, Gpr &s2)","BYTE, U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2002s2 = dmem->byte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDB .(SB) *+SP[s1(U24)], s2(R4)","LOAD BYTE, SP,"]},{"entry":["void ISA::OPC_LDB_40b_258 (U24 &s1, Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002s2 = sign_extend(dmem->byte(Sp+s1));",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+LBR[s1(U4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_47 (U4 &s1,Gpr &s2)","BYTE, LBR, +U4"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->ubyte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+LBR[s1(R4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_52 (Gpr &s1, Gpr &s2)","BYTE, LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->ubyte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *LBR++[s1(U4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_57 (U4 &s1, Gpr &s2)","BYTE, LBR, +U4"]},{"entry":["{","OFFSET POST"]},{"entry":["\u2002s2.clear( );","ADJ"]},{"entry":["\u2002s2 = dmem->ubyte(Lbr);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *LBR++[s1(R4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_62 (Gpr &s1, Gpr &s2)","BYTE, LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","ADJ"]},{"entry":["\u2002s2 = dmem->ubyte(Lbr);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+s1(R4), s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_67 (Gpr &s1, Gpr &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->ubyte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *s1(R4)++, s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_20b_72 (Gpr &s1, Gpr &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","INC"]},{"entry":["\u2002s2 = dmem->ubyte(s1);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+s1[s2(U20)], s3(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_185 (Gpr &s1, U20 &s2, Gpr &s3)","BYTE, +U20"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s3.clear( );",{}]},{"entry":["\u2002s3.byte(0) = dmem->ubyte(s1+s2);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *s1++[s2(U20)], s3(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_190 (Gpr &s1, U20 &s2, Gpr &s3)","BYTE, +U20"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s3.clear( );","ADJ"]},{"entry":["\u2002s3.byte(0) = dmem->ubyte(s1+s2);",{}]},{"entry":["\u2002s1+= s2;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+LBR[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_195 (U24 &s1, Gpr &s2)","BYTE, LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2.byte(0) = dmem->ubyte(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *LBR++[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_200 (U24 &s1, Gpr &s2)","BYTE, LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","ADJ"]},{"entry":["\u2002s2.byte(0) = dmem->ubyte(Lbr);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *s1(U24),s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_205 (U24 &s1, Gpr &s2)","BYTE, U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2.byte(0) = dmem->ubyte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(SB) *+SP[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDBU_40b_255 (U24 &s1,Gpr &s2)","BYTE, SP, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2.byte(0) = dmem->ubyte(Sp+s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(V3) *+s1(R4), s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPCV_LDBU_20b_22 (Vreg4 &s1, Vreg4 &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->ubyte(s1);",{}]},{"entry":["}",{}]},{"entry":["LDBU .(V3) *s1(R4)++, s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPCV_LDBU_20b_27 (Vreg4 &s1, Vreg4 &s2)","BYTE, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","INC"]},{"entry":["\u2002s2 = dmem->ubyte(s1);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+LBR[s1(U4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_51 (U4 &s1,Gpr &s2)","HALF, LBR, +U4"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->half(Lbr+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+LBR[s1(R4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_56 (Gpr &s1, Gpr &s2)","HALF, LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->half(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *LBR++[s1(U4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_61 (U4 &s1, Gpr &s2)","HALF, LBR, +U4"]},{"entry":["{","OFFSET POST"]},{"entry":["\u2002s2 = dmem->half(Lbr);","ADJ"]},{"entry":["\u2002Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *LBR++[s1(R4)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_66 (Gpr &s1, Gpr &s2)","HALF, LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2 = dmem->half(Lbr);","ADJ"]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+s1(R4), s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_71 (Gpr &s1, Gpr &s2)","HALF, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->half(s1);",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *s1(R4)++, s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_20b_76 (Gpr &s1, Gpr &s2)","HALF, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2 = dmem->half(s1);","INC"]},{"entry":["\u2002s1 += 2;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+s1[s2(U20)], s3(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_189 (Gpr &s1, U20 &s2, Gpr &s3)","HALF, +U20"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s3 = dmem->half(s1+(s2<<1));",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *s1++[s2(U20)], s3(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_194 (Gpr &s1, U20 &s2, Gpr &s3)","HALF, +U20"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s3 = dmem->half(s1);","ADJ"]},{"entry":["\u2002s1 += s2<<1;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+LBR[s1(U24)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_199 (U24 &s1, Gpr &s2)","HALF, LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->half(Lbr+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *LBR++[s1(U24)], s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_204 (U24 &s1, Gpr &s2)","HALF, LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2 = dmem->half(Lbr);","ADJ"]},{"entry":["\u2002Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *s1(U24),s2(R4)","LOAD SIGNED"]},{"entry":["void ISA::OPC_LDH_40b_209 (U24 &s1, Gpr &s2)","HALF, U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2002s2 = dmem->half(s1<<1);",{}]},{"entry":["}",{}]},{"entry":["LDH .(SB) *+SP[s1(U24)], s2(R4)","LOAD HALF, SP,"]},{"entry":["void ISA::OPC_LDH_40b_259 (U24 &s1, Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002s2 = sign_extend(dmem->half(Sp+(s1<<1)));",{}]},{"entry":["}",{}]},{"entry":["LDH .(V3) *+s1(R4), s2(R4)","OAD SIGNED"]},{"entry":["void ISA::OPCV_LDH_20b_26 (Vreg4 &s1, Vreg4 &s2)","HALF, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->half(s1);",{}]},{"entry":["}",{}]},{"entry":["LDH .(V3) *s1(R4)++, s2(R4)","LOAD SIGNED"]},{"entry":["oid ISA::OPCV_LDH_20b_31 (Vreg4 &s1, Vreg4 &s2)","HALF, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","INC"]},{"entry":["\u2002s2 = dmem->half(s1);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+LBR[s1(U4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_48 (U4 &s1,Gpr &s2)","HALF, LBR, +U4"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->uhalf(Lbr+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+LBR[s1(R4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_53 (Gpr &s1, Gpr &s2)","HALF, LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->uhalf(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *LBR++[s1(U4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_58 (U4 &s1, Gpr &s2)","HALF, LBR, +U4"]},{"entry":["{","OFFSET POST"]},{"entry":["\u2002s2.clear( );","ADJ"]},{"entry":["\u2002s2 = dmem->uhalf(Lbr);",{}]},{"entry":["\u2002Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *LBR++[s1(R4)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_63 (Gpr &s1, Gpr &s2)","HALF, LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","ADJ"]},{"entry":["\u2002s2 = dmem->uhalf(Lbr);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+s1(R4), s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_68 (Gpr &s1, Gpr &s2)","HALF, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->uhalf(s1);",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *s1(R4)++, s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_20b_73 (Gpr &s1, Gpr &s2)","HALF, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","INC"]},{"entry":["\u2002s2 = dmem->uhalf(s1);",{}]},{"entry":["\u2002s1 += 2;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+s1[s2(U20)], s3(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_186 (Gpr &s1, U20 &s2, Gpr &s3)","HALF, +U20"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s3.clear( );",{}]},{"entry":["\u2002s3.half(0) = dmem->uhalf(s1+(s2<<1));",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *s1++[s2(U20)], s3(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_191 (Gpr &s1, U20 &s2, Gpr &s3)","HALF, +U20"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s3.clear( );","ADJ"]},{"entry":["\u2002s3.half(0) = dmem->uhalf(s1);",{}]},{"entry":["\u2002s1 += s2<<1;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+LBR[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_196 (U24 &s1, Gpr &s2)","HALF, LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2.half(0) = dmem->uhalf(Lbr+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *LBR++[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_201 (U24 &s1, Gpr &s2)","HALF, LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","ADJ"]},{"entry":["\u2002s2.half(0) = dmem->uhalf(Lbr);",{}]},{"entry":["\u2002Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *s1(U24),s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_206 (U24 &s1, Gpr &s2)","HALF, U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2.half(0) = dmem->uhalf(s1<<1);",{}]},{"entry":["}",{}]},{"entry":["LDHU .(SB) *+SP[s1(U24)], s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPC_LDHU_40b_256 (U24 &s1,Gpr &s2)","HALF, SP, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2.half(0) = dmem->uhalf(Sp+(s1<<1));",{}]},{"entry":["}",{}]},{"entry":["LDHU .(V3) *+s1(R4), s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPCV_LDHU_20b_23 (Vreg4 &s1, Vreg4 &s2)","HALF, ZERO"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->uhalf(s1);",{}]},{"entry":["}",{}]},{"entry":["LDHU .(V3) *s1(R4)++, s2(R4)","LOAD UNSIGNED"]},{"entry":["void ISA::OPCV_LDHU_20b_23 (Vreg4 &s1, Vreg4 &s2)","HALF, ZERO"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2.clear( );","INC"]},{"entry":["\u2002s2 = dmem->uhalf(s1);",{}]},{"entry":["}",{}]},{"entry":["LDRF .SB s1(R4), s2(R4)","LOAD REGISTER"]},{"entry":["void ISA::OPC_LDRF_20b_80 (Gpr &s1, Gpr &s2)","FILE RANGE"]},{"entry":["{",{}]},{"entry":["\u2002if(s1 <= s2)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003for(int r=s2.address( );r<s1.address( );\u2212\u2212r)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002Sp += 4;",{}]},{"entry":["\u2003\u2002gprs[r] = dmem->read(Sp.value( ));",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["LDSYS .(SB) s1(R4), s2(R4)","LOAD SYSTEM"]},{"entry":["void ISA::OPC_LDSYS_20b_162 (Gpr &s1, Gpr &s2)","ATTRIBUTE"]},{"entry":["{","(GLS)"]},{"entry":["\u2002gls_is_load._assert(1);",{}]},{"entry":["\u2002gls_attr_valid._assert(1);",{}]},{"entry":["\u2002gls_is_ldsys._assert(1);",{}]},{"entry":["\u2002gls_regf_addr._assert(s2.address( ));",{}]},{"entry":["\u2002gls_sys_addr._assert(s1);",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+LBR[s1(U4)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_49 (U4 &s1,Gpr &s2)","LBR, +U4 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->word(Lbr+(s1<<2));",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+LBR[s1(R4)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_54 (Gpr &s1, Gpr &s2)","LBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->word(Lbr+s1);",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *LBR++[s1(U4)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_59 (U4 &s1, Gpr &s2)","LBR, +U4 OFFSET"]},{"entry":["{","POST ADJ"]},{"entry":["\u2002s2 = dmem->half(Lbr);",{}]},{"entry":["\u2002Lbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *LBR++[s1(R4)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_64 (Gpr &s1, Gpr &s2)","LBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2 = dmem->word(Lbr);","ADJ"]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+s1(R4), s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_69 (Gpr &s1, Gpr &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002s2 = dmem->word(s1);",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *s1(R4)++, s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_20b_74 (Gpr &s1, Gpr &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2002s2 = dmem->word(s1);",{}]},{"entry":["\u2002s1 += 4;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+s1[s2(U20)], s3(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_40b_187 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002s3 = dmem->word(s1+(s2<<2));",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *s1++[s2(U20)], s3(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_40b_192 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2002s3 = dmem->word(s1);",{}]},{"entry":["\u2002s1 += s2<<2;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+LBR[s1(U24)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_40b_197 (U24 &s1, Gpr &s2)","LBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002s2 = dmem->word(Lbr+(s1<<2));",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *LBR++[s1(U24)], s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPC_LDW_40b_202 (U24 &s1, Gpr &s2)","LBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002s2 = dmem->word(Lbr);","ADJ"]},{"entry":["\u2002Lbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *s1(U24),s2(R4)","LOAD WORD, U24"]},{"entry":["void ISA::OPC_LDW_40b_207 (U24 &s1, Gpr &s2)","IMM ADDRESS"]},{"entry":["{",{}]},{"entry":["\u2002s2 = dmem->word(s1<<2);",{}]},{"entry":["}",{}]},{"entry":["LDW .(SB) *+SP[s1(U24)], s2(R4)","LOAD WORD, SP,"]},{"entry":["void ISA::OPC_LDW_40b_257 (U24 &s1, Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002s2.word(0) = dmem->word(Sp+(s1<<2));",{}]},{"entry":["}",{}]},{"entry":["LDW .(V3) *+s1(R4), s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPCV_LDW_20b_24 (Vreg4 &s1, Vreg4 &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->word(s1);",{}]},{"entry":["}",{}]},{"entry":["LDW .(V3) *s1(R4)++, s2(R4)","LOAD WORD,"]},{"entry":["void ISA::OPCV_LDW_20b_29 (Vreg4 &s1, Vreg4 &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2 = dmem->word(s1);",{}]},{"entry":["LMOD .(SA,SB) s1(R4), s2(R4)","LEFT MOST ONE"]},{"entry":["void ISA::OPC_LMOD_20b_82 (Gpr &s1, Gpr &s2, Unit &unit)","DETECT"]},{"entry":["{",{}]},{"entry":["\u2002int test = 1;",{}]},{"entry":["\u2002int width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2002int i;",{}]},{"entry":["\u2002for(i=0;i<=width;++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002s2 = i;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["LMOD .(V,VP) s1(R4), s2(R4)","LEFT MOST ONE"]},{"entry":["void ISA::OPCV_LMOD_20b_35 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","DETECT"]},{"entry":["{",{}]},{"entry":["\u2002int test = 1;",{}]},{"entry":["\u2002int width,i;",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003width = (s1.size( )>>1) \u2212 1;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2003width\u2003\u2003= s1.size( ) \u2212 1;",{}]},{"entry":["\u2003int numbits = (s1.size( )>>1)\u22121;",{}]},{"entry":["\u2003for(i=0;i<=numbits;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2.range(16,31) = i;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["LMODC .(SA,SB) s1(R4), s2(R4)","LEFT MOST ONE"]},{"entry":["void ISA::OPC_LMODC_20b_83 (Gpr &s1, Gpr &s2, Unit &unit)","DETECT W\/"]},{"entry":["{","CLEAR"]},{"entry":["\u2002int test = 1;",{}]},{"entry":["\u2002int width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2002int i;",{}]},{"entry":["\u2002for(i=0;i<=width;++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(s1.bit(width\u2212i) == test)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002s1.bit(width\u2212i) = !(test&0x1);",{}]},{"entry":["\u2003\u2002break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002s2 = i;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["LMODC .(V,VP) s1(R4), s2(R4)","LEFT MOST ONE"]},{"entry":["void ISA::OPCV_LMODC_20b_36 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","DETECT W\/"]},{"entry":["{","CLEAR"]},{"entry":["\u2002int test = 1;",{}]},{"entry":["\u2002int width,i;",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["{",{}]},{"entry":["\u2003width = (s1.size( )>>1) \u2212 1;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(s1.bit(width\u2212i) == test)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003s1.bit(width\u2212i) = !(test&0x1);",{}]},{"entry":["\u2003\u2003break;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2003width\u2003\u2003= s1.size( ) \u2212 1;",{}]},{"entry":["\u2003int numbits = (s1.size( )>>1)\u22121;",{}]},{"entry":["\u2003for(i=0;i<=numbits;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(s1.bit(width\u2212i) == test)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003s1.bit(width\u2212i) = !(test&0x1);",{}]},{"entry":["\u2003\u2003break;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2.range(16,31) = i;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2002width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(s1.bit(width\u2212i) == test)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003s1.bit(width\u2212i) = !(test&0x1);",{}]},{"entry":["\u2003\u2003break;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["LMZD .(SA,SB) s1(R4), s2(R4)","LEFT MOST ZERO"]},{"entry":["void ISA::OPC_LMZD_20b_84 (Gpr &s1, Gpr &s2, Unit &unit)","DETECT"]},{"entry":["{",{}]},{"entry":["\u2002int test = 0;",{}]},{"entry":["\u2002int width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2002int i;",{}]},{"entry":["\u2002for(i=0;i<=width;++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002s2 = i;",{}]},{"entry":["\u2002Csr.bi",{}]},{"entry":["LMZD .(V,VP) s1(R4), s2(R4)","LEFT MOST ZERO"]},{"entry":["void ISA::OPCV_LMZD_20b_37 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","DETECT"]},{"entry":["{",{}]},{"entry":["\u2002int test = 0;",{}]},{"entry":["\u2002int width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2002int i;",{}]},{"entry":["\u2002for(i=0;i<=width;++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002s2 = i;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["LMZDS .(SA,SB) s1(R4), s2(R4)","LEFT MOST ZERO"]},{"entry":["void ISA::OPC_LMZDS_20b_85 (Gpr &s1, Gpr &s2, Unit &unit)","DETECT W\/ SET"]},{"entry":["{",{}]},{"entry":["\u2002int test = 0;",{}]},{"entry":["\u2002int width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2002int i;",{}]},{"entry":["\u2002for(i=0;i<=width;++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(s1.bit(width\u2212i) == test)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002s1.bit(width\u2212i) = !(test&0x1);",{}]},{"entry":["\u2003\u2002break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002s2 = i;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["LMZDS .(V,VP) s1(R4), s2(R4)","LEFT MOST ZERO"]},{"entry":["void ISA::OPCV_LMZDS_20b_38 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","DETECT W\/ SET"]},{"entry":["{",{}]},{"entry":["\u2002int test = 0;",{}]},{"entry":["\u2002int width,i;",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003width = (s1.size( )>>1) \u2212 1;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003width\u2003\u2003= s1.size( ) \u2212 1;",{}]},{"entry":["\u2003int numbits = (s1.size( )>>1)\u22121;",{}]},{"entry":["\u2003for(i=0;i<=numbits;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2.range(16,31) = i;",{}]},{"entry":["\u2003width = s1.size( ) \u2212 1;",{}]},{"entry":["\u2003for(i=0;i<=width;++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(s1.bit(width\u2212i) == test) break;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2 = i;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MAX .(SA,SB) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_MAX_20b_121 (Gpr &s1, Gpr &s2,Unit &unit)","MAXIMUM"]},{"entry":["{",{}]},{"entry":["\u2002Csr.bit(LT,unit) = s2 < s1;",{}]},{"entry":["\u2002Csr.bit(GT,unit) = s2 > s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2002if(Csr.bit(LT,unit)) s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MAX .(V,VP) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPCV_MAX_20b_72 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MAXIMUM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(LTA) = (s2.range(0,15)) < (s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(GTA) = (s2.range(0,15)) > (s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(EQA) = (s2.range(0,15)) == (s1.range(0,15));",{}]},{"entry":["\u2003if(Vr15.bit(LTA)) (s2.range(0,15)) = (s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(LTB) = (s2.range(16,31)) < (s1.range(16,31));",{}]},{"entry":["\u2003Vr15.bit(GTB) = (s2.range(16,31)) > (s1.range(16,31));",{}]},{"entry":["\u2003Vr15.bit(EQB) = (s2.range(16,31)) == (s1.range(16,31));",{}]},{"entry":["\u2003if(Vr15.bit(LTB)) (s2.range(16,31)) = (s1.range(16,31));",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(LT) = (s2) < (s1);",{}]},{"entry":["\u2003Vr15.bit(GT) = (s2) > (s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = (s2) == (s1);",{}]},{"entry":["\u2003if(Vr15.bit(LT)) (s2) = (s1);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MAX2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAX2_20b_133 (Gpr &s1, Gpr &s2)","MAXIMUM w\/"]},{"entry":["{","REORDER"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp.range(0,15) = s1.range(16,31) > s2.range( 0,15)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s1.range(16,31) : s2.range( 0,15);",{}]},{"entry":["\u2002tmp.range(16,31) = s1.range( 0,15) > s2.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s1.range( 0,15) : s2.range(16,31);",{}]},{"entry":["\u2002s2.range(16,31) = s1.range(16,31) > s2.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s1.range(16,31) : s2.range(16,31);",{}]},{"entry":["\u2002s2.range( 0,15) = s1.range(16,31) > s2.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? tmp.range(16,31) : tmp.range( 0,15);",{}]},{"entry":["}",{}]},{"entry":["MAX2 .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_MAX2_20b_133 (Vreg4 &s1, Vreg4 &s2)","MAXIMUM w\/"]},{"entry":["{","REORDER"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp.range(16,31) = s1.range(16,31)>=s2.range(16,31) ?",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003s1.range(16,31) : s2.range(16,31);",{}]},{"entry":["\u2002tmp.range(0,15) = s1.range(0,15)>=s2.range(0,15) ?",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003s1.range(0,15) : s2.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = tmp.range(16,31)>=tmp.range(0,15) ?",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003tmp.range(16,31) : tmp.range(0,15);",{}]},{"entry":["\u2002s2.range(0,15) = tmp.range(16,31)>=tmp.range(0,15) ?",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003tmp.range(0,15) : tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MAX2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAX2U_20b_156 (Gpr &s1, Gpr &s2)","MAXIMUM w\/"]},{"entry":["{","REORDER,"]},{"entry":["\u2002Result tmp;","UNSIGNED"]},{"entry":["\u2002tmp.range(0,15) = (s1.range(0,15) >=s2.range(0,15)) ? s1.range(0,15):",{}]},{"entry":["s2.range(0,15);",{}]},{"entry":["\u2002tmp.range(16,31) = (s1.range(16,31) >=s2.range(16,31)) ? s1.range(16,31)",{}]},{"entry":[":s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = (tmp.range(16,31)>=tmp.range(0,15)) ? tmp.range(16,31)",{}]},{"entry":[":tmp.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (tmp.range(16,31)>=tmp.range(0,15)) ? tmp.range(0,15)",{}]},{"entry":[":tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MAX2U .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_MAX2U_20b_153 (Vreg4 &s1, Vreg4 &s2)","MAXIMUM w\/"]},{"entry":["{","REORDER,"]},{"entry":["\u2002Result tmp;","UNSIGNED"]},{"entry":["\u2002tmp.range(0,15) = (s1.range(0,15) >=s2.range(0,15)) ? s1.range(0,15)",{}]},{"entry":[":s2.range(0,15);",{}]},{"entry":["\u2002tmp.range(16,31) = (s1.range(16,31) >=s2.range(16,31)) ? s1.range(16,31)",{}]},{"entry":[":s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = (tmp.range(16,31)>=tmp.range(0,15)) ? tmp.range(16,31)",{}]},{"entry":[":tmp.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (tmp.range(16,31)>=tmp.range(0,15)) ? tmp.range(0,15)",{}]},{"entry":[":tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MAXH .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAXH_20b_131 (Gpr &s1, Gpr &s2)","MAXIMUM"]},{"entry":["{",{}]},{"entry":["\u2002s2.range( 0,15) = s2.range( 0,15) > s1.range( 0,15)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range( 0,15) : s1.range( 0,15);",{}]},{"entry":["\u2002s2.range(16,31) = s2.range(16,31) > s1.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MAXHU .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAXHU_20b_132 (Gpr &s1, Gpr &s2)","MAXIMUM,"]},{"entry":["{","UNSIGNED"]},{"entry":["\u2002s2.range( 0,15) = _unsigned(s2.range( 0,15)) > _unsigned(s1.range( 0,15))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range( 0,15) : s1.range( 0,15);",{}]},{"entry":["\u2002s2.range(16,31) = _unsigned(s2.range(16,31)) > _unsigned(s1.range(16,",{}]},{"entry":["31))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MAXMAX2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAXMAX2_20b_157 (Gpr &s1, Gpr &s2)","MAXIMUM AND"]},{"entry":["{","2nd MAXIMUM"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp.range(16,31) = (s1.range(0,15)>=s2.range(16,31)) ? s1.range(0,15)",{}]},{"entry":["\u2002: s2.range(16,31);",{}]},{"entry":["\u2002tmp.range(0,15) = (s1.range(16,31)>=s2.range(0,15)) ? s1.range(16,31)",{}]},{"entry":["\u2002: s2.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (s1.range(16,31)>=s2.range(16,31)) ? s1.range(16,31)",{}]},{"entry":[": s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = (s1.range(16,31)>=s2.range(16,31)) ? tmp.range(16,31)",{}]},{"entry":[": tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MAXMAX2 .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_MAXMAX2_20b_154 (Vreg4 &s1, Vreg4 &s2)","MAXIMUM AND"]},{"entry":["{","2nd MAXIMUM"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp.range(16,31) = (s1.range(0,15)>=s2.range(16,31)) ? s1.range(0,15)",{}]},{"entry":["\u2002: s2.range(16,31);",{}]},{"entry":["\u2002tmp.range(0,15) = (s1.range(16,31)>=s2.range(0,15)) ? s1.range(16,31)",{}]},{"entry":["\u2002: s2.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (s1.range(16,31)>=s2.range(16,31)) ? s1.range(16,31)",{}]},{"entry":[": s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = (s1.range(16,31)>=s2.range(16,31)) ? tmp.range(16,31)",{}]},{"entry":[": tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MAXMAX2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MAXMAX2U_20b_158 (Gpr &s1, Gpr &s2)","MAXIMUM AND"]},{"entry":["{","2nd MAXIMUM,"]},{"entry":["\u2002Result tmp;","UNSIGNED"]},{"entry":["\u2002tmp.range(16,31) = (_unsigned(s1.range(0,15)) >=_unsigned(s2.range(16,31)))",{}]},{"entry":["? s1.range(0,15) : s2.range(16,31);",{}]},{"entry":["\u2002tmp.range(0,15) = (_unsigned(s1.range(16,31))>=_unsigned(s2.range(0,15)))",{}]},{"entry":["? s1.range(16,31) : s2.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (_unsigned(s1.range(16,31))>=_unsigned(s2.range(16,31)))",{}]},{"entry":["? s1.range(16,31) : s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = (_unsigned(s1.range(16,31))>=_unsigned(s2.range(16,31)))",{}]},{"entry":["? tmp.range(16,31) : tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MAXMAX2U .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_MAXMAX2U_20b_155 (Vreg4 &s1, Vreg4 &s2)","MAXIMUM AND"]},{"entry":["{","2nd MAXIMUM,"]},{"entry":["\u2002Result tmp;","UNSIGNED"]},{"entry":["\u2002tmp.range(16,31) = (_unsigned(s1.range(0,15)) >=_unsigned(s2.range(16,31))) ",{}]},{"entry":["? s1.range(0,15) : s2.range(16,31);",{}]},{"entry":["\u2002tmp.range(0,15) = (_unsigned(s1.range(16,31))>=_unsigned(s2.range(0,15)))",{}]},{"entry":["? s1.range(16,31) : s2.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (_unsigned(s1.range(16,31))>=_unsigned(s2.range(16,31)))",{}]},{"entry":["? s1.range(16,31) : s2.range(16,31);",{}]},{"entry":["MAXU .(SA,SB) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_MAXU_20b_120 (Gpr &s1, Gpr &s2,Unit &unit)","MAXIMUM"]},{"entry":["{",{}]},{"entry":["\u2002Csr.bit(LT,unit) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2002Csr.bit(GT,unit) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2002if(Csr.bit(LT,unit)) s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MAXU .(V,VP) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPCV_MAXU_20b_71 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MAXIMUM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(LTA) = _unsigned(s2.range(0,15)) < _unsigned(s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(GTA) = _unsigned(s2.range(0,15)) > _unsigned(s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(EQA) = _unsigned(s2.range(0,15)) == _unsigned(s1.range(0,15));",{}]},{"entry":["\u2003if(Vr15.bit(LTA)) s2.range(0,15) = s1.range(0,15);",{}]},{"entry":["\u2003Vr15.bit(LTB) = _unsigned(s2.range(16,31)) < _unsigned(s1.range(16,31));",{}]},{"entry":["\u2003Vr15.bit(GTB) = _unsigned(s2.range(16,31)) > _unsigned(s1.range(16,31));",{}]},{"entry":["\u2003Vr15.bit(EQB) = _unsigned(s2.range(16,31)) == _unsigned(s1.range(16,31));",{}]},{"entry":["\u2003if(Vr15.bit(LTB)) s2.range(16,31) = s1.range(16,31);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(LT) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2003Vr15.bit(GT) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = _unsigned(s2) == _unsigned(s1);",{}]},{"entry":["\u2003if(Vr15.bit(LT)) s2 = s1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MFVRC .(SB) s1(R5),s2(R4)","MOVE VREG TO"]},{"entry":["void ISA::OPC_MFVRC_40b_266 (Vreg &s1, Gpr &s2)","GPR, COLLAPSE"]},{"entry":["{",{}]},{"entry":["\u2002Event initiate,complete;",{}]},{"entry":["\u2002Reg s2Save;",{}]},{"entry":["\u2003risc_is_mfvrc._assert(1);",{}]},{"entry":["\u2003vec_regf_enz._assert(0);",{}]},{"entry":["\u2003vec_regf_hwz._assert(0x3);",{}]},{"entry":["\u2003vec_regf_ra._assert(s1);",{}]},{"entry":["\u2003s2Save = s2.address( );",{}]},{"entry":["\u2003initiate.live(true);",{}]},{"entry":["\u2003complete.live(vec_wdata_wrz.is(0));",{}]},{"entry":["}",{}]},{"entry":["MFVVR .(SB) s1(R5), s2(R5), s3(R4)","MOVE"]},{"entry":["void ISA::OPC_MFVVR_40b_264 (Vunit &s1, Vreg &s2,Gpr &s3)","VUNIT\/VREG TO"]},{"entry":["{","GPR"]},{"entry":["\u2002Event initiate,complete;",{}]},{"entry":["\u2002Reg s3Save;",{}]},{"entry":["\u2002risc_is_mfvvr._assert(1);",{}]},{"entry":["\u2002vec_regf_ua._assert(s1);",{}]},{"entry":["\u2002vec_regf_hwz._assert(0x3);",{}]},{"entry":["\u2002vec_regf_enz._assert(0);",{}]},{"entry":["\u2002vec_regf_ra._assert(s2);",{}]},{"entry":["\u2002s3Save = s3.address( );",{}]},{"entry":["\u2002initiate.live(true);\u2003\/\/this is an modeling artifact",{}]},{"entry":["\u2002complete.live(vec_wdata_wrz.is(0)); \/\/ditto",{}]},{"entry":["\u2002}",{}]},{"entry":["MIN .(SA,SB) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPC_MIN_20b_119 (Gpr &s1, Gpr &s2,Unit &unit)","MINIMUM"]},{"entry":["{",{}]},{"entry":["\u2002Csr.bit(LT,unit) = s2 < s1;",{}]},{"entry":["\u2002Csr.bit(GT,unit) = s2 > s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2002if(Csr.bit(GT,unit)) s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MIN .(V,VP) s1(R4), s2(R4)","SIGNED"]},{"entry":["void ISA::OPCV_MIN_20b_70 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MINIMUM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(LTA) = (s2.range(0,15)) < (s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(GTA) = (s2.range(0,15)) > (s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(EQA) = (s2.range(0,15)) == (s1.range(0,15));",{}]},{"entry":["\u2003if(Vr15.bit(GTA)) (s2.range(0,15)) = (s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(LTB) = (s2.range(16,31)) < (s1.range(16,31));",{}]},{"entry":["\u2003Vr15.bit(GTB) = (s2.range(16,31)) > (s1.range(16,31));",{}]},{"entry":["\u2003Vr15.bit(EQB) = (s2.range(16,31)) == (s1.range(16,31));",{}]},{"entry":["\u2003if(Vr15.bit(GTB)) (s2.range(16,31)) = (s1.range(16,31));",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(LT) = (s2) < (s1);",{}]},{"entry":["\u2003Vr15.bit(GT) = (s2) > (s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = (s2) == (s1);",{}]},{"entry":["\u2003if(Vr15.bit(GT)) (s2) = (s1);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MIN2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MIN2_20b_166 (Gpr &s1, Gpr &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp.range(0,15) = (s1.range(0,15) <s2.range(0,15)) ? s1.range(0,15):s2.",{}]},{"entry":["range(0,15);",{}]},{"entry":["\u2002tmp.range(16,31) = (s1.range(16,31) <s2.range(16,31)) ? s1.range(16,31)",{}]},{"entry":[":s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = (tmp.range(16,31)<tmp.range(0,15)) ? tmp.range(16,31)",{}]},{"entry":[":tmp.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (tmp.range(16,31)<tmp.range(0,15)) ? tmp.range(0,15)",{}]},{"entry":[":tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MIN2 .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_MIN2_20b_166 (Vreg4 &s1, Vreg4 &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp.range(0,15) = (s1.range(0,15) <s2.range(0,15)) ? s1.range(0,15):s2.",{}]},{"entry":["range(0,15);",{}]},{"entry":["\u2002tmp.range(16,31) = (s1.range(16,31) <s2.range(16,31)) ? s1.range(16,31)",{}]},{"entry":[":s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = (tmp.range(16,31)<tmp.range(0,15)) ? tmp.range(16,31)",{}]},{"entry":[":tmp.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (tmp.range(16,31)<tmp.range(0,15)) ? tmp.range(0,15)",{}]},{"entry":[":tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MIN2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MIN2U_20b_167 (Gpr &s1, Gpr &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM,"]},{"entry":["\u2002Result tmp;","UNSIGNED"]},{"entry":["\u2002tmp.range(0,15) = (_unsigned(s1.range(0,15)) <_unsigned(s2.range(0,15)))",{}]},{"entry":["? s1.range(0,15):s2.range(0,15);",{}]},{"entry":["\u2002tmp.range(16,31) = (_unsigned(s1.range(16,31)) <_unsigned(s2.range(16,31)))",{}]},{"entry":["? s1.range(16,31):s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = (_unsigned(tmp.range(16,31))<_unsigned(tmp.range(0,15)))",{}]},{"entry":["? tmp.range(16,31):tmp.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (_unsigned(tmp.range(16,31))<_unsigned(tmp.range(0,15)))",{}]},{"entry":["? tmp.range(0,15):tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MIN2U .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_MIN2U_20b_167 (Vreg4 &s1, Vreg4 &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM,"]},{"entry":["\u2002Result tmp;","UNSIGNED"]},{"entry":["\u2002tmp.range(0,15) = (_unsigned(s1.range(0,15)) <_unsigned(s2.range(0,15)))",{}]},{"entry":["? s1.range(0,15):s2.range(0,15);",{}]},{"entry":["\u2002tmp.range(16,31) = (_unsigned(s1.range(16,31)) <_unsigned(s2.range(16,31)))",{}]},{"entry":["? s1.range(16,31):s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = (_unsigned(tmp.range(16,31))<_unsigned(tmp.range(0,15)))",{}]},{"entry":["? tmp.range(16,31):tmp.range(0,15);",{}]},{"entry":["\u2002s2.range(16,31) = (_unsigned(tmp.range(16,31))<_unsigned(tmp.range(0,15)))",{}]},{"entry":["? tmp.range(0,15):tmp.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MINH .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MINH_20b_160 (Gpr &s1, Gpr &s2, Unit &unit)","MINIMUM"]},{"entry":["{",{}]},{"entry":["\u2002s2.range( 0,15) = s2.range( 0,15) < s1.range( 0,15)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range( 0,15) : s1.range( 0,15);",{}]},{"entry":["\u2002s2.range(16,31) = s2.range(16,31) < s1.range(16,31)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MINHU .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MINHU_20b_161 (Gpr &s1, Gpr &s2, Unit &unit)","MINIMUM,"]},{"entry":["{","UNSIGNED"]},{"entry":["\u2002s2.range( 0,15) = _unsigned(s2.range( 0,15)) < _unsigned(s1.range( 0,15))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range( 0,15) : s1.range( 0,15);",{}]},{"entry":["\u2002s2.range(16,31) = _unsigned(s2.range(16,31)) < _unsigned(s1.range(16,31))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MINMIN2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MINMIN2_20b_168 (Gpr &s1, Gpr &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp.range(16,31) = s1.range(0,15) <s2.range(16,31) ? s1.range(0,15) : s2.",{}]},{"entry":["range(16,31);",{}]},{"entry":["\u2002tmp.range(0,15) = s1.range(16,31)<s2.range(0,15) ? s2.range(16,31) : s1.",{}]},{"entry":["range(16,31);",{}]},{"entry":["\u2002s2.range(16,31) = s1.range(16,31)<s2.range(16,31) ? s1.range(16,31) : s2.",{}]},{"entry":["range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = s1.range(16,31)<s2.range(16,31) ? tmp.range(16,31):",{}]},{"entry":["tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MINMIN2 .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_MINMIN2_20b_168 (Vreg4 &s1, Vreg4 &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM"]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp.range(16,31) = s1.range(0,15) <s2.range(16,31) ? s1.range(0,15) : s2.",{}]},{"entry":["range(16,31);",{}]},{"entry":["\u2002tmp.range(0,15) = s1.range(16,31)<s2.range(0,15) ? s2.range(16,31) : s1.",{}]},{"entry":["range(16,31);",{}]},{"entry":["\u2002s2.range(16,31) = s1.range(16,31)<s2.range(16,31) ? s1.range(16,31) : s2.",{}]},{"entry":["range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = s1.range(16,31)<s2.range(16,31) ? tmp.range(16,31):",{}]},{"entry":["tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MINMIN2U .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_MINMIN2U_20b_169 (Gpr &s1, Gpr &s2)","MINIMUM AND"]},{"entry":["{","2nd MINIMUM,"]},{"entry":["\u2002Result tmp;","UNSIGNED"]},{"entry":["\u2002tmp.range(16,31) = _unsigned(s1.range(0,15) )<_unsigned(s2.range(16,",{}]},{"entry":["31)) ? s1.range(0,15) : s2.range(16,31);",{}]},{"entry":["\u2002tmp.range(0,15) = _unsigned(s1.range(16,31))<_unsigned(s2.range(0,15) ) ",{}]},{"entry":["? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["\u2002s2.range(16,31) = _unsigned(s1.range(16,31))<_unsigned(s2.range(16,31))",{}]},{"entry":["? s1.range(16,31) : s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = _unsigned(s1.range(16,31))<_unsigned(s2.range(16,31))",{}]},{"entry":["? tmp.range(16,31): tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MINMIN2U .(VPx) s1(R4), s2(R4)",{}]},{"entry":["void ISA::OPCV_MINMIN2U_20b_169 (Vreg4 &s1, Vreg4 &s2)","HALF WORD"]},{"entry":["{","MINIMUM AND"]},{"entry":["\u2002Result tmp;","2nd MINIMUM,"]},{"entry":["\u2002tmp.range(16,31) = _unsigned(s1.range(0,15) )<_unsigned(s2.range(16,31))","UNSIGNED"]},{"entry":["? s1.range(0,15) : s2.range(16,31);",{}]},{"entry":["\u2002tmp.range(0,15) = _unsigned(s1.range(16,31))<_unsigned(s2.range(0,15) )",{}]},{"entry":["? s2.range(16,31) : s1.range(16,31);",{}]},{"entry":["\u2002s2.range(16,31) = _unsigned(s1.range(16,31))<_unsigned(s2.range(16,31))",{}]},{"entry":["? s1.range(16,31) : s2.range(16,31);",{}]},{"entry":["\u2002s2.range(0,15) = _unsigned(s1.range(16,31))<_unsigned(s2.range(16,31))",{}]},{"entry":["? tmp.range(16,31): tmp.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MINU .(SA,SB) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPC_MINU_20b_118 (Gpr &s1, Gpr &s2,Unit &unit)","MINIMUM"]},{"entry":["{",{}]},{"entry":["\u2002Csr.bit(LT,unit) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2002Csr.bit(GT,unit) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2 == s1;",{}]},{"entry":["\u2002if(Csr.bit(GT,unit)) s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MINU .(V,VP) s1(R4), s2(R4)","UNSIGNED"]},{"entry":["void ISA::OPCV_MINU_20b_69 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MINIMUM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(LTA) = _unsigned(s2.range(0,15)) < _unsigned(s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(GTA) = _unsigned(s2.range(0,15)) > _unsigned(s1.range(0,15));",{}]},{"entry":["\u2003Vr15.bit(EQA) = _unsigned(s2.range(0,15)) == _unsigned(s1.range(0,15));",{}]},{"entry":["\u2003if(Vr15.bit(GTA)) s2.range(0,15) = s1.range(0,15);",{}]},{"entry":["\u2003Vr15.bit(LTB) = _unsigned(s2.range(16,31)) < _unsigned(s1.range(16,31));",{}]},{"entry":["\u2003Vr15.bit(GTB) = _unsigned(s2.range(16,31)) > _unsigned(s1.range(16,31));",{}]},{"entry":["\u2003Vr15.bit(EQB) = _unsigned(s2.range(16,31)) == _unsigned(s1.range(16,31));",{}]},{"entry":["\u2003if(Vr15.bit(GTB)) s2.range(16,31) = s1.range(16,31);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Vr15.bit(LT) = _unsigned(s2) < _unsigned(s1);",{}]},{"entry":["\u2003Vr15.bit(GT) = _unsigned(s2) > _unsigned(s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = _unsigned(s2) == _unsigned(s1);",{}]},{"entry":["\u2003if(Vr15.bit(GT)) s2 = s1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MPY .(SA,SB) s1(R4), s2(R4)","SIGNED 16b"]},{"entry":["void ISA::OPC_MPY_20b_115 (Gpr &s1, Gpr &s2,Unit &unit)","MULTIPLY"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2.range(0,15)*s1.range(0,15);",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["MPY .(V,VP) s1(R4), s2(R4)","SIGNED 8b\/16b"]},{"entry":["void ISA::OPCV_MPY_20b_66 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MULTIPLY"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s1lo = s1.range(0,7);",{}]},{"entry":["\u2003Reg s2lo = s2.range(0,7);",{}]},{"entry":["\u2003Result r1lo = s2lo*s1lo;",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = r1lo.range(0,15);",{}]},{"entry":["\u2003Reg s1hi = s1.range(16,23);",{}]},{"entry":["\u2003Reg s2hi = s2.range(16,23);",{}]},{"entry":["\u2003Result r1hi = s2hi*s2hi;",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = r1hi.range(0,15);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1lo,s2lo,r1lo);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1hi,s2hi,r1hi);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result r1 = s2 * s1;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,r1);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MPYH .(SA,SB) s1(R4), s2(R4)","SIGNED 16b"]},{"entry":["void ISA::OPC_MPYH_20b_116 (Gpr &s1, Gpr &s2,Unit &unit)","MULTIPLY, HIGH"]},{"entry":["{","HALF WORDS"]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2.range(16,31)*s1.range(16,31);",{}]},{"entry":["\u2002s1 = r1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["MPYH .(V,VP) s1(R4), s2(R4)","SIGNED 8b\/16b"]},{"entry":["void ISA::OPCV_MPYH_20b_67 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MULTIPLY, HIGH"]},{"entry":["{","HALF"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s1lo = s1.range(8,15);",{}]},{"entry":["\u2003Reg s2lo = s2.range(8,15);",{}]},{"entry":["\u2003Result r1lo = s2lo*s1lo;",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = r1lo.range(0,15);",{}]},{"entry":["\u2003Reg s1hi = s1.range(24,31);",{}]},{"entry":["\u2003Reg s2hi = s2.range(24,31);",{}]},{"entry":["\u2003Result r1hi = s2hi*s1hi;",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = r1lo.range(0,15);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1lo, s2lo, r1lo);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1hi, s2hi, r1hi);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result r1 = s2.range(16,31) * s1.range(16,31);",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1, s2, r1);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MPYLH .(SA,SB) s1(R4), s2(R4)","SIGNED 16b"]},{"entry":["void ISA::OPC_MPYLH_20b_117 (Gpr &s1, Gpr &s2,Unit &unit)","MULTIPLY, LOW"]},{"entry":["{","HALF TO HIGH"]},{"entry":["\u2002Result r1;","HALF"]},{"entry":["\u2002r1 = s2.range(16,31)*s1.range(0,15);",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["MPYLH .(V,VP) s1(R4), s2(R4)","SIGNED 8b\/16b"]},{"entry":["void ISA::OPCV_MPYLH_20b_68 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MULTIPLY, LOW"]},{"entry":["{","TO HIGH"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s1lo = s1.range(0,7);",{}]},{"entry":["\u2003Reg s2hi = s2.range(8,15);",{}]},{"entry":["\u2003Result r1lo = s2hi*s1lo;",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = r1lo.range(0,15);",{}]},{"entry":["\u2003Reg s1hi = s1.range(24,31);",{}]},{"entry":["\u2003Reg s2lo = s2.range(16,23);",{}]},{"entry":["\u2003Result r1hi = s2hi*s1hi;",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = r1hi.range(0,15);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1lo, s2lo, r1lo);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1hi, s2hi, r1hi);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s1lo = s1.range(0,15);",{}]},{"entry":["\u2003Reg s2hi = s2.range(16,23);",{}]},{"entry":["\u2003Result r1 = s2hi * s1lo;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1lo, s2hi, r1);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MPYU .(SA,SB) s1(R4), s2(R4)","UNSIGNED 16b"]},{"entry":["void ISA::OPC_MPYU_20b_159 (Gpr &s1, Gpr &s2,Unit &unit)","MULTIPLY"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = ((unsigned)s2.range(0,15)) * ((unsigned)s1.range(0,15));",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = r1.zero( );",{}]},{"entry":["}",{}]},{"entry":["MPYU .(V,VP) s1(R4), s2(R4)","UNSIGNED 8b\/16b"]},{"entry":["void ISA::OPCV_MPYU_20b_87 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","MULTIPLY"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result r1,r2;",{}]},{"entry":["\u2003Reg s1lo = _unsigned(s1.range(0,7));",{}]},{"entry":["\u2003Reg s1hi = _unsigned(s1.range(16,23));",{}]},{"entry":["\u2003Reg s2lo = _unsigned(s2.range(0,7));",{}]},{"entry":["\u2003Reg s2hi = _unsigned(s2.range(16,23));",{}]},{"entry":["\u2003r1 = s1lo * s2lo;",{}]},{"entry":["\u2003r2 = s1hi * s2hi;",{}]},{"entry":["\u2003s2.range(0,15) = r1.range(0,15);",{}]},{"entry":["\u2003s2.range(16,31) = r2.range(0,15);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1lo,s2lo,r1);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1hi,s2hi,r2);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003Reg s2lo = _unsigned(s2.range(0,15));",{}]},{"entry":["\u2003Reg s1lo = _unsigned(s1.range(0,15));",{}]},{"entry":["\u2003r1 = s1lo * s2lo;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1lo,s2lo,r1);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MTV .(SA,SB) s1(R4), s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTV_20b_164 (Gpr &s1, Vreg &s2)","VREG,"]},{"entry":["{","REPLICATED"]},{"entry":["\u2002Result r1;","(LOW VREG)"]},{"entry":["\u2002r1.clear( );",{}]},{"entry":["\u2002r1 = s1.range(0,15);",{}]},{"entry":["\u2002risc_is_mtv._assert(1);",{}]},{"entry":["\u2002vec_regf_enz._assert(0);",{}]},{"entry":["\u2002vec_regf_wa._assert(s2);",{}]},{"entry":["\u2002vec_regf_wd._assert(r1);",{}]},{"entry":["\u2002vec_regf_hwz._assert(0x0); \/\/active low, write both halves",{}]},{"entry":["}",{}]},{"entry":["MTV .(SA,SB) s1(R4), s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTV_20b_165 (Gpr &s1, Vreg &s2)","VREG,"]},{"entry":["{","REPLICATED"]},{"entry":["\u2002Result r1;","(HIGH VREG)"]},{"entry":["\u2002r1.clear( );",{}]},{"entry":["\u2002r1.range(16,31) = s1.range(16,31);",{}]},{"entry":["\u2002risc_is_mtv._assert(1);",{}]},{"entry":["\u2002vec_regf_enz._assert(0);",{}]},{"entry":["\u2002vec_regf_wa._assert(s2);",{}]},{"entry":["\u2002vec_regf_wd._assert(r1);",{}]},{"entry":["\u2002vec_regf_hwz._assert(0x0); \/\/active low, write both halves",{}]},{"entry":["}",{}]},{"entry":["MTVRE .(SB) s1(R4),s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTVRE_40b_265 (Gpr &s1, Vreg &s2)","VREG, EXPAND"]},{"entry":["{",{}]},{"entry":["\u2002risc_is_mtvre._assert(1);",{}]},{"entry":["\u2002vec_regf_enz._assert(0);",{}]},{"entry":["\u2002vec_regf_wa._assert(s2);",{}]},{"entry":["\u2002vec_regf_wd._assert(s1);",{}]},{"entry":["\u2002vec_regf_hwz._assert(0x0); \/\/active low, both halves",{}]},{"entry":["}",{}]},{"entry":["MTVVR .(SB) s1(R4), s2(R5), s3(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTVVR_40b_263 (Gpr &s1,Vunit &s2,Vreg &s3)","VUNIT\/VREG"]},{"entry":["{",{}]},{"entry":["\u2002risc_is_mtvvr._assert(1);",{}]},{"entry":["\u2002vec_regf_ua._assert(s2);",{}]},{"entry":["\u2002vec_regf_enz._assert(0);",{}]},{"entry":["\u2002vec_regf_wa._assert(s3);",{}]},{"entry":["\u2002vec_regf_wd._assert(s1);",{}]},{"entry":["\u2002vec_regf_hwz._assert(0x0); \/\/active low, both halves",{}]},{"entry":["}",{}]},{"entry":["MTVVR .SB s1(R4), s2(R4), s3(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MTVVR_40b_261 (Gpr &s1,Gpr &s2,Vreg &s3)","VUNIT\/VREG"]},{"entry":["{",{}]},{"entry":["\u2002risc_is_mtvvr._assert(1);",{}]},{"entry":["\u2002risc_vec_ua._assert(s2.range(0,3));",{}]},{"entry":["\u2002risc_vec_wa._assert(s3);",{}]},{"entry":["\u2002risc_vec_wd._assert(s1);",{}]},{"entry":["\u2002risc_vec_hwz._assert(0x0); \/\/active low, both halves",{}]},{"entry":["}",{}]},{"entry":["MV .(SA,SB) s1(R4), s2(R4)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MV_20b_110 (Gpr &s1, Gpr &s2)","GPR"]},{"entry":["{",{}]},{"entry":["\u2002s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MV .(V,VP) s1(R4), s2(R4)","MOVE VREG4 TO"]},{"entry":["void ISA::OPCV_MV_20b_61 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","VREG4"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = s1.range(LSBU,MSBU);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = s1.range(LSBL,MSBL);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MVC .(SA,SB) s1(R5), s2(R4)","MOVE (LOW)"]},{"entry":["void ISA::OPC_MVC_20b_134 (Creg &s1, Gpr &s2)","CONTROL"]},{"entry":["{","REGISTER TO"]},{"entry":["\u2003s2 = s1;","GPR"]},{"entry":["}",{}]},{"entry":["MVC .(SA,SB) s1(R5), s2(R4)","MOVE (HIGH)"]},{"entry":["void ISA::OPC_MVC_20b_135 (Creg &s1, Gpr &s2)","CONTROL"]},{"entry":["{","REGISTER TO"]},{"entry":["\u2002s2 = s1;","GPR"]},{"entry":["}",{}]},{"entry":["MVC .(SA,SB) s1(R4), s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MVC_20b_136 (Gpr &s1, Creg &s2)","(LOW) CONTROL"]},{"entry":["{","REGISTER"]},{"entry":["\u2003s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MVC .(SA,SB) s1(R4), s2(R5)","MOVE GPR TO"]},{"entry":["void ISA::OPC_MVC_20b_137 (Gpr &s1, Creg &s2)","(HIGH) CONTROL"]},{"entry":["{","REGISTER"]},{"entry":["\u2002s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MVCSR .(SA,SB) s1(R4),s2(U4)","MOVE GPR BIT"]},{"entry":["void ISA::OPC_MVCSR_20b_45 (Gpr &s1, U4 &s2)","TO CSR"]},{"entry":["{",{}]},{"entry":["\u2002Csr.setBit(s2.value( ),s1.bit(0));",{}]},{"entry":["}",{}]},{"entry":["MVCSR .(SA,SB) s1(U4),s2(R4)","MOVE CSR BIT"]},{"entry":["void ISA::OPC_MVCSR_20b_46 (U4 &s1, Gpr &s2)","TO GPR"]},{"entry":["{",{}]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2.bit(0) = Csr.bit(s1.value( ));",{}]},{"entry":["}",{}]},{"entry":["MVCSR .(Vx) s1(R4), s2(R4)","MOVE VREG BIT"]},{"entry":["void ISA::OPCV_MVCSR_20b_46 (Vreg4 &s1, U5 &s2)","TO CSR"]},{"entry":["{",{}]},{"entry":["\u2002Vr15.setBit(s2.value( ),s1.bit(0));",{}]},{"entry":["}",{}]},{"entry":["MVCSR .(Vx) s1(U5),s2(R4)","MOVE CSR BIT"]},{"entry":["void ISA::OPCV_MVCSR_20b_48 (U5 &s1, Vreg4 &s2)","TO VREG"]},{"entry":["{",{}]},{"entry":["\u2002s2.clear( );",{}]},{"entry":["\u2002s2.bit(0) = Vr15.bit(s1.value( ));",{}]},{"entry":["}",{}]},{"entry":["MVK .(SA,SB) s1(S4), s2(R4)","MOVE S4 IMM TO"]},{"entry":["void ISA::OPC_MVK_20b_112 (S4 &s1, Gpr &s2)","GPR"]},{"entry":["{",{}]},{"entry":["\u2002s2 = sign_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["MVK .(SB) s1(S24),s2(R4)","MOVE S24 IMM"]},{"entry":["void ISA::OPC_MVK_40b_229 (S24 &s1,Gpr &s2)","TO GPR"]},{"entry":["{",{}]},{"entry":["\u2002s2 = sign_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["MVK .(V,VP) s1(S4), s2(R4)","MOVE S4 IMM TO"]},{"entry":["void ISA::OPCV_MVK_20b_63 (S4 &s1, Vreg4 &s2, Unit &unit)","VREG4"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = s1.value( );",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = s1.value( );",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MVKA .(SB) s1(S16), s2(U3), s3(R4)","MOVE S16 IMM"]},{"entry":["void ISA::OPC_MVKA_40b_227 (S16 &s1, U3 &s2, Gpr &s3)","TO GPR,"]},{"entry":["{","ALIGNED"]},{"entry":["\u2002s3 = s1 << (s2*8);",{}]},{"entry":["}",{}]},{"entry":["MVKAU .(SB) s1(U16), s2(U3), s3(R4)","MOVE U16 IMM"]},{"entry":["void ISA::OPC_MVKAU_40b_226 (U16 &s1, U3 &s2, Gpr &s3)","TO GPR,"]},{"entry":["{","ALIGNED"]},{"entry":["\u2002s3.clear( );",{}]},{"entry":["\u2002s3 = (s1 << (s2*8));",{}]},{"entry":["}",{}]},{"entry":["MVKCHU .(SB) s1(U32),s2(R5)","MOVE IMM TO"]},{"entry":["void ISA::OPC_MVKCHU_40b_250 (U32 &s1,Creg &s2)","CREG, HIGH"]},{"entry":["{","HALF"]},{"entry":["\u2002s2.range(16,31) = s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MVKCLHU .(SB) s1(U32),s2(R5)","MOVE IMM TO"]},{"entry":["void ISA::OPC_MVKCLHU_40b_251 (U32 &s1,Creg &s2)","CREG, LOW TO"]},{"entry":["{","HIGH HALF"]},{"entry":["\u2002s2.range(16,31) = s1.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MVKCLU .(SB) s1(U32),s2(R5)","MOVE IMM TO"]},{"entry":["void ISA::OPC_MVKCLU_40b_249 (U32 &s1,Creg &s2)","CREG, LOW HALF"]},{"entry":["{",{}]},{"entry":["\u2002s2.range(0,15) = s1.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MVKHU .(SB) s1(U32),s2(R4)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKHU_40b_242 (U32 &s1,Gpr &s2)","GPR, HIGH HALF"]},{"entry":["{",{}]},{"entry":["\u2002s2.range(16,31) = s1.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["MVKLHU .(SB) s1(U32),s2(R4)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKLHU_40b_243 (U32 &s1,Gpr &s2)","GPR, LOW TO"]},{"entry":["{","HIGH HALF"]},{"entry":["\u2002s2.range(16,31) = s1.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["MVKLU .(SB) s1(U32),s2(R4)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKLU_40b_241 (U32 &s1,Gpr &s2)","GPR, LOW HALF"]},{"entry":["{",{}]},{"entry":["\u2002s2 = s1;",{}]},{"entry":["}",{}]},{"entry":["MVKU .(SA,SB) s1(U4), s2(R4)","MOVE U4 IMM"]},{"entry":["void ISA::OPC_MVKU_20b_111 (U4 &s1,Gpr &s2)","TO GPR"]},{"entry":["{",{}]},{"entry":["\u2002s2 = zero_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["MVKU .(SB) s1(U24),s2(R4)","MOVE U24 IMM"]},{"entry":["void ISA::OPC_MVKU_40b_228 (U24 &s1,Gpr &s2)","TO GPR"]},{"entry":["{",{}]},{"entry":["\u2002s2 = zero_extend(s1);",{}]},{"entry":["}",{}]},{"entry":["MVKU .(V,VP) s1(U4), s2(R4)","MOVE U4 IMM"]},{"entry":["void ISA::OPCV_MVKU_20b_62 (U4 &s1, Vreg4 &s2, Unit &unit)","TO VREG4"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = zero_extend(s1);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = zero_extend(s1);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s1;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["MVKVRHU .(SB) s1(U32), s2(R5), s3(R5)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKVRHU_40b_268 (U16 &s1, Vunit &s2, Vreg &s3)","VUNIT\/VREG,"]},{"entry":["{","HIGH HALF"]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = _unsigned(s1.range(16,31));",{}]},{"entry":["\u2002risc_is_mtvvr._assert(1);",{}]},{"entry":["\u2002vec_regf_ua._assert(s2);",{}]},{"entry":["\u2002vec_regf_enz._assert(0);",{}]},{"entry":["\u2002vec_regf_wa._assert(s3);",{}]},{"entry":["\u2002vec_regf_wd._assert(r1);",{}]},{"entry":["\u2002vec_regf_hwz._assert(0x1); \/\/active low, high half",{}]},{"entry":["}",{}]},{"entry":["MVKVRLU .(SB) s1(U32), s2(R5), s3(R5)","MOVE U16 TO"]},{"entry":["void ISA::OPC_MVKVRLU_40b_267 (U16 &s1, Vunit &s2, Vreg &s3)","VUNIT\/VREG,"]},{"entry":["{","LOW HALF"]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1.clear( );",{}]},{"entry":["\u2002r1 = _unsigned(s1);",{}]},{"entry":["\u2002risc_is_mtvvr._assert(1);",{}]},{"entry":["\u2002vec_regf_ua._assert(s2);",{}]},{"entry":["\u2002vec_regf_enz._assert(0);",{}]},{"entry":["\u2002vec_regf_wa._assert(s3);",{}]},{"entry":["\u2002vec_regf_wd._assert(r1);",{}]},{"entry":["\u2002vec_regf_hwz._assert(0x0); \/\/active low, both halves",{}]},{"entry":["}",{}]},{"entry":["NOP .(SA,SB)","NO OPERATION"]},{"entry":["void ISA::OPC_NOP_20b_17 (void)",{}]},{"entry":["{",{}]},{"entry":["}",{}]},{"entry":["NOP .(V)","NO OPERATION"]},{"entry":["void ISA::OPC_NOP_20b_17 (void)",{}]},{"entry":["{",{}]},{"entry":["}",{}]},{"entry":["NOT .(SA,SB) s1(R4)","BITWISE"]},{"entry":["void ISA::OPC_NOT_20b_8 (Gpr &s1,Unit &unit)","INVERSION"]},{"entry":["{",{}]},{"entry":["\u2002s1 = ~s1;",{}]},{"entry":["\u2002Csr.setBit(EQ,unit,s1.zero( ));",{}]},{"entry":["}",{}]},{"entry":["NOT .(V) s1(R4)","BITWISE"]},{"entry":["void ISA::OPCV_NOT_20b_1 (Vreg4 &s1,Unit &unit)","INVERSION"]},{"entry":["{",{}]},{"entry":["\u2002s1 = ~s1;",{}]},{"entry":["\u2002Vr15.bit(EQ) = s1.zero( );",{}]},{"entry":["}",{}]},{"entry":["OR .(SA,SB) s1(R4), s2(R4)","BITWISE OR"]},{"entry":["void ISA::OPC_OR_20b_90 (Gpr &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002s2 |= s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["OR .(SA,SB) s1(U4), s2(R4)","BITWISE OR, U4"]},{"entry":["void ISA::OPC_OR_20b_91 (U4 &s1,Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2002s2 |= s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["OR .(SB) s1(S3), s2(U20), s3(R4)","BITWISE OR, U20"]},{"entry":["void ISA::OPC_OR_40b_214 (U3 &s1, U20 &s2, Gpr &s3,Unit &unit)","IMM, BYTE"]},{"entry":["{","ALIGNED"]},{"entry":["\u2002s3 |= (s2 << (s1*8));",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["OR .(V) s1(R4), s2(R4)","BITWISE OR"]},{"entry":["void ISA::OPCV_OR_20b_90 (Vreg4 &s1, Vreg4 &s2)",{}]},{"entry":["{",{}]},{"entry":["\u2002s2 |=s1;",{}]},{"entry":["\u2002Vr15.bit(EQ) = s2==0;",{}]},{"entry":["}",{}]},{"entry":["OR .(V,VP) s1(U4), s2(R4)","BITWISE OR, U4"]},{"entry":["void ISA::OPCV_OR_20b_91 (U4 &s1, Vreg4 &s2, Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(0,15)|=zero_extend(s1);",{}]},{"entry":["\u2003s2.range(16,31)|=zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(tEQB) = s2.range(0,15) == 0;",{}]},{"entry":["\u2003Vr15.bit(tEQA) = s2.range(16,31) == 0;",{}]},{"entry":["\u2002} else if(isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(0,7)|=zero_extend(s1);",{}]},{"entry":["\u2003s2.range(8,15)|=zero_extend(s1);",{}]},{"entry":["\u2003s2.range(16,23)|=zero_extend(s1);",{}]},{"entry":["\u2003s2.range(24,31)|=zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(tEQA) = s2.range(0,7) == 0;",{}]},{"entry":["\u2003Vr15.bit(tEQB) = s2.range(8,15) == 0;",{}]},{"entry":["\u2003Vr15.bit(tEQC) = s2.range(16,23) == 0;",{}]},{"entry":["\u2003Vr15.bit(tEQD) = s2.range(24,31) == 0;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2|=zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["OUTPUT .(SB) *+s1[s2(R4)], s3(S8), s4(U6), s5(R4)","OUTPUT, 5"]},{"entry":["void ISA::OPC_OUTPUT_40b_238 (Gpr &s1,Gpr &s2,S8 &s3,U6 &s4,","operand"]},{"entry":["Gpr &s5)",{}]},{"entry":["{",{}]},{"entry":["\u2002int imm_cnst = s3.value( );",{}]},{"entry":["\u2002int bot_off = s2.range(0,3);",{}]},{"entry":["\u2002int top_off = s2.range(4,7);",{}]},{"entry":["\u2002int blk_size = s2.range(8,10);",{}]},{"entry":["\u2002int str_dis = s2.bit(12);",{}]},{"entry":["\u2002int repeat = s2.bit(13);",{}]},{"entry":["\u2002int bot_flag = s2.bit(14);",{}]},{"entry":["\u2002int top_flag = s2.bit(15);",{}]},{"entry":["\u2002int pntr = s2.range(16,23);",{}]},{"entry":["\u2002int size = s2.range(24,31);",{}]},{"entry":["\u2002int tmp,addr;",{}]},{"entry":["\u2002if(imm_cnst > 0 && bot_flag && imm_cnst > bot_off)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(!repeat)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002tmp = (bot_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002tmp = bot_off;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(imm_cnst < 0 && top_flag && \u2212imm_cnst > top_off)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(!repeat)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003tmp = \u2212(top_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003\u2002else",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003tmp = \u2212top_off;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002tmp = imm_cnst;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002pntr = pntr << blk_size;",{}]},{"entry":["\u2002if(size == 0)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003addr = pntr + tmp;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if((pntr + tmp) >= size)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002addr = pntr + tmp \u2212 size;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(pntr + tmp < 0)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003addr = pntr + tmp + size;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003\u2002else",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003addr = pntr + tmp;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002addr = addr + s1.value( );",{}]},{"entry":["\u2002risc_is_output._assert(1);",{}]},{"entry":["\u2002risc_output_wd._assert(s5);",{}]},{"entry":["\u2002risc_output_wa._assert(addr);",{}]},{"entry":["\u2002risc_output_pa._assert(s4);",{}]},{"entry":["\u2002risc_output_sd._assert(str_dis);",{}]},{"entry":["}",{}]},{"entry":["OUTPUT .(SB) *+s1[s2(S14)], s3(U6), s4(R4)","OUTPUT, 4"]},{"entry":["void ISA::OPC_OUTPUT_40b_239 (Gpr &s1,S14 &s2,U6 &s3,Gpr &s4","operand"]},{"entry":[")",{}]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s1 + s2;",{}]},{"entry":["\u2002risc_is_output._assert(1);",{}]},{"entry":["\u2002risc_output_wd._assert(s4);",{}]},{"entry":["\u2002risc_output_wa._assert(r1);",{}]},{"entry":["\u2002risc_output_pa._assert(s3);",{}]},{"entry":["\u2003risc_output_sd._assert(s1.bit(12));",{}]},{"entry":["}",{}]},{"entry":["OUTPUT .(SB) *s1(U18), s2(U6), s3(R4)","OUTPUT, 3"]},{"entry":["void ISA::OPC_OUTPUT_40b_240 (S18 &s1,U6 &s2,Gpr &s3)","operand"]},{"entry":["{",{}]},{"entry":["\u2002risc_is_output._assert(1);",{}]},{"entry":["\u2002risc_output_wd._assert(s3);",{}]},{"entry":["\u2002risc_output_wa._assert(s1);",{}]},{"entry":["\u2002risc_output_pa._assert(s2);",{}]},{"entry":["\u2002risc_output_sd._assert(0);",{}]},{"entry":["}",{}]},{"entry":["PACKHH (.SA,.SB) s1(R4, s2(R4)","PACK REGISTER,"]},{"entry":["void ISA::OPC_PACKHH_20b_372 (Gpr &s1, Gpr &s2)","HIGH\/HIGH"]},{"entry":["{",{}]},{"entry":["\u2002s2 = (s1.range(16,31) << 16) | s2.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["PACKHH .(VPx) s1(R4), s2(R4), s3(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_PACKHH_20b_290 (Vreg4 &s1, Vreg4 &s2, Vreg4 &","PACK,"]},{"entry":["s3)","HIGH\/HIGH, 3"]},{"entry":["{","OPERAND"]},{"entry":["\u2002s3 = (s1.range(16,31) << 16) | s2.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["PACKHL (.SA,.SB) s1(R4, s2(R4)","PACK REGISTER,"]},{"entry":["void ISA::OPC_PACKHL_20b_371 (Gpr &s1, Gpr &s2)","HIGH\/LOW"]},{"entry":["{",{}]},{"entry":["\u2002s2 = (s1.range(16,31) << 16) | s2.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["PACKHL .(VPx) s1(R4), s2(R4), s3(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_PACKHL_20b_289 (Vreg4 &s1, Vreg4 &s2, Vreg4 &","PACK,"]},{"entry":["s3)","HIGH\/LOW, 3"]},{"entry":["{","OPERAND"]},{"entry":["\u2002s3 = (s1.range(16,31) << 16) | s2.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["PACKLH (.SA,.SB) s1(R4, s2(R4)","PACK REGISTER,"]},{"entry":["void ISA::OPC_PACKLH_20b_370 (Gpr &s1, Gpr &s2)","LOW\/HIGH"]},{"entry":["{",{}]},{"entry":["\u2002s2 = (s1.range(0,15) << 16) | s2.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["PACKLH .(VPx) s1(R4), s2(R4), s3(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_PACKLH_20b_288 (Vreg4 &s1, Vreg4 &s2, Vreg4 &","PACK,"]},{"entry":["s3)","LOW\/HIGH, 3"]},{"entry":["{","OPERAND"]},{"entry":["\u2002s3 = (s1.range(0,15) << 16) | s2.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["PACKLL (.SA,.SB) s1(R4, s2(R4)","PACK REGISTER,"]},{"entry":["void ISA::OPC_PACKLL_20b_369 (Gpr &s1, Gpr &s2)","LOW\/LOW"]},{"entry":["{",{}]},{"entry":["\u2002s2 = (s1.range(0,15) << 16) | s2.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["PACKLL .(VPx) s1(R4), s2(R4), s3(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_PACKLL_20b_287 (Vreg4 &s1, Vreg4 &s2, Vreg4 &s","PACK, LOW\/LOW,"]},{"entry":["3)","3 OPERAND"]},{"entry":["{",{}]},{"entry":["\u2002s3 = (s1.range(0,15) << 16) | s2.range(0,15);",{}]},{"entry":["}",{}]},{"entry":["RELINP .(SA,SB)","RELEASE INPUT"]},{"entry":["void ISA::OPC_RELINP_20b_18 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2002risc_is_release._assert(1);",{}]},{"entry":["}",{}]},{"entry":["REORD .(SA,SB) s1(U5), s2(R4)","REORDER WORD"]},{"entry":["void ISA::OPC_REORD_20b_330 (U5 &s1, Gpr &s2)",{}]},{"entry":["{",{}]},{"entry":["\u2002#define RORD(w,x,y,z) { \\",{}]},{"entry":["\u2003s2.range(0 ,7) = w; \\",{}]},{"entry":["\u2003s2.range(8 ,15) = x; \\",{}]},{"entry":["\u2003s2.range(16,23) = y; \\",{}]},{"entry":["\u2003s2.range(24,31) = z; \\",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002int sw = s1.value( );",{}]},{"entry":["\u2002switch(sw)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003case 0x01: RORD(RO_A,RO_B,RO_D,RO_C); break;",{}]},{"entry":["\u2003case 0x02: RORD(RO_A,RO_C,RO_B,RO_D); break;",{}]},{"entry":["\u2003case 0x03: RORD(RO_A,RO_C,RO_D,RO_B); break;",{}]},{"entry":["\u2003case 0x04: RORD(RO_A,RO_D,RO_B,RO_C); break;",{}]},{"entry":["\u2003case 0x05: RORD(RO_A,RO_D,RO_C,RO_B); break;",{}]},{"entry":["\u2003case 0x06: RORD(RO_B,RO_A,RO_C,RO_D); break;",{}]},{"entry":["\u2003case 0x07: RORD(RO_B,RO_A,RO_D,RO_C); break;",{}]},{"entry":["\u2003case 0x08: RORD(RO_B,RO_C,RO_A,RO_D); break;",{}]},{"entry":["\u2003case 0x09: RORD(RO_B,RO_C,RO_D,RO_A); break;",{}]},{"entry":["\u2003case 0x0a: RORD(RO_B,RO_D,RO_A,RO_C); break;",{}]},{"entry":["\u2003case 0x0b: RORD(RO_B,RO_D,RO_C,RO_A); break;",{}]},{"entry":["\u2003case 0x0c: RORD(RO_C,RO_A,RO_B,RO_D); break;",{}]},{"entry":["\u2003case 0x0d: RORD(RO_C,RO_A,RO_D,RO_B); break;",{}]},{"entry":["\u2003case 0x0e: RORD(RO_C,RO_B,RO_A,RO_D); break;",{}]},{"entry":["\u2003case 0x0f: RORD(RO_C,RO_B,RO_D,RO_A); break;",{}]},{"entry":["\u2003case 0x10: RORD(RO_C,RO_D,RO_A,RO_B); break;",{}]},{"entry":["\u2003case 0x11: RORD(RO_C,RO_D,RO_B,RO_A); break;",{}]},{"entry":["\u2003case 0x12: RORD(RO_D,RO_A,RO_B,RO_C); break;",{}]},{"entry":["\u2003case 0x13: RORD(RO_D,RO_A,RO_C,RO_B); break;",{}]},{"entry":["\u2003case 0x14: RORD(RO_D,RO_B,RO_A,RO_C); break;",{}]},{"entry":["\u2003case 0x15: RORD(RO_D,RO_B,RO_C,RO_A); break;",{}]},{"entry":["\u2003case 0x16: RORD(RO_D,RO_C,RO_A,RO_B); break;",{}]},{"entry":["\u2003case 0x17: RORD(RO_D,RO_C,RO_B,RO_A); break;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["REORD .(Vx) s1(U5), s2(R4)","REORDER WORD"]},{"entry":["void ISA::OPCV_REORD_20b_129 (U5 &s1, Vreg4 &s2)",{}]},{"entry":["{",{}]},{"entry":["\u2002switch(s1.value( ))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003case 0x01: RORD(RO_A,RO_B,RO_D,RO_C); break;",{}]},{"entry":["\u2003case 0x02: RORD(RO_A,RO_C,RO_B,RO_D); break;",{}]},{"entry":["\u2003case 0x03: RORD(RO_A,RO_C,RO_D,RO_B); break;",{}]},{"entry":["\u2003case 0x04: RORD(RO_A,RO_D,RO_B,RO_C); break;",{}]},{"entry":["\u2003case 0x05: RORD(RO_A,RO_D,RO_C,RO_B); break;",{}]},{"entry":["\u2003case 0x06: RORD(RO_B,RO_A,RO_C,RO_D); break;",{}]},{"entry":["\u2003case 0x07: RORD(RO_B,RO_A,RO_D,RO_C); break;",{}]},{"entry":["\u2003case 0x08: RORD(RO_B,RO_C,RO_A,RO_D); break;",{}]},{"entry":["\u2003case 0x09: RORD(RO_B,RO_C,RO_D,RO_A); break;",{}]},{"entry":["\u2003case 0x0a: RORD(RO_B,RO_D,RO_A,RO_C); break;",{}]},{"entry":["\u2003case 0x0b: RORD(RO_B,RO_D,RO_C,RO_A); break;",{}]},{"entry":["\u2003case 0x0c: RORD(RO_C,RO_A,RO_B,RO_D); break;",{}]},{"entry":["\u2003case 0x0d: RORD(RO_C,RO_A,RO_D,RO_B); break;",{}]},{"entry":["\u2003case 0x0e: RORD(RO_C,RO_B,RO_A,RO_D); break;",{}]},{"entry":["\u2003case 0x0f: RORD(RO_C,RO_B,RO_D,RO_A); break;",{}]},{"entry":["\u2003case 0x10: RORD(RO_C,RO_D,RO_A,RO_B); break;",{}]},{"entry":["\u2003case 0x11: RORD(RO_C,RO_D,RO_B,RO_A); break;",{}]},{"entry":["\u2003case 0x12: RORD(RO_D,RO_A,RO_B,RO_C); break;",{}]},{"entry":["\u2003case 0x13: RORD(RO_D,RO_A,RO_C,RO_B); break;",{}]},{"entry":["\u2003case 0x14: RORD(RO_D,RO_B,RO_A,RO_C); break;",{}]},{"entry":["\u2003case 0x15: RORD(RO_D,RO_B,RO_C,RO_A); break;",{}]},{"entry":["\u2003case 0x16: RORD(RO_D,RO_C,RO_A,RO_B); break;",{}]},{"entry":["\u2003case 0x17: RORD(RO_D,RO_C,RO_B,RO_A); break;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["RET .(SB)","RETURN FROM"]},{"entry":["void ISA::OPC_RET_20b_15 (void)","SUBROUTINE"]},{"entry":["{",{}]},{"entry":["\u2002Sp +=4;",{}]},{"entry":["\u2002Pc = dmem->read(Sp);",{}]},{"entry":["}",{}]},{"entry":["REV .(SB) s1(U6), s2(U6), s3(R4)","REVERSE BIT"]},{"entry":["void ISA::OPC_REV_40b_283 (U6 &s1, U6 &s2,Gpr &s3,Unit &unit)","FIELD"]},{"entry":["{",{}]},{"entry":["\u2002Reg tmp = s3;",{}]},{"entry":["\u2002int j = s2.value( );",{}]},{"entry":["\u2002for(int i=s1.value( );i<=s2.value( );++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s3.bit(j\u2212\u2212) = tmp.bit(i);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["REVB .(SA,SB) s1(U2), s2(U2), s3(R4)","REVERSE BITS"]},{"entry":["void ISA::OPC_REVB_20b_92 (U2 &s1, U2 &s2,Gpr &s3,Unit &unit)","WITHIN BYTE"]},{"entry":["{","FIELD"]},{"entry":["\u2002int istart = s1.value( ) \u2002*8;",{}]},{"entry":["\u2002int iend \u2002= (s2.value( )+1)*8;",{}]},{"entry":["\u2002int j = iend\u22121;",{}]},{"entry":["\u2002Reg tmp = s3;",{}]},{"entry":["\u2002for(int i=istart;i<iend;++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s3.bit(j\u2212\u2212) = tmp.bit(i);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["REVB .(V) s1(U2), s2(U2), s3(R4)","REVERSE BITS"]},{"entry":["void ISA::OPCV_REVB_20b_45 (U2 &s1, U2 &s2, Vreg4 &s3)","WITHIN BYTE"]},{"entry":["{","FIELD"]},{"entry":["\u2002int istart = s1.value( )*8;",{}]},{"entry":["\u2002int iend = (s2.value( )+1)*8;",{}]},{"entry":["\u2002int j = iend\u22121;",{}]},{"entry":["\u2002Reg tmp = s3;",{}]},{"entry":["\u2002for(int i=istart;i<iend;++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s3.bit(j\u2212\u2212) = tmp.bit(i);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002Vr15.bit(EQ) = s3==0;",{}]},{"entry":["}",{}]},{"entry":["RHLDHU .(VP3,VP4) s1(R4), s2(R4), s3(R4)","LOAD HALF"]},{"entry":["void ISA::OPCV_RHLDHU_20b_296 (Vreg4 &s1, Vreg4 &s2, Vreg4 &","UNSIGNED,"]},{"entry":["s3)","RELATIVE"]},{"entry":["{","HORIZONTAL"]},{"entry":["\u2002Result addrlo,addrhi;","ACCESS"]},{"entry":["\u2002addrlo.range(0,19) = _unsigned((s1.range(0,12)<<6))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _signed(s2.range(0,13))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _unsigned(((HG_POSN.range(0,7)<<6) | POSN.range(0,5",{}]},{"entry":[")));",{}]},{"entry":["\u2002addrhi.range(0,19) = _unsigned((s1.range(16,27)<<6))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _signed(s2.range(16,29))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _unsigned(((HG_POSN.range(0,7)<<6) | POSN.range(0,5",{}]},{"entry":[")));",{}]},{"entry":["\u2002s3.range(0,15) = fmem0->uhalf(addrlo);",{}]},{"entry":["\u2002s3.range(16,31) = fmem1->uhalf(addrhi);",{}]},{"entry":["}",{}]},{"entry":["RHLDHU .(VP3,VP4) s1(R4), s2(S6), s3(R4)","LOAD HALF"]},{"entry":["void ISA::OPCV_RHLDHU_40b_317 (Vreg4 &s1, S6 &s2, Vreg4 &s3)","UNSIGNED,"]},{"entry":["{","RELATIVE"]},{"entry":["\u2002Result addrlo,addrhi;","HORIZONTAL"]},{"entry":["\u2002addrlo.range(0,19) = _unsigned((s1.range(0,12)<<6))","ACCESS"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _signed(s2)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _unsigned(((HG_POSN.range(0,7)<<6) | POSN.range(0,5",{}]},{"entry":[")));",{}]},{"entry":["\u2002addrhi.range(0,19) = _unsigned((s1.range(16,27)<<6))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _signed(s2)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _unsigned(((HG_POSN.range(0,7)<<6) | POSN.range(0,5",{}]},{"entry":[")));",{}]},{"entry":["\u2002s3.range(0,15) = fmem0->uhalf(addrlo);",{}]},{"entry":["\u2002s3.range(16,31) = fmem1->uhalf(addrhi);",{}]},{"entry":["}",{}]},{"entry":["RHSTH .(VP3,VP4) s1(R4), s2(R4),s3(R4)","STORE HALF,"]},{"entry":["void ISA::OPCV_RHSTH_20b_297 (Vreg4 &s1, Vreg4 &s2, Vreg4 &s3","RELATIVE"]},{"entry":[")","HORIZONTAL"]},{"entry":["{","ACCESS"]},{"entry":["\u2002Result addrlo,addrhi;",{}]},{"entry":["\u2002addrlo.range(0,19) = _unsigned((s1.range(0,12)<<6))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _signed(s2.range(0,13))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _unsigned(((HG_POSN.range(0,7)<<6) | POSN.range(0,5",{}]},{"entry":[")));",{}]},{"entry":["\u2002addrhi.range(0,19) = _unsigned((s1.range(16,27)<<6))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _signed(s2.range(16,29))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _unsigned(((HG_POSN.range(0,7)<<6) | POSN.range(0,5",{}]},{"entry":[")));",{}]},{"entry":["\u2002fmem0->half(addrlo) = s3.range(0,15);;",{}]},{"entry":["\u2002fmem1->half(addrhi) = s3.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["RHSTH .(VP3,VP4) s1(R4), s2(S6), s3(R4)","STORE HALF,"]},{"entry":["void ISA::OPCV_RHSTH_40b_318 (Vreg4 &s1, S6 &s2, Vreg4 &s3)","RELATIVE"]},{"entry":["{","HORIZONTAL"]},{"entry":["\u2002Result addrlo,addrhi;","ACCESS"]},{"entry":["\u2002addrlo.range(0,19) = _unsigned((s1.range(0,12)<<6))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _signed(s2)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _unsigned(((HG_POSN.range(0,7)<<6) | POSN.range(0,5",{}]},{"entry":[")));",{}]},{"entry":["\u2002addrhi.range(0,19) = _unsigned((s1.range(16,27)<<6))",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _signed(s2)",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003+ _unsigned(((HG_POSN.range(0,7)<<6) | POSN.range(0,5",{}]},{"entry":[")));",{}]},{"entry":["\u2002fmem0->half(addrlo) = s3.range(0,15);;",{}]},{"entry":["\u2002fmem1->half(addrhi) = s3.range(16,31);",{}]},{"entry":["}",{}]},{"entry":["RLD .V4 *+s1(R2)[s2(S6)], s3(R2), s4(R4)","RELATIVE LOAD,"]},{"entry":["void ISA::OPCV_RLD_20b_401 (Gpr2 &s1, S6 &s2, Vreg2 &s3, Vreg","IMM FORM"]},{"entry":["&s4)",{}]},{"entry":["{",{}]},{"entry":["\u2002risc_vsr_rdz._assert(D0,0);",{}]},{"entry":["\u2002risc_vsr_ra._assert(D0,s3.address( ));",{}]},{"entry":["\u2002Result rVSR = risc_vsr_rdata.read( );",{}]},{"entry":["\u2002risc_regf_ra1._assert(D0,s1.address( ));",{}]},{"entry":["\u2002risc_regf_rd1z._assert(D0,0);",{}]},{"entry":["\u2002Result rBase = risc_regf_rd1.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002bool vb_lo = s3.bit(15);",{}]},{"entry":["\u2002bool vb_hi = s3.bit(31);",{}]},{"entry":["\u2002bool sfmblock = rVSR.range(9,10) == 0x00;",{}]},{"entry":["\u2002bool mirror \u2002= rVSR.range(9,10) == 0x01;",{}]},{"entry":["\u2002bool repeat \u2002= rVSR.range(9,10) == 0x02;",{}]},{"entry":["\u2002bool saturate = rVSR.range(9,10) == 0x03;",{}]},{"entry":["\u2002bool saturate_lo = saturate && vb_lo;",{}]},{"entry":["\u2002bool saturate_hi = saturate && vb_hi;",{}]},{"entry":["\u2002if(saturate_lo && saturate_hi)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s4 = 0x7FFF7FFF;",{}]},{"entry":["\u2003return;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002int base = rBase.range( 0,15);",{}]},{"entry":["\u2002int v_index_lo = s3.range( 0,14);",{}]},{"entry":["\u2002int v_index_hi = s3.range(16,30);",{}]},{"entry":["\u2002Result rPOSN = risc_posn.read( );",{}]},{"entry":["\u2002int posn_lo = (rPOSN.range(0,3)<<1) + 1;",{}]},{"entry":["\u2002int posn_hi = (rPOSN.range(0,3)<<1);",{}]},{"entry":["\u2002int pos2_lo = (rHG_POSN.range(0,7) << 5) | posn_lo;",{}]},{"entry":["\u2002int pos2_hi = (rHG_POSN.range(0,7) << 5) | posn_hi;",{}]},{"entry":["\u2002int s_offset \u2002= sign_extend(s2);",{}]},{"entry":["\u2002int h_index_lo = s_offset + pos2_lo;",{}]},{"entry":["\u2002int h_index_hi = s_offset + pos2_hi;",{}]},{"entry":["\u2002int hg_size \u2003= rVSR.range(0,7);",{}]},{"entry":["\u2002int hg_size_32 = hg_size + 32;",{}]},{"entry":["\u2002bool left_size_lo = (h_index_lo < 0);",{}]},{"entry":["\u2002bool right_size_lo = (h_index_lo >= hg_size_32);",{}]},{"entry":["\u2002bool left_size_hi = (h_index_hi < 0);",{}]},{"entry":["\u2002bool right_size_hi = (h_index_hi >= hg_size_32);",{}]},{"entry":["\u2002bool bounded_lo = !sfmblock && (left_size_lo || right_size_lo);",{}]},{"entry":["\u2002bool bounded_hi = !sfmblock && (left_size_hi || right_size_hi);",{}]},{"entry":["\u2002if((bounded_lo && saturate))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s4.range( 0,15) = 0x7FFF;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(bounded_lo && mirror)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(left_size_lo) h_index_lo = \u2212h_index_lo;",{}]},{"entry":["\u2003\u2002else \u2003\u2003\u2003h_index_lo = (hg_size_32<<1)\u2212h_index_lo;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003if(bounded_lo && repeat)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(left_size_lo) h_index_lo = 0;",{}]},{"entry":["\u2003\u2002else \u2003\u2003\u2003h_index_lo = hg_size_32 \u2212 1;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003int addr_lo = h_index_lo + base + v_index_lo;",{}]},{"entry":["\u2003s4.range( 0,15) = vmemLo->uhalf(addr_lo);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002\/\/High range",{}]},{"entry":["\u2002if((bounded_hi && saturate))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s4.range(16,31) = 0x7FFF;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(bounded_hi && mirror)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(left_size_hi) h_index_hi = \u2212h_index_hi;",{}]},{"entry":["\u2003\u2002else \u2003\u2003\u2003h_index_hi = (hg_size_32<<1)\u2212h_index_hi;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003if(bounded_hi && repeat)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(left_size_hi) h_index_hi = 0;",{}]},{"entry":["\u2003\u2002else \u2003\u2003\u2003h_index_hi = hg_size_32 \u2212 1;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003int addr_hi = h_index_hi + base + v_index_hi;",{}]},{"entry":["\u2003s4.range(16,31) = vmemHi->uhalf(addr_hi);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["RLD .V4 *+s1(R2)[s2(R4)], s3(R2), s4(R4)","RELATIVE LOAD,"]},{"entry":["void ISA::OPCV_RLD_20b_403 (Gpr2 &s1, Vreg &s2, Vreg2 &s3, Vreg","REG FORM"]},{"entry":["&s4)",{}]},{"entry":["{",{}]},{"entry":["\u2002risc_vsr_rdz._assert(D0,0);",{}]},{"entry":["\u2002risc_vsr_ra._assert(D0,s3.address( ));",{}]},{"entry":["\u2002Result rVSR = risc_vsr_rdata.read( );",{}]},{"entry":["\u2002risc_regf_ra1._assert(D0,s1.address( ));",{}]},{"entry":["\u2002risc_regf_rd1z._assert(D0,0);",{}]},{"entry":["\u2002Result rBase = risc_regf_rd1.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002bool vp_lo = s3.bit(15);",{}]},{"entry":["\u2002bool vp_hi = s3.bit(31);",{}]},{"entry":["\u2002bool sfmblock = rVSR.range(9,10) == 0x00;",{}]},{"entry":["\u2002bool mirror \u2002= rVSR.range(9,10) == 0x01;",{}]},{"entry":["\u2002bool repeat \u2002= rVSR.range(9,10) == 0x02;",{}]},{"entry":["\u2002bool saturate = rVSR.range(9,10) == 0x03;",{}]},{"entry":["\u2002bool saturate_lo = saturate && vp_lo;",{}]},{"entry":["\u2002bool saturate_hi = saturate && vp_hi;",{}]},{"entry":["\u2002if(saturate_lo && saturate_hi)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s4 = 0x7FFF7FFF;",{}]},{"entry":["\u2003return;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002int base = rBase.range( 0,15);",{}]},{"entry":["\u2002int v_index_lo = s3.range( 0,14);",{}]},{"entry":["\u2002int v_index_hi = s3.range(16,30);",{}]},{"entry":["\u2002Result rPOSN = risc_posn.read( );",{}]},{"entry":["\u2002int posn_lo = (rPOSN.range(0,3)<<1) + 1;",{}]},{"entry":["\u2002int posn_hi = (rPOSN.range(0,3)<<1);",{}]},{"entry":["\u2002int pos2_lo = (rHG_POSN.range(0,7) << 5) | posn_lo;",{}]},{"entry":["\u2002int pos2_hi = (rHG_POSN.range(0,7) << 5) | posn_hi;",{}]},{"entry":["\u2002int s_offset_lo = sign_extend(s2.range( 0,15));",{}]},{"entry":["\u2002int s_offset_hi = sign_extend(s2.range(16,31));",{}]},{"entry":["\u2002int h_index_lo = s_offset_lo + pos2_lo;",{}]},{"entry":["\u2002int h_index_hi = s_offset_hi + pos2_hi;",{}]},{"entry":["\u2002int hg_size \u2002= rVSR.range(0,7);",{}]},{"entry":["\u2002int hg_size_32 = hg_size + 32;",{}]},{"entry":["\u2002bool left_size_lo = (h_index_lo < 0);",{}]},{"entry":["\u2002bool right_size_lo = (h_index_lo >= hg_size_32);",{}]},{"entry":["\u2002bool left_size_hi = (h_index_hi < 0);",{}]},{"entry":["\u2002bool right_size_hi = (h_index_hi >= hg_size_32);",{}]},{"entry":["\u2002bool bounded_lo = !sfmblock && (left_size_lo || right_size_lo);",{}]},{"entry":["\u2002bool bounded_hi = !sfmblock && (left_size_hi || right_size_hi);",{}]},{"entry":["\u2002if((bounded_lo && saturate))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s4.range( 0,15) = 0x7FFF;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(bounded_lo && mirror)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(left_size_lo) h_index_lo = \u2212h_index_lo;",{}]},{"entry":["\u2003\u2002else \u2003\u2003\u2003h_index_lo = (hg_size_32<<1)\u2212h_index_lo;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003if(bounded_lo && repeat)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(left_size_lo) h_index_lo = 0;",{}]},{"entry":["\u2003\u2002else \u2003\u2003\u2003h_index_lo = hg_size_32 \u2212 1;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003int addr_lo = h_index_lo + base + v_index_lo;",{}]},{"entry":["\u2003s4.range( 0,15) = vmemLo->uhalf(addr_lo);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if((bounded_hi && saturate))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s4.range(16,31) = 0x7FFF;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(bounded_hi && mirror)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(left_size_hi) h_index_hi = \u2212h_index_hi;",{}]},{"entry":["\u2003\u2002else \u2003\u2003\u2003h_index_hi = (hg_size_32<<1)\u2212h_index_hi;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003if(bounded_hi && repeat)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(left_size_hi) h_index_hi = 0;",{}]},{"entry":["\u2003\u2002else \u2003\u2003\u2003h_index_hi = hg_size_32 \u2212 1;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003int addr_hi = h_index_hi + base + v_index_hi;",{}]},{"entry":["\u2003s4.range(16,31) = vmemHi->uhalf(addr_hi);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ROT .(SA,SB) s1(R4), s2(R4)","ROTATE"]},{"entry":["void ISA::OPC_ROT_20b_93 (Gpr &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003int bit = s2.bit(0);",{}]},{"entry":["\u2003unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003s2 = (bit<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ROT .(SA,SB) s1(U4), s2(R4)","ROTATE, U4 IMM"]},{"entry":["void ISA::OPC_ROT_20b_94 (U4 &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003int bit = s2.bit(0);",{}]},{"entry":["\u2003unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003s2 = (bit<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ROT .(V,VP) s1(R4), s2(R4)","ROTATE"]},{"entry":["void ISA::OPCV_ROT_20b_46 (Vreg4 &s1, Vreg4 &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003\/\/Lower",{}]},{"entry":["\u2003Reg s2lo(s2.range(LSBL,MSBL));",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit = s2lo.bit(0);",{}]},{"entry":["\u2003\u2002unsigned int us2 = _unsigned(s2lo);",{}]},{"entry":["\u2003\u2002s2lo = (bit<<s2lo.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003\/\/Upper",{}]},{"entry":["\u2003Reg s2hi(s2.range(LSBL,MSBL));",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit = s2hi.bit(0);",{}]},{"entry":["\u2003\u2002unsigned int us2 = _unsigned(s2hi);",{}]},{"entry":["\u2003\u2002s2hi = (bit<<s2hi.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = s2lo.value( );",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = s2hi.value( );",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2lo==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2hi==0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit = s2.bit(0);",{}]},{"entry":["\u2003\u2002unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003\u2002s2 = (bit<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ROT .(V,VP) s1(U4), s2(R4)","ROTATE, U4 IMM"]},{"entry":["void ISA::OPCV_ROT_20b_47 (U4 &s1, Vreg4 &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003\/\/Lower",{}]},{"entry":["\u2003Reg s2lo(s2.range(LSBL,MSBL));",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit = s2lo.bit(0);",{}]},{"entry":["\u2003\u2002unsigned int us2 = _unsigned(s2lo);",{}]},{"entry":["\u2003\u2002s2lo = (bit<<s2lo.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003\/\/Upper",{}]},{"entry":["\u2003Reg s2hi = s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit = s2hi.bit(0);",{}]},{"entry":["\u2003\u2002unsigned int us2 = _unsigned(s2hi);",{}]},{"entry":["\u2003\u2002s2hi = (bit<<s2hi.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = s2lo.value( );",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = s2hi.value( );",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2lo==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2hi==0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit = s2.bit(0);",{}]},{"entry":["\u2003\u2002unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003\u2002s2 = (bit<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ROTC .(SA,SB) s1(R4), s2(R4)","ROTATE THRU"]},{"entry":["void ISA::OPC_ROTC_20b_95 (Gpr &s1, Gpr &s2,Unit &unit)","CARRY"]},{"entry":["{",{}]},{"entry":["\u2002for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003int bit = s2.bit(0);",{}]},{"entry":["\u2003unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003s2 = (Csr.bit(C,unit)<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003Csr.bit(C,unit) = bit;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ROTC .(SA,SB) s1(U4), s2(R4)","ROTATE THRU"]},{"entry":["void ISA::OPC_ROTC_20b_96 (U4 &s1, Gpr &s2,Unit &unit)","CARRY, U4 IMM"]},{"entry":["{",{}]},{"entry":["\u2002for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003int bit = s2.bit(0);",{}]},{"entry":["\u2003unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003s2 = (Csr.bit(C,unit)<<s2.width( )\u22121) | (us2 >> 1);",{}]},{"entry":["\u2003Csr.bit(C,unit) = bit;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["ROTC .(Vx,VPx,VBx) s1(R4), s2(R4)","ROTATE THRU"]},{"entry":["Code:","CARRY"]},{"entry":["void ISA::OPCV_ROTC_20b_95 (Vreg4 &s1, Vreg4 &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002if(isVunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit = s2.bit(0);",{}]},{"entry":["\u2003\u2002unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003\u2002s2 = (Vr15.bit(tCA)<<(s2.width( )\u22121)) | (us2 >> 1);",{}]},{"entry":["\u2003\u2002Csr.bit(C,unit) = bit;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003unsigned int width = s2.width( )>>1;",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bitlo = s2.bit(0);",{}]},{"entry":["\u2003\u2002int bithi = s2.bit(16);",{}]},{"entry":["\u2003\u2002unsigned int us2lo = _unsigned(s2.range(0,15));",{}]},{"entry":["\u2003\u2002unsigned int us2hi = _unsigned(s2.range(16,31));",{}]},{"entry":["\u2003\u2002s2.range(0,15) = (Vr15.bit(tCA)<<(width\u22121)) | (us2lo >> 1);",{}]},{"entry":["\u2003\u2002s2.range(16,31) = (Vr15.bit(tCB)<<(width\u22121)) | (us2hi >> 1);",{}]},{"entry":["\u2003\u2002Vr15.bit(tCA) = bitlo;",{}]},{"entry":["\u2003\u2002Vr15.bit(tCB) = bithi;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Vr15.bit(tCA) = s2.bit(0);",{}]},{"entry":["\u2003Vr15.bit(tCB) = s2.bit(16);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003unsigned int width = s2.width( )>>2;",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit0 = s2.bit(0);",{}]},{"entry":["\u2003\u2002int bit8 = s2.bit(8);",{}]},{"entry":["\u2003\u2002int bit16 = s2.bit(16);",{}]},{"entry":["\u2003\u2002int bit24 = s2.bit(24);",{}]},{"entry":["\u2003\u2002unsigned int us2_0 = _unsigned(s2.range(0,7));",{}]},{"entry":["\u2003\u2002unsigned int us2_8 = _unsigned(s2.range(8,15));",{}]},{"entry":["\u2003\u2002unsigned int us2_16 = _unsigned(s2.range(16,23));",{}]},{"entry":["\u2003\u2002unsigned int us2_24 = _unsigned(s2.range(24,31));",{}]},{"entry":["\u2003\u2002s2.range(0,7) = (Vr15.bit(tCA)<<(width\u22121)) | (us2_0 >> 1);",{}]},{"entry":["\u2003\u2002s2.range(8,15) = (Vr15.bit(tCB)<<(width\u22121)) | (us2_8 >> 1);",{}]},{"entry":["\u2003\u2002s2.range(16,23) = (Vr15.bit(tCC)<<(width\u22121)) | (us2_16 >> 1);",{}]},{"entry":["\u2003\u2002s2.range(24,31) = (Vr15.bit(tCD)<<(width\u22121)) | (us2_24 >> 1);",{}]},{"entry":["\u2003\u2002Vr15.bit(tCA) = bit0;",{}]},{"entry":["\u2003\u2002Vr15.bit(tCB) = bit8;",{}]},{"entry":["\u2003\u2002Vr15.bit(tCC) = bit16;",{}]},{"entry":["\u2003\u2002Vr15.bit(tCD) = bit24;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Vr15.bit(tCA) = s2.bit(0);",{}]},{"entry":["\u2003Vr15.bit(tCB) = s2.bit(8);",{}]},{"entry":["\u2003Vr15.bit(tCC) = s2.bit(16);",{}]},{"entry":["\u2003Vr15.bit(tCD) = s2.bit(24);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["ROTC .(Vx,VPx,VBx) s1(U4), s2(R4)","ROTATE THRU"]},{"entry":["void ISA::OPCV_ROTC_20b_96 (U4 &s1, Vreg4 &s2, Unit &unit)","CARRY, U4 IMM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit = s2.bit(0);",{}]},{"entry":["\u2003\u2002unsigned int us2 = _unsigned(s2);",{}]},{"entry":["\u2003\u2002s2 = (Vr15.bit(tCA)<<(s2.width( )\u22121)) | (us2 >> 1);",{}]},{"entry":["\u2003\u2002Csr.bit(C,unit) = bit;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003unsigned int width = s2.width( )>>1;",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bitlo = s2.bit(0);",{}]},{"entry":["\u2003\u2002int bithi = s2.bit(16);",{}]},{"entry":["\u2003\u2002unsigned int us2lo = _unsigned(s2.range(0,15));",{}]},{"entry":["\u2003\u2002unsigned int us2hi = _unsigned(s2.range(16,31));",{}]},{"entry":["\u2003\u2002s2.range(0,15) = (Vr15.bit(tCA)<<(width\u22121)) | (us2lo >> 1);",{}]},{"entry":["\u2003\u2002s2.range(16,31) = (Vr15.bit(tCB)<<(width\u22121)) | (us2hi >> 1);",{}]},{"entry":["\u2003\u2002Vr15.bit(tCA) = bitlo;",{}]},{"entry":["\u2003\u2002Vr15.bit(tCB) = bithi;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Vr15.bit(tCA) = s2.bit(0);",{}]},{"entry":["\u2003Vr15.bit(tCB) = s2.bit(16);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003unsigned int width = s2.width( )>>2;",{}]},{"entry":["\u2003for(int i=0;i<s1.value( );++i)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int bit0 = s2.bit(0);",{}]},{"entry":["\u2003\u2002int bit8 = s2.bit(8);",{}]},{"entry":["\u2003\u2002int bit16 = s2.bit(16);",{}]},{"entry":["\u2003\u2002int bit24 = s2.bit(24);",{}]},{"entry":["\u2003\u2002unsigned int us2_0 = _unsigned(s2.range(0,7));",{}]},{"entry":["\u2003\u2002unsigned int us2_8 = _unsigned(s2.range(8,15));",{}]},{"entry":["\u2003\u2002unsigned int us2_16 = _unsigned(s2.range(16,23));",{}]},{"entry":["\u2003\u2002unsigned int us2_24 = _unsigned(s2.range(24,31));",{}]},{"entry":["\u2003\u2002s2.range(0,7) \u2009= (Vr15.bit(tCA)<<(width\u22121)) | (us2_0 >> 1);",{}]},{"entry":["\u2003\u2002s2.range(8,15) = (Vr15.bit(tCB)<<(width\u22121)) | (us2_8 >> 1);",{}]},{"entry":["\u2003\u2002s2.range(16,23) = (Vr15.bit(tCC)<<(width\u22121)) | (us2_16 >> 1);",{}]},{"entry":["\u2003\u2002s2.range(24,31) = (Vr15.bit(tCD)<<(width\u22121)) | (us2_24 >> 1);",{}]},{"entry":["\u2003\u2002Vr15.bit(tCA) = bit0;",{}]},{"entry":["\u2003\u2002Vr15.bit(tCB) = bit8;",{}]},{"entry":["\u2003\u2002Vr15.bit(tCC) = bit16;",{}]},{"entry":["\u2003\u2002Vr15.bit(tCD) = bit24;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003Vr15.bit(tCA) = s2.bit(0);",{}]},{"entry":["\u2003Vr15.bit(tCB) = s2.bit(8);",{}]},{"entry":["\u2003Vr15.bit(tCC) = s2.bit(16);",{}]},{"entry":["\u2003Vr15.bit(tCD) = s2.bit(24);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["RST .V4 *+s1(R2)[s2(R4)], s3(R2), s4(R4)","RELATIVE"]},{"entry":["void ISA::OPCV_RST_20b_404 (Gpr2 &s1, Vreg &s2, Vreg2 &s3, Vreg","STORE, REG"]},{"entry":["&s4)","FORM"]},{"entry":["{",{}]},{"entry":["\u2002risc_vsr_rdz._assert(D0,0);",{}]},{"entry":["\u2002risc_vsr_ra._assert(D0,s3.address( ));",{}]},{"entry":["\u2002Result rVSR = risc_vsr_rdata.read( );",{}]},{"entry":["\u2002bool store_disable = rVSR.bit(8);",{}]},{"entry":["\u2002if(store_disable) return;",{}]},{"entry":["\u2002risc_regf_ra1._assert(D0,s1.address( ));",{}]},{"entry":["\u2002risc_regf_rd1z._assert(D0,0);",{}]},{"entry":["\u2002Result rBase = risc_regf_rd1.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002bool vb_lo = s3.bit(15);",{}]},{"entry":["\u2002bool vb_hi = s3.bit(31);",{}]},{"entry":["\u2002if(vb_lo && vb_hi) return;",{}]},{"entry":["\u2002int base = rBase.range( 0,15);",{}]},{"entry":["\u2002int v_index_lo = s3.range( 0,14);",{}]},{"entry":["\u2002int v_index_hi = s3.range(16,30);",{}]},{"entry":["\u2002Result rPOSN = risc_posn.read( );",{}]},{"entry":["\u2002int posn_lo = (rPOSN.range(0,3)<<1) + 1;",{}]},{"entry":["\u2002int posn_hi = (rPOSN.range(0,3)<<1);",{}]},{"entry":["\u2002int pos2_lo = (rHG_POSN.range(0,7) << 5) | posn_lo;",{}]},{"entry":["\u2002int pos2_hi = (rHG_POSN.range(0,7) << 5) | posn_hi;",{}]},{"entry":["\u2002int s_offset_lo = sign_extend(s2.range( 0,15));",{}]},{"entry":["\u2002int s_offset_hi = sign_extend(s2.range(16,31));",{}]},{"entry":["\u2002int h_index_lo = s_offset_lo + pos2_lo;",{}]},{"entry":["\u2002int h_index_hi = s_offset_hi + pos2_hi;",{}]},{"entry":["\u2002int hg_size \u2002= rVSR.range(0,7);",{}]},{"entry":["\u2002int hg_size_32 = hg_size + 32;",{}]},{"entry":["\u2002bool suppress_lo = (h_index_lo < 0) || (h_index_lo >= hg_size_32) || vb_lo;",{}]},{"entry":["\u2002bool suppress_hi = (h_index_hi < 0) || (h_index_hi >= hg_size_32) || vb_hi;",{}]},{"entry":["\u2002if(!suppress_lo)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003int addr_lo = h_index_lo + base + v_index_lo;",{}]},{"entry":["\u2003vmemLo->uhalf(addr_lo) = s4.range( 0,15);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(!suppress_hi)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003int addr_hi = h_index_hi + base + v_index_hi;",{}]},{"entry":["\u2003vmemHi->uhalf(addr_hi) = s4.range(16,31);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["RST .V4 *+s1(R2)[s2(S6)], s3(R2), s4(R4)","RELATIVE"]},{"entry":["void ISA::OPCV_RST_20b_402 (Gpr2 &s1, S6 &s2, Vreg2 &s3, Vreg","STORE, IMM"]},{"entry":["&s4)","FORM"]},{"entry":["{",{}]},{"entry":["\u2002risc_vsr_rdz._assert(D0,0);",{}]},{"entry":["\u2002risc_vsr_ra._assert(D0,s3.address( ));",{}]},{"entry":["\u2002Result rVSR = risc_vsr_rdata.read( );",{}]},{"entry":["\u2002bool store_disable = rVSR.bit(8);",{}]},{"entry":["\u2002if(store_disable) return;",{}]},{"entry":["\u2002risc_regf_ra1._assert(D0,s1.address( ));",{}]},{"entry":["\u2002risc_regf_rd1z._assert(D0,0);",{}]},{"entry":["\u2002Result rBase = risc_regf_rd1.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002bool vb_lo = s3.bit(15);",{}]},{"entry":["\u2002bool vb_hi = s3.bit(31);",{}]},{"entry":["\u2002if(vb_lo && vb_hi) return;",{}]},{"entry":["\u2002int base = rBase.range( 0,15);",{}]},{"entry":["\u2002int v_index_lo = s3.range( 0,14);",{}]},{"entry":["\u2002int v_index_hi = s3.range(16,30);",{}]},{"entry":["\u2002Result rPOSN = risc_posn.read( );",{}]},{"entry":["\u2002int posn_lo = (rPOSN.range(0,3)<<1) + 1;",{}]},{"entry":["\u2002int posn_hi = (rPOSN.range(0,3)<<1);",{}]},{"entry":["\u2002int pos2_lo = (rHG_POSN.range(0,7) << 5) | posn_lo;",{}]},{"entry":["\u2002int pos2_hi = (rHG_POSN.range(0,7) << 5) | posn_hi;",{}]},{"entry":["\u2002int s_offset \u2002= sign_extend(s2);",{}]},{"entry":["\u2002int h_index_lo = s_offset + pos2_lo;",{}]},{"entry":["\u2002int h_index_hi = s_offset + pos2_hi;",{}]},{"entry":["\u2002int hg_size = rVSR.range(0,7);",{}]},{"entry":["\u2002int hg_size_32 = hg_size + 32;",{}]},{"entry":["\u2002bool suppress_lo = (h_index_lo < 0) || (h_index_lo >= hg_size_32) || vb_lo;",{}]},{"entry":["\u2002bool suppress_hi = (h_index_hi < 0) || (h_index_hi >= hg_size_32) || vb_hi;",{}]},{"entry":["\u2002if(!suppress_lo)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003int addr_lo = h_index_lo + base + v_index_lo;",{}]},{"entry":["\u2003vmemLo->uhalf(addr_lo) = s4.range( 0,15);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(!suppress_hi)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003int addr_hi = h_index_hi + base + v_index_hi;",{}]},{"entry":["\u2003vmemHi->uhalf(addr_hi) = s4.range(16,31);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["RSUB .(SA,SB) s1(U4), s2(R4)","REVERSE"]},{"entry":["void ISA::OPC_RSUB_20b_125 (U4 &s1, Gpr &s2,Unit &unit)","SUBTRACT"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s1 \u2212 s2;",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["RSUB .(V,VP) s1(U4), s2(R4)","REVERSE"]},{"entry":["void ISA::OPCV_RSUB_20b_75 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","SUBTRACT"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s2lo = s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003Reg s2hi = s2.range(LSBU,MSBU);",{}]},{"entry":["\u2003Result r1lo = s1 \u2212 s2lo;",{}]},{"entry":["\u2003Result r1hi = s1 \u2212 s2hi;",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = r1lo.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = r1hi.range(LSBU,MSBU);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1,s2lo,r1lo);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1,s2hi,r1hi);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result r1 = s1 \u2212 s2;",{}]},{"entry":["\u2003s2 = r1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,r1);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SABSD .(VBx,VPx) s1(R4), s2(R4)","ABSOLUTE"]},{"entry":["void ISA::OPCV_SABSD_20b_52 (Vreg4 &s1 , Vreg4 &s2, Unit &unit)","DIFFERENCE"]},{"entry":["{","AND SUM"]},{"entry":["\u2002if(isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = _abs(s2.range(24,31) \u2212 s1.range(24,31))",{}]},{"entry":["\u2003\u2003+ _abs(s2.range(16,23) \u2212 s1.range(16,23))",{}]},{"entry":["\u2003\u2003+ _abs(s2.range(8,15) \u2212 s1.range(8,15))",{}]},{"entry":["\u2003\u2003+ _abs(s2.range(0,7) \u2212 s1.range(0,7));",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = _abs(s2.range(16,31) \u2212 s1.range(16,31));",{}]},{"entry":["\u2003\u2003+ _abs(s2.range(0,15) \u2212 s1.range(0,15));",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SABSDU .(VBx,VPx) s1(R4), s2(R4)","ABSOLUTE"]},{"entry":["void ISA::OPCV_SABSDU_20b_53 (Vreg4 &s1, Vreg4 &s2, Unit &unit","DIFFERENCE"]},{"entry":[")","AND SUM,"]},{"entry":["{","UNSIGNED"]},{"entry":["\u2002if(isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = _abs(_unsigned(s2.range(24,31)) \u2212 _unsigned(s1.range(24,31)))",{}]},{"entry":["\u2003\u2002+ _abs(_unsigned(s2.range(16,23)) \u2212 _unsigned(s1.range(16,23)))",{}]},{"entry":["\u2003\u2002+ _abs(_unsigned(s2.range(8,15)) \u2212 _unsigned(s1.range(8,15)))",{}]},{"entry":["\u2003\u2002+ _abs(_unsigned(s2.range(0,7)) \u2212 _unsigned(s1.range(0,7)));",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = _abs(_unsigned(s2.range(16,31)) \u2212 _unsigned(s1.range(16,31)))",{}]},{"entry":["\u2003\u2002+ _abs(_unsigned(s2.range(0,15)) \u2212 _unsigned(s1.range(0,15)));",{}]},{"entry":["\u2002}",{}]},{"entry":["SADD .(SA,SB) s1(R4), s2(R4)","SATURATING"]},{"entry":["void ISA::OPC_SADD_20b_127 (Gpr &s1, Gpr &s2,Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2 + s1;",{}]},{"entry":["\u2002if(r1.overflow( )) \u2003s2 = 0xFFFFFFFF;",{}]},{"entry":["\u2002else if(r1.underflow( )) s2 = 0;",{}]},{"entry":["\u2002else \u2003\u2003\u2003\u2003s2 = r1;",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2002Csr.bit(EQ, unit) = s2.zero( );",{}]},{"entry":["\u2002Csr.bit(SAT,unit) = r1.overflow( ) | r1.underflow( );",{}]},{"entry":["}",{}]},{"entry":["SADD .(V,VP) s1(R4), s2(R4)","SATURATING"]},{"entry":["void ISA::OPCV_SADD_20b_76 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","ADDITION"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result r1,r2;",{}]},{"entry":["\u2003r1 = s2.range(0,15) + s1.range(0,15);",{}]},{"entry":["\u2003r2 = s2.range(16,31) + s1.range(16,31);",{}]},{"entry":["\u2003if(r1 > 0xFFFF) s2.range(0,15) = 0xFFFF;",{}]},{"entry":["\u2003else if(r1 < 0) s2.range(0,15) = 0;",{}]},{"entry":["\u2003else \u2003\u2003\u2003s2.range(0,15) = r1.range(0,15);",{}]},{"entry":["\u2003if(r2 > 0xFFFF) s2.range(16,31) = 0xFFFF;",{}]},{"entry":["\u2003else if(r2 < 0) s2.range(16,31) = 0;",{}]},{"entry":["\u2003else \u2003\u2003\u2003s2.range(16,31) = r2.range(0,15);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1,s2,r1);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1,s2,r2);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 + s1;",{}]},{"entry":["\u2003if(r1.overflow( )) \u2003s2 = 0xFFFFFFFF;",{}]},{"entry":["\u2003else if(r1.underflow( )) s2 = 0;",{}]},{"entry":["\u2003else \u2003\u2003\u2003s2 = r1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,r1);",{}]},{"entry":["\u2003Vr15.bit(SAT) = isSat(s1,s2,r1);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SETB .(SA,SB) s1(U2), s2(U2), s3(R4)","SET BYTE FIELD"]},{"entry":["void ISA::OPC_SETB_20b_97 (U2 &s1,U2 &s2,Gpr &s3,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002s3.range(s1*8,((s2+1)*8)\u22121) = 1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["SETB .(V) s1(U2), s2(U2), s3(R4)","SET BYTE FIELD"]},{"entry":["void ISA::OPCV_SETB_20b_48 (U2 &s1, U2 &s2, Vreg4 &s3)",{}]},{"entry":["{",{}]},{"entry":["\u2002s3.range(s1*8,((s2+1)*8)\u22121) = 1;",{}]},{"entry":["\u2002Vr15.bit(EQ) = s3==0;",{}]},{"entry":["}",{}]},{"entry":["SEXT .(SA,SB) s1(U3), s2(R4)","SIGN EXTEND"]},{"entry":["void ISA::OPC_SEXT_20b_79 (U3 &s1, Gpr &s2)",{}]},{"entry":["{",{}]},{"entry":["\u2002switch(s1.value( ))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003case 0: s2 = sign_extend(s2.range(0,7));",{}]},{"entry":["\u2003case 1: s2 = sign_extend(s2.range(0,15));",{}]},{"entry":["\u2003case 2: s2 = sign_extend(s2.range(0,23));",{}]},{"entry":["\u2003case 3: s2 = s2.undefined(true); \/\/future expansion",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SEXT .(V,VP) s1(U3), s2(R4)","SIGN EXTEND"]},{"entry":["void ISA::OPCV_SEXT_20b_34 (U3 &s1, Vreg4 &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(0,15 ) = sign_extend(s2.range(0, 7 ));",{}]},{"entry":["\u2003s2.range(16,31) = sign_extend(s2.range(16,23));",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003switch(s1.value( ))",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002case 0: s2 = sign_extend(s2.range(0,7));",{}]},{"entry":["\u2003\u2002case 1: s2 = sign_extend(s2.range(0,15));",{}]},{"entry":["\u2003\u2002case 2: s2 = sign_extend(s2.range(0,23));",{}]},{"entry":["\u2003\u2002case 3: s2 = s2.undefined(true); \/\/future expansion",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SHL .(SA,SB) s1(R4), s2(R4)","SHIFT LEFT"]},{"entry":["void ISA::OPC_SHL_20b_98 (Gpr &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002s2 = s2 << s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHL .(SA,SB) s1(U4), s2(R4)","SHIFT LEFT, U4"]},{"entry":["void ISA::OPC_SHL_20b_99 (U4 &s1,Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2002s2 = s2 << s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHL .(V,VP) s1(R4), s2(R4)","SHIFT LEFT"]},{"entry":["void ISA::OPCV_SHL_20b_49 (Vreg4 &s1, Vreg4 &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = s2.range(LSBL,MSBL) << s1.value( );",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = s2.range(LSBU,MSBU) << s1.value( );",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s2 << s1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SHL .(V,VP) s1(U4), s2(R4)","SHIFT LEFT, U4"]},{"entry":["void ISA::OPCV_SHL_20b_50 (U4 &s1, Vreg4 &s2, Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = s2.range(LSBL,MSBL) << zero_extend(s1);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = s2.range(LSBU,MSBU) << zero_extend(s1)",{}]},{"entry":[";",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s2 << zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SHR .(SA,SB) s1(R4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPC_SHR_20b_102 (Gpr &s1, Gpr &s2,Unit &unit)","SIGNED"]},{"entry":["{",{}]},{"entry":["\u2002s2 = s2 >> s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHR .(SA,SB) s1(U4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPC_SHR_20b_103 (U4 &s1, Gpr &s2,Unit &unit)","SIGNED, U4 IMM"]},{"entry":["{",{}]},{"entry":["\u2002s2 = s2 >> s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHR .(V,VP) s1(R4), s2(R4)","SHIFT RIGHT,"]},{"entry":["Code:","SIGNED"]},{"entry":["void ISA::OPCV_SHR_20b_53 (Vreg4 &s1, Vreg4 &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = s2.range(LSBL,MSBL) >> s1.value( );",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = s2.range(LSBU,MSBU) >> s1.value( );",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s2 >> s1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SHR .(V,VP) s1(U4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPCV_SHR_20b_54 (U4 &s1, Vreg4 &s2, Unit &unit)","SIGNED, U4 IMM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = s2.range(LSBL,MSBL) >> zero_extend(s1);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = s2.range(LSBU,MSBU) >> zero_extend(s1)",{}]},{"entry":[";",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s2 >> zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SHRU .(SA,SB) s1(R4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPC_SHRU_20b_100 (Gpr &s1, Gpr &s2,Unit &unit)","UNSIGNED"]},{"entry":["{",{}]},{"entry":["\u2002s2 = (_unsigned(s2)) >> s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHRU .(SA,SB) s1(U4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPC_SHRU_20b_101 (U4 &s1, Gpr &s2,Unit &unit)","UNSIGNED, U4"]},{"entry":["{","IMM"]},{"entry":["\u2002s2 = (_unsigned(s2)) >> s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SHRU .(V,VP) s1(R4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPCV_SHRU_20b_51 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","UNSIGNED"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = _unsigned(s2.range(LSBL,MSBL)) >> s1.value( );",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = _unsigned(s2.range(LSBU,MSBU)) >> s1.value( );",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = _unsigned(s2) >> s1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SHRU .(V,VP) s1(U4), s2(R4)","SHIFT RIGHT,"]},{"entry":["void ISA::OPCV_SHRU_20b_52 (U4 &s1, Vreg4 &s2, Unit &unit)","UNSIGNED, U4"]},{"entry":["{","IMM"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = _unsigned(s2.range(LSBL,MSBL)) >> zero_extend(s1);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = _unsigned(s2.range(LSBU,MSBU)) >> zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = _unsigned(s2) >> zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SSUB .(SA,SB) s1(R4), s2(R4)","SATURATING"]},{"entry":["void ISA::OPC_SSUB_20b_128 (Gpr &s1, Gpr &s2,Unit &unit)","SUBTRACTION"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2 \u2212 s1;",{}]},{"entry":["\u2002if(r1 > 0xFFFFFFFF) s2 = 0xFFFFFFFF;",{}]},{"entry":["\u2002else if(r1 < 0) \u2003s2 = 0;",{}]},{"entry":["\u2002else \u2003\u2003\u2003s2 = r1;",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2002Csr.bit(EQ, unit) = s2.zero( );",{}]},{"entry":["\u2002Csr.bit(SAT,unit) = r1.overflow( ) | r1.underflow( );",{}]},{"entry":["}",{}]},{"entry":["SSUB .(V,VP) s1(R4), s2(R4)","SATURATING"]},{"entry":["void ISA::OPCV_SSUB_20b_77 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","SUBTRACTION"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result r1,r2;",{}]},{"entry":["\u2003r1 = s2.range(0,15) \u2212 s1.range(0,15);",{}]},{"entry":["\u2003r2 = s2.range(16,31) \u2212 s1.range(16,31);",{}]},{"entry":["\u2003if(r1 > 0xFFFF) s2.range(0,15) = 0xFFFF;",{}]},{"entry":["\u2003else if(r1 < 0) s2.range(0,15) = 0;",{}]},{"entry":["\u2003else \u2003\u2003s2.range(0,15) = r1.range(0,15);",{}]},{"entry":["\u2003if(r2 >0xFFFF) s2.range(16,31) = 0xFFFF;",{}]},{"entry":["\u2003else if(r2 < 0) s2.range(16,31) = 0;",{}]},{"entry":["\u2003else \u2003\u2003s2.range(16,31) = r2.range(0,15);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1,s2,r1);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1,s2,r2);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result r1;",{}]},{"entry":["\u2003r1 = s2 \u2212 s1;",{}]},{"entry":["\u2003if(r1.overflow( )) \u2003s2 = 0xFFFFFFFF;",{}]},{"entry":["\u2003else if(r1.underflow( )) s2 = 0;",{}]},{"entry":["\u2003else \u2003\u2003\u2003\u2003s2 = r1;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,r1);",{}]},{"entry":["\u2003Vr15.bit(SAT) = isSat(s1,s2,r1);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+SBR[s1(U4)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_26 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2003dmem->byte(Sbr+s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+SBR[s1(R4)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_29 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2002dmem->byte(Sbr+s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *SBR++[s1(U4)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_32 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2002dmem->byte(Sbr) = s2.byte(0);",{}]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *SBR++[s1(R4)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_35 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002dmem->byte(Sbr) = s2.byte(0);","ADJ"]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+s1(R4), s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_38 (Gpr &s1, Gpr &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->byte(s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *s1(R4)++, s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_20b_41 (Gpr &s1, Gpr &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2002dmem->byte(s1) = s2.byte(0);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+s1[s2(U20)], s3(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_40b_170 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->byte(s1+s2) = s3.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *s1++[s2(U20)], s3(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_40b_173 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2002dmem->byte(s1) = s3.byte(0);",{}]},{"entry":["\u2002s1 += s2;",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+SBR[s1(U24)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_40b_176 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002dmem->byte(Sbr+s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *SBR++[s1(U24)], s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPC_STB_40b_179 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002dmem->byte(Sbr) = s2.byte(0);","ADJ"]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *s1(U24),s2(R4)","STORE BYTE, U24"]},{"entry":["void ISA::OPC_STB_40b_182 (U24 &s1, Gpr &s2)","IMM ADDRESS"]},{"entry":["{",{}]},{"entry":["\u2002dmem->byte(s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(SB) *+SP[s1(U24)], s2(R4)","STORE BYTE, SP,"]},{"entry":["void ISA::OPC_STB_40b_252 (U24 &s1,Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->byte(Sp+s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(V4) *+s1(R4), s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPCV_STB_20b_16 (Vreg4 &s1, Vreg4 &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->byte(s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STB .(V4) *s1(R4)++, s2(R4)","STORE BYTE,"]},{"entry":["void ISA::OPCV_STB_20b_19 (Vreg4 &s1, Vreg4 &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2002dmem->byte(s1) = s2.byte(0);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+SBR[s1(U4)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_27 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->half(Sbr+(s1<<1)) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+SBR[s1(R4)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_30 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2002dmem->half(Sbr+(s1<<1)) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *SBR++[s1(U4)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_33 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2002dmem->half(Sbr) = s2.half(0);",{}]},{"entry":["\u2002Sbr += (s1<<1);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *SBR++[s1(R4)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_36 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002dmem->half(Sbr) = s2.half(0);","ADJ"]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+s1(R4), s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_39 (Gpr &s1, Gpr &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->half(s1) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *s1(R4)++, s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_20b_42 (Gpr &s1, Gpr &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2002dmem->half(s1) = s2.half(0);",{}]},{"entry":["\u2002s1 += 2;",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+s1[s2(U20)], s3(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_40b_171 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->half(s1+(s2<<1)) = s3.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *s1++[s2(U20)], s3(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_40b_174 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2002dmem->half(s1) = s3.half(0);",{}]},{"entry":["\u2002s1 += s2<<1;",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+SBR[s1(U24)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_40b_177 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002dmem->half(Sbr+(s1<<1)) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *SBR++[s1(U24)], s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPC_STH_40b_180 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002dmem->half(Sbr) = s2.half(0);","ADJ"]},{"entry":["\u2002Sbr += 2;",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *s1(U24),s2(R4)","STORE HALF, U24"]},{"entry":["void ISA::OPC_STH_40b_183 (U24 &s1, Gpr &s2)","IMM ADDRESS"]},{"entry":["{",{}]},{"entry":["\u2002dmem->half(s1<<1) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(SB) *+SP[s1(U24)], s2(R4)","STORE HALF, SP,"]},{"entry":["void ISA::OPC_STH_40b_253 (U24 &s1, Gpr &s2)","+U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->half(Sp+(s1<<1)) = s2.half(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(V4) *+s1(R4), s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPCV_STH_20b_17 (Vreg4 &s1, Vreg4 &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->half(s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STH .(V4) *s1(R4)++, s2(R4)","STORE HALF,"]},{"entry":["void ISA::OPCV_STH_20b_20 (Vreg4 &s1, Vreg4 &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2002dmem->half(s1) = s2.byte(0);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["STRF .SB s1(R4), s2(R4)","STORE REGISTER"]},{"entry":["void ISA::OPC_STRF_20b_81 (Gpr &s1, Gpr &s2)","FILE RANGE"]},{"entry":["{",{}]},{"entry":["\u2002if(s1 >= s2)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003for(int r=s2.address( );r<s1.address( );++r)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002dmem->write(Sp,r);",{}]},{"entry":["\u2003\u2002Sp \u2212= 4;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["STSYS .(SB) s1(R4), s2(R4)","STORE SYSTEM"]},{"entry":["void ISA::OPC_STSYS_20b_163 (Gpr &s1, Gpr &s2)","ATTRIBUTE"]},{"entry":["{","(GLS)"]},{"entry":["\u2002gls_is_load._assert(0);",{}]},{"entry":["\u2002gls_attr_valid._assert(1);",{}]},{"entry":["\u2002gls_is_stsys._assert(1);",{}]},{"entry":["\u2002gls_regf_addr._assert(s2.address( )); \/\/reg addr of s2",{}]},{"entry":["\u2002gls_sys_addr._assert(s1); \/\/contents of s1",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+SBR[s1(U4)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_28 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->word(Sbr+(s1<<2)) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+SBR[s1(R4)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_31 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET"]},{"entry":["\u2002dmem->word(Sbr+(s1<<2)) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *SBR++[s1(U4)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_34 (U4 &s1,Gpr &s2)","SBR, +U4 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2002dmem->word(Sbr) = s2.word( );",{}]},{"entry":["\u2002Sbr += (s1<<2);",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *SBR++[s1(R4)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_37 (Gpr &s1, Gpr &s2)","SBR, +REG"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002dmem->word(Sbr) = s2.word( );","ADJ"]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+s1(R4), s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_40 (Gpr &s1, Gpr &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->word(s1) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *s1(R4)++, s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_20b_43 (Gpr &s1, Gpr &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2002dmem->word(s1) = s2.word( );",{}]},{"entry":["\u2002s1 += 4;",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+s1[s2(U20)], s3(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_172 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->word(s1+(s2<<2)) = s3.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *s1++[s2(U20)], s3(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_175 (Gpr &s1, U20 &s2, Gpr &s3)","+U20 OFFSET,"]},{"entry":["{","POST ADJ"]},{"entry":["\u2002dmem->word(s1) = s3.word( );",{}]},{"entry":["\u2002s1 += s2<<2;",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+SBR[s1(U24)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_178 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET"]},{"entry":["\u2002dmem->word(Sbr+(s1<<2)) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *SBR++[s1(U24)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_181 (U24 &s1, Gpr &s2)","SBR, +U24"]},{"entry":["{","OFFSET, POST"]},{"entry":["\u2002dmem->word(Sbr) = s2.word( );","ADJ"]},{"entry":["\u2002Sbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *s1(U24),s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_184 (U24 &s1, Gpr &s2)","U24 IMM"]},{"entry":["{","ADDRESS"]},{"entry":["\u2002dmem->word(s1<<2) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(SB) *+SP[s1(U24)], s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPC_STW_40b_254 (U24 &s1,Gpr &s2)","SP, +U24 OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->word(Sp+(s1<<2)) = s2.word( );",{}]},{"entry":["}",{}]},{"entry":["STW .(V4) *+s1(R4), s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPCV_STW_20b_18 (Vreg4 &s1, Vreg4 &s2)","ZERO OFFSET"]},{"entry":["{",{}]},{"entry":["\u2002dmem->word(s1) = s2.byte(0);",{}]},{"entry":["}",{}]},{"entry":["STW .(V4) *s1(R4)++, s2(R4)","STORE WORD,"]},{"entry":["void ISA::OPCV_STW_20b_21 (Vreg4 &s1, Vreg4 &s2)","ZERO OFFSET,"]},{"entry":["{","POST INC"]},{"entry":["\u2002dmem->word(s1) = s2.byte(0);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["SUB .(SA,SB) s1(R4), s2(R4)","SUBTRACT"]},{"entry":["void ISA::OPC_SUB_20b_113 (Gpr &s1, Gpr &s2,Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2 \u2212 s1;",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SUB .(SA,SB) s1(U4), s2(R4)","SUBTRACT, U4"]},{"entry":["void ISA::OPC_SUB_20b_114 (U4 &s1, Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2 \u2212 s1;",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.underflow( );",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["SUB .(SB) s1(U28),SP(R5)","SUBTRACT, SP,"]},{"entry":["void ISA::OPC_SUB_40b_231 (U28 &s1)","U28 IMM"]},{"entry":["{",{}]},{"entry":["\u2002Sp \u2212= s1;",{}]},{"entry":["}",{}]},{"entry":["SUB .(SB) s1(U24), SP(R5), s3(R4)","SUBTRACT, SP,"]},{"entry":["void ISA::OPC_SUB_40b_232 (U24 &s1, Gpr &s3)","U24 IMM, REG"]},{"entry":["{","DEST"]},{"entry":["\u2002s3 = Sp\u2212s1;",{}]},{"entry":["}",{}]},{"entry":["SUB .(SB) s1(U24),s2(R4)","SUBTRACT, U24"]},{"entry":["void ISA::OPC_SUB_40b_233 (U24 &s1,Gpr &s2,Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s2 \u2212 s1;",{}]},{"entry":["\u2002s2 = r1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["\u2002Csr.bit( C,unit) = r1.carryout( );",{}]},{"entry":["}",{}]},{"entry":["SUB .(V,VP) s1(R4), s2(R4)","SUBTRACT"]},{"entry":["void ISA::OPCV_SUB_20b_64 (Vreg4 &s1, Vreg4 &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s1lo = s1.range(LSBL,MSBL);",{}]},{"entry":["\u2003Reg s2lo = s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003Reg resultlo = s2lo \u2212 s1lo;",{}]},{"entry":["\u2003Reg s1hi = s1.range(LSBU,MSBU);",{}]},{"entry":["\u2003Reg s2hi = s2.range(LSBU,MSBU);",{}]},{"entry":["\u2003Reg resulthi = s2hi \u2212 s1hi;",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = resultlo.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = resulthi.range(LSBU,MSBU);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1lo,s2lo,resultlo);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1hi,s2hi,resulthi);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg result = s2 \u2212 s1;",{}]},{"entry":["\u2003s2 = result;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,result);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SUB .(V,VP) s1(U4), s2(R4)","SUBTRACT, U4"]},{"entry":["void ISA::OPCV_SUB_20b_65 (U4 &s1, Vreg4 &s2, Unit &unit)","IMM"]},{"entry":["{",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg s2lo = s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003Reg resultlo = s2lo \u2212 zero_extend(s1);",{}]},{"entry":["\u2003Reg s2hi = s2.range(LSBU,MSBU);",{}]},{"entry":["\u2003Reg resulthi = s2hi \u2212 zero_extend(s1);",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = resultlo.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = resulthi.range(LSBU,MSBU);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2003Vr15.bit(CA) = isCarry(s1,s2lo,resultlo);",{}]},{"entry":["\u2003Vr15.bit(CB) = isCarry(s1,s2hi,resulthi);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Reg result = s2 \u2212 zero_extend(s1);",{}]},{"entry":["\u2003s2 = result;",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2003Vr15.bit(C) = isCarry(s1,s2,result);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SUB2 .(SA,SB) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_SUB2_20b_367 (Gpr &s1, Gpr &s2)","SUBTRACTION"]},{"entry":["{","WITH DIVIDE BY 2"]},{"entry":["\u2002s2.range(0,15) =",{}]},{"entry":["\u2003(s2.range(0,15) \u2212 s1.range(0,15)) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) =",{}]},{"entry":["\u2003(s2.range(16,31) \u2212 s1.range(16,31)) >> 1;",{}]},{"entry":["}",{}]},{"entry":["SUB2 .(SA,SB) s1(U4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPC_SUB2_20b_368 (U4 &s1, Gpr &s2)","SUBTRACTION"]},{"entry":["{","WITH DIVIDE BY 2"]},{"entry":["\u2002s2.range(0,15) = (s2.range(0,15) \u2212 s1.value( )) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) = (s2.range(16,31) \u2212 s1.value( )) >> 1;",{}]},{"entry":["}",{}]},{"entry":["SUB2 .(VPx) s1(R4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_SUB2_20b_30 (Vreg4 &s1, Vreg4 &s2)","SUBTRACTION"]},{"entry":["{","WITH DIVIDE BY 2"]},{"entry":["\u2002s2.range(0,15) =",{}]},{"entry":["\u2003(s2.range(0,15) \u2212 s1.range(0,15)) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) =",{}]},{"entry":["\u2003(s2.range(16,31) \u2212 s1.range(16,31)) >> 1;",{}]},{"entry":["}",{}]},{"entry":["SUB2 .(VPx) s1(U4), s2(R4)","HALF WORD"]},{"entry":["void ISA::OPCV_SUB2_20b_31 (U4 &s1, Vreg4 &s2)","SUBTRACTION"]},{"entry":["{","WITH DIVIDE BY 2"]},{"entry":["\u2002s2.range(0,15) = (s2.range(0,15) \u2212 s1.value( )) >> 1;",{}]},{"entry":["\u2002s2.range(16,31) = (s2.range(16,31) \u2212 s1.value( )) >> 1;",{}]},{"entry":["}",{}]},{"entry":["SUM .(VBx,VPx) s1(R4), s2(R4)","SUMMATION"]},{"entry":["void ISA::OPCV_SUM_20b_54 (Vreg4 &s1, Vreg4 &s2, Unit &unit)",{}]},{"entry":["{",{}]},{"entry":["\u2002if(isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s1.range(24,31)",{}]},{"entry":["\u2003\u2003+ s1.range(16,23)",{}]},{"entry":["\u2003\u2003+ s1.range(8,15)",{}]},{"entry":["\u2003\u2003+ s1.range(0,7);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s1.range(16,31)",{}]},{"entry":["\u2003\u2003+ s1.range(0,15);",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SUMU .(VBx,VPx) s1(R4), s2(R4)","SUMMATION,"]},{"entry":["void ISA::OPCV_SUMU_20b_55 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","UNSIGNED"]},{"entry":["{",{}]},{"entry":["\u2002if(isVBunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = _unsigned(s1.range(24,31))",{}]},{"entry":["\u2003\u2003+ _unsigned(s1.range(16,23))",{}]},{"entry":["\u2003\u2003+ _unsigned(s1.range(8,15))",{}]},{"entry":["\u2003\u2003+ _unsigned(s1.range(0,7));",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = _unsigned(s1.range(16,31))",{}]},{"entry":["\u2003\u2003+ _unsigned(s1.range(0,15));",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SWAP .(SA,SB) s1(R4), s2(R4)","SWAP"]},{"entry":["void ISA::OPC_SWAP_20b_146 (Gpr &s1, Gpr &s2)","REGISTERS"]},{"entry":["{",{}]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp = s1;",{}]},{"entry":["\u2002s1 = s2;",{}]},{"entry":["\u2002s2 = tmp;",{}]},{"entry":["}",{}]},{"entry":["SWAP .(V,VP) s1(R4), s2(R4)",{}]},{"entry":["void ISA::OPCV_SWAP_20b_82 (Vreg4 &s1, Vreg4 &s2, Unit &unit)","SWAP"]},{"entry":["{","REGISTERS"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp = s1;",{}]},{"entry":["\u2003s1.range(LSBL,MSBL) = s2.range(LSBU,MSBU);",{}]},{"entry":["\u2003s1.range(LSBU,MSBU) = s2.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = tmp.range(LSBL,MSBL);",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = tmp.range(LSBU,MSBU);",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003Result tmp;",{}]},{"entry":["\u2003tmp = s1;",{}]},{"entry":["\u2003s1 = s2;",{}]},{"entry":["\u2003s2 = tmp;",{}]},{"entry":["\u2002}",{}]},{"entry":["}",{}]},{"entry":["SWAPBR .(SA,SB)","SWAP LBR and"]},{"entry":["void ISA::OPC_SWAPBR_20b_11 (void)","SBR"]},{"entry":["{",{}]},{"entry":["\u2002Result tmp;",{}]},{"entry":["\u2002tmp = Lbr;",{}]},{"entry":["\u2002Lbr = Sbr;",{}]},{"entry":["\u2002Sbr = tmp;",{}]},{"entry":["}",{}]},{"entry":["SWIZ .(SA,SB) s1(R4), s2(R4)","SWIZZLE,"]},{"entry":["void ISA::OPC_SWIZ_20b_44 (Gpr &s1, Gpr &s2)","ENDIAN"]},{"entry":["{","CONVERSION"]},{"entry":["\u2002\/\/This should be defined as a p-op, it overlaps",{}]},{"entry":["\u2002\/\/one form of REORD",{}]},{"entry":["\u2002s2.range(0,7) = s1.range(24,31);",{}]},{"entry":["\u2002s2.range(8,15) = s1.range(16,23);",{}]},{"entry":["\u2002s2.range(16,23) = s1.range(8,15);",{}]},{"entry":["\u2002s2.range(24,31) = s1.range(0,7);",{}]},{"entry":["}",{}]},{"entry":["SWIZ .(Vx) s1(R4), s2(R4)","SWIZZLE,"]},{"entry":["void ISA::OPCV_SWIZ_20b_44 (Vreg4 &s1, Vreg4 &s2)","ENDIAN"]},{"entry":["{","CONVERSION"]},{"entry":["\u2002\/\/This should be defined as a p-op, it overlaps",{}]},{"entry":["\u2002\/\/one form of REORD",{}]},{"entry":["\u2002s2.range(0,7)\u2003= s1.range(24,31);",{}]},{"entry":["\u2002s2.range(8,15) = s1.range(16,23);",{}]},{"entry":["\u2002s2.range(16,23) = s1.range(8,15);",{}]},{"entry":["\u2002s2.range(24,31) = s1.range(0,7);",{}]},{"entry":["}",{}]},{"entry":["TASKSW .(SA,SB)","TASK SWITCH"]},{"entry":["void ISA::OPC_TASKSW_20b_19 (void)",{}]},{"entry":["{",{}]},{"entry":["\u2002risc_is_task_sw._assert(1);",{}]},{"entry":["}",{}]},{"entry":["TASKSWTOE .(SA,SB) s1(U2)","TASK SWITCH"]},{"entry":["void ISA::OPC_TASKSWTOE_20b_126 (U2 &s1)","TEST OUTPUT"]},{"entry":["{","ENABLE"]},{"entry":["\u2002risc_is_taskswtoe._assert(1);",{}]},{"entry":["\u2002risc_is_taskswtoe_opr._assert(s1);",{}]},{"entry":["}",{}]},{"entry":["VIC .V3 s1(R4), s2(S9), s3(R2)","VERTICAL INDEX"]},{"entry":["void ISA::OPCV_VIC_20b_399 (Gpr &s1, S9 &s2, Vreg2 &s3)","CALC,"]},{"entry":["{","IMMEDIATE"]},{"entry":["\u2002risc_regf_ra0._assert(D0,s1.address( ));","FORM"]},{"entry":["\u2002risc_regf_rd0z._assert(D0,0);",{}]},{"entry":["\u2002Result rVIP = risc_regf_rd0.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002int mode\u2003\u2003= rVIP.range(28,29);",{}]},{"entry":["\u2002bool store_disable = rVIP.bit(27);",{}]},{"entry":["\u2002int hg_size\u2003\u2003= rVIP.range( 0, 7); \/\/aka Block_Width",{}]},{"entry":["\u2002int buffer_size\u2003= rVIP.range( 8,15);",{}]},{"entry":["\u2002bool block \u2003\u2003= mode == 0x00;",{}]},{"entry":["\u2002if(block)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2002\u2009unsigned int u_offset = _unsigned(s2.range(0,7));",{}]},{"entry":["\u2003int addr = (hg_size<<5) * u_offset;",{}]},{"entry":["\u2003s3.range( 0,15) = addr;",{}]},{"entry":["\u2003s3.range(16,31) = addr;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003bool top_flag = rVIP.bit(31);",{}]},{"entry":["\u2003bool bot_flag = rVIP.bit(30);",{}]},{"entry":["\u2003int tboffset\u2003= rVIP.range(24,26);",{}]},{"entry":["\u2003int pointer\u2003= rVIP.range(16,23);",{}]},{"entry":["\u2002int s_offset = sign_extend(s2.range(0,7));",{}]},{"entry":["\u2003bool top_bound = top_flag && (s_offset < (\u2212tboffset));",{}]},{"entry":["\u2003bool bot_bound = bot_flag && (s_offset > ( tboffset));",{}]},{"entry":["\u2003bool mirror = (mode == 0x01);",{}]},{"entry":["\u2003bool repeat = (mode == 0x02);",{}]},{"entry":["\u2003if(mirror)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int tboffset_x2 = tboffset << 1;",{}]},{"entry":["\u2003\u2002if(top_bound) s_offset = \u2212(tboffset_x2 + s_offset);",{}]},{"entry":["\u2003\u2002if(bot_bound) s_offset = (tboffset_x2 \u2212 s_offset);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else if(repeat)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(top_bound) s_offset = \u2212tboffset;",{}]},{"entry":["\u2003\u2002if(bot_bound) s_offset = tboffset;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003int addr = pointer + s_offset;",{}]},{"entry":["\u2003if(addr > buffer_size) addr \u2212= buffer_size;",{}]},{"entry":["\u2003else if(addr < 0)\u2003\u2003addr += buffer_size;",{}]},{"entry":["\u2003addr *= hg_size << 5;",{}]},{"entry":["\u2003Result r1 = addr;",{}]},{"entry":["\u2003bool bounded = top_bound || bot_bound;",{}]},{"entry":["\u2003s3.bit(31)\u2003= bounded;",{}]},{"entry":["\u2003s3.bit(15)\u2003= bounded;",{}]},{"entry":["\u2003s3.range(16,30) = r1.range(0,14);",{}]},{"entry":["\u2003s3.range(0,14) = r1.range(0,14);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002Result newSreg;",{}]},{"entry":["\u2002newSreg.range(9,10) = mode;",{}]},{"entry":["\u2002newSreg.bit(8)\u2003\u2003= store_disable;",{}]},{"entry":["\u2002newSreg.range(0,7) = hg_size;",{}]},{"entry":["\u2002risc_vsr_wrz._assert(E1,0);",{}]},{"entry":["\u2002risc_vsr_wa._assert(E1,s3.address( ));",{}]},{"entry":["\u2002risc_vsr_wd._assert(E1,newSreg.range(0,10));",{}]},{"entry":["}",{}]},{"entry":["VIC .V3 s1(R4), s2(R4), s3(R2)","VERTICAL INDEX"]},{"entry":["void ISA::OPCV_VIC_20b_400 (Gpr &s1, Vreg &s2, Vreg2 &s3)","CALC, REGISTER"]},{"entry":["{","FORM"]},{"entry":["\u2002risc_regf_ra0._assert(D0,s1.address( ));",{}]},{"entry":["\u2002risc_regf_rd0z._assert(D0,0);",{}]},{"entry":["\u2002Result rVIP = risc_regf_rd0.read( ); \/\/E0 is implied",{}]},{"entry":["\u2002int mode\u2003\u2003\u2003= rVIP.range(28,29);",{}]},{"entry":["\u2002int buffer_size\u2003= rVIP.range(16,23);",{}]},{"entry":["\u2002bool store_disable = rVIP.bit(27);",{}]},{"entry":["\u2002int hg_size\u2003\u2003= rVIP.range( 0, 7); \/\/aka Block_Width",{}]},{"entry":["\u2002bool block\u2003\u2003\u2002= mode == 0x00;",{}]},{"entry":["\u2002if(block)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003\/\/For block processing s2 is treated as an unsigned",{}]},{"entry":["\u2003\/\/absolute offset value",{}]},{"entry":["\u2003unsigned int u_offset_lo = _unsigned(s2.range( 0,15));",{}]},{"entry":["\u2003unsigned int u_offset_hi = _unsigned(s2.range(16,31));",{}]},{"entry":["\u2003int addr_lo = (hg_size<<5) * u_offset_lo;",{}]},{"entry":["\u2003int addr_hi = (hg_size<<5) * u_offset_hi;",{}]},{"entry":["\u2003s3.range( 0,15) = addr_lo;",{}]},{"entry":["\u2003s3.range(16,31) = addr_hi;",{}]},{"entry":["\u2003\/\/The shadow register is updated below the else clause",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003\/\/Extract the other VIP contents that are used here",{}]},{"entry":["\u2003bool top_flag = rVIP.bit(31);",{}]},{"entry":["\u2003bool bot_flag = rVIP.bit(30);",{}]},{"entry":["\u2003int tboffset = rVIP.range(24,26);",{}]},{"entry":["\u2003int pointer = rVIP.range(16,23);",{}]},{"entry":["\u2003\/\/s_offset is aka the imm_cnst found in the T20 ISA.",{}]},{"entry":["\u2003\/\/Aligning names to System Spec.",{}]},{"entry":["\u2003int s_offset_lo = sign_extend(s2.range( 0,15));",{}]},{"entry":["\u2003int s_offset_hi = sign_extend(s2.range(16,31));",{}]},{"entry":["\u2003\/\/Detect the boundary processing conditions",{}]},{"entry":["\u2003bool top_bound_lo = top_flag && (s_offset_lo < (\u2212tboffset));",{}]},{"entry":["\u2003bool bot_bound_lo = bot_flag && (s_offset_lo > ( tboffset));",{}]},{"entry":["\u2003bool bounded_lo = top_bound_lo || bot_bound_lo;",{}]},{"entry":["\u2003bool top_bound_hi = top_flag && (s_offset_hi < (\u2212tboffset));",{}]},{"entry":["\u2003bool bot_bound_hi = bot_flag && (s_offset_hi > ( tboffset));",{}]},{"entry":["\u2003bool bounded_hi = top_bound_hi || bot_bound_hi;",{}]},{"entry":["\u2003\/\/Form the mode flags",{}]},{"entry":["\u2003bool mirror = (mode == 0x01);",{}]},{"entry":["\u2003bool repeat = (mode == 0x02);",{}]},{"entry":["\u2003if(mirror)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002int tboffset_x2 = tboffset << 1;",{}]},{"entry":["\u2003\u2002if(top_bound_lo) s_offset_lo = \u2212(tboffset_x2 + s_offset_lo);",{}]},{"entry":["\u2003\u2002if(top_bound_hi) s_offset_hi = \u2212(tboffset_x2 + s_offset _hi);",{}]},{"entry":["\u2003\u2002if(bot_bound_lo) s_offset_lo = (tboffset_x2 \u2212 s_offset_lo);",{}]},{"entry":["\u2003\u2002if(bot_bound_hi) s_offset_hi = (tboffset_x2 \u2212 s_offset_hi);",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else if(repeat)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(top_bound_lo) s_offset_lo = \u2212tboffset;",{}]},{"entry":["\u2003\u2002if(top_bound_hi) s_offset_hi = \u2212tboffset;",{}]},{"entry":["\u2003\u2002if(bot_bound_lo) s_offset_lo = tboffset;",{}]},{"entry":["\u2003\u2002if(bot_bound_hi) s_offset_hi = tboffset;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003int addr_lo = pointer + s_offset_lo;",{}]},{"entry":["\u2003if(addr_lo > buffer_size) addr_lo \u2212= buffer_size;",{}]},{"entry":["\u2003else if(addr_lo < 0) addr_lo += buffer_size;",{}]},{"entry":["\u2003int addr_hi = pointer + s_offset_hi;",{}]},{"entry":["\u2003if(addr_hi > buffer_size) addr_hi \u2212= buffer_size;",{}]},{"entry":["\u2003else if(addr_hi < 0) addr_hi += buffer_size;",{}]},{"entry":["\u2003\/\/ Shift and mul by hg_size",{}]},{"entry":["\u2003addr_lo *= hg_size << 5;",{}]},{"entry":["\u2003addr_hi *= hg_size << 5;",{}]},{"entry":["\u2003\/\/ Assign addr to a Result type so we can use range( ) instead",{}]},{"entry":["\u2003\/\/ of C bit manipulation;",{}]},{"entry":["\u2003Result r_lo = addr_lo;",{}]},{"entry":["\u2003Result r_hi = addr_hi;",{}]},{"entry":["\u2003\/\/ Assign the boundary processing flag bit",{}]},{"entry":["\u2003s3.bit(15)\u2003\u2003= bounded_lo;",{}]},{"entry":["\u2003s3.bit(31)\u2003\u2003= bounded_hi;",{}]},{"entry":["\u2003s3.range(0,14) = r_lo.range(0,14);",{}]},{"entry":["\u2003s3.range(16,30) = r_hi.range(0,14);",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002\/\/ Form the contents of the shadow register",{}]},{"entry":["\u2002Result newSreg;",{}]},{"entry":["\u2002newSreg.range(9,10) = mode;",{}]},{"entry":["\u2002newSreg.bit(8) = store_disable;",{}]},{"entry":["\u2002newSreg.range(0,7) = hg_size;",{}]},{"entry":["\u2002\/\/ Update the shadow register",{}]},{"entry":["\u2002risc_vsr_wrz._assert(E1,0);",{}]},{"entry":["\u2002risc_vsr_wa._assert(E1,s3.address( ));",{}]},{"entry":["\u2002risc_vsr_wd._assert(E1,newSreg.range(0,10));",{}]},{"entry":["}",{}]},{"entry":["VINPUT (SB) s1(R4), s2(R4)","VECTOR INPUT, 2"]},{"entry":["void ISA::OPC_VINPUT_20b_129 (Gpr &s1, Gpr &s2)","OPERAND"]},{"entry":["{",{}]},{"entry":["\u2002gls_is_vinput._assert(1);",{}]},{"entry":["\u2002gls_sys_addr._assert(s1);",{}]},{"entry":["\u2002gls_vreg._assert(s2.address( ));",{}]},{"entry":["}",{}]},{"entry":["VINPUT (SB) *+s1(R4)[s2(R4)], s3(R4)","VINPUT, 3"]},{"entry":["void ISA::OPC_VINPUT_40b_244 (Gpr &s1, Gpr &s2, Gpr &s3)","OPERAND,"]},{"entry":["{","REGISTER FORM"]},{"entry":["\u2002gls_is_vinput._assert(1);",{}]},{"entry":["\u2002Result r1 = s1+s2;",{}]},{"entry":["\u2002gls_sys_addr._assert(r1.value( ));",{}]},{"entry":["\u2002gls_vreg._assert(s3.address( ));",{}]},{"entry":["}",{}]},{"entry":["VINPUT (SB) *+s1(R4)[s2(U16)], s3(R4)","VINPUT, 3"]},{"entry":["void ISA::OPC_VINPUT_40b_245 (Gpr &s1, U16 &s2, Gpr &s3)","OPERAND,"]},{"entry":["{","IMMEDIATE"]},{"entry":["\u2002gls_is_vinput._assert(1);","FORM"]},{"entry":["\u2002Result r1 = s1+s2;",{}]},{"entry":["\u2002gls_sys_addr._assert(r1.value( ));",{}]},{"entry":["\u2002gls_vreg._assert(s3.address( ));",{}]},{"entry":["}",{}]},{"entry":["VINPUT .SB *+s1(R4)[s2(U16)], s3(R4), s4(R4)","VINPUT, 4"]},{"entry":["void ISA::OPC_VINPUT_40b_245 (Gpr &s1, U16 &s2, Gpr &s3, Vreg","OPERAND,"]},{"entry":["&s4)","IMMEDIATE"]},{"entry":["{","FORM"]},{"entry":["\u2002Result r1 = _unsigned(s1)+_unsigned(s2);",{}]},{"entry":["\u2002risc_is_vinput._assert(1); \/\/instruction flag",{}]},{"entry":["\u2002gls_sys_addr._assert(r1.value( )); \/\/calculated address",{}]},{"entry":["\u2002risc_vip_size._assert(s3.range(0,7)); \/\/size field from VIP",{}]},{"entry":["\u2002risc_vip_valid._assert(1); \/\/size field valid",{}]},{"entry":["\u2002gls_vreg._assert(s3.address( )); \/\/virtual register address",{}]},{"entry":["}",{}]},{"entry":["VINPUT .SB *+s1(R4)[s2(R4)], s3(R4), s4(R4)","VINPUT, 4"]},{"entry":["void ISA::OPC_VINPUT_40b_244 (Gpr &s1, Gpr &s2, Gpr &s3, Vreg","OPERAND,"]},{"entry":["&s4)","REGISTER FORM"]},{"entry":["{",{}]},{"entry":["\u2002Result r1 = _unsigned(s1)+_unsigned(s2);",{}]},{"entry":["\u2002risc_is_vinput._assert(1); \/\/instruction flag",{}]},{"entry":["\u2002gls_sys_addr._assert(r1.value( )); \/\/calculated address",{}]},{"entry":["\u2002risc_vip_size._assert(s3.range(0,7)); \/\/size field from VIP",{}]},{"entry":["\u2002risc_vip_valid._assert(1); \/\/size field valid",{}]},{"entry":["\u2002gls_vreg._assert(s4.address( )); \/\/virtual register address",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *+LBR[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_20b_336 (U4 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","BYTE, LBR, +U4"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *+LBR[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_20b_341 (Gpr &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","BYTE, LBR, +REG"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *LBR++[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_20b_346 (U4 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","BYTE, LBR, +U4"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *LBR++[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_20b_351 (Gpr &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","BYTE, LBR, +REG"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *+s1(R4), s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_20b_356 (Gpr &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","BYTE, ZERO"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *s1(R4)++, s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_20b_361 (Gpr &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","BYTE, ZERO"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));","INC"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *+s1(R4)[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_40b_474 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD SIGNED"]},{"entry":["{","BYTE, +U20"]},{"entry":["\u2002Result r1 = s1 + s2;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *s1(R4)++[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_40b_479 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD SIGNED"]},{"entry":["{","BYTE, +U20"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002s1 += s2;",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *+LBR[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_40b_484 (U24 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","BYTE, LBR, +U24"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *LBR++[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_40b_489 (U24 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","BYTE, LBR, +U24"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VLDB .(SB) *s1(U24),s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDB_40b_494 (U24 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","BYTE, U24 IMM"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","ADDRESS"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *+LBR[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_20b_333 (U4 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","BYTE, LBR, +U4"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *+LBR[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_20b_338 (Gpr &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","BYTE, LBR, +REG"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *LBR++[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_20b_343 (U4 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","BYTE, LBR, +U4"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET POST"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","ADJ"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(Lbr));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *LBR++[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_20b_348 (Gpr &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","BYTE, LBR, +REG"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *+s1(R4), s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_20b_353 (Gpr &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","BYTE, ZERO"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *s1(R4)++, s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_20b_358 (Gpr &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","BYTE, ZERO"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));","INC"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002++s1;",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *+s1(R4)[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_40b_471 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD UNSIGNED"]},{"entry":["{","BYTE, +U20"]},{"entry":["\u2002Result r1 = s1 + s2;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *s1(R4)++[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_40b_476 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD UNSIGNED"]},{"entry":["{","BYTE, +U20"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002s1 += s2;",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *+LBR[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_40b_481 (U24 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","BYTE, LBR, +U24"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *LBR++[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_40b_486 (U24 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","BYTE, LBR, +U24"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VLDBU .(SB) *s1(U24),s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDBU_40b_491 (U24 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","BYTE, U24 IMM"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","ADDRESS"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *+LBR[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_20b_337 (U4 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","HALF, LBR, +U4"]},{"entry":["\u2002Result r1 = Lbr + (s1<<1);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *+LBR[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_20b_342 (Gpr &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","HALF, LBR, +REG"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *LBR++[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_20b_347 (U4 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","HALF, LBR, +U4"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *LBR++[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_20b_352 (Gpr &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","HALF, LBR, +REG"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *+s1(R4), s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_20b_357 (Gpr &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","HALF, ZERO"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *s1(R4)++, s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_20b_362 (Gpr &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","HALF, ZERO"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));","INC"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002s1 += 2;",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *+s1(R4)[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_40b_475 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD SIGNED"]},{"entry":["{","HALF, +U20"]},{"entry":["\u2002Result r1 = s1 + (s2<<1);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *s1(R4)++[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_40b_480 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD SIGNED"]},{"entry":["{","HALF, +U20"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002s1 += (s2<<1);",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *+LBR[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_40b_485 (U24 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","HALF, LBR, +U24"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *LBR++[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_40b_490 (U24 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","HALF, LBR, +U24"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002Lbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["VLDH .(SB) *s1(U24),s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDH_40b_495 (U24 &s1, Gpr &s2)","LOAD SIGNED"]},{"entry":["{","HALF, U24 IMM"]},{"entry":["\u2002Result r1 = s1<<1;","ADDRESS"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *+LBR[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_20b_334 (U4 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","HALF, LBR, +U4"]},{"entry":["\u2002Result r1 = Lbr + (s1<<1);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *+LBR[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_20b_339 (Gpr &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","HALF, LBR, +REG"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *LBR++[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_20b_344 (U4 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","HALF, LBR, +U4"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *LBR++[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_20b_349 (Gpr &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","HALF, LBR, +REG"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *+s1(R4), s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_20b_354 (Gpr &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","HALF, ZERO"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *s1(R4)++, s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_20b_359 (Gpr &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","HALF, ZERO"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));","INC"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002s1 += 2;",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *+s1(R4)[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_40b_472 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD UNSIGNED"]},{"entry":["{","HALF, +U20"]},{"entry":["\u2002Result r1 = s1 + (s2<<1);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *s1(R4)++[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_40b_477 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD UNSIGNED"]},{"entry":["{","HALF, +U20"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002s1 += (s2<<1);",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *+LBR[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_40b_482 (U24 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","HALF, LBR, +U24"]},{"entry":["\u2002Result r1 = Lbr + (s1<<1);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *LBR++[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_40b_487 (U24 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","HALF, LBR, +U24"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002Lbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["VLDHU .(SB) *s1(U24),s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDHU_40b_492 (U24 &s1, Gpr &s2)","LOAD UNSIGNED"]},{"entry":["{","HALF, U24 IMM"]},{"entry":["\u2002Result r1 = s1<<1;","ADDRESS"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *+LBR[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_20b_335 (U4 &s1, Gpr &s2)","LOAD WORD,"]},{"entry":["{","LBR, +U4 OFFSET"]},{"entry":["\u2002Result r1 = Lbr + (s1<<2);",{}]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *+LBR[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_20b_340 (Gpr &s1, Gpr &s2)","LOAD WORD,"]},{"entry":["{","LBR, +REG"]},{"entry":["\u2002Result r1 = Lbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *LBR++[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_20b_345 (U4 &s1, Gpr &s2)","LOAD WORD,"]},{"entry":["{","LBR, +U4 OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","POST ADJ"]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vildu._assert(1);",{}]},{"entry":["\u2002Lbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *LBR++[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_20b_350 (Gpr &s1, Gpr &s2)","LOAD WORD,"]},{"entry":["{","LBR, +REG"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(0);","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002Lbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *+s1(R4), s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_20b_355 (Gpr &s1, Gpr &s2)","LOAD WORD,"]},{"entry":["{","ZERO OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *s1(R4)++, s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_20b_360 (Gpr &s1, Gpr &s2)","LOAD WORD,"]},{"entry":["{","ZERO OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","POST INC"]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002s1 += 4;",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *+s1(R4)[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_40b_473 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD WORD,"]},{"entry":["{","+U20 OFFSET"]},{"entry":["\u2002Result r1 = s1 + (s2<<2);",{}]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *s1(R4)++[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_40b_478 (Gpr &s1, U20 &s2, Gpr &s3)","LOAD WORD,"]},{"entry":["{","+U20 OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","POST ADJ"]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002s1 += (s2<<2);",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *+LBR[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_40b_483 (U24 &s1, Gpr &s2)","LOAD WORD,"]},{"entry":["{","LBR, +U24"]},{"entry":["\u2002Result r1 = Lbr + (s1<<2);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *LBR++[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_40b_488 (U24 &s1, Gpr &s2)","LOAD WORD,"]},{"entry":["{","LBR, +U24"]},{"entry":["\u2002risc_fmem_addr._assert(Lbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Lbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["\u2002Lbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["VLDW .(SB) *s1(U24),s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VLDW_40b_493 (U24 &s1, Gpr &s2)","LOAD WORD, U24"]},{"entry":["{","IMM ADDRESS"]},{"entry":["\u2002Result r1 = s1<<2;",{}]},{"entry":["\u2002risc_fmem_addr._asser(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vild._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VOUTPUT .(SB) *+s1 [s2(R4)], s3(S8), s4(U6), s5(R4)","VOUTPUT, 5"]},{"entry":["void ISA::OPC_VOUTPUT_40b_235 (Gpr &s1,Gpr &s2,S8 &s3,U6 &s","operand"]},{"entry":["4,Vreg4 &s5)",{}]},{"entry":["{",{}]},{"entry":["\u2002int imm_cnst = s3.value( );",{}]},{"entry":["\u2002int bot_off = s2.range(0,3);",{}]},{"entry":["\u2002int top_off = s2.range(4,7);",{}]},{"entry":["\u2002int blk_size = s2.range(8,10);",{}]},{"entry":["\u2002int str_dis = s2.bit(12);",{}]},{"entry":["\u2002int repeat\u2003= s2.bit(13);",{}]},{"entry":["\u2002int bot_flag = s2.bit(14);",{}]},{"entry":["\u2002int top_flag = s2.bit(15);",{}]},{"entry":["\u2002int pntr \u2003= s2.range(16,23);",{}]},{"entry":["\u2002int size \u2003= s2.range(24,31);",{}]},{"entry":["\u2002int tmp,addr;",{}]},{"entry":["\u2002if(imm_cnst > 0 && bot_flag && imm_cnst > bot_off)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(!repeat)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002tmp = (bot_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002tmp = bot_off;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if(imm_cnst < 0 && top_flag && \u2212imm_cnst > top_off)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(!repeat)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003tmp = \u2212(top_off<<1) \u2212 imm_cnst;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003\u2002else",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003tmp = \u2212top_off;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002tmp = imm_cnst;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002pntr = pntr << blk_size;",{}]},{"entry":["\u2002if(size == 0)",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003addr = pntr + tmp;",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003if((pntr + tmp) >= size)",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002addr = pntr + tmp \u2212 size;",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2003else",{}]},{"entry":["\u2003{",{}]},{"entry":["\u2003\u2002if(pntr + tmp < 0)",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003addr = pntr + tmp + size;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003\u2002else",{}]},{"entry":["\u2003\u2002{",{}]},{"entry":["\u2003\u2003addr = pntr + tmp;",{}]},{"entry":["\u2003\u2002}",{}]},{"entry":["\u2003}",{}]},{"entry":["\u2002}",{}]},{"entry":["\u2002addr = addr + s1.value( );",{}]},{"entry":["\u2002risc_is_voutput._assert(1);",{}]},{"entry":["\u2002risc_output_wd._assert(s5);",{}]},{"entry":["\u2002risc_output_wa._assert(addr);",{}]},{"entry":["\u2002risc_output_pa._assert(s4);",{}]},{"entry":["\u2002risc_output_sd._assert(str_dis);",{}]},{"entry":["}",{}]},{"entry":["VOUTPUT .(SB) *+s1[s2(S14)], s3(U6), s4(R4)","VOUTPUT, 4"]},{"entry":["void ISA::OPC_VOUTPUT_40b_236 (Gpr &s1,S14 &s2,U6 &s3,Vreg4","operand"]},{"entry":["&s4)",{}]},{"entry":["{",{}]},{"entry":["\u2002Result r1;",{}]},{"entry":["\u2002r1 = s1 + s2;",{}]},{"entry":["\u2002risc_is_voutput._assert(1);",{}]},{"entry":["\u2002risc_output_wd._assert(s4);",{}]},{"entry":["\u2002risc_output_wa._assert(r1);",{}]},{"entry":["\u2002risc_output_pa._assert(s3);",{}]},{"entry":["\u2002risc_output_sd._assert(s1.bit(12));",{}]},{"entry":["}",{}]},{"entry":["VOUTPUT .(SB) *s1(U18), s2(U6), s3(R4)","VOUTPUT, 3"]},{"entry":["void ISA::OPC_VOUTPUT_40b_237 (S18 &s1,U6 &s2,Vreg4 &s3)","operand"]},{"entry":["{",{}]},{"entry":["\u2002risc_is_voutput._assert(1);",{}]},{"entry":["\u2002risc_output_wd._assert(s3);",{}]},{"entry":["\u2002risc_output_wa._assert(s1);",{}]},{"entry":["\u2002risc_output_pa._assert(s2);",{}]},{"entry":["\u2002risc_output_sd._assert(0);",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *+SBR[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_20b_312 (U4 &s1, Gpr &s2)","STORE BYTE,"]},{"entry":["{","SBR, +U4 OFFSET"]},{"entry":["\u2002Result r1 = Sbr + s1;",{}]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *+SBR[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_20b_315 (Gpr &s1, Gpr &s2)","STORE BYTE,"]},{"entry":["{","SBR, +REG"]},{"entry":["\u2002Result r1 = Sbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *SBR++[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_20b_318 (U4 &s1, Gpr &s2)","STORE BYTE,"]},{"entry":["{","SBR, +U4 OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(Sbr.range(2,19));","POST ADJ"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(Sbr));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *SBR++[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_20b_321 (Gpr &s1, Gpr &s2)","STORE BYTE,"]},{"entry":["{","SBR, +REG"]},{"entry":["\u2002Result r1 = Sbr + s1;","OFFSET, POST"]},{"entry":["\u2002risc_fmem_addr._assert(Sbr.range(2,19));","ADJ"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(Sbr));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *+s1(R4), s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_20b_324 (Gpr &s1, Gpr &s2)","STORE BYTE,"]},{"entry":["{","ZERO OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *s1(R4)++, s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_20b_327 (Gpr &s1, Gpr &s2)","STORE BYTE,"]},{"entry":["{","ZERO OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","POST INC"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002s1 += 1;",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *+s1(R4)[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_40b_456 (Gpr &s1, U20 &s2, Gpr &s3)","STORE BYTE,"]},{"entry":["{","+U20 OFFSET"]},{"entry":["\u2002Result r1 = s1 + s2;",{}]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *s1(R4)++[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_40b_459 (Gpr &s1, U20 &s2, Gpr &s3)","STORE BYTE,"]},{"entry":["{","+U20 OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","POST ADJ"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002s1 += s2;",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *+SBR[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_40b_462 (U24 &s1, Gpr &s2)","STORE BYTE,"]},{"entry":["{","SBR, +U24"]},{"entry":["\u2002Result r1 = Sbr + s1;","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *SBR++[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_40b_465 (U24 &s1, Gpr &s2)","STORE BYTE,"]},{"entry":["{","SBR, +U24"]},{"entry":["\u2002risc_fmem_addr._assert(Sbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(Sbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VSTB .(SB) *s1(U24),s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTB_40b_468 (U24 &s1, Gpr &s2)","STORE BYTE, U24"]},{"entry":["{","IMM ADDRESS"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(byte_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *+SBR[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_20b_313 (U4 &s1, Gpr &s2)","STORE HALF,"]},{"entry":["{","SBR, +U4 OFFSET"]},{"entry":["\u2002Result r1 = Sbr + (s1<<1);",{}]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *+SBR[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_20b_316 (Gpr &s1, Gpr &s2)","STORE HALF,"]},{"entry":["{","SBR, +REG"]},{"entry":["\u2002Result r1 = Sbr + (s1<<1);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *SBR++[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_20b_319 (U4 &s1, Gpr &s2)","STORE HALF,"]},{"entry":["{","SBR, +U4 OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(Sbr.range(2,19));","POST ADJ"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Sbr));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002Sbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *SBR++[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_20b_322 (Gpr &s1, Gpr &s2)","STORE HALF,"]},{"entry":["{","SBR, +REG"]},{"entry":["\u2002risc_fmem_addr._assert(Sbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half decode(Sbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *+s1(R4), s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_20b_325 (Gpr &s1, Gpr &s2)","STORE HALF,"]},{"entry":["{","ZERO OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *s1(R4)++, s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_20b_328 (Gpr &s1, Gpr &s2)","STORE HALF,"]},{"entry":["{","ZERO OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","POST INC"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002s1 += 2;",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *+s1(R4)[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_40b_457 (Gpr &s1, U20 &s2, Gpr &s3)","STORE HALF,"]},{"entry":["{","+U20 OFFSET"]},{"entry":["\u2002Result r1 = s1 + s2;",{}]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *s1(R4)++[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_40b_460 (Gpr &s1, U20 &s2, Gpr &s3)","STORE HALF,"]},{"entry":["{","+U20 OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","POST ADJ"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002s1 += s2<<1;",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *+SBR[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_40b_463 (U24 &s1, Gpr &s2)","STORE HALF,"]},{"entry":["{","SBR, +U24"]},{"entry":["\u2002Result r1 = Sbr + (s1<<1);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *SBR++[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_40b_466 (U24 &s1, Gpr &s2)","STORE HALF,"]},{"entry":["{","SBR, +U24"]},{"entry":["\u2002risc_fmem_addr._assert(Sbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Sbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002Sbr += s1<<1;",{}]},{"entry":["}",{}]},{"entry":["VSTH .(SB) *s1(U24),s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTH_40b_469 (U24 &s1, Gpr &s2)","STORE HALF, U24"]},{"entry":["{","IMM ADDRESS"]},{"entry":["\u2002Result r1 = s1<<1;",{}]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *+SBR[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_20b_314 (U4 &s1, Gpr &s2)","STORE WORD,"]},{"entry":["{","SBR, +U4 OFFSET"]},{"entry":["\u2002Result r1 = Sbr + (s1<<2);",{}]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *+SBR[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_20b_317 (Gpr &s1, Gpr &s2)","STORE WORD,"]},{"entry":["{","SBR, +REG"]},{"entry":["\u2002Result r1 = Sbr + (s1<<2);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *SBR++[s1(U4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_20b_320 (U4 &s1, Gpr &s2)","STORE WORD,"]},{"entry":["{","SBR, +U4 OFFSET,"]},{"entry":["\u2002Result r1 = Sbr + (s1<<2);","POST ADJ"]},{"entry":["\u2002risc_fmem_addr._assert(Sbr.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002Sbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *SBR++[s1(R4)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_20b_323 (Gpr &s1, Gpr &s2)","STORE WORD,"]},{"entry":["{","SBR, +REG"]},{"entry":["\u2002risc_fmem_addr._assert(Sbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(0);","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002Sbr += s1;",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *+s1(R4), s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_20b_326 (Gpr &s1, Gpr &s2)","STORE WORD,"]},{"entry":["{","ZERO OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *s1(R4)++, s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_20b_329 (Gpr &s1, Gpr &s2)","STORE WORD,"]},{"entry":["{","ZERO OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","POST INC"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(s1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002s1 += 4;",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *+s1(R4)[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_40b_458 (Gpr &s1, U20 &s2, Gpr &s3)","STORE WORD,"]},{"entry":["{","+U20 OFFSET"]},{"entry":["\u2002Result r1 = s1 + s2;",{}]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *s1(R4)++[s2(U20)], s3(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_40b_461 (Gpr &s1, U20 &s2, Gpr &s3)","STORE WORD,"]},{"entry":["{","+U20 OFFSET,"]},{"entry":["\u2002risc_fmem_addr._assert(s1.range(2,19));","POST ADJ"]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s3.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002s1 += s2<<2;",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *+SBR[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_40b_464 (U24 &s1, Gpr &s2)","STORE WORD,"]},{"entry":["{","SBR, +U24"]},{"entry":["\u2002Result r1 = Sbr + (s1<<2);","OFFSET"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(r1));",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *SBR++[s1(U24)], s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_40b_467 (U24 &s1, Gpr &s2)","STORE WORD,"]},{"entry":["{","SBR, +U24"]},{"entry":["\u2002risc_fmem_addr._assert(Sbr.range(2,19));","OFFSET, POST"]},{"entry":["\u2002risc_fmem_bez._assert(half_decode(Sbr));","ADJ"]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["\u2002Sbr += s1<<2;",{}]},{"entry":["}",{}]},{"entry":["VSTW .(SB) *s1(U24),s2(R4)","VECTOR IMPLIED"]},{"entry":["void ISA::OPC_VSTW_40b_470 (U24 &s1, Gpr &s2)","STORE WORD,"]},{"entry":["{","U24 IMM"]},{"entry":["\u2002Result r1 = s1<<2;","ADDRESS"]},{"entry":["\u2002risc_fmem_addr._assert(r1.range(2,19));",{}]},{"entry":["\u2002risc_fmem_bez._assert(0);",{}]},{"entry":["\u2002risc_vec_opr._assert(s2.address( ));",{}]},{"entry":["\u2002risc_is_vist._assert(1);",{}]},{"entry":["}",{}]},{"entry":["XOR .(SA,SB) s1(R4), s2(R4)","BITWISE"]},{"entry":["void ISA::OPC_XOR_20b_104 (Gpr &s1, Gpr &s2,Unit &unit)","EXCLUSIVE OR"]},{"entry":["{",{}]},{"entry":["\u2002s2 {circumflex over (\u2009)}= s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["XOR .(SA,SB) s1(U4), s2(R4)","BITWISE"]},{"entry":["void ISA::OPC_XOR_20b_105 (U4 &s1, Gpr &s2,Unit &unit)","EXCLUSIVE OR,"]},{"entry":["{","U4 IMM"]},{"entry":["\u2002s2 {circumflex over (\u2009)}= s1;",{}]},{"entry":["\u2002Csr.bit(EQ,unit) = s2.zero( );",{}]},{"entry":["}",{}]},{"entry":["XOR .(SB) s1(S3), s2(U20), s3(R4)","BITWISE"]},{"entry":["void ISA::OPC_XOR_40b_215 (U3 &s1, U20 &s2, Gpr &s3,Unit &unit)","EXCLUSIVE OR,"]},{"entry":["{","U20 IMM, BYTE"]},{"entry":["\u2002s3 {circumflex over (\u2009)}= (s2 << (s1*8));","ALIGNED"]},{"entry":["\u2002Csr.bit(EQ,unit) = s3.zero( );",{}]},{"entry":["}",{}]},{"entry":["XOR .(V) s1(R4), s2(R4)","BITWISE"]},{"entry":["void ISA::OPCV_XOR_20b_55 (Vreg4 &s1, Vreg4 &s2)","EXCLUSIVE OR"]},{"entry":["{",{}]},{"entry":["\u2002s2 = s2 {circumflex over (\u2009)} s1;",{}]},{"entry":["\u2002Vr15.bit(EQ) = s2==0;",{}]},{"entry":["}",{}]},{"entry":["XOR .(V,VP) s1(U4), s2(R4)","BITWISE"]},{"entry":["void ISA::OPCV_XOR_20b_56 (U4 &s1, Vreg4 &s2, Unit &unit)","EXCLUSIVE OR,"]},{"entry":["{","U4 IMM"]},{"entry":["\u2002if(isVPunit(unit))",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2.range(LSBL,MSBL) = s2.range(LSBL,MSBL) {circumflex over (\u2009)} zero_extend(s1);",{}]},{"entry":["\u2003s2.range(LSBU,MSBU) = s2.range(LSBU,MSBU) {circumflex over (\u2009)} zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQA) = s2.range(LSBL,MSBL)==0;",{}]},{"entry":["\u2003Vr15.bit(EQB) = s2.range(LSBU,MSBU)==0;",{}]},{"entry":["\u2002} else",{}]},{"entry":["\u2002{",{}]},{"entry":["\u2003s2 = s2 {circumflex over (\u2009)} zero_extend(s1);",{}]},{"entry":["\u2003Vr15.bit(EQ) = s2==0;",{}]},{"entry":["\u2002}",{}]},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"The GLS unit  can map a general C++ model of data types, objects, and assignment of variables to the movement of data between the system memory , peripherals , and nodes, such as node -, (including hardware accelerators if applicable). This enables general C++ programs which are functionally equivalent to operation of processing cluster , without requiring simulation models or approximations of system Direct Memory Access (DMA). The GLS unit can implement a fully general DMA controller, with random access to system data structures and node data structures, and which is a target of a C++ compiler. The implementation is such that, even though the data movement is controlled by a C++ program, the efficiency of data movement approaches that of a conventional DMA controller, in terms of utilization of available resources. However, it generally avoids the desire to map between system DMA and program variables, avoiding possibly many cycles to pack and unpack data into DMA payloads. It also automatically schedules data transfers, avoiding overhead for DMA register setup and DMA scheduling. Data is transferred with almost no overhead and no inefficiency due to schedule mismatches.","Turning now to , the Global Load Store (GLS) unit  can be seen in greater detail. The main processing component of GLS unit  is GLS processor , which can be a general 32-bit RISC processor similar to node processor  detailed above but may be customized for use in the GLS unit . For example, GLS processor  may be customized to be able to replicate the addressing modes for the SIMD data memory for the nodes (i.e., -) so that compiled programs can generate addresses for node variables as desired. The GLS unit  also can generally comprise context save memory , a thread-scheduling mechanism (i.e., message list processing  and thread wrappers ), GLS instruction memory , GLS data memory , request queue and control circuit , dataflow state memory , scalar output buffer , global data IO buffer , and system interfaces . The GLS unit  can also include circuitry for interleaving and de-interleaving that converts interleaved system data into de-interleaved processing cluster data, and vice versa and circuitry for implementing a Configuration Read thread, which fetches a configuration for the processing cluster  from memory  (containing programs, hardware initialization, etc.) and distributes it to the processing cluster .","For GLS unit , there can be three main interfaces (i.e., system interface , node interface , and messaging interface ). For the system interface , there is typically a connection to the system L3 interconnect, for access to system memory  and peripherals . This interface  generally has two buffers (in a ping-pong arrangement) large enough to store (for example) 128 lines of 256-bit L3 packets each. For the messaging interface , the GLS unit  can send\/receive operational messages (i.e., thread scheduling, signaling termination events, and Global LS-Unit configuration), can distribute fetched configurations for processing cluster , and can transmit transmitting scalar values to destination contexts. For node interface , the global IO buffer  is generally coupled to the global data interconnect . Generally, this buffer  is large enough to store 64 lines of node SIMD data (each line, for example, can contain 64 pixels of 16 bits). The buffer  can also, for example, be organized as 256\u00d716\u00d716 bits to match the global transfer width of 16 pixels per cycle.","Now, turning to the memories , , and , each contains information that is generally pertinent to resident threads. The GLS instruction memory  generally contains instructions for all resident threads, regardless of whether the threads are active or not. The GLS data memory  generally contains variables, temporaries, and register spill\/fill values for all resident threads. The GLS data memory  can also have an area hidden from the thread code which contains thread context descriptors and destination lists (analogous to destination descriptors in nodes). There is also a scalar output buffer  which can contain outputs to destination contexts; this data is generally held in order to be copied to multiple destinations contexts in a horizontal group, and pipelines the transfer of scalar data to match the processing cluster  processing pipeline. The dataflow state memory  generally contains dataflow state for each thread that receives scalar input from the processing cluster , and controls the scheduling of threads that depend on this input.","Typically, the data memory for the GLS UNIT  is organized into several portions. The thread context area of data memory  is visible to programs for GLS proce
