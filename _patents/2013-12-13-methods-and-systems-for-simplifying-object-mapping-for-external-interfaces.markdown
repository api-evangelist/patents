---
title: Methods and systems for simplifying object mapping for external interfaces
abstract: Methods and systems for simplifying object mapping for external interfaces. At least two client requests for action may be received from an external interface wherein each client request may be evaluated sequentially or concurrently in a governed and non-blocking technique. Each client request may be associated to a logical object in order to minimize a representational gap between the client request and a physical object using the logical object. Each query request may be responded to using the object relational mapping in order to simplify the external interface by minimizing the representational gap between the external interface and the physical object using the logical object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08983984&OS=08983984&RS=08983984
owner: Catavolt, Inc.
number: 08983984
owner_city: Alpharetta
owner_country: US
publication_date: 20131213
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BRIEF DESCRIPTION OF THE DRAWINGS","DETAILED DESCRIPTION OF SEVERAL EMBODIMENTS"],"p":["This application is related to and claims the benefit of U.S. Provisional Application 61\/736,882, filed Dec. 13, 2012. This application is also a continuation-in-part of U.S. patent application Ser. No. 13\/830,667, filed Mar. 14, 2013, which is a continuation of U.S. patent application Ser. No. 12\/829,680, filed Jul. 2, 2010 (now U.S. Pat. No. 8,423,561, Issued Apr. 16, 2013), which, in turn, claims the benefit of U.S. Provisional Application No. 61\/222,557, filed Jul. 2, 2009. All of the foregoing are incorporated by reference in their entireties.",{"@attributes":{"id":"p-0003","num":"0002"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6B"},"Contemporary web service approaches may be based on request\/response protocols that send and receive documents, for example third-party scripts. Third-party scripts may commit security and\/or resource violations. Systems and methods described herein may enable the safe execution of programs such as third-party scripts. Systems and methods described herein may provide rich interactions based on entity schemas. A lightweight scripting system may allow entity interactions to be composed remotely and then distributed across participating back ends. Each participating back end may implement the scripting system. Original architecture and design may be provided so that a systems programmer can create a compatible scripting system in any application programming language.","The lightweight scripting system may be conversational so that requesters may be able to preserve session state between calls to the scripting engine. The lightweight scripting system may be composable so that it may support programming-in-the-small abstractions that allow for sub-procedures, looping, and building of expressions from other expressions. The lightweight scripting system may be multi-tenant friendly so that it may be fair to Software as a Service (SaaS) environments that house multiple tenants. A tenant may not be able to prevent another tenant from its fair share of resources. The lightweight scripting system may be highly scalable so that it may be sealable to new heights compared to typical enterprise architectures (e.g., 100,000's of concurrent users per process instead of the typical 1,000s of users). The lightweight scripting system may be very low risk so that it may help ensure the basic tenets of security, which are confidentiality, integrity, and availability.","The systems and methods described herein may comprise one or more computers. A computer may be any programmable machine capable of performing arithmetic and\/or logical operations. In some embodiments, computers may comprise processors, memories, data storage devices, and\/or other commonly known or novel circuits and\/or components. These components may be connected physically or through network or wireless links. Computers may also comprise software which may direct the operations of the aforementioned components. Computers may be referred to with terms that are commonly used by those of ordinary skill in the relevant arts, such as servers, PCs, mobile devices, communication devices, and other terms. Computers may facilitate communications between users, may provide databases, may perform analysis and\/or transformation of data, and\/or perform other functions, it will be understood by those of ordinary skill that those terms used herein are interchangeable, and any computer capable of performing the described functions may be used. For example, though the terms \u201cdatabase\u201d and \u201cserver\u201d may appear in the following specification, the disclosed embodiments may not necessarily be limited to databases and\/or servers.","Computers may be linked to one another via a network or networks. A network may be any plurality of completely or partially interconnected computers wherein some or all of the computers are able to communicate with one another. It will be understood by those of ordinary skill that connections between computers may be wired in some cases (i.e. via Ethernet, coaxial, optical, or other wired connection) or may be wireless (i.e. via Wi-Fi, WiMax, cellular, satellite, or other wireless connection). Connections between computers may use any protocols, including connection oriented protocols such as TCP or connectionless protocols such as UDP. Any connection through which at least two computers may exchange data may be the basis of a network.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 1","FIG. 6A","FIG. 6B"],"b":["100","100","100","110","200","200","110","600","110","650","200","120","200","130","140","100","140","200","120"]},"The scripting systems and methods described herein may introduce an ADL as a lightweight scripting language and the ADL application  as an execution environment for the language. Implementations, discussions, and examples presented herein may be based on the Scala programming language, the Java Virtual Machine (JVM), the Akka model of actors, and the libraries of the respective frameworks, although ADL and the ADL application  described herein may be used with other languages, models, libraries, etc.","Application Dialog Language","ADL may be a compact, infinitely composable scripting language. ADL may be based on symbolic expressions (s-expressions), which are the foundation of languages like Lisp and Scheme. The atoms, lists, and procedures of ADL may be as follows:","Documentation Conventions","The following documentation conventions may be used to describe variables:\n\n","Variable names may be descriptive like <days-integer> as opposed to just <integer>.","Atoms","Atoms may be the indivisible building blocks of ADL and may include the following:\n\n","The following expression may determine whether an s-expression is an atom, (atom? <s-expr>)","Lists","Data and programs may be specified equivalently as lists of words, numbers, or other lists, separated by whitespace and surrounded by parentheses.","ADL may be based on s-expressions and may be defined inductively as:\n\n","An abbreviated notation may be used to represent lists in s-expressions, so that x y z) stands for (x . (y . (z. nil)))","The following convenience functions may determine whether an s-expression is a list or an empty list, respectively.",{"@attributes":{"id":"p-0025","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(list? <s-expr>)"]},{"entry":[{},"(empty? <s-expr>)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"An association may be a pair where the first value may be an atom and the second value may be an atom or another s-expr.","(<atom> <s-expr>)","The following convenience function determines whether an s-expr may be an association.","(assoc? <s-expr>)","Association List","An association list (or a-list) may be a data structure used frequently in ADL. An a-list may be a list of pairs (conses); each pair may be an association. The head of a pair may be called the key, and the tail may be called the datum.","Key values may be atoms, but datum values may be an atom or another s-expr.","((<atom-1> <s-expr-1>) . . . (<atom-N> <s-expr-N>))","A variable association list may be abbreviated as <a-list>.","Typed List","A typed list (or t-list) may be used to convert object instances between ADL and the JVM. The first element may be a capitalized symbol, and the remaining elements may be one or more s-expressions.","(<Type> <s-expr-1> . . . <s-expr-N>)","A typed list may be abbreviated as <t-list>.","Special Forms","Special forms may be different because they may not evaluate in strict applicative order.",{"@attributes":{"id":"p-0038","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(and arg1, arg2, . . . argN)","At least two arguments are required. Return the last"]},{"entry":[{},"evaluation if all arguments evaluate to non-nil (true)"]},{"entry":[{},"values. Return nil (false) the first time an argument"]},{"entry":[{},"evaluates to nil. This expression short circuits."]},{"entry":["(begin arg1 . . . argN)","Evaluate each argument in order. Return the last"]},{"entry":[{},"evaluation as the value for the begin expression."]},{"entry":["(cond (p1 e1) . . . (pN eN))","The predicate p1 is evaluated first. If its value is nil"]},{"entry":[{},"(false), then p2 is evaluated. If p2's value is nil, then"]},{"entry":[{},"p3 is evaluated. This process continues until a"]},{"entry":[{},"predicate is found whose value is non nil (true), in"]},{"entry":[{},"which case the interpreter returns the value of the"]},{"entry":[{},"corresponding consequent expression eN of the clause"]},{"entry":[{},"as the value of the conditional expression. If none of"]},{"entry":[{},"the predicates is found to be non nil, the value of cond"]},{"entry":[{},"is nil."]},{"entry":["(define symOrFormals expr)","Define a variable or a procedure. If symOrFormals is"]},{"entry":[{},"a symbol, then bind into the environment the"]},{"entry":[{},"evaluation of expr at the symbol symOrFormals,"]},{"entry":[{},"otherwise symOrFormals has to be a formal procedure"]},{"entry":[{},"definition where the first symbol is the procedure"]},{"entry":[{},"name and the remaining symbols are the argument"]},{"entry":[{},"names. For example, the expression (factorial n)"]},{"entry":[{},"describes the factorial procedure that takes one"]},{"entry":[{},"argument. The expr argument contains the body of the"]},{"entry":[{},"procedure definition."]},{"entry":["(if pred conseq alt)","If the pred expression is non nil (true) then evaluate"]},{"entry":[{},"the conseq expression. Otherwise evaluate the alt"]},{"entry":[{},"expression. The alt expression is optional. If alt is not"]},{"entry":[{},"provided, and the pred expression evaluates to false,"]},{"entry":[{},"then nil (undefined) is returned."]},{"entry":["(lambda formals body)","Define a closure (ad-hoc procedure) over the current"]},{"entry":[{},"environment. The formals and body are specified"]},{"entry":[{},"under the same rules as the define expression. Here's"]},{"entry":[{},"an example expression (map (lambda (x) (* x x)) (list"]},{"entry":[{},"1 2 3 4 5 6)) that uses a lambda inline and returns (1 4"]},{"entry":[{},"9 16 25 36) when evaluated."]},{"entry":["(or arg1, arg2, . . . argN)","At least two arguments are required. Return the first"]},{"entry":[{},"evaluation that is non nil (true). If all arguments"]},{"entry":[{},"evaluate to nil (false), then return nil. This expression"]},{"entry":[{},"short circuits."]},{"entry":["(quote arg)","Return arg without evaluation."]},{"entry":["(set! sym arg)","Set the value of sym to arg in the environment"]},{"entry":[{},"structure. The variable at sym must already be"]},{"entry":[{},"defined."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0039","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(atom? arg)","Is arg an atom? Return arg if true, otherwise return nil."]},{"entry":["(concur arg1 . . . argN)","Evaluate each argument concurrently. Return results"]},{"entry":[{},"in the same order as the expressions."]},{"entry":["(cons arg1 arg2)","Return a new list where arg1 is the head and arg2 is"]},{"entry":[{},"the tail."]},{"entry":["(empty? arg)","Is arg an empty list? Return true or nil."]},{"entry":["(eq? arg1 arg2)","Is arg1 and arg2 the same object in memory?"]},{"entry":["(equal? arg1 arg2)","Do the two arguments have equal value? Return true"]},{"entry":[{},"or nil."]},{"entry":["(error \u201cmsg\u201d)","Escape processing with a \u201cmsg\u201d as the error message."]},{"entry":["(eval arg)","Evaluate arg as an expression."]},{"entry":["(list arg1 . . . argN)","Return a list containing arg1 . . . argN."]},{"entry":["(list? arg)","Is arg a list? Return arg if true, otherwise return nil."]},{"entry":["(map proc lis)","Map the procedure over the given list. See details"]},{"entry":[{},"below under \u201cThe map( ) Procedure\u201d."]},{"entry":["(not arg)","Return true if arg is nil, otherwise return nil."]},{"entry":["(num? arg)","Is arg a number? Return arg if true, otherwise return"]},{"entry":[{},"nil."]},{"entry":["(pair? arg)","Is arg a pair? Return arg if true, otherwise return nil."]},{"entry":["(println arg)","Print the string representation of arg to the system"]},{"entry":[{},"log."]},{"entry":["(string arg)","Return a string representation of arg. In JVM based"]},{"entry":[{},"languages, this is equivalent to the toString( )"]},{"entry":[{},"method."]},{"entry":["(string? arg)","Is arg a string?"]},{"entry":["stringConcat(arg1 . . . argN)","Concatenate the string representation of each"]},{"entry":[{},"argument into one string."]},{"entry":["(substring str start end)","Return the substring starting and start and ending at"]},{"entry":[{},"end, which is the first character that is NOT part of"]},{"entry":[{},"the string."]},{"entry":["(sym? arg)","Is arg a symbol?"]},{"entry":["(head arg)","Return the head of the list arg."]},{"entry":["(tail arg)","Return the tail of the list arg."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0040","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"The map ( ) Procedure"]},{"entry":[{},{},";Return a new list by mapping the given \u201clis\u201d argument to"]},{"entry":[{},{},";a new set of values transformed with the \u201cproc\u201d function."]},{"entry":[{},{},"(define (map proc lis)"]},{"entry":[{},{},"(if (not (list? lis))"]},{"entry":[{},{},"(error \u201cInvalid map call. Argument is not a List.\u201d))"]},{"entry":[{},{},"(cond"]},{"entry":[{},{},"((empty? lis) \u2032( ))"]},{"entry":[{},{},"(else (cons (proc (head lis)) (map proc (tail lis))))"]},{"entry":[{},{},")"]},{"entry":[{},{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The elements of ADL may be immutable. Procedures may create new expressions from other expressions, but all strings, numbers, symbols, and lists may be immutable.","An s-expression may be classically defined as an atom or an expression of the form (x . y) where x and v are s-expressions. The second, recursive part of the definition may represent an ordered pair so that s-expressions are effectively binary trees. ADL may use an abbreviated notation (like most modern s-expression notations) to represent lists in s-expressions, so that","(x y z) stands for (x . (y . (z. nil)))","The ADL Application","The ADL application may be a non-blocking design. The requester may submit an ADL expression (e.g., an ADL script) to be evaluated, and an environment of procedures and variables, and a continuation call for when the result is ready. This approach may allow processing to be suspended until sub-processing is completed, which may also be suspended until some external event is achieved.",{"@attributes":{"id":"p-0045","num":"0055"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["200","200","200","240","210","220","230","200","1","2","210","210","220","3","240","210","210","220","230"]},{"@attributes":{"id":"p-0046","num":"0056"},"figref":["FIG. 3","FIG. 4"],"b":["300","310","110","140","320","200","330","200","200","340","110","350","110","130"]},{"@attributes":{"id":"p-0047","num":"0057"},"figref":"FIG. 4","b":["400","200","400","210","220"]},"In , the evaluator module  may receive data to be evaluated (step  of ). The data may be a request comprising one or more s-expressions. In , the evaluator module  may schedule an initial s-expression from the data. In , the evaluator module  may determine whether there are presently any s-expressions scheduled for execution by the scheduler module . If not, in  the process  may complete with a final result (step  of ), and in  the process  may end.","Otherwise, in  the evaluator module  may get the next s-expression from the data. In , the evaluator module  may pass this s-expression to the governor module . The governor module  may check execution to prevent any individual session from abusing resources of the ADL application  to ensure that security or resource violations do not occur. If the governor module  detects a violation, for example because execution would exceed specified security or resource constraints, it may notify the evaluator module , and in  the evaluator module  may complete processing of the s-expression with a violation error return and the process  may exit . If there is no error, in  the evaluator module  may determine whether there are any more s-expressions to evaluate. If so, in  the evaluator module  may get the next s-expression from the scheduler module . If not, in  the process  may complete with a final result (step  of ), and in  the process  may end.","If the governor module  does not detect a violation, in  the evaluator module  may analyze the s-expression to determine whether it can be calculated locally by the ADL application  in the session environment . If it can, in  the evaluator module  may complete processing of the s-expression with a request for execution by the session environment , which may then process the s-expression. In , the evaluator module  may determine whether there are any more s-expressions to evaluate. If so, in  the evaluator module  may get the next s-expression from the scheduler module . If not, in  the process  may complete with a final result (step  of ), and in  the process  may end.","If the s-expression will not be processed in the session environment , in  the evaluator module  may analyze the s-expression to determine whether it can be calculated externally after a dialog request. If so, in  the evaluator module  may complete processing of the s-expression with a call to a dialog system (step  of ). In , the evaluator module  may determine whether there are any more s-expressions to evaluate. If so, in  the evaluator module  may get the next s-expression from the scheduler module . If not, in  the process  may complete with a final result (step  of ), and in  the process  may end.","It the s-expression will not be processed by the dialog system, in  the evaluator module  may analyze the s-expression to determine whether it is a primitive request that can be executed by the evaluator module  itself. If so, in  the evaluator module  may complete processing of the s-expression and return a primitive result. In , the evaluator module  may determine whether there are any more s-expressions to evaluate. If so, in  the evaluator module  may get the next s-expression from the scheduler module . If not, in  the process  may complete with a final result (step  of ), and in  the process  may end.","If the s-expression will not be processed by the evaluator module , in  the evaluator module  may analyze the s-expression to determine whether it is a complex request that should be executed by external resources. If so, in  the evaluator module  may pass the contents of the s-expression to the scheduler module  for scheduling. In , the evaluator module  may determine whether there are any more s-expressions to evaluate. If so, in  the evaluator module  may get the next s-expression from the scheduler module . If not, in  the process  may complete with a final result (step  of ), and in  the process  may end.","The process  may thus allow multiple client requests to be performed using the ADL application  before a result is returned. The following example script may be executed according to this process .","An Example Script","The following example is a simple read of name, phoneNumber, and emailAddress from the entity identified as com.catavolt.mk.test.case002.domain.Customer. The data to be read enters the ADL application  at step  of  and a result is provided at step  in . The example illustrates a number of features; the script is conversational and resumes an existing session based on a cryptographic hash of a session key; a procedure is composed (using begin) of three other procedures: createEditorModel, openEditorModel, and readEditorModel; session state is conditionally defined and maintained using the procedures if not, defined?, and define: a request number field rqsNr is computed each time the script is run; and finally, the script ends with a list literal that contains the request number and the read result. The last expression of a script determines the result, so the list literal of the example is returned to the caller through a continuation every time the script is evaluated.",{"@attributes":{"id":"p-0056","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2002(resumeSession \u2032(sessionHandle \u201cd41d8cd98f00b204e9800998ecf8427e\u201d)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2032(callProps nil)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(begin"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(if (not (defined? dh))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(define dh (createEditorModel \u2032(domainClassName"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201ccom.catavolt.mk.test.case002.domain.Customer\u201d)"]},{"entry":[{},"\u2032(callProps nil)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},")"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(if (not (defined? oemr))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(define oemr (openEditorModel dh"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2032(mode read)"]},{"entry":[{},"\u2032(objectId \u201c129\u201d)"]},{"entry":[{},"\u2032(projection (\u201cname\u201d \u201cphoneNumber\u201d \u201cemailAddress\u201d))"]},{"entry":[{},"\u2032(callProps nil)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},")"]},{"entry":[{},"(if (not (defined? remr))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(define remr (readEditorModel dh"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2032(callProps nil)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},")"]},{"entry":[{},"(if (not (defined? rqsNr)) (define rqsNr 0))"]},{"entry":[{},"(set! rqsNr (+ rqsNr 1))"]},{"entry":[{},"(list rqsNr remr)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},")"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":")"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"210"},"The ADL application  may be implemented as an actor in Scala using the Akka framework. The design may take advantage of the built-in and highly scalable Akka runtime for asynchronous processing. The following code snippet is an example Machine class illustrating method signatures which may be involved in a non-blocking evaluator module .",{"@attributes":{"id":"p-0058","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"type Continuation = (Either[Throwable, Any]) => Unit"},{"entry":"private[mk] class Machine extends Actor with ActorLogging {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"private eval(pExpr: Any, pEnv: Env, pCont: Continuation): NotUsed"]},{"entry":[{},"private def evalArgs(pArgs: List[Any], pEnv: Env, pCont:"]},{"entry":[{},"Continuation): NotUsed"]},{"entry":[{},"private def evalProc(pList: List[Any], pEnv: Env, pCont:"]},{"entry":[{},"Continuation): NotUsed"]},{"entry":[{},"private def runEval(pExpr: Any, pEnv: Env, pSender: ActorRef):"]},{"entry":[{},"NotUsed"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The runEval( ) method may be the entry point to the recursive evaluation process. It may receive an expression, environment, and continuation that correspond to the main entry point (step  of ). The implementation may set up a continuation object that may be used to complete the process with either a success or a failure.",{"@attributes":{"id":"p-0060","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"private def runEval(pExpr: Any, pEnv: Env, pSender: ActorRef):"]},{"entry":[{},"NotUsed = {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"val mainCont: Continuation = (result) => {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"result match {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case Left(e) => pSender ! Status.Failure(e)"]},{"entry":[{},"case Right(v) => pSender ! Result(v)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"eval(pExpr, pEnv, mainCont)"]},{"entry":[{},"NotUsed"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The eval( ) method may be the main program loop (i.e., - of ) and may run repeatedly until all expressions and sub-expressions are evaluated, or until an exception halts the process. The eval method may reveal the simplistic power of s-expressions and the ADL language. The entire language may be built upon types of String, Decimal, Boolean, Sym, and List.",{"@attributes":{"id":"p-0062","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"private eval(pExpr: Any, pEnv: Env, pCont: Continuation): NotUsed = {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"try {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"pExpr match {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case string: String => pCont(Right(string))"]},{"entry":[{},"case decimal: BigDecimal => pCont(Right(decimal))"]},{"entry":[{},"case boolean: Boolean => pCont(Right(boolean))"]},{"entry":[{},"case sym: Sym => pEnv.find(sym) match {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case None => pCont(Left(new"]},{"entry":[{},"MachineException(\u201cNot found: \u201d + sym)))"]},{"entry":[{},"case Some(v) => pCont(Right(v))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"case list: List[_] => list match {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case Nil => pCont(Right(Nil))"]},{"entry":[{},"case _ => self ! CallProc(list, pEnv, pCont)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"case other => pCont(Left(new MachineException(\u201cInvalid:"]},{"entry":[{},"\u201d + pExpr)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} catch {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case exc => pCont(Left(new MachineException(\u201cUnexpected\u201d,"]},{"entry":[{},"exc)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"NotUsed"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The evalProc( ) method may be used to invoke procedures, which may be the only higher level expression supported, all other expressions may be atoms. The system of evaluation may be applicative order. The first element of the list may evaluate to a procedure defined by the language. The remaining list elements (the tail) may be evaluated and may all be defined after evaluation. The procedure associated with the first element may then be applied to the arguments from the remaining list elements.",{"@attributes":{"id":"p-0064","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"private def evalProc(pList: List[Any], pEnv: Env, pCont: Continuation):"},{"entry":"NotUsed = {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"def exitPoint: Continuation = (result) => {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"governor.exitProc(pList)"]},{"entry":[{},"pCont(result)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"try {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (pList == Nil) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pCont(Right(Nil)) \/\/ An empty list evaluates to an empty"]},{"entry":[{},"list"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"val cont: Continuation = (evalResult) => {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"evalResult match {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case Left(exc) => pCont(Left(exc))"]},{"entry":[{},"case Right(args) => args match {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case (proc: Proc) :: args =>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"overnor.enterProc(pList)"]},{"entry":[{},"proc(args, pEnv, this, exitPoint)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case other =>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pCont(Left(new"]},{"entry":[{},"MachineException(\u201cInvalid: \u201d +"]},{"entry":[{},"evalResult)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"evalArgs(pList, pEnv, cont)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} catch {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case exc => pCont(Left(new MachineException(\u201cUnexpected\u201d,"]},{"entry":[{},"exc)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"NotUsed"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The evalArgs( ) method may be used to evaluate arguments before they are applied within the evalProc( ) method described above. Each argument may be evaluated individually and asynchronously if it involves a sub-expression. Finally, when all arguments are known, the continuation may be called to apply the procedure to these arguments.",{"@attributes":{"id":"p-0066","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"private def evalArgs(pArgs: List[Any], pEnv: Env, pCont: Continuation):"},{"entry":"NotUsed = {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"try {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (pArgs == Nil) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"pCont(Right(Nil))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"val iter = pArgs.iterator"]},{"entry":[{},"var buffer = ListBuffer[Any]( )"]},{"entry":[{},"\u2002\/\/ Eval first element"]},{"entry":[{},"\u2002eval(iter.next( ), pEnv, cont)"]},{"entry":[{},"\u2002\/\/ Eval next element on completion of prev element"]},{"entry":[{},"\u2002def cont: Continuation = (result) => {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"result match {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case Left(e) =>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"pCont(Left(e))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case Right(v) =>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"buffer.append(v)"]},{"entry":[{},"if (iter.hasNext) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"eval(iter.next( ), pEnv, cont)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"pCont(Right(buffer.toList))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"} catch {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case exc => pCont(Left(new MachineException(\u201cUnexpected"]},{"entry":[{},"\u201d, exc)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"NotUsed"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"220"},"The scheduler module  in the Machine class described above may be built on the Akka framework. The scheduling details that determine when a procedure will run, and on what thread the procedure will run, may be determined by the Akka runtime. In order to use the Akka scheduling, the ADL application  may implement the receive method to handle the asynchronous processing.","Expressions may be submitted for scheduling through an actor send method. The eval( ) method shown above may use the self ! CallProc(list, pEnv, pCont) statement to schedule an asynchronous evaluation of a sub-expression.","The ADL application  may be activated by the scheduler module  by invoking its receive method. One embodiment of a basic receive method is shown below. The two messages which may be essential to the operation of the ADL application  are Eval and CallProc.",{"@attributes":{"id":"p-0070","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"def receive: PartialFunction[Any, Unit] = {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case message => try {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"message match {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case CallProc(list, env, cont) =>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"evalProc(list, env, cont)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case Eval(x, env) => env match {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case None => runEval(x, Env( ), sender)"]},{"entry":[{},"case Some(v) => runEval(x, v, sender)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case Status.Failure(e) =>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"log.error(e, \u201cMachine received unhandled"]},{"entry":[{},"failure\u201d)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case u =>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"sender ! Status.Failure(new"]},{"entry":[{},"MachineException(\u201cUnknown: \u201d + u))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} catch {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case exc => sender ! Status.Failure(new"]},{"entry":[{},"MachineException(\u201cUnexpected\u201d, exc))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}],"b":"230"},"The governor module  may contain the necessary protocol to ensure that maximum allowances are not exceeded for at least the following metrics: elapsed running time, call depth, number of calls, number of object references, and size allocations.",{"@attributes":{"id":"p-0072","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"trait Governor {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"def decRef(pValue: Any)"]},{"entry":[{},"def enterProc(pExpr: List[Any])"]},{"entry":[{},"def exitProc(pExpr: List[Any])"]},{"entry":[{},"def incRef(pValue: Any)"]},{"entry":[{},"def println(pLine: String)"]},{"entry":[{},"def printStatus"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Procedure calls may be checked with the governor module  at the entry points and exit points using enterProc( ) and exitProc( ) as shown above in the sample code for evalProc( ). The governor module  may use these calls to track the elapsed running time, number of calls, and call depth. The enterProc( ) and exitProc( ) procedures may make calls to incRef( ) and decRef( ) so that object references and size allocations may be tracked as arguments move in and out of scope with expressions. The concur procedure, as defined above, may dispatch work concurrently. In this ease, the call depth tracking may suffice for \u201ccall width\u201d tracking as well.","The methods incRef( ) and decRef( ) may be called any time an object is held or released (respectively) through a reference. This may allow the governor module  to track the number of object references and size allocations. There may be at least three scenarios where reference counting need to occur: when arguments are passed to a sub-expression, when a cons procedure creates a pair, and when a value is held by the Env object.","The only output available to ADL scripts may be a simple print in procedure for system logging and debugging. This procedure may route its output through the governor module  to ensure that the maximum log output for a session is not exceeded. The printStatus method may be an internal method used for debugging and may not be available to ADL scripts during execution.","Generalizing Reference Counting in Terms of Expressions","The simplicity of s-expressions and the recursive nature of evaluating expressions may make it easier to reason about reference counting.  is a general definition of s-expressions  according to an embodiment of the invention. This definition  may indicate that all expressions other than atoms may be evaluated recursively. This one point may be used to reason about governance in terms of expressions. For example, the elements of expressions may be atoms and expressions. The elements of expressions may be immutable. Elements may be referenced in nested expressions, so elements passed to nested expressions may be actively counted and uncounted as they move in and out of scope. The cons operator may create a reference to the tail element that may need to be counted. A head element that is no longer referenced may need to uncount its tail reference. Elements bound to the Env object may have acquired a new reference and may need to be counted. Likewise, an element unbound from the Env object may have lost a reference and may need to be uncounted. An element that is no longer referenced may be eligible to have its memory reclaimed. In the reference implementation and implementations based on the JVM, that may mean the object is left for garbage collection. An expression that is evaluated and not used may leave an element that is not referenced. The element may be eligible to have its memory reclaimed.","According to the reasoning based on the definition , some interesting scenarios may be realized. For example, a variable n may be changed. The previous value stored at n may be unbound from the Env object and may be uncounted. The new value at n may be bound and counted. See element \u201ca\u201d of  for an example.","In another example, a complex expression may be evaluated. The begin procedure may cause an expression to be bound to the Env object under the factorial symbol. The nested expressions under define may be counted and may remain as active references because they were bound transitively through the Env object. The actual call (factorial ) may not be used, therefore its result may no longer be referenced and may be eligible to have its memory reclaimed. See element \u201cb\u201d of  for an example.","In another example, a computation may be made. During computation the operator and integer objects may have been active and referenced. At completion however, the final result and all intermediate results may no longer be referenced and may be eligible to have their memory reclaimed. See element \u201cc\u201d of  for an example.","Deployment Scenarios","The ADL application  may be implemented in process if the application server  has a structured web services API, or it can be implemented out of process as a services broker.",{"@attributes":{"id":"p-0081","num":"0091"},"figref":"FIG. 6A","b":["200","500","600","200","610","620","630","640"]},{"@attributes":{"id":"p-0082","num":"0092"},"figref":"FIG. 6B","b":["200","650","650","200","660","670","620","630","640"]},"In either scenario , , conversational applications may be supported through the notion of a session. Each session may have its own ADL environment  that may preserve state between process-to-process invocations. An invocation may look up the session environment  and then may pass it through on the eval(expr, env, cont) call shown in . All processing within an ADL application  may be isolated to its environment therefore the session may be isolated to its session environment . When the result is ready, the continuation (callback) may be invoked to complete processing.","While various embodiments have been described above, it should be understood that they have been presented by way of example and not limitation. It will be apparent to persons skilled in the relevant art(s) that various changes in form and detail may be made therein without departing from the spirit and scope. In fact, after reading the above description, it will be apparent to one skilled in the relevant art(s) how to implement alternative embodiments. Thus, the present embodiments should not be limited by any of the above-described embodiments.","In addition, it should be understood that any figures which highlight the functionality and advantages are presented for example purposes only. The disclosed methodology and system are each sufficiently flexible and configurable such that they may be utilized in ways other than that shown.","Further, the purpose of any Abstract of the Disclosure is to enable the U.S. Patent and Trademark Office and the public generally, and especially the scientists, engineers and practitioners in the art who are not familiar with patent or legal terms or phraseology, to determine quickly from a cursory inspection the nature and essence of the technical disclosure of the application. An Abstract of the Disclosure is not intended to be limiting as to the scope of the present invention in any way.","Although the term \u201cat least one\u201d may often be used in the specification, claims and drawings, the terms \u201ca\u201d, \u201can\u201d, \u201cthe\u201d, \u201csaid\u201d, etc. also signify \u201cat least one\u201d or \u201cthe at least one\u201d in the specification, claims and drawings.","Additionally, the terms \u201cincluding\u201d, \u201ccomprising\u201d or similar terms in the specification, claims and drawings should be interpreted as meaning \u201cincluding, but not limited to.\u201d","Finally, it is the applicant's intent that only claims that include the express language \u201cmeans for\u201d or \u201cstep for\u201d be interpreted under 35 U.S.C. 212, paragraph 6. Claims that do not expressly include the phrase \u201cmeans for\u201d or \u201cstep for\u201d are not to be interpreted under 35 U.S.C. 212, paragraph 6."],"BRFSUM":[{},{}],"DETDESC":[{},{}]}
