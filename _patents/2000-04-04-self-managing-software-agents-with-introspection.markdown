---
title: Self managing software agents with introspection
abstract: A system and method is described for managing plugin program components through encapsulation in a self managing agent that supports introspection for installation. An agent evaluator engine at the host machine interrogates the introspective interface for the agent to determine what resources are required by the plugin. In addition, the engine determines what effect the plugin will have on the host system, and invokes the installation logic which may be contained in the agent. Using the introspective mechanism and installation logic, any changes in the plugin (such as revisions) and the associated dependency changes can be readily accommodated since only a single base of information and installation logic, that which is contained within the enclosing agent, requires modification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06871345&OS=06871345&RS=06871345
owner: Motive, Inc.
number: 06871345
owner_city: Austin
owner_country: US
publication_date: 20000404
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["INCORPORATION BY REFERENCE","BACKGROUND","SUMMARY OF INVENTION","DETAILED DESCRIPTION OF DRAWINGS"],"p":["The following applications are hereby incorporated herein by reference in their entirety and made part of the present application:","(1) U.S. patent application Ser. No. 09\/542,602, filed concurrently herewith; and","(2) U.S. patent application Ser. No. 09\/542,273, filed concurrently herewith.","1. Technical Field","The present invention relates to the field of computer systems. In one aspect, the present invention relates to computer software agents with introspection that manage computer software plugins, and that can be used in connection with other computer programs.","2. Description of Related Art","In computer network applications, particularly telecommunication networks (e.g., the Internet), it is common for an application running at a particular computer to interact with or use another application that may be located at the same computer or at a different computer connected to the network. In addition, technology in the computer area is subject to rapid change, both in the hardware and software technologies that are continually introduced. As a consequence, computer applications in a network environment are often faced with changes in the network environment, whether they be changes in software applications used by a program or changes in hardware (including changing the machines or connections used to run services in the network environment). The challenge of adapting to new technologies resides not only with the end user or client side, but also with the network service provider. For example, an Internet Service Provider (\u201cISP\u201d) experiences changes in the hardware and software technologies that must be supported, in the expectations of the subscribers, and in the need for service enhancements to respond to competitive pressures.","Generally speaking, computer software products that require modification or extension after the software products are up and running on a client system (for example, within a client\/server environment) are typically extended using a plugin module that interfaces the client system wherein the software product is resident. The client system must recognize and install the appropriate plugin to complete a software extension and must interface both the plugin module and the software product. The responsibility for all knowledge of how to verify the appropriateness of the use of a specific plugin module (due to version changes, procedural interface changes, functional changes, etc.) resides both in the host computer system as well as all related modules that expect to use the plugin module.","This base of information grows exponentially as plugin modules are added and evolve over the life cycle of the software product. Indeed, sweeping upgrades to existing modules may be required each time a new individual plugin is defined. For example, in conventional client\/server based systems, the management of distributed state information for the system requires storage of per-client state information at the service end so that services can rely on certain facts about the client state. Such a server would need to store overhead information about the particular programs and versions available at a client to permit proper interaction between the server and client. Hence, the conventional system for implementing extension creates the significant problem of an ever-growing base of information that is required to maintain compatibility. In conventional systems, each new software extension, or \u201cplugin\u201d module, creates a new set of module interdependencies that must be maintained in all modules that expect to use the newly created plugin. Furthermore, the controlling system must contain all information about the management of the plugin prior to actually loading it and providing its services to the software system. In addition, with conventional plugin modules, user intervention is typically required to effectuate software extension.","Further limitations and disadvantages of conventional systems will become apparent to one of skill in the art after reviewing the remainder of the present application with reference to the drawings and detailed description which follow.","In accordance with the invention, an apparatus for storing a computer-readable module for use in a host computer is provided where the module comprises a functional component for providing a predetermined programming functionality, and a preprocessing interface component for providing introspective information about any requirements of the functional component in response to a request from the host computer. In addition, an installation program component may be provided as part of the module or as part of the host computer that manages the installation of the functional components. The preprocessing interface may be implemented in a variety of ways, including implementation as command sequences that encapsulate or identify the functional component, or as executable object code that encapsulates or identifies the functional component. In selected embodiments, the host computer may request introspective information as part of an installation of the module in the host computer, or when the module is required by a second module stored at the host computer. The introspective information provided by the preprocessing interface may be version information for the module, identification of an external module required by the functional component, identification of the type of functional component, identification of at least a first resource at the host computer that will be modified by the functional component, or any of a variety of other identification data specifying the behavioral or functional requirements of the module.","In accordance with an alternate embodiment of the present invention, a computer system is provided including a first computer having at least a first plugin module and a harness. Such a computer system may be a client\/server system where the first plugin module is a client plugin module or a server plugin module, may be network computers (sometimes described as \u201cthin client\u201d systems) or dumb terminals, or may be any other arrangement of computer machines in connection with which modules are used, whether locally or remotely.","The first plugin module includes an introspection interface portion and a program behavior portion, and may also include an installation program component. The harness evaluates the introspection interface portion of the first plugin module to determine if any resources are required for use of the program behavior portion of the first plugin module. In addition, the computer system may also include a second computer connected to the first computer, where the second computer includes a first resource required by the first plugin module that is transferred to the first computer upon request by the plugin installation program component, or upon request by the harness. In a selected embodiment, the first resource is a second plugin module that itself includes an introspection interface portion, an installation manager portion and a program behavior portion. In addition or alternatively, the harness may be configured to evaluate the introspection interface portion of the second plugin module to determine if any resources are required for use of the program behavior portion of the second plugin module. As will be appreciated, either or both of the introspection interface portion and the installation manager portion may be an executable script (e.g., a Tcl script), a command series or an object-code module.","In connection with the present invention, a harness assists with the introspection and\/or installation of new modules. In a selected embodiment, the harness includes a loader component for loading a plugin module comprised of an introspection interface portion, an installation manager portion and a program behavior portion; a validator component for interfacing with the introspection interface portion to identify any resources required by the plugin module; and a finder component for surveying the computer system for any resources identified by the validator component.","In accordance with a still further embodiment of the present invention, a method is provided for preprocessing a software module that has an interface portion and a program portion. The method includes receiving a first software module, querying the interface portion of the first software module to identify any resources required by the program portion, and invoking the installation manager portion of the module if all resources required by the program portion are available. For example, the first software module may be received by connecting to a remote computer over a telecommunication network and downloading the first software module from the remote computer. In addition, resources required by the program portion are retrieved that were identified as a result of querying the introspection interface portion prior to invocation of the first software module or as a result of invoking the installation manager portion. In a selected embodiment where the retrieved resource is a second software module comprised of an introspective interface portion, an installation manager portion and a program portion, the interface portion of the second software module is queried to identify any resources required by the program portion of the second software module.",{"@attributes":{"id":"P-00024","num":"00024"},"figref":"FIG. 1","b":["100","97","99","101","101","97","99","101","115","117","135","136","101"]},"In accordance with the present invention, the client\/server network  shown in  may include one or more client systems , ,  and\/or one or more server systems ,  in which plugin manager agents of the present invention may be used. Examples of client\/server platforms that may be used with the present invention include Digital Open VMS, Digital UNIX, DOS, Java, Macintosh, Linux, Microsoft Windows, Sun Solaris, IBM AIX, etc.",{"@attributes":{"id":"P-00026","num":"00026"},"figref":["FIG. 2","FIG. 2"],"b":["135","135","135","135","135","135","135","135"],"i":["a ","b ","c ","b","b ","a ","c"]},"This method also provides for the management of a heterogeneous set of plugins within a system. Since the details of the plugin are encapsulated within the module itself, the details are free to change in arbitrary ways in the future with no impact to installed controller systems.","As shown in , the plugin agent module of the present invention consists of the actual plugin component (i.e., a plugin to provide a new service, application or other feature) and two components of the agent which enclose and encapsulate the plugin component. The first agent component is an introspective interface that allows an interrogation process to discover the characteristics of the enclosed plugin. The second component is an installation manager component that manages the process of preparing the target program and system as well as the plugin component itself for the installation process, and actually installing the plugin component ","In one embodiment, the plugin component is object code, etc., and the installation interface and installation manager are command scripts that encapsulate the plugin component. These commands provide certain interface features, including an introspection capability that responds to interrogation with the details of the identity and characteristics of the plugin modules. These characteristics specify the types and versions of other modules or programs that are required for the plugin component to function. The introspection capability may identify not only the other modules required to run the plugin component, but may also identify alternative groupings of modules as options for running the plugin component. The introspection interface may also provide version information for the plugin to the outside world. The installation manager component of the agent contains executable functionality that implements the logic which is required to correctly load the plugin component into the client system.","In accordance with alternate embodiments, the plugin functionality is implemented in executable code and the introspective interface and installation manager are also implemented in executable code so that the entire module  can be compiled and run as a unit of code. While the plugin  in this embodiment is not in any strict sense of the word \u201cscripted,\u201d the introspection functionality is still provided, though with a coded interface rather than a scripted interface. A plugin in this form continues to provide compatible introspection and installation management functionality.","As yet another alternative embodiment, the plugin functionality and the introspection interface and installation manager are all implemented in command scripts.","As may be appreciated, the plugin functionality of may be of arbitrary form where the interface defines specific details about its installation and use.","Referring again to , the computer system (e.g., ) that receives the plugin manager agent  includes a mechanism for installing or loading the plugin module. One example of such a mechanism is a plugin harness  or plugin engine. This mechanism is used to install, invoke and\/or run the plugin module, whether the plugin module be command script, directly executable code or some combination program. The plugin engine may be implemented as a command evaluation engine, directly executable code or some combination of the two depending upon the types of plugin modules that are to be used. Regardless of form, the engine provides installation\/invocation processing in connection with a new plugin module through a series of steps which are outlined in FIG. .","As shown in , the engine first retrieves or receives a new plugin manager agent (step ). This can be accomplished in a variety of well-known ways, including retrieving the module from a floppy disk, CD-ROM, remote storage or from another computer system on the Internet. Once retrieved, the plugin manager agent will be used to install the plugin module prior to actual use of the module. In accordance with one embodiment of the present invention, the installation proceeds under the control of the plugin engine which queries the introspection interface portion of the plugin module to determine the extent to which the plugin module can be installed.","In particular, the engine queries the new module to determine from the introspection interface of the module what, if any, other modules are required to run the new module (step ). As will be appreciated by those skilled in the art, this determination can be accomplished in many ways. In one embodiment, the query step  asks the plugin manager agent  to identify the plugin module's version information and to also identify any other modules (including version information for the modules) that are required for the plugin module to operate. Additional information can be retrieved from the plugin manager agent  through the introspection interface , including the application environment in which the plugin should run and the type of plugin identifying whether the plugin defines procedures, creates objects or procedures, creates or updates files or loads various program behaviors such as libraries or executables. Additional retrieved information may include a listing of procedures, files, objects or configuration values that the plugin will define, create, replace or modify. For example, a procedure named \u201cInstall_Widget1.0\u201d uses an \u201coption\u201d parameter to provide the introspection that is used to determine correct way to load the plugin. By evaluating the procedure with a pre-defined value for the option parameter, the client program can learn such details as the form of the plugin (command script, Windows DLL, Solaris \u201c.so\u201d library, etc.), the nature of the resources it requires, the details of the interface it implements, etc.","Through the execution of logic within the introspection interface , the plugin engine then determines if the computer system on which the engine resides has the other modules that are required for the plugin module to operate (). Such a determination can involve searching the memory storage  of the computer system  to locate the required modules , , or may also include searching through remote storage locations (i.e., on other computers  to which the computer system is connected over a telecommunication network). In addition, the availability of required resources can be determined by searching a list of resources  available to the computer system, where the list was previously or periodically generated to expedite the speed of any such survey.","Based on the introspection and survey (steps , ), the engine can then determine whether all of the required resources are available at the computer system (step ). If all required resources are available, then installation can proceed immediately upon determining that there are not conflicts presented by using the new module (step ). The plugin may be installed, either by the plugin engine or by the plugin module itself. Once the plugin engine has made the determination to proceed with the installation, it invokes the agent's installation manager code to complete the installation. If any required resource is not available, then the engine retrieves the required resource from a resource repository whose location is previously known (step ). For example, the computer system  can contact a designated server  or group of servers over a telecommunication network  to retrieve the required resource from a library of resources stored at the server . Alternatively, local storage  could include a pointer or vector for a site where the desired resource is stored. Another option upon determining that the required resources are not available (step ) would be to issue a failure report to indicate that the plugin module and any required resources cannot be loaded (step ).","Of course, once a resource is retrieved (step ), the process may be repeated all over again. For example, if the engine retrieves a required resource (e.g., a graphics extension module) for the new plugin module that is not locally available, the engine invokes the introspection interface (step ) of the graphics extension module to determine what resources are required by the graphics extension module, and again checks the availability of such resources locally (step ) before deciding whether to retrieve any missing resources before installation (steps , ), or to instead indicate that the plugin cannot be installed (step ).","Once the plugin engine has collected the information it needs in order to prepare to load the plugin module , the plugin engine invokes the agent's installation manager to complete the installation. The plugin installation manager is expected to manage the details of loading from this point on, although it may certainly make use of features of the client program. As mentioned above, this can be a multi-step process, whereby a plugin is loaded, decides that it needs to install another plugin in the client program in order to complete its install, and does so using the methods and techniques of the present invention. The installation manager may also locate, transport and store files, program components and other plugins under its own direction and with or without the direct involvement of the plugin engine. This ability is not limited to the actions that are provided by the plugin engine, but may use operating system facilities as well as facilities of other plugin components. The installation manager may also determine and ensure the presence of prerequisite resources through mechanisms that have complete, some or no dependence on the plugin engine. The installation manager is in this respect an independent agent that is loaded and started by the plugin engine.","In accordance with one embodiment of the present invention illustrated in , the details of a plugin code are abstracted through the use of an interfaces and where logic and procedures are resident within the plugin manager agent . In this manner, the host system or related module needs only to support the interface language in use to fully interoperate with the newly added plugin manager agent . Since the interface logic for and is contained within the plugin manager agent , all requirements for specific knowledge about the plugin are localized to the agent . This abstraction allows arbitrary plugin architecture and services.","The relationship between the plugin manager agent  and the host system (i.e., client ) allows the client's system controller  to install the plugin via an abstracted interface. The system controller invokes the installation manager interface that is contained within the agent . As this interface is evaluated or executed, all system dependencies and versioning information are correlated and the agent , in effect, manages the installation of the plugin component that it contains. A success\/fail signal is returned to the system controller to indicate progress and availability of the plugin for further use.","As for the relationship between the newly installed plugin  and another resident plugin  or related module in the client , as services are required of the new plugin , an invocation interface is used to properly identify and validate the requested usage of the plugin . As the interface logic is evaluated, information such as version compatibility and\/or procedure interfaces is resolved in an active manner with plugin specific behavior possible. As the installation logic is evaluated, interface version and state management requirements are resolved so that the newly installed plugin can interoperate with another resident plugin such as  or related module in the client such as . After a successful evaluation of the installation interface, the environment for direct \u201cnative\u201d use of the plugin component by the related module  has been enabled. Ongoing use of the plugin is then accomplished in whatever arbitrary manner that may be required for efficiency or other requirements, as will be appreciated by those skilled in the art.","As described herein, management aspects of plugin modules are accomplished via the introspection interface and installation manager which allows for completely dynamic and extensible behavior. The management interface itself may be extended on a module by module basis allowing for unlimited future functionality while maintaining the history of previous methods. This has the added benefit of eliminating unused or outdated control logic automatically from the controlling system. Without the active agent method, the controlling system is typically extended to contain the specific information of module evolution. This usually results in an ever-increasing code size to maintain historical compatibility. With the active agent method, only the actual required management code is present because it resides directly within the modules that require management. When a module is replaced or becomes outdated and is deleted, its specific management logic and associated code overhead leave the system immediately.",{"@attributes":{"id":"P-00044","num":"00044"},"figref":["FIG. 4","FIGS. 1 and 2","FIG. 4"],"b":["135","117","410","119","135","135","135","420","420","119"],"i":["b ","a ","c "]},"Next, the newly created plugin manager agent  is placed in storage at a location that can be accessed by the client  (step ), whether at the client computer , at a remote computer on the network , , or both. Next, the client  requests or receives a copy of the plugin manager agent from storage (step ). The client  may either have some built in knowledge of the location of the plugin manager agent, or it \u201cdiscovers\u201d the plugin manager agent via an enumeration application programming interface (\u201cAPI\u201d) that calls the plugin storage site. After the plugin manager agent has been transferred to the client (step ), the client uses the introspective features of the plugin manager agent's interface to determine the exact details of the loading process (step ). Finally, the plugin manager agent's installation manager interface is invoked and the plugin component is loaded and is available for use by the client (step ).","As shown in , the client  may include a client plugin harness component  that encapsulates the task of finding and loading plugins into an API for client programs (steps , ,  shown in FIG. ).  illustrates the components of an exemplary client plugin harness . It will be appreciated that the harness functionality is implemented in either hardware or software form, or a combination thereof.","As described in the related applications incorporated by reference herein, a plugin manager agent  may be located by name or characteristics in the distributed network  using the finder component . Once the path to a particular plugin manager agent has been determined by the finder , this path is presented to the client plugin harness loader  in a \u201cload plugin\u201d request. The client plugin harness then checks the validity of the plugin  with the validator component . The validator  queries the plugin characteristics via the introspection support provided by the introspection interface for the plugin manager agent . Different types of plugins have different validation sequences.","For example, a new set of procedures may be tested for non-perturbation. That is, this type of plugin manager agent is expected to provide a list of the new procedures it contains, and a list of the procedures that might replace procedures that already exist in the target client namespace. The loader  checks these against the current state of the client program in order to ensure that the plugin  does not inadvertently redefine an existing procedure.","As another example, a plugin  might contain a binary load-able library. In this case the loader  verifies that the library is of the correct type for the client machine, and that proper versioning structure is maintained, i.e. that older versions do not replace newer versions.","During validation, a plugin manager agent  may indicate that it requires the presence or absence of another plugin, or that it replaces another plugin if it is present. In an exemplary embodiment, the loader  supports a simple file versioning scheme, where the plugin manager agent  is interrogated to determine what files it will create, replace or modify. The loader  makes a copy of any existing files that match the names supplied by the plugin manager agent , and records the details of file names and the plugin name in a log file. This log file can later be used to roll back the changes that a plugin introduces.","In the event that a plugin manager agent  needs to load a file or another plugin, it uses facilities in the client plugin harness  to do this, substantially as described above.","The client plugin harness  may support local storage of plugin manager agents for reloading. The reloading process is functionally equivalent to loading the plugin manager agent from the original storage site, except for the physical collection of the plugin manager agent itself. If all the plugin manager agent and plugin-related file searching and loading operations have been completed using relative pathnames, then the re-loading process can search for and load these files via local storage. In one embodiment, an option to the load command allows absolute path names to be used for the initial load, but for subsequent searches and loads, a local copy is used if it is available. Without this option, absolute pathnames always result in accesses to the original storage site.","As will be appreciated by those skilled in the art, the client plugin harness  may itself be replaced by a new plugin. In this way, support for new features may be added when needed to the harness functionality.","In accordance with one embodiment of the present invention, the client plugin harness  completes validation and load operations as described above. In an alternative embodiment, the load and validate functions provide a more rigorous examination of the process and the file system before and after the plugin  is loaded in order to provide a high level of confidence that the plugin programmer has properly implemented the introspective description. This \u201cqualifier version\u201d of the harness  tests the plugin  by executing logic that is gathered from the plugin installer through interrogation. The plugin programmer provides this logic as a part of the plugin introspection interface . Its purpose is to exercise the plugin logic to the degree that it is possible to do so in an automated fashion. In this way, the harness  detects most or all of the effects of actually executing the plugin , not just loading it.","The qualifier version of the client plugin harness may also be used in a special validation client that collects the results of the load attempt and prepares a report listing details of the changes and potential problems. This process is repeated in multiple passes in combination with other plugins so as to detect harmful interactions. The validation client builds a list of plugins to test against each other by browsing the available plugins and looking at their properties. These properties contain \u201crelation\u201d attributes, lists that describe which plugins can be run together, depend on each other, supercede each other, etc. If there is a relation that applies to an earlier version of the new plugin, then it applies to the new plugin by default, although the plugin programmer can override this. This limits the validation process to those plugin combinations that might actually appear in a normal client.","In accordance with one embodiment that is especially useful when a client machine is first used, the client plugin harness has a \u201cbootstrap\u201d capacity that allows the harness to look for a service that can provide plugins, and then load one or more. This feature can be based on use of a default \u201cbootstrap\u201d plugin that understands how to access minimal functionality in the distributed services network. This service always listens at an Internet address and port number that is either built in to the bootstrap plugin, or is provided to the client program via runtime configuration or user interaction. In one embodiment, the default locations are machines named \u201cesbbootX.Z.com\u201d, where the \u201cX\u201d is a number from 1 to 100, and \u201cZ\u201d is the domain name of the subscriber's ISP or some other service. Many port numbers are supported, and this data takes the form of a service point map. The bootstrap plugin sequences through these addresses and port numbers until it finds a working service.",{"@attributes":{"id":"P-00057","num":"00057"},"figref":["FIG. 6","FIG. 4","FIGS. 1 and 2"],"b":["118","420","118","621"],"i":"b "},"Once the plugin functionality (such as executable code) is prepared (step ), the programmer creates a generator control file  (step ) which specifies the details of the plugin  such as its name, its storage location, its type and the executable files from which it is constructed. An interface generator ,  may be used to create the plugin agent install logic based on the information in the generator control file  (step ), including programming to provide minimum introspection support and installation management. The interface generator ,  also invokes the validation client in order to produce the required validation report (step ). After generating the plugin manager agent and using it to produce the validation report, the generator ,  submits the report, the generated plugin manager agent and all relevant files for storage as a plugin manager agent module  (step ).","As will be appreciated by those skilled in the art, the plugin manager agents described here are intended to support any kind of element of programming behavior, including anything that can be sent across a network connection and subsequently executed or accessed by an executing program. This flexibility is based in part by providing each plugin with a interface mechanism for introspectively determining its behavior and requirements, and then providing the relevant information about the plugin performance and requirements on the use of the plugin to any other entity (i.e., the client hosting the plugin or any module calling the plugin) requiring such information (i.e., for installation or execution). This flexibility is also based in part on providing each plugin with an installation manager that can complete any arbitrary installation step without regard to the preprogrammed limitations of the plugin harness.","In accordance with an exemplary embodiment of the present invention, client plugin components are used to implement an element of program behavior in a client program at runtime. Such plugins can also be used with server programs to like effect. The flexibility needed for such implementation is advantageously provided by the present invention through use of parameter-driven behavior that provides introspective information about the plugin.","In an exemplary implementation, the API that the plugins are required to support uses a parameter-driven feature set whereby any changes in the features supported by the API are reflected only in the parameters to the API functions, not in the signatures of the functions themselves. In this way, new features can be added to the API without impacting its compatibility with existing callers of the API. As described herein, this API uses a single API function and a single parameter to control its primary introspection function. This parameter causes the API function to return various kinds of information about itself, i.e. to exhibit reflection, or to take one of potentially many actions.","To address instances where changes in the arguments supported by a function introduce pathological incompatibility that is not evident (for example, version 1.0 of an API supports an option called \u201coutput\u201d that opens a file for \u201cappend,\u201d so that the previous file contents are saved and new output is added, but version 2.0 of the API retains the option but changes its behavior to write, erasing any previous file contents), all interactions between the API user and the API provider (i.e. the plugin loader and the plugin manager agent, respectively) begin with a version sync operation.","Referring to , the loader  interrogates the plugin manager agent  for a specification of the API version in use, and if the version of the plugin is supported by the loader, then the plugin manager agent  is loaded. However, if the plugin version is not supported by the loader  at the client, an alternate loader is obtained. For example, the plugin loader is implemented using an application namespace feature such that multiple, incompatible versions of the loader can co-exist in alternate execution namespaces. The client program has at least one version of the plugin loader installed, so other loader versions can be loaded as plugins. All loader versions are available in forms compatible with all other loader versions, so the loader version required in order to load a plugin can always be loaded for use when needed.","Referring again to , there is shown a schematic block diagram of an exemplary client\/server system  having, among other components, a plugin module (e.g.,  or ) that enables dynamic extensibility for computer software according to the present invention. More specifically, a server computing system  generates and downloads to a client system  a plugin manager agent module  that enables dynamic extensibility for computer software residing within the client system .","In accordance with the present invention, a user desiring to extend software residing within the client system  requests a plugin manager agent module from the server computing system . The server computing system  has a stored copy of the previously generated plugin manager agent. A plugin delivery module  forwards the plugin manager agent to the client system . The plugin manager agent  is received by a communication device  and stored in the memory  of the client .","On receiving the plugin manager agent , a processor  interfaces with the plugin manager agent under control of a processing engine  (which may reside in memory ) to evaluate and implement instructions within the installation and management portions of the plugin manager agent  to accomplish the desired software extension and\/or install the plugin. As will be appreciated, the plugin manager agent installation logic is evaluated by the processor to determine all system dependencies and\/or versioning information for the plugin  and to correlate this information with the client-side system information so that it can be determined if the plugin can be successfully installed at the client , or if instead, additional information or plugins are required for installation. Likewise, any module ,  at the client  requesting usage of the plugin  may invoke the engine  to interface with the introspection aspect of the plugin  or may invoke the functional part of the plugin directly.","As an alternate embodiment of the present invention, the server computing system  also includes a server plugin interface generator  that produces a server plugin interface for server plugin  for extending an application at the server . When the server functionality of plugin  is required by a resident application at the server , the server interface engine  implements logic within the installation and management portions of the plugin manager agent  to enable extension of the application using the plugin  if it is determined through introspection of plugin  that the module  is compatible and\/or properly interfaced.",{"@attributes":{"id":"P-00068","num":"00068"},"figref":["FIG. 7","FIG. 1"],"b":["100","201","201","203","233","238","239","205","235"]},"To initiate processing, the controller  downloads plugin manager agent module , either from a server, through a network or from some other storage media. Residing within the client system  are applications  and . The application  includes several modules , ,  and  that require extensibility. On receiving the plugin manager agent module , the controller  invokes the introspective interface portions of script plugin module  using the interface processing engine . As the interface logic is evaluated, all system dependencies and versioning information are correlated to determine if the client system  has the resources required by module . Once all the required criteria have been met, the controller  completely installs plugin module  by invoking the plugin manager agent's installation manager component. If additional modules (e.g., modules , ) are required to run module , the controller  accesses a server to retrieve the modules , , when such a plugin is available.","Of course, the present invention may also be used each time a module is requested or called, and not just at installation. For example, if execution of a first Application  requires use of module , a script interpreter  invokes the introspection function of plugin manager agent  to determine if the required resources for module  are present. To run the first Application , the controller  loads the plugin manager agent module  which has an introspective interface . The interface processing engine  invokes the introspection and installation logic within the plugin agent module . The logic implements evaluation of management or version compatibility information, for example. Thus, the interface engine  checks for version compatibility and correlates all information before running the plugin module . As the installation logic and the installation manager logic are evaluated, all system dependencies and versioning information are correlated and the plugin , in effect, manages its own installation. A success\/fail signal is returned to the system controller  to indicate progress and availability.","All knowledge of the plugin  is encapsulated within the module itself. In addition, the system controller  has introspective access to all required information in the plugin manager agent module . As the plugin  evolves into future modules, for example, only the plugin  having a single base of information need be replaced or modified. Moreover, the management of a heterogeneous set of plugins within a system becomes a relatively effortless task.","As described above, the plugin engine or client plugin harness are shown as distinct programs within the client system within the client\/server network of FIG. . It will be appreciated that this aspect of the present invention can also be implemented as part of another program application. In such an embodiment, an application requiring extensibility includes an introspection segment for interfacing with plugin modules. When the application is executed, the introspection segment identifies and downloads compatible plugin modules as required and on the fly.","As described above, the plugin manager agent module  may include its own installation functionality for managing the installation of the module. In such an embodiment, there may be a substantial amount of code or logic (i.e., for managing the process of retrieving necessary modules, deciding whether to complete the installation and actually installing the plugin module) which is repeated in each plugin manager agent module and which provides a high degree of autonomy within each plugin manager agent module. However, from an overall system efficiency standpoint, it may be desirable to have any common installation functionality be incorporated once at the plugin engine. Accordingly, an alternate embodiment of the present invention allocates the installation functionality at the plugin engine, thereby reducing the need to store such functionality as part of each plugin module.","While the system and method of the present invention has been described in connection with the preferred embodiment, it is not intended to limit the invention to the particular form set forth, but on the contrary, is intended to cover such alternatives, modifications and equivalents as may be included within the spirit and scope of the invention as defined by the appended claims so that those skilled in the art should understand that they can make various changes, substitutions and alterations without departing from the spirit and scope of the invention in its broadest form."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"P-00017","num":"00017"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00018","num":"00018"},"figref":"FIG. 2","b":"1"},{"@attributes":{"id":"P-00019","num":"00019"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"P-00020","num":"00020"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00021","num":"00021"},"figref":"FIG. 5","b":"1"},{"@attributes":{"id":"P-00022","num":"00022"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00023","num":"00023"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
