---
title: Method and system for importing data
abstract: A method of transferring batches of data to a target database includes receiving ordered rows of data and loading the ordered rows into batch tables. Each batch table being either a parent table, a child table or a no dependency table. The parent batch tables and no dependency batch tables are entered into a ready queue and the child batch tables are entered into a into a waiting pool. Any batch table in the ready queue may be transferred to the database using one or more processors. Any child batch table is moved to the ready queue if no corresponding parent table is in the ready queue. A dependency count of a child table is maintained and decremented if a parent table is imported to a database. In one embodiment, the corresponding child table in the waiting pool is transferred to the ready queue if the dependency count is zero.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07421440&OS=07421440&RS=07421440
owner: Microsoft Corporation
number: 07421440
owner_city: Redmond
owner_country: US
publication_date: 20040824
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Exemplary Embodiments of the Invention"],"p":["This invention relates in general to the field of database computing. More particularly, this invention relates to an efficient transfer between a batch table cache and a target database.","Due to the innumerable active systems running in a enterprise environment, data movements such as exporting and importing operations became very frequent. The frequency of these operations tends to be constant but the amount of data involved tends to grow over time. Therefore, being able to import data to a database in the least time possible is often a very important matter for many IT departments; it could mean a better availability for a mission critical application.","There are many different options for bulk data loading into a database. In a Microsoft\u00ae SQL Server\u00ae computer environment available from Microsoft Corporation in Redmond, Wash., one could use BCP command line, a T-SQL bulk insert, the OLE database products DB IRowsetFastLoad interface or other variations known in the art. A common attribute of all these options is that they handle only a single table operation. The bottleneck in the loading operation is that the database management functions are engulfed in tasks to keep the database receiving the data. Usually the client side is reasonably fast because its tasks are reading and converting the data from the input file and transmitting the data to the server. Once the data is in the server, being appended to the database table, the client side may process another chunk of data, but it will not submit it until it receives an answer about the first data submitted.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1","b":["100","102","105","102","105","102","102","105"]},"The data shredder  can produce row data in a format that allows a cache  to form distinct tables representing the row data. For example Table A, , may represent a parent table from row data received for the data shredder . Table B,  may represent child table data related to Table A. Table C,  may represent row data from the data shredder  that is a child of Table B. Since the row data generally is provided in a hierarchal form with parent data first, Table A, being a parent data table may be filled first followed by Tables B and C respectively. Once loaded, these tables are in a form for transfer to the database .","Prior art transfers from the cache organizer  to a database  are generally performed in a serial manner. Table A would be transferred first followed by Table B and then Table C in order to satisfy the need for the database to generate appropriate indexes and other hierarchical structures for the database. The process is also typically serial because only one processor typically handles the transfer of the Tables and the tables are filled completely and then transferred over to the data base in serial generation order.","It is well known that the bandwidth of a serial interface  from the cache  to the database  can be greater than the processing speed of the cache organizer  itself. Consequently, the database  could, in theory, be loaded much faster if the cache organizer  could more quickly produce data for the database. However, the single processor serial transfer mechanism of the prior art limits the speed at which tables destined for the data are made available. Even in multiprocessor environments, it is typically the responsibility of a single processor to manage the transfer of tabular data to a database.","Thus, there is a need for a technique which can perform a time and resource efficient transfer of tabular data to a target database. In particular, it would be useful if the technique could make use of a multiprocessor environment. The present invention addresses the aforementioned needs and solves them with additional advantages as expressed herein.","An embodiment of the invention includes a method for importing data from a source to a target in a resource and time efficient manner. Data that is to be imported to a target database may be stored in multiple dependent tables. One embodiment of the invention can load multiple tables at the same time resulting in a shorter operation time.","Initially, a prior art mechanism generates the ordered rows to be imported. These rows are received and batched in an appropriate order based on the dependency of the tables involved in the operation. The rows are cached and processed as batches in the right order. The order may be maintained by a graph of batch dependency and what batches are ready to be inserted into a database. The batches that are ready to be imported to the database are transferred to the database using multiple threads so that multiple processors can conduct the transport simultaneously. One embodiment uses multiple batches in a ready queue awaiting importation. Since multiple batches could be ready at any given time, a multiple processed environment can take full advantage of those resources and import batches concurrently.","In one embodiment, a priority queue may be used to designate some batches as higher priority than others based on the number of child tables dependent on rows in the parent such that after the parent is transferred to the database, the children may then be loaded into a ready queue thus providing the ready queue with a broad number of tables to be imported.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2","b":["200","102","205","205","210"]},"The row caching and dispatch component  is responsible for caching and processing the batches tables in the right order. This row caching and dispatch function  maintains a structure, for example, a graph, of the batch table dependency and what batch tables are ready to be provided as an output. The row caching and dispatch  also controls the number of concurrent sessions opened against the target database and the number of threads processing the batches. As a result, batch tables can be efficiently imported to the database  via the database manipulation functionality .","The database manipulation component  is responsible for performing the import operation using a fast database transfer technique. This component receives a batch of rows to be imported and performs the transfer operation. After importing the batch, the dependency graph is updated and more batches become ready to be imported. Because multiple batches could be ready at any given time, a multiple processed environment can take advantage of the multiple batch tables available and import batches concurrently to the database .","The row caching and dispatch component  manages the resource utilization during the load process. Its responsibilities include managing the memory utilization, transaction control, multithread synchronization and task flow control.  is an example of a manner in which cache tables may be assembled according to an aspect of the invention. As described above ordered rows are input into the row caching and dispatch function . Those rows correspond to a structure of the input data . According to an aspect of the invention, the rows can be organized in cache batches and represent tables or parts of tables that reflect the structured organization of the input data. For example, if the input data  is XML, the structure may be a dependency graph or node tree. The row caching and dispatch component can take the ordered rows and generate cache batches. For example, if the row data indicates that there is a parent grouping called customer and a child grouping called order, then the table batches could be generated as shown in the example depiction  of . There the customer batch  (CB), , can be a parent table for order batch table  (OB),  and a dependency exists between them. Likewise assume that order batch  (OB) is also a child to a parent customer batch table  (CB), . There is then a dependency between order batch table  (OB), , and customer batch table  (CB), . Another parent\/child dependency relationship may also exist between order batch table  (OB),  and customer batch table  (CB), . All tables may not be linked to all other tables as customer batch table  (CB),  is parent to child order batch table  (OB), , but not related to parent tables CB,  or CB, .","In an aspect of the invention, as soon as a parent table, such as CB,is available for transfer, it can be transferred to a database. However, a child table such as OB,  cannot be transferred until after it's parent CB,  has been transferred to the database. Thus, in , the transfer priority is parent and then child. Thus, CB and CB are transferred before OB and OB. Note that OB cannot be transferred until both CB and CB are transferred because of the OB child dependency on CB and CB.","In another aspect of the invention, if both CB and CB were roughly simultaneously available, then CB may be transferred first because it has two child dependencies; OB and OB as opposed to the only one child dependency that CB represents. The concept in this priority is that if transfers could be performed simultaneously, then transfers could be prioritized to provide the maximum number of child tables to be transferred. For example, by transferring CB out to a database in preference to CB, then two tables, OB and OB are potentially available for transfer. In the example of , OB is actually ready to be transferred.","In a system that provides multiple transfer simultaneously, CB, CB, and CB# could be transferred simultaneously, thus allowing the transfer of all of the child tables OB, OB, and OB shortly thereafter. However, if a question arose as to which parent table to discharge to a database next where resources allowed only one parent file to be transferred, then the table with the highest number of total dependencies would be chosen. These availability principles are used as aspects of the implementation for the row and caching and dispatch component  of the present invention.","In one embodiment, a user can specify control the operation of the bulk loader invention and regulate how much memory is used during bulk loading operations by setting a client buffer size property. This property is expressed in number of rows and is used as a guideline since there is no way to make sure that the bulk load will be able to accomplish the number of rows defined. For example, assume two tables need to loaded which have a relationship between them, such that a row for table A must be inserted before a row in table B. If the row order in the input data, for example XML input data, happens to be first row B and then row A, it is preferable for an XML bulk load to cache row B, insert row A and then insert row B. In this simple case if the user specifies a client buffer size to be equal to 1, meaning cache just one row at a time, a deadlock would occur. Thus, it is preferable that a user select enough cache to allow for a meaningful batch size.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4","b":["210","402","420","430","205","210","401","405","420","405","430","420","430","420"],"i":["a, ","b, "]},"In an aspect of the invention, based on the total count of rows stored in the waiting pool  and ready queue , the component performing the row generation tasks  may be blocked or suspended, while another thread is processing the batch tables in the ready queue . This is the mechanism used to keep the memory utilization around user defined limits if necessary.","As previously described, when rows forming a batch are in the ready queue , the batch is made available for import to the database . This is performed by informing the database manipulation  component via link  that a ready cache is available. The database manipulation  component can interface with available processors to allow a software thread to transport the ready cached table to the database. Eventually, the row is inserted into the destination table and it can be marked as processed. When processed, the database manipulation feedback  informs the move child rows function  to move child rows from the waiting pool  to the ready queue  if the child to be moved has no parent table in the ready queue . That is, when a batch table is transferred to the database, all its children are updated and those child cached tables that have all parent cached tables or rows marked as processed will be removed from the waiting pool  and pushed  to the ready queue .","The database manipulation component  is responsible for performing database commands. The bulk data load process can be simple as loading data into a single database table, or more complex as loading data into multiple tables with many dependencies among them. The database manipulation component  receives a row and can determine the database command to create. In one embodiment, the database command is an object that implements IDbCommand interface, defined below in C# language. The IDbCommand interface, part of a Microsoft .Net\u00ae Framework 1.0, is included as well.",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface IDbCommand : IDisposable"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IDbConnection Connection {get; set;}"]},{"entry":[{},"IDbTransaction Transaction {get; set;}"]},{"entry":[{},"string CommandText {get; set;}"]},{"entry":[{},"int CommandTimeout {get; set;}"]},{"entry":[{},"CommandType CommandType {get; set;}"]},{"entry":[{},"IDataParameterCollection Parameters {get;}"]},{"entry":[{},"void Prepare( );"]},{"entry":[{},"UpdateRowSource UpdatedRowSource {get;set;}"]},{"entry":[{},"void Cancel( );"]},{"entry":[{},"IDbDataParameter CreateParameter( );"]},{"entry":[{},"int ExecuteNonQuery( );"]},{"entry":[{},"IDataReader ExecuteReader( );"]},{"entry":[{},"IDataReader ExecuteReader(CommandBehavior behavior);"]},{"entry":[{},"object ExecuteScalar( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"internal interface IDbCommand2 : IDbCommand"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void PrepareCommit( );"]},{"entry":[{},"void PrepareRollback( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Referring to , in one embodiment, the database manipulation function  may function to transfer an XML batch of rows or table from the ready queue  to a SQL database. Interface link  can make available a row or table batch and ask for a database command via the DBCommandFactory  in order to transfer the ready queue batch to the database . The DBCommandFactory  may create a new database command or use an already existing instance of a command based on the bulk data load request settings defined by the user. The request settings are all the public properties exposed by the bulk data load class as well as the SQL connection and XML data. For instance, the public property UpdateOnExisting equals true, activates the update\/insert (upsert) behavior, so that when the DBCommandFactory needs to create a database command, it will return the object that knows how to implement the upsert behavior.","DBCommandFactory  is the element that allows an extension of the bulk data load features that relate exclusively to the database manipulation without affecting other components because it encapsulates the logic of deciding which database command to use for each individual table. After determining the appropriate database command to use, DBCommandFactory  returns an object that implements the IDBCommand  or IDBCommand interfaces. As indicated before, feedback link  can provide information as to the status of the transferred batch so that child rows can be moved  from the waiting pool  to the ready queue  if appropriate.","In an aspect of the invention, the ready queue  implements a priority queue based on the number of children cached. In other words, the greater number of children depending on a cached parent table, the higher the priority should be given to the patent cached table. For example, given a cached parent table or row set has 5 children and another cached parent table or row set has 15 children, the ready queue  should first transfer the cache with 15 children and then the cache with 5 children. The reason underlying this behavior is to maximize the number of cached items in the waiting pool  that can be transferred to the ready queue  so as to take advantage of the existence of multiple processors and multiple threads for transfer to the database .","In an aspect of the invention, as soon as the rows or tables are batched in the row\/table cache  are produced, they are pushed to the corresponding storage container; the waiting pool  or ready queue . After the row\/table batch is produced, a class still keeps a reference to it to be used in the event that children rows might come later on. Because the number of dependent rows can change after a row is pushed to the ready queue , the priority queue implementation should preferably support an efficient priority change operation. Specific priority queue implementations are well known in the art.","In one embodiment of the invention, the row caching and dispatch component  raises internal events every time N rows have being processed to some level. There can be an internal component that subscribes to these events and in response to them, pushes transaction management tasks to the ready queue. These are the tasks include preparing a commit task to push out a batch to an available processor via the database manipulation component  which generates appropriate database commands. Another task includes generating a single commit transaction task. This single task is a special kind of task that requires all threads to be blocked inside the row caching and dispatch component  to avoid both deadlocks accessing common data structures and racing conditions.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 5","FIGS. 2 and 4","FIG. 5"],"b":["500","505","205","510","520","515"]},"Following path B, assuming that a table was assembled (step ) and moved to the ready queue (step ), the process  notifies one or more processors to transfer the batch tables out of the ready queue (step ). The computer environment preferably is a multiprocessor environment where more than one processor may be available to respond to the notification to extract a batch table from a ready queue. However, a single processor environment may work as well. Once an available processor responds to the notification that a batch table is available, the responding processor is permitted to transfer the batch table out of the ready queue and into a target database (step ).","As mention above, both paths A and B of  are occurring nearly simultaneously as the process  represents a type of pipeline to transfer cached batch tables out to a database. In path B, a cached set of rows may make up a child table (step ). Cached child rows or tables are moved into a waiting pool (step ). There, child rows or tables wait until their respective parent tables are taken out of the ready queue as described with respect to steps  and . Thus, a functional test of the waiting pool tables is conducted (step ) to determine if parents of the child batches in the waiting pool are still in the ready queue. If there are parent tables in the ready queue whose children are in the waiting pool, then those children tables remain in the waiting pool to be tested again. However, if there are no parents of the children in the ready queue, then the child table is moved to the ready queue (step ). Once a child table is entered into the ready queue, A ready queue priority is recalculated (step ) as discussed above to allow a more efficient construction of data into a target database. Once the ready queue priority is established, the data that is entered into the ready queue is immediately available for notification to an available processor (step ) and transfer out to the database (step ).","In one embodiment, the test of step  is implemented as a test of a control register as indicated in .  is a portion  of the  process . The steps shown in  are those of the path B of  with the addition of a feedback step. Referring to , upon entering a child row or table into the waiting pool, a dependency counter on the child row or table may be generated such that the dependency counter indicates the total number of parent tables that the specific child depends upon. For example, if a child has three parent tables, then the dependency counter would be set to three.","Referring to , once a parent row or table is moved into the ready queue (step ), The ready queue priority is recalculated (step ) and processors in the hosting system are notified that a cache of a parent row or table is available for transfer out to the target database (step ). An available processor may then transfer the available parent row or table to the target database using appropriate database commands and communications paths (step ). In one embodiment, the process continues by decrementing the dependency counter associated with a child table in the waiting pool for the specific parent that has just been removed from the ready queue. In this way, as parent tables are transferred out of the ready queue, the respective child tables indicate fewer and fewer parent dependencies in the dependency counter. Eventually, if no more parent tables are present in the ready queue, the dependency counter is zero. Under those conditions, the test of step  in  is a check of the dependency counter for a child file. If the dependency counter for a specific table is tested and equals zero, then there are no parent dependencies in the ready queue and the child table can be moved to the read queue as shown and described in  (step ). Other implementation of the test (step ) of  are possible and are in accord with an aspect of the invention.","Exemplary Computing Device",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 7"},"Although not required, embodiments of the invention can also be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, appliances, lights, environmental control elements, minicomputers, mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network\/bus or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 7","b":["700","700","700","700"]},"With reference to , an exemplary system for implementing an embodiment of the invention includes a general purpose computing device in the form of a computer system . Components of computer system  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer system  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, Random Access Memory (RAM), Read Only Memory (ROM), Electrically Erasable Programmable Read Only Memory (EEPROM), flash memory or other memory technology, Compact Disk Read Only Memory (CDROM), compact disc-rewritable (CDRW), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer system , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer system  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM, CDRW, DVD, or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer system . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer system  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory (not shown). In addition to monitor , computer systems may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer system  may operate in a networked or distributed environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer system , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer system  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer system  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer system , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web-enabled interface for applications and computing devices, making computing activities increasingly Web browser or network-oriented.","For example, MICROSOFT\u00ae's .NET\u2122 platform, available from Microsoft Corporation, includes servers, building-block services, such as Web-based data storage, and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device, one or more portions of an embodiment of the invention may also be implemented via an operating system, application programming interface (API) or a \u201cmiddle man\u201d object between any of a coprocessor, a display device and a requesting object, such that operation may be performed by, supported in or accessed via all of .NET\u2122's languages and services, and in other distributed computing frameworks as well.","As mentioned above, while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to implement a bulk transfer mechanism of information to a database. Thus, the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages, names and examples are chosen herein as representative of various choices, these languages, names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same, similar or equivalent systems and methods achieved by embodiments of the invention.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the signal processing services of an embodiment of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While aspects of the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Therefore, the claimed invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of exemplary embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating embodiments of the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
