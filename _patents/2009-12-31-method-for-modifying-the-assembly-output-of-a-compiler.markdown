---
title: Method for modifying the assembly output of a compiler
abstract: The present invention performs manipulations on the assembly file level. As a compiler outputs an assembly file, the assembly file may be inspected and modified before it is sent to the assembler. One or more of the following modifications may be made to the assembly file: rewrite certain symbols, scramble program symbols, reorganize declarations of global variables so that their layout and default values are known prior to linking, and identify initializer and de-initializer functions in order to make them callable through central initialization and de-initialization functions, respectively.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08930928&OS=08930928&RS=08930928
owner: Opera Software ASA
number: 08930928
owner_city: Oslo
owner_country: NO
publication_date: 20091231
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This non-provisional application claims priority under 35 U.S.C. \u00a7119(e) on U.S. Provisional Application No. 61\/141,881, filed Dec. 31, 2008, the entire contents of which are incorporated herein by reference into the present application.","The present invention is directed to a tool for making specialized changes to the assembly output of the compiler, before running the assembler, to achieve a desired behavior that is not otherwise easily achievable.","A software library generally consists of a collection of subroutines or classes, and contains code and data that provide services to independent application programs. This allows for the data and code to be shared and updated in a modular fashion. A library may be statically linked to a target application, i.e., copied into the application program at compile time. Alternatively, a library may be dynamically linked, meaning that its functions and subroutines is loaded into the application program at the time of loading or executing the application in the underlying system.","The underlying operating system generally contains the necessary linking code (sometimes called a \u201cloader\u201d) to link in the library at the appropriate time. In addition to loading the library from disk to the application program, the loader is also designed to perform memory management functions for adding relevant data from the library into memory. Furthermore, the library generally must rely upon system software (e.g., standard system libraries) to initialize its global variables and global objects during the standard startup procedure of the relevant application, and de-initialize them during the standard shutdown procedure of the application (this is a process generally known as \u201cbootstrapping\u201d the linked application).","As such, existing libraries cannot govern the initialization and de-initialization of their own global variables and objects. Thus, even if the controlling application program is done using the library's global variables\/objects, the library cannot effectively release its global variables\/objects even when they are no longer needed. It would be advantageous to allow the library to effectively control initialization and de-initialization of its own global variables\/objects.","For complete applications which are not delivered as a library or libraries, a similar problem exists. I.e., existing applications cannot control the initialization and de-initialization of their own global variables and objects at will; instead the operating system which loads the applications is also responsible for controlling such initialization and de-initialization of the global variables\/objects.","Another problem with existing libraries and applications is that various proprietary information of the software developer (e.g., names of functions, variables, and object classes) is open to inspection by others (e.g., customers). It would be advantageous to scramble various symbols in the library code in an effort to protect such proprietary information. Furthermore, in a library or application, a conflict may arise when a variable or object of the same name is used by another library or application loaded in the same system. Thus, it would be advantageous to rename certain symbols in order to avoid such conflicts in the underlying system.","The present invention relates to a method, system, and computer program for modifying software at the assembly file level. Particularly, an assembly file may be modified by either rewriting one or more symbols in the code; scrambling one or more symbols in the code related to the name of a function, variable, or object class; and\/or removing the declaration of one or more global variables for insertion into another assembly file.","According to an exemplary embodiment, a symbol representing a memory management function in the relevant assembly syntax is rewritten, such that the rewritten symbol represents a memory management function to be specifically implemented by the library. This allows the library to use its own management function, e.g., instead of a memory management function provided by the operating system or the application or a support library.","According to another exemplary embodiment, a symbol is scrambled using a cryptographic hash, in an effort to hide the meaning of the symbol. A log file may be kept to correlate the scrambled symbol to its original unscrambled form.","According to another exemplary embodiment, the declaration of one or more global variables may be moved from the assembly file, and other assembly files of the same library, to be inserted in a global data assembly file. This allows the declarations of global variables to be co-located in a single assembly file and be assembled in such a way that the library can control their initialization.","According to another exemplary embodiment, initializer functions may be identified from the assembly file, and other assembly files of the same library, to be made callable through a single central initialization function which is automatically created. This allows the initialization of variables and objects to be controlled by the library. Furthermore, if the compiler arranges for de-initializer functions to be called explicitly, the de-initializer functions may also be identified from the assembly file, and other assembly files of the same library, and be made callable through a single central de-initialization function which is automatically created. This would allow the de-initialization of variables and objects to also be controlled by the library.","Further scope of applicability of the present invention will become apparent from the detailed description given hereinafter. However, it should be understood that the detailed description and specific examples, while indicating preferred embodiments of the invention, are given by way of illustration only, since various changes and modifications within the spirit and scope of the invention will become apparent to those skilled in the art from this detailed description.","The drawings will be described in detail in the course of the detailed description of the invention.","The following detailed description of the invention refers to the accompanying drawings. The same reference numbers in different drawings identify the same or similar elements. Also, the following detailed description does not limit the invention. Instead, the scope of the invention is defined by the appended claims and equivalents thereof.","Exemplary embodiments of the present invention are directed to an \u201cASMFIX\u201d tool which may be implemented as a computer executable program to modify an assembly file according to one or more of the procedures described in detail below.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","100"]},"In , computer system  has various functional components including a central processor unit (CPU) , memory , communication port(s) , a video interface , and a network interface . These components may be in communication with each other by way of a system bus .","The memory , which may include ROM, RAM, flash memory, hard drives, or any other combination of fixed and removable memory, stores the various software components of the system. The software components in the memory  may include a basic input\/output system (BIOS) , an operating system , various computer programs  including applications and device drivers, various types of data , and other executable files or instructions such as macros and scripts .","The communication ports  may be connected to one or more local devices  such as user input devices, a printer, a media player, external memory devices, and special purpose devices such as e.g. a global positioning system receiver (GPS). Communication ports , which may also be referred to as input\/output ports (I\/O), may be any combination of such ports as USB, PS\/2, RS-232, infra red (IR), Bluetooth, printer ports, or any other standardized or dedicated communication interface for local devices .","The video interface device  is connected to a display unit . The display unit  might be an integrated display. For instance, if the computer system  is implemented as a PDA, mobile telephone, or other small portable devices, the display will generally be an integrated display such as an LCD display. However, the display unit  does not have to be integrated with the other elements of the computer system . Instead, the display unit  could be implemented as a separate device, e.g., a standalone monitor.","The network interface device  provides the computer system  with the ability to connect to a network in order to communicate with a remote device . The communication network, which in  is only illustrated as the line connecting the network interface  with the remote device , may be, e.g., a local area network or the Internet. The remote device  may in principle be any computing device or system with similar communications capabilities as the system , such as a server or some other unit providing a networked service.","It will be understood that the computer system  illustrated in  is not limited to any particular configuration or embodiment regarding its size, resources, or physical implementation of components. For example, more than one of the functional components illustrated in  may be combined into a single integrated unit of the system . Also, a single functional component of  may be distributed over several physical units. Other units or capabilities may of course also be present. Furthermore, while it is contemplated that the system  may be implemented using general purpose computers or servers, various aspects of the present invention could be implemented using a system  with more limited processing capabilities, such as a notebook or \u201cnetbook\u201d computer, a personal digital assistant (PDA), a cellphone or smartphone, or a set-top box system or other home-entertainment unit.","According to an exemplary embodiment, the computer system  may be configured as a software development environment. As such, referring again to , the stored computer programs  may include a combination of one or more software development tools for implementing such an environment. Such software development tools may include software component(s) which is necessary to compile the source code into one or more assembly files, and assemble the resultant assembly file(s) into object files (e.g., which constitute a library), which can be linked to generate usable machine code.","Also, the software development tools in the computer programs  of system  may optionally include software component(s) necessary for a user to write or author the source code to be compiled. The software development tool(s) may be specifically designed for a particular programming language. According to an exemplary embodiment the programming language may be object-based (e.g., C++). Furthermore, the software development tools of system  may be designed for a visual programming language (e.g., Visual C++), a diagrammatic (text-based) programming language, or both.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 2","FIG. 2"],"b":["100","200","210","220","230","240","250","200"]},"In an exemplary embodiment, the software development environment  may be used to produce a software library consisting of object files, e.g., to be sent to a customer using another computing platform. Alternatively, the software development environment may be used to produce an application to be delivered to the customer. The source code programming interface  may provide an interface for software developers to write the source code for such a library or application. The resultant source code, e.g., in C++ or another object-based programming language, is transferred to the compiler . The compiler  may be instructed or otherwise configured to create assembly files as output. As is known in the relevant art, the compiler  operates according to a convention or standard, often referred to as an \u201capplication binary interface\u201d (ABI), in which certain symbols have special meaning, i.e., are defined for a specific purpose (such symbols are sometimes referred hereinbelow as \u201cspecial symbols\u201d). For instance, as will be described in further detail below, some of the special symbols defined in the application binary interface of the compiler  may relate to memory management functions to be implemented by the system software (e.g., the operating system or standard system libraries) of the platform on which the developed library or application is to run.","Reference has been made above to the computing platform (e.g., customer platform) where the developed library or application is to run. It is contemplated that such a platform may constitute a different computer system  than the software development environment  which is used for programming, compiling, and modifying the assembly files. However, it should be noted that the computer system  which is intended to run the resultant library\/application may have more limited processing capabilities than the system  which is used for developing the library\/application. Furthermore, it is also possible for the same computer system  acting as the software development environment  of  to be used to as the platform which runs the resultant library or application if desired. Also, as noted earlier, it is possible for some of the components illustrated in  to be implemented on separate computer systems , e.g., the linker\/loader  may be located on the customer platform separate from the system  on which the compiler , ASMFIX tool , and assembler  are implemented.","Referring again to , various aspects of the present invention, which will be described in more detail below, may be implemented by the ASMFIX tool . In particular, the ASMFIX tool  may be designed to automatically inspect and modify each assembly file in accordance with the aforesaid principles. A benefit of performing such modifications at the assembly file level is that there are few restrictions imposed on what can be changed at this level, and the build environment does not have to make special provisions since the changes can be made transparent to the linking process. This is important since it may not be desirable to change anything in the build\/link environment to use a specific software library or application. When an object file is assembled from an assembly files modified by the ASMFIX tool , it may look, for all practical purposes, just like a regular object file, and also link normally.","Referring again to , an assembly file modified in accordance with the ASMFIX tool  may be sent to an assembler  to be assembled into a corresponding object file. If the object files of a particular software library are output from the assembler , they may be linked to another application program by the linker\/loader . In the case of generating a dynamically linked library, the majority of functionality of the linker\/loader  may be performed by the underlying operating system in which the application program is to be loaded and run.","However, the object file(s) outputted by the assembler  may correspond to an application program, e.g., to be delivered to a customer. As such, linking may be performed by a linker component  at the developer's site, thereby generating the machine code to be delivered to the customer and loaded by the operating system of the underlying platform.","It should be noted that each of the functional components illustrated in  may be implemented in any combination of software, firmware, and\/or hardware, as will be readily apparent to persons of ordinary skill in the art in view of this detailed description.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 3","FIG. 3","FIG. 3","FIG. 3"],"b":"230"},"As shown in , an assembly file, which is generated by the compiler , is obtained and applied to the ASMFIX tool  (operation S). The ASMFIX tool may proceed to modify the assembly file according to one or more of the following operations:\n\n","In order to implement various modifications and operations as described above, the ASMFIX tool  may be tailored toward the relevant assembly language syntax, the compiler , and CPU-type for the software development environment  of the library. For instance, the ASMFIX tool  may need a detailed knowledge of the assembly syntax in order to identify and rewrite specific symbols relating to memory management functions according to operation S. Further, to implement some of the other types of modifications described heretofore, the ASMFIX tool  might be programmed to know specifically how the compiler  organizes the assembly file contents into sections, how to identify the initializer and de-initializer functions, global variables, symbols to be scrambled, etc. It will be readily apparent to persons of ordinary skill in the art how to design and implement such an ASMFIX tool , in light of the following description of the aforementioned modifications and operations.","Rewriting Special Symbols (Operation S):",{"@attributes":{"id":"p-0046","num":"0050"},"figref":["FIG. 4","FIG. 3"],"b":"320"},"Depending on the particular assembly syntax in use, certain special symbols may be defined as declarations of, and calls to, certain memory management functions (e.g., global operators) in the underlying operating system which will link\/load the particular library\/application. According to an exemplary embodiment, at least some of these special symbols can be rewritten into symbols which do not have any special meaning to the compiler , system libraries or other libraries, but rather, are unique to the particular library\/application and represent memory management functions that are specific to the particular library\/application.","In , operation S shows that such symbol rewriting may be controlled through a mapping between special symbols relating to memory management functions, and their replacement symbol names which are unique or specific to the particular library\/application. According to an exemplary embodiment, this mapping may be designated through a configuration file which lists how the symbol rewriting should be performed. For instance, the programmer of a software library\/application may create the configuration file to be input to the ASMFIX tool  along with the assembly files generated by the compiler  for implementing the library\/application.","Specifically, the symbol rewriting can be accomplished via a simple mapping, e.g., in the aforementioned configuration file. For instance, in the case where symbol rewriting is to be performed for a particular software library, a configuration file may include the following statement:\n\n_nwj Library_global_new\n\nThus, the above mapping could be used to rewrite the special symbol (\u2018_nwj\u2019) into a symbol (\u2018Library_global_new\u2019) that is specific to the particular software library (designated as \u201cLibrary\u201d for purposes of this example). In this particular example, the symbol \u2018_nwj\u2019 is assumed to correspond to the global operator \u2018new,\u2019 according to the naming convention for operator \u2018new\u2019 as used by the relevant compiler .\n","It should be noted that the use of a configuration file to map the names of special symbols to their rewritten counterparts, in connection with S, is but one way in which the ASMFIX tool  can be controlled to determine the rewritten symbol-names. The ASMFIX tool  could be controlled in other ways to rewrite special symbols without departing from the spirit or scope of the invention.","Referring again to , in operation S, the code of the input assembly file is analyzed to identify the special symbol(s) to be rewritten. According to operation S, the code in the assembly file may be modified by replacing each identified special symbol with its mapped library-specific (or application-specific) symbol. To ensure that operation S is correctly performed, the ASMFIX tool  may be designed to parse and check all syntax constructs in the assembly file (as well as any other assembly files for implementing the library\/application) which could possibly contain the identified symbol.","Using the Library example above, the operations S and S may be implemented as follows. Assume that a source file in Library is written using the C++ programming language, and contains the following code:",{"@attributes":{"id":"p-0053","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Implement Library's own \u2032new\u2032 operator"]},{"entry":[{},"void* operator new(size_t size) { ...Body of operator \u2018new\u2019... }"]},{"entry":[{},"\/\/ A function allocating memory:"]},{"entry":[{},"void* alloc10(void)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return new char[10];"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"When this C++ file is compiled, the resulting assembly file could look something like this (only important parts included):",{"@attributes":{"id":"p-0055","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"_nwj:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"...Body of operator \u2018new\u2019..."]},{"entry":[{},"ret"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"alloc10:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"move #10, r0"]},{"entry":[{},"jump _nwj"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"However, when the ASMFIX tool  identifies and rewrites the \u2018_nwj\u2019 symbol according to operations S and S, the relevant portion of the modified assembly file may look like:",{"@attributes":{"id":"p-0057","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Library_global_new:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"...Body of operator \u2018new\u2019..."]},{"entry":[{},"ret"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"alloc10:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"move #10, r0"]},{"entry":[{},"jump Library_global_new"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"According to this example, after the modified assembly file is assembled into an object file, the resultant object file does not contain any declaration of, or calls to, the allocator function of the operating system or standard libraries, where the default \u2018_nwj\u2019 symbol is normally declared.","Rewriting Symbols with Conflicts or Incompatibilities (Operation S):","In , operation S shows that the ASMFIX tool  may be used to identify and rewrite symbols in the assembly file which implements part of a particular library or application, in order to avoid symbol-name clashes with other software installed on the underlying platform, and\/or to prevent the library\/application from calling incompatible functions.  is a flowchart illustrating an exemplary embodiment for implementing operation S of .","According to operation S of , the ASMFIX tool  identifies symbols in the assembly file to be rewritten, e.g., those symbols which potentially have the same name as symbols in other software and\/or those symbols which might be used to call functions (e.g., in the system software) which are incompatible with the particular library or application being developed.","The actual way of determining which symbols in a particular library\/application might conflict with other symbol names, or result in calls to incompatible functions, is outside the scope of this detailed description. Suffice it to say that such determination may be made in any manner as would be contemplated by persons of ordinary skill in the art.","According to operation S of , the ASMFIX tool  may be controlled to rewrite the symbols, which are identified in S, through the use of a mapping between the identified symbols and the replacement symbol names. For instance, similar to operation S of  described above, such mapping may be specified by a configuration file which is input to the ASMFIX tool  along with the assembly files for implementing the library\/application. However, other ways of controlling the ASMFIX tool  to rename the identified symbols may be used as well.","According to operation S of , the ASMFIX tool  modifies the code of the assembly file by replacing all instances of the identified symbols with their renamed counterparts.","Symbol Scrambling (Operation S):","Referring again to , the ASMFIX tool  may be configured to scramble or modify one or more symbols within an input assembly file to hide their meaning, as illustrated in operation S. According to an exemplary embodiment, such symbol scrambling may be performed based on a cryptographic hash.",{"@attributes":{"id":"p-0065","num":"0069"},"figref":["FIG. 6","FIG. 3"],"b":"340"},"According to operation S of , a selection is made as to which symbols are to be scrambled. For instance, in order to be able to call a specific library's functions, it would be necessary for some symbols to be exempted from scrambling in the assembly file. Particularly, some symbols in a specific library may be part of that library's application programming interface (API) and thus needs to be made visible to the controlling application to which the specific library is linked. Also, there may be symbols in a particular library or application which are the names of resources in system libraries, other supporting libraries, or the controlling application with which the particular library\/application needs to interact. If such symbols were scrambled, this might prevent the particular library or application from referring to functionality it needs. As an example, when a symbol which is the name of standard functionality like the C\/C++\u201cstrlen\u201d function, which is typically implemented in a system library, this symbol should be excluded from scrambling.","The determination of which symbols should and should not be scrambled may be accomplished through the use of a separate configuration file. In fact, if the symbol rewriting (S) of  is also performed, it is contemplated that the same configuration file could be used both for mapping symbols to rewritten symbols (operation S), and for identifying which symbols should be selected for (or exempt from) scrambling (operation S).","According to operation S of , the selected symbols are cryptographically scrambled. This may accomplished by any cryptographic process as contemplated by persons of ordinary skill in the art, e.g., based on a cryptographic hash. If a cryptographic hash is used, e.g., each scrambled symbol might be the result of computing the hash value of the unscrambled symbol name and some secret information that is only known to those who perform the scrambling. To perform symbol scrambling correctly, the ASMFIX tool  may be need to parse and check every syntax construct in the assembly file (and the other assembly files in the same library) which could possibly contain the selected symbols, to ensure that all instances of such symbols in the assembly file code is replaced with their scrambled counterparts.","According to operation S in , a log file may be kept recording each scrambled symbol in the modified assembly file. This could help avoid name-clashes between scrambled symbols, or between a scrambled and unscrambled symbol. Also, the log file may also be used to map the scrambled symbols to their original unscrambled counterparts. As such, the log file may be used to translate each scrambled symbol into its original unscrambled form. This makes it possible to decipher call-stacks, etc., that contain scrambled symbols.","For instance, each time a symbol is scrambled according to S, the log file may be checked to determine whether the scrambling results in a name-collision or conflict with another symbol. In particular, it is possible that two different symbols could be scrambled in such a manner that the respective scrambled symbols are the same (this might be referred to as a \u201chash collision\u201d if a cryptographic hash is used). An analysis of the log file could detect such a name conflict between scrambled symbols (e.g., hash collision) by checking all the scrambled symbols which are recorded in the log file for different symbols, in an effort to find duplicates. However, when a strong cryptographic hash function is used, such hash collisions become very unlikely. As such, the ASMFIX tool  might simply be programmed to output an error message in the unlikely event that a check of the log file finds a hash conflict, to prevent incorrect operation.","It should be noted that symbols, which were previously rewritten according to S of , can additionally be scrambled according to the process described above. For instance, in the example described above in connection with , the rewritten symbol \u2018Library_global_new,\u2019 as well as the symbol \u2018alloc10,\u2019 may be scrambled in order to hide its meaning according to the process of .","Reorganize Declarations of Global Variables (S):","Referring again to , operation S shows that the ASMFIX tool  may be used for reorganizing the declaration of global variables in a particular library or application. Specifically, this operation S can be performed in such a manner that the exact layout and default values of each declared global variable in the library\/application is known prior to linking. As such, the ASMFIX tool  may generate a special \u201cglobal data\u201d assembly file for the library\/application which holds all the declared global variables of the library\/application in a layout that the linker  will not change.","When this modification is performed on the assembly files for implementing a software library, this has the benefit of allowing the software library to be called on (e.g., by an application program to which it is linked) to control its global variable initialization process (i.e., initialize and re-initialize the global variables when needed) without relying on or being forced by the standard startup procedure for the linked application program. In a similar vein, if such modification were to be performed on assembly files for implementing an application, the application can be programmed to control the initialization process for its global variables.  is a flowchart illustrating an exemplary process for reorganizing the global variables of a library\/application as described above.","Typically, global variables can be identified by detecting the \u2018data\u2019 and \u2018bss\u2019 segments in an assembly file. The term \u2018bss\u2019 is a label for memory which is expected to be initialized to all zero bytes as part of the initialization process, while the term \u2018data\u2019 is a label for memory that is expected to be initialized to a designated (possibly non-zero) value during initialization. Accordingly, variables which are declared in the \u2018data\u2019 section of an assembly file are typically initialized to some predefined values, while variables declared in a \u2018bss\u2019 segment are typically initialized to zero. Take for example an assembly file containing the following \u2018bss\u2019 and \u2018data\u2019 sections:",{"@attributes":{"id":"p-0075","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"section bss"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"scratch_data:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"size 1024"]},{"entry":[{},"section data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"default_answer:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"dcl 42"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the example assembly file above, the \u2018bss\u2019 segment holds read-write data which needs to be initialized to zero, while the \u2018data\u2019 segment holds read-write data that needs to be initialized to a given value (possibly non-zero). The symbols of the above assembly file are identifiable as having a \u2018:\u2019 (colon) after the symbol-name. Furthermore, the \u2018size\u2019 directive shown above reserves the specified number of bytes in the corresponding object file. Also, the \u2018dcl\u2019 directive means \u201cdeclare long\u201d which, in this example, is a 32-bit word (4 bytes). The value of the 32-bit word is listed after the \u2018dcl\u2019 directive, such value being placed into the object file at the given position.","When assembly files, such as the above, are assembled into object files and sent to a linker program, the linker will arrange all \u2018bss\u2019 symbols together somewhere in memory, and all \u2018data\u2019 symbols together somewhere else in memory. However, it is impossible to know beforehand how the \u2018bss\u2019 and \u2018data\u2019 sections of various object files, e.g., of different libraries, will be arranged by the linker. Accordingly, to ensure that a particular library's data\/bss symbols are placed together in a particular order, the linker has to be prevented from deciding the layout of the library's global variables.","Thus, according to operations S and S of , the ASMFIX tool  detects the \u2018data\u2019 and \u2018bss\u2019 sections from the regular assembly files of a particular library, removes the declaration of each variable in the detected \u2018data\u2019 and \u2018bss\u2019 sections, and inserts the declarations of the variables into a special global data assembly file. Particularly, these variable declarations may be placed in a single segment declaration ('data' or \u2018bss\u2019) of the global data assembly file. By doing this, when the library object files are sent to a linker (e.g., the linker\/loader  of ), the linker will not be allowed to rearrange the declaration of these variables.","In moving the declaration of variables according to S, the ASMFIX tool  should be designed to make such variables accessible from their original assembly files (they may have to be explicitly imported and exported, depending on the assembly syntax).","Furthermore, it would be advantageous to design the ASMFIX tool  so that each variable of the library, which had local scope in the assembly file where it was originally declared, does not interfere with symbols elsewhere (i.e., outside the assembly file where it was originally declared). Thus, according to operation S of , each variable whose scope is local to the assembly file in which it was originally declared may be prefixed with a \u201cnamespace identifier\u201d string which is unique to that assembly file. Of course, the names of such variables may be modified in other ways to ensure that they do not interfere with symbols outside their original scope, as will be contemplated by those of ordinary skill in the art.","According to an exemplary embodiment, the declarations of both variables to be initialized to zero (\u2018bss\u2019 symbols) and variables to be initialized to non-zero values (\u2018data\u2019 symbols) may be moved into a single \u2018bss\u2019 segment of the global data assembly file. Accordingly, the non-zero initialization values from the detected \u2018data\u2019 sections of the original assembly files will need to be inserted in a section of the global data assembly file that is separate from the variable declarations, according to operation S of . By having the initial values of the global variables placed outside the global variables themselves, they will remain unchanged and can be used for re-initializing the global variables over and over. The initial values may be placed in read-only portion of the memory, if the system allows.","For instance, in operation S, the non-zero initialization values may be copied from the various \u2018data\u2019 sections of the original assembly files and copied into a \u2018text\u2019 section of the global data assembly file. As a specific example of this will be described using the following \u2018bss\u2019 and \u2018data\u2019 segments of an assembly file:",{"@attributes":{"id":"p-0083","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"section bss"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"scratch_data:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"size 1024"]},{"entry":[{},"section data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"default_answer:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"dcl 42"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Assume that the ASMFIX tool  receives the above assembly file as part of the same library or application as other assembly files declaring \u2018other_info\u2019 as a 16-byte variable\/object, and \u2018other_pointer\u2019 as a pointer that is initialized to point to the \u2018other info\u2019 variable. If the ASMFIX tool  were to reorganize the declaration of global variables of such assembly files according to , this could result in the following global data assembly file:",{"@attributes":{"id":"p-0085","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"section bss"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"begin_special_bss_section:"]},{"entry":[{},"scratch_buffer:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"size 1024"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"other_info:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"size 16"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end_special_bss_section:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"section bss"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"begin_special_data_area:"]},{"entry":[{},"default_answer:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"size 4\u2003; To hold the \u2018dcl 42\u2019 declaration"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"other_pointer:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"size 4\u2003; To hold the \u2018dcl other_info\u2019"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"declaration"]},{"entry":[{},"end_special_data_area:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"section text"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"begin_special_data_init_values:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"dcl 42"]},{"entry":[{},"dcl other_info"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end_special_data_init_values:"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"It should be noted that the \u2018text\u2019 section of an assembly file, as illustrated above, is a section where the data may be read-only and thus cannot be changed.","In the example above, the global variables have been placed in the \u2018bss\u2019 segment of the global data assembly file, according to operation S, where they are designated for initialization either to zero (the first \u2018bss\u2019 section) or have initial values copied from the template in the \u2018text\u2019 segment (for the second \u2018bss\u2019 section). The template in the \u2018text\u2019 segment is where the initial values of the (possibly non-zero) global variables have been inserted, according to operation S. This would allow the library or application to be programmed to initialize the global variables by copying everything between \u2018begin_special_data init_values\u2019 and \u2018end_special_data_init_values\u2019 into \u2018begin_special_data_area,\u2019 and initializing everything between \u2018begin_special_bss_section and \u2018end_special_bss_section\u2019 to zero. However, it is important to keep the order of the variables and sizes of the variables consistent in the \u2018text\u2019 and \u2018bss\u2019 segments of the global data assembly file, or else variables could get the wrong values during global variable initialization.","Please note that the term \u201cvariable,\u201d as used heretofore and hereinafter, is intended to cover all types of identifiable data-storing structures, including objects.","Identify and Collect Initializer and De-Initializer Functions (Operation S):","As set forth in operation S of , the ASMFIX tool  may be configured to identify all initializer and\/or de-initializer functions from the assembly files of a particular library or application.","However, as mentioned above, the identification of de-initializer functions according to this operation should be made conditional on whether the compiler  has explicitly arranged for the de-initializer functions to be called explicitly (by producing an explicit list of the de-initializers to be called). In the case where de-initializers are not arranged by the compiler  to be called explicitly, the de-initializer functions are typical registered dynamically into a system facility during system initialization, in such a manner that the de-initializer functions are called upon termination of the relevant application. In the case of dynamic registration, the de-initializer functions do not need to be collected according to operation S of ; instead, the particular library or application may be adapted to implement the dynamic registration function locally (in such a manner that it does not conflict with the underlying system facility for dynamic registration). The local implementation of the dynamic registration functionality within the particular library\/application can call on the dynamically registered de-initializers at will, i.e., when the global variables and objects are no longer needed.",{"@attributes":{"id":"p-0091","num":"0095"},"figref":["FIG. 8","FIG. 3"],"b":"360"},"According to operation S of , the assembly files of a library may be analyzed to identify the initializer functions contained therein, and possibly the de-initializer functions contained therein (conditioned on whether the de-initializers are to be called explicitly). According to operation S, information as to how the identified initializer (and possibly de-initializer) functions may be extracted from the assembly files so that the system software (e.g., standard system libraries) will be unable to call these functions during standard startup\/shutdown procedures. The identified initializer functions may be called from a single central initialization function (entry point) that is generated by the ASMFIX tool  according to operation S. Furthermore, if applicable, the identified de-initializer functions may also be called from a single central de-initialization function (entry point) that is generated by the ASMFIX tool  according to operation S (since this operation is conditional, block S in  is illustrated by dotted lines).","In view of this modification, the ASMFIX tool  may arrange it so that the initializer (and possibly de-initializer) functions are not called during the operating system's standard application startup and shutdown procedures, respectively. Instead, the initializer functions can be called by the library at will through a single entry point, and if applicable, the de-initializer functions through another single entry point.","An example will now be described as to how initializer and de-initializer functions can be detected from an assembly file in accordance with operation S. In this example, an assembly file contains the following sections:",{"@attributes":{"id":"p-0095","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"section ctors"]},{"entry":[{},"dcl _static_init"]},{"entry":[{},"section dtors"]},{"entry":[{},"dcl _static_deinit"]},{"entry":[{},"section text"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"_static_init:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"...Initialize instructions..."]},{"entry":[{},"ret"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"_static_deinit:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"...De-initialize instructions..."]},{"entry":[{},"ret"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the assembly file of the above example, the sections \u2018ctors\u2019 and \u2018dtors\u2019 are special sections which are used to hold pointers to all \u201cconstructors\u201d and \u201cdestructors\u201d (names typically used in C++). In this example, the symbol \u2018_static_init\u2019 represents the name of one static initializer function, while \u2018_static_deinit\u2019 represents the name of one static de-initializer function. Such symbols are created as a result of a compiler (e.g., compiler  of ) deciding that initialization and de-initialization, respectively, are needed. Typically, the functions \u2018_static_init\u2019 and \u2018_static_deinit\u2019 would be implemented by such compiler locally in the file where they are needed (where the global variables\/objects requiring initialization or de-initialization are located).","In order to perform standard startup and shutdown procedures, respectively, the system software will typically analyze the \u2018ctors\u2019 and \u2018dtors\u2019 sections, and call the initializer and de-initializer functions listed therein, respectively, to perform initialization and possibly de-initialization.","Thus, information can be extracted by the ASMFIX tool  from such an assembly file in order to prevent the system software from attempting to call the initializer\/de-initializer functions during the standard startup\/shutdown procedures, in accordance with operation S. Specifically, the ASMFIX tool  can do this by removing the ctors' and \u2018dtors\u2019 sections from the assembly file. Specifically, in reference to the example given above, the ASMFIX tool  can rewrite the above sections of the assembly file as follows:",{"@attributes":{"id":"p-0099","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"section text"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"_static_init_namespace_id_1:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"...Initialize instructions..."]},{"entry":[{},"ret"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"_static_deinit_namespace_id_1:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"...De-initialize instructions..."]},{"entry":[{},"ret"]},{"entry":[{},"export _static_init_namespace_id_1"]},{"entry":[{},"export _static_deinit_namespace_id_1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"It should be noted that the \u2018ctors\u2019 and \u2018dtors\u2019 sections have been removed from the assembly file by the ASMFIX tool  in this example. Thus, the system software, e.g., standard system libraries, will no longer call the initializers and de-initializers; this is now the responsibility of the particular library or application of which the assembly file is a part. Furthermore, as shown in this example, the symbols for the initializer and de-initializer functions are exported so that they are visible outside of their originating assembly file. As such, the names of the initializer and de-initializer functions may be rewritten by the ASMFIX tool  to include a namespace identifier (\u2018_namespace_id1\u2019 in this example) unique to their originating assembly file, according to an exemplary embodiment. As described above in connection with S of , such a namespace identifier can help prevent the symbols from interfering with other symbols outside the scope of the assembly file.","As shown in operation S of , the identified initializer functions of multiple assembly files for a particular library or application may be assembled into a single entry point. Similarly, operation S shows that, if applicable, the identified de-initializer functions of multiple assembly files may be assembled into a single entry point. In an exemplary embodiment, the respective entry points of the initializer and de-initializer functions may be placed in a central assembly file created by the ASMFIX tool . Specifically, referring again to the above example, the ASMFIX tool  could create an assembly file containing something like the following:",{"@attributes":{"id":"p-0102","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"section text"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"call_Library_initializers:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"call _static_init_namespace_id_1"]},{"entry":[{},"call _static_init_namespace_id_2"]},{"entry":[{},"..."]},{"entry":[{},"call _static_init_namespace_id_x"]},{"entry":[{},"ret"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"call_Library_deinitializers:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"call _static_deinit_namespace_id_x"]},{"entry":[{},"..."]},{"entry":[{},"call _static_deinit_namespace_id_2"]},{"entry":[{},"call _static_deinit_namespace_id_1"]},{"entry":[{},"ret"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this example, the ASMFIX tool  has created the entry point for the initializer functions as \u2018call Library_initializers,\u2019 and the entry point for the de-initializer functions as \u2018call Library_deinitializers\u2019 (note: this example assumes that the original assembly files are part of a software library designated as \u201cLibrary\u201d). Here, the namespace identifiers \u2018_namespace_id_x\u2019 are used to differentiate initializer\/de-initializer functions located in different assembly files, so that there are no symbol-name conflicts. Accordingly, the ASMFIX tool  has rewritten the symbol \u2018_static_init,\u2019 which is for the assembly file in Library corresponding to x, into \u2018_static_init_namespace_x\u2019; and similarly has rewritten the symbol \u2018_static_deinit\u2019 for the same assembly file into \u2018_static_init_namespace_x.\u2019 This ensures that all initializers and de-initializers are uniquely named across the collection of assembly files in Library.","It is further noted in the above example that the assembly file, which is created by the ASMFIX tool , calls the de-initializers in the reverse order in which the initializers are called. This may be necessitated, e.g., by the C++ specification.","The above example is for the situation where operation S is performed by the ASMFIX tool  to collect both the initializer functions and de-initializer functions into respective single entry points. However, as mentioned above, it is possible that the compiler  might not explicitly arrange for the de-initializer functions of the assembly files to be called explicitly (i.e., the compiler  does not produce an explicit list of the de-initializers to be called), in which case the de-initializer functions would not be assembled into a single entry point according to S. However, in this instance, the ASMFIX tool  could still be used to modify the assembly files so that the corresponding library\/application can control termination.","Consider an example where the compiler  does not produce explicitly arrange for the de-initializers to be called explicitly. In this case, the compiler  might produce something like the following:",{"@attributes":{"id":"p-0107","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"section ctors"]},{"entry":[{},"dcl _static_init"]},{"entry":[{},"section text"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"_static_init:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"...Initialize instructions..."]},{"entry":[{},"move #_static_deinit, r0"]},{"entry":[{},"call _cxa_atexit"]},{"entry":[{},"ret"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"_static_deinit:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"...De-initialize instructions..."]},{"entry":[{},"ret"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this example, like the previous, the \u2018ctors\u2019 section still contains pointers to each initializer that need to be called. However, the initializer function registers de-initializer function to be called before it terminates, through a call to \u2018_cxa_atexit\u2019 method in the above example. This prompts the \u201cat-exit\u201d method in the system software to register a function that is to be called upon termination of the application.","In this situation, the ASMFIX tool  may used to allow the corresponding library or application to control its own termination, by modifying the assembly files. According to an exemplary embodiment, the ASMFIX tool  can do this by replacing the call to the \u2018_cxa_atexit\u2019 method with a call to an \u201cat-exit\u201d management function in the library\/application itself This can be accomplished in the above example by rewriting the symbol \u2018_cxa_atexit\u2019 into, e.g., \u2018Library_cxa_atexit\u2019 (assuming that the assembly files are for implementing a library designated as \u201cLibrary\u201d). The \u201cat-exit\u201d management function of the library\/application would take (at least) one argument, which is the address of the function to be called upon termination (i.e., at exit) of the library\/application. In such an embodiment, the compiler  may arrange for the initializer function to register its corresponding de-initialization function.","When implementing the \u201cat-exit\u201d management function of the library\/application, a function similar to the earlier-described \u2018call Library_intializers\u2019 should be provided, which goes through the previously dynamically registered pointers for the respective de-initializer functions of the assembly files, and calls these functions. In doing this, it might be necessary to call the registered de-initializer functions in reverse order of registration, e.g., for C++ compliance.","As described above in connection with , the ASMFIX tool  of the present invention can be designed to modify the assembly files of a particular library or application so that the initializer functions contained therein can be assembled into a single entry point. This can be particularly advantageous for a software library because, by creating a single entry point for the initializer functions in the library, the library can be called on by an application program to initialize all of the global memory it uses at will, without relying on or being forced by a standard startup procedure of the operating system. However, the library still has the option of initializing memory and calling its initializers on standard startup and\/or standard shutdown of its corresponding application program.","Furthermore, as described above, the ASMFIX tool  may be used to modify the assembly files of a library or application so that the library\/application can control the calls to its de-initializer functions. This can provide an efficient mechanism for calling the de-initializer functions (and effectively terminating the library\/application) when the global variables or objects are no longer needed. Furthermore, in the particular case where a software library is implemented by the assembly files, this feature allows the library to be effectively exited even though the controlling application program, to which the library is linked, is still running. Examples of an application program which may continue to run, after its linked library has effectively exited, includes but is not limited to: user interfaces, glue-code for operating system functions, timers, event-notifiers, etc., which are either a monolithically linked program containing the entire runtime environment, or a single program started and stopped by the operating system.","In fact, a library which has effectively been exited in the aforementioned manner, i.e., while its controlling application program continues to run, may be able to repeat the initialization of its global variables and the calling of the initializer functions via the entry point to effectively launch the library a second time, even if the controlling application has not been terminated in the meantime. To allow this, the library might have to explicitly release all resources acquired dynamically from the operating system or application program before or while running the de-initializer functions. This is because a forced release of resources does not generally happen upon an \u201cexit\u201d of the library, and a re-initialization might cause previous references to operating system resources to be lost (with some exceptions as described below).","In a further exemplary embodiment, not all global variables of a particular library or application need to be governed by the library\/application in the manner described above in connection with . As such, operation S may be modified so that not all initializer and de-initializer functions are identified to be extracted and assembled into the respective entry points. Certain exceptions may be granted, e.g., through the use of a configuration file. Exceptions may be granted for certain global variables which are preferably not be governed by the library, e.g., so that they can keep their values from one startup\/shutdown cycle to the next. This could be useful for, e.g., event logging, keeping handles on operating system resources that can't or shouldn't be released and re-acquired, etc.","With particular embodiments being described above for purposes of example, the present invention covers any and all obvious variations as would be readily contemplated by those of ordinary skill in the art."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will become more fully understood from the detailed description given hereinbelow and the accompanying drawings which are given by way of illustration only, and thus are not limitative of the present invention, and wherein",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
