---
title: Method and system for interpolating level-of-detail in graphics processors
abstract: A method determining LOD values for a geometric primitive, in accordance with one embodiment of the present invention, includes accessing a plurality of geometric parameters of a vertex. An LOD value for a vertex is calculated as a function of the plurality of parameters of the vertex in a setup module. In a raster module an LOD value for a pixel is interpolated as a function of the LOD value of the pixel corresponding to the vertex and a view distance of the non-vertex pixel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08416242&OS=08416242&RS=08416242
owner: Nvidia Corporation
number: 08416242
owner_city: Santa Clara
owner_country: US
publication_date: 20040514
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present application is related to U.S. patent application Ser. No. 10\/846,787, filed May 14, 2004, by Edward Hutchins, entitled \u201cMethod and System for Deferred Evaluation of Transforms in Graphics Processors, which is incorporated herein by reference.\u201d","Three-dimensional graphics processing is utilized in a number of applications, from electronic games, and movies to computer aided design (CAD). Conventionally, three-dimensional graphics processing includes a multi-step rendering process of transitioning from a database representation of three-dimensional objects to a pseudo realistic two-dimensional projection of the object into a display space. The process generally includes setting up a polygon model (e.g., a plurality of primitives) of objects, applying linear transformation to each primitive, culling back facing primitives, clipping the primitives against a view volume, rasterizing the primitives to a pixel coordinate set, shading\/lighting the individual pixels using interpolated or incremental shading techniques, and the like. Typically, graphics processors are organized in a \u201cdeep\u201d pipeline architecture, where each stage is dedicated to performing specific functions. A benefit of a deep pipeline architecture is that it permits fast, high quality rendering of even complex scenes.","The stages of a conventional graphics processor architecture are optimized for high-speed rendering operations (e.g., interpolating parameters, such as color, texture and depth over each two dimensional projection of a primitive). The architecture of the deep pipeline is configured in order to maximize the overall rendering throughput of the graphics processor. Generally, deep pipeline architectures have sufficient data throughput (e.g., pixel fill rate) to implement fast, high quality rendering on large display space devices of even complex scenes. For example, such conventional deep pipelines are configured to compute the various parameters required to render the pixels using multiple, high precision functions. The functions are implemented such that they generate high precision results even in those circumstances where such precision is redundant or unnecessary.","The dedicated stages of deep pipeline architectured graphics processors require a relatively high transistor count. Accordingly, conventional graphic processors require a significant chip area, resulting in relatively high costs. In addition, to achieve fast, high quality rendering in deep pipeline architectures, various stages experience periods of idle processing cycles. Many of the stages consume about the same amount of power regardless of whether they are processing pixels or idle. Accordingly, conventional graphics processors consume significant power, even if the stages are performing comparatively little processing.","As a result of cost and power consumption considerations, conventional graphics processors are unsuitable for many mobile and wireless applications (e.g., wireless phones, personal digital assistants and the like). Therefore, what is desired is a graphics processor architecture having relatively low power consumption and costs.","Embodiments of the present invention are directed toward determining pixel parameters for use in three-dimensional graphics processing. In one embodiment, a method of determining pixel parameters includes accessing a geometric primitive having a plurality of vertices. Each vertex of the geometric primitive has a plurality of parameters, such as an X coordinate, a Y coordinate and a respective view distance (W) value associated therewith. The LOD interpolant value for a vertex may be computed as a function of the other vertex parameters divided by 1\/Wfor the vertex. During rasterization of the geometric primitive, final LOD values for pixels in the geometric primitive are interpolated. The interpolated final LOD values for the pixels are determined according to the formula: final_LOD(i)=Log(LOD_interp*Wi), where final_LOD(i) is interpolated for a respective pixel, i. The method may further include propagating the pixels and the respective final LOD values to modules of a graphics pipeline for rendering thereof.","In another embodiment, a method of determining LOD values for a geometric primitive includes accessing a plurality of geometric parameters of a vertex. An LOD interpolant value for a vertex is calculated as a function of the plurality of parameters of the vertex. A final LOD value for a pixel of the primitive is interpolated as a function of the LOD interpolant value of the pixel corresponding to the vertex and a view distance of the pixel at the time of rasterization.","In yet another embodiment, a graphics processor includes a setup module, a raster module and a data fetch module. The data fetch module is communicatively coupled to the raster module. The raster module is communicatively coupled to the setup module. The setup module receives drawing commands and parameters describing a geometric primitive: The setup module calculates an LOD interpolant value for each texture coordinate set for each vertex of the geometric primitive. The raster module receives the LOD interpolant value for each texture. The raster module interpolates a final LOD value, as a function of the LOD interpolant values of the vertices, for one or more pixels of the geometric primitive. The data fetch module receives the final LOD values and fetches texture data stored in a mip-map as a function of the LOD values of each pixel.","Embodiments of the present invention advantageously reduce the computational workload of the graphics processor, as compared to conventional graphics processors. The reduction in computation workload reduces power consumption by the graphics processor.","Reference will now be made in detail to the embodiments of the invention, examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with these embodiments, it will be understood that they are not intended to limit the invention to these embodiments. On the contrary, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the scope of the invention as defined by the appended claims. Furthermore, in the following detailed description of the present invention, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it is understood that the present invention may be practiced without these specific details. In other instances, well-known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the present invention.","Embodiments of the present invention provide a method and system for implementing interpolation the level-of-detail (LOD) parameter for primitives. Embodiments of the present invention advantageously evaluate the LOD at the vertices of the primitives, and interpolate the LOD parameter over the interior pixels. Limiting the need to evaluate the LOD parameter to the vertex and performing interpolation at the pixels reduces power expenditures and reduces the number of circuit elements. Embodiments of the present invention and their benefits are further described below.","Referring to , block diagrams of exemplary computing device architectures for implementing embodiments of the present invention, are shown. The computing device may be a cellular telephone, PDA or other portable wireless appliance, navigation system (e.g., map enabled GPS), palm-sized computer, tablet computer, game console, personal entertainment center, media center PC, computer based simulator, desktop computer, laptop computer, or the like. The computing device architectures provide the execution platform for implementing certain software-based functionality of embodiment of the present invention. As depicted in , a first computing device may include a processor , system memory controller , system memory , host interface , graphics processor , graphics memory controller , graphics memory , display controller  and display . The processor  may be communicatively coupled to the system memory  through the system memory controller . The processor  may also be communicatively coupled to the graphics processor  through the host interface . The graphics processor  may be communicatively coupled to the graphics memory  through the graphics memory controller . The graphics memory controller  may also communicatively couple the display controller  to the graphics memory . The display  may be communicatively coupled to the display controller .","The processor  provides one or more applications by operating on instructions (e.g., computer executable code) and information (e.g., data) stored in the system memory  (e.g., computer-readable memory). The system memory controller  controls the flow of such information and instructions between the processor  and the system memory . Images to be output on the display  may be off-loaded to the graphics processor  by the processor . The images are off-loaded by transferring geometric primitive parameters (e.g., vertex data representations of triangulated three-dimensional models of objects), draw commands and instructions for controlling the operation of the graphics processor . The primitive parameters, draw commands and instructions are transferred from the processor  to the graphics processor  under control of the host interface . In one implementation, a widely implemented graphics application programming interface, such as the OpenGL-ES\u2122 graphics language, Direct3D\u2122, or the like, is utilized for the software interface between the graphics processor  and the applications provided by the processor .","The graphics processor  generates a color and depth value for each pixel of the display  in response to the received primitives, draw commands and instructions. In one implementation, the primitive parameters are stored in a first buffer local to the graphics processor . The graphics processor  performs geometrical calculations (e.g., transforms) on the primitive in accordance with the draw commands. The graphics processor  also performs rasterization wherein values from the geometrical calculations are mapped to corresponding pixels in the display space. The graphics processor  also retrieves color, texture and depth information from the graphics memory . The graphics memory controller  controls the flow of such information between the graphics memory  and the graphics processor . The color, texture and depth information may be cached local to the graphics processor .","The color and depth value of each pixel may then be determined by the graphics processor  upon applying such functions as texture mapping, fogging, alpha testing, depth testing for culling occluded pixel, alphablend color combining and the like. The color of each pixel may then be cached in a second buffer local to the graphics processor . When the second buffer is filled, the output pixel data (e.g., color and depth value of each of a plurality of pixels) may then be stored by the graphics processor  in the graphics memory  under control of the graphics memory controller . The display controller  reads the output pixel data out of the graphics memory , under control of the graphics memory controller . The display controller  generates scan control signals, from the pixel data, for output to the display . An image is project by the display  as a function of the scan control signals.","As depicted in , a second computing device may include a processor , host interface , graphics processor , unified memory controller , unified memory , display controller  and display . The processor  may be communicatively coupled to the unified memory  through the unified memory controller . The processor  may also be communicatively coupled to the graphics processor  through the host interface . The graphic processor  may be communicatively coupled to the unified memory  through the unified memory controller . The unified memory controller  may also communicatively couple the display controller  to the unified memory . The display  may be communicatively coupled to the display controller .","The processor  provides one or more applications by operating on instructions (e.g., computer-executable code) and information (e.g., data) stored in the unified memory  (e.g., computer-readable memory). The unified memory controller  controls the flow of such information and instructions between the processor  and the unified memory . Images to be output on the display  may be off-loaded to the graphics processor  by the processor . The images are off-loaded by transferring geometric primitive parameters (e.g., vertex data), draw commands and instructions for controlling the operation of the graphics processor . The primitive parameters, draw commands and instructions are transferred from the processor  to the graphics processor  under control of the host interface . In one implementation, a widely implemented graphics application programming interface, such as the OpenGL-ES\u2122 graphics library, Direct3D\u2122, or the like, is utilized for the software interface between the graphics processor  and the applications provided by the processor .","The graphics processor  generates a color and depth value for each pixel of the display  in response to the received primitives, draw commands and instructions. In one implementation, the primitive parameters are stored in a first buffer local to the graphics processor . The graphics processor  performs geometrical calculation (e.g., transforms) on the primitive in accordance with the draw commands. The graphics processor  also performs rasterization wherein values from the geometrical calculations are mapped to corresponding pixels in the display space. The graphics processor  also retrieves color, texture and depth information from the unified memory . The unified memory controller also controls the flow of such information between the graphics processor  and the unified memory . The color, texture and depth information may be cached local to the graphics processor .","The color and depth values of each pixel may then be determined by the graphics processor  upon applying such functions as texture mapping, fogging, alpha testing, depth testing for culling occluded pixels, alphablend color combining and the like. The color of each pixel may then be cached in a second buffer local to the graphics processor . When the second buffer is filled, the output pixel data (e.g., color and depth value of each of a plurality of pixels) may then be stored by the graphics processor  in the unified memory , under control of the unified memory controller . The display controller  reads the output pixel data output from the unified memory , under control of the unified memory controller . The display controller  generates scan control signals, from the pixel data, for output to the display . An image is projected by the display  as a function of the scan control signals.","Referring now to , a block diagram of a graphical processor , in accordance with one embodiment of the present invention, is shown. As depicted in , the graphical processor  includes a setup module , a raster module , a gatekeeper module , a data fetch module , a micro-shader module , and a data write module . The graphics processor  may further include a vertex buffer , a scoreboard , a fetch cache  and\/or a write buffer . The modules - of the graphical processor  are arranged in a pipeline architecture.","The setup module  may be communicatively coupled to a host interface . The setup module  receives geometric primitives (e.g., parameters defining a polygon in three-dimensional space), draw commands and instructions (e.g., for controlling operation of the modules -) from the host interface . The setup module  prepares parameters (e.g., vertex data) of the primitives for rasterization. In one implementation, the primitives include parameters describing the three vertices of a triangle in three-dimensional space. The setup module  supports input formats of 32 bit IEEE floating point, 32 bit S15.16 fixed point (e.g., OpenGL-ES\u2122 fixed standard) and\/or 8 bit packet (e.g., for colors) data packets. The data packets may contain up to 24 parameters in addition to x, y, z, and w parameters, per primitive.","The setup module  may be communicatively coupled to the vertex buffer . The vertex buffer , in one implementation, includes storage (e.g., a plurality of discrete slots) for 256 words (e.g., vertex words). In one implementation, the discrete slots may either be in 8 or 16 word vertex formats, under control of software. Primitive parameters (e.g., three-dimensional vertex data) may be loaded from the host interface  into the vertex buffer  through the setup module , under software control. Although the host interface  is communicatively coupled to the setup module , the host interface  may effectively load vertex data directly into the vertex buffer .","A transform (e.g., matrix multiplication) is performed upon the vertices to convert the three-dimensional arbitrary space that a given application is working in to the two-dimension display space that is being projected onto (e.g., view surface). The transform process is not automatically performed when vertex data is loaded into the vertex cache  by the host interface .","Referring now to , an exemplary vertex buffer, in accordance with one embodiment of the present invention, is illustrated. As depicted in  in conjunction with , a transform indicator bit  is associated with each vertex word  stored in the vertex buffer . The associated transform indicator bit  indicates whether the given vertex word  has been transformed. When the host interface  loads a vertex word (e.g., ) into the vertex buffer , the data is in three-dimensional space and therefore the associated transform indicator bit (e.g., ) is set to a first state (e.g., cleared). When the setup module  accesses a draw command from the host interface , the setup module  retrieves vertex data, applicable to the given draw command, from the vertex buffer . The state of the associated transform indicator bit is checked upon retrieving the given vertex data. If the given vertex word is three-dimensional data (e.g., ) as indicated by the transform indicator bit, the setup module  transforms the given vertex data from three-dimensional into a two-dimensional representation. The vertex word (e.g., ) may be over written with the transformed (e.g., two-dimensional) vertex word (e.g., \u2032) and the associated transform indicator bit (\u2032) is set to a second state (e.g., set). For a given triangle, if its indicator bit indicates transformed data, then the triangle is accessed directly for rasterization without transformation required. After transformation, the setup module stores the vertex data back to the vertex buffer and sets the indicator bit to indicate the transformation state.","Referring now to , an exemplary primitive, in accordance with one embodiment of the present invention, is illustrated. As depicted in  in conjunction with , the level-of-detail (LOD) for each vertex - of the given primitive is also calculated by the setup module . Calculation of the LOD includes determining the approximate area of each vertex pixel projected into the image space (e.g., the area of each box represents an area of an exemplary pixel projected into the image space). In the conventional art, an LOD value of each vertex of a primitive may be calculated as a function of the primitive's vertex X coordinate value, the vertex Y coordinate value, the texture S coordinate value and the texture T coordinate value according to Equation 1, as follows:\n\nLOD=Log(max(sqrt(),sqrt()))\u2003\u2003(1)\n\nIn accordance with embodiments of the present invention, LOD interpolant values (LOD_interp(n)) of the vertices of a triangular primitive determined prior to calculating the logarithm base two. The pre-Log( ) LOD is also divided by the square of a homogeneous view distance (w) squared for each vertex (n) according to Equation 2, as follows:\n\nLOD_interp()=[max(sqrt(()()),sqrt(()()))]\/()\u2003\u2003(2)\n\nIt is appreciated that the pre-Log( ) LOD should actually be divided by w(n)(e.g., based on the partial derivatives of the pre-Log( ) LOD calculations with respect to changes in X and Y). However, using w(n)is sufficiently accurate to provide relatively good quality images as perceived by the human eye under substantially all circumstances. Utilizing w(n)advantageously reduces computation costs and the dynamic range. Upon determining the LOD interpolant values of the vertices, they may be interpolated just like any other perspective-correct primitive parameter.\n","Accordingly, the LOD calculations are done on a per primitive basis, as opposed to per-pixel. Calculating the LOD on a per-primitive basis reduces power consumption by the graphics processor . The LOD values of the vertex pixels may then be utilized in the raster module  to interpolate the LOD values of the other pixels in the given primitive based on the vertex data.","In one implementation, the setup module  calculates barycentric coefficients for rastering. In a barycentric coordinate system, distances in primitives (e.g., triangles) are measured with respect to its vertices. The use of barycentric coordinates reduces the required dynamic range, which permits using fixed-point calculations that require less power than floating point calculations. The two-dimensional parameters (e.g., barycentric) are sent from the setup module to the raster module. The setup module  may also perform clipping and viewporting operations. The setup module  may also perform culling of back-facing primitives and occlusion. Thus, culling and occlusion operations are performed before texturing and shading. Eliminating pixels, as a result of culling and\/or occlusion, before texturing and shading reduces power consumption and reduces the associated memory accesses by the data fetch module  and the data write module . The setup module  may also support guard-band clipping, power management for the rest of the pipeline, and\/or collection of statistics from other modules -, buffers , , caches  and\/or the scoreboard .","The raster module  may be communicatively coupled to the setup module . The raster module  receives instructions and applicable transformed vertex data and performs rasterization thereupon. The raster module  determines which pixels on a screen correspond to a given polygon as defined by the transformed vertex data. Rasterizing includes \u201cwalking\u201d the primitive and generating pixel packets that contain parameters (e.g., set of descriptions for each pixel). The raster module  also determines shader processing operations to be performed, as part of rendering, on each pixel, such as color, texture and fog operations. Hence, the raster module  converts from per polygon (e.g., triangle) to per pixel processing.","The raster module  generates at least one pixel packet for each pixel of a primitive. Each pixel packet includes fields for a payload of pixel parameters required for processing, an instruction sequence of operation to be performed on the pixel packet, and sideband information. The payload of the pixel may include color values, texture coordinates (e.g., S and T), X coordinate values, Y coordinate values, Z depth values, LOD values and the like. In one implementation, the color field may be a pair of 8-bit precision color values, or packed 5555 ARGB color values. The texture field may be 16-bit S and T coordinates, with a 4-bit LOD value. The depth field may be a 16-bit value. In one implementation, the sideband information includes a valid field, a kill field, packet type descriptor (whether the packet is a register write or contains pixel data) or the like. The generated pixel packets may be four 20-bit variables per row, and up to 4 rows. The generated pixel packets may also include 4 high-precision and 4 low-precision perspective-corrected iterated values per row.","The raster module  interpolates the LOD of the pixels from the calculated LOD interpolant values of the primitive vertices -. However, a straight interpolation across the primitive (e.g., triangle) will provide relatively poor image quality. Accordingly, the final LOD (final_LOD(0) for each pixel is interpolated according to Equation 3:\n\nfinal_LOD()=Log(LOD_interp())*)\u2003\u2003(3)\n\nwhere final LOD(i) are interpolated values of LOD for a respective pixel, i, of the pixels. Equation 3 may be evaluated for each texture to be applied to the pixels of the primitive. Assuming that a fast approximation of the logarithm base two is available, Equation 3 can be simplified as given by Equation 4:\n\nfinal_LOD()=approx_Log(LOD_interp)+Log(2)\u2003\u2003(4)\n\nThe final LOD of each pixel is clamped between zero and Log(N), where N is the maximum dimension of the largest texture supported by the device. The LOD value has an integer portion and a fractional portion. In one implementation, an eight-bit value representing the LOD of each pixel, where four integer bits indicate which of a plurality of mip-map levels to use and four factional bits are utilized to interpolate the mip-map level.\n","It is appreciate that if there are many texels (texture elements) in a given pixel, than an average texel (e.g., filtered value) may be determined. In mip-mapping the texture is pre-filtered into a plurality of resolutions. For example, a first file of the texture has a first resolution, a second file has a quarter of the resolution of the primary texture, a third file has a sixteenth of the resolution, and so on until a last file contains a single value (e.g., the overall average value) for the texture. The LOD value for each pixel is utilized to determine an appropriate mip-map level such that the texel corresponds one-to-one with the screen space pixel.","The LOD filtering provided by mip-mapping is configured to prevent moir\u00e9 interference patterns, aliasing, and rendering artifacts by scaling and filtering a full resolution texture map into multiple lower resolution versions. The integer portion of the computed LOD value is used to select the correct mip-map level corresponding to the primitive's distance from the viewpoint. For example, a 4-bit LOD value may be utilized to access one of 0 through 15 mip-map levels. The fractional portion of the computed LOD value is used to configure a blending operation performed on corresponding texels in corresponding mip-map levels. For example, the fractional portion is used to assign different weights to texels of corresponding mip-map levels.","The shader operations do not utilize LOD parameter values that are outside of the range of zero to Log(N). Thus, the raster module  is configurable to clamp the LOD value to a maximum value if a computed LOD value is greater than a predetermined range. Similarly, the LOD may be clamped to a minimum value if a computed LOD value is less than the predetermined range. In other words, when the computed LOD parameter corresponds to a texel:pixel ratio, for the primitive, that is larger than the coarsest (smallest) mip-map level, the LOD value may be clamped to the maximum range value. When the computed LOD parameter corresponds to a texel:pixel ratio that is smaller than the finest (largest) mip-map level, the LOD value may be clamped to this minimum range value. In one implementation, once the LOD value is clamped to the minimum or maximum range value, the fractional portion may also be clamped. Alternatively the fractional portion may be discarded. For example, in a case where the maximum LOD parameter value has been exceeded (e.g., mip-map level ), the lowest resolution version will be fetched by the data fetch module . The fractional portion would be insignificant with respect to any blending process.","The gatekeeper module  may be communicatively coupled to the raster module . The gatekeeper module  may also be communicatively coupled to the scoreboard . The gatekeeper module  provides data flow control (e.g., regulates the flow of pixels through the pipeline). The gatekeeper module  attempts to keep the pipeline as full as possible, such that the modules operate on substantially every clock. To facilitate data flow control, the scoreboard  tracks the entry and retirement of pixels in the pipeline. In one implementation, a corresponding bit in the scoreboard  is set when a pixel packet is received from the raster module  by the gatekeeper module . The corresponding bit in the scoreboard  is reset as the pixel packet drains out of the graphic processor .","The scoreboard  is utilized by the gatekeeper module  for scheduling, load balancing, resource allocation and hazard avoidance of pixel packets. The gatekeeper module  also utilizes the scoreboard  to ensure cache coherency for the data fetch  and data-write modules . By tracking the entry and retirement of pixel packet utilizing the scoreboard , the gatekeeper module  prevents coincident pixels from entering the micro-shader module . The gatekeeper module  also utilizes the scoreboard  to support recirculation of pixel packets for complex shader operations. The gatekeeper module  may also detects micro-shader  idle conditions. The gatekeeper module  may also handle debug register reads.","The data fetch module  may be communicatively coupled to the gatekeeper module  and a memory controller . The data fetch module  may also be communicatively coupled to the fetch cache . The data fetch module  performs color, texture and depth data reads from memory (not shown) for each pixel packet flowing through the pipeline. The data fetch module  reads data from memory and buffers the data in the fetch cache . In one implementation, the data fetch module  reads data from memory in 128 bit chunks (e.g., the width of the communication channel between the graphics processor and the memory controller). In one implementation the fetch cache  may be partitioned into a color cache, texture cache and depth cache. Alternatively the fetch cache  may be composed of separate caches for storing color, texture and depth information. The data fetch module  inserts the appropriate color, texture and depth information into each pixel packet prior to sending the pixel packet onto the micro-shader module .","It is appreciated that because previous and subsequent pixels are spatially related to each other, such that there is a reasonable probability that the color, texture and\/or depth data buffered in the fetch cache  may be utilized from subsequent pixel packets. Therefore, the bandwidth utilization of the communication channel between the graphics processor  and the memory controller  may be reduced, if a subsequent pixel packets can utilize color, texture and\/or depth data buffered in the fetch cache , which were retrieved for a previous pixel packet.","The micro-shader module  may be communicatively coupled to the data fetch module . The micro-shader module , in one implementation, includes one or more arithmetic logic units (ALU). Each arithmetic logic unit implements a unified arithmetic function. In one implementation, each ALU performs a plurality of scalar arithmetic logic operations in the form of [a*b \u201cop\u201d c*d] on a set of input parameters, where \u201cop\u201d represents a programmable operation and * is a multiplication operation. The input parameters may be one or more parameters from a given pixel packet, one or more previous result values and\/or one or more constants. The arithmetic logic operation may implement functions such as a fog algorithm, alpha blend algorithm, alpha test algorithm and\/or a texture combine operation. The ALU may simultaneously perform different operations, thereby improving the functionality of the ALU and decreasing power consumption, as compared to conventional graphics processors. The output of the micro-shader module  is a color and depth value for a given pixel of the display.","The data write module  may be communicatively coupled to the ALU modules  and the memory controller . The data write module  may also be communicatively coupled to a write buffer  and\/or the gatekeeper module . The data write module  send the resultant pixel data, calculated by the ALU module, out to memory controller . In one implementation, the communication channel between the graphics processor  and the memory controller  is 128-bits wide and the pixel data is 16-bits. Therefore, the resultant pixel data is buffered in the write buffer until 128 bits are accumulated. The accumulated resultant pixel data is output to the memory controller  for storage in memory. By buffering the resultant pixel data, efficient use of the communication channel bandwidth may be achieved.","The data write module  may also indicate retired writes to the scoreboard , thereby keeping data consistent. The data write module  may also recirculate pixel packets for further processing. In one implementation, the data write module  may optionally dither to 565 colors.","Each module - of the graphics processor  is sub-block clocked. Sub-block clocking enables disabling of the clock tree for a given sub-block which is idle (e.g., command and\/or data path). Furthermore, the logic is designed to minimize active regions of the logic cone. For example, the logic cone is optimized such that power is consumed when an operation is performed as opposed to every clock cycle. Thus, if an operation is not performed on a pixel packet in a block of a given module - during a clock cycle, power savings propagate down the logic tree of the pipeline.","Referring now to , a flow diagram of an exemplary method of deferred transform evaluation, in accordance with one embodiment of the present invention, is shown. As depicted in , in conjunction with , the method of deferred transform evaluation includes receiving vertex data of a geometric primitive from a host interface, at . At , it is determined by an interlocking mechanism if the new vertex data will overwrite vertex data currently being utilized. If the new vertex data received from the host interface will overwrite vertex data currently involving a draw command, the host interface is held off from loading the new vertex data into the vertex buffer , at . If the new vertex data will not overwrite vertex data currently involving a draw command, the host interface loads the new vertex data (e.g., , , ) into the vertex buffer  and clears the an associated transform indicator bit (e.g., , , ) in the vertex buffer , at .","The method of deferred transform evaluation further includes receiving a draw command from the host interface, at . At , the vertex data corresponding to the draw command is retrieved from the vertex buffer . At , it is determined, from the state of transform indicator bit, if the retrieved vertex data has been transformed. If the vertex data (e.g., ) is three-dimensional data of a graphics primitives, as indicated by the corresponding transform indicator bits (e.g., ), the vertex data is transformed into a two-dimensional representation, at . At , the transformed vertex data (e.g., \u2032) is written back to the vertex buffer \u2032 and the corresponding transform indicator bit (e.g., \u2032) is set. If the retrieved vertex data (e.g., ) has already been transformed into a two-dimensional representation, the transform process  and corresponding write back process  are not performed.","Accordingly, transforms are not automatically performed when vertex data is loaded into the vertex buffer . In addition, if a given vertex data has already been transformed as a result of a previous draw command of a primitive that shared the given vertex datum, the repeated transform of the given vertex data may be advantageously eliminated. Eliminating the repeated transform of vertex data currently stored in the vertex buffer  reduces power consumed by the graphics processor. Furthermore, it is appreciated that the transform-indicator bit enables storage of pre-transform vertex data and post-transform vertex data in a single vertex buffer . Hence, the hardware (e.g., transistors implementing the registers utilized to store vertex data) of the graphics processor may be reduced. In addition, the sharing of a single vertex buffer allows the same underlying hardware units (multipliers, adders and the like) to be utilized by both the transformation and setup calculations by virtue of the inherent arbitration between said calculations, further reducing cost and complexity.","Referring now to , a flow diagram of a method of interpolating level-of-detail, in accordance with one embodiment of the present invention, is shown. As depicted in , the method of interpolating the level-of-detail begins with receipt of parameters for each vertex of a given geometric primitive, at . Each vertex is specified by a plurality of parameters, such as a primitive X coordinate value, a Y coordinate value, and a W coordinate value (e.g., view distance). At , the level-of-detail (LOD) is calculated at each vertex. The LOD of each vertex may be calculated according to Equation 2 for each texture. In one implementation, the LOD of each vertex varies across the triangle as a function of 1\/W.","At , the LOD of the pixels of the primitive may be interpolated from the LOD values of the primitive vertices according to Equation 4. The LOD value is between zero and Log(N), where N is the maximum texture dimension supported by the device. The LOD value includes an integer portion and a fractional portion. In one implementation, the LOD value is encoded as an eight-bit representation. Four bits (e.g., integer portion) indicate which of a plurality of mip-map levels to fetch and four bits (e.g., fractional portion) are utilized to interpolate the texel in the specified mip-map level.","At optional process , the integer portion and\/or the fractional portion of the LOD value may be clamped. For example, if the calculated LOD is less than a zero, than the integer portion of the LOD value is clamped to zero and the fractional portion may be discarded. If the calculated LOD is greater than Log(N), than the integer portion of the LOD value is clamped to maximum resolution and the fractional portion may be discarded. Alternatively, if the calculated LOD is less than a zero, than the integer portion of the LOD value is clamped to zero and the fractional portion may also be clamped. If the calculated LOD is greater than Log(N), than the integer portion of the LOD value is clamped to maximum resolution and the fractional portion may also be clamped. The clamped LOD value may then be output, at .","In the conventional art, the LOD is calculated for each pixel in a given primitive based on the pixel's other parameters. In embodiments of the present invention, the level-of-detail (LOD) is calculated once per vertex of a given primitive. It is appreciated that a given triangle has only three vertexes, but typically has hundreds of pixels. Hence, the computational workload of graphics processors, in accordance with embodiments of the present invention, is advantageously reduced as compared to conventional graphics processors because interpolation is more efficient than computation of the LOD values according to the conventional technique. The reduction in computation workload reduces power consumption by the graphics processors.","The foregoing descriptions of specific embodiments of the present invention have been presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed, and obviously many modifications and variations are possible in light of the above teaching. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the Claims appended hereto and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present invention are illustrated by way of example and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
