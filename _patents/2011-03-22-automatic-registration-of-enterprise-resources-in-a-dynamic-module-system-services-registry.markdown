---
title: Automatic registration of enterprise resources in a dynamic module system services registry
abstract: A computer-implemented method, system, and medium are disclosed for implementing a hybrid application server. The server comprises an application server container, a dynamic module system, and a resources-exporter module deployed on the dynamic module system. The resources-exporter module is configured to detect that a system-level resource of the application server container has been deployed. In response to detecting that the container resource has been deployed, the resources-exporter is configured to register a proxy object for the system-level resource as a service in the dynamic module system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08706881&OS=08706881&RS=08706881
owner: Oracle International Corporation
number: 08706881
owner_city: Redwood City
owner_country: US
publication_date: 20110322
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["As software systems have become more complex, code modularity has become an increasingly important design goal. Building software systems using modular components enables developers to reuse code, modify software quickly when requirements evolve, mitigate costs of producing multiple versions, and reduce development time by integrating pre-written, third-party components.","Many tools and frameworks have been proposed for facilitating modular software development. For example, Java Enterprise Edition\u2122 (Java EE) is a widely used application server environment for enterprise server programming in Java\u2122. The platform includes a component container that provides a set of services, application programming interfaces (APIs), and protocols that facilitate modular software development. The container also provides runtime support, such as lifecycle management, security frameworks, deployment services, automatic threading, transaction management, and other services. A container that provides such services, such as the Java EE container, may be referred to herein generally as an application server container or component container. The components to which the container provides such services are said to be managed by the container.","Using Java EE standards, developers can define web-tier components (e.g., Servlets), business-tier components (e.g., Enterprise Java Beans\u2122 or EJBs\u2122), components for accessing enterprise information systems (e.g., JDBC\u2122), and others, and assemble applications from these components. At runtime, the assembled application can be deployed on the container as a package of components (e.g., using a JAR). The container provides the application components with services, such as lifecycle management, security, deployment, threading, transaction management, persistence, remote invocation, context propagation, and others. By providing such services, an application server component container, such as that provided by Java EE, enables programmers to concentrate on developing application logic rather than on wiring components together and implementing commonly required and\/or low-level functionality.","There has also been much interest in service-oriented architectures and dynamic module systems. A dynamic module system is a framework that allows components to be deployed as independent modules and to dynamically discover and use one another during runtime. Such systems are \u201cdynamic\u201d in that components may enter and\/or exit the system independently of other components. For example, OSGi is a dynamic module system for building modular, service-oriented Java\u2122 applications. OSGi provides a service registry where developers can register and unregister services. Each service listed by the service registry may have multiple implementations and an OSGi component may query the service registry to discover and retrieve various implementations of a particular service. In response to a service query, an OSGi container may determine an appropriate implementation that satisfies the query and return it to the querying component. Using the handle, the discovering object may then invoke the service. Related services are often deployed in OSGi as a group of implementing classes known as a bundle or module. Such a module may define a set of capabilities (i.e., service interfaces), requirements (i.e., dependencies), and classes (i.e., implementations). OSGi includes a lifecycle layer that enables modules to be dynamically installed, started, stopped, updated, and uninstalled during runtime, which enables reconfiguration without system downtime.","A computer-implemented method, system, and medium are disclosed for implementing a hybrid application server. The server comprises an application server container, a dynamic module system, and a resources-exporter module deployed on the dynamic module system. The resources-exporter module is configured to detect that a system-level resource of the application server container has been deployed. In response to detecting that the container resource has been deployed, the resources-exporter is configured to register a proxy object for the system-level resource as a service in the dynamic module system. Thereafter, the proxy object is discoverable and invocable by components of the dynamic module system.","In some embodiments, the system-level resource may correspond to a pool of connections to a database (e.g., JDBC) or to other system-level resources. The system-level resource may be deployed according to a configuration parameter, which the resources-exporter may associate with the service as a service property. In response to detecting that the configuration parameter has been modified, the resources-exporter may modify the service property to reflect the modified configuration parameter.","When a client component invokes a service provided by the proxy object, the proxy object may discover the system-level resource by performing a lookup using a directory service of the application server container. The proxy object may then invoke an interface of the system-level resource that corresponds to the one invoked by the client.","When the system detects that the system-level resource is no longer deployed on the application server container, the resources-exporter may unregister the proxy object form the dynamic module system. The dynamic module system may be configured to notify one or more clients that the proxy object is unregistered.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description hereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the invention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Any headings used herein are for organizational purposes only and are not meant to limit the scope of the description or the claims. As used herein, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to) rather than the mandatory sense (i.e. meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","Application server component containers (e.g., that provided by Java EE) and dynamic module systems (e.g., OSGi) each provide valuable tools that help programmers develop and manage modular software applications. For example, enterprise services typically require transactional access to data systems such as relational database servers, message-oriented middleware, CORBA, ERP systems (e.g., SAP, PeopleSoft, etc.), legacy systems, and\/or others, which may be integrated with a security policy of an underlying system. The Java EE component container provides well-established APIs for building services with transactional access to such data systems, whereas OSGi does not. On the other hand, OSGi provides a dynamic modular runtime that enables components to be inserted, discovered, updated, and removed dynamically at runtime. It is therefore desirable to build hybrid applications that can be deployed in an environment that integrates the benefits of an enterprise application server component container with those of a dynamic module system.","According to various embodiments, an application server may be deployed with both a component container usable to manage application components and a dynamic module system usable to provide dynamic services to those components. Thus, applications executing on the hybrid server may leverage both the benefits of a component container as well as those of the dynamic module system. Such applications may be referred to herein as hybrid applications and may be implemented as a group of independently deployable modules (or bundles) in the dynamic module system. As used herein, a bundle is a unit of deployment in a dynamic module system, such as OSGi.","In some embodiments, the application server may be a Java EE-compliant application server (e.g., GlassFish), which may itself be deployed as bundles of a dynamic module system (e.g., an OSGi implementation, such as Felix, Equinox, Knopflerfish, etc.). Although many of the embodiments described herein are illustrated in terms of a Java EE application server and an OSGi dynamic module framework, the systems and techniques described herein are not intended to be limited to those technologies alone. In recognition that particular standards evolve and that alternatives become available, it is intended that the embodiments described herein be applicable to any application server, component container, and dynamic module system.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 1","FIG. 1"],"b":["105","130","135","135","105","130","135","140"]},"According to , hybrid application server  comprises various components and libraries, such as Java EE server bundles , Java EE server extensions , and other libraries . In some embodiments, server  may itself be implemented as an OSGi application. For example, Java EE server bundles  may be a number of OSGi bundles that together implement a Java EE application server and\/or various other server functionalities. Such functionality may implement a Java EE server standard. In addition to the standard implementation, extensions  may include third party OSGi bundles used to implement functionality beyond that defined by the standard server (i.e., in bundles ) and libraries  may implement various other functionality usable by the server and\/or hybrid applications .","According to , hybrid application  comprises various components, such as OSGi service components , Java EE components , and hybrid components . Any of components - may be organized into modules of hybrid application .","An OSGi service component, such as in , may be defined as part of an OSGi bundle that includes various classes implementing one or more services. An OSGi bundle may also include OSGi metadata that describes the implemented services and\/or other configuration information usable to deploy the components. Hybrid application server  may use this metadata to deploy OSGi service components  as dynamic services in OSGi container .","According to the illustrated embodiment, a hybrid application may further comprise Java EE components . Java EE components may be written as self-contained, reusable components (e.g., EJBs, Servlets, etc.) that are deployable on an application server and are managed by a configurable Java EE container. Before deploying a Java EE component into production on the Java EE container, the application server  may verify that the component is well formed and in compliance with a Java EE specification.","The Java EE container may be implemented by application server  (e.g., in Java EE server bundles ) and configured using various configuration files. A Java EE container may provide Java EE components with different services, such as security, transaction management, Java Naming and Directory Interface (JNDI) lookup functionality, remote connectivity, and\/or other services. For example, the Java EE container may be configured with a given security model such that a managed component (e.g., an EJB) that is managed by the container prevents access by unauthorized users to restricted system resources. In another example, the container may implement a transaction model that allows programmers to define atomic transactions by specifying relationships among methods of one or more components that make up the transaction; the container may then ensure that all methods in the transaction are executed together as a single atomic unit without the need for the particular components to implement the low-level atomicity mechanisms. In some embodiments, the container may expose lookup interfaces (e.g., JNDI) that provide the managed components with a unified interface to various naming and directory services in an enterprise. Similarly, a container may also provide Java EE components with interfaces to remote components, such that a Java EE component can transparently access a remote component as though it is local.","Because the Java EE container provides a configurable context in which components execute, application components can be made to behave differently based on the particular container configuration in which they are deployed. For example, a particular EJB may have security settings that allow it a certain level of access to a database in one production environment and another level in a different production environment. Therefore, programmers can develop application components that are modular and reusable to implement different behavior as determined by the particular container in which they are deployed.","In some embodiments, a container may also provide other services, such as enterprise bean and servlet lifecycle management, database connection resource pooling, data persistence, dependency injection services, and provide access to various other Java EE container APIs. In some embodiments, application server  may implement multiple containers and\/or sub-containers, such as separate EJB and web containers for managing business logic components (e.g., EJBs) and web components (e.g., JSPs\/Servlets) respectively.","In some embodiments, multiple ones of Java EE components  may be bundled together as an archive (e.g., JAR file). Such an archive may include multiple classes implementing one or more Java EE components. The archive may also include various Java EE metadata that describes deployment settings of the one or more Java EE components. For example, the Java EE metadata may be declared in an XML-file (i.e., a deployment descriptor) that provides deployment metadata such as transaction attributes and security authorizations for the Java EE components. Therefore, an administrator may change the deployment descriptor to implement new functionality without the need to modify the source code implementing the Java EE components themselves. At runtime, server  may read the deployment descriptor and act upon Java EE components  accordingly.","In various embodiments, different types of Java EE components  may be packaged in different archives that include different metadata. For example, EJBs may be archived in a JAR archive that includes an EJB-specific deployment descriptor while JSPs, servlets, image files, and\/or other web-tier components may be packaged in a WAR archive that includes a web-specific deployment descriptor.","In addition to (or instead of) deploying components that take advantage of either the OSGi framework or the Java EE framework, it may be desirable for a hybrid application to deploy hybrid components (e.g., ) that can take advantage both of the benefits provided by the OSGi container  and of those provided by the Java EE container (implemented by server ). For example, a hybrid component may be deployed as a Java EE component (which is managed by and can take advantage of a Java EE container implemented in server ), but that are also visible as OSGi services managed by OSGi container . Such a component may take advantage of being a Java EE-managed component (e.g., transaction management, security framework, dependency injection framework, etc.) and also of being an OSGi-managed service (e.g., modularity, dynamic, service-oriented architecture, etc.). Accordingly, hybrid components  may be implemented as part of Java EE components  and\/or of OSGi service components .","In , hybrid application  includes one or more hybrid components , which are implemented as both OSGi service components and Java EE components. In various embodiments, hybrid components  may correspond to a hybrid module and\/or an entire hybrid application. Hybrid components  may be packaged together in a hybrid archive that includes various classes, OSGi metadata, and Java EE metadata.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2"},"According to the illustrated embodiment, hybrid archive  includes classes . Classes  may include compiled code, source code, byte-code and\/or any other encoding of the object classes that implement application functionality. For example, classes  may implement various Java EE components (e.g., EJBs), which may be configured to run within and be manageable by a Java EE container. Components defined in classes  may be configured to expose different interfaces and\/or services. Hybrid archive  also includes Java EE metadata . Java EE metadata  may describe deployment settings of the Java EE components defined by classes , such that those components may be deployed on a Java EE container. In some embodiments, the Java EE metadata may be analogous to that used to deploy Java EE components  of . For example, the Java EE metadata may be declared in an XML-file of the archive (i.e., a deployment descriptor) that provides deployment metadata such as transaction attributes and security authorizations for the Java EE components. In some embodiments, some or all of Java EE metadata  may be expressed using annotations within classes  rather than only in a deployment descriptor. Java EE metadata  may enable the Java EE components defined in classes  to be deployed into a Java EE container.","Hybrid archive  also includes OSGi metadata . OSGi metadata  may describe deployment settings of one or more services exposed by classes , such that those services may be deployed into an OSGi container, such as  in , as an OSGi bundle. In various embodiments, OSGi metadata  may include a manifest file describing the contents of archive  and\/or other information about the bundle, such as interfaces to the services the bundle will expose, dependency information, a unique identifier for the bundle, a human-readable name, the name of an activator class, a class path, and\/or other metadata usable to deploy classes  as an OSGi service. In some embodiments, OSGi metadata  may further include optional documentation, such as that commonly included in an OSGI-OPT directory of OSGi bundles.","In various embodiments, Java EE metadata  and OSGi metadata  may be specified in separate files, together in a single file, using annotations within classes , or any combination thereof. For example, in some embodiments, a single deployment descriptor file may contain portions of Java EE metadata  and OSGi metadata , such that some common metadata (e.g., manifest of classes ) need not be repeated in separate locations.","As describe above, a hybrid archive, such as , may be used to deploy a hybrid module, hybrid application, and\/or various hybrid components. Such components may utilize both the benefits of the Java EE container and those of the OSGi container. For example, in some embodiments, hybrid archive  may be used to package and deploy one or more OSGi-enabled Java EE components, such as EJBs. In some embodiments, deploying components in such an archive may include deploying components on both the OSGi container and Java EE container. Therefore, such a hybrid archive may be considered an OSGi-enabled Java EE bundle.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 3","FIG. 1"],"b":"130"},"According to the illustrated embodiment, method  begins by installing an extender bundle in the OSGi runtime, as in . In some embodiments, the extender bundle may be a component or module packaged as an OSGi bundle. Such a bundle may be distributed as part of a hybrid application server.","Once the extender bundle is deployed on the OSGi container, it may listen for state transitions of OSGi-enabled Java EE bundles to determine when such a bundle has been deployed on the OSGi container. In some embodiments, the extender bundle may utilize built-in notification mechanisms of the OSGi container to detect deployment of OSGi-enabled Java EE bundles. For example, the extender bundle may register its interest with the OSGi container in receiving state transition notifications of newly deployed bundles. When the extender bundle receives notification of a newly deployed OSGi bundle, the extender bundle may examine the newly deployed bundle to determine whether the newly deployed bundle is a hybrid that should be deployed in the Java EE container.","According to the illustrated embodiment, after the extender bundle is installed in , an OSGi-enabled Java EE bundle is deployed to the OSGi container in . Such a bundle may include both OSGi and Java EE metadata and be packaged in a hybrid archive, such as  of .","After or while the OSGi-enabled Java EE bundle is deployed (as in ), the extender bundle receives event notifications regarding the status of the OSGi-enabled Java EE bundle. In , the extender bundle determines that the OSGi-enabled Java EE bundle is ready to be deployed to the Java EE container. The specific details of when a bundle is ready may vary across bundles and\/or dynamic module system implementations. For example, in various embodiments, a bundle may be ready when the OSGi container has resolved all of the bundle's dependencies and\/or when the container has invoked one or more appropriate activation methods of the bundle.  and the accompanying description below illustrate how the extender bundle may determine, as in , that an OSGi-enabled Java EE component is ready to be deployed to the Java EE container, according to some embodiments.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 4","FIG. 4"]},"According to , an OSGi bundle may start in INSTALLED state , where it has been detected and is waiting for all of its dependencies to be resolved. That is, the OSGi framework attempts to find each class on which the installed bundle depends (e.g., that the installed bundle references). Once all of a bundle's dependencies are resolved, the bundle enters the RESOLVED state . In some embodiments, the framework moves the bundle into RESOLVED state  after ensuring that the runtime environment meets or exceeds the environment required by the bundle and dependencies (e.g., packages imported by the bundle or other bundles required by the bundle) are present and either in the RESOLVED state  themselves or can be resolved at the same time as the bundle.","According to the illustrated embodiment, the STARTING state  is a transitional state between RESOLVED state  and ACTIVE state . During the STARTING state , the container may create the resources required by the bundle. When the resources are created, the container may call the start( ) function on the bundle's activator (if one is provided), as indicated by the transition to ACTIVE state . If the bundle has an activation policy, the bundle may remain in the STARTING phase  until the bundle is activated according to its activation policy. For example, if the bundle has a LAZY activation policy (i.e., a policy mandating that the bundle be activated upon the first successful request to load a class from that bundle), then the bundle may not become active until the first successful request to load a class from the bundle.","Once a bundle is activated, it may enter ACTIVE state  and become ready to be invoked and perform functionality defined by its classes. Services in an OSGi container can be stopped and started dynamically, such as by invoking a stop method on the bundle's activator. While a bundle is being stopped (e.g., after the stop method is called on the activator, but before the stop method returns), the bundle may be in STOPPING stage . Once the container fully stops the bundle, the bundle may return to the RESOLVED state .","According to the illustrated embodiment, determining when a given bundle is ready for deployment to the Java EE container may depend on the given bundle's activation policy. For example, if the bundle has a default activation policy, then the extender bundle may determine that the given bundle is ready when the given bundle enters the ACTIVE state . However, if the given bundle has a lazy activation policy, then the extender bundle may determine that the given bundle is ready when it is in the STARTING state.","In  of , the extender bundle detects a state transition that indicates the bundle is ready to be deployed to the Java EE container. In , the extender bundle examines the bundle to determine whether it is a Java EE bundle. For example, in , the extender bundle may examine the bundle metadata to determine if it contains Java EE component metadata (e.g.,  of hybrid archive ) that would allow one or more components in the bundle to be deployed as Java EE components in a Java EE container.","In response to determining that the bundle is an OSGi-enabled, Java EE bundle (as in ) and is ready for deployment (as in ), the extender bundle deploys the Java EE bundle to the Java EE container, as in . In , the extender determines whether the newly deployed OSGi-enabled Java EE bundle contains any components that should be registered with the OSGi container as services. For example, in some embodiments, the OSGi-enabled Java EE bundle may include metadata (e.g., in an \u201cExport-EJB\u201d header) that indicates various Java EE components (e.g., EJBs) and\/or interfaces to expose via OSGi. In different instances, the metadata may indicate that all, none, or some subset of the components and\/or interfaces defined in the Java EE bundle should be exposed as OSGi services.","Once the extender bundle has determined one or more Java EE components or interfaces to expose as OSGi services (as in ), the extender instantiates the components as objects in the Java EE container, as in . In , the extender bundle registers the instantiated components (or references to the instantiated components), in the OSGi service registry, as in , so that the components are available for clients to discover and use. In some embodiments, registering a component may comprise registering all the component interfaces of the components as OSGi service interfaces.","In some embodiments, the extender bundle may determine whether a given Java EE component meets one or more deployment criteria, such as compatibility with the OSGi scoping model, before deploying the component as OSGi service. For example, an EJB that is designated as \u201cstateful\u201d is typically created by and\/or for a given client, performs work on behalf of the client, and maintains state between invocations by the client. However, an OSGi scoping model may only be able to support singleton or singleton-per-bundle services. Because such services may be shared between multiple bundles, it may be incompatible to back such a service with a stateful bean. In some embodiments, the extender bundle may detect such scoping incompatibilities and avoid registering the incompatibly scoped Java EE component as an OSGi service.","Once a Java EE component interface is registered as an OSGi service in the OSGi service registry, the component may be available both as a Java EE component managed by the Java EE container and as an OSGi service available via the OSGi registry and managed by the OSGi container. The fact that the OSGi service is backed by a Java EE component may be transparent to clients who may discover and access Java EE-backed services in the OSGi service registry in the same manner as discovering and accessing normal OSGi services.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 5","FIG. 1","FIG. 3"],"b":["500","130","300","500","505"]},"According to the illustrated embodiment, method  begins when the OSGi container receives a query for an OSGi service, as in . For example, in some embodiments, a client component may use a lookup service provided by its bundle context to query the OSGi container for a particular service. In some embodiments, the query may include a variety of selection criteria that the OSGi container can use to identify the appropriate service, such as a class name and\/or additional tags.","In , the OSGi container uses the query data to determine the Java EE-backed service requested by the client component. In some embodiments, the OSGi container may locate the proxy handle registered by the extender bundle for the Java EE-component.","After determining the Java EE-backed service in , the server locates the corresponding delegate Java EE-component instance that backs the service, as in . In some embodiments, the server may locate the appropriate Java EE component by performing a lookup using a lookup interface, such as JNDI. For example, the server may use the portable JNDI name of the Java EE component to perform a JNDI lookup. Once the server discovers the delegate Java EE component (as in ), it may forward invocations of the service to the delegate Java EE component for processing, as in .","As described with regard to , a client may utilize a Java EE-component backed OSGi service transparently as though it were a normal OSGi service. However, because the service is backed by a Java EE component executing in a Java EE container, the backing component still enjoys the benefits of Java EE container management. For example, if an OSGi client begins a transaction using the OSGi\/JTA API, then a method invocation of the underlying Java EE component (e.g., an EJB) occurs in the context of the same transaction, which may allow the Java EE component developer to control the transactional behavior of the component through transactional attributes.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 6","FIG. 6","FIG. 1"],"b":["600","130"]},"According to the illustrated embodiment, system  comprises OSGi container  and Java EE container . However, in various embodiments, OSGi container  may correspond to a container of another dynamic module system and Java EE container  may correspond to a component container other than Java EE.","OSGi container  comprises a variety of deployed bundles , including an OSGi-enabled EJB bundle  and Java EE extender bundle . OSGi-enabled EJB bundle  may be a type of OSGi-enabled Java EE bundle (as described in reference to ) that contains EJB components. In some embodiments, OSGi-enabled EJB bundle  may be deployed using a hybrid archive, such as , that includes both Java EE and OSGi metadata, such as  and .","In some embodiments, Java EE extender bundle  may be configured to listen for state transition events of bundles on OSGi container , as described herein with reference to , and to deploy bundle  onto Java EE container  when bundle  becomes ready. For example, in response to detecting that OSGi-enabled EJB bundle  is ready for deployment (e.g., as described in reference to ) and that the bundle is an OSGi-enabled EJB bundle (e.g., as described in reference to ), Java EE extender bundle  may deploy bundle  onto Java EE container  as EJB bundle .","Java EE extender bundle  may read deployment metadata of EJB bundle  to determine which EJBs and\/or interfaces should be exposed as OSGi services. For example, Java EE extender bundle  may determine which EJBs and\/or services of EJBs to register as OSGi services by reading an \u201cExport-EJB\u201d header in the metadata of EJB bundle . In various instances, the header may indicate that all EJBs should be made available as OSGi services, that none should be, that only a subset should be (e.g., by class name), and\/or that only a subset of methods of any given EJB should be registered.","In response to determining that a given EJB (i.e., Java EE component) defined by EJB bundle  should be made available as an OSGi service, extender bundle  may create a corresponding EJB instance to back such a service. For example, in the illustrated embodiment, Java EE extender bundle  has instantiated EJB instance  from its definition in EJB bundle .","In system , extender bundle  creates EJB proxy handle , which corresponds to EJB instance , and registers it in OSGi service registry . The proxy handle  may be registered using the EJB class name and\/or various other metadata that enables clients to discover the service by querying OSGi registry . The fact that the service is an EJB-backed service may be transparent to clients, which may discover and invoke the service just like any other OSGi service. When a client invokes the service provided by EJB proxy handle , the server may transparently locate the corresponding delegate EJB instance  using a lookup service, such as JNDI, and forward the method invocation to that delegate.","As discussed above, a Java EE container, such as , may be configured to expose a variety of system-level resources for use by applications executing in the container. Such resources may include database connection pools (e.g., JDBC), messaging services (e.g., JMS), naming directory lookup services (e.g., JNDI), and\/or other Java EE resources (e.g., JavaMail, other custom resources, etc.). The resources may be accessed by one or more applications executing in the container. Thus, the one or more applications may take advantage of various resources without need to re-implement the functionality. A system-level resource provided by a Java EE container may also be referred to herein as a Java EE resource.","For example, an administrator of the Java EE container may create a JDBC connection pool as a system-level resource. The resource comprises a pool of connections to a given database that one or more applications in the container may use. The administrator may configure the JDBC resource by providing information necessary to reach the target database as well as various resource parameters, such as a minimum, maximum, and\/or target number of connections for the container to maintain in the pool. The container may then create the declared pool and make it available to one or more web application components via a given interface. When an application requires access to the given database, the application may request a connection from the container-managed pool rather than creating a new connection to the JDBC resource each time it is needed. Meanwhile, the Java EE container may transparently manage the pool such that it contains an ideal number of connections, given the prevailing workload.","In some embodiments, a hybrid server may be configured to expose system-level container resources, such as a JDBC connection pool, as dynamic services. Thus, a module in a dynamic module system may discover and use a container resource. Various examples and illustrations are discussed below.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 7","FIG. 7","FIG. 1","FIG. 6"],"b":["700","130","600"]},"According to the illustrated embodiment, system  includes an OSGi container  and Java EE container . However, as in system , OSGi container  may correspond to a container of another dynamic module system and Java EE container  may correspond to a component container other than Java EE.","An administrator may deploy Java EE resources onto Java EE container . For example, an administrator may create a JDBC resource, such as . As described above, the administrator may provide various configuration information and\/or parameters, such as the minimum, maximum, and\/or ideal number of connections to maintain in a connection pool of the JDBC resource . Once the resource is deployed on the Java EE container , Java EE components executing in Java EE container  may access the JDBC resource via a given interface (e.g., javax.sql.DataSource).","In the illustrated embodiment, Java EE container  includes a deployment event notifier , which may be configured to detect deployment events of Java EE system resources (e.g., JDBC , JMS, JavaMail, etc.) and to notify interested listeners. Deployment events may include a Java EE resource being deployed, modified, and\/or deleted. The notifier  may detect a creation event in response to an administrator first creating the JDBC resource. The notifier may subsequently detect a modification event in response to an administrator modifying any parameters of the resource (e.g., max number of connections). The notifier may also detect a deletion event in response to an administrator removing the resource from the Java EE container, such that components may no longer use the resource.","In some embodiments, one or more listeners may register their respective interests with event notifier . The registration may specify the types of events about which the listener is interested in being notified. When such an even occurs, notifier  may notify the interested listeners of the event.","In the illustrated embodiment, deployment event notifier  is configured to notify Java EE resources-exporter bundle  of various resource deployment events. Java EE resources-exporter bundle  is one of deployed bundles  in OSGi container . Thus, when an administrator creates, modifies, and\/or deletes JDBC resource , event notifier  detects the event and notifies resources-exporter bundle .","In response to receiving notification that a Java EE resource has been created, resources-exporter bundle  may create a proxy object (such as ) for the resource and register the proxy object as a service in OSGi service registry . According to the illustrated embodiment, exporter  has registered proxy object  in OSGi registry , as indicated by entry . In some embodiments, exporter bundle  may register the proxy object using a standard interface corresponding to the underlying Java EE resource. Furthermore, the exporter may associate the proxy object entry with various service properties (e.g., ), which may reflect parameters of the Java EE resource (e.g., class name, JNDI name, or any other configuration parameters.","Once the proxy object is registered in the OSGi registry, OSGi clients may query the registry to discover, acquire a handle to, and invoke methods exposed by the proxy object. In response to being invoked, the proxy object may locate the underlying Java EE resource (e.g., using a JNDI lookup) and invokes the resource on behalf of the client. Thus, OSGi clients may take advantage of a Java EE resource, such as a JDBC connection pool.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 8","b":["800","700"]},"Registration method  begins when an administrator deploys a system-level resource, such as JDBC resource  in Java EE container . The JDBC resource may include various configuration information and\/or parameters, such as the minimum, maximum, and\/or ideal number of connections to maintain in a connection pool of the JDBC resource.","In , a deployment event notifier (e.g., ) detects the deployment event and, in , notifies a resource-exporter bundle (e.g., ) of the deployment event. In response to being notified of the event, the resources-exporter creates a proxy object (e.g., ) for the resource. The resources-exporter may configure the proxy to locate and invoke the Java EE resource. For example, the resources-exporter may provide the proxy object with a JNDI name of the Java EE resource. Thus, the proxy object may perform a JNDI lookup in the Java EE container to locate the underlying Java EE resource.","In , the resources-exporter bundle binds the proxy object the OSGi registry. Binding the proxy to the OSGi registry may comprise registering the proxy as one or more service interfaces in the OSGi registry, such that OSGi clients may query the registry to discover the proxy. In some embodiments, the resources-exporter bundle may register the proxy object using a standard interface of the underlying Java EE resource. For example, the resources-exporter may register a proxy object for a JDBC resource as a javax.sql.DataSource interface, a proxy object for a JMS Queue resource as a javax.jms.Queue interface, a proxy object for a JMS Topic resources as a javax.jms.Topic interface, a proxy object for a JMS Connection Factory resource as ajavax.jms.queueConnectionFactory or javax.jms.TopicConnectionFactory or javax.jms.ConnectionFactory interface, and so on. The resources-exporter may also associate the registered service interface with various service properties (e.g., ), any of which may reflect configuration parameters of the underlying Java EE resource.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 9","FIG. 7"],"b":["900","700"]},"In , an OSGi client (e.g., ) queries an OSGi registry (e.g., ) for a service provided by a Java EE resource (e.g., JDBC resource ). The query may include an interface name and\/or various other qualifiers. For example, the query may specify that the returned object must be associated with service properties (e.g., ) that match one or more parameters.","In , the OSGi registry responds to the query by returning a handle to a matching proxy object (e.g., ). As described above, the handle may be a reference to the proxy object.","In , the client uses the returned handle to invoke a service interface (e.g., method) of the proxy object. In , the proxy object responds to the invocation by performing a JNDI lookup to locate the underlying Java EE resource and invoking the resource in . As discussed above, the proxy object may be configured with the JNDI name of the underlying Java EE resource, which enables the proxy to perform the JNDI lookup. The JNDI lookup may return a handle to the Java EE resource, which the proxy object may invoke. Although the proxy object may use the same handle to perform multiple invocations on behalf of the OSGi client, in some embodiments, the proxy object may be configured to perform a new JNDI lookup to acquire an updated handle for each invocation. Thus, the proxy object may ensure that it does not invoke a Java EE resource that has been deleted or otherwise changed.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 10","b":["1000","700"]},"Update method  may be triggered when an administrator updates a Java EE resource, as in . For example, the administrator may modify the maximum, minimum, or ideal number of connections in a JDBC connection pool of a JDBC resource, such as . In some instances, some or all of the modified configuration parameters may be reflected in a service properties object (e.g., ) corresponding to a proxy of the resource (e.g., ). Therefore, the system may be configured to update such service properties, as shown in method .","In , the deployment event notifier detects the update event, and in , the notifier notifies the resource-exporter bundle of the update. The notification may include information regarding which properties were update and\/or the new values of those properties.","In , the resources-exporter bundle identifies the proxy object corresponding to the updated resource. In , the resources-exporter modifies the service properties object associated with the proxy object's entry in the OSGi services registry. Using system  as an example, if an administrator updates a configuration parameter of JDBC resource , notifier  notifies resources-exporter . In response to the notification, resources-exporter  determines that proxy object  (which corresponds to JDBC resource ) provides a service that has been modified. Accordingly, resource-exporter  may locate proxy object entry  (corresponding to proxy object ) and modify corresponding service properties . In some embodiments, service properties  may be implemented as an object. In such embodiments, resources-exporter  may update the object or replace it with another object. In some embodiments, one or more other components or subcomponents may perform the update.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 11","FIG. 11"],"b":["1100","700"]},"Remove method  may be triggered when an administrator deletes a Java EE resource, as in . In , the deployment event notifier detects the delete event and in , responds by notifying the resources-exporter of the delete event. In , the resources-exporter responds to receiving the delete event by unregistering the proxy object from the OSGi services registry. In some embodiments, the resources-exporter may perform the unregistering operation synchronously with the notification.","In , the OSGi container notifies any clients that currently hold a handle to the proxy object that the service represented by the proxy object is no longer available. In various embodiments, the message may be of a standard type for communication between the OSGi container and OSGi clients. Because OSGi is a dynamic module system, OSGi clients may be configured to respond to such a message by taking appropriate action to avoid any broken dependencies.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 12","b":"1200"},"The hybrid server, applications, dynamic module systems, application component container, and\/or code to execute various methods described herein may be provided as a computer program product, or software, that may include a computer-readable storage medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to various embodiments. A computer-readable storage medium may include any mechanism for storing information in a form (e.g., software, processing application) readable by a machine (e.g., a computer). The computer-readable storage medium may include, but is not limited to, magnetic storage medium (e.g., floppy diskette); optical storage medium (e.g., CD-ROM); magneto-optical storage medium; read only memory (ROM); random access memory (RAM); erasable programmable memory (e.g., EPROM and EEPROM); flash memory; electrical, or other types of medium suitable for storing program instructions. In addition, program instructions may be communicated using optical, acoustical or other form of propagated signal (e.g., carrier waves, infrared signals, digital signals, etc.)","A computer system  may include one or more processors , each of which may include multiple cores, any of which may be single or multi-threaded. The computer system  may also include one or more persistent storage devices  (e.g. optical storage, magnetic storage, hard drive, tape drive, solid state memory, etc), which may persistently store, for example, data such as program source code , executable code , and\/or various outputs  as shown in .","According to the illustrated embodiment, computer system  may include one or more memories  (e.g., one or more of cache, SRAM, DRAM, RDRAM, EDO RAM, DDR 10 RAM, SDRAM, Rambus RAM, EEPROM, etc.). The one or more processors , the storage device(s) , and the system memory  may be coupled to an interconnect . Various embodiments may include fewer or additional components not illustrated in  (e.g., video cards, audio cards, additional network interfaces, peripheral devices, a network interface such as an ATM interface, an Ethernet interface, a Frame Relay interface, monitors, keyboards, speakers, etc.).","One or more of the system memories  may contain program instructions . Program instructions  may be encoded in platform native binary, any interpreted language such as Java\u2122 byte-code, in any high-level programming language such as C\/C++, Java\u2122, etc., or in any combination thereof. Program instructions  may include instructions executable to implement various applications , such as hybrid web applications, application module, and\/or application components. Such applications may be executed on an application server, such as .","In the illustrated embodiment, program instructions  include instructions executable to implement compiler , which may be usable to compile source code representations of programs and\/or components into an executable form (e.g., native binary or interpreted language). Compiler  may be configured to validate source code for type safety, including for that of injected dependencies, as described herein. In the illustrated embodiment, program instructions  may also include one or more runtime environments . Runtime environments  may include a Java\u2122 runtime, Java EE container, OSGi container, or various runtime support mechanisms as described herein.","In some embodiments, memory  may include any number of in-memory variables and\/or data structures, such as . Variables and data structures may comprise any number of variables and\/or data structures allocated by executing programs, such as applications , server , compiler , and runtime environments .","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
