---
title: Apparatus and method for determining a program neighborhood for a client node in a client-server network using markup language techniques
abstract: An apparatus and method for determining a program neighborhood of a client node in a client-server network is described. The program neighborhood of the client node includes application programs hosted by application servers on the network. The present invention enables a user of a client node to learn of these application programs. The user is not required to know where to find such applications or to manually establish links to such applications. To make the client node aware of its program neighborhood, a host server collects application-related information corresponding to application programs hosted by the servers in the network. The application-related information can include the application name, the server location of the application, minimum capabilities required of client nodes for executing the application, and those users who are authorized to use that application. User credentials are received from the client system. The user credentials are used to filter the application-related information. Information representing those application programs that are available to the client node is transmitted from the host server to the client system for display. In a Windows-based client node, the information can be represented by a graphical icon for each available application program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06928469&OS=06928469&RS=06928469
owner: Citrix Systems, Inc.
number: 06928469
owner_city: Fort Lauderdale
owner_country: US
publication_date: 19990907
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Program Neighborhood","Application Database","Program Neighborhood Service Program (PNSVC)","Program Neighborhood Application Program Interface (PNAPI)","Program Neighborhood User Interface"],"p":["This application claims the benefit of U.S. Provisional Application Ser. No. 60\/114,099 filed Dec. 29, 1998 and is a continuation-in-part of U.S. patent application Ser. No. 09\/252,391 now U.S. Pat. No. 6,643,690, filed Feb. 18, 1999.","The invention relates generally to client-server networks. More specifically, the invention relates to a method for informing a client system of application programs installed at server systems that are available to the client system for execution.","Contemporary computer networks consist of a number of computer systems, called nodes, communicating with other computer systems via communication links. Typically, some of the nodes are client nodes and other nodes are server nodes. A client node formulates and delivers queries to a server node. A user of the client node enters the queries through a user interface operating on the client node. The server node evaluates the queries and delivers responses to the client node for display on the client user interface.","Usually, the server nodes host a variety of application programs that can be accessed and executed by client nodes. When a client node launches an application program, the execution of that application program can occur at either the client node or the server node, depending upon the computing model followed by the computer network. In a server-based computing model, the server node executes the application program, and only the control information for the client user interface is transmitted across the computer network to the client node for display. In a client-based computing model, the server node transmits the application program to the client node so that the client node can run the program using the resources of the client node.","One drawback of contemporary computer networks is that client nodes may be unaware of the application programs available for use on the server nodes. In fact, client nodes may not even be aware of each available server node on the network. To find available application programs on a particular server node, a user of the client node may need to find and gain access to that server node and perform a directory listing of the files existing on that server node. Even then, this listing might not indicate to the user those applications which the user is authorized to use.","Moreover, once the user is aware of the application programs on a server node, often that user must establish a link to those applications. Industry has developed software tools to aid the user in creating these links, e.g., Remote Application Manager manufactured by Citrix Systems, Inc., of Ft. Lauderdale, Fla. The Remote Application Manager is an application program installed on the client node. This application program guides an administrator of the client node to enter information that establishes a link to an application published on a particular server node. The administrator supplies such information as the name of the session, the protocol for accessing the server node, the server name or IP address or the published application. Approaches of this kind require that the administrator know the information and understand the details of protocols and domains in order to establish the connection.","The present invention enables the user of a client system to become informed about available application programs on servers in a network without requiring the user to know where to find such applications or to enter technical information necessary to link to such applications.","In one aspect, the invention relates to a method for presenting application programs to a client system in a network including the client system and a plurality of servers. The servers include a host server that receives application-related information corresponding to application programs hosted by a plurality of servers in a network. User credentials are received from the client system. Whether each hosted application program is available to the client system for execution is determined based on the user credentials and the received application-related information. Information is transmitted from the host server to the client system indicating to the client system each hosted application that is available to the client system for execution. In some embodiments, the host server creates an output display containing the application-related information, such as a HyperText Markup Language (HTML) file, an Extended Markup Language (XML), or other Structured General Markup Language (SGML) file.","The host server can authenticate the client system based on received user credentials. When the client system selects one of the available applications for execution, that application can be executed without requiring additional input of user credentials by a user of the client system, although the selected application is at a server other than the host server.","In one embodiment, a connection is established between the client system and the host server using an Independent Computing Architecture (ICA) protocol. The ICA protocol can establish a virtual channel to transmit information to the client system indicating each hosted application program that is available to the client system. A request to execute one of the available hosted application programs can be received on the connection. In response to the request, a second connection between the client system and the host server can be established to exchange information associated with an execution of the requested application program. In another embodiment, a connection between the host server and a second server hosting the requested application can be established in response to the request. Information associated with an execution of the requested application program can be exchanged between the second server and the client system via the host server.","A second request to execute a second one of the available hosted application programs can be received on the connection between the host server and the client system. Another connection between the host server and a third server hosting the requested application can be established in response to the second request. Information associated with an execution of the second requested application program can be exchanged between the third server and the client system via the host server. Information received from the second and third servers can be merged for transmission to the client system.","In still another embodiment, application information can be provided by the host server to the client system in response to the first request. A second connection can be established between the client system and a second server hosting the requested application in response to the provided application information.","The host server can transmit the available application information in response to a request by the client system. The transmitted information can produce a graphical user interface display at the client system having icons representing the available application programs. The transmitted information can also disclose each hosted application program that the client system is unauthorized to use.","The host server can communicate with each of the other servers to determine the application programs hosted by those other servers and to develop a database for storing the application-related information. The database can be accessible to each of the other servers of the plurality, or each of the other servers can maintain a database for storing the application-related information.","In another aspect, the invention relates to a method for presenting to a client system each application hosted by a server that is available to the client system. User credentials are received from the client system. Application-related information is maintained by the server. Whether each application hosted by the server is available to the client system for execution is determined based on the user credentials and the application-related information. Information indicating each application that is available to the client system is transmitted from the server to the client system.","In another aspect, the invention relates to a server comprising a service module that collects application-related information corresponding to application programs hosted by the plurality of servers. A database stores the collected application-related information. A receiver receives user credentials from the client system. The service module determines for each application program hosted by the plurality of servers whether that hosted application program is available for use by the user of the client system based on the user credentials and the application-related information stored in the database. A transmitter transmits information to the client system.","The service module can transmit a datagram to other servers in the plurality to collect the application-related information corresponding to the application programs hosted by those servers. The transmitted information discloses to a user of the client system each hosted application program that is available for use by the user of the client system. The transmitter can transmit available application information using a virtual channel communications protocol.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["10","20","30","32","34","36","40","40","10","20","40"]},"The client node  can be any personal computer (e.g., 286, 386, 486, Pentium, Pentium II, Macintosh computer), Windows-based terminal, Network Computer, wireless device, information appliance, RISC Power PC, X-device, workstation, mini computer, main frame computer or other computing device that has a windows-based desktop and sufficient persistent storage for executing application programs downloaded from the application servers , ,  across the network . Windows-oriented platforms supported by the client node  can include Windows 3.x, Windows 95, Windows 98, Windows NT 3.51, Windows NT 4.0, Windows CE, Macintosh, Java, and Unix. The client node  can include a display screen , a keyboard , memory  for storing downloaded application programs, a processor , and a mouse . The memory  can provide persistent or volatile storage. The processor  can execute the application programs locally on the client node  and display a resulting windows-based desktop on the display screen . Such local processing on the client node  is according to the above-described client-based computing model.","Alternatively, the client node  can be any terminal (windows or non-windows based), or thin-client device operating according to a server-based computing model. In a server-based computing model, the execution of application programs occurs entirely on the application servers , , , and the user interface, keystrokes, and mouse movements are transmitted over the network  to the client node . The user interface can be text driven (e.g., DOS) or graphically driven (e.g., Windows). Platforms that can be supported by the client node  include DOS and Windows CE for windows-based terminals. The client node  includes a display screen , a keyboard , a mouse , a processor (not shown), and persistent storage (not shown).","The application servers , , , and  can be any computing device that controls access to other portions of the network (e.g., workstations, printers). It is to be understood that more or fewer application servers can be connected to the network . The servers , , , and  can operate according to either a client-based computing model or a server-based computing model as described above.","Each application server , , , and  hosts one or more application programs that can be accessed by the client nodes  and . Applications made available to client nodes for use are referred to as published applications. Examples of such applications include word processing programs such as MICROSOFT WORD\u00ae and spreadsheet programs such as MICROSOFT EXCEL\u00ae, both manufactured by Microsoft Corporation of Redmond, Wash., financial reporting programs, customer registration programs, programs providing technical support information, customer database applications, or application set managers.","The servers , , and  can belong to the same domain . In the network , a domain is a sub-network comprising a group of application servers and client nodes under control of one security database. A domain can include one or more \u201cserver farms.\u201d (A server farm is a group of servers that are linked together to act as a single server system to provide centralized administration.) Conversely, a server farm can include one or more domains. For servers of two different domains to belong to the same server farm, a trust relationship may need to exist between the domains. A trust relationship is an association between the different domains that allows a user to access the resources associated with each domain with just one log-on authentication.","In one embodiment, the application server  is in a different domain than the domain . In another embodiment, the application server  is in the same domain as servers , , and . For either embodiment, application servers , , and  can belong to one server farm, while the server  belongs to another server farm, or all of the application servers , , , and  can belong to the same server farm. When a new server is connected to the network , the new server joins either an existing server farm or starts a new server farm.","The network  can include a master server node for performing load-level balancing among the application servers , , , and . The master server node can be one of the application servers , , , or . The master server node includes a list of server addresses and load information corresponding to each of the other application servers. The master server node can direct the client node to a particular server node on which to execute an application based on the list of available servers and corresponding load levels. Alternatively, the application servers , , ,  may collaborate among themselves in a peer-to-peer fashion in order to exchange administration information such as load levels, allowing any server , , ,  to respond to a request made by a client node , .","According to the principles of the invention, a user of either client node ,  is able to learn of the availability of application programs hosted by the application servers , , , and  in the network  without requiring the user to known where to find such applications or to enter technical information necessary to link to such applications. These available application programs comprise the \u201cprogram neighborhood\u201d of the user. A system for determining a program neighborhood for a client node includes an application program (hereafter referred to as the \u201cProgram Neighborhood\u201d application), memory for storing components of the application program, and a processor for executing the application program.","The Program Neighborhood application can be installed in memory of the client node  and\/or on the application servers , , , and  as described below. The Program Neighborhood application is a collection of services, applications program interfaces (APIs), and user interface (UI) programs that disclose to users of the client nodes ,  those application programs hosted by the application servers that each client node is authorized to use (e.g., execute).","An application server operating according to the Program Neighborhood application collects application-related information from each of the application servers in a server farm. The application-related information for each hosted application can be a variety of information including, for example, an address of the server hosting that application, the application name, the users or groups of users who are authorized to use that application, and the minimum capabilities required of the client node before establishing a connection to run the application. For example, the application may stream video data, and therefore a required minimum capability is that the client node supports video data. Other examples are that the client node can support audio data or can process encrypted data. The application-related information can be stored in a database as described later in the specification.","When a client node logs onto the network , the user of the client node provides user credentials. User credentials typically include the username of the client node, the password of the user, and the domain name for which the user is authorized. The user credentials can be obtained from smart cards, time-based tokens, social security numbers, user passwords, personal identification (PIN) numbers, digital certificates based on symmetric key or elliptic curve cryptography, biometric characteristics of the user, or any other means by which the identification of the user of the client node can be obtained and submitted for authentication. The server responding to the client node can authenticate the user based on the user credentials. The user credentials can be stored wherever the Program Neighborhood application is executing. When the client node  executes Program Neighborhood application, the user credentials can be stored at the client node . When an application server is executing the Program Neighborhood, the user credentials can be stored at that server.","From the user credentials and the application-related information, the server can also determine which application programs hosted by the application servers are available for use by the user of the client node. The server transmits information representing the available application programs to the client node. This process eliminates the need for a user of the client node to set-up application connections. Also, an administrator of the server can control access to applications among the various client node users.","The user authentication performed by the server can suffice to authorize the use of each hosted application program presented to the client node, although such applications may reside at another server. Accordingly, when the client node launches (i.e., initiates execution of) one of the hosted applications, additional input of user credentials by the user may be unnecessary to authenticate use of that application. Thus, a single entry of the user credentials can serve to determine the available applications and to authorize the launching of such applications without an additional, manual log-on authentication process by the client user.","Either a client node ,  or an application server can launch the Program Neighborhood application as described in connection with . The results are displayed on the display screen ,  of the client node , . In a graphic windows-based implementation, the results can be displayed in a Program Neighborhood graphical window and each authorized application program can be represented by a graphical icon in that window.","One embodiment of the Program Neighborhood application filters out application programs that the client node ,  is unauthorized to use and displays only authorized (i.e., available) programs. In other embodiments, the Program Neighborhood application can display authorized and unauthorized applications. When unauthorized applications are not filtered from the display, a notice can be provided indicating that such applications are unavailable. Alternatively, the Program Neighborhood application can report all applications hosted by the application servers , , ,  to the user of a client node, without identifying which applications the client node ,  is authorized or unauthorized to execute. Authorization can be subsequently determined when the client node ,  attempts to run one of those applications.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 2A","b":["10","42","10","30","30","43","10","32","10","32","45","46","32","10","10","32","32","10","10","32","30","32","41","43","46","10","10","10"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2B","b":["10","10","10","41","50","30","30","30","10","30","51","10","41","32","10","32","53","54","10","41","32","41","10"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 2C","b":["10","20","80"]},"The client node , via the web browser , transmits a request  to access a Uniform Resource Locator (URL) address corresponding to an HTML page residing on server . In some embodiments the first HTML page returned  to the client node  by the server  is an authentication page that seeks to identify the client node .","The authentication page allows the client node  to transmit user credentials, via the web browser , to the server  for authentication. Transmitted user credentials are verified either by the server  or by another server in the farm. This allows a security domain to be projected onto the server . For example, if the server  runs the WINDOWS NT operating system, manufactured by Microsoft Corporation of Redmond, Wash., and the authenticating server runs the UNIX operating system, the UNIX security domain may be said to have been projected onto the server . User credentials may be transmitted \u201cin the clear,\u201d or they may be encrypted. For example, user credentials may be transmitted via a Secure Socket Layer (SSL) connection, which encrypts data using the RC3 algorithm, manufactured by RSA Data Security, Inc. of San Mateo, Calif.","The server  may verify the user credentials received from the client node . Alternatively, the server  may pass the user credentials to another server for authentication. In this embodiment, the authenticating server may be in a different domain from the server . Authenticated user credentials of the client node  may be stored at the client node  in a per-session cookie, in fields that are not displayed by the web browser , or in any other manner common in maintenance of web pages. In some embodiments, a server farm with which the server  is associated may allow guest users, i.e., users that do not have assigned user credentials, to access applications hosted by servers in the farm. In these embodiments, the authentication page may provide a mechanism for allowing a client node  to identify that it is a guest user, such as a button or menu selection. In other of these embodiments, the server  may omit the authentication page entirely.","Still referring to , once the client node  is authenticated by the server , the server prepares and transmits to the client node  an HTML page  that includes a Program Neighborhood window  in which appears graphical icons , \u2032 representing application programs to which the client node  has access. A user of client node  invokes execution of an application represented by icon  by clicking that icon .",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 3A","b":["10","30","32","10","72","32","10","32","72","10"]},"In this embodiment, the Program Neighborhood application runs on the client node . The client node display has a Program Neighborhood window  in which appears a graphical icon  representing a second application program. A user of the client node  can launch the second application program by double-clicking the icon  with the mouse. The request passes to the master server node  via a connection . The master server node  indicates to the client node  via the connection  that the sought-after application is available on server . The client node  signals the server  to establish a second connection . The server  requests the user credentials from the client node  to authenticate access to the second application program. Upon a successful authentication, the client node  and server  establish the second connection  and exchange information regarding the execution of the second application program. Accordingly, the client node  and the server  communicate with each other over multiple connections.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 3B","b":["20","30","32","34","36","20","73","32","20","32","73","20","32"]},"In this embodiment, the Program Neighborhood application runs on the server . The server  includes software providing a server-based client engine , enabling the server  to operate in the capacity of the client node . The client node  display has a Program Neighborhood window  in which appears graphical icons , \u2032 representing a second application program and a third application program, respectively. A user of the client node  can launch the second application program by double-clicking the icon . The request to launch the second application program passes to the server  via active connection , and the server  forwards the request to the master server node  (arrow ).","The master server node  indicates (arrow ) to the server  that the sought-after application is available on server . The server  contacts the server  to establish a connection . To authenticate access to the application, the server  obtains the user credentials of the client node  from the server . The server  and server  establish the connection (arrow ) by which the server  requests execution of the second application and the server  returns the graphical user interface results to the server . The server  forwards the graphical user interface results to the client node , where the results are displayed. Accordingly, the information exchanged between the client node  and the server  \u201cpasses through\u201d the server .","Similarly, the client node  can launch the third application program by double-clicking the icon \u2032. The request to launch the third application program passes to the server . The server  forwards the request to the master server node , which considers load-balancing and application program availability to determine which server can handle the request. In this example, the master server node indicates that the server  can run the third application program.","The server  and the server  establish a connection (arrow ) by which the server  requests execution of the third application program, and the server  returns the graphical user interface results to the server . To permit execution of the third application program, the server  can authenticate the user credentials of the client node , which are obtained from the server . The server  forwards the graphical user interface results to the client node  where the results are displayed. Accordingly, the results of executing the third application program pass between the client node  and the server  through the server .","From this illustration it should be understood that client  can run multiple application programs through one connection with the server , while the server  maintains multiple connections (in this example, one connection with server  and a second connection with server ). Also, the server  merges the information received from the server  with the information received from the server  into one data stream for transmission to the client node .",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 3C","b":["20","30","32","34","20","76","32","20","32","76","20"]},"In this embodiment, the Program Neighborhood application runs on the server . The client node  display has a Program Neighborhood window  in which appears a graphical icon  representing a second application program. A user of the client node  can launch the second application program by double-clicking the icon . The request to launch the second application program passes to the server . The server  responds (i.e., \u201ccalls back\u201d) to the client node  by returning application-related information such as the name of the application and capabilities needed by the client node  for the second application to run.","With the information provided by the server , the client node  then communicates with the master server node  via connection  to determine the server for executing the second application program. In this example, that server is server . The client node  then establishes a connection  to the server . Server  requests the user credentials from the client node  to authenticate the user of the client node . The second application program executes on the server , and the server  returns the graphical user interface to the client node  via the established connection . Accordingly, the client node  can have multiple active connections between the multiple servers.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 3D","b":["20","30","32","20","30","2","30","90","20","30","92","3"]},"In this embodiment, the template  is a standard SGML, HTML, or XML document containing Program Neighborhood-specific tags that are replaced with dynamic information. The tags indicate to the server  where in the output display to insert information corresponding to available applications, such as icon images. In one particular embodiment, the Program Neighborhood-specific tags are embedded within comments inside a file, allowing the file to remain compatible with standard interpreters. In another embodiment, the Program Neighborhood-specific tags are extensions of the markup language used as the base for the template.","Examples of HTML tags that may be used in a template in accordance with the present invention are set forth below in Table 1:",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Tag","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ControlField field value","This tag is used to set the value of data"]},{"entry":[{},"that either persists between Program"]},{"entry":[{},"Neighborhood web pages, is set by the"]},{"entry":[{},"user, or is used to help in cross page"]},{"entry":[{},"navigation, such as user name, domain,"]},{"entry":[{},"password, template, and application."]},{"entry":["DrawProgramNeighborhood","This tag is used to draw a Program"]},{"entry":[{},"Neighborhood display at this location in"]},{"entry":[{},"an output display."]},{"entry":["AppName","This tag is replaced by the name of the"]},{"entry":[{},"published application in the current"]},{"entry":[{},"context."]},{"entry":["WindowType","This tag is replaced by the window type of"]},{"entry":[{},"the published application in the current"]},{"entry":[{},"context."]},{"entry":["WindowHeight","This tag is replaced by the window height"]},{"entry":[{},"of the published application in the current"]},{"entry":[{},"context."]},{"entry":["WindowWidth","This tag is replaced by the window width"]},{"entry":[{},"of the published application in the current"]},{"entry":[{},"context."]},{"entry":["WindowScale","This tag is replaced by the window scale"]},{"entry":[{},"of the published application in the current"]},{"entry":[{},"context."]},{"entry":["WindowColors","This tag is replaced by the color depth of"]},{"entry":[{},"the published application in the current"]},{"entry":[{},"context."]},{"entry":["SoundType","This tag is replaced by the sound setting"]},{"entry":[{},"of the published application in the current"]},{"entry":[{},"context."]},{"entry":["VideoType","This tag is replaced by the video setting"]},{"entry":[{},"of the published application in the current"]},{"entry":[{},"context."]},{"entry":["EncryptionLevel","This tag is replaced by the encryption"]},{"entry":[{},"level of the published application in the"]},{"entry":[{},"current context."]},{"entry":["Icon","This tag is replaced by the icon of the"]},{"entry":[{},"published application in the current"]},{"entry":[{},"context."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In one embodiment, the template is constructed dynamically using, for example, COLD FUSION, manufactured by Allaire Corp. of Cambridge, Mass. or ACTIVE SERVER PAGES manufactured by Microsoft Corporation of Redmond, Wash. Alternatively, the template may be static. The Program neighborhood application parses the template, replacing Program Neighborhood-specific tags as noted above. Tags that are not Program Neighborhood-specific are left in the file to be parsed by the browser program  executing on the client .","In one embodiment, a template parser object is provided that accepts an HTML template as input, interprets Program Neighborhood-specific tags present in the template, and outputs the original template with all Program Neighborhood tags replaced with appropriate text. The template parser object can be passed a cookie, a URL query string, or a control field from a web server interface to provide the information with which Program Neighborhood-specific tags should be replaced.","In another embodiment, the Program Neighborhood application allows scripts to access to information via an application programming interface. Scripts may be written in, for example, VBScript or Jscript. In this embodiment, the scripting language is used to dynamically generate an output display using information returned by the application in response to queries posed by the script. Once the output display is generated, it is transmitted to client node  for display by the browser program .","A user of the client node  can launch an application by double-clicking with a mouse an icon , \u2032 displayed in the Program Neighborhood web page. In some embodiments, each icon , \u2032 is an encoded URL that specifies: the location of the application (i.e., on which servers it is hosted or, alternatively, the address of a master server); a launch command associated with the application; and a template identifying how the output of the application should be displayed (i.e., in a window \u201cembedded\u201d in the browser or in a separate window). In some embodiments, the URL includes a file, or a reference to a file, that contains the information necessary for the client to create a connection to the server hosting the application. This file may be created by the Program Neighborhood application dynamically. The client node  establishes a connection (arrow ) with the server identified as hosting the requested application (in this example, server ) and exchanges information regarding execution of the desired application. In some embodiments, the connection  is made using the Independent Computing Architecture (ICA) protocol, manufactured by Citrix Systems, Inc. of Fort Lauderdale, Fla. Thus, the client node  may display application output in a window separate from the web browser , or it may \u201cembed\u201d application output within the web browser.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 4","b":["10","44","48","52","56","60"]},"The application server , for example, includes the service component (PNSVC)  and the application database . The client node , which is a representative example of a client node that can support a client-based implementation of the Program Neighborhood application, includes the application program interface PNAPI , the user interface user interface component , and the local cache  components. The PNAPI  communicates with the user interface component  and the local cache . The PNSVC  communicates with the application database  and with the PNAPI  on the client node  via communications link .","The communications link  can be established by, for example, using the ICA protocol. ICA is a general-purpose presentation services protocol designed to run over industry standard network protocols, such as TCP\/IP, IPX\/SPX, NetBEUI, using industry-standard transport protocols, such as ISDN, frame relay, and asynchronous transfer mode (ATM). The ICA protocol provides for virtual channels, which are session-oriented transmission connections that can be used by application-layer code to issue commands for exchanging data. The virtual channel commands are designed to be closely integrated with the functions of client nodes. One type of virtual channel connection supported by the ICA protocol is a Program Neighborhood virtual channel.","The Program Neighborhood virtual channel protocol can include four groups of commands:\n\n","The application database  is a cache of the authorized user and group information for all the public (i.e., published) applications in a server farm or in a group of trusted domains. Each server in a server farm can maintain its own application-related information in persistent storage and build up the database  in volatile storage. In another embodiment, all collected application-related information in the database  can be stored in persistent storage and made accessible to each other server in the server farm. The database  can be implemented in a proprietary format (e.g., as a linked list in memory) or using Novell's Directory Services (NDS) or any directory service adhering to the X.500 standard defined by the International Telecommunication Union (ITU) for distributed electronic directories.","The application database  includes a list of application servers. Each server in the list has an associated set of applications. Associated with each application is application-related information that can include the application name, a list of servers, and client users that are authorized to use that application. An overly-simplified example of the application-related information maintained in the database is illustrated by the following Table 2. Users A and B are users of the client nodes , , \u201cn\/a\u201d indicates that the application is hosted, but is not available to client node users, and \u201c-\u201d indicates that the application is not hosted.",{"@attributes":{"id":"p-0079","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"center"}}],"thead":{"row":{"entry":[{},"TABLE 2"]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"Applications"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Customer",{},{}]},{"entry":["Server Name","SpreadSheet","Database","Word Processor","Calculator"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Server 30","User A","User B","n\/a","\u2014"]},{"entry":["Server 32","User B","n\/a","User A","\u2014"]},{"entry":["Server 34","\u2014","\u2014","\u2014","User A"]},{"entry":[{},{},{},{},"User B"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Table 2 shows a list of servers , , , the applications hosted by the servers, (SpreadSheet, Customer Database, Word Processor, and Calculator), and those users who are authorized to use the applications. For example, the server  hosts the SpreadSheet program, the Customer Database and the Word Processor. User A is authorized to use the SpreadSheet, User B is authorized to use the Customer Database, and on users are authorized to use the Word Processor. It is to be understood that other techniques can be used to indicate who is authorized to use a particular application. For example, the user information stored in the database can be used to indicate those users who are unauthorized to use a particular application rather than those who are authorized.","To obtain the information that is stored in the database , the server  obtains the application-related information from each other server in the server farm regarding the applications on those servers, including control information that indicates which client users and servers are permitted to access each particular application. The application-related information maintained in the database may or may not persist across re-boots of the server .","The application database  can be a central database that is stored at the application servers ,  and  and are accessible to all of the servers in the server farm. Accordingly, the application-related information can be available for use by other servers such as those servers that perform published application authentication during session log-on and application launching. In another embodiment, the application database  can be maintained at each of the application servers ,  and  based upon the information that each server obtains from communications with each other server in the server farm.","Each server , ,  and  having the Program Neighborhood application installed thereon executes the PNSVC software . The PNSVC software , operating on each server , ,  and  establishes a communication link (e.g. a named pipe) with each other server. The servers , ,  and  exchange the application-related information on the named pipes. In another embodiment, the PNSVC software  collects the application-related information from the other servers in the server farm through remote registry calls (e.g., the service component  transmits a datagram to other servers in the plurality requesting the application-related information corresponding to the application programs hosted by those servers). The PNSVC  software also maintains the relationships of groups and users to published applications in the application database  and accesses the information when authenticating a client user. An administrator of the server  can use a user interface to configure the PNSVC .","Other functions of the PNSVC software  include implementing the services and functions requested by the PNAPI  and communicating with the PNAPI  on the client node  using a Program Neighborhood virtual device driver (VDPN). The VDPN operates according to the Program Neighborhood virtual channel protocol described above for establishing and maintaining an ICA connection.","The PNAPI  is a set of software functions or services that are used by the Program Neighborhood application to perform various operations (e.g., open windows on a display screen, open files, and display message boxes). The PNAPI  provides a generic mechanism for launching application objects (e.g., icons) produced by running the Program Neighborhood application and application objects in a legacy (i.e., predecessor or existing for some time) client user interface. When the client node  launches an available application, the launch mechanism can launch the application on the server , if necessary (e.g., when the client node  does not have the resources to locally execute the application).","The PNAPI  provides all published application information to the user interface component  for display on the screen  () of the client node . The PNAPI  also manages server farm log-ons in a local database of logon credentials (e.g., passwords) for users of the client node  to support the single authentication feature. Credentials may or may not be persistent across bootings (power-off and on cycles) of the client node .","The PNAPI  provides automatic and manual management for Program Neighborhood application objects stored in the local cache . The local cache  can either be refreshed manually by the user of the client node , or at a user-definable refresh rate, or by the server at any time during a connection. In a Windows implementation, the PNAPI  can build remote application file associations and manage the \u201cStart\u201d menu and desktop icons for application object shortcuts.","The user interface module  interfaces the PNAPI  and can be a functional superset of an existing client-user interface (e.g., Remote Application Manager). The user interface module  accesses the information stored in the local cache  through the PNAPI  and visually presents that information to the user on the display screen  () of the client node . The displayed information is a mixture of information generated by a user of the client node  and information obtained by the Program Neighborhood application. The user interface module  can also show the user all applications that the user is currently running and all active and disconnected sessions.","In a windows-based embodiment, the user interface module  can present a variety of graphical components, such as windows and pull-down menus, to be displayed on the display screen  (FIG. ). A display of a combination of such graphical user interface components is generally referred to as a \u201cdesktop.\u201d A desktop produced by the user interface module  can include a Program Neighborhood window displaying the neighborhood of application programs available to the user of the client node  for use. These application programs are a filtered combination of the published applications hosted by a server farm on the network. The user interface module  can generate a Program Neighborhood window for each server farm or merge the applications from different server farms under a single Program Neighborhood window.","At a top level, the Program Neighborhood window includes a folder for each server farm. Clicking on one of the folders with the mouse  () produces a window containing a representation (e.g., an icon) of each hosted application available to the user, e.g., see . The Program Neighborhood window becomes the focal point for launching published applications, and the user interface module  can be used to launch applications through the PNAPI . For example, the user of the client node  can use the mouse  to select one of the displayed icons and launch the associated application.","A feature of a client-based implementation is that the user can browse the objects displayed in the Program Neighborhood window although the client node is offline, that is, the ICA connection  is inactive. Also, a user of the client node  can drag application objects and folders out of the Program Neighborhood window and into other graphical components (e.g., other windows, folders, etc.) of the desktop.",{"@attributes":{"id":"p-0092","num":"0095"},"figref":"FIG. 5","b":["44","48","52","56","60","44","48","52","56","60","30","4","44","48","52","52","56","60"]},"Similar to that described in  for the client node , the client node  logs on to the network  (FIG. ), the server \u2032 develops and maintains a database containing the application related information collected from the other servers ,  in the server farm, and a communication link is established between the server \u2032 and the client node . The application server \u2032 is in communication with the client node  via an ICA channel connection \u2032. The channel connection \u2032 can be established by an ICA virtual channel protocol (e.g., Thinwire). The Thinwire protocol can be used to transmit presentation commands from Windows-based applications running on the application server \u2032 to the client node . To a user of the client node , the applications appear to be running on the client node . The client node  can include a Remote Application Manager application program  that communicates with the application server \u2032 via the ICA channel connection \u2032.","To run the Program Neighborhood application in a server-based implementation, the user of the client node  connects to an initial desktop (at the server \u2032) and launches the Program Neighborhood application from within that desktop environment. The connection to the initial desktop can occur automatically, e.g., via a logon script of the client node , via an entry in the StartUp group in Windows 95, or by another centrally managed server specific mechanism. All remote application management and launching is accomplished through this initial desktop.","Similar to that described in  for the server , the server \u2032 uses the user credentials to determine those application programs that are authorized for use by the user of the client node . A Program Neighborhood graphical window is returned to the client node  and displayed on the client screen  (FIG. ). This window can contain icons representing the available and, possible, the unavailable application programs that are in the program neighborhood of the client node .","The user of the client node  can select and launch one of the application programs displayed in the Program Neighborhood window. When launching an application, the Program Neighborhood application can execute the application on the same server \u2032, where applicable, taking into account load balancing requirements among servers and the availability of the application on that server \u2032. The PNAPI \u2032 can include a launch mechanism for launching a remote application locally on the server \u2032 when the server \u2032 is nominated to launch the application. When a different server is needed to run the application, the Program Neighborhood application can launch the application via the server \u2032 (i.e., server-based client) using the windows to present the application on the desktop of the client node  as described above in FIG. B.","In one embodiment, the web-based Program Neighborhood application includes a group of objects that manage various aspects of the application. In one embodiment, the application include three primary object classes that \u201cplug in\u201d to a web server: a gateway object class; a credentials object class; and an applications object class. In some specific embodiments, the object classes are provided as Java beans. The three primary object classes facilitate: validation of user credentials into a server farm; generation of lists of published applications that a specified user may access; provision of detailed information about a specific published application; and conversion of published application information into an ICA-compatible format.","When provided as Java beans, the objects can be accessed in a number of different ways. For example, they may be compiled as COM objects and made available to the web server as ActiveX components. In another embodiment, the Java beans can be used in their native form, such as when the server uses Java Server Pages technology. In yet another embodiment, the Java beans can be instantiated and used directly in a Java servlet. In still another embodiment, the server  can instantiate the Java beans as COM objects directly.","A credentials object class manages information necessary to authenticate a user into a target server farm. A credentials object passes stored user credentials to other Program Neighborhood objects. In some embodiments, the credentials object is an abstract class that cannot be instantiated and represents a user's credentials. Various class extensions may be provided to allow different authentication mechanisms to be used, including biometrics, smart cards, token-based authentication mechanisms such as challenge-response and time-based password generation, or others. For example, a \u201cclear text credentials\u201d extension may be provided that stores a user's name, domain, and password in plain text.","A gateway object class handles communications with a target server farm. In one embodiment, the gateway object class is provided as an abstract Java class that cannot be instantiated. A particular gateway object may retrieve application information by communicating with a server farm using a particular protocol, reading cached application information, a combination of these two methods, or other various methods.","As noted above, the gateway object class caches information to minimize communication with a target server farm. Extensions to the gateway object may be provided to communicate with the server farm over specific protocols, such as HTTP. In one embodiment, an extension class is provided that allows the gateway object to communicate with the server farm via WINDOWS NT named pipes. The gateway object may provide an application programming interface hook that allows other Program Neighborhood objects to query the object for application information.","An applications object class contains information about published applications and returns information about applications hosted by the server farm in order to create the Program Neighborhood web page. The applications object class creates objects representing applications by retrieving information relating to the applications, either from an object created by the gateway object or directly from the servers in the server farm. An applications object acts as a container for certain properties of the application, some settable and some not settable, such as: the name of the application (not settable); the percentage of the client's desktop that the client window should occupy (settable); the width of the client window, in pixels, for this application (settable); the height off the client window, in pixels, for this application (settable); the number of colors to use when connecting to the application (settable); the severity of audio bandwidth restriction (settable); the level of encryption to use when connecting to the application (settable); the level of video to use when connecting to this application (settable); whether the application should be placed on a client's start menu (settable); whether the application should be placed on the client's desktop (settable); the identity of the Program Neighborhood folder to which the application belongs (settable); the description of the application (settable); the source of the graphics icon file for the application (settable); the type of window that should be used when connecting to the application (not settable); and whether to override default parameters for the object.",{"@attributes":{"id":"p-0103","num":"0106"},"figref":["FIG. 6A","FIG. 1"],"b":["120","12","22","10","20","120","122","122","30","32","34","36","40","1","18","28","14","24"]},{"@attributes":{"id":"p-0104","num":"0107"},"figref":["FIG. 6B","FIG. 1","FIGS. 6A and 6B"],"b":["124","12","22","10","20","124","126","128","126","128","30","32","34","36","40","1","126","10","20","18","28","14","24","122","166","128"]},"Each application program represented by one of the icons  is unavailable to the user of the client node ,  (FIG. ), although such applications are present in the server farm. The unavailability of these application programs can be noted on the display screen (e.g., \u201cX\u201ds can be drawn through the icons ). An attempt to launch such an application program can trigger a message indicating that the user is not authorized to use the application.",{"@attributes":{"id":"p-0106","num":"0109"},"figref":"FIG. 7","b":["10","20","30","32","34","36","40","1","80","10","20","32","32","32","10","82","84","10","20","85"]},"In step , the application server  establishes a connection with each other servers ,  and  to exchange application-related information, as described above, corresponding to application programs hosted on those servers (step ). In step , the application server  develops and maintains a database of the collected application-related information. Each other server , ,  in the server farm can develop a database equivalent to the database of the server  and in similar manner as the server . In another embodiment, the database of the server  can be a centralized database that is accessible to each other application server , ,  in the server farm. The collecting of application-related information can occur independently or be triggered by the request of the client node ,  to log-on to the server farm .","In step , the client node ,  can request execution of an application program from the desktop display. The master server node can process the request and, using a load-balancing evaluation and application availability as described above, determine the application server to provide the service to the client node ,  (step ). For example, the application server  can be selected to service the request with the client node , . In step , the client node ,  establishes a communications link with the server . The server  and the client node ,  can communicate according to the ICA protocol appropriate for that client node as described above.","Also in response to this request to run the application program, the master server node  or the server  can run the Program Neighborhood application (step ) and push the results to the client node , , although the client node ,  may not have requested the PN application program. When executing the PN application program, the master server node  or server  filters the application-related information in the database using the user credentials (step ). The result of filtering the database determines those application programs that are authorized for use by the user of the client node , . The authorized application programs are in the program neighborhood of the client node , . This program neighborhood of available application information is pushed to the client node ,  (step ) and displayed on the client screen ,  in a Program Neighborhood graphical window (step ).","In other embodiments, the Program Neighborhood window may include applications that are in the server farm but unavailable for use to the client node , . In a Windows-based implementation, the available (and unavailable) application programs can be represented by icons. The user of the client node ,  can select and launch one of the application programs displayed in the Program Neighborhood window.","The present invention may be provided as one or more computer-readable programs embodied on or in one or more articles of manufacture. The article of manufacture may be a floppy disk, a hard disk, a CD ROM, a flash memory card, a PROM, a RAM, a ROM, or a magnetic tape. In general, the computer-readable programs may be implemented in any programming language. Some examples of languages that can be used include C, C++, or JAVA. The software programs may be stored on or in one or more articles of manufacture as object code.","While the invention has been shown and described with reference to specific preferred embodiments, it should be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as defined by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention is pointed out with particularity in the appended claims. The above and further advantages of the invention may be better understood by referring to the following description in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 3A","b":["3","3"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3D"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
