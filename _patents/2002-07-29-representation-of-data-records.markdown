---
title: Representation of data records
abstract: A computerized method for representing a data record comprising: querying a data source to obtain data selected from the group consisting of a data element in a record, and metadata concerning the record; presenting in a display a record handle for manipulation of the record; presenting in the display a data item wherein the data item is a list of data items or a reference to another record; and, optionally, presenting on the display the metadata above the data item. In some embodiments, the method includes the step of retrieving one or more heterogeneous records from a plurality of databases for display and manipulation. The invention is also a grid control programmed to implement a disclosed method and is a computer-readable medium having computer-executable instructions for performing a disclosed method. The invention links the grid control of the invention with automatic query generation using hierarchical data schema trees. Both the trees and the grid records represent relational foreign keys as extra reference columns. In the grid control, these reference columns are additional embedded record handles.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07461077&OS=07461077&RS=07461077
owner: 
number: 07461077
owner_city: 
owner_country: 
publication_date: 20020729
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","WORKING EXAMPLE"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/309,251, filed Jul. 31, 2001, the disclosure of which application is incorporated by reference as if fully set forth herein.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyrights whatsoever.","Not Applicable","The present invention relates to the processing of information. In particular, the invention relates to the representation of data on the screen of a computer or similar device.","Background art systems typically use three approaches for representation of data residing in a database on the screen of a computer or similar device: grids, forms and reports. In a simple example, if one wanted to query a database about families, one would have to pose the query in some way. For example, one might have a window into which could be typed a Standard Query Language (SQL) query, such as:\n\n","The results of such a query would typically be displayed in a grid as shown at  in . This grid is an area containing data records of the same type, with column header labels displayed at the top of the grid.  shows background art grid control  containing a representation on a display of the result of a join between the two tables, \u2018Dad\u2019 and \u2018Kids,\u2019 and a selection on the name of the parent, as shown in the SQL query presented above. One having ordinary skill in the art would know that a grid control has an outer frame . It may be possible to resize and move this frame around the screen. The contents of the grid control are a number of cells of various types arranged into a grid. The contents within the frame are usually scrollable up and down and side to side when the total data contents do not fit entirely within the bounds of the frame, but this aspect is not shown here. In software applications involving access to databases, it is common for the top cells of a grid to contain the names of the columns of the table in the database being queried. This is shown in top cells  through  which contain the column names qualified with their table name. Below this header row are the data cells, such as data cell .","Referring to , the result of the query on two relational tables \u2018Dad\u2019 and \u2018Kids\u2019 is shown. The \u2018Dad\u2019 table has two columns: \u2018name\u2019 which contains the text of a father's name, and \u2018id\u2019 which is the primary key for the record and has no other function. The \u2018Kids\u2019 table has two columns: \u2018name\u2019 which contains the text of a child's name and \u2018parent\u2019 which acts as a foreign key to relate a particular child to his or her parent. Thus, the \u2018Dad\u2019 table is a master table, and the \u2018Kids\u2019 table is a detail table. The two are related by a primary key\/foreign key pair. The data shown in  are used herein to illustrate many points about relational data. One having ordinary skill in the art would understand that the query result contains data from two \u2018Dad\u2019 records whose primary keys are 1 and 2. These two records are joined with the \u2018Kids\u2019 records whose \u2018parent\u2019 fields refer to one of the two \u2018Dad\u2019 records.","It is common in background art database software applications for the header row to be operative to activate manipulation of the data displayed below it. For example, pointing at a cell in the header with cursor  may enable one to manipulate the data by dragging and dropping with the mouse. Furthermore, it is often the case that columns can be resized or moved. In the case illustrated in , the column \u2018Kids.name\u2019 has been selected and the mouse has been right-clicked. This has the effect of displaying on the screen a menu of action options that are possible for the selected cell.","It is also common in the background art for data cells within grid controls to present menus of action options. Those having ordinary skill in the art will know that, depending on the cell that has been chosen, the action options vary. For example, in the case of data cell , it makes no sense to sort the contents of a single cell. However, for selected cell , the cell is a column header that represents the whole column. Menu of options  is specific to that column. In this case, sorting is a sensible option. If the user selects a \u2018Sort\u2019 option, all of the rows will be sorted so that the contents of each row is unchanged but the rows are sorted in the order specified for the selected column. In background art database interfaces, it is usual for the column header cells to have more options available to them than other kinds of cells. No background art reference discloses an invention that permits the selection of a data cell to offer the action of joining the cell to further unfetched (unretrieved) data within the database.","In background art user interfaces, often there is also a cell that does not contain data to the left of each row of data. A cell like this, such as cell , may also have options available to it when selected, such as hiding the row, or increasing its depth to show several lines of text. No background art reference discloses an invention that increases the functionality of this cell to the left of the record  or allows it to occur in other parts of the grid.","In recent years, editing of elements of data presented in grids has been supported in background art grid controls. In this case, the changed data are either saved as a group or various means are used to co-ordinate changing of the value on the screen with updating the underlying data in the database.","In the example given above, the five entries for a parent of name \u2018Nick\u2019 represent two parents. It will also be noticed that the \u2018Dad.id\u2019 column  and \u2018Kids.parent\u2019 column  hold essentially a form of meta-data. These meta-data join the real data together. The Dad.id does not tell the user anything about the Dad. Both of these problems, repeated data and meta-data are features of relational databases. All database systems use meta-data, but the relational system treats it as if it were real-world data.","For parts of software applications that typically manipulate one record in a master table and several in detail\/child tables of the current record, it is common in the background art to use a forms approach, but recently, background art hierarchical grid controls have been developed. These allow a master-detail relationship to be displayed in a grid control. Examples are MSHFlexGrid from Microsoft Corp, Redmond, Wash., and UltraWinGrid from Infragistics Inc of Cranbury, N.J. Referring again to , background art hierarchical grid  is displayed. Grid  is displaying the same data as grid . The values in cells  and  replace the first three rows of \u2018Dad.name\u2019 column  and \u2018Dad.id\u2019 column , in background art grid . These two values constitute a master record, which is related to three detail records ,  and . The detail records only appear if first-detailed records expansion node  for the master record is expanded. In the case of the second master record, second detailed records expansion node  is contracted (indicated by a \u2018+\u2019 sign), so there are no tree lines , and the detail records are not displayed. Nodes  and  can be expanded or contracted independently, and when contracted the master rows move closer to occupy the vacated space. Existing art hierarchical grids are typically linked to hierarchical datasets, such as those provided by ADO from Microsoft. For datasets in which a master record has two different detail record sets, existing art hierarchical grids are not capable of expanding and contracting different detail record sets for the same master record independently. However, existing art hierarchical grids solve the problem of repetition of data from the master table.","Forms have an important role to play in limiting users' access to subsets of the total data in the database, and to guide users through data input processes. In the relational database model, forms are usually used to present data that does not fall nicely into a tabular output. The fact that the same parent has more than one child is represented by having different areas of the form containing single items and lists. However, it would be advantageous to be able to replace some forms applications with a grid control of the present invention accessing a relational database via a standard interface of the present invention. As the grid control and relational database interface are generalized for any relational database schema, no programming effort would be required.","The present invention can handle many different data models, but this disclosure concentrates on object and relational data models. In the object model, a data record is called an object, and is identified by a unique object identifier (OID). This is like having an extra column in the equivalent relational record, but the OID is meta-data that cannot be modified by the user, and is usually not displayed. The object is usually of a type or class, which replaces the table of the relational model. In this disclosure, objects are referred to as being of a certain type. Types have a name and a list of attributes. The attributes are roughly equivalent to columns. The attributes have attribute types such as number, character string, binary large object (BLOB), in the same way as columns have data types.","The value of the attribute within a given object is called a data element throughout this section of the disclosure, although elsewhere the value is sometimes also called an attribute. Attributes can be multi-valued, which means the value of the attribute in a given object can be an array or list of data elements, whereas in the relational model the value must be single-valued. In a list, the order is not important, whereas in an array the position of the element in the list is important. The OID value of one object can be stored in a data element of another object, so the second object can refer to the first object. This is described in U.S. Pat. No. 5,615,367 and is a common practice in background art databases.","Some background art databases require, that for a given reference attribute, the data element must always point at an object of the same type. Less strict systems do not impose this limitation. The model used in this disclosure is the latter, but does not rule out the former.",{"@attributes":{"id":"p-0019","num":"0019"},"figref":["FIG. 3","FIG. 2"],"b":["501","502","503","518","501","502","503","504","505","506","501","507","508","511","512","513","514","515","516","501","502","504","505","206"]},"\u2018Cars\u2019 attribute , and \u2018Homes\u2019 attribute  are multi-valued attributes. They store references to other objects. The value stored at (reference) value  in the \u2018Cars\u2019 attribute is the OID of an object of type \u2018Car\u2019. This referenced object is shown at \u2018car\u2019 object . Although the value for object  has only one element, the \u2018Cars\u2019 attribute is multi-valued as will be seen later. \u2018Homes\u2019 attribute  is also multi-valued, and for first \u2018family\u2019 object  has two elements with values 5 and 6, which are the OID's of two objects not shown here.","In the object data model presented here, OID's are similar to primary keys in the relational model, and references are similar to foreign keys. The relational system does not support multi-valued fields.","The object data shown in this disclosure is ideally suited to the visual elements used in the present invention. The unit for grouping data on the screen is called a record in this disclosure. The object data used in the disclosure can be represented with one record per object. Although the attributes in these objects may be multi-valued, the elements are always atomic. This means that they are things like numbers, strings of text or single blocks of binary data that have no internal structure (as far as the database is concerned). There are object and semi-structured data models (as well as object-relational databases), which allow elements in single-valued or multi-valued attributes to consist of a series of sub-attributes. In some cases an attribute can itself contain a type. In these cases a single record on-screen is not capable of representing a single object or record of the underlying data model. The present invention maintains a common visual interface in these cases by treating this kind of data as containing lists of references, even though these references are to data within the object, rather than outside it. This will be covered in more depth later.","The background art of the present invention is characterized by U.S. Pat. Nos. 5,495,567; 5,546,526; 5,615,367; 5,657,460; 5,692,175; 5,729,730; 5,745,891; 5,835,683; 5,848,424; 5,873,079; 5,884,304; 5,884,306; 5,918,225; 5,940,818; 5,966,704; 5,995,984; 6,009,432; 6,014,138; 6,016,497; 6,081,801; 6,085,202; 6,108,651; the disclosures of which are incorporated by reference as if fully set forth herein.","Iizawa et al. in U.S. Pat. No. 5,495,567 disclose an automatic interface layout generator for database systems. This invention is limited in that it focuses on automatic layout generation.","Li et al. in U.S. Pat. No. 5,546,526 disclose a system for reconfiguration of a database by interactive manipulation of icons. This invention is limited in that it teaches re-grouping of columns in databases.","Bennett et al. in U.S. Pat. No. 5,615,367 disclose a system for automatic linking of tables for improved relational database modeling. This invention is limited in that it addresses only forms and not grids.","Egan et al. in U.S. Pat. No. 5,657,460 disclose a system for storing and displaying data. This invention is limited in that requires display of a visual representation of the object whose data are being displayed.","Davies et al. in U.S. Pat. No. 5,692,175 disclose a system for accessing and analyzing data. The invention is limited in that it applies only to large-scale entities such as databases, filters and report generators and does not concern individual data records.","Wlaschin et al. in U.S. Pat. No. 5,729,730 disclose an information storage and retrieval system. The invention is limited in that it does not teach visual representation of data.","Minakuchi et al. in U.S. Pat. No. 5,745,891 disclose a data search apparatus. The invention is limited in that it concerns highlighting portions of data that are to be displayed at certain locations on a display screen.","Corella et al. in U.S. Pat. No. 5,835,683 disclose a system and method for authoring an expert system. The invention is limited in that it calls for all displayed data to be contained within a single interaction cell that is not visible at runtime.","Scheinkman et al. in U.S. Pat. No. 5,848,424 disclose a data navigator interface with navigation as a function of draggable elements and drop targets. This invention is limited in that it requires dragging and dropping actions on the part of the user.","Davis, III et al. in U.S. Pat. No. 5,873,079 disclose a filtered index apparatus and method. This invention is limited in that does not teach visual display of data.","Davis, III et al. in U.S. Pat. No. 5,884,304 disclose an alternative key index query apparatus. This invention is limited in that does not teach visual display of data.","Bliss et al. in U.S. Pat. No. 5,884,306 disclose a system and method for directly manipulating fields for grouping items on a display. This invention is limited in that it teaches only the grouping of existing data in categories.","White et al. in U.S. Pat. No. 5,918,225 disclose a SQL-based database system with an improved indexing methodology. This invention is limited in that it teaches storing data vertically instead of horizontally.","Malloy et al. in U.S. Pat. No. 5,940,818 disclose attribute-based access for multi-dimensional databases. This invention is limited in that it concerns n-dimensional data.","Furegati et al. in U.S. Pat. No. 5,966,704 disclose storage systems based on the concept of storage plane organization. This invention is limited in that it teaches organizing data in storage roughly in order of data entry.","Lau et al. in U.S. Pat. No. 5,995,984 disclose an apparatus and method for zoom-in entry of a element in a table. This invention is limited in that it teaches switching between a forms-based representation and a grid-based representation of data on a display.","Tarin in U.S. Pat. No. 6,009,432 discloses a value-instance-connectivity database. This invention is limited in that it concerns only database storage techniques.","Cain et al. in U.S. Pat. No. 6,014,138 disclose a visual programming development system. This invention is limited in that it teaches the storage of OID's in columns.","Suver in U.S. Pat. No. 6,016,497 discloses a method and system for storing and accessing embedded information in object-relational databases. This invention is limited in that it teaches only access and storage of data.","Cochrane et al. in U.S. Pat. No. 6,081,801 disclose shared nothing parallel execution of procedural constructs in SQL. This invention is limited in that it applies only to a parallel-processing environment.","Rao et al. in U.S. Pat. No. 6,085,202 disclose a method and system for producing a table image having focus and context regions. This invention is limited in that it concerns n-dimensional data.","Guha in U.S. Pat. No. 6,108,651 discloses heuristic co-identification of objects across heterogeneous information sources. This invention is limited in that teaches joining tables in different databases using metadata.","In summary, no single reference or combination of references teaches the novel aspects of the present invention. There still exists a need for improved functionality in an devices and methods for representing and managing data.","The purpose of the invention is to provide an apparatus and method for representing and managing data. The present invention concerns the visual representation of a data record on any screen or display. It also concerns the constituent graphical elements of the data record, icons representing a join between data records, use of a grid control for handling the organization of these records and icons, and ways of programming the records, graphical elements and grids for effective data access and modification. In preferred embodiments, the present invention provides means for representing data records (e.g., grids) that involve use of a record handle, drop-down lists and icons to represent joins. The present invention also deals with new ways of using hierarchical data trees to represent data schemas and to generate data queries.","Preferred embodiments of the present invention enable data to be displayed that does not conform to the standard tabular format of a given number of rows each having the same number of columns. The record handle allows management of updating the database with changes that have been made to the on-screen representation of data. It also allows a user to remove the data that are not required from the screen. The embedded record handle that represents a reference within an existing on-screen record allows the user to fetch the record that the reference refers to. This enables data navigation from a grid control environment. The further ability to create a join, represented by a join icon on any data element(s) on the screen allows very flexible navigation, because the data to be joined with are decided at run-time. Because heterogeneous data are allowed, the data that are navigated to can be brought back and displayed on the same window as the starting point of the navigation. This has advantages over web-style navigation, wherein the user has to leave one piece of data to go to another. In existing art database applications, navigating from one piece of data to another is usually performed using forms programming. In contrast to forms programming used with background art databases, the invention allows a uniform interface to databases. In further contrast to background art forms programming, a software application can be designed without knowing the schema of the database(s) to which the database(s) are to be interfaced. Moreover, common master-detail relationships in relational databases can be displayed in a way that is easy to understand without any programming effort. In contrast to background art forms programming, list-items can be edited in position rather than at the top of a combination list. By providing a combination of mixed data classes and a granularity of one record for saving data, the user can access all the data he\/she is interested in from the same window. In contrast to background art grid programming data from, different types of database can coexist in the same grid. In contrast to forms programming, the user can decide the flow of navigation at run-time with great flexibility.","Preferred embodiments of the present invention extend the concept of a grid control to non-tabular data including references and multi-valued attributes. Traditionally, references and multi-valued attributes were handled in a forms environment. Preferred embodiments of the present invention simplify the representation of relational data, object-relational data or object data, or semi-structured data by using only four extra visual elements: the record handle, list handle, join icon and the drop-down list. The present invention also allows the display of heterogeneous data\u2014data of different types and with different numbers of fields can be mixed in the same display. Using a simple display format, complications in the data model are not reflected in the on-screen representation. This provides the visual representation a general applicability. With preferred embodiments of the present invention, visual representation of data that is the result of inheritance does not differ from representation of other kinds of data. Thus, the visual representation does not have to be as complicated as the underlying data.","The invention also deals with the use of hierarchical trees to represent data schemas. A data schema is the information describing what kinds of records, tables and objects the database currently stores. In the simple example of the relational system, one part of the schema would detail the names of the tables and the names and types of fields within a given table. Where references are implemented between records in one table and another via primary-key\/foreign-key pairs, or where an equivalent linking of references in object databases between an attribute in one type of object and objects of a specific type exists, descriptions of these references would also form part of the data schema. Typically in a relational system, the data in the schema about foreign keys are displayed separately from the data about the columns or fields within a table. In the current invention, the foreign keys are represented as expansible extra columns. By displaying the foreign keys in the same part of a hierarchical data schema tree as the columns, the user is helped to generate queries on the data, particularly those involving joins.","In preferred embodiments, the screen or display of the present invention is associated with a computer, a Wireless Applications Protocol (WAP) telephone, an interactive digital television (IDTV) or any other device with a screen and a means for the user to interact with the data contents of that screen or display. The grid control of the present invention may form part of an Internet browser, or a plug-in to an Internet browser, or the records and\/or join icons can be displayed in such a browser without use of the grid control.","Preferred embodiments of the present invention further include software packages containing a grid control and records and join icons of the present invention. These software packages comprise database software applications which illustrate how the preferred embodiments of the grid control and records of the present invention improve usability compared with existing art software packages.","In a preferred embodiment of the present invention, the unit of data granularity on the screen is the record. Preferably, each record has a visual element called a \u2018record handle\u2019, which is used to move between the various stages of data retrieval, editing, saving, closing and removing records from the screen. The \u2018record handle\u2019 is an extra field which stands for (represents) the whole record. In object databases, it stores the OID of the object that the record is representing. For other data models, it can store other means of locating the data in the database, such as a primary key. It tracks the state of the record from newly keyed-in to saved, to modified, to closed or deleted.","In a preferred embodiment, the invention is a computerized method for representing data on a display, the method comprising: querying a data source to obtain data comprising a first data record; presenting the first data record on the display as a data field; and presenting on the display a record handle for manipulation of the first data record; wherein the data field is selected from the group consisting of a single data element, a list of data elements, and a reference to a second data record; wherein the record handle is a visual element that represents the first data record and that is operative to track and control the state of the first data record.","In a computer system having a memory and a graphical user interface including a display and an input device for use by a user, a preferred embodiment of the invention is a method of displaying and manipulating data in a first data record stored in a database residing in said memory, the method comprising: retrieving said first data record from said database, said first data record having at least one data element; displaying a record handle having a state on the display wherein said state is selected from the group consisting of (1) a save state that is displayed after the at least one data element has been entered or changed by the user and in which state said record handle is operative to save to the database all the data elements in the displayed first data record, (2) a close state that is displayed after the at least one data element has been saved by the user and in which state said record handle is operative to remove all the data elements in the first data record from the display, and (3) a get state that is displayed after the data element is removed from the display and in which state said record handle is operative to refresh all the data elements in the first data record on the display; and displaying the first data record on the display as one or more data fields; wherein said record handle is a visual element that represents the first data record and that is operative to track and control said state.","In another preferred embodiment, the invention is a computer-readable medium having computer-executable instructions for performing a method, the method comprising: displaying a data field at a first location on a screen, said data field containing a data element of a first data record; and displaying a record handle at a second location on the screen, said second location being horizontally in-line with said first location and said record handle being operative by a user to save the data element to a memory after it has been changed by the user; wherein said record handle is a visual element that represents the first data record and that is operative to track and control the state of the first data record.","In a further preferred embodiment, the invention is an apparatus for representing data on a display, the apparatus comprising: means for querying a data source to obtain data comprising a first data record; means for presenting the first data record on the display as a data field; and means for presenting on the display a record handle for manipulation by a user of the first data record, said record handle being operative to track the state of said first data record and being capable of performing actions on said first data record; wherein the data field is selected from the group consisting of a single data element, a list of data elements, and a reference to a second data record; wherein said record handle is a visual element that represents the first data record and that is operative to track and control the state of the first data record.","In preferred embodiments, the record handle can be selected by a user in several ways. Depending on the embodiment, record handle selection may be by speech activation, keyboard input or use of the mouse. In a preferred embodiment, selection is by clicking the mouse in one of three ways: single click on the left button\u2014known as single-click, double-click on the left button\u2014known as double-click, and single click on the right button\u2014known as right-click. For brevity, these selections are referred to in this disclosure as single-clicking, double-clicking or right-clicking, although, as explained above, other input devices may be used. Preferably, the current default action of the record handle is selected by a single-click, and, in preferred embodiments, the name of this action is displayed as text on the handle. Preferably, a right-click on the handle reveals a pop-up menu with a list of the names of other possible actions of which the record handle is capable. These actions can also be supplied by software application programmers. An action can modify the default action and action list, thus enabling the record handle to go through a series of states adapted to the data it is being used to manage.","In preferred embodiments, the other graphical elements of the present invention are also capable of default actions and action lists. A record on the screen consists of a record handle (whose display item is a single-valued reference), followed by a series of data fields. The types of data fields include: single-valued reference field, reference list, single-valued text field and multi-valued text field.","In addition, in a preferred embodiment, a row on the screen may also contain the representation of a join. The data fields, reference fields and the join are collectively described as display items. The graphical elements representing these fields and joins include: record handle, list handle, single-valued text cell, multi-valued text cell and join icon. The present invention also allows for the creation of new data field types and associated graphical element types. In a preferred embodiment the join is only displayed for joins not being related to primary key\/foreign key relationships.","In preferred embodiments, the data fields of the present invention are represented by graphical elements. A normal text or numeric data field, for example, is represented by a single text cell similar to one on a background art spreadsheet or database. Text can be edited within the cell. Upon editing, the change in the contents of the cell is noted by the cell, and the cell informs its record handle. Usually, the record handle sets its default action to \u2018Save\u2019 at this point, because the data on the screen is different from that in the database. If the record handle's \u2018Save\u2019 action is now selected, the procedure supplied for that action for that particular record handle is performed. The procedure saves the data to the database that the record is stored in, in a way suited to that database.","In a preferred embodiment, fields in the record can be multi-valued. A multi-valued text field contains a multi-valued version of the normal text or numeric data field described above. This field is represented by a list of cells starting at the current row and displaying subsequent cells below the first one. These cells are called multi-valued text cells, although individually they only contain one value. These cells can be edited in the same way as the single-valued text cells in contrast with existing art combination list boxes which select from a list but edit in a list box at the top of it, but the list is capable of being contracted to occupy the space of a single cell on the top row by double-clicking any of the elements. In a preferred embodiment, double-clicking on a contracted list re-expands the list to display all elements in it. The lists can either overlay data records below them or push them down. Thus, the multi-valued text cell is similar to a single-valued one except for its action following a double-click.","In a preferred embodiment, fields in the record can be references, that is, the fields can refer to other data records. Reference fields are displayed as record handles. When a record containing a reference is displayed on the screen, the record handle representing the reference field may refer to data that is not yet on the screen. In this case, the default action of the reference's record handle is \u2018Get\u2019. The \u2018Get\u2019 action retrieves the referenced data from the database and expands it inline on the screen starting at the reference's record handle. Subsequent fields in the existing record that contained the reference are displaced to the right to accommodate the new data.","In a preferred embodiment, the record handle controls the behavior of the data record, not the display row. If there are joined records or records of expanded references, the actions of the record handle do not normally extend to these. For example, a \u2018Save\u2019 action on a record handle does not normally save changes to data within another record in the same row that was fetched as an expanded reference.","In another preferred embodiment, fields in the record can be lists of references. In the expanded form of the list, the display consists of a vertical list of record handles. In the unexpanded form, a graphical element called a list handle is displayed. The default action of this element is to expand the list, hence causing the list handle to disappear.","In a preferred embodiment, records of the present invention may be displayed within a grid control. This grid control is a scrollable area capable of controlling the display of records and headers within it.","In a preferred embodiment, a data row has an optional header. If a header is required, the grid control is capable of displaying a header above the data records and joins within the row.","In contrast with background art database GUI's, the grid control of the present invention is designed to display heterogeneous data\u2014data of differing types with different number and types of fields\u2014in the same area. This support of heterogeneous data increases user productivity, and extends the types of query the user can run on data. Preferably, the grid control has sufficient intelligence to manage the display of a single header row over a series of data records that are of the same type or whose fields match, but to insert a new header when the data being displayed on the next row changes.","If the action of a record handle modifies the layout of fields on the screen, such as expanding a reference in-line, the grid control has sufficient intelligence to adapt the header to the changed data below it, inserting labels into the header and potentially inserting new header rows between records that previously were of the same format but now differ. In other cases, the header rows may removed as either the row above changes to become like the row below or vice versa. In cases where the data differs between rows of records that are the result of expanding references in a reference list, in a preferred implementation header sub-rows are introduced with act as headers for these records.","In a preferred embodiment, the grid control controls the display of the data fields and joins. For example, if a record on one row is removed from the screen by selecting its \u2018Close\u2019 action, the subsequent records are moved upwards to take up the space.","Preferred embodiments of the present invention bring listing and navigating capabilities of the forms environment to the grid, but without the extensive programming required for forms. They also bring a common visual representation for relational and non-relational databases.","A preferred embodiment of the present invention can be used with both relational and non-relational databases. In the relational database case, it provides easier navigation between records in relational database tables related by primary key\/foreign key links. In \u2018native\u2019 format, it allows interfaces to object databases including those which represent the entity-relation model without breaking them down using relational normalization. It achieves this by providing visual analogs to references and to multi-valued elements of objects. Thus, the data model used is even more flexible than the entity-relation model.","In a preferred embodiment, data input and retrieval can take place in a mixed record-type format. Thus, a user does not need to change windows to input two different types of record. Similarly, data retrieval is sufficiently flexible to select data that is of different types. These types may be linked by similar data somewhere in their data fields.","Records within the same grid may even be from completely different kinds of datasource. In a preferred embodiment of the present invention, a relational record could coexist with an XML record. The \u2018Save\u2019 action on the record handles of these two records would call radically different callback procedures. The former might send a command via ODBC to a data-source, while the latter may send the modified data to an internet web servlet. Thus, the invention has the advantage of using a consistent visual interface, rather than requiring a consistent underlying data model. Existing art grids usually link to a standardized data source.","In a preferred embodiment of the present invention, a selection of data from a single table in a relational database is displayed as rows of records. Each row starts with the record handle, followed by the contents of the columns in the table displayed in single-valued text cells. A selection of data from a relational database using an SQL query containing a join can be displayed in the same way, but in this case the programming of the interface between the grid control becomes more complicated. It may not be possible to modify data in these records and save them, as the data record on the screen spans two tables in the database. The display produced by a normal join that uses a primary key\/foreign key pair, often called a natural join, usually contains repetition of data that comes from a single field in the database. To improve the display and action, the user may use the object display mode of the present invention. In this mode, fields belonging to the table on the right are given a second record handle. The handles store the primary key information required to save the records to the relational database. If the SQL query did not contain this primary key, the preferred embodiment of the grid control\/RDBMS interface of the present invention adds the required columns to the query before sending it. These extra columns are not displayed, but the primary key information is stored. The object display format displays a join query between a master and detail table in such a way that the same record in the master table only occurs once (unless sorting requirements of the query disallows this). Preferably the present invention displays foreign keys as references, that is as record handles appended to the data in a relational record. If the join is a natural one, the record handle representing the relevant foreign key is expanded inline with the data from the related table. Foreign keys in a detail table are displayed as single references in the detail table itself. Foreign keys in a detail table map to lists of references in the master table. In the latter case, the foreign key is represented by a vertical list of reference handles. The records from the detail table that match the current master table are displayed one below the other. It is noted that this format is appropriate for many common reports. Whereas one of the goals of the relational method of organizing data was to reduce data duplication in storage, it increased duplication in query output. The object display format reduces this duplication. Once in the object display format, the data can be modified and written back to the database. These gains in formatting and elimination are also present in existing art hierarchical grids.","Because, in a preferred embodiment, the grid control of the present invention is designed to display heterogeneous data, it can be used with non-standard extensions of the SQL language that allow queries to be run on relational databases that return heterogeneous data. The non-standard queries can be processed by the preferred embodiment of the grid control\/RDBMS interface of the current invention to break them down into more than one standard SQL query. Post-processing of the results returned allows operations such as sorts to be performed on fields in the combined data from all of the queries, leading to heterogeneous data sorted according to common criteria.","In a further embodiment of an interface between the grid control of the present invention and a relational database, metadata which groups relational tables by means of primary and foreign keys into larger entities is stored in the interface between the RDBMS and the grid. The primary and foreign key columns from the relational tables used to create the attributes of the larger entity are hidden where appropriate. The larger entities may be displayed as single records on the screen. Foreign keys not involved internally in the combined entity may be represented as reference attributes as shown above. In this way, the grid control can be used to display entities in the format that they were designed in before they were normalized to conform to the relational model.","In a further embodiment, an interface of the present invention between the grid control of the present invention and an object database is provided that causes the programming of the interface to become trivial for objects that are retrieved and saved using an OID.","In a preferred embodiment, one copy of the grid control is incorporated into the main Data Processing window of a preferred embodiment of the present invention. There are two other windows in this preferred embodiment, the New Type window which allows selection of different or new types of data, and the Data Retrieval window, which is used to select new data in graphical ways as well as using queries in standard or extended versions of SQL. The Data Retrieval window contains another grid control, in which sets of selected data can be refined or augmented before returning to the Data Processing window. The Data Retrieval and New Type windows have tree hierarchies of data types and their attributes organized in novel ways.","A preferred embodiment of the present invention uses a graphical element called a join icon to represent relational and other joins between data. In the case of natural joins in a relational database, this icon is preferably redundant, as the join already centers on the pivotal role of the record handle that acts as a field in the master table record and also as the record handle for the detail record. In a preferred embodiment, a join icon can be created to be associated with existing data in the grid. Graphical elements representing data can be selected singly or in groups. If the action \u2018Join\u2019 is then selected, the selected data forms the left-hand side of a join. Each resulting data element has a join icon displayed alongside it and the Data Retrieval window is then used to complete the right-hand side of the join by selecting data attributes to join with the selected items.","In a preferred embodiment, the grid control is designed to receive logical display items which represent parts of the record to be displayed. By separating these display items themselves from the graphical elements that represent them, and by allowing actions to be added to the display items at run-time, new display item types, such as for multi-media data, can be created simply in preferred embodiments of the invention. New actions and new versions of existing actions can be defined to interface the graphical elements representing the record to different types of underlying data.","Preferred embodiments of the present invention uses database queries that rely on extensions of the Standard Query Language (SQL). Some of the extensions are already in use, as a review of U.S. Pat. Nos. 5,884,304 and 6,016,497 reveals. The extensions are explained as they occur. Note, however, that whereas the SQL language is designed for relational databases, the extensions are useful in both relational and non-relational contexts.","Recent attempts have been made to develop replacements or extensions of the SQL language which incorporate such features. For example, Davis, III et al. describes some extensions in U.S. Pat. No. 5,884,304 that were developed by the Department of Computer Science at Stanford University, CA. Note, however, that the data model of the Lorel language is more complicated than that used in preferred embodiments of the present invention.","In preferred embodiments, the enhanced replacement to cell to the left of the record  is called a \u2018record handle\u2019, preferably, but not necessarily, lying to the left of data records. The handle may exist anywhere within the data grid, thus allowing an object style of data access. The object style of access does not require an object-based underlying database. The present invention also brings advantages to data access to relational database systems. Its uses are not limited to use with these types of database, as it supports either rigid or very loose underlying data structures. A requirement of preferred embodiment of the invention is as follows: if there is a requirement to modify the data on-screen and save it back to the database, sufficient data must be maintained in the grid or the record itself to allow the data to be saved.","A preferred embodiment of the invention is a computerized method for representing data on a display, the method comprising: querying a data source (e.g., a database or an XML document) to obtain data comprising a first data record; presenting the first data record on the display as a data field; and presenting on the display a record handle for manipulation of the first data record; wherein the data field is a list of data elements or a reference to a second data record. Preferably, the data obtained during the querying step further comprises metadata concerning the first data record and the method further comprises: presenting on the display the metadata as a label in a header above the data field. Preferably, the vertical list of data elements is presented in a format such as a single data element in the list, a list handle that is operative to present all the data elements in the list, all of the data elements in the list, or a new field that is operative to allow the user to add a data element to the list. Preferably, the reference to the second data record is presented in one or more of the following formats: a get handle that is operative to display a second data element in the second data record on the same line upon which the get handle is displayed wherein the displayed record handle is not operative to save data to the second record, or a second record handle and the data element in the second data record. In preferred embodiments, the metadata that is obtained comprises a first data record type and a first data element name.","In a computer system having a memory and a graphical user interface including a display and an input device for use by a user, a preferred embodiment of the invention is a method of displaying and manipulating data in a first data record stored in a database residing in said memory, the method comprising: retrieving said first data record from said database, said first data record having at least one data element; displaying a record handle having a state on the display wherein said state comprises a save state that is displayed after the at least one data element has been entered or changed by the user and in which state said record handle is operative to save to the database all the data elements in the displayed first data record, a close state that is displayed after the at least one data element has been saved by the user and in which state said record handle is operative to remove all the data elements in the first data record from the display, or a get state that is displayed after the data element is removed from the display and in which state said record handle is operative to refresh all the data elements in the first data record on the display; and displaying the first data record on the display as one or more data fields. In preferred embodiments, the method further comprises: displaying on the display a header comprising one or more names wherein said one or more names is a type name for the type of the first data record, and a data element name for the at least one data element. In another preferred embodiment, the first data record comprises more than one data element and displaying the first data record on the display comprises displaying a display item comprising of a single-valued data field, a multi-valued data field, or a reference to another data record. Preferably, the method further comprises: retrieving one or more heterogeneous records from a plurality of databases for display and manipulation. In preferred embodiments, the at least one data element comprises character data or binary data. Preferably, method further comprises: displaying on the display a retractable multi-valued data field as a list handle that is operative to display on the display each individual data element comprising the multi-valued data item in a drop down list. Preferably, the method further comprises: displaying on the display a reference data field of the first data record that refers to a second data record as a second record handle having a get state that is operative to display on the display the second data elements of the second data record on the same line upon which the record handle having a get state is displayed wherein the record handle of the first data record is not operative to save to the database the second data elements of the second data record; and displaying a third record handle on the display having a new state that is operative to create or link another referenced data record to the first data record. Preferably, the method further comprises: entering a query statement into a user interface element before the retrieving step is executed. Preferably, the query statement is a join statement that is operative to cause a second data record to be displayed on the same line as the first data record, said first displayed data record and said second displayed data record being separated by a symbol and being related in the manner specified in the join statement.","A preferred embodiment of the invention is a grid control programmed to implement a method disclosed herein, the contents of said grid control being accessible by scrolling. Preferably, the grid control is implemented as a Windows component.","In a preferred embodiment, the invention is a computer-readable medium having computer-executable instructions for performing a method, the method comprising: retrieving a data record from a database, said record having a plurality of data elements; displaying a record handle on a display wherein said record handle is a save handle that is displayed after one the data element has been input or edited by a user and that is operative when selected by a user to save all the data elements in the data record to the database, a close handle that is displayed after the data elements have been saved by the user and that is operative when selected by the user to remove all the data elements from the display, and a get handle that is displayed after the data elements are removed from the display and that is operative when selected by the user to refresh all the data elements on the display; and displaying the data elements on the display wherein each one of said data elements is a null data element, a character or numerical data element, a list or array of data elements, or a reference to another data record. Preferably, the method further comprises: at the option of the user, displaying on the display a header line comprising one or more names wherein said one or more names is a type name for the type of the data record, or a field name for the data field.","In a computer system having a memory and a graphical user interface including a display and an input device for use by a user, a preferred embodiment of the invention is an apparatus for displaying and manipulating data in a first data record stored in a database residing in said memory, the apparatus comprising: means for retrieving said first data record from said database, said first data record having at least one data element; means for displaying a record handle having a state on the display wherein said state is a save state that is displayed after the at least one data element has been entered or changed by the user and in which state said record handle is operative to save to the database all the data elements in the displayed first data record, a close state that is displayed after the at least one data element has been saved by the user and in which state said record handle is operative to remove all the data elements in the first data record from the display, or a get state that is displayed after the data element is removed from the display and in which state said record handle is operative to refresh all the data elements in the first data record on the display; and means for displaying the first data record on the display as one or more data fields. Preferably, the apparatus further comprises: means for displaying on the display a header comprising one or more names wherein said one or more names is a type name for the type of the first data record, and a data element name for the at least one data element. Preferably, the first data record comprises more than one data element and the means for displaying the first data record on the display comprises means for displaying a display item comprising a single-valued data field, a multi-valued data field, or a reference to another data record. Preferably, the apparatus further comprises: means for retrieving one or more heterogeneous records from a plurality of databases for display and manipulation. Preferably, the apparatus of claim  wherein the at least one data element comprises character data or binary data. Preferably, the apparatus further comprises: means for displaying on the display a retractable multi-valued data field as a list handle that is operative to display on the display each individual data element comprising the multi-valued data item in a drop down list. Preferably, the apparatus also further comprises: means for displaying on the display a reference data field of the first data record that refers to a second data record as a record handle having a get state that is operative to display on the display the second data elements of the second data record on the same line upon which the record handle having a get state is displayed wherein the record handle of the first data record is not operative to save to the database the second data elements of the second data record. Preferably, the apparatus further comprises: means for entering a query statement into a user interface element before the retrieving step is executed. Preferably, the query statement is a join statement that is operative to cause a second data record to be displayed on the same line as the first data record, said first displayed data record and said second displayed data record being separated by a symbol and being related in the manner specified in the join statement. In a preferred embodiment, the invention is a grid control comprising an apparatus disclosed herein.","In a preferred embodiment, the invention is a computerized method for querying by a user of a non-relational database, said database comprising a data record that comprises a multi-valued attribute and a single-valued attribute, said method comprising: said user submitting a select command to the database, said select command instructing the database to retrieve information concerning said multi-valued attribute and said single-valued attribute; and said database returning a name for said multi-valued attribute, each value of said multi-valued attribute, a name for said single-valued attribute and the single value of said single-valued attribute; wherein said returned data is displayed by means of a grid control disclosed herein.","In a preferred embodiment, the invention is a computerized method for querying by a user of a non-relational database, said database comprising a plurality of data records, at least some of which data records comprising a multi-valued attribute, said method comprising: said user submitting a select command to a database, said select command instructing the database to conditionally retrieve information concerning said plurality of data records, wherein the condition is selected from the group consisting of an any condition that is operative to select any data record wherein at least one of the values of the multi-valued attribute of the selected record is equal to, less than or greater than a given value, and an all condition that is operative to select any data record wherein all of the values of the multi-valued attribute of the selected data record are equal to, less than or greater than a given value; and said database returning information concerning each data record that meets the selected condition; wherein said returned information is displayed by means of a grid control disclosed herein. Preferably, the computerized method further comprises: in the case of the any condition, displaying either the values of all multi-valued attributes in the selected data records or, if the keyword selected is present in the query, only the values of the multi-valued attributes that comply with the condition.","In another preferred embodiment, the invention is a computer-readable medium having computer-executable instructions for performing a method, the method comprising: displaying a data field at a first location on a screen, said data field containing a data element; and displaying a record handle at a second location on the screen, said second location being horizontally in-line with said first location and said record handle being operative by a user to save the data element to a memory after it has been changed by the user. Preferably, the method further comprises: displaying the default action of the record handle on the record handle. Preferably, the method further comprises: upon activation of a menu associated with the record handle by a user, revealing record handle actions available to the user. Preferably, the method further comprises: displaying a multi-valued data field on the screen, said multi-valued data field comprising attributes, said attributes being displayable as a vertical list with each member of the list being displayed in an editable cell and said attributes being contractable into a single graphical element. Preferably, the method further comprises: displaying a header on the screen above the data field, said header comprising a label that describes data field on the screen below it.","In a computer system having a graphical user interface for use by a user, the graphical user interface including a display and a selection device, a preferred embodiment of the invention is a method of providing and selecting from a menu on the display, the method comprising: displaying a first data field consisting of at least one data element on the display; in response to selection of the first data field by the user, retrieving a set of menu entries for the menu, each of the menu entries representing an action to be performed by the computer system on the contents of the first data first; displaying the set of menu entries on the display; in response to selection of a menu entry by the user, receiving a menu entry selection signal indicative of the selection device pointing at a selected menu; and in response to the signal, performing the action on the contents of the first data cell. Preferably, the action is a join action and the method further comprises: presenting on the display a window that contains means for selecting a second data field with which the first data field is to be joined; and in response to selection of the second data field, presenting the joined data on the display.","In yet another preferred embodiments, the invention is a grid control programmed to implement a method disclosed herein, said grid control further comprising: a scrollable area capable of automatically controlling the display of data records and headers within it. Preferably, the grid control is operative to implement the process of moving lower records upward to take up intervening space when a upper data record is closed and moving lower records downward when a list in an upper record is expanded. Preferably, the grid control is programmed to implement the method of displaying data of different types, from different sources, and of different data models, having different numbers of fields, and different width fields all at the same time. Preferably, the grid control is programmed to implement the method of displaying multi-valued reference attributes as lists of record handles. Preferably, the grid control is programmed so that the record handle is capable of implementing a remove action which makes the data field refer to nothing.","In a further preferred embodiment, the invention is an apparatus for representing data on a display, the apparatus comprising: means for querying a data source to obtain data comprising a first data record; means for presenting the first data record on the display as a data field; and means for presenting on the display a record handle for manipulation by a user of the first data record; wherein the data field is a list of data elements, or a reference to a second data record. Preferably, the apparatus further comprises: means for displaying all of the elements in a hierarchical view of a data schema of the data source at the top level of a tree view, even if some of the elements also occur somewhere else in the hierarchy. Preferably, the apparatus further comprises: means for displaying the representations of attributes below the representations of attribute types as well as below the representations of record types on a tree view, by providing that the branches of a tree view extend outward from their sources at different angles to represent different dimensions in the hierarchy. Preferably, the apparatus further comprises: means for displaying a foreign key from a relational database having a data schema as an expansible tree element, thereby allowing for navigation of the data schema via the foreign key. Preferably, the apparatus further comprises: means for navigating through the data schema to represent a join via links across the foreign key which are capable of automatic query generation, or automatic generation of a part of an SQL or other query that uses the foreign keys in its joins. Preferably, the apparatus further comprises: means for presenting the first data record on the display as a first plurality of data fields; wherein at least one of the first plurality of data fields is a list of data elements, or a reference to a second data record. Preferably, the at least one data field is a reference to a second data record that has been expanded horizontally inline within the first record, displacing at least some of the data fields of the first record to the right on the display. Preferably, the apparatus further comprises: means for displaying a plurality of representations of foreign keys relating a first table to a second table in a relational database in a plurality of second data fields in a column in a grid displaying data from the first table, each of the plurality of second data fields comprising a display item selected from the group consisting of a record handle and a list handle, and each of said display items being operative to fetch data from the second table when the display item is selected by the user. Preferably, the apparatus further comprises: means for displaying a foreign key from a relational database having a data schema as an expansible element of a tree, thereby allowing for navigation of the data schema via the foreign key.","In another embodiment, the invention is a computer-readable medium having computer-executable instructions for performing a method, the method comprising: retrieving a data record from a database, said record having a plurality of data fields; displaying a record handle on a display wherein said record handle changes visually to become a save handle that is displayed after one of the data fields has been input or edited by a user and that is operative when selected by a user to save all the data fields in the data record to the database, a close handle that is displayed after the data fields have been saved by the user and that is operative when selected by the user to remove all the data fields from the display, and a get handle that is displayed after the data fields are removed from the display and that is operative when selected by the user to refresh all the data fields on the display; and displaying the data fields on the display wherein each one of said data fields is selected from the group consisting of a null data element, a character or numerical data element, a list or array of data elements, and a reference to another data record; wherein said record handle is a visual element that represents said data record and that is operative to track and control the state of said data record. Preferably, the method further comprises: at the option of the user, displaying on the display a header line comprising one or more names wherein said one or more names is a type name for the type of the data record, or a field name for the data field.","In yet another preferred embodiment, the invention is a computer-readable medium having computer-executable instructions for performing a method, the method comprising: displaying a data field at a first location on a screen, said data field containing a data element of a first data record in a data source; and displaying a record handle at a second location on the screen, said second location being horizontally in-line with said first location and said record handle being operative by a user to save the data element to a memory after it has been changed by the user; wherein the record handle is a visual element that represents the first data record and that is operative to control and continuously track the state of the first data record on the screen and in the data source; and wherein the record handle is operative to indicate to a user a current default action that will be activated when the user clicks on the record handle. Preferably, the computer-readable medium has further computer-executable instructions for performing the method, the method further comprising: displaying the default action of the record handle on the record handle. Preferably, the computer-readable medium has further computer-executable instructions for performing the method, the method further comprising: upon activation of a menu associated with the record handle by a user, revealing record handle actions available to the user. Preferably, the computer-readable medium has further computer-executable instructions for performing the method, the method further comprising: displaying a multi-valued data field on the screen, said multi-valued data field comprising attributes, said attributes being displayable as a vertical list with each member of the list being displayed in an editable cell and said attributes being contractable into a single graphical element. Preferably, the computer-readable medium has further computer-executable instructions for performing the method, the method further comprising: displaying a header on the screen above the data field, said header comprising a label that describes data field on the screen below it.","Further aspects of the invention will become apparent from consideration of the drawings and the ensuing description of preferred embodiments of the invention. A person skilled in the art will realize that other embodiments of the invention are possible and that the details of the invention can be modified in a number of respects, all without departing from the inventive concept. Thus, the following drawings and description are to be regarded as illustrative in nature and not restrictive.","The following reference numerals are used to indicate the parts and environment of the invention on the drawings:\n\n","Preferred embodiments of the invention include a grid-based graphical interface to database systems of various types, including relational systems and modern object and object-relational systems. The underlying data model is sufficiently generic to not require extensive type-information about data if this is not required.","In preferred embodiments, the grid control of the present invention includes a handle element for each data record that precedes the data elements and controls the life-cycle of the data on the screen. Further, the handle does not relate to the row but to a record which may contain multi-valued attributes, therefore involving more than one row. The handle is logically connected to the data required to fetch and save data. Thus, as there may be more than one record in a row, there may be more than one handle on a row. If one of the data elements of a record itself identifies another record, that data element is represented as a further handle embedded in first record. Using this handle, the second record can be selected and expanded in-line within the existing first record, displacing subsequent fields in this record.","Preferably, the grid control of the present invention is capable of displaying data of different types interspersed with each other. Optional header rows above data rows identify the different types of data. The ability to display heterogeneous data enables the grid control to be used in applications which select and display relational data in unusual ways using extensions of the SQL query language, and using the navigation possibilities inherent in the graphical elements on the grid. Applications incorporating the grid can also be used to select and display data from object databases, where the relationship between the visual representation and the underlying data will normally be closer.","In preferred embodiments, default actions and other options of the record handle, join icon and other graphical elements on the grid enable easy navigation of data. The display of data allows formats common in reports produced from databases. Actions of the record handle, and other graphical elements can be modified at run-time, to implement the life-cycle of the handle and allow flexible interfacing to different data sources.","The present invention has applications in the object database and object-relational sphere, where the storage of OID's (object identifiers that identify other records) as elements within a data record make the interface of the present invention advantageous. It is good for some forms of semi-structured data, such some kinds of XML. It is also useful as an interface for relational database systems. In particular, foreign keys may be added as record handles or lists of record handles to the fields in a relation record. This enables the user to navigate to related records in other relational tables. Using the present invention with relational databases allows standard SQL queries involving joins to be represented in a more meaningful way. The invention also extends this representation of foreign keys as extra columns to hierarchical data schema trees, with important advantages for automatic generation of queries.","Preferred embodiments of the present invention have further value in the object database sphere, as the grid of the present invention is capable of displaying data items that are lists or arrays of data elements. These multi-valued attributes are displayed as a vertical list, which drops down from the record, and which can be retracted to only occupy a single row of the display. In preferred embodiments, the retractable drop-down lists represent multi-valued fields in a data-record and are editable inline.","In this disclosure, the following terms have the indicated definitions:","(Software) application programmer\u2014one who puts components such as the grid control of the present invention together into a software package that is ready for use by the end user.","Action\u2014either the current default behavior of a graphical element, or an option of the graphical element that can be selected from its pop-up menu. Actions are distinguished from methods, which are the software methods with which the graphical element is programmed. A method is capable of choosing the required action, and performing it on the data.\n\nAPI (application programming interface)\u2014in situations in which computer programs are broken down into components, the API defines the interface of a given component to the other components.\n\nAttribute type\u2014describes what a given attribute is like. It may be numeric, text of a given length etc. It may be a reference (OID) or list of references. It may be single-valued or multi-valued.\n\nAttribute\u2014a data component within a data type. A type consists of a type name and a series of attributes.\n\nButton\u2014a graphical element of windowing operating systems that looks and acts like a physical button. When it is selected, an action associated with the button is performed.\n\nCallback programming\u2014a system for programming graphical user interfaces (GUI's) in which graphical elements are defined during development and for each graphical element a method is defined for each event that one is interested in. For example, the system may not react in a double-click on a scroll region, but a double click on a button element on the screen would have meaning. Thus, a double-click method for the button element is defined. The program then waits until an event happens. The callback routine for the combination of event and graphical element is then called.\n\nCell\u2014a single cell within a display item. Thus, a multi-valued field may contain several cells, preferably arranged one below the other.\n\nCompile time\u2014the time at which a computer program is built. Some of the characteristics of a program are determined at compile time, whereas others are decided later at run time.\n\nData element\u2014the value of an attribute within an object or the value of a field within a relational table. The value is preferably in the format used by the records and grid control of the present invention. For a multi-valued attribute, there may be several data elements within the attribute.\n\nData field\u2014a display item containing a data element or list of data elements. In the present invention, a data field may contain more than one element, if the field is multi-valued.\n\nData record\u2014the unit of data granularity with which records are fetched from the database and written back to it. In preferred embodiments, when a record is saved, all of the data elements within display items belonging to the data record are saved.\n\nDisplay item\u2014an item that is to be displayed on the screen, in the format in which it is passed to the grid. The grid allocates one or more graphical elements that can be displayed on the screen, and associates them with the display item, and displays them on the screen.\n\nForeign key\u2014field in a relational table that refers to a primary key in another table.\n\nForms applications\u2014database software applications or parts of applications that lay data out in a format similar to a paper office form, with data in fields spread around the form and interspersed with text and choice buttons.\n\nGranularity\u2014the level of detail at which data can be written to a database. For example, if the data from a relational join between two tables are modified it cannot be written out as a single record. Instead, a write is potentially performed to a record in each table. The unit of granularity is the record (although one can technically modify individual fields within the record). In preferred embodiments of the present invention, the unit of granularity on the screen is the data record, controlled by the record handle.\n\nGraphical element (sometimes called a widget)\u2014an element that can be displayed on the screen; a visual component of an on-screen display that is treated by the windowing operating system as an object in its own right. In a windowing operating system, it is of a type that the operating system is capable of displaying. Thus, an edit box is a graphical element, but a single character written in it is not. Graphical elements include windows, edit boxes, icons, buttons, and menus. Graphical elements are associated with display items.\n\nGrid, grid control\u2014an area in a GUI that contains display items arranged into a grid pattern. Preferably, a grid control controls items in the grid. For example, if a row is removed, following rows are moved up. The grid control, also called the grid, of the present invention is not necessarily a component in its own right\u2014it may be implemented using existing components.\n\nGUI (graphical user interface)\u2014a part of a computer program that defines how data are represented on the screen, and how the user interacts with display via input from a device such as a keyboard or a mouse.\n\nHeader label\u2014an individual label in a header identifying a given column.\n\nHeader\u2014the row above the row(s) containing display items displaying data records in a database output that labels the columns of the data records.\n\nHot-key combination\u2014a combination of keys used to select an option in a GUI. For example pressing the \u2018Ctrl\u2019 and \u2018F\u2019 keys at the same time on a keyboard is often used to Find something on the screen. Thus, \u2018Ctrl\u2019 and \u2018F\u2019 is the hot-key combination for Find. In addition, there might be a Find button or menu option available.\n\nJoin\u2014a way of joining two groups of data by comparing fields in the two groups. Usually, the comparison used is the fields being equal.\n\nJoin icon\u2014an icon representing a join on the screen.\n\nList handle\u2014the on-screen representation of a list, particularly a list of record handles in a multi-valued reference field. It can be selected to list the elements within the list.\n\nMaster-detail relationship\u2014in a relational database, this is the relationship between a table (the master) whose primary key is referred to by a foreign key in a second table (the detail table). One record in the master table is referenced by one or more records in the detail table.\n\nMeta-data\u2014data about data; data that is not real-world data but is related to the representation of that data in a database. Examples are OID's and, in some cases, relational database keys.\n\nMethod\u2014a method is defined at compilation time, and is related to events happening on a given graphical element. To vary the behavior of a graphical element, a method calls an action. This action can be modified during the run-time of the program.\n\nMulti-valued attribute\u2014an attribute that can contain more than one element in the same object, such as a list or an array, preferably in an object database.\n\nNon-standard SQL\u2014extending the standard SQL syntax with new keywords (for example, \u2018any\u2019 and \u2018all\u2019) and with new concepts such as selecting on attribute type. For brevity these queries are referred to as non-standard SQL queries, despite the fact that the \u2018S\u2019 in SQL stands for \u2018Standard\u2019. The use of SQL syntax does not imply that the underlying database is relational.\n\nObject\u2014a unit of data within an object database. An object has data elements. The data elements may conform to the attributes of the object-type if the object has a type.\n\nObject-based\u2014any type of database that contains objects rather than relations or relational tables.\n\nODBC\u2014a standard interface for connecting to relational database systems.\n\nODBMS (object database management system)\u2014any database management system that stores data in a format where an object (record) can be retrieved using an object identifier (OID). Sometimes the object type or class is also required to identify the object.\n\nOID (object identifier)\u2014in object databases, an identifier (usually a number), that is either unique or unique within the object's type. This identifier is used to identify an object, and when stored as an element in another object is a reference from the latter object to the former object.\n\nParse\u2014the action of breaking down a string of characters into a given format to which it is supposed to conform. A parser decides whether a string conforms, and if so performs certain procedures. A database query parser is the part of a database which receives queries and interprets them in such a way that the database can return or update data. Pop-up menu-a menu that appears connected to a graphical element when that element is selected in a certain way.\n\nReference\u2014a data element in one data record that is used to refer to another data record.\n\nReferenced\u2014the use of \u2018referenced\u2019 as an adjective or verb is shorthand for saying \u2018(being) referred to\u2019.\n\nRDBMS (relational database management system)\u2014the kind of database system described in 1 by C. J. Date, Fifth Edition, Addison-Wesley (1990) and elsewhere, which stores data in tables consisting of identical rows of fields.\n\nRecord handle\u2014the on-screen representation of the collective aspects of a relation record or data object. It can be used to perform operations such as saving, closing or fetching the record.\n\nRun-time\u2014at the time a program is in use by a user. Some of the behavior of a program is only decided at run-time, either at the start of the program (initialization) or during the session.\n\nSchema\u2014information in a database about what types of data or tables are contained in it. The individual columns within the table or the attributes within a data type are detailed in the schema, as are relationships between types or tables.\n\nSelection (of a graphical element)\u2014the action of choosing a visual item or option on the screen, either by using a hot-key combination on a keyboard, by clicking a pointing device such as a mouse, by speech activation or by other user input. This is not to be confused with selection on a database. There is often more than one means of selection of an option. For example, a hot-key combination can duplicate the action of a button on the screen.\n\nSelect (on a database)\u2014the basic command in SQL used to get data out of a database.\n\nSoftware application, software package\u2014a completed software program that a user can use. It can be made of components, such as the grid control of the present invention. Components are not applications, as they do not function on their own.\n\nSQL\u2014Standard Query Language. See Date above.\n\nType\u2014the type of an object, preferably in an object database. The word \u2018class\u2019 in not used interchangeably because the present invention does not specify full object-orientation (inheritance, encapsulation and methods).\n\nWhere-clause\u2014that part of an SQL query starting with \u2018where\u2019 that identifies a record or records. The where-clause is only useful for the present invention if it uniquely identifies a record, or can be modified to do so.\n\nWindow\u2014in background art computer programs, an area of the screen delimited by a rectangle within which further graphical elements can be displayed. Often different programs run within different windows on the same screens, or different parts of the same program are put into different windows.\n","Referring to , the basic hardware and software environment of a preferred embodiment of the present invention is illustrated. Practice of the present invention requires a screen or display  on which records (described later) are displayed. The screen may be a computer screen, WAP telephone screen, IDTV screen or other display device. On screen  is shown a cursor , which may be used to identify selected graphical elements on screen . An alternative to the use of cursor  is highlighting of the graphical element.","The present invention relies on one or more processing units  that perform output to the screen and receives input from the user. The processing may be split between separate devices that are connected using communications devices. At the bottom of  are preferred input devices that the user can use to communicate with the program running in processing units . Possible devices are keyboard or keypad , microphone  for voice-activated input, computer mouse , and a generic input device , representing any other form of user input. In general, processing units  coordinate the identification of graphical elements on the screen using highlighting or the cursor  with input from input devices -. For example, with mouse  and cursor , the movement of mouse  is coordinated by the software in processing units  with the movement of cursor  on screen .","Preferred embodiments of the present invention operate on an IBM-compatible personal computer (IBM-PC)\u2014a standard defined by IBM (International Business Machines Corporation) of Armonk, N.Y. These embodiments use the Microsoft Windows 98 operating system from Microsoft Corporation of Redmond, Wash. They are developed using C++ Builder Edition from Borland Software Corporation, Scotts Valley, Calif. For information about how to program the C++ language, the reader is referred to the online Help for C++ Builder, and also The C++ Programming Language, by Bjarne Stroustrup, Addison-Wesley, 1987. For information about how to program Windows 98, the reader is referred to Charles Petzold's , Microsoft Press, 1999.","The preferred embodiments could also be developed on other operating systems such versions of Unix such as Digital Unix or Solaris from Sun Microsystems, using windowing systems such as \u2018X,\u2019 Motif, etc. The records of the present invention and the grid of the present invention could further be developed on devices such as interactive digital television (IDTV) devices that do not have windowing operating systems such as Windows 98. The more advanced the development tools and windowing operating system become, the easier the functionality described herein is to develop. Similarly, the use of the C++ language or C++ Builder in the preferred embodiments does not preclude the use of Java or other programming languages. In particular, although preferred embodiments disclosed herein are standalone software programs, it is envisaged that the same behavior of windows, records, grids and databases would be useful as part of a plug-in program that can be added to an Internet browser. The behavior could also be incorporated as standard in Internet browsers of the future.","Referring to , a simple record of a preferred embodiment of the present invention is illustrated. A record consists of an optional header row  and a data record . Header row  comprises header cell  on the left of header row , containing the name of the record type. Depending on the embodiment, these header labels can be customized with aliases. The rest of the cells - in header row  are field header labels for the fields in the data record. Preferably, the GUI allows the user to distinguish between header labels and data. In this case, the header labels have been shown having a dashed frame around their cell, whereas the data has a continuous line around it. Data record  contains data fields -. These data fields display the data for the respective columns in the record indicated by the header. Left-handle cell  is the record handle, or handle for the record. The functionality of this record handle is enhanced in comparison with equivalent fields in background art database interfaces. The enhancements allow it to perform actions on the records. In this case, the default action on selecting handle  is to save the record to the database.","Record handle  is illustrated in  as having diagonal hatching, which in this monochrome drawing represents a blue rectangle with lettering in a contrasting color. However, record handle  does not have to be a blue rectangle, as it can be any visual element. In , the data on the screen have been changed or created afresh on the screen. Selecting handle  saves the data to the database. Preferably, at that point, the default action of handle  turns to \u2018Close\u2019, selection of which removes the data from the screen. However, as soon as the on-screen version of the data has been modified, the state of the handle changes back to \u2018Save,\u2019 meaning that the data on the screen differ from that in the database. Modification of data within the record alerts the record handle. There is no actual requirement to write the words disclosed herein on the handle . The handle is a visual element that forms the link between the on-screen data and the database. In a preferred embodiment, the record can be of a certain type or of no type. It does not have to conform to any of the existing database types such as those storable in background art relational databases or object-relational databases.","In a simple case, a record appears in a word-processing document like the one used to prepare this disclosure. If the user edits one of the data fields - within the record in the document and uses the \u2018Save\u2019 action of handle , the changed data are written to the database. However, this embodiment of the present invention requires more functionality within the record than is required for embodiments where the records are contained within a grid control of the present invention.","The GUI of a preferred embodiment of the invention consists of three windows: a \u2018Data Processing\u2019 window which is the main window of the software application, a \u2018New Type\u2019 window and a \u2018Data Retrieval\u2019 window. The last two windows are used to define record types or classes to be used on the main window, and to get data onto the main window, respectively.","Referring to , Data Processing window  of a preferred embodiment of the present invention is illustrated. The purpose of Data Processing window  is to enable a user to display data and relationships between data in an easily understandable format. Window  may also be used for preparing reports. The format of window  makes it easier to input, modify and delete data than is possible with background art GUIs.","In a preferred embodiment, screen  in  displays Data Processing window , which contains query entry window , series of buttons -, and grid control  of the present invention. It will be noted that grid control  is not filled with a lattice of cells, as is often the case with background art grids. Where there is no data element, such as below record , there are no cell dividers. Furthermore, cells on different rows can have different widths. The grid area is scrollable in the vertical and horizontal directions, but in , the scroll bars are not present because the data do not extend beyond the visible part of grid control . Scroll bars appear when the data exceed the bounds of grid control  in their respective directions.",{"@attributes":{"id":"p-0142","num":"0430"},"figref":["FIG. 6","FIG. 5","FIG. 8"],"b":["803","802","810","812","809","811","803","803"]},"Grid control  helps to control the organization of the records within its bounds and marks the bounds within which the records are displayed. Grid control  is capable of scrolling up and down and side to side, if needed to show more data. When several records are to be displayed, it is convenient to display them into a grid control of the present invention.","In a preferred embodiment, the user of Data Processing window  can add new data rather than getting data from a database. In a preferred embodiment, the user begins this process by selecting \u2018New Type\u2019 button . For example, in a relational system, selection of \u2018New Type\u2019 button  displays a list of tables within the relational database to which the program is connected. Regardless of how the new type is specified, the software application program creates a new empty record of the required type in a format understood by the grid and passes it to grid control  for display. Grid control  supplies a new header row if necessary based on information linked to the new record supplied. Thus, the \u2018New Type\u2019 button creates a new record on the screen for efficiency, so that the user does not need to select \u2018New Object\u2019 button  the first time.","In a preferred embodiment, the user can select \u2018New Object\u2019 button  to add further objects of the current type. In the preferred embodiment of grid control , the application program supplies the display items for a new empty record of the current type, and the grid displays it in the correct place. The record looks like that in , but with the data in fields - set to null. The user can now key in new data.","Referring to , it has been mentioned that the displayed data are heterogeneous. The user has added two different types to grid control . The user has also keyed data into the data fields. Record handles  and  reflect the fact that there are data on the screen that are different from that in the database or that are not present in the database at all. This is accomplished by setting the default action set to \u2018Save\u2019. Modifying or keying data into the data fields alerts the record handle, which is preferably programmed to change to \u2018Save\u2019. If the user selects a record handle, such as record handle , the data is saved to the database and the handle changes its default behavior to \u2018Close\u2019. Selection of the \u2018Close\u2019 action removes the record from the screen.","Second data record  displayed on  is of a completely different type from the first one, as supported by the data model of the GUI. There is no requirement to retrieve or generate data grouped by a relational table or shared data-type class. Preferably, data records are stored one record at a time (although the GUI also allows one to select groups of records for saving). Thus, a preferred embodiment of the present invention supports a combination of mixed data classes and a granularity of one record for saving data. The user can access all the data he\/she is interested in accessing from the same window.","Referring to , Data Processing window  of the same software application as is illustrated in  is shown. In this instance, an employee of a combined (natural gas and electricity) utilities company runs a query which spans two tables in one or more legacy relational database systems. The data are fetched into grid control  by the user typing in a query in non-standard SQL into query window . Run Query button  is then selected to run the query and fetch the data onto the screen. It is noted that, when the user has just fetched the data, the default action for handles  and  is \u2018Close\u2019. This is because there is no point in saving data that is the same on the screen as it is in the database.","In this instance, the user enters a query that uses a query language similar in syntax to SQL, but a query language that enables one to search more than one table (or object-type, if the database is object-based) at the same time. The query language also allows one to sort by similar types of data in columns in different tables. As mentioned above, background art database languages allow one to do similar things, and the syntax used here is merely indicative. The keyword \u2018or\u2019 in the query in query window  is used to indicate that the two rows from the tables are not to be joined together. If the \u2018or\u2019 were replaced by a comma in standard SQL, the query would produce a PRODUCT of the two tables, with every combination of each row within each table being displayed. Instead, this is a UNION, which is the appending of one table after the other. The ability of the grid to display heterogeneous data encourages the development of queries that return heterogeneous data.","The query in query window  is parsed and processed as two or more SQL queries in a relational system. One having ordinary skill in the art will see that even if the database in use was not an object database but, instead, was a relational database, the query could be parsed into two standard SQL queries. In fact, it is possible in standard SQL to use a UNION operator to join the results of two queries into one, but the resultant data must have the same number and types of columns. This has rendered the use of UNION's rare. The procedure for returning heterogeneous data used by the present invention is described later.",{"@attributes":{"id":"p-0151","num":"0439"},"figref":["FIG. 8","FIG. 7","FIG. 8"],"b":["803","1001","1002","1003","1004","1005","1006","1007","1008","1011"]},"Selections and data display can be heterogeneous in preferred embodiments of the present invention. The advantage of this approach is that without any application programming the user can see both kinds of record at the same time, in the same window. Typically, this would not be the case for a background art database software application.","With a preferred embodiment of the present invention, the user can see all of the relevant records in the same query. The user can modify individual records and save them (or select several handles and save all at one time). The heterogeneous nature of the data means that a worker who is performing several tasks at once, for example in a telephone call center, can put a new type of record in the same grid control for each type of work being carried out. If the date\/time field is automatically generated for these records, a journal of a day's work is automatically generated without software application programming effort.","In , one cannot determine how the data have come to appear on the screen. It could have been the result of a data query, or of the user inputting new data and then saving it. However, the state of the record handle, for records , , and  is \u2018Close\u2019. This means that the data have already been saved to the database, and a \u2018Close\u2019 would take the record off the screen, along with its header if the latter only served one row of data. Any subsequent records will move up to fill the gap. The ability to remove uninteresting records from the screen, bringing records that the user is interested in closer together is an advantage of preferred embodiments of the present invention.","In contrast to the other three record handles, the state of the handle for record  is \u2018Save\u2019. This means either that the information is new and requires saving, or that it has been fetched and modified. In the latter case, the on-screen version of the data is different to that in the database, and can be saved. It is normal for the default action of the record handle to be \u2018Save\u2019 when the data within the display item are new or modified. As an example, a customer phones in to say that his end reading is 101965 in record , rather than the estimated value that the utilities company has been using. The employee of the utility company then modifies the record. Changing the data in cell  alerts record handle , which typically changes its default action to \u2018Save\u2019. Note that this action is only the default action for the record handle. Other options are available by right-clicking the \u2018Save\u2019 button.","The default action of the record handle is typically selected using a single left-click on a mouse. An alternative selection such as right-clicking on the mouse reveals the pop-up menu . The menu appears near the selected record handle or other cell. The menu shows the current default action of the handle \u2018Save\u2019 action , as well as alternative actions. Those actions that are not currently available are preferably shown as grayed out (shown here in a larger font). In this example, \u2018New\u2019 action  might not relevant as a record already exists, but \u2018Get\u2019 action  might be valid, as the user may have messed up the fields and want to refresh them.","The current discussion has been in terms of using the interface to access a relational database, whereas, a preferred way to use the interface is in conjunction with an object-based database.  shows a second Data Processing window of a preferred embodiment of the present invention, in this case illustrating the display of multi-valued attributes. It should be noted however that the embodiment in  is merely an enhancement of that illustrated in  and each would be valid for processing relational or object data. In a variation of the Data Processing window of the preferred embodiment shown in , the window of  contains the familiar query window , \u2018Run Query\u2019 button , \u2018New Type\u2019 button , \u2018New Object\u2019 button , and \u2018Get Data\u2019 button .","As described in the explanation of , \u2018New Type\u2019 button  is used to specify a new type. This action also supplies the first new record of that type. \u2018New Object\u2019 button  supplies subsequent records. In either case, a new row is displayed for the user to fill with data.","If the user wants get to existing data from the database onto the window, \u2018Get Data\u2019 button  is used. Data are fetched onto the screen and displayed in the same way as data that has been input by the user. \u2018Get Data\u2019 button  activates the Data Retrieval window of the preferred embodiment, to allow browsing of data rather than use of a query. The buttons along the top that are familiar ones from , are divided by divider  from a series of buttons that relate to record types  and attribute types  and  that may be useful in building up new records or display items. These record type buttons and attribute type buttons are created dynamically based on the most commonly used record types and attribute types. Scroll arrow  allows the user to scroll to other buttons. Data grid  contains two records: \u2018Gas Bill\u2019 record , which contains only simple single-valued text fields, and \u2018Family\u2019 record , which contains multi-valued attributes and references. Header row  to the \u2018Family\u2019 record is as in previous figures. On the data row, record handle  is present as normal. Display item  is a simple text field showing that the Dad's name is \u2018Nick\u2019. The next column displays the values of a multi-valued attribute. This means that the display item can contain more than one element, in this case containing the names of the children, -. If the user uses the downward cursor key to key downwards from element , an empty cell  is added to the list, allowing the entry of more data.","In the case of the first record, \u2018Gas bill\u2019 record , all of the data-input fields are white. This is a convention adopted here to show that the fields are atomic fields that can be modified with ordinary data entry, but different colors could be used to indicate different cell types. The definition of the record-type, \u2018Gas bill\u2019, may have specified a variety of conditions on the data. For example, two of the fields appear to be numeric fields and the other two, currency fields. The present invention does not specify or limit these types or the rules that apply to them. However, one could envisage a \u2018file\u2019 type of field referring to a file in the operating system, with the suffix on the file-name referring to the default software application to be run when selecting this item. Similarly, there could be a \u2018binary large object type\u2019 (BLOB), which is a large amount of binary data in a database field. These are extensions in the behavior of the graphical elements, which are discussed later.","To return to the white data-fields in \u2018Gas bill\u2019 record , these fields refer to simple single-valued fields. The graphical element is a single editable cell that can be edited in a normal way like a cell in a spreadsheet or normal database grid control. In , data elements - (which are preferably cream-yellow in color) are in fact a single field in the record. This type of field stores a list or array of values: a so-called multi-valued attribute. The use of multi-valued attributes and references give the records of preferred embodiments of the present invention much of their power. In , they are filled with a dotted pattern. In a preferred representation, this represents a non-white color such as cream, to distinguish them from the single-valued attributes. In preferred embodiments of the present invention, the color does not have to be cream, and it is not essential to use a different color for multi-valued attributes.","Preferably, the multi-valued fields on a record have the ability to expand downwards to show all of the data elements in the list, or to contract to take up a single line. Within a given record, some multi-valued fields may be expanded while others are contracted. If the list is long, it is scrollable. In a preferred embodiment of the present invention, for simple editable fields, a single-click preferably selects that field for editing, whereas a double click preferably changes the state of the list from expanded to contracted or vice versa. In contrast with most background art systems, the fields in the list are preferably editable inline, rather than using the combination list-box arrangement, which often requires selection from a drop-down list and then editing it in an edit box situated at the top row of the list. If the user expands a list that is not in the lowest row in the grid control, either subsequent rows are preferably pushed down or the list overlays other records. In a preferred embodiment of the present invention, these two choices are set as an option in real-time. In the case of overlaying, a preferred embodiment uses shadowing or highlighting of the cells to remove the confusion that it may cause.","The ability to display lists is an important aspect of preferred embodiments of the invention. It provides a natural way to group and display data. The relational model makes this difficult. When reports based on the on-screen information are printed out, the pushing down option is likely to be more useful, as it reflects how reports are prepared from tabular data. Thus, in many cases, preferred embodiments of the present invention avoid the use of an additional report layer of software over and above a traditional tabular grid control display.","Another important feature of preferred embodiments of the data model of the present invention is support of references. Fields are allowed to be references to other data objects. In general, a reference means \u2018enough information to uniquely identify a data record being referred to.\u2019 The reference simply is a means of getting the data for the new record, or saving it when modified.","Referring again to , the next column, \u2018Cars\u2019 column , contains a multi-valued attribute field whose elements are references to other records. The data model does not assume that references from elements of the same attribute of a type are all to objects of the same type. It appears that these two objects might both be \u2018Cars\u2019, but that is not a requirement unless it has been specified by the user or programmer in a rule. Preferably, any such rule is defined in the software application, not handled in the grid. First reference  is a reference to an existing \u2018Car\u2019 record, whereas second reference  is a space for the creation or linking of a new record to \u2018Family\u2019 record .","In preferred embodiments of the present invention, first reference data element  is blue in color, like the record handle. In , as in previous figures, this is represented in monochrome by diagonal hatching. This data element is itself a handle of the same kind as that at the start of the record, handle . For the purpose of the display, \u2018Cars\u2019 reference  is a data element of the \u2018Family\u2019 record, but it is at the same time a data handle for a \u2018Cars\u2019 record. In the example shown, the family already has one car. It exists already, because the state of the object handle is \u2018Get\u2019. Assuming that  shows access of an object database, this means the object handle contains a valid OID, which for object databases is all that is needed to get that object from the database. This means that one related \u2018Cars\u2019 object is in the database. Selecting the default action, \u2018Get\u2019, of record handle  gets the object from the database and expands it inline.","In , the Homes column also contains a multi-valued attribute field, but, in this variation of the preferred embodiment, the list has been retracted into a single graphical element, called list handle  in the present invention. In , list handle  is shown with a fill pattern that differs from the fill pattern of the record handle and the multi-valued text cell. This different fill pattern represents a different color, such as green. The default action of selection of a list handle is to list the elements in the item. The list handle is acting as a sort of lid on a list of references. The list handle is not to be confused with a record handle, and if the word \u2018handle\u2019 is used on its own, a record handle is to be assumed. In the case of a list of elements that are not references, it is preferable to be able to see the first element of a list when the list has been retracted. However, in the case of references, particularly when the object data model is used, showing the reference would not be of much use. This is because the data in the reference is an object identifier (OID), which tells nothing about the data within the object. To get data from the objects being referenced, a second data fetch is required.","In preferred embodiments, there is little difference between a reference\/handle that is a field within a data record and the one that defines the data record. The former merely has an extra action possibility, \u2018remove\u2019, which removes the reference to the data but does not delete the data to which it refers.",{"@attributes":{"id":"p-0169","num":"0457"},"figref":["FIG. 10","FIG. 9","FIG. 10","FIG. 9","FIG. 9","FIG. 10","FIG. 9"],"b":["1323","1321","1321"]},"The data fields within the Cars record have been labeled with header labels  and . The data for the referenced record is shown in data fields  and . Header label  and data fields  for Homes have been pushed to the right to accommodate the new data. The repositioning of the data cells and header labels is preferably performed automatically by the grid control, which calculates new positions based on the insertion of the new data. The header rows are generated by the grid, and new header rows and new labels within existing header rows are introduced when records are changed in such a way that the header no longer reflects the all of the data below it.","The ability to get from a reference to the thing being referenced is an important feature of preferred embodiments of the present invention. This is how people think about references within records. One sees a simple record, but knows that nested within a reference in that record are more data. In the world of background art Internet browsers, the default action for a reference is to go to the referenced data, leaving the data that referred to it behind. In the context of the present invention, the default action is to expand the data inline. The user wants to be able to see all related data in the same place on the screen. Moreover, if the user is not interested in \u2018Homes\u2019, he wants to be able to hide that information.","Preferably, the default unit of data granularity is the record as defined by the handle. This means that when data are modified on the screen and the \u2018Save\u2019 action of the handle is invoked, all of the data within the record are saved. However, this does not preferably extend to data within records referenced by reference fields within the record being saved, even if they have been fetched onto the screen. The data that are saved are all of the fields from the record, including the reference. The reference is simply the means of identifying the other record, not the contents of the referenced record. In terms of the example in , if the \u2018Family\u2019 record were identified by a record identifier of 0001234 and the Fiat car was identified by 00005678, saving record 00001234 would save Dad \u2018Nick\u2019, Kids \u2018Fabio, Patrick, Lucia\u2019 and Car 00005678. It would not save \u2018Fiat\u2019 and \u2018E976 MDX\u2019.","However, writing out only the data of the record whose handle is selected is only the default behavior. For example, a software application program that uses grid control  of the present invention to interface to a relational database might be programmed to save a record in a master table and its related records in a detail table. The relationship between grid control  and the application program is discussed later.","In preferred embodiments of the invention, it is not necessary to fetch the whole referenced object. Using the right mouse button and selecting \u2018Get some fields,\u2019 the user is presented with the means of selecting which fields to fetch. An item fetched in this state can be filled out at a later date with \u2018Get all fields\u2019 in the same way, or by selecting more fields.","Referring again to , at the bottom of the Car list \u2018New\u2019 record handle  is displayed, which allows the user to add a new object. For empty single-valued reference fields, a \u2018New\u2019 record handle is also provided. Selecting the action \u2018New\u2019 on this record handle allows a user to specify a new data type, by going to the \u2018New Type\u2019 window described below. On return, the fields of the new object are expanded inline on the grid and values may be entered into the data elements.","If the type of the new record is always the same for a given attribute, the \u2018New\u2019 action of the reference record handle may be programmed to return a new record of that record type immediately. However, as mentioned earlier, the data model used allows references in a reference list to be of different types, and in the example \u2018Cars\u2019 is an attribute that allows this. Therefore, before supplying an empty new record the application goes to the New Type window, which will be described shortly, to select the type required. The \u2018Homes\u2019 reference list always refers to objects of type \u2018Home\u2019, so the \u2018New\u2019 action for those reference record handles inserts a record of this type without going to the New Type window. The variations in the result of the \u2018New\u2019 action are because the actions, and the methods called by the actions are not supplied by the grid itself, but rather by the application program that incorporates it.","Instead of selecting \u2018New\u2019, the user may right-click on the object handle and select \u2018Get\u2019 from a menu of choices. \u2018Get\u2019 allows the user to select an existing object by going to the Data Retrieval window. On return, references to the selected data are put in the reference or reference list. In the case of a reference list, the selection may be of more than one object.","Removing a reference is preferably a non-default option on a reference record handle. In the case of a single-valued reference, removing a reference results that the field's handle reverts to state \u2018New\u2019. This is effectively a null field. The referenced data are not deleted. For multi-valued references, the reference is removed from the list.","Referring to , New Type window  of a preferred embodiment of the present invention is illustrated. New Type window  is used to specify a data type for use in Main Data Processing window , illustrated in . The type may be new in the sense that it is different, or new in the sense that it is to be newly defined in this visit to New Type window .","New Type window  may be called from \u2018New Type\u2019 button  or in cases outlined above on selection of the \u2018New\u2019 action of a record handle. On return from New Type window , a type has been selected and a new empty record has been displayed on the grid. In New Type window , scrolling region  contains buttons for commonly-used and recently-used types: \u2018Gas Bill\u2019 type button , \u2018Family\u2019 type button , text type button , ref (for a reference type) type button , and reflist (for a reference list) type button . Scrolling region  is controlled by pair of arrows  and , which allow one to scroll through these options.","Buttons - enable the user to select a given existing data type, or attribute type quickly. On selection of a type, New Type window grid  is filled in with information about the selected type. On selection of an attribute type, information about that attribute type is filled into the next available row of the grid. One having ordinary skill in the art will see that scrolling region  and its buttons can be replaced with a menu bar and a drop-down menu. A scrolling region of dynamically allocated buttons and a drop-down menu are commonly used in background art software applications.","A comprehensive list of types and attribute types is found in type hierarchical data schema tree  of New Type window . Note that data schema tree  does not display a strict hierarchy in mathematical terms, because the same item can occur at more than one place. This area is scrollable using panel scrollbars  and . The right-hand wall of the panel can be moved thus allowing the panel displaying data schema tree  to be re-sized to use more of New Type window  for browsing. The data schema tree is a tree view similar to the directory browser in Windows Explorer from Microsoft. A selection of tree views and directory browsers is available in Borland C++ Builder.","There are two types of folders in this diagram, hatched and black, representing different colors in a preferred embodiment. The diagonally-hatched folder shapes  and  represent existing types. The types have nodes  and  to their left, enabling expansion and collapsing of their attributes. This is discussed further with reference to  later in this disclosure.","Black folder shapes - represent attribute types. \u2018Number\u2019 attribute type  has two derived attribute types: \u2018integer\u2019 attribute type  and \u2018float\u2019 attribute type . The minus sign within node  connected to \u2018number\u2019 attribute type  shows that the level of the hierarchy below \u2018number\u2019 attribute type  is expanded. Clicking this minus sign collapses the hierarchy below \u2018number\u2019 attribute type  and replaces the minus with a plus sign. This is the situation at \u2018text\u2019 attribute type, where plus sign  shows that \u2018text\u2019 attribute type  has a hierarchy of derived attribute types that is not shown. In this case, the attribute type below \u2018text\u2019 attribute type  is \u2018text20\u2019 attribute type . In a departure from background art hierarchy displays, the display illustrated in  shows all of the elements of the hierarchy at the top level. Thus, \u2018text20\u2019, which is hidden below the collapsed hierarchy of \u2018text\u2019 attribute type , is also shown at the top level of the hierarchy at \u2018text20\u2019 attribute type . Similarly, the attribute type \u2018integer\u2019 occurs twice\u2014once at the top-level of the hierarchy at \u2018integer\u2019 attribute type , and once as a derived attribute type of \u2018number\u2019 at derived \u2018integer\u2019 attribute type . This methodology is preferably applied to derivation of both types and attribute types, and enables the user to locate a type or attribute type either alphabetically or hierarchically. It is also useful for generation of queries, as will be shown later.","In that the data tree is to show the derivation of both types and attributes, alternatives designs are envisioned. With background art tree controls, there is only one dimension of hierarchy. Each node can only be opened in one way. For types we want to show two kinds of hierarchy, the attributes within a type, and the types derived from a type. One embodiment involving the use of background art tree controls mixes the two types of element at the same level in the hierarchy. Thus, for a type element, its attributes are shown first, followed by any derived types. Another embodiment involves adding another expansible node to the right of the element, which could be used as the start of one of the hierarchies, so that each element can be the start of two hierarchies. In this disclosure, applicant notes this possibility, but uses background art trees where each element can only have one sub-tree.","This disclosure only shows basic means of selecting types, and methods relating to claims. It assumes that normal methods of selecting commonly used types and attributes, such as menus or scroll-regions of recently used types in existing art systems are possible in alternative embodiments. When considering hierarchical data trees, one needs to distinguish between selecting an element and expanding a node. Selecting the folder shape or the text of its name selects that element in the tree. Selecting a square node containing a plus, \u2018+\u2019 or minus \u2018\u2212\u2019 expands or contracts the node and preferably does not select the element. With respect to selection of a type, a single click on a type preferably puts the type and attribute information into New Type window grid , for possible further modification. In the case of a double-click on a type, the type is preferably returned directly to the main window, closing New Type window .","Referring again to , top left cell or \u2018Family2\u2019 cell  in New Type window grid  displays the name of the type, which is preferably editable. The remaining cells on the top row, \u2018Attribute type\u2019 cell  and \u2018Multi-valued?\u2019 cell , contain header labels for the information about the attribute types in the rows that follow. In this simple example of a preferred embodiment of the present invention, the only information about the attribute types are their names, which are displayed in the column below \u2018Attribute type\u2019 cell  and whether they are multi-valued or not, which are displayed in the column below \u2018Multi-valued?\u2019 cell . All of the rows except the first one are preferably scrollable using grid scrollbar . The remaining cells in the left-hand column, remaining cells -, display the attribute names. The row consisting of cells - gives the user the opportunity to add attributes to the type. This requires a change of type name, at top left cell . In , the user has changed the name from Family to Family2. At this point, providing the new type has retained all of the attributes of the old type and has only added extra attributes, it can be considered a derived type. Check box  is enabled when derived types are being processed. This allows the user to specify whether the new type is to be considered as being derived from the old type. If so, the new type appears below that type in type hierarchy panel .","If \u2018Cancel\u2019 button  is selected, the type selection process is aborted and the software application returns to the main Data Processing window. If \u2018OK\u2019 button  is selected, the software application returns a definition of the selected new or existing type to main Data Processing window .","Referring to , the state of the Data Processing window after the return from the New Type window of  is illustrated. In the description of , it was pointed out that the user was going to return with a type called \u2018Family2\u2019 derived from type \u2018Family\u2019.  shows the case in which the user chooses a type \u2018Car2\u2019 instead. This type is similar to \u2018Car\u2019, but has an extra attribute called \u2018photo\u2019. In , the user has returned to the Data Processing window and a new record has been inserted consisting of the fields , , and . This new record belongs to record handle , which has moved down with respect to its position in . The user has filled in the \u2018make\u2019 of car (\u2018Ford\u2019) and car registration number into fields  and . Because the label required for field  is not the existing one, \u2018type\u2019, the grid has inserted new label sub-row  to correctly label the new inserted record. If the label for cell  had been \u2018type\u2019, the grid would have used the existing header, inserting a label \u2018photo\u2019, alongside \u2018registration\u2019 label . Record handle , whose \u2018New\u2019 action was selected to cause the transition from  to  has moved down to accommodate the new label row. Also, in this preferred embodiment, the record handle has not been re-labeled, as it is considered as being an attribute of the \u2018Family\u2019 record that contains it, and hence its label is \u2018Cars\u2019. Note that the \u2018New\u2019 action of the record handle  in  has added another \u2018New\u2019 handle  below it to replace it. Note also that \u2018Homes\u2019 label  and its field  have been moved further to the right leaving a gap in the label row for the \u2018Family\u2019 record. This preferred embodiment considers that the \u2018Cars\u2019 attribute extends downwards as far as the new record handle , and rightwards as far as the \u2018photo\u2019 column, which contains label sub-row  and cell . Thus, in accordance with a preferred embodiment of the present invention, the correct place for the \u2018Homes\u2019 column is where it is shown. Other preferred embodiments may use extra grid-lines and other visual elements to help alleviate any perceived lack of cohesion in the display of data.","Considering data field , in the \u2018Photo\u2019 column, this is an example of a programmer-defined extension to the visual interface of the present invention. In its current state, the invention specifies five display items, reference (single-valued), reference list, single-valued text field, multi-valued text field, and join which can be generated in the application program and passed to the grid to display. The grid supplies a sixth display item\u2014the label. The label is generated by the grid according to information supplied by the application program.","The display items have graphical elements that represent them on-screen. For example a single reference is displayed on the screen using a record handle. In , the application programmer has derived a new class \u2018Photo\u2019 from the base class \u2018DisplayItem\u2019 defined within the grid. The DisplayItem class is not displayable by the operating system. Instead classes derived from \u2018DisplayItem\u2019 maintain pointers to a parallel set of classes that are displayable by the operating system. For example, a \u2018Join\u2019 class derived from \u2018DisplayItem\u2019 is represented on the screen by a \u2018TjoinIcon\u2019 graphical object, which is derived from a Borland BitBtn class. The Join class maintains a pointer to the TjoinIcon object. This means that application programmers can extend the visual interface by deriving a new class such as \u2018Photo\u2019 from \u2018DisplayItem\u2019. They may then independently define the visual representation of their display item class. They then have to define functions to create the graphical element and add its actions. In functions defined for the new display item, the graphical element can be passed to the grid to be placed and sized by the grid's internal programming.","The proposed \u2018Photo\u2019 display item is designed to hold the file-system address of a file which contains a photo of the car. Initially, the \u2018Browse\u2019 action displays a dialog enabling the user to select a graphics file. Once selected, the default action changes to \u2018Display\u2019. This opens a viewer in a separate window to display the photo. This is simple example of the extensibility of the graphical interface.","Referring to , Data Retrieval window  of a preferred embodiment of the present invention is illustrated. Data Retrieval window  contains query window ; command button region ; scrollable region , which is governed by two arrows,  and , and contains keywords used in the creation of queries; type and attribute type data schema tree ; and data grid . The data schema tree is similar to that presented in . It is apparent that attribute node , from , for \u2018Family\u2019 type  has been expanded to show the attributes of this type, which are attributes -. The attributes are those in previous examples such as those in . It is possible to expand the types in New Type window , shown in , but this feature is not shown on that figure.","Types and attribute types can be selected by browsing hierarchical tree display . The user can also enter or modify a query in query window , either by typing the query in, selecting keywords from keyword region , selecting types and attributes from hierarchical tree display , or a combination of these approaches. It is a common practice in background art graphical interfaces for databases for a window to be provided having some of the features of Data Retrieval window , often called a query builder window, to allow the user to build up a query from a variety of sources.","Once the query has been completed to the satisfaction of the user, selecting \u2018Select\u2019 button  retrieves the data into data grid  which is a preferred embodiment of the data grid of the present invention. Note that the data are added to any existing data in data grid . The user is able to refine the choice of selected data. Selecting a few of the data records in data grid , and then selecting \u2018Keep\u2019 button , causes only those data that were selected to be retained. Similarly, selecting a few data records and then selecting \u2018Drop\u2019 button  removes those records from data grid . Selecting a record, or group of records of the same type, and then selecting \u2018More Fields\u2019 button  allows the user to retrieve more of the fields of the records(s) that were not part of the original query. Selecting \u2018Cancel\u2019 button  cancels the entire operation and returns the user to the main Data Processing window. Selecting \u2018Return\u2019 button  returns the user to the main data processing window, adding the records that had been fetched into data grid  into data grid  of main Data Processing window  shown in .","The preferred embodiments shown in  uses two data grids. The present invention does not preclude the use of a single window with a single data grid. However, use of two grids, one for fetching raw data and then refining the choice by closing many of the records before returning the selected data to main grid, has many advantages.","In alternative embodiments, expanding node , for the family type, reveals the attributes of this type. The attributes \u2018dad\u2019, \u2018kids\u2019, \u2018cars\u2019 and \u2018homes\u2019 appear in . It will be noticed that the two reference attributes, \u2018cars\u2019 and \u2018homes\u2019, have nodes  and node  respectively. In a preferred implementation of the present invention, expanding these nodes reveals the type or types of object to which the reference is allowed to refer. In , it was shown that the \u2018cars\u2019 attribute can refer to more than one type of object. In , it is assumed that it can only refer to objects of type \u2018car\u2019 or of types derived from type \u2018car\u2019. This is a further restriction with respect to the discussion of .","In studying the query in query window  in , a person having ordinary skill in the art will see that there are two keywords, \u2018matching\u2019, and \u2018fetch\u2019, that are not part of the syntax of normal SQL. These two keywords are examples of the extensions to the SQL languages used within this disclosure. These extensions of the SQL language are described herein. Some of them are disclosed in the background art, and they are used as examples to show the extra possibilities available to the object data model and the display possibilities of the present invention.","Starting with a simple conventional SQL query, the format is as follows:\n\n","An example of a valid standard SQL query is:\n\n","Using the example in which the Family.kids attribute is multi-valued, a user can add a \u2018matching\u2019 keyword to the multi-valued attribute as follows:\n\n","With this query, only those Kids called \u2018Fabio\u2019 are returned. The object is not returned as a whole. Note that the selection of the object is via the condition. Once an object has been selected, the selection of attributes within the multi-valued attribute is by a modification of the \u2018columns\u2019 section of the query. The absence of a \u2018matching\u2019 keyword is equivalent to an \u2018all\u2019 keyword meaning return all elements in a multi-valued attribute. \u2018all\u2019 is thus the implicit default. A multi-valued column within the selection criterion \u2018column condition column_or_value\u2019 can be modified by one of three keywords, \u2018any\u2019, \u2018all\u2019, and \u2018no\u2019 as follows:\n\n","With this query, all of the values of the multi-valued attribute Family.kids within a given object have to equal \u2018Fabio\u2019 for the object to be selected. The default behavior is \u2018any\u2019, which selects an object if any of the values within the multi-valued attribute fulfill the condition. A further keyword that may be used in this position is \u2018no\u2019, which is fulfilled if none of the values of the multi-value attribute fulfill the condition.","The keyword \u2018or\u2019 is used to divide two tables. In the following standard SQL query, all combinations of the records in tables \u2018a\u2019 and \u2018b\u2019 would be combined horizontally in a product. If \u2018a\u2019 had 4 rows and \u2018b\u2019 had 5 rows this would result in 20 rows:\n\n","An extension to the language uses the \u2018or\u2019 keyword to create a union. It would list table \u2018a\u2019 followed by table \u2018b\u2019, returning 9 rows:\n\n","The keyword \u2018or\u2019 can also be used to divide columns in a sorting expression:\n\n","In another extension, a further keyword \u2018attr_type\u2019 followed by an attribute type replaces a column name in a query. This is so that selection can be made on the basis of attribute type rather than on attribute name or column name. The following query selects any record containing a field that is an integer, or derived from one that was over 99:\n\n","The \u2018attr_type\u2019 keyword may be qualified with \u2018no\u2019. The following query finds all records that have at least one date-field that contains today's date, and also delivers all records that do not have an attribute of type date:\n\n","Finally, an extension to the query language allows the use of the \u2018fetch\u2019 keyword before a reference column:\n\n","The description of preferred extensions to SQL presented herein has not been exhaustive or definitive. Some of the language extensions disclosed herein can be used to return heterogeneous data from relational databases and others can be used to fetch data from object databases. In either case, the returned data is in a format suitable for display in a grid control of a preferred embodiment of the present invention.","To return to the query in query window  of , the \u2018matching\u2019 keyword is used where a selection uses a multi-valued attribute as a selection criterion. The part of the where-clause \u2018kids=\u2018Fabio\u2019\u2019, selects a row in a relational database. In the object data model, the query selects objects that have at least one \u2018Kids\u2019 data element that matches the selection criterion. The default behavior is then to return all of the \u2018Kids\u2019 elements within the selected objects. The \u2018matching\u2019 keyword overrides that behavior and returns only those data elements of a multi-valued attribute that match the selection criterion. This does not affect multi-valued attributes like \u2018Homes\u2019 that do not form part of a selection criterion. All of these are returned within the selected object. This is apparent from inspection of returned record , wherein the \u2018Kids\u2019 attribute has only one data element, data element , which matches the selection criterion. This is due to the use of the \u2018matching\u2019 keyword. Normally, this object would return three \u2018Kids\u2019 elements, as seen at cells - in .","The other non-standard keyword in the query in query window  is \u2018fetch\u2019. The \u2018Cars\u2019 data element has been fetched. Instead of displaying a handle in the \u2018Get\u2019 state, the data have already been fetched, and the handle for \u2018Cars\u2019 attribute  is now in the \u2018Close\u2019 state. Data elements  and  have been expanded inline as in .","The present invention provides ways of inter-relating data schema tree , representing the data schema with the grid control of the present invention, such as data grid , and the query window . One way to accomplish this is to use data schema tree  to automatically generate all or part of a data query. The present invention is particularly helpful to users interested in queries resulting from the selection of a single element of the tree. In the case where \u2018family\u2019 type  is selected the default query is:\n\n","In the case where the hierarchy below \u2018family\u2019 is expanded and the reference attribute \u2018cars\u2019 is expanded using its node, , selecting the \u2018family\u2019 type  generates the query:\n\n","If subsequently \u2018kids\u2019 element  is selected, the generated query becomes:\n\n","To summarize, selection of an object type in data tree  can signify fetching all objects of that type. Expansion of a reference attribute can signify fetching the referenced data and inserting it inline in the external object record. Selecting a non-reference attribute can signify that the query will filter the selection based on the value of that attribute.","In a preferred embodiment of the present invention, all objects having a field of a certain attribute type can be selected. Referring to , Data Retrieval window  from , showing selection based on attribute type, is illustrated. The figure is labeled using the equivalent labels from  where appropriate. It can be seen that the hierarchy of derived attribute types of \u2018datetime\u2019 attribute type  has been expanded. These are \u2018date\u2019 attribute type  and \u2018timestamp\u2019 attribute type . In this example, \u2018date\u2019 attribute type  has a date part but no time component, so it does not distinguish between different times on the same day. In contrast, \u2018timestamp\u2019 attribute type has both date and time information. In the example, the timestamp is a time that is set at the time of record creation, and cannot be modified. Reflection reveals that the query in query window  up to the \u2018=\u2019 is the default query for a user selecting \u2018datetime\u2019 attribute type , and could be generated automatically by selecting \u2018datetime\u2019 attribute type . This part of the query selects every data element from every type that has an attribute that is of attribute type \u2018datetime\u2019 or of an attribute derived from \u2018datetime\u2019. It can be seen that the attributes that conform to the attribute type specified in the query are the \u2018Birthday\u2019 attribute  in \u2018People\u2019 type and the \u2018Time\u2019 attribute  in Call type.","On selecting \u2018Select\u2019 button , two records are returned. First record  is of type \u2018Call\u2019. Second record  is of type \u2018People\u2019. It can be seen that the values of the \u2018Datetime\u2019 attributes: \u2018Time\u2019  and \u2018Birthday\u2019  match the day on which the query was run (26 Mar. 2001). The ability of the grid control of the present invention to accept heterogeneous data encourages the use of queries based on similar attribute types within different types. The query is effectively asking for every piece of data that refers to a given day.","In alternative embodiments to the preferred embodiment, hierarchical data schema tree  allows for the possibility of displaying actual data values, such as key-fields. This is the case where keys of the objects are displayed as nodes in the hierarchical display. It also provides further opportunities for navigation if classes contain Boolean fields or enumerated fields that can only take a few values. In this case, these possibilities can be represented by sub-branches in the hierarchy. A different color can be used to represent these choices.","The above describes navigation within a data schema. If the interface has cached everything that is known about the data types, navigation of the schema can be done without accessing the data itself, which may exist on a remote server.","The final phase of selection provides the user with the possibility of fetching more fields within the objects selected. In this case, the user returns to the class browser and redefines the required fields. Then \u2018More Fields\u2019 button  is selected and these fields are fetched. Alternatively, by selecting the record handle and right-clicking, a \u2018Fetch all fields\u2019 option is available.","In a preferred embodiment, Data Retrieval window  is not modal. Thus, it is possible to keep it open while working in main Data Processing window . For example, the user could keep the data retrieval window open and copy and paste records into different handles in the main data processing window. Menu options available from selected record handles preferably allow normal copy and pasting of data fields as is commonly implemented in windowing systems. Similarly, records can be dragged and dropped from Data Retrieval window  to Data Processing window , as is commonly implemented in windowing systems. Copying from Data Retrieval window  to Data Processing window  results in copying the visual representation of a record from one window to the other. Copying within Data Processing Window  results in making a new record with the same contents (but different OID) as the record being copied. However, copying a record into a reference data element in another record has the result of copying a reference to that record into the reference element. If the data in data grid  is copied using cut and paste into Data Processing Window , the user can use \u2018Cancel\u2019 button  to remove Data Retrieval window  from the screen. Alternatively, using \u2018Return\u2019 button , the user returns to Data Processing Window  adding the data from data grid  to grid control  of Data Processing window , shown in ,  and .","Data Retrieval window  can be used to select data based on data types or on attribute types. It can also be used to retrieve heterogeneous data. It can be further used to refine the selection of data by adding and dropping records or fields. The user can copy retrieved data using the cut-and-paste or drag-and-drop methods common to background art GUI's. Alternatively, the user can return from the window, bringing back those records selected in the grid control of Data Retrieval window  onto Data Processing window .","To this point in this disclosure, the principles of using the data tree and query window to automatically, or semi-automatically, generate queries have been described in the object world. Referring to , the advantages of a preferred embodiment of the present invention for querying relational databases are illustrated. Because the visual representation of data records is the same for relational as for object data, the same Data Retrieval window  can be used.","Referring to , in data schema tree , relational data sources (e.g., ODBC database sources) are shown as the top level of the hierarchy. It is normal in background art graphical user interfaces to navigate the data schemas of multiple data sources using a hierarchical tree. In the example illustrated in , selection of node  for \u2018datasource\u2019 is operative to start the opening of the data source. This source might typically be an ODBC data source accessed via its DSN (data source name). In this case, the DSN is \u2018datasource\u2019. In a preferred implementation, for some data sources an optional dialog window is displayed requesting a user-name and password. Upon supplying these, the data source is connected to or otherwise opened and the hierarchy is expanded to display the tables in the data source. The use of the expansion of the data source level to signify connecting and opening the database is common in the background art, as is subsequent displaying of the tables within the data source.","In existing art GUI's, opening of a table displays the columns within the table. However, to find the foreign keys the user has to navigate to a different part of the display. Referring to , it can be seen that \u2018Kids\u2019 table  has been expanded. In the example shown, the data schema has changed slightly compared to that for the data in . An extra column, \u2018Id\u2019 column , has been added to \u2018Kids\u2019 table . It can be seen that the columns within the Kids table, \u2018Id\u2019 column , \u2018name\u2019 column , and \u2018parent\u2019 column , are displayed as elements in data schema tree . Below the columns are displayed two extra elements, \u2018Dad\u2019 element , and \u2018hobbies\u2019 element . These elements are expansible via their nodes, \u2018Dad\u2019 element node  and \u2018hobbies\u2019 element node . These extra elements represent foreign keys of \u2018Kids\u2019 table . The present invention optionally represents foreign keys as extra expansible columns in a hierarchical data schema tree. It is possible with the current invention to use the name of the foreign key as the name of the element in the tree, but these are often very long. In a preferred implementation of the present invention, the foreign key elements are labeled with the name of the foreign table to which they refer. It will be seen that there are two foreign keys for \u2018Kids\u2019 table . The first, \u2018Dad\u2019 element , relates \u2018parent\u2019 column  in \u2018Kids\u2019 table  to the \u2018id\u2019 column in \u2018Dad\u2019 table . The second, \u2018hobbies\u2019 element , relates to a new unspecified table in which \u2018Id\u2019 column  in \u2018Kids\u2019 table  is related to a table specifying their hobbies. A child (\u2018Kid\u2019) may have multiple hobbies. Returning to the \u2018parent\u2019 foreign key , it will be noted that its node, \u2018Dad\u2019 element node , has been expanded revealing the data schema for the table related to \u2018Kids\u2019 via this foreign key. In this case the table in question is \u2018Dad\u2019, and it is apparent that the columns of \u2018Dad\u2019 element  (second representation of \u2018Dad\u2019 table ) are \u2018id\u2019 column  and \u2018name\u2019 column . \u2018Dad\u2019 element  also has a foreign key, \u2018kids\u2019 column , which points back at \u2018Kids\u2019 table . Note that second representation of \u2018Dad\u2019 table  is also represented at \u2018Dad\u2019 table . Referring back to , it can be seen that in the object world expandable attribute nodes are reference attributes, whereas in the relational world they are foreign keys. Because relational foreign keys can only refer to one table, expansion of the foreign key node immediately displays the columns of the related table, missing out a stage present in the object case. Summarizing, in a hierarchical tree structure, the data schema of a relational database can be traversed using expansible foreign keys represented as extra columns.","Considering automatic query generation for the relational case, selecting a table at the top of the table hierarchy, such as \u2018Dad\u2019 table  generates:\n\n","This method can be used to join any number of tables via selected foreign keys. Visual programming is improved because the path of navigating through the hierarchy is used to specify which joins are made by the query. The navigation path is the same as the join path.","Selecting a column within a table that is reached by a foreign key from another table within the hierarchy, such as Dad.name column  generates a query with a join and a filter on that column, prompting the user for a value:\n\n","In , panel  contains the keywords used to build up queries in steps. The present disclosure has concentrated on a query generated by a single selection. It will be noted that for a query containing any number of joins and a filtering based on the value of on column or attribute, the expressive power of the proposed interface is capable of generating this kind of query, leaving the user only to key in the value of the filtered column. This is powerful because this class of query represents a large proportion of all queries in SQL. Preferred embodiments of the present invention could clearly be modified to use multiple selections in alternative embodiments.",{"@attributes":{"id":"p-0231","num":"0536"},"figref":["FIG. 23","FIG. 22"],"b":["1902","3510","1920"]},"Grid control  in  with the results of the query from  displayed in a mode described in this disclosure as the object display mode. In the object display mode, first master record  and second master record , are clearly associated with the detail records with which they are associated: first detail records - for first master record  and second detail records - for second master record . Comparing  with , in a background art database grid such as background art grid control  in , first master record  would be repeated three times, filling up the rows until second master record  was displayed. The object display mode of preferred embodiments of the present invention shows the relationships between master and detail records much more clearly than relational output in conventional background art grids. Moreover, background art grids do not have the interactive capabilities of the present invention, due to not having record handles.","Referring to , master record  consists of first record handle , two relational data fields, \u2018id\u2019 data field  and \u2018name\u2019 data field , containing data returned by the query, followed by a reference list of record handles, second record handle , third record handle  and fourth record handle . These record handles represent the foreign key that relates the \u2018Dad\u2019 table to the \u2018Kids\u2019 table, and constitute an extra column or meta-column, that is not present as a column in the relational data schema. Referring back to data schema tree  in , it can be seen that the extra column is equivalent to an extra expandable element, such as \u2018Dad\u2019 element , representing the foreign key. Thus, foreign keys are shown as extra columns both in the data schema tree and in data records. Looking at one of the record handles, second record handle , it can be seen that this forms the record handle of the detail \u2018Kid\u2019s record, which then continues with the following data fields: \u2018id\u2019 data field , \u2018name\u2019 data field , and \u2018parent\u2019 data field . These three data fields contain the relational data returned from the database. Following them are the following two foreign key fields: \u2018Dad\u2019 foreign key field , and \u2018Kids\u2019 foreign key field . Because the Kids\/Dad relationship is many-to-one, this foreign key is represented by a record handle, fifth record handle , whose default action is \u2018Get\u2019 because the data have not yet been fetched. Because the Kids\/Hobbies relationship is one-to-many (one child can have more than one hobby), this is represented by a list handle, first list handle , which upon expansion will fetch all of the records from the \u2018hobbies\u2019 table related to this child.","Thus, in the object display mode, foreign keys in detail tables (wherein the relationship is one to many) are displayed as multi-valued reference fields in the master table, and foreign keys in detail tables are displayed as single-valued reference fields in the detail table. If the foreign keys have not been used in joins, the multi-valued reference fields contain list handles, and the single-valued reference fields contain record handles in the \u2018Get\u2019 state.","It will be noted that the order of tables in the generated query in query window  of  is different from that in which they were selected in the hierarchy. This is because, in object display mode, the master table is on the left, and the detail table to the right. The \u2018order by\u2019 clause added to the query is to group detail records by their master record for the object display mode.","The data shown in grid  in  comprise the result of running a single SQL query on a relational database and formatting the output in the new way of the present invention. However, the record handles and list handles have the same meaning as for object data. Thus, the user can close records that are not of interest. Second detail record handle  is now in the \u2018Save\u2019 state because the user has changed the contents of second \u2018name\u2019 field  to \u2018Fred\u2019, illustrating that the records behave like those from object databases.","The record handles for foreign keys of the detail records, fifth record handle  and first list handle , can be used to navigate further within the data, fetching more data and expanding it inline. The grid control of preferred embodiments of the present invention navigates by fetching data and expanding it inline. This has advantages over opening a new window as background art Internet browsers do. The philosophy of the present invention is to get all data in which the user is interested close together in the same grid.","It is important to consider the relationship between queries in the query window  of  and selections in the data schema tree  that may have generated them. If a user uses a selection in the data schema tree to partially generate a query, the application program already knows what foreign keys are being used for joins, and which table is the master table. Thus, when the \u2018sort by\u2019 clause is added, which is a requirement of the object display mode, this can be supplied by the data schema tree. If, however, the query is typed free-form into query window , the query must be parsed by a module that has knowledge of the data schema, to supply this \u2018sort by\u2019 clause. Also, the automatic re-ordering of the tables to put the master on the left must be performed on the user-supplied query by the parser module if the user supplies the query by hand. If the user-supplied query does not contain the primary keys for any of the tables, the parser modifies the query to include these columns. This means that although the primary key columns might not be displayed, they are still stored so that they can be used to save or delete modified data.","Preferably, the object display mode is optional. That is, if the user wants data returned as uniform rows, this is also possible. Without the object display mode, the display of a preferred embodiment of the present invention is similar to that in , but with the cells like cell  replaced with record handles. However, the actions available to these record handles are likely to be limited to actions such as \u2018Close\u2019 that do not modify data, as the record contains data from two tables. It is possible to conceive an interface between the grid and the database capable of implementing \u2018Save\u2019 actions, but the data repetition between different records makes this much more difficult.","Whereas removal of data duplication was a goal of the relational method of storing data, output from relational queries increases data duplication on display. The present invention reduces data duplication on display, and distinguishes between data that are different but have the same value.","The object display mode for relational data displays joins between tables using foreign keys, often called natural joins, using the record handle that represents the foreign key to represent the join. The present invention is also capable of joining on any data field using any condition.","One having ordinary skill in the art will know that a join consists of linking two sets of data with one or more conditions. This disclosure only deals with the case of a single condition, but one having ordinary skill in the art would understand how to extend these concepts to more conditions. The two sets of data are known as the left-hand and right-hand sides of the join. The condition relates a single field in a record from the left-hand side to a single field in the record of the right-hand side. Thus, to specify the join one must supply the two datasets, the two fields and the condition linking them.","There are two cases in which preferred embodiments of the present invention are capable of displaying non-natural joins. The first is as the result of parsing a query that contains a join. If the parser determines that the join is not a natural one (i.e., it is not using an embedded record handle), the system inserts a join icon as discussed later. The second case is an interactive join with existing on-screen data.","Referring to , a representation on the screen of a preferred embodiment of the present invention of a join between two relational tables or between two object types is presented. In this case, the join was present in the original query. The data from \u2018Electricity Bill\u2019 record , shown in , is joined to records in a table called \u2018Royal\u2019, which contains names and ages of some of the British Royal Family. The data are displayed in grid control  of the Data Processing window from . The query, which is syntactically identical to standard SQL, is shown in query window . It matches all royals whose age is less than the customer ID. It is not a likely query, but illustrates several points. First record handle  and fields  and  of the \u2018Electricity Bill\u2019 record are broken at the joined \u2018Customer\u2019 field  by join icon . These items are followed by the items of the matching records from the second record type. There are two matching records, second record handle , with data fields  and , and third record handle  with data fields  and . The rest of the fields from the \u2018Electricity Bill\u2019 record fields - are shown after the \u2018Royal\u2019 records. The decision concerning whether to put the new joined record at the end of the existing record, or to insert it after the field on which one is joining is an option that can be decided by the user or the programmer.","Join icon  is preferably a red diamond, shown as white in monochrome, but can be of any shape and design. One join icon is preferably related to each joined data cell on the left-hand side of the join. The join icon preferably represents a join between a data record described as on the left of a join and one or more records on the right. A Join display item is the object passed to the grid to be displayed as a join icon. It has a pointer to the item that was joined on one side, usually described as the left of the join, and a list of records on the other side. The \u2018Close\u2019 action of the join icon removes the data records logically on the right-hand side of the join from the grid control.","The display of joined data is preferably identical in the case of an interactive non-natural join. In this case, initially, one or more cells of data existing in the grid of the present invention are selected by the user as the fields of the left-hand side. The set of selected data elements need not be the same attribute or from the same type. In the interactive case, the \u2018Join\u2019 action of the data cells is used to allow the user to specify the other two components: condition and right-hand side. Second, the condition governing the join is supplied by the user. Usually this is a join on equality, and this is supplied automatically. Third, the set of data with which to join the selected data must be defined by the user. The user selects the set of data and the field to be tested for the condition. In the simple case, the user selects a given field within a table as the set of data to which the join condition is applied.","To arrive at the display in  interactively, a right-click on data cell  causes that cell's pop-up menu to be displayed. In grid controls of the present invention, data fields have actions. Selecting the \u2018Join\u2019 action takes the user to Data Retrieval window  of the present invention as shown at . The \u2018Royal\u2019 table (not shown) is found in data schema tree  and opened. Selecting the \u2018age\u2019 column within the \u2018Royal\u2019 table then automatically generates the following SQL query\n\n","In a preferred embodiment, selecting \u2018Select\u2019 button  in  selects the two records whose handles are  and , and displays them in grid , preceded by join icon . Selecting \u2018Return\u2019 button  returns display items - from the Data Retrieval Window to display joined to the left-hand side in grid , where the join action was initiated as shown in .","The preferred embodiments described in this disclosure select data in the Data Retrieval window  and transfer it to the Data Processing Window's grid . Other preferred embodiments could perform all operations in a window similar to Data Retrieval window , without a need for a second window. Similarly, new types could be generated using the same data schema tree  as is used for data selection. However, there are advantages to having two grids, and creating joins is one operation that is greatly simplified by using two windows.","In the general case, the left-hand side contains multiple fields. Returning multiple sets of records, the interface must divide them up between the selected fields on the left-hand side.","Specifying the right-hand side consists of selecting both a set of data to consider, and the field within that data. The same visual metaphor using the data schema tree is used as described for  for selection of initial datasets, with the complication that an attribute must be selected as well as a table or object-type. Depending on the underlying data model, the data schema tree may be a simple hierarchy of tables and columns as in  or types, attributes and attribute types as in . In the Data Retrieval window, if the user selects a data attribute within a data type in data schema tree , and returns, the action is to join each selected data element to records of that data type whose value for that attribute matches the selected data element in the left-hand side of the join. Alternatively, if the user selects a data attribute type and returns, the action is to join each selected data element to one or more records from any data type containing an attribute of that attribute type where the attribute matches the selected data element in the existing left-hand side of the join. In a less likely scenario, if the user selects a data type in data tree , the join matches any field or attribute within that type. Note that these joins are based on equality between the fields on either side of the join.","A join is effectively a select using selected fields as the right-hand side of the comparison. Related extensions to the SQL language are discussed later. However, if a query has to be created to complete a complicated join, it can be seen to be the equivalent of a select query involving a join, where one half of the join has already been selected. Consider the query discussed earlier, that produces the output in :\n\n","Previous sections of this disclosure have described what preferred embodiments of the record, grid control and software application do. The next section deals with how preferred embodiments accomplish these things.","Referring to , object relationships within the grid control of a preferred embodiment of the invention are illustrated. The objects here are not database objects, but objects in the software design of a preferred embodiment of the invention. To avoid confusion, the discussion refers to the grid rather than the grid object, the type instead of the type object, and so on. In , grid  has a list of rows - of data and headers that it is displaying. The rows consist either of lists of header labels - or of lists of display items , , , , , and . Display items include references (represented on screen by record handles), joins and display items relating to data fields. In , no joins are shown. Display items , , and  belong to first data record  and display items , , and  belong to second data record . The data records in turn are of a certain type, type . The display items and labels are related to type names  in the case of the display items for the record handles  and  and to type attributes  and  within the type, as shown by the dotted arrows. In a preferred embodiment, types contain type names and data records contain display items, but other approaches may be taken. Alternatively, data records can point to display items. Note that in  these types and attributes are display types and attributes. They do not necessarily relate to object database types and attributes. They can equally refer to relational database tables and columns. The objects shown in  are in a format that the grid control is capable of displaying, and as such are transformations of the data in the underlying data model, be it relational or object data.","Display item  for first data record  is the single-valued reference related to the record handle for the record. It contains information about how to save the record. Joins are not shown here, but they are display items, and have their own header labels. Dashed line  shows the boundary between, on one side, software objects generated by the grid control\u2014the grid, rows and header labels, and, on the other side, objects created by the calling program and passed into the grid\u2014the types, attributes, data records and display items.  also shows that a display item that represents data contains the data to be displayed in it. Attribute  is a multi-valued attribute. This means that display items  and  have more than one data element\u2014data elements  and  for display item  and data elements  and  for display item . One having ordinary skill in the art will realize that use of the data elements is required for the initial display, but for subsequent updating of the database, a choice to access the version of the data maintained by the windowing system may be made.","The following discussion is concerned with several, preferred basic display item types or kinds, which are named here. The record handle for a given object has a display item type of SVARef, meaning that this is a single-valued reference item. An embedded reference within a record is also of type SVARef, but a multi-valued attribute containing references is of type MVARef. Joins are of display item type Join. Ordinary single-valued text fields are of kind SVAText, and ordinary multi-valued text fields are of kind MVAText. Note that text fields are capable of containing numbers, so with these display item types, a lot of functionality is available. Note also that there is one display item for each multi-valued field, but these may be linked to several graphical elements.","Referring to , relationships between a preferred embodiment of the grid control of the present invention and an object database are disclosed.  shows the relationship between data supplied by the object database and the equivalent data passed to the grid control of the preferred invention. The object data model is as follows:\n\n","Referring again to , object database\/grid interface  is a preferred embodiment of an object database\/grid control interface of the present invention. It is an interface between such an object database and the grid control of the present invention. Items above interface  in  are data presented by an application-programming interface (API) of the object database. Items below interface  are the data that are passed by interface  to grid control  of . Thus, data record  is the data record of the same number shown in . Type  is as shown in , although arranged differently on the page. Similarly items - and - are labeled using the same numbers as in . It is apparent that the list of display items starting at display item  is that required for record  in , providing that the \u2018Kids\u2019 attribute is omitted (for reasons of space). Note also that Cars has an extra data element in .","At the top of , type  is the database equivalent of grid control type . Type  is in the format supplied by the API of the object database, and grid control type  is in the format required by a preferred embodiment of the grid control of the present invention. Similarly, type name , which contains the name \u2018Family\u2019, is the equivalent of grid control type name , and the attributes , , and  match type attributes , , and , respectively. Object  represents the data returned by the database. It is identified uniquely to the database by object identifier (OID) . In some systems, to uniquely identify an object, the combination of type and OID is used. Because preferred embodiments of the present invention allow very weak type-control of data, it is assumed here that the database illustrated in  just uses the OID. Apart from the OID, the data object contains a series of elements  or groups of elements  and , one for each attribute - in the object's type . If a type's attribute is multi-valued, the data consist of a list or set of elements. Thus, data field  has two elements, element  and element , as does data field  (element  and element ).","Using the data model from the top half of , an object database is likely to have an API containing functions like those shown below. The parameters to the function are shown in parenthesis. The function list presented below is not exhaustive:","Oid_get_object(oid): Use the supplied OID to get an object similar to object  containing an oid and a list of elements from the database.","Oid_get_elements(oid, attribute_list): Use the supplied OID to get part of an object. Return only those attributes named in the list.","Type_get_attr_list(type): Given a type name or identifier, return a type and list of attributes like type  and its attributes.","Save_object(object): Given an object , containing an OID and elements, save the object to the database.","Allocate_object(type): Allocate a new object structure like object , based on the supplied type like type .","Define_type(type_name, attribute_list): Define a new type in the database with the supplied type name and an attribute list like that of starting attribute .","When updating the data in the database, a call is made to the save_object( ) function, passing object  with an updated list of elements -. The database uses OID  to reference the object to be updated in the database. Similarly, when fetching an object referenced by a reference field, calling the oid_get_object( ) function passing the OID stored in the reference field as a parameter returns an object like object .","In a preferred embodiment, the role of object database\/grid interface  is to convert a type, like type , and its attributes ,  and , into the equivalents, type  and attributes , , and . Similarly, database\/grid interface  converts an object, like object  and elements -, into data record  and other display items , , and . Examining the symmetry of , it is clear that a newly-designed database can be customized to return type structures identical to those used by the grid control. Similarly, such a database can supply objects in the format of data records and display items, although the additional data structures relating to the specific windowing system being used render the database interface structures larger and more platform-specific. In any case, it is clear that for this preferred object database model, database\/grid interface  is uncomplicated. For other data models such as CORBA, XML, etc., the interface needs to accomplish more work. In most cases, some form of transformation of the data from the database's data model to that required by the grid of the current invention is required. In the object world, this transformation is required if multi-valued attributes are not atomic. By atomic is meant a data type which has no internal structure such as a number or a character-string. If data elements in a multi-valued attribute have structure, the transformation is to represent them as lists of references. The record handles in the reference list control the contents of the structure of the individual elements. Thus, although all of the data in the complex data element is internal to the object, it appears on the screen related to a record handle which normally signifies a reference to data external to an object. The present invention is capable of representing many different types of data by generalizing the representation. This means that the division into records on the screen does not always conform to the granularity of the data model in the database.","Referring to , relationships between a preferred embodiment of the grid control of the present invention and an existing art relational database management system (RDBMS) are illustrated. This figure is equivalent to  for the relational database case. As in , there is a database\/grid interface, in this case a preferred embodiment of relational database\/grid interface  of the present invention. Items above interface  are representations of data and metadata in the relational database, and items below it are data that are passed to the grid control of the preferred embodiment of the present invention.  shows record  from , without the \u2018rate\u2019, and \u2018total cost\u2019 columns. All of the columns come from the same table , with table name  of \u2018gas_bill\u2019. The database returns a series of rows such as row , with data fields - relating to table columns -. Only one row is shown here.","The role of interface  is more complicated here than in the case of an object database\/grid interface. The unit of granularity, that is, the unit in which data are saved to the database, is a row or partial row within a single table. Therefore, if the query joins two tables, the interface usually splits the query results into two sets of data records\u2014one for each table. In the case of the query shown, there is only one table, so there is one data record, data record . This data record contains the familiar display items: item , for the record handle's reference item, items - for the record fields, and their data elements -. The data elements are simply the contents of data fields -.",{"@attributes":{"id":"p-0265","num":"0578"},"figref":"FIG. 18","b":["2324","2302","2325","2326","2329","2304","2307","2301","2314","2301","2314"]},"If the original query does not contain the primary key information, interface  adds those columns to the query. In the case of , the primary key information is considered to be the Customer and the Date (the customer can only receive one bill per day). This information is passed from item  and item  not only to data elements  and  in the display items representing those columns, but also to data element  of handle . The data are shown as being stored as a where-string. A where-string is the string that is the clause in an SQL query that determines whether a row is included in a selection. When one uses equality to the primary key in a where-string, this identifies a row uniquely. Thus, to save the data when modified, the query becomes as follows:\n\n","The part of the query up to \u2018values\u2019 is obtained by traversing the type and attributes -. The new values are obtained from data elements -, and the clause after \u2018where\u2019 is that stored in the handle's data element . In fact, only the modified fields need to go into the update query. Thus, interface  is capable of saving modified records in a simple and uniform way. The procedure for saving the data is independent of any knowledge of the specific tables in the relational database, which need not be known when the interface is built. Where the relational query consists of a join between single rows in a master table and multiple rows in a detail table, the object way of displaying these data means that the master table row is only displayed once.","Referring to , relationships between a preferred embodiment of the grid control of the present invention and an RDBMS are illustrated, showing how to combine tables and represent them on-screen as a non-relational type. This figure is equivalent to  for the relational database case. As in , database\/grid interface  is provided. In this case, database\/grid interface  is a more complicated embodiment of a relational database\/grid interface of the present invention than is interface  in . Items above interface  are representations of data and metadata in the database, and items below it are data that are passed to the grid control of the preferred embodiment of the present invention.","Interface  is capable of storing metadata about how to connect groups of relational tables into larger entities. This practice is known in the art, in particular in the sense that the relational tables are often designed as these larger entities and then broken down or \u2018normalized\u2019 to satisfy the relational model. In the example illustrated in , the tables \u2018Dad\u2019 and \u2018Kids\u2019, from  have been combined into an entity \u2018Family\u2019.","The data shown is the first two data rows shown in . First table  has a first table name  of \u2018Dad\u2019. Columns  and  are \u2018Dad.name\u2019 and \u2018Dad.id\u2019, respectively. Second table  has table name  of \u2018Kids\u2019. The \u2018Kids\u2019 table has two columns: \u2018Kids.name\u2019 column  and \u2018Kids.Parent\u2019 column . The following standard SQL query sent to the RDBMS returns several rows, of which only two are shown here:\n\n","First row  contains four fields -. Second row  also contains four fields -. Prior to the query, a decision was made and stored within database\/grid interface  that the two relational database tables \u2018Dad\u2019, and \u2018Kids\u2019, are to be combined as a single type  with type name  of \u2018Family\u2019. The two tables are to be joined by the columns \u2018Dad.id\u2019 column  and \u2018Kids.Parent\u2019 column  and the displayable fields are to be \u2018Dad.name\u2019 column , which is renamed as \u2018Dad\u2019 attribute  and \u2018Kids.name\u2019 column , which is renamed as \u2018Kids\u2019 attribute . \u2018Kids\u2019 attribute  is a multi-valued attribute. This avoids data duplication. Database\/grid interface  combines two rows of relational data  and  into single data record . First display item  is the reference (displayed as a record handle) for data record . The second display item is the field for \u2018Dad.name\u2019 column (\u2018Dad\u2019 attribute). Note that adopting an object-based display mode means that duplicate data fields  and  are reduced to a single field. The primary key information for the first table, \u2018Dad.id\u2019 , is stored in data element  of the record handle's reference item. This is sufficient for saving modified data back into the \u2018Dad\u2019 table, but it is not sufficient for writing back the data to the \u2018Kids\u2019 table. In this example, the primary key for the \u2018Kids\u2019 table consists of both columns  and . It is assumed that no two Kids have the same name and the same Dad (for the purposes of the example). This means that, for the combination of more than one relational table into a single display type, interface  has more work to do, related to tracking of primary key information of detail tables. This does not mean that interface  cannot perform this task. It simply means this is not shown on .","The join between the \u2018Dad.id\u2019 column and the \u2018Kids.parent\u2019 column is used to bind two relational tables into a larger object. However, other foreign keys defined on the \u2018Dad\u2019 table and \u2018Kids\u2019 table, or defined on other tables to link them to the \u2018Dad\u2019 and \u2018Kids\u2019 tables, can be represented as references or reference lists in this interface and displayed as record handles or list handles in the grid control. Thus, in the relational world, the present invention is capable of combining simple table rows into complex on-screen objects, whereas, as discussed for  above complex objects in the object world may have to be broken down to conform to the visual model used by the present invention.","To maintain the extensibility of the graphical elements displayable by the grid, a preferred embodiment maintains a split between display items, as discussed in , and the graphical elements that represent them on the screen. In the simplest example, a single-valued text display item is represented by a white editable text cell on the screen. There is a one to one relationship between the logical display item and graphical element that represents it. However, a list of references can either be represented by a list handle or by a series of record handles. This is the first reason for splitting the graphical representation from the logical display items. If a grid control is designed as a component, with an interface that allows it to be passed software objects of classes derived from a base class \u2018DisplayItem\u2019, this means that new display items can be designed after the grid control. These new classes may in turn be represented by newly defined graphical element classes.","In a preferred embodiment developed using C++ Builder, the display items are derived from a base class, DisplayItem. The display items are SVAText (single-valued text item), MVAText (multi-valued text item), SVARef (single-valued reference), MVARef (reference list), and Join (join). The graphical elements are instances of windows classes derived from C++ Builder classes that can be displayed on the screen. The record handle is a TRecordHandle class derived from a C++ Builder customizable edit box, TCustomEdit. The cell of a single-valued non-reference attribute, TSVACell, the cell of a multi-valued non-reference attribute, TMVACell and the list handle, TlistHandle, are also derived from TcustomEdit. The header label is implemented as TMyLabel, which is derived from TCustomEdit, but is set to read-only. The join icon is implemented as TJoinIcon, which is derived from TBitBtn, a button class whose icon can be customized","The preferred process creates graphical element structures that the windowing operating system can display such as, TMyLabel, TSVACell, TMVACell, TRecordHandle, and TjoinIcon, and associates them with their display items, SVAText, MVAText, SVARef, MVARef, and Join. Derived classes are required because the behavior of the graphical elements is modified. However, most of the normal behavior of an edit box is inherited. For example, when the user types input on the keyboard it appears as it normally does in the cell. Pressing the backspace key removes the preceding character. In the Microsoft Windows environment, the new derived windows classes are registered with the operating system. Registration means that the behavior of the classes, when certain events happen, can be modified with respect to that of the base class.","The terms \u2018grid\u2019 and \u2018grid control\u2019 are used interchangeably in this description. In C++ Builder, it is possible to build controls as components. These components have well-defined behavior and can be used by other programmers in their programs. However, the \u2018grid\u2019 of a preferred embodiment of the present invention is implemented using an unmodified TScrollBox. The extra functionality and data can be defined externally. In this sense, it is not a new control in the C++ Builder sense, and is not a new Windows class as far as the operating system is concerned. Alternatively, the grid control can be implemented as a component.","In the case where the program wants to display a data record on a new row, a linked list of display items is passed to the grid control for display. The grid control calls a routine to display the first display item. Using object-oriented programming, the routine is customized for the class of display item being displayed, derived from the base DisplayItem class. The routine is passed details of the position of the display item in terms of previous and next display items. Some parts of the routine are standard, so for example the position of the new display item is always immediately to the right of the total extent of previous display item. At the end of the routine, the width and depth of the DisplayItem must be calculated to work out where the next DisplayItem should go. The calculation of the width of a DisplayItem is easy for a SVAText item (it is the width of the cell). For an MVARef, the calculation is more difficult, and takes place using the overloaded sub-function defined for this class. In the prototype, a record handle, whose logical object is an SVARef or MVARef object was assumed to contain the display items representing fields in the record, including embedded record or list handles.","Referring to  again, the record handle list is considered as a single display item with depth stretching from  to . Its width is that of the widest record within the lists, stretching as far as  and . This assumption enables the correct alignment of the homes label,  and list handle .","Preferably, the grid is capable of calculating whether the new item requires a new header. This means the application does not need to do this. Display or removal of headers may require repositioning of subsequent rows.","One having ordinary skill in the art will know that display of differing display items in a list can be implemented in an object-oriented programming language by creating a base class, DisplayItem, and deriving the different types of display item from it. Using this approach, the display of a given item is defined as the implementation of a virtual function for its derived class.","In a preferred embodiment using Borland C++ Builder, a data row is displayed by calling a routine called DisplayItem::Display( ) to display the first display item. The base function of Display( ) is used for all display item classes, but this function calls virtual functions\u2014functions which are defined differently for the various derived classes of the base class. Record handles are considered to own their data records, so the routine displays the record handle and then items belonging to it, called dependent items. For simple text display items, there are no dependent items, so the virtual function of this class to display dependent items does nothing. Display( ) then displays the next reference, which is only active in the case of reference lists. Finally, it displays the next item. The display continues rightwards and downwards until there are no more display items that have not been displayed or are in the wrong place.","The simplified code shown below illustrates how separating the display item from the graphical element allows extensibility. The part of the code where the Display( ) routine creates the graphical element if it is not present and then displays it at a certain position and size is shown. At A: a pointer to a generic graphical element Tcontrol is created. Virtual function GetControl( ) which is shown below for class SVAText returns the graphical element for this object of this class. If the value is null there is not graphical element, and the CreateGraphicalElement( ) function for the class is called. In the case of SVAText, it creates a TSVACell object. GetControl( ) is called again to get a pointer to it. The generic function InsertControl( ) which works for all Tcontrol objects is called to insert the graphical element into the grid. At F: for new or existing graphical elements, SetBounds( ) is called to locate and size the graphical element in the grid. Thus, to define a new display item and graphical element, new versions of CreateGraphicalElement( ) and GetControl( ) must be defined.",{"@attributes":{"id":"p-0283","num":"0598"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void DisplayItem:Display(TscrollBox * grid, int x_location, int"},{"entry":"y_location, Int width, int height, bool expanded)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Tcontrol * control;","\/\/ A: The graphical element is"]},{"entry":"derived from a windows control"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Graphics = this->GetControl( );","\/\/ B: Get any existing"]},{"entry":"graphical element"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If (!Graphics)","\/\/ C: If there isn't already a"]},{"entry":"graphical element create it."},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"this->CreateGraphicalElement( );","\/\/ D: use the virtual func-"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"tion for this display item to create its graphical"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Graphics = this->GetControl( );","\/\/ element."]},{"entry":[{},"this->InsertControl(Graphics);","\/\/ E: insert the control in-"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"to the grid."},{"entry":"}"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Graphics->SetBounds(x_location, y_location,","\/\/ F: Set the size and"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"width, height);","location of the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"control"},{"entry":"}"},{"entry":"void SVAText::CreateGraphicalElement(void )"},{"entry":"{"},{"entry":"cell = new TSVACell(grid, data, this);"},{"entry":"}"},{"entry":"TControl * SVAText::GetControl(void)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return cell;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Once the record has been displayed, the system waits for user interaction such as selection of handles or typing in values into data fields. As discussed above, the response to user interaction is governed by routines supplied by the interfaces to the grid control of the present invention.","Referring to , a software architecture diagram showing a preferred embodiment of the interface between the grid control of the present invention and background art RDBMS  is illustrated. It shows the interactions between the three components for a simple query. It also shows the architecture and interfaces between RDBMS , RDBMS\/grid control interface component of a preferred embodiment of software application  of the present invention and grid control  of the present invention. RDBMS  may be a client-server RDBMS from Oracle Corporation, Redwood Shores, Calif.; Sybase Inc of Emeryville, Calif.; Informix Software of Menlo Park, Calif.; or a PC-based database or database file such as Paradox from Borland; or Access from Microsoft or any other conventional database. Accessing relational database  may equally be via a standard interface such as ODBC. The diagram deals with the case of a standard SQL query, but is sufficient to describe non-standard queries. At initialization of the software program, interface , or another component of the software application allocates grid control  and displays it at allocation procedure . It also connects to the database at connection procedure , and either gets the complete database schema at this stage, or subsequently gets the parts of the schema it is interested in for individual queries.","When the user submits a query, the interface pre-parses a query that is supplied to it into one or more standard SQL queries at pre-parsing procedure . In this example, procedure  has no effect on the query, because it is a standard SQL query that contains primary key information. At query transmission procedure , the interface sends the resultant standard SQL query or queries unchanged to the RDBMS. One having ordinary skill in the art will see that the query in the example is consistent with fetching several records. One of the records returned could be that whose display is shown in . At data transmission procedure , the database sends rows of data to the interface. At type and record allocation procedure , the interface allocates a type structure conformant with the interface of grid control , as described in . The attributes of the type are allocated to be equivalent to the columns of the query. The reference display item for a record handle is supplied with an action for saving the relevant row, if it is changed. Each record handle is given the same \u2018Save\u2019 action. For standard SQL, this is directly derivable from the types. Each handle is supplied with data uniquely identifying the record, e.g., \u201cCustomer=9 and date=\u201801\/11\/2001\u2019,\u201d called a where-string. Alternatively, interface  in  stores information about the primary key of table . These relevant data from fields - for the record can then be accessed in the case of a \u2018Save\u2019 action to create the where-string at the time of the action. The record handle is also provided with a list of actions for its pop-up list, a default action for click, and a default action for double-click, as discussed above. In a simple embodiment, where a single interface  and the grid control are combined, these actions may be identical for each record handle. In the more general case, these actions may differ, and are passed to the grid at run-time. However, in a preferred embodiment, the \u2018Save\u2019 action can be the same for all relational records. (To be more precise, the part of the \u2018Save\u2019 action that generates an SQL query can be the same and the means of sending that query to different relational databases may differ).","At type and record allocation procedure , interface  prepares rows of display items in the format required by the grid control interface as shown in . At row passing procedure , these rows are passed to the grid control. At display procedure , the grid control creates and displays each data row of display items, adding a header row if required. The grid control then waits for user input. At handle update procedure , the data in the grid control have been changed, and the default action of the handle for a given row has been changed to \u2018Save\u2019. An example is record  in . The change of record handle state is internal to the grid and is not shown in . On selecting the handle with state \u2018Save\u2019, the save action defined by the interface at type and record allocation procedure  is called. At pointer passing procedure , a pointer to the data record is passed back to the \u2018Save\u2019 action, which is logically part of interface .","At update query creation procedure , the \u2018Save\u2019 action obtains the where-string from the handle, or generates it from information about primary keys. It also obtains the updated data from the record, and creates a standard SQL update query. This update query is passed to the RDBMS as a query at database update procedure , thus updating the data in the database. The \u2018Save\u2019 can build up an SQL query to update the database simply by traversing the record and noting what fields have changed. The query is as follows:\n\n","In a preferred embodiment, interface  has the following characteristics. Firstly, the commands it sends to the RDBMS  are standard SQL queries. It requires only an existing connection to a relational database, and information about the data schema. Secondly, the action of the \u2018Save\u2019 action described above is entirely generic, and the query it creates is determined by the relational schema of the database, the initial data and the actions that have been performed to change the state of the data displayed on the screen. Thus, a minimal relational database interface embodiment connects to the proposed grid control and record controls in such a way that no customizing of actions is required. The interface does not need to know anything about the schema in advance. The interface can then be customized to interface to drivers for any standard RDBMS, or to ODBC data sources. A prototype was developed by the applicant that was capable of attaching to ODBC drivers for RDBMS's from several manufacturers and fetching the data and modifying it in a completely general manner.  used the example of a standard SQL query, but pre-parsing procedure  is capable of converting non-standard SQL queries into a series of standard SQL queries.","Referring to , a logic flow diagram of a preferred routine for converting a query that need not be standard SQL into standard SQL queries containing key information is illustrated. It is equivalent to pre-parsing procedure  in . It would also have been effective for creating the heterogeneous data from an RDBMS in . On input, the query preferably is in the non-standard version of SQL used through this disclosure. At query parsing step , the syntax of the query is parsed. If the syntax is not normal (i.e., standard SQL), the decision at decision step  sends the query to be split into one or more standard queries at query splitting step . At obtain standard query step , the first\/next standard SQL query is taken. At obtain table step , the first or next table within the current standard SQL query is taken. At unique field determination step , if selected fields selected by the query do not include the primary key or other data uniquely identifying the records making up the query, the current query is passed to primary key addition step , where extra fields are added to it so that the primary keys are present. At other table determination step , the routine loops back if there are more tables in the query. At execute query step , the standard SQL query with possibly extra key fields is executed. At process other queries step , the routine loops to process further SQL queries if there are any present. Once all the queries have been run, merge results step  is run. This imposes order in cases where the query requires the results to be sorted in terms of a field or field-type that occurs in more than one of the tables queried, such as date fields - in .","In the query discussed in , the individual rows returned consist of records within single tables, rather than with joins. This means that provided primary key information was stored for each record (i.e., either the query already contained this information, or the pre-parser added it), the grid control has enough information to save the record if its contents are changed. Thus, the record handle can advertise its \u2018Save\u2019 action and the user can save data. If the rows returned consist of joins between two or more relational tables, for the user to be able to save changed data, one handle must be displayed for each table represented in the row. This can be done provided the pre-parser is set up to get primary key information about the records that are being fetched.","An operational prototype of a preferred embodiment of the interface of the present invention was implemented. The prototype allowed the user to select one of the following new types: \u2018Family\u2019, \u2018Car\u2019 or \u2018Home\u2019. Selection of the \u2018Family\u2019 type caused a header row to appear in the main window. Selection of \u2018New Object\u2019 caused a new record to appear. (In an alternative implementation, the first record appeared automatically with the type.)","Inputting data into the single-valued text (white) and multi-valued text (yellow) cells caused the action on the associated handle (the blue cell on the left) to change from \u2018Close\u2019 to \u2018Save\u2019. Extra data was input to the multi-valued text cell by pressing the down-arrow key and keying in the text. Double-clicking on the list collapsed the list and subsequent rows moved up to fill the vacated space. Double-clicking again expanded the list showing that the data were not lost. Subsequent rows moved down to accommodate this action.","Selection of \u2018New\u2019 on a multi-valued reference record handle (blue) in the Cars column allowed the user to select the type of the referenced object. Thus, the type was not imposed on the user by the software\u2014the user could have inserted a \u2018Home\u2019 into a \u2018Cars\u2019 column. On return, the Second multi-value attribute handle for \u2018Homes\u2019 was pushed to the right and an extra record handle appeared below the one the user had just added a record to. When the user input the details of a \u2018Car\u2019, the record handle changed to \u2018Save\u2019. When inner records were saved and closed, subsequent rows were shifted inwards.","The prototype implemented the data schema tree of  as a means of navigating and querying ODBC datasources. Queries involving joins and filters were automatically generated by selecting the data tree schema. The data were presented in the grid in the object display mode for relational databases with foreign keys represented as record handles or list handles. Modifying data in records made the default action of the record handle \u2018Save\u2019. Selecting \u2018Save\u2019 successfully wrote data back to the ODBC databases. The same interface was capable of accessing Oracle and Microsoft SQL Server databases.","Many variations of the invention will occur to those skilled in the art. Some variations include means and methods for representation of data from relational databases. Other variations call for means and methods for representation of data from object databases. Other variations call for means and methods for representation of data, often transient data, not stored in databases, such as XML data. All such variations are intended to be within the scope and spirit of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The features of the invention will be better understood by reference to the accompanying drawings which illustrate presently preferred embodiments of the invention. In the drawings:",{"@attributes":{"id":"p-0100","num":"0100"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0101","num":"0101"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0102","num":"0102"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0103","num":"0103"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0104","num":"0104"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0105","num":"0105"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0106","num":"0106"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0107","num":"0107"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0108","num":"0108"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0109","num":"0109"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0110","num":"0110"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0111","num":"0111"},"figref":["FIG. 12","FIGS. 9 and 10"]},{"@attributes":{"id":"p-0112","num":"0112"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0113","num":"0113"},"figref":["FIG. 14","FIG. 13"]},{"@attributes":{"id":"p-0114","num":"0114"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0115","num":"0115"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0116","num":"0116"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0117","num":"0117"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0118","num":"0118"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0119","num":"0119"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0120","num":"0120"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0121","num":"0121"},"figref":["FIG. 22","FIG. 13"]},{"@attributes":{"id":"p-0122","num":"0122"},"figref":["FIG. 23","FIG. 22"]}]},"DETDESC":[{},{}]}
