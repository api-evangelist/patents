---
title: Methods, systems, and computer program products for network firewall policy optimization
abstract: Methods, systems, and computer program products for firewall policy optimization are disclosed. According to one method, a firewall policy including an ordered list of firewall rules is defined. For each rule, a probability indicating a likelihood of receiving a packet matching the rule is determined. The rules are sorted in order of non-increasing probability in a manner that preserves the firewall policy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08042167&OS=08042167&RS=08042167
owner: Wake Forest University
number: 08042167
owner_city: Winston-Salem
owner_country: US
publication_date: 20060328
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","GOVERNMENT INTEREST","TECHNICAL FIELD","BACKGROUND ART","SUMMARY","DETAILED DESCRIPTION OF THE INVENTION","REFERENCES"],"p":["This application claims the benefit of U.S. Provisional Patent Application Ser. No. 60\/665,664, filed Mar. 28, 2005; the disclosure of which is incorporated herein by reference in its entirety.","This invention was made with Government support under Grant No. DE-FG02-03ER25581 awarded by U.S. Department of Energy, Mathematical and Computational Information Sciences Division. The Government has certain rights in the invention.","The subject matter described herein relates to optimizing polices for network firewalls. More particularly, the subject matter described herein relates to methods, systems, and computer program products for optimizing performance of network firewalls.","Network firewalls remain the forefront defense for most computer systems. Guided by a security policy, these devices provide access control, auditing, and traffic control [3, 30, 31]. A security policy is a list of ordered rules, as seen in Table 1, that defines the action to perform on matching packets. For example, an accept action passes the packet into or from the secure network, while deny causes the packet to be discarded. In many implementations, the rule set is stored internally as a linked list. A packet is sequentially compared to the rules, starting with the first, until a match is found; otherwise, a default action is performed [30, 31]. This is referred to as a first-match policy and is used in many firewall systems including the Linux firewall implementation iptables [25].",{"@attributes":{"id":"p-0006","num":"0005"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Security Policy Consisting of Multiple Ordered Rules"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Source","Destination",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["No.","Proto.","IP","Port","IP","Port","Action","Prob."]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}},{"entry":["1","UDP","1.1.*","*","*","80","deny","0.01"]},{"entry":["2","TCP","2.*","*","1.*","90","accept","0.02"]},{"entry":["3","UDP","*","*","1.*","*","accept","0.10"]},{"entry":["4","TCP","2.*","*","1.*","20","accept","0.17"]},{"entry":["5","UDP","1.*","*","*","*","accept","0.20"]},{"entry":["6","*","*","*","*","*","deny","0.50"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}}]}}},"Traditional firewall implementations consist of a single, dedicated machine, similar to a router, that sequentially applies rules to each arriving packet. However, packet filtering represents a significantly higher processing load than routing decisions [24, 29, 31]. For example, a firewall that interconnects two 100 Mbps networks would have to process over 300,000 packets per second [30]. Successfully handling these traffic loads becomes more difficult as rule sets become more complex [4, 22, 31]. Furthermore, firewalls must be capable of processing even more packets as interface speeds increase. In a high-speed environment (e.g. Gigabit Ethernet), a single firewall can easily become a bottleneck and is susceptible to DoS attacks [4, 9, 13, 14]. An attacker could simply inundate the firewall with traffic, delaying or preventing legitimate packets from being processed.","One approach to increase firewall performance focuses on improving hardware design. Current research is investigating different distributed firewall designs to reduce processing delay [4, 9, 22], and possibly provide service differentiation [11]. Another approach focuses on improving performance via better firewall software [6, 7, 12, 16, 17, 24]. Similar to approaches that address the longest matching prefix problem for packet classification [8, 10, 25, 28], solutions typically represent the firewall rule set in different fashions (e.g. tree structures) to improve performance. While both approaches, together or separate, show great promise, each requires radical changes to the firewall system, and therefore are not amenable to current or legacy systems.","Accordingly, there exists a need for improved methods, systems, and computer program products for network firewall policy optimization.","The subject matter described herein includes methods, systems, and computer program products for network firewall policy optimization. According to one method, a firewall policy including an ordered list of firewall rules is defined. For each rule, a probability indicating a likelihood of receiving a packet matching the rule is defined. Neighboring rules are sorted in order of non-increasing probability in a manner that preserves the firewall policy.","As used herein, the term \u201cfirewall\u201d refers to a logical entity that is adapted to filter packets at the ingress and\/or egress portions of a network based on a policy. The term \u201cfirewall\u201d is intended to include systems that block packets from entering or leaving a network and systems that perform intrusion detection and intrusion protection functions for packets entering or leaving a network. Thus, the methods and systems described herein for firewall policy optimization can be used to optimize policies for intrusion detection and intrusion protection firewalls.","The subject matter described herein includes a method to improve firewall performance and lower packet delay that can be applied to both legacy and current systems. In one implementation, a firewall rule set may be reordered to minimize the average number of rule comparisons to determine the action, while maintaining the integrity of the original policy. Integrity is preserved if the reordered and original rules always arrive at the same result. To maintain integrity, a firewall rule set may be modeled as a Directed Acyclical Graph (DAG), where vertices are firewall rules and edges indicate precedence relationships. Given this representation, any linear arrangement of the DAG is proven to maintain the original policy integrity. Unfortunately, determining the optimal rule order from all the possible linear arrangements is proven to be NP-complete, since it is equivalent to sequencing jobs with precedence constraints for a single machine [15]. Although determining the optimal order is NP-complete, a heuristic will be described below to order firewall rules that reduces the average number of comparisons while maintaining integrity. Simulation results show the proposed reordering method yields rule orders that are comparable to optimal; thus, provides a simple means to significantly improve firewall performance and lower packet delay.","The subject matter described herein for network firewall policy optimization may be implemented using any combination of hardware, software, or firmware. For example, the subject matter described herein may be implemented using a non-transitory machine-accessible and readable medium having stored thereon machine-executed instructions for controlling the machine to perform steps. Exemplary machine readable media suitable for implementing the subject matter described herein include disk memory devices, chip memory devices, programmable logic devices, application specific integrated circuits, and downloadable electrical signals. In addition, a machine readable medium that implements the subject matter described herein may be implemented using a single device or computing platform or may be distributed across multiple devices or computing platforms.","Modeling Firewall Security Policies","As described above, a firewall rule set, also known as a firewall policy, is traditionally an ordered list of firewall rules. Firewall policy models have been the subject of recent research [1, 2, 16]; however, the primary purpose is anomaly detection and policy verification. In contrast, the policy model described in this herein is designed for firewall performance optimization and integrity. Firewall performance refers to reducing the average number of comparisons required to determine an action, while integrity refers to maintaining the original policy intent. Although improving the worst-case performance is important, it is not possible without changing the list-based representation [16, 24].","Firewall Rule and Policy Models","In the examples described herein, a rule r is modeled as an ordered tuple of sets, r=(r[1], r[2], . . . , r[k]). Order is necessary among the tuples since comparing rules and packets requires the comparison of corresponding tuples. Each tuple r[l] is a set that can be fully specified, specify a range, or contain wildcards \u2018*\u2019 in standard prefix format. For the Internet, security rules are commonly represented as a 5-tuple consisting of: protocol type, IP source address, source port number, IP destination address, and destination port number [30, 31]. Given this model, the ordered tuples can be supersets and subsets of each other, which forms the basis of precedence relationships. In addition to the prefixes, each filter rule has an action, which is to accept or deny. However, the action will not be considered when comparing packets and rules. Similar to a rule, a packet (IP datagram) d can be viewed as an ordered k-tuple d=(d[1], d[2], . . . , d[k]); however, ranges and wildcards are not possible for any packet tuple.","Using the previous rule definition, a standard security policy can be modeled as an ordered set (list) of n rules, denoted as R={r, r, . . . , r}. A packet d is sequentially compared against each rule rstarting with the first, until a match is found (dr) then the associated action is performed. A match is found between a packet and rule when every tuple of the packet is a subset of the corresponding tuple in the rule.","Definition Packet d matches rif",{"@attributes":{"id":"p-0053","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":"driff d[l]r[l], l=1, . . . , k"}}}},"The rule list R is comprehensive if for every possible legal packet d a match is found using R. Furthermore, two rule lists R and R\u2032 are equivalent if for every possible legal packet d the same action is performed by the two rule lists. If R and R\u2032 are different (e.g. a reorder) and the lists are equivalent, then the policy integrity is maintained.","As previously mentioned, a rule list has an implied precedence relationship where certain rules must appear before others if the integrity of the policy is to be maintained. For example consider the rule list in Table 1. Rule rmust appear before rules rand r, likewise rule rmust be the last rule in the policy. If for example, rule rwas moved to the beginning of the policy, then it will shadow [2] the original rule r. However, there is no precedence relationship between rules rand rgiven in Table 1. Therefore, the relative ordering of these two rules will not impact the policy integrity and can be changed to improve performance. The present example assumes that the original policy is free from any anomalies. Likewise, when a policy is reordered to improve performance it should not introduce any anomalies, which will occur if precedence relationships are not maintained. As a result, a model is needed to effectively represent precedence relationships.","Modeling Rule List Precedence Relationships","The precedence relationship between rules in a policy will be modeled as a Directed Acyclical Graph (DAG) [23, 18]. Such graphs have been successfully used to represent the relative order of individual tasks that must take place to complete a job (referred to as a task graph model). Since certain rules must appear before others to maintain policy integrity, this structure is well suited for modeling the precedence of firewall rules. Let G=(R, E) be a rule list DAG for a rule list R, where vertices are rules and edges E are the precedence relationships (constraint). A precedence relationship, or edge, exists between rules rand r, if i<j, the actions for each rule are different, and the rules intersect.","Definition The intersection of rule rand r, denoted as r\u2229r, is",{"@attributes":{"id":"p-0057","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":"r\u2229r=(r[l]\u2229r[l]), l=1, . . . , k\n\nTherefore, the intersection of two rules results in an ordered set of tuples that collectively describes the packets that match both rules. The rules rand rintersect if every tuple of the resulting operation is non-empty. In contrast, the rules rand rdo not intersect, denoted as r\u2229r, if at least one tuple is the empty set. Note the intersection operation is symmetric; therefore, if rintersects r, then rwill intersect r. The same is true for rules that do not intersect.\n"}}}},"For example consider the rules given in Table 1, the intersection of rand ryields (UDP, 1.1.*, *, 1.*, 80). Again, the rule actions are not considered in the intersection or match operation. Since these two rules intersect, a packet can match both rules for example d=(UDP, 1.1.1.1, 80, 1.1.1.1, 80). Furthermore, the actions of the two rules are different. Therefore, the relative order must be maintained between these two rules and an edge drawn from rto rmust be present in the rule list DAG, as seen in . More particularly,  illustrates a rule list DAG for the rules in Table 1.  illustrates a linear arrangement of the rules in . In , the vertices represent rules, the circles represents an accept rules, and the squares represents deny rules. Edges that connect the vertices represent precedence requirements. As can be seen from , because of the edge between rules rand r, precedence between rules rand rmust be maintained. In contrast consider the intersection of rules rand r. These two rules intersect, indicating packets belonging to the set (UDP, 1.*, *, 1.*, *) would match both rules. However, it does not matter which of the two rules a packet matches first, since the action is the same for both rules. Therefore, an edge does not exist between rules rand rin the diagram. Similarly, rules rand rdo not intersect due to the fifth tuple (destination port). A packet cannot match both rules indicating the relative order can change; therefore, an edge will not exist between them.","The match operation can be used to identify precedence relationships, but it cannot do so in every case. Consider a partial-match example [1], where r=(UDP, *, 80, 10.*, 90, accept) and r=(UDP, 10.*, 80, *, 90, deny). The intersection of rand ris (UDP, 10.*, 80, 10.*, 90); therefore a packet, such as d=(UDP, 10.10.10.10, 80, 10.10.10.10, 90), can match both rules. If rappears before rthen the packet d is accepted, but if roccurs before rthen d is rejected. As a result, the order of rand rin the original policy must be maintained. However, the match operation is unable to identify the precedence in this example. A partial match exists in between rules rand rin Table 1, but as previously discussed an edge does not exist between the rules since the actions are the same.","Using the rule list DAG representation a linear arrangement is sought that improves the firewall performance. As depicted in , a linear arrangement (permutation or topological sort) is a list of DAG vertices where all the successors of a vertex appear in sequence after that vertex [23]. Therefore it follows that a linear arrangement of a rule list DAG represents a rule order, if the vertices are read from left to right. Furthermore, it is proven in the following theorem that any linear arrangement of a rule list DAG maintains integrity.","Theorem Any linear arrangement of a rule list DAG maintains integrity.","Proof Assume a rule list DAG G is constructed from the security policy R that is free of anomalies. Consider any two rules rand rin the policy, where i<j. If an edge between rand rin G does not exist, then a linear arrangement of G can interchange the order of the two rules. An edge will not exist if the rules do not intersect; however, a reorder will not affect integrity since a packet cannot match both rules. Shadowing is not introduced due to the reorder since the intersection operation is symmetric. An edge will not exist if the two rules intersect but have the same action; however, a reorder will not affect integrity since the same action will occur regardless of which rule is matched first. If an edge does exist between the rules, then their relative order will be maintained in every linear arrangement of G; thus maintaining precedence and integrity.\n\nRule List Optimization\n","As described above, it is important to inspect packets as quickly as possible given increasing network speeds and QoS requirements. Using the rule list DAG to maintain policy integrity, a linear arrangement is sought that minimizes the average number of comparisons required. However, this will require information not present in the firewall rule list. Certain firewall rules have a higher probability of matching a packet than others. As a result, it is possible to develop a policy profile over time that indicates frequency of rule matches (similar to cache hit ratio). Let P={p, p, . . . , p} be the policy profile, where pis the probability that a packet will match rule i (first match in the policy). Furthermore, assume a packet will always find a match, \u03a3p=1; therefore R is comprehensive. Using this information, the average number of rule comparisons required is",{"@attributes":{"id":"p-0063","num":"0062"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"E","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"n"}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"n"},"mo":"\u2062","mrow":{"mi":"i","mo":"\u00b7","msub":{"mi":["p","i"]}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}},"br":{}},"Given a rule list DAG G=(R, E) and policy profile P={p, p, . . . , p} a linear arrangement \u03c0 of G is sought that minimizes Equation 1. In the absence of precedence relationships, the average number of comparisons is minimized if the rules are sorted in non-increasing order according to the probabilities [26], which is also referred to as Smith's algorithm [27]. Precedence constraints cause the problem to be more realistic; however, such constraints also make determining the optimal permutation more problematic.","Determining the optimal rule list permutation can be viewed as job scheduling for a single machine with precedence constraints [15, 21]. The notation for such scheduling problems is \u03b1|\u03b2|\u03b3|\u03b4, where \u03b1 is the number of machines, \u03b2 is the precedence (or absence of) which can be represented as a DAG, \u03b3 is a restriction on processing time, and \u03b4 is the optimality criterion [15]. Determining the optimal rule order is similar to the 1|\u03b2|1|\u03a3\u03c9Cscheduling problem, or optimality criterion, where \u03c9 is a weight associated with a job (for example, importance) and Cis the completion time. As previously noted, the 1|\u2225\u03a3\u03c9Cproblem can be solved in linear time the using Smith's algorithm [27], which orders jobs according to non-decreasing",{"@attributes":{"id":"p-0066","num":"0065"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"msub":{"mi":["t","i"]},"mi":"\u03c9"}}},"br":[{},{},{},{}],"sub":["i ","i","i","i ","i","i ","i","i","i ","i","i "]},"Although determining the optimal rule permutation was proven to be NP-complete, reducing the average number of comparisons required to process a packet remains an important objective. As previously discussed, a sorting algorithm must maintain the precedence relationships among rules. Of course an exhaustive search is possible if the number of rules is small (generate and test all possible topological orders); however as proven in the previous section, this is not feasible with a realistic rule list.","One exemplary algorithm starts with the original the rule set, then sorts neighboring rules based on nonincreasing probabilities. However, an exchange of neighbors should never occur if the rules intersect and have different actions. This test preserves any precedence relationships in the policy. For example, the following sorting algorithm uses such a comparison to determine if neighboring rules should be exchanged. Note adenotes the action associated with the irule.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"done = false"]},{"entry":[{},"while(!done)"]},{"entry":[{},"\u2003done = true"]},{"entry":[{},"\u2003for(i = 1; i <n; i++)"]},{"entry":[{},"\u2003\u2003if(p< pAND (r \u2009rOR a== a))then"]},{"entry":[{},"\u2003\u2003\u2003exchange rules, actions, and probabilities"]},{"entry":[{},"\u2003\u2003\u2003done = false"]},{"entry":[{},"\u2003\u2003endif"]},{"entry":[{},"\u2003endfor"]},{"entry":[{},"endwhile"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Other sorting algorithms are possible if the completion time of the sort is an issue; however, the method presented is easy to implement and only requires a simple neighbor comparison. Assume the match probabilities for the rule list given in Table 1. Applying the sorting algorithm to this rule list results in the ordering depicted in , which has 10% fewer comparisons on average. However when using the algorithm, it is possible that one rule can prevent another rule from being reordered. For example, rule rprevents rule rfrom being placed closer to the beginning of the rule set. However, if both rules rand rare placed closer to the beginning of the policy while maintaining their relative order, the average number of comparison will be further reduced, 15% fewer. This is the optimal order for the 6 rule set, which is depicted in . Although this simple sorting algorithm is unable to move groups of rules, it can still improve the performance of the firewall system. Its effectiveness is measured experimentally in the next section.","Experimental Results","In this section, the average number of rule comparisons required after sorting the rules is compared with average number of comparisons required using the original order and the optimal order. Note the optimal rule ordering was determined via an exhaustive search. As a result, it was not feasible to determine the optimal ordering once the number of rules equaled 15 given the number of permutations to consider. Two different variations of the rule sorting method described in the preceding section were implemented. The difference between the methods was the comparison used to determine if neighboring rules should be exchanged. The first sorting algorithm exchanged neighboring rules if they were out of order and did not intersect. The if-condition was as follows.",{"@attributes":{"id":"p-0072","num":"0071"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":["if","then"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["p","i"]},"mo":"<","mrow":{"msub":[{"mi":"p","mrow":{"mi":"i","mo":"+","mn":"1"}},{"mi":["r","i"]},{"mi":"r","mrow":{"mi":"i","mo":"+","mn":"1"}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"AND"}}}}}},"br":{}},"In the first experiment, lists of 10 firewall rules were generated with random precedence relationships. The match probability of each rule was given by a Zipf distribution [20], which assigns probabilities according to the rank of an item. For this simulation, the last rule had the highest probability which is consistent with most policies (last rules are more general). As a result, the original order yields the worst average number of comparisons. The intersection percentage measured the percentage of rules that intersect in the policy. This metric gives a value for the dependency level in the policy; however note, rule action is not considered when calculating this metric. Rules were equally likely to have an accept or deny action and the results (average number of rule comparisons) for a particular intersection percentage were averaged over 1000 simulations.","Results of the first experiment are given in . More particularly,  is a graph illustrating the average number of packet comparisons versus intersection percentage for the original rule sorting, the non-action sort, the action sort, and the optimal sort.  is a graph illustrating the percent difference in the average number of comparisons required between the sorted and optimal firewall policy configurations. The average number of comparisons required was lower for the sorted and the optimal lists when the intersection percentage was low, as seen in . This was expected since there is a large number of possible rule permutations (few edges in the DAG). When the intersection percentage approached 100%, the values converged to the number required for the original list. This is due to the limited number of possible rule orders, only one order in the extreme case. The percent difference between the sorted and optimal order is shown in . At zero intersection percentage the sorted and optimal orders are equal, since any ordering is possible. Similarly at an intersection percentage of 100, the sorted and optimal orders are equal since only one order is possible. Between these two extremes, the action sorting algorithm remains close to the optimal value. In contrast, the non-action sort had a maximum difference of 33%.","The benefit of rule sorting on larger policies is also of interest; however as previously described, it was not possible to determine the optimal ordering once the number of rules approaches 15. Therefore, the second experiment used larger rule sets, but only compared the original order and the sorted orders. The number of rules ranged from 10 to 1000, while the matching probabilities and intersection percentages were the same as the previous experiment. The results of this experiment are depicted in . The sorted rule sets always performed equal to or better than the original order, while the action sort consistently performed better than the non-action sort. As noted in the previous experiment, the percent difference is very large given few intersections (e.g. 80% decrease for 1000 rules with 0% dependency), but approaches zero as all the rules intersect. As the number of rules increases, sorting is increasingly beneficial, although only at low intersection percentages. The benefit of sorting drops more significantly as the intersection percentage increases with larger rule sets. This is primarily due to the low matching probabilities of each rule, which requires a complete reordering to have a significant impact on the average number of comparisons. As a result, large rule sets can benefit from sorting if the intersection percentage is low.","The impact of considering rule actions when sorting is illustrated in . In this experiment lists of 1000 rules were generated, where the intersection percentages ranged from 0% to 100% and the percentage of rules with the same action varied from 50% to 100%. The performance of the action sort to the original list was then compared. As the percentage of rules with the same action increased, the percent difference (reduction) in the average number of comparisons also increased. This is due to the increased number of permutations possible when the rule actions are increasingly the same (fewer edges in the rule list DAG to consider). This is depicted in  where a policy with a 100% intersection percentage can significantly reduce the number of comparisons (80% reduction) if all the rules have the same action. This performance increase is not possible with the non-action sort. Therefore, considering the rule action increases the number of possible rule orders, thereby providing more possibilities to improve firewall performance.","Conclusions","Network firewalls enforce a security policy by comparing arriving packets to a list of rules. An action, such as accept or deny, is then performed on the packet based on the matching rule. Unfortunately packet filtering can impose significant delays on traffic due to the complexity and size of rule sets. Therefore, improving firewall performance is important, given network Quality of Service (QoS) requirements and increasing network traffic loads.","The sections above describe rule ordering methods to improve the performance of network firewalls. Assuming each rule has a probability of a packet matching, firewall rules should be sorted such that the matching probabilities are non-increasing. This reduces the average number of comparisons and the delay across the firewall. However, a simple sort is not possible given precedence relations across rules. It is common in a security policy that two rules may match the same packet yet have different actions. It is this precedence relationship between rules that must be maintained to preserve integrity. The method described above uses Directed Acyclical Graphs (DAG) to represent the precedence order rules must maintain. Given this representation, a topological sort can be used to determine the optimal order (minimum average number of comparisons); however, the examples above prove this problem to be NP-complete (similar to job scheduling for a single nonpreemptive machine with precedence constraints). As an alternative, a simple sorting method was introduced that maintained the precedence order of the rules. Simulation results indicate this method can significantly reduce the average number of comparisons required and is comparable to optimal ordering.","Several areas exist for future research in optimizing firewall rule lists. The sorting method proposed above is based on a simple algorithm. Although it can offer an improvement over the original rule order, algorithms that can move groups of rules could provide a larger reduction in the average number of comparisons. The effect of stateful firewalls should also be addressed in future research. Security can be enhanced with connection state and packet audit information. For example, a table can be used to record the state of each connection, which is useful for preventing certain types of attacks (e.g., TCP SYN flood) [30, 31]. The impact of such rules on the firewall needs to be investigated and whether sorting can be done on-line to reflect temporal changes. In addition, more research is needed to determine more accurate probability distributions for packet matching and dependency percentages. Given this information, better algorithms can be designed and more realistic simulations can be performed.","Trie-Based Network Firewall Optimization Methods and Rule Splitting Overview","As described above, while assuring firewall policy integrity is critical, performance is equally important given increasing network speeds and traffic volumes. Firewall processing delay can be reduced via hardware as well as policy optimization, where rules are manipulated to reduce the number of comparisons. For a given firewall installation, it can be determined that certain security rules have a higher probability of matching a packet than others. As a result, it is possible to develop a policy profile over time that indicates frequency of rule matches (similar to cache hit ratio). Given this information, trie-based methods are described herein to minimize the average number of comparisons required per packet. Although most firewall systems still utilize an ordered list representation, the proposed enhancements still are applicable to current firewall systems since a policy trie can be converted into an ordered list using an in order traversal.","Rule Sorting","As described above, rule sorting of neighboring rules based on ascending probabilities in a manner that considers rules intersection and rule actions can be used to improve firewall performance by reducing the number of packet comparisons. The methods described above use Directed Acyclic Goal Graphs (DAGs) to represent firewalls. The methods described in this section will use the rule sorting algorithms in combination with policy trie representations to perform sorting of groups of rules in a manner that improves firewall performance.","In this example, it is assumed that a security policy contains a list of n ordered rules, {r, r, . . . , r}. In addition, let prepresent the probability that a packet will match rule i (first match in the policy). Therefore, the policy is comprehensive, which means every packet will have a match, if \u03a3p=1. Using this information, the average number of rule comparisons required can be calculated as",{"@attributes":{"id":"p-0083","num":"0082"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"E","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"n"}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"n"},"mo":"\u2062","mrow":{"mi":"i","mo":"\u00b7","msub":{"mi":["p","i"]}}}],"mo":"="}}},"br":{},"sub":"i ","sup":"th ","ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":"if (p<pAND r\u2229rOR a==a)) then"}}}},"Sorting rules in this fashion can have positive impact on the average number of comparisons required.  is a table illustrating a firewall policy prior to rule sorting. The expected number of comparisons for the policy of  is 4.26 comparisons per packet.  is a table illustrating the firewall policy of  after sorting using the above-described algorithm. In , the expected number of comparisons per packet has been reduced to 3.94. Thus, using the method described above, the number of comparisons per packet can be reduced by 8%.","However, it can be seen from  that one rule can prevent another rule from being reordered. For example in , rule rprevents rule rfrom being placed closer to the beginning of the rule set. However, if both rules rand rare placed closer to the beginning of the policy while maintaining their relative order, the average number of comparison will be reduced.","To solve this problem, rule sets can be sorted a using policy tries. First, the rule list is converted into an equivalent policy trie. Each sub-trie will have an associated probability  that is average probability (hit-ratio) of the rules comprising the sub-trie. Sub-tries can be rotated around their parent node to increase performance, using the method described earlier. Since the policy trie (or equivalent rule set) is tested from left to right, rotation should occur if the probability of the right sub-trie is greater than the left sub-trie. As a result, the average number of comparisons required will be reduced and the policy integrity is maintained.  is a trie representation of the rules in .  is a table representing resulting rule set after rotating the TCP and UDP sub-tries. The TCP sub-trie in  has an expected packet matching probability of 0.095 while the UDP sub-trie has an expected packet matching probability of 0.155. Thus, the UDP sub-trie and the TCP sub-trie should be rotated so that the UDP sub-trie becomes the left sub-trie and the TCP sub-trie becomes the right sub-trie. In the table illustrated in , which lists the ordering of the rules after rotating the sub-tries, the average number of comparisons per packets has been reduced to 3.70.","Rule Splitting","Rule splitting takes a general rule and creates more specific rules that collectively perform the same action over the same set of packets. Here, rule splitting is used to reduce the average number of comparisons. For example in , rule ris split into two separate rules, rfor UDP and rfor TCP.  is a table corresponding to the policy trie of . Once the rules are positioned based on their probabilities and their relation to other rules, the average number of rule comparisons is reduced to 2.98 (after sort, trie rotation, and splitting) which is a 30% less.","It many not be advantageous to split a general rule since it adds another rule to the policy. For example, assume a policy contains 20 rules where the first 19 rules have the same probability. Assume the last rule can be split and the new specific rule has a probability that is",{"@attributes":{"id":"p-0089","num":"0089"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mn":["3","4"]}}},"br":{},"figref":["FIGS. 8A and 8B","FIG. 8A","FIG. 8B","FIG. 8B"]},"The effect of splitting a single rule can be described mathematically as follows. Consider n rules where rule rcan be split into rules rand r(whose union is the original rule). In addition, assume the split rule rwill be located at the mposition (1\u2266m<n), while rule rwill remain at the nlocation. The goal is to determine the best location m, which yields a lower average number of comparisons as compared to the original rule set. This can be defined mathematically in the following formula.",{"@attributes":{"id":"p-0091","num":"0091"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"n"},"mo":"\u2062","mrow":{"mi":"i","mo":"\u00b7","msub":{"mi":["p","i"]}}},{"mrow":[{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"1"},{"mi":"m","mo":"-","mn":"1"}]},"mo":"\u2062","mrow":{"mi":"i","mo":"\u00b7","msub":{"mi":["p","i"]}}},{"mi":"m","mo":"\u00b7","msub":{"mi":"p","mrow":{"mi":["n","l"],"mo":","}}},{"munderover":{"mo":"\u2211","mrow":[{"mi":["i","m"],"mo":"="},{"mi":"n","mo":"-","mn":"1"}]},"mo":"\u2062","mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":"i","mo":"+","mn":"1"}},"mo":"\u00b7","msub":{"mi":["p","i"]}}},{"mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"+","mn":"1"}},"mo":"\u00b7","msub":{"mi":"p","mrow":{"mi":["n","r"],"mo":","}}}],"mo":["+","+","+"]}],"mo":">"}}},"br":{}},{"@attributes":{"id":"p-0092","num":"0092"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"m","mo":"<","mfrac":{"mrow":[{"mrow":[{"mi":["n","p"],"mo":"\u00b7"},{"mi":"n","mo":"\u00b7","msub":{"mi":["p","n"]}},{"mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"+","mn":"1"}},"mo":"\u00b7","msub":{"mi":"p","mrow":{"mi":["n","r"],"mo":","}}}],"mo":["-","+"]},{"mi":"p","mo":"-","msub":{"mi":"p","mrow":{"mi":["n","l"],"mo":","}}}]}}}},"br":[{},{}],"sup":"th"},"In the preceding sections, optimizing the entire security policy has been discussed. However, it may be desirable to optimize the rules for a certain type of traffic, in order to reduce the average number of comparisons this traffic encounters. This can be done by organizing the policy trie via traffic classification, then optimizing the sub-tries. The result is an ordering where the rules for the most important traffic are tested first.","Network Firewall Optimization Using Rule Compression","Another method for network firewall optimization is referred to as rule compression. Given a security policy R, one objective in optimizing firewall performance is to reduce number of rules in the policy while maintaining the original integrity. A method for reducing the number of rules called rule compression, which combines and replaces two rules in the policy will now be described. Although compression does reduce the number of rules, it can only be done if the integrity of the original policy is maintained.","Consider two rules rand rin policy R, where rappears before r. The two rules can be compressed if and only if the following conditions are true\n\n","The result of compression is a new rule, rwhose tuples are the union of the corresponding tuples of rules rand r. The new rule rreplaces both rand rin R; however, the location of rin R may require the relocation of other rules. Let Dbe the ordered set of rules that appear after rthat directly or indirectly depend upon r. The new rule is placed at the original location of rin R and the rules Dare placed before r.","For example, consider the policy given in Table 2. It is possible to compress rules rand r, creating the new rule r=[TCP, *, *, 2.*, *, accept]. The ordered set Din this example consists of the rules rand r. As a result, the new rule ris placed at the original location of rwhile the rules in Dare placed before the new rule.  respectively illustrate the original policy DAG for Table 2 and the policy DAG after rules rand rare compressed.",{"@attributes":{"id":"p-0098","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Policy Consisting of Multiple Ordered Rules"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Source",{},"Destination",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["No.","Proto.","IP","Port","IP","Port","Action"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":["1","TCP","1.1.*","*","2.2.*","*","accept"]},{"entry":["2","TCP","1.*","*","*","80","deny"]},{"entry":["3","TCP","3.3.*","*","*","80","accept"]},{"entry":["4","TCP","3.*","*","*","*","deny"]},{"entry":["5","TCP","*","*","2.*","90","accept"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{},{}],"sub":["i ","j ","i ","j ","j ","i ","i","i ","j","j ","i","i ","j ","i ","j ","i,j","i ","j ","i ","j"]},"Although compression may be possible, it may not improve the performance of the policy due to the relocation of rules. Compression should only occur if the average number of comparisons required for the new policy Ris less than the original policy R; therefore, E[R]<E[R].","Firewall Rule Sub-Trie and Sub-List Ordering","Policy Sub-Trie Ordering","Additional methods for firewall optimization are referred to as firewall sub-trie and sub-list ordering. Given a policy trie T, it may be desirable to order all sub-tries such that the average number of tuple comparisons is reduced and policy integrity is maintained. Consider a policy trie T that contains sub-tries Tand Thaving the same parent node, as seen in . Let Pdenote the sum of the probabilities of the rules contained in sub-trie i, while Cdenotes the number of comparisons required to completely traverse sub-trie i (which is equal to the number of branches). In order to reduce the average number of tuple comparisons, sub-tries that share the same parent node should be ordered such that the following two conditions are observed.\n\n","Consider a group of n sub-tries that share the same parent node that are numbered sequentially from left to right. Consider any two non-intersecting sub-tries Tand Tin this group that are out of order. If two sub-tries do not intersect, denoted as T\u2229T, then no rule in one sub-trie will intersect with any rule in the other sub-trie, r\u2229r, \u2200r\u03b5T, \u2200r\u03b5T. The following integrity condition must be observed when reordering the sub-tries. The two sub-tries can be exchanged (rotated about the parent) if and only the sub-tries Tthrough Tdo not intersect with Tand the sub-tries Tthrough Tdo not intersect with T. Similar to finding the linear sequence of a policy DAGs, these conditions maintain the policy trie integrity. This is observed in , where no edge exists between any rule in Tand T. More particularly,  is a policy DAG of a six-rule firewall list.  is a policy trie representation of the firewall rule list represented by . In , the average number of tuple compares required per packet is 5.5.  illustrates the policy trie after rotating sub-tries Tand T. In , the average number of tuple compares required is 4.5. In , the following probabilities are assumed:","P=0.5","C=4","P=0.5; and","C=2.","The average number of tuple comparisons is an estimate based on the longest trie path.","Using the conditions for comparing and ordering, the following sorting algorithm sorts neighboring sub-tries that share the same parent node.",{"@attributes":{"id":"p-0107","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"m = a parent node in T"},{"entry":"done = false"},{"entry":"while(!done)"},{"entry":"\u2003done = true"},{"entry":"\u2003for each sub-trie Thaving parent m AND a right neighboring sub-trie"},{"entry":"\u2003\u2003if((P< PAND (Pi == Pi+1 AND Ci > Ci+1)) AND T \u2009T) then"},{"entry":"\u2003\u2003interchange Tand T"},{"entry":"\u2003\u2003done = false"},{"entry":"\u2003\u2003endif"},{"entry":"\u2003endfor"},{"entry":"endwhile"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0108","num":"0113"},"figref":["FIGS. 11A-11D","FIG. 11A","FIG. 11B","FIG. 11C","FIG. 11C","FIG. 11D","FIG. 11D","FIG. 11D","FIG. 11E","FIG. 11E","FIG. 11E"],"sub":["1 ","2 ","7 ","8","3","4","5","6","3 ","4","1 ","2","1 ","2"]},"Policy Sub-List Ordering","The preceding section describes conditions for sorting policy sub-tries, which allow the exchange of groups of rules (sub-tries). The same conditions can be applied to list based policies, where sub-lists are ordered to improve the average number of rule comparisons.","In the sections above relating to rule sorting, a method is described to exchange neighboring rules in a list-based security policy, as seen in . However, it was observed that when ordering rules in this fashion it is possible that one rule can block the exchange of another. If groups of rules were allowed to be exchanged the average number of rule comparisons could be further reduced.","Given a policy list L, it may be desirable to order all sub-lists such that the average number of rule comparisons is reduced and policy integrity is maintained. Consider a policy list L that contains sub-tries Land L. Let Pdenote the sum of the probabilities of the rules contained in sub-list i, while Cdenotes the number of rules in sub-list i. In order to reduce the average number of rule comparisons, sub-lists should be ordered such that the following two conditions are observed.\n\n","Consider a group of n sub-lists that are numbered sequentially from left to right. Consider any two non-intersecting sub-lists Land Lin this group that are out of order. If two sub-lists do not intersect, denoted as L\u2229L, then no rule in one sub-list will intersect with any rule in the other sub-list, r\u2229r, \u2200r\u03b5L, \u2200r\u03b5L. The following integrity condition must be observed when reordering the sub-lists. The two sub-lists can be exchanged if and only if the sub-lists Lthrough Ldo not intersect with any rule in Land sub-lists Lthrough Ldo not intersect with L. Similar to finding the linear sequence of a policy DAGs, these conditions maintain the policy trie integrity. For example, consider the sub-lists L={r, r} and L={r, r} given in . No edge exists between any rule in Land L. The two sub-lists are out of order with respect to P and should be exchanged. The resulting list is given in .  illustrates the original policy order and results in an average number of rule comparisons of 3.4. In the sorted version in , the average number of rule comparisons is 3.3. In , the average number of rule comparisons has been reduced to 2.7. Using the conditions for comparing and ordering, the following sorting algorithm sorts neighboring sub-lists.",{"@attributes":{"id":"p-0113","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"done = false"},{"entry":"while(!done)"},{"entry":"\u2003done = true"},{"entry":"\u2003for each sub-list Lhaving a right neighboring sub-list"},{"entry":"\u2003\u2003if ((P< POR (P== PAND C> C)) AND L \u2009L)then"},{"entry":"\u2003\u2003\u2003interchange rules and probabilities"},{"entry":"\u2003\u2003\u2003done = false"},{"entry":"\u2003\u2003endif"},{"entry":"\u2003endfor"},{"entry":"endwhile"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"As stated above, the methods and systems described herein for a network firewall policy optimization can be implemented using any combination of hardware, software, and\/or firmware. Alternatively, the steps for firewall policy optimization can be performed manually with the number of rules being optimized is small enough.  is a flow chart illustrating an exemplary process for firewall policy optimization according to an embodiment of the subject matter described herein. Referring to , in block , a firewall policy including an ordered list of firewall rules is defined. In block , for each rule, a probability indicating a likelihood of receiving a packet that matches each rule is specified. In block , neighboring rules are sorted in order of non-increasing probability in a manner that preserves firewall policy. In block , groups of rules are sorted in order of non-increasing probability in a manner that preserves firewall policy. For example, any of the policy-trie-based methods described above may be used. In block , one or more rules are split to reduce the number of average packet comparisons. In block , intersecting rules having common actions are identified and collapsed into single rules.","As described above, the subject matter described herein may be implemented in hardware, software, and\/or firmware. In one implementation, the subject matter described herein for firewall policy optimization may be implemented on a general purpose computing platform.  is a block diagram of a general purpose computing platform including software for firewall policy optimization according to an embodiment of the subject matter described herein. Referring to , computing platform  may be a general purpose computer, such as a personal computer, that includes a microprocessor , memory , and I\/O interfaces . Microprocessor  may be any suitable microprocessor, such as any of the Intel or AMD families of microprocessors. Memory  may include volatile memory for running programs and persistent memory, such as one or more disk storage devices. I\/O interface  may include interfaces with I\/O devices, such as user input devices and output devices.","In the illustrated example, software that may be resident in memory  includes a firewall policy editor  and a firewall policy optimizer . Firewall policy editor  may allow a user to define a firewall policy. For example, firewall policy editor  may allow a user to define a firewall policy by specifying different rules. The rules may be specified in a graphical manner, for example using policy DAGs as described above. Alternatively, firewall policy editor  may allow a user to input rules in a tabular manner, as illustrated in any of the tables described herein. Firewall policy optimizer  may implement any or all of the firewall policy optimization techniques to order rules entered via firewall policy editor  in a manner that preserves policy integrity and that enhances firewall performance.","A firewall rule set that is optimized using the subject matter described herein may be implemented on any firewall system that includes one or more firewalls. For example, an optimized firewall rule set according to embodiments of the subject matter described herein may be implemented using any of the hierarchical, multi-node firewall systems described in commonly assigned, co-pending U.S. patent application Ser. No. 11\/316,331, filed Dec. 22, 2005, the disclosure of which is incorporated herein by reference in its entirety.  illustrates an example of a multi-node firewall system suitable for implementing the firewall rules according to an embodiment of the subject matter described herein. Referring to , a plurality of firewall nodes , , , and  may collectively implement any of the optimized firewall policies described herein. For example, the firewall nodes may collectively implement different portions of a firewall policy data structure including an ordered list of firewall rules. A firewall policy engine  resident on each firewall node may filter packets using its local portion  of the firewall policy data structure. A control node  may include a firewall policy optimizer  that measures the average number of comparisons per packets for the current rule configuration and may dynamically reorder the rules to reduce the average number of comparisons per packet. For example, firewall policy optimizer  may utilize any of the methods described herein to rearrange rules and improve firewall performance. Rules may be tested for rearrangement at user-specified intervals or when average number of packet comparisons increases by a user-specified amount.","Gateless Design","The gate plays an important role in the function-parallel design. It accepts information from the firewall nodes to determine the correct action to apply to a packet. Unfortunately, the gate is a special device that must coordinate with the individual firewall nodes in the system, which may be problematic to implement. However, it is possible to eliminate the gate and allow the firewall nodes to operate independently without any coordination. The significant advantage is that the gateless function-parallel design can be implemented with any firewall system (from open source to proprietary).","Eliminating the gate requires a rule distribution such that for any given packet, only one machine will ever accept and the remaining machines will always deny. Rule actions are either accept or deny. This can be seen in the policy DAG by denoting deny rules with a square and accept rules with a circle. To assure only one machine will accept a packet, an accept rule in a firewall node cannot intersect with another accept rule in any other firewall node. As described above, the intersection of two rules describes the set of packets that can match both rules. If an edge spans the local rules of firewall nodes, then the set of packets would be accepted by both firewall nodes; thus, duplicate packets would be accepted. In addition, every drop rule must be present in each firewall node to assure the remaining firewall nodes will drop the packet. Given these two requirements a policy DAG edge will not span firewall nodes, as illustrated in .","For example, consider a two-firewall node function-parallel system that implements the five-rule policy given in Table 3 set forth below. The policy DAG is given in , where the first and last rules are deny. An initial gateless rule distribution is given in  which has no edges spanning the firewall nodes. Given the local policy DAG, deny rules can be removed if: no inbound edges exist for the deny rule; and all out-going edges for the deny rule connect to a superset deny rule. Using these constraints, the first rule in the second firewall node depicted in  can be removed (it is a subset of rand has no other edges). This gives the final gateless rule distribution shown in . As a result, the first firewall node in this distribution will only process UDP traffic, while the second machine only processes TCP. The rules can be divided with respect to other tuples, and can be done to provide QoS guarantees.",{"@attributes":{"id":"p-0122","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Security Policy Consisting of Multiple Ordered Rules"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},"Source","Destination",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["No.","Proto.","IP ","Port","IP","Port","Action","Prob."]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","UDP","1.1.*","*","\u2002\u2009*","80","deny","0.01"]},{"entry":["2","TCP","\u2002\u20091.*","*","1.*","90","accept","0.02"]},{"entry":["3","TCP","\u2002\u20092.*","*","2.*","20","accept","0.25"]},{"entry":["4","UDP","\u2002\u20091.*","*","\u2002\u2009*","*","accept","0.22"]},{"entry":["5","*","\u2003\u2009\u2009*","*","\u2002\u2009*","*","deny","0.50"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}}]}}},"The disclosure of each of the following references is hereby incorporated herein by reference in its entirety.\n\n","It will be understood that various details of the invention may be changed without departing from the scope of the invention. Furthermore, the foregoing description is for the purpose of illustration only, and not for the purpose of limitation."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Preferred embodiments of the subject matter described herein will now be explained with reference to the accompanying drawings of which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 2A","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 5B","FIG. 5A"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 6A","FIG. 5B"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 6B","FIG. 5A"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7A","sub":["5 ","5a ","5b"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 7B","FIG. 5A"],"sub":["5 ","5a ","5b"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9B","sub":["1 ","5"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 10C","sub":["1 ","2"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 11C","sub":["1 ","2 ","7 ","8"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 11D","sub":["3 ","4"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 11E","sub":["1 ","2"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 12A"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 12B","FIG. 12A"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 12C","sub":["1 ","1 ","3 ","2 ","2 ","4"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 16A"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 16B"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 16C"}]},"DETDESC":[{},{}]}
