---
title: In-band transport mechanism for carrying communications among functional components of a storage I/O interface stack
abstract: An in-band protocol transport carries command-response protocol communications between first and second functional components of a storage input/output (I/O) interface stack, for example to control encryption-related processing of storage I/O commands. A storage read command used as a protocol transport message has protocol data in a read data buffer, and predetermined read address information, such as a prime-numbered starting block address and a small, odd-valued length value, unlikely to occur in normal (non-transport) storage read commands. The second functional component determines that the storage read command contains the predetermined read address information, indicating that the storage read command is a protocol transport message rather than a normal read. For greater confidence, it also determines that the protocol data in the read data buffer includes protocol identification data such as a protocol signature. The protocol data is used to control a processing action for subsequent normal storage I/O commands, such as encryption-related processing, and a protocol response is returned by creating and storing response data in the read data buffer and signaling completion of the storage read command to the first functional component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08190784&OS=08190784&RS=08190784
owner: EMC Corporation
number: 08190784
owner_city: Hopkinton
owner_country: US
publication_date: 20110330
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention is related to the field of data processing, in particular to storage-related operation of data processing systems.","In data processing systems, it is known to utilize a stack of input\/output (I\/O) functional components or drivers in a host computer to realize an interface to an external data storage system. The functional components of an I\/O interface stack generally perform different types of functions at different logical layers in a coordinated fashion in order to obtain all the desired functionality of the interface. As an example, a high-level I\/O driver may interact with a so-called \u201cmultipathing\u201d driver that has knowledge of multiple distinct paths to storage devices and that uses the knowledge to distribute storage I\/O commands among the different paths in a way that improves performance or achieves other system goals (such as enhanced availability). The multipathing driver in turn relies one or more lower-level drivers that control the operation of a host bus adapter providing a hardware-level interface to a storage-oriented interconnect bus that connects the host computer to the storage system.","In data processing systems employing I\/O interface stacks such as described above, it can be useful or necessary for two or more functional components of a stack to communicate with each other. In the context of storage-related operations, for example, a host computer may provide support for encryption of storage data. If the encryption is performed at a low level (e.g., by a host bus adapter) while the management of encryption keys and other encryption-related information and processing is performed at a higher level (e.g., at a key controller module residing at a higher level of the I\/O interface stack), then some amount of communications among the levels is necessary so that the higher-level entity (key controller module) can pass the encryption keys and\/or other encryption-related information to the lower-level entity (host bus adapter). This is only one example of the usefulness of communications among the functional components of an I\/O interface stack.","In any scheme for communication among functional components of an I\/O interface stack, it is necessary to utilize some type of transport mechanism for carrying the communications. The transport mechanism is generally distinct from the architecture and content of the communications protocol which conveys the desired information. As an example, a communications protocol may be a command-response protocol in which an initiator generates a protocol-defined command and a responder responds with a protocol-defined response. The transport mechanism is the mechanism used to convey the command from the initiator to the responder and the response from the responder to the initiator. A variety of general transport mechanisms are known, including for example memory-based rings and queues. One distinction among transport mechanisms is between a so-called \u201cout of band\u201d mechanism, which employs a datapath and signaling separate from those used for operational functions (e.g., for processing storage read and write commands), and an \u201cin-band\u201d mechanism that utilizes the same datapath and signaling used to carry out those functions.","A method of operating a computer connected to a storage device is disclosed in which a command-response communications protocol is employed between first and second functional components of a storage input\/output (I\/O) interface stack of the computer. The command-response protocol includes exchange of protocol data used to control processing of storage I\/O commands by the second functional component. The protocol data also includes identification data identifying the protocol data as data of the command-response protocol.","The method includes use of an in-band transport mechanism as follows. At the first functional component, a storage read command is created as a protocol transport message in a memory of the computer. The storage read command is directed to the storage device and includes a read command data structure and a read data buffer specifically associated therewith. The read data buffer includes first protocol data constituting a protocol command, and the read command data structure includes a storage read command and predetermined read address information used to identify the storage read command as the protocol transport message. In one embodiment, the predetermined read address information may include a prime-numbered starting block address and a small, odd-valued length value, which are very unlikely to occur in normal (non-transport) storage read commands.","At the second functional component, the read command data structure is accessed from the memory and it is tested to make a first determination that it contains the predetermined read address information. This is an indication (to a high confidence) that the storage read command is a protocol transport message rather than a normal storage read message. Based on the first determination, the read data buffer is accessed from the memory and it is tested to make a second determination that it includes the identification data. This second determination increases the confidence that the storage read command is the protocol transport message and not a normal read command that happens to be using address information which matches the predetermined address information.","Based on the second determination and the protocol data in the read data buffer, the second functional component (a) executes a protocol-controlled processing action with respect to subsequent normal storage I\/O commands, and (b) returns a protocol response to the first functional component by creating and storing response data in the read data buffer and signaling a completion of the storage read command to the first functional component. The storage read command is not sent to the storage device. In one embodiment, the command-response protocol may be a data encryption key management protocol used to provide a data encryption key and other encryption-related data to the second functional component, and the protocol-controlled process action includes encryption and decryption of data of the storage I\/O commands using data encryption key and encryption-related data provided by the first functional component.","The in-band transport mechanism can provide advantages over other transport mechanisms, especially for processing of storage I\/O commands and for encryption-related processing in particular. By its use of a storage read command and response, it can provide for independence from the details of any particular hardware or software platform on which it may operate. Whatever mechanism is already used in a given platform for generating and signaling normal storage read commands and responses can readily be used as part of the transport mechanism for the command-response protocol also. The transport mechanism also has a desirable feature of automatically flowing down and back up an I\/O interface stack, regardless of the exact constitution of the stack. Thus, it can automatically support the presence (or absence) of intermediate layers that might need to examine and in some cases even alter the flow of the protocol communications. Specific examples of such intermediate layers are discussed below.","The description herein provides numerous details regarding a particular use and operating environment for an in-band communications transport mechanism in a host computer. Specifically, the transport mechanism is disclosed in the context of a distributed computer system that provides encrypted data storage, with the transport mechanism carrying a data encryption key management protocol that is used to control encryption-related processing in various functional components of the system. The transport mechanism can provide certain benefits in this kind of operating environment. However, the transport mechanism has a more general nature and is capable of use in other applications or environments, and the description herein is not to be taken as unnecessarily limiting.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["10","10","12","14","16","16","16","16","12","16","14","16","20","20","20","20","18","14","18"],"i":["a","b","n","a","b","m"]},"In operation, the hosts  execute application programs that utilize the storage devices  for non-volatile data storage. The storage interconnect  may employ a storage-oriented protocol such as iSCSI or Fibre Channel to enable block-oriented read and write commands and the accompanying data to be transferred between the hosts  and storage devices . Additionally, the system  provides selective encryption of storage data by the hosts . The key manager server  and host interconnect  provide support for the data encryption function as described in more detail below.","Key manager server  provides key manager functionality, i.e., the generation, protection, storage, replacement, and elimination of data encryption keys and related data that are used in data encryption\/decryption operations. In one embodiment, key manager server  is a server appliance. One example of a key manager server  usable in some embodiments is the RSA Data Protection Manager appliance manufactured by EMC Corp. of Hopkinton, Mass. It should be understood that this is by way of example only; other products may also serve as the key manager server .","Key manager server  and hosts  connect to each other via host interconnect . Host interconnect  may be, for example, a network, such as a local area network (LAN) or a wide area network (WAN). Host interconnect  may also be realized by a collection of one or more switches interconnecting key manager server  and hosts .","Hosts  are computers executing applications that store data on the data storage devices . In addition to connecting to the host interconnect , each host  also connects to the storage interconnect , typically via a plurality of independent connections. In one embodiment, the hosts  employ a multipathing function which establishes and utilizes multiple paths from a given host  to a given storage device , which can provide higher performance as well as redundancy for greater availability. Further detail regarding hosts  is provided below in connection with .","The storage interconnect  can be any type of network or input\/output (I\/O) bus capable of interconnecting storage devices  with host computers . In some embodiments, the storage devices  and host  are interconnected in a manner such that, to the operating systems running on the hosts , the storage devices  appear as locally attached, but this is not required. The storage interconnect  may be a shared, public, or private network and encompass a wide area or local area and can be implemented through any suitable combination of wired and\/or wireless communication networks. Furthermore, the storage interconnect  may include a LAN, a WAN, an intranet, the Internet, or a set of switches. For example, in one embodiment, the storage interconnect  works with Fibre Channel connectivity and is implemented in the form of a storage area network (SAN). In another embodiment, the storage interconnect  works with internet protocol (IP) connectivity and is implemented via an Internet-Small Computer System Interface (iSCSI) (e.g., for Fibre Channel). Those of skill in the art will recognize that other implementations are, of course, possible.","Storage devices  may be any sort of storage equipment capable of connecting to storage interconnect . In some embodiments, each storage device  is a disk array. As is well-known in the art, a typical disk array includes a disk array controller, disk enclosures holding a plurality of disk drives, and a power supply. A disk array may also include a cache. Examples of disk arrays include the Symmetrix Integrated Cache Disk Array System and the CLARiiON Disk Array System, both available from EMC Corp. of Hopkinton, Mass.","As mentioned, key manager server  controls the generation, protection, storage, replacement, and elimination of data encryption keys. In particular, key manager server  creates encryption keys and corresponding key identifiers. Each key identifier, referred to as a key_id, is associated with a corresponding encryption key and can be used to obtain the key from the key manager server , provided that all permissions and credentials are in place.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 2"],"b":["16","16","30","14","32","34","36","36","36","36","18","32","34","36"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3","b":["34","34","38","40","38","40","32","34"]},"OS  (which contains many well-known components that are not shown or described herein) includes a file system  and a logical volume manager . OS  also includes an input\/output (I\/O) filter driver  and an HBA driver . I\/O filter driver  may be, for example, a component of the PowerPath Encryption With RSA software available from EMC Corp. of Hopkinton, Mass. I\/O filter driver  includes an OS interface , an HBA interface , and a set of common application programming interfaces (CMN APIs) . I\/O filter driver  also includes a key controller module (KCM) or encryption manager  and one or more intermediate layers (IL) . ILs  may include, for example, one or more virtualization modules  and multipathing modules . Crypto kernel  may also be considered to be part of I\/O filter driver . Portions of the I\/O filter driver  and the HBA driver  may also make up storage I\/O stack . It should be understood that this arrangement is by way of example only; in some embodiments, one or more components of the storage I\/O stack  may be external to the I\/O filter driver . In any case, for purposes of this disclosure, the storage I\/O stack  includes components between the KCM  and a software interface to an encryption endpoint (EE) where encryption is performed (e.g., between KCM  and HBA driver ).","The KCM  is generally responsible for managing the data encryption aspects of operation of the host  in which it resides. In some arrangements, the KCM  may arrange for the encryption to be performed by crypto kernel . However, since KCM  and crypto kernel  both run in software (running on processor ), such operation may impose a performance penalty in terms of latency and\/or throughput of data storage operations. Therefore, in some arrangements, KCM  is able to arrange for the encryption to be performed by hardware-level encrypting circuitry which may be located within one or more HBAs  as mentioned above. In many case, such encrypting circuitry will include a combination of hardware and firmware. An HBA  that includes such encrypting circuitry may be referred to as an encrypting HBA or \u201cEHBA\u201d, while an HBA  that does not include such encrypting circuitry may be referred to as a non-encrypting HBA or \u201cNHBA\u201d. The term \u201chardware-assisted encryption\u201d is used to refer to encryption being performed using such encrypting circuitry.","The various drivers and modules shown in  are also referred to using the term \u201cfunctional components\u201d elsewhere in this description.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 4","b":["46","16","20","16"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 4","FIG. 3","FIG. 4","FIG. 4"],"b":["70","72","74","70","72","46","36","62","47","70","72","74","46","74","76"]},"The communications protocol (e.g., DEK management protocol) is assumed to be a command-response protocol which involves the sending of a protocol command message (CMD)  by the first functional component  and the returning of a corresponding protocol response (RSP)  by the second functional component . The command message and response ,  effect an exchange of protocol data that is used to control the processing of storage I\/O commands by the second functional component  (and potentially by the first functional component  and\/or other components represented by box ). The processing may be encryption-related processing, for example. The protocol data also preferably includes certain identification data that identifies the protocol data as such, i.e., the identification data indicates that the data being conveyed by the transport mechanism  constitutes a protocol message  or  as opposed to some other data that should not be interpreted as a protocol message.","The transport mechanism  is an \u201cin-band\u201d mechanism that employs storage read commands and corresponding read responses of the general type used for normal storage read operations. For example, in the case that the storage I\/O interface between the host  and a storage device  employs Small Computer Systems Interconnect (SCSI) protocol, the in-band transport mechanism can use a SCSI Read command and its associated response as the command  and response  respectively. The various layers of the I\/O stack  will be designed to identify and process storage I\/O commands as normally used by the host  to store and retrieve data to\/from a storage device . The transport mechanism  utilizes this built-in capability to provide a way to carry the protocol communications among the layers to enable them to coordinate their processing of storage I\/O commands in a desired way, for example as part of a data encryption scheme, etc. As explained below, it is particularly desirable that the DEK management protocol be carried in-band rather than via an out-of-band mechanism. Among other things, an in-band transport mechanism provides for generality and compatibility so as to be useful in a variety of hardware and\/or software operating environments. It also provides for involvement of the intermediate layers  in the communications to conditionally modify commands and responses as may be needed to support multipathing, virtualization or other complex operations. Additionally, an in-band transport allows protocol commands to be directed to particular storage device in the same way as a normal storage read or write is directed to that storage device, and thus it supports protocols such as the DEK Management protocol that require processing specific to a storage device.","Generally, the transport mechanism  employs a \u201ctransport\u201d read command which is a storage read command having unusual parameters or being otherwise different from \u201cnormal\u201d storage read commands that are used by the host  to obtain storage data from the storage devices . In particular, the transport storage read command can utilize certain unusual predetermined read address information that plays a distinguishing role. In one embodiment, the read command uses a combination of an unusual starting block address and an unusual length. For example, the combination (1009, 3) might be used. This combination represents a small and odd-length extent of storage space located at a prime-numbered address, which is unlikely to be the target of a normal read command. A functional component (e.g., ) can examine the starting block address and length of read commands, and upon finding the predetermined read address information it can identify the read command as a protocol transport message rather than a normal storage read command. In other embodiments, other types of predetermined address information can be used, including different combinations of starting block address and\/or length.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5","FIG. 4"],"b":["81","74","82","84","86","88","90","86","34","92","88","94","96","98","100","81","94","96","98","92","102","78","80"]},"Like other storage read commands, a transport read command  employs a memory-based mechanism within the host  for communicating I\/O requests among different functional entities. For example, in a Windows\u00ae environment, so-called \u201cI\/O Request Packets\u201d may be used. Other mechanisms such as queues or rings may be used in other computer architectures. The transport read command  employs both a read command data structure  and an associated read buffer , with the read command data structure  including the predetermined address information that identifies the read command as a transport read command . The read command data structure  is created in the memory , and a section of the memory  is allocated as the read data buffer . The protocol message ,  is carried in the read data buffer . It will be appreciated that this represents an unusual use of a read data buffer. Read data buffer. Read buffers are not normally used to pass information from an initiator of a read command to another entity, and in fact the contents of a read data buffer are normally undefined until the data that is the subject of the read request is returned to the initiator via the read buffer. However, as part of the transport mechanism , the read data buffer  will contain a command message  when initially created, and will be read by a responder (second functional component ).","As described below, additional identification data may also be used to provide increased confidence that the read command (or response) is a valid transport message as opposed to a normal read command (or response) that happens to be directed to the storage extent defined by the predetermined address information.","As mentioned above, the various items in  that make up a transport read command  are stored and operated upon in the memory  by both the initiator and responder (e.g., functional components  and ), and are passed between functional components using an I\/O request signaling mechanism in the host computer  such as generally known in the art. In one example, the Other data  of the read command data structure  includes a status field by which the completion of a read operation is signaled. For example, the responder (e.g., functional component ) may change the status field to a value signifying completion, and the initiator (e.g., functional component ) recognizes the completion of the read by this change to the value of the status field. Using this kind of technique, a single read data buffer  may be used for both a command message  and its associated response . The read data buffer  is initially filled with the command message  by the initiator, and the responder obtains the command message  by accessing the read data buffer (using the buffer pointer  in the read command data structure ). When the response  is to be sent, the responder stores the response data in the read data buffer  and signals completion of the read (such as by modifying a status field in the Other data ). The initiator then obtains the response  from the read data buffer .","It is to be understood that the transport mechanism  of  may use a set of multiple transport read commands  and their associated responses at different levels of a multiple-level I\/O interface stack such as the I\/O stack . For example, distinct transport read commands  and their responses may be used between the KCM  and virtualization module , between the virtualization module  and the multipathing module , and between the multipathing module  and the HBA driver . This chain-like functioning enables a layer to take layer-specific action on a protocol command and\/or response. Examples are discussed below, including the duplicating of protocol commands to multiple functional components at an underlying layer and obtaining appropriate responses from each before returning a success response to the next higher layer. In this description, the term \u201clike-organized\u201d is used to signify a protocol transport message or protocol command having essentially the same organization or structure of another message or command. In the case of the chain-like functioning just described, it is contemplated that all of the protocol transport messages and protocol commands are like-organized.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 6","FIGS. 4 and 5"],"b":"74"},"At , the first functional component  creates a storage read command as a protocol transport message in the memory  of the host computer . The storage read command is directed to a specified storage device  and includes a read command data structure  and an associated read data buffer . The read data buffer  includes first protocol data constituting a protocol command (e.g., command message ), while the read command data structure  includes a storage read command  and the predetermined read address information (LBA  and length ) which is used to identify the storage read command  as a protocol transport message.","At , various steps are performed at the second functional component . At , the second functional component  accesses the read command data structure  from the memory  and tests it to make a first determination that it contains the predetermined read address information. If it does, then operation proceeds to step . Otherwise, processing terminates as indicated at  (at this point the read command may be processed separately as a normal I\/O read command).","At , based on the first determination of step , the read data buffer  is accessed from the memory  and it is tested to make a second determination that it includes certain identification data identifying the first protocol data as data of the command-response protocol. If it does, then processing proceeds to step . Otherwise, processing terminates as indicated at  (at this point the read command may be processed separately as a normal I\/O command). In one embodiment, the identification data is referred to as a \u201cprotocol signature\u201d, and is described below.","At , based on the second determination at  and the protocol data obtained from the read data buffer , the contents of the read data buffer  are interpreted as a protocol command  and the following actions are taken: (a) a protocol-controlled processing action specified by the protocol command is executed with respect to subsequent storage I\/O commands which are initiated by the host  and directed to the specified storage device  via the storage I\/O interface stack , and (b) a response is returned to the first functional component  by creating and storing response data in the read data buffer  and signaling a completion of the storage read command to the first functional component . This signaling may be effected by writing a completion status as described above or some other signaling mechanism Examples of protocol-controlled processing actions are described below.","As indicated above, a transport read command  of the transport mechanism  is similar to a normal I\/O read request and response but with certain important differences. One difference is the use of the special predetermined address information which identifies the storage read command as a protocol transport message. A layer or component processing a read command can examine the address information and determine (to a high confidence) that the read command is a protocol transport message rather than a normal storage read command. Secondly, the actual protocol message (command message  or response ) is carried in the read data buffer  of the read command. Thus, in contrast to normal storage reads, the read data buffer  of a transport read contains defined and meaningful data at the time the read command is created, not just at the completion of the read operation.","It will be appreciated that it is generally not possible to guarantee that normal (non-transport) storage read commands will never utilize whatever predetermined address information is chosen to identify the transport read commands . If a normal read were to use the predetermined address information, then a functional component processing such a read command (such as second functional component , for example) might erroneously attempt to interpret the undefined contents of the associated read buffer as a protocol message to be processed in accordance with the protocol, leading in general to indeterminate and perhaps even destructive operation. This problem is addressed by use of the identification data in the message  as discussed above. Before processing the contents of a read buffer  as a protocol message, a functional component makes an additional determination that the data in the read buffer  includes the identification data which identifies the data as a protocol message (see step  of ). This additional test makes a false positive much less likely, as it would be required that both a normal read using the unusual address information has occurred and that the undefined data initially in the read buffer includes the protocol identification data.","For additional confidence, the command-response protocol may employ multiple messages in an initial phase of communication which must all succeed in order for the protocol-controlled processing to commence. Examples below include the combination of a handshake command and a query command. This can further reduce the chance that a set of normal read requests will be erroneously interpreted as the required sequence of initial protocol commands.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 7","FIG. 7"],"b":["120","46","46","46","20","36","140","1","140","4","1","4","36","156","1","156","3","256","1"]},"A logical volume L () is defined by virtualization module . Virtualization module  provides a \u201cvirtualization\u201d system function, presenting a logical unit of data (LU) as a logical disk or logical volume (LV) to KCM  and to the OS  via OS interface  even though the LV may not actually be a contiguous physical entity, which is assumed to result in assigning logical blocks of L to specific storage devices . This virtualization may be, for example, a mirroring, a striping, or some combination thereof. In arrangement , logical volume L () is shown as being virtualized across two storage devices D () and D (). It should be understood that, throughout this description, the term LU is used to refer to a logical unit of data at any level of abstraction (e.g., as seen by the KCM , as seen by one of the ILs , or as seen by an HBA ), while the term LV is used to specifically refer to an LU as seen by the KCM . In general, the virtualization module  maps one or more storage \u201cextents\u201d defined at an upper layer of the I\/O stack  to corresponding storage extents defined at a lower layer of the I\/O stack , and in operation it generally maps upper-layer data location information of an upper-layer I\/O command to corresponding lower-layer data location information. The term \u201cextent\u201d refers to a (generally contiguous) set of addressable blocks of storage data. The mapping may be from one address location to another on a given device, for example, or even from one device to another (in the case of striping, for example). \u201cData location information\u201d includes items such as a logical block address and length appearing in a storage command.","A multipathing module  provides a multipathing system function by which multiple paths to these storage devices are established through the storage interconnect  and utilized in operation for greater parallelism, availability, and performance. As depicted, multipathing module  connects to EHBA (), EHBA (), EHBA (), and NHBA () (via the HBA driver interface  and HBA driver  of ), and the following paths exist:","To D () via EHBA (), EHBA (), and NHBA ()","To D () via EHBA () and EHBA ()","To D () via NHBA ()","To D () via EHBA () and NHBA ().","It should be noted that  presents a simplified example which assumes that each HBA ,  and storage device  has only one connection to the storage interconnect . In general, as depicted in , each HBA  and storage device  may have multiple such connections, and it will be appreciated that the number of potential paths between a given HBA ,  and storage device  may be correspondingly greater.","In the configuration of , the only path to disk D () is via NHBA (), which means that there is no hardware-assisted encryption available for encrypting\/decrypting data of that disk. The significance of this incapability is described below.","In an arrangement such as that of , the multipathing module  is responsible for maintaining an awareness of which disks  it can \u201creach\u201d (engage in I\/O operations with) as well as the corresponding set of usable paths to each reachable disk. The virtualization module  maintains an awareness of the disks (e.g., D () and D ()) which underlie each logical volume (e.g., L ()). Upon receiving storage commands (I\/O commands including reads and writes of storage data) directed to logical volume L (), the virtualization module  generates corresponding storage commands to D and D and issues these commands to the multipathing module . The multipathing module  responds by selecting a path for each command and issuing the command to the HBA  for the selected path. Storage commands directed to an encrypted region of a disk  may utilize the hardware-assisted encryption provided by an EHBA  along a selected path. In the event that a disk  is not reachable via an EHBA  (such as disk D () as mentioned above), any such storage commands will utilize the encryption functionality of the crypto kernel .",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIGS. 8A and 8B","b":["156","256","62","1","4","256","156","1","4"]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 8A","FIG. 8A","FIG. 8A"],"b":["124","1","4","1","1","122","1","4","1","156","1","1","156","1","3","156","3","62","156","1","156","3","4","1","156","1","62","1","156","1","1","156","1","3","156","3","1","122"],"i":["a","a"]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 8B","b":["126","2","122","2","140","2","3","140","3","3","1","256","1","2","122","3","156","126","84","2","122"],"i":["b","b","b"]},"The above description in connection with FIGS.  and A-B illustrates certain important aspects of using hardware-assisted encryption in a system such as that of . First, it must be possible for an EHBA  to obtain the encryption metadata (including encryption key) for those regions of encrypted storage for which that EHBA  will handle data storage commands, so that the encryption circuitry of the EHBA  can perform the correct encryption\/decryption operation using the correct key for each distinct region of storage. As the KCM  is the overall manager of encryption operations for the host  in which an EHBA  resides, a mechanism is needed to enable the KCM  to communicate the encryption metadata to its EHBAs . Additionally, a mechanism is needed for the KCM  to ascertain whether hardware-assisted encryption is available for any given region of storage. Both these needs are further complicated by the presence of ILs , especially those (like virtualization module ) which are \u201cremapping\u201d layers that effect a translation or mapping between two different representations of a given storage volume. Additionally, even non-remapping layers like the multipathing module  create potential problems, because hardware-assisted encryption may not be available on all paths for a given disk , yet the system must ensure that encryption is performed reliably. All these issues point to the need for a communications protocol among the different layers of the storage I\/O stack  to support the data encryption function.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 9","FIG. 9"],"b":["200","1","122","46","46","74"],"i":"a"},"By \u201cup and down\u201d the storage I\/O stack  it is meant that a DEK management protocol command may be created by KCM  then passed to a top-level IL , such as virtualization module . That IL  examines the command and, in most cases (exceptional cases are discussed below), will send one or more corresponding commands to the next IL  down the stack, such as multipathing module . This pattern repeats until one or more commands reach HBA driver(s) . Responses flow in the other direction, from the HBA drivers  upward to the KCM . In some cases, commands may not travel completely down the storage I\/O stack , and responses may be generated and sent upwards by one or more ILs . By this chain-like communications mechanism, information required for proper encryption-related operation is shared among the various components of the storage I\/O stack . In all cases, the initiator of a command is an example of a first functional component  of , while a responder is an example of a second functional component . It will be appreciated that intermediate layers  may act as a responder for commands received from higher in the I\/O stack , and also act as an initiator for commands being sent further down the I\/O stack .","As described above with reference to , the transport mechanism  carries protocol communications messages (e.g., messages , ) to cause a functional component to execute a protocol-controlled processing action with respect to storage I\/O commands. In the case of the DEK management protocol, the protocol-controlled processing action is the encrypting and decrypting of the data that is the subject of the storage I\/O commands. Details of DEK management protocol messages and the use of the DEK management protocol for controlling encryption\/decryption operation are now described.","In one embodiment, KCM  uses the DEK management protocol to first determine whether or not there is an EHBA  (or a set of multiple EHBAs ) that can provide encryption for each encrypted region of the logical volume L (). If not, then it is deemed that EHBA encryption is not available, and the KCM  assumes responsibility for encryption\/decryption operations for the logical volume L using the crypto kernel . If the KCM  determines that such EHBA encryption is available, it uses the DEK management protocol to provide the required encryption metadata to each EHBA  that requires it. Subsequently, storage commands directed to the logical volume L are sent down the stack  for execution, relying on operation of one or more EHBAs  for the data encryption\/decryption part of operation for the encrypted regions.","As previously noted, encryption may be applied to separate \u201cregions\u201d of a given volume  or disk . Here \u201cregion\u201d refers to a span of contiguous logical block addresses (LBAs). To illustrate the concept, assume a hypothetical simple volume  having 16 blocks of storage with addresses 0 through 15. The volume may have an encryption pattern as follows:",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["LBA range","Encryption?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0-3","Not encrypted"]},{"entry":["\u20024-12","Encrypted"]},{"entry":["13-15","Not encrypted"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The overall pattern for a given logical unit of data (LU) is referred to below as a \u201cLUN map\u201d (the term \u201cLUN\u201d is commonly used in the industry to refer to an LU). In operation, it is necessary for the KCM  to provide the LUN map for each volume to any EHBA  that will handle I\/O for that volume. It is assumed herein that only one data encryption key is used for each volume, although in general it is possible to use different keys for different regions, for example.","In a somewhat more realistic example, an encrypted LU may store metadata and formatting information in plaintext form. In addition, certain additional regions of an encrypted LU may be designated as unencrypted for various reasons (e.g., to enhance performance on a region that is frequently accessed). For example, logical volume L () may be an encrypted LU having a size of 10 megabytes. Given a 512-byte block size, logical volume L () has 20,480 blocks. Blocks - may be unencrypted and reserved for operating system use, while blocks - may be unencrypted and reserved for storing encryption metadata. Blocks -, may be encrypted, blocks ,-, may be unencrypted for performance reasons, and blocks ,-, encrypted. Thus, only blocks -, and ,-, of logical volume L () are subject to encryption.","Additionally, the virtualization module  distributes the blocks of logical volume L () out across D () and D (). For example, blocks -, may be stored on D (), while blocks ,-, are stored on D (). This arrangement places portions of logical volume L () subject to encryption on both D () and D (). It should be noted that the mapping between L and D\/D may not (and in many cases will not) preserve LBAs. Thus blocks -, of L may be mapped to blocks ,-, of D, for example.","Referring again to , in step , KCM  determines if there exist one or more EEs (e.g., EHBA(s) ) that can perform encryption\/decryption for all encrypted regions of an encrypted logical volume (LV). If step  returns an affirmative response, execution proceeds with step , while if step  returns a negative response, execution may proceed with step . At step , it is concluded that there is no EE to perform encryption\/decryption for the subject volume\/disk, which means that any required encryption\/decryption operations are to be performed by the KCM  using the crypto kernel . As described above with reference to , in the present example the condition of step  is satisfied for logical volume L (). However, for logical volume L (), step  evaluates in the negative because there is no encrypted path to D (), and thus the method will execute step  with respect to logical volume L (). It should be noted that in some embodiments, even if an EHBA  is present in all paths to a storage device , condition  could still fail if an essential path (or an essential group of paths) is blocked by an error in the EHBA  (e.g., the EHBA  has no remaining capacity or is temporarily offline).","As shown in , step  may be accomplished by performing some or all of sub-steps  and , which perform handshake and query operations. In connection with these sub-steps, different specific commands and responses of the DEK management protocol are used as described more fully below. Table 1 provides a general structure for a DEK management protocol command block used in performing these operations:",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General command block format"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bytes","Field"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["0-7","(8 bytes) Protocol Signature"]},{"entry":["\u20028-15","(8 bytes) Checksum"]},{"entry":["16-19","(4 bytes) Version"]},{"entry":["20-23","(4 bytes) Reserved"]},{"entry":["24-27","(4 bytes) DEK Management protocol Opcode"]},{"entry":["28-31","(4 bytes) DEK Management protocol Response Status"]},{"entry":["32-39","(8 bytes) DEK Management protocol Endpoint ID"]},{"entry":["40-47","(8 bytes) Key Controller Handle"]},{"entry":["\u200348-1535","Command Specific Parameters and Data"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The general command block format is a structure having a format as shown in Table 1. In some embodiments, all commands are a maximum of 1536 bytes (3\u00d7512-byte blocks) long, although this is by way of example only. The fields and arguments are described below. In the description below, the label [In] means the parameter is an \u201cinput\u201d passed from the KCM  in\/down to the EE (via one or more ILs ), while [Out] means the parameter is an \u201coutput\u201d returned by the EE out\/up to the KCM  (via one or more ILs ). \u201cInitiator\u201d means the KCM  or cooperating IL  that generates a protocol command. \u201cDevice Object\u201d means a device managed by a driver in the storage I\/O stack . It may be a volume, an LV, an LU, a path device, or a storage device.","The following is a description of the various fields in the general command block shown in Table 1 above:\n\n","Referring again to , in step  (which may be omitted), KCM  sends a Handshake command down to the next IL  in order to test for the existence of a cooperating EE in the storage I\/O stack .","The KCM  sends the Handshake command as the first DEK management protocol command to a Device Object. Only one handshake at a time should be outstanding to a given device object. The EE should not trigger an internal state change upon receipt of a Handshake, e.g., a Handshake command should not reset associations currently in effect for a Device Object.","Generally, KCM  will send one Handshake command per LV that it manages. As long as KCM  receives one affirmative Handshake response command block in response to the Handshake command, KCM  will proceed to step . Otherwise, KCM  will proceed with software encryption.","When a cooperating IL  receives a Handshake command from above in the storage I\/O stack , it passes the command down to the next level down in the storage I\/O stack . If the LU potentially involves multiple EEs of the storage I\/O stack , then the IL will replicate the command block (potentially with modification as discussed below) and send a copy down the storage I\/O stack  toward each such EE.","For example, if the IL  is a virtualization module  that virtualizes the LU across two storage devices () and (), then virtualization module  sends two copies of the Handshake command block down the storage I\/O stack , one referencing storage device () as the device object, and the other referencing storage device () as the device object. If the virtualization module  receives any affirmative Handshake response command blocks, the virtualization module  responds back to the KCM  with an affirmative response. This indicates to the KCM that there is at least one EE that may require encryption metadata. However, it should be understood that in some embodiments, some ILs  may be configured to respond negatively if any of the Handshake response command blocks from below are negative.","The DEK management protocol supports multiple \u201cclasses\u201d of EEs. An EE of a cooperating class ignores Handshake commands that do not contain its class name and acknowledges a Handshake addressed to its EE class name by filling in the Endpoint ID field.","See Table 2, below, for an example layout of a Handshake command block with Handshake-specific definitions of bytes -.",{"@attributes":{"id":"p-0090","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Handshake command block format"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bytes","Field"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["0-7","Protocol Signature"]},{"entry":["\u20028-15","Checksum"]},{"entry":["16-19","Version"]},{"entry":["20-23","Reserved"]},{"entry":["24-27","Handshake Opcode"]},{"entry":["28-31","DEK management protocol Response Status"]},{"entry":["32-39","DEK management protocol Endpoint ID"]},{"entry":["40-47","Key Controller Handle"]},{"entry":["\u200248-303","(256 bytes) Encryption Endpoint Class Name"]},{"entry":["304-511","(208 Bytes) Reserved"]},{"entry":["\u2002512-1023","(512 Bytes) Pseudo-random bytes"]},{"entry":["1024-1151","(128 Bytes) Reserved"]},{"entry":["1152-1407","(256 Bytes) Pseudo-random bytes"]},{"entry":["1408-1535","(128 Bytes) Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The following is a description of various command-specific fields in the Handshake command block shown in Table 2 above:\n\n","The EE is expected to update the version field if the version supported by EE is different than requested by KCM . The ILs  are also expected to ensure version compatibility with the EE. If the EE supports a lower version than required by the IL , IL  should fail the Handshake request.","Referring again to , in step  the KCM  sends a Probe command down to the next IL  to probe for the existence of \u201cnon-protocol-aware\u201d intermediate layer virtualization drivers in the device stack , where \u201cnon-protocol-aware\u201d means that the driver either cannot (or for some reason just does not) recognize and act on the DEK management protocol messages in the transport read commands\/responses. Based on receipt of the \u201cSuccess\u201d Response Status at the end of the Handshake stage, the KCM  is aware of the EE's presence, possibly with a non-protocol-aware intermediate driver that does not remap the LBA  on the device object. However, the intermediate driver could be re-mapping other LBAs on the device object and may not be a participant in the DEK management protocol, and that could lead to potential data corruption. The KCM  tries to minimize this possibility by the use of a Probe command.","The KCM sends a read capacity command on the device object and then sends Probe requests at three odd LBAs (and of length ) on the device. The LBAs might be selected as the smallest odd integral values near to \u2153*n, (\u2154)*n & n\u22121. The Probe-specific data in the payload contains the LBA itself.","Once the Probe command is dispatched, a co-operating and remapping driver  is expected to appropriately change the LBA in the read buffer  as well. A non-cooperating non-remapping driver lets the request go through as a normal read request, and a non-cooperating remapping driver remaps the LBA in the CDB  but does not alter the LBA in the read buffer .","After the Handshake phase is complete, the EE is expected to examine all read requests whose length is 3 blocks regardless of LBA. If it finds the protocol signature and the Probe opcode in the read buffer , it compares the LBA in the CDB  with the LBA in the read buffer . Should there be a mismatch, the EE returns a \u201cNon-cooperating Virtualization Layer\u201d (NOCOOP_VIRT) status, and otherwise (i.e., a matching relationship) it returns Success. In either case, the Read CDB  is not sent over the storage interconnect .","Based on the opcode status, the KCM  becomes aware of a non-cooperating driver between KC and EE.","See Table 3, below, for an example layout of a Probe command block.",{"@attributes":{"id":"p-0099","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Probe command block format"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bytes","Field"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["0-7","Protocol Signature"]},{"entry":["\u20028-15","Checksum"]},{"entry":["16-19","Version"]},{"entry":["20-23","Reserved"]},{"entry":["24-27","Probe Opcode"]},{"entry":["28-31","DEK management protocol Response Status"]},{"entry":["32-39","DEK management Endpoint ID"]},{"entry":["40-47","Key Controller Handle"]},{"entry":["48-55","(8 bytes) Logical Block Address"]},{"entry":["\u200256-511","(456 Bytes) Reserved"]},{"entry":["\u2002512-1023","(512 Bytes) Pseudo-random bytes"]},{"entry":["1024-1151","(128 Bytes) Reserved"]},{"entry":["1152-1407","(256 Bytes) Pseudo-random bytes"]},{"entry":["1408-1535","(128 Bytes) Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The following is a description of the various fields in the Probe command block shown in Table 3 above:","Probe Opcode\u20144 bytes\u2014Probe\u20140x07080a (Sent as \u201c0x09\u201d, \u201c0x0a\u201d, \u201c0x08\u201d, \u201c0x07\u201d in the Little Endian byte order)","DEK Management protocol Response Status\u20144 bytes\u2014possible returns for a Probe are Success and Non-cooperating Virtualization Layer.","DEK Management protocol Endpoint ID\u20148 bytes\u2014[In] Returned by the Encryption Endpoint for the Handshake, echoed back by Key Controller, thus addressing the Endpoint ID.","Key Controller Handle\u20148 bytes\u2014Not used. Preferably set to zero.","Logical Block Address\u20148 bytes\u2014[In] Set by the KC to the same LBA as in the Read CDB. Compared with the LBA in the Read CDB by the EE. The EE returns Success status if the two are identical and Non Cooperating Virtualization Layer if they are different. Intervening layers that remap LBAs will adjust them in the CDB. Protocol-aware ILs need to set this field and the CDB LBA to the same value.","The probe operation as described uses a somewhat different transport than other protocol commands\u2014its transport is permitted to an address other than 1009, and an endpoint recognizes the probe transport by its use of a length 3 read command and the presence of the protocol signature and probe operation code in the read buffer. In alternative embodiments, a probe could be implemented using a non-read-based transport.","Referring again to , in step , KCM  sends a Query command down to the next IL  to determine if an encryption capability such as hardware-assisted encryption is supported for a specified range on an LV. Each IL  between the KCM  and the EE responds to the Query based on the encryption capabilities of the underlying devices.","An IL  broadcasts the Query command to all the underlying devices and aggregates the results of individual queries into one response to the KCM  (or an IL  above it). The response from an IL  should not lead to data corruption. For example, an IL managing a virtual volume spanning two underlying LUs should support hardware-assisted encryption on the virtual volume only if the paths to both the LUs have hardware-assisted encryption available.","For example, if the IL  is a virtualization module  that virtualizes a logical volume across two storage devices () and (), then virtualization module  sends two copies of the Query command block down the storage I\/O stack , one referencing storage device () as the device object, and the other referencing storage device () as the device object. Generally, only if the virtualization module  receives affirmative Query response command blocks for both storage devices () and () will the virtualization module  respond back to the KCM  with an affirmative response, however, this behavior may differ if a particular form of virtualization is performed that allows otherwise. For example, in the case of a read-only LV mirrored onto two or more distinct LUs, as long as one of the LUs is readable with encryption at the level of an EHBA , the virtualization module  may return an affirmative response, even if a negative response is returned for one of the LUs.","As an alternate example, if the IL  is a multipathing module  having paths through multiple HBAs  to a given storage device , then the multipathing module  sends copies of the Query command block to all such HBAs down the storage I\/O stack . If the multipathing module  receives any affirmative Query response command blocks, the virtualization module  respond back to the KCM  with an affirmative response.","An EE looks for the Endpoint ID in the payload that matches its ID (i.e., the Endpoint ID that is sent up by the EE to the KCM  in the Handshake response), and returns affirmatively if it can perform its encryption capabilities on the specified ranges for the device object. Otherwise the EE may return in the negative (e.g., if the EE does not have a connection to the appropriate storage device , if the EE was not initialized, or if the EE is temporarily busy and the command should be retried).","Included within the Query command is a LUN Map, which defines the areas subject to encryption. Each area is provided with reference to a Logical Block Address (LBA), which is an abstraction of the block addresses at a given layer of logical abstraction. Returning to the example provided above in which logical volume L () is an encrypted LV  megabytes in size, blocks ,-, and ,-, of logical volume L () would be listed as subject to encryption.","Some ILs  may remap the LUN map as appropriate. These ILs  are referred to as \u201cremapping\u201d ILs . For example, a virtualization module  is an example of a remapping IL , while a typical multipathing module  is not a remapping IL . Recall that, in the example, blocks -, of logical volume L () are stored on D (), while blocks ,-, are stored on D (). Further suppose that the encrypted blocks stored on D () begin at local block ,,, while the encrypted blocks stored on D (), begin at local block ,,, but actually are spread out across 2 ranges: ,,-,, and ,,-,,. Therefore, in the Query command passed on to storage device D (), the LUN Map will indicate LBAs ,,-,,; and in the Query command passed on to storage device D (), the LUN Map will indicate LBAs ,,-,, and ,,-,,.","See Table 4, below, for an example layout of a Query command block.",{"@attributes":{"id":"p-0115","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Query command block format"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bytes","Field"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["0-7","Protocol Signature"]},{"entry":["\u20028-15","Checksum"]},{"entry":["16-19","Version"]},{"entry":["20-23","Reserved"]},{"entry":["24-27","Query Opcode"]},{"entry":["28-31","DEK management protocol Response Status"]},{"entry":["32-39","DEK management protocol Endpoint ID"]},{"entry":["40-47","Key Controller Handle, Undefined"]},{"entry":["48-71","(24 bytes) Undefined"]},{"entry":["72-75","(4 bytes) LUN Map Count"]},{"entry":["76-83","(8 bytes) Starting LBA Entry[0]"]},{"entry":["84-91","(8 bytes) Number of Blocks [0]"]},{"entry":["92-99","(8 bytes) Starting LBA Entry[1]"]},{"entry":["100-107","(8 bytes) Number of Blocks [1]"]},{"entry":["\u2002108-1019","LBA Range Structures [2] to [58]"]},{"entry":["1020-1027","(8 bytes) Starting LBA Entry[59]"]},{"entry":["1028-1035","(8 bytes) Number of Blocks [59]"]},{"entry":["1036-1535","Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The following is a description of the various fields in the Query command block shown in Table 4 above:\n\n","Recall that, if step  returns an affirmative response, execution proceeds with step , while if step  returns a negative response, execution may proceed with step . In some embodiments, step  may also be executed on its own, without first performing step .","In step , KCM  sends encryption metadata associated with the encrypted LV from the KCM  to the EE via ILs , the encryption metadata identifying an encryption key and one or more encrypted regions of the LV. The encryption metadata may also identify other associated encryption information needed to perform the encryption algorithm, such as, for example, an identification of the encryption algorithm. The sending results in establishment of one or more shared associations between the KCM  and the EE, the shared associations associating the encrypted LV with the encryption metadata for the encrypted LV. In one embodiment, this step is accomplished using the DEK management protocol by sending a DEK Management Associate command.","The Associate command creates an association of (1) an Encryption Key Blob, with (2) a LUN Map on (3) a Device Object, thereby effectively turning on encryption for the LU and LBA Range(s). The Key Blob is a set of encryption metadata, storing the key and all the other information needed to perform encryption\/decryption that is stored on the key manager, as described below. Although in the on-host case, the key blob is sent within the Associate command, in an off-host case, the key ID may be sent within the Associate command instead of the key blob (or, in some embodiments, an encrypted version of the key blob, referred to as a \u201cwrapped\u201d key blob, may be sent). Multiple Key Blob\/LUN Map Associations can be made for a Device Object. Associate commands can be generated by the KCM  and by ILs , although ILs  do not originate an association, but rather pass on one or more copies (with modifications as necessary) of an Associate command received from above. In some cases, the association may also include Application information.","There are two forms of an Associate command:\n\n","An EE should respond as follows for the different Association types\/association handle values:","If the Association Handle is NULL\u2014it means the KCM  or an IL  is creating a new Association, so the EE should:\n\n","If the Association Handle is not Null\u2014it means the Association exists, so the EE should:\n\n","Any Associate command (whether the first or a repeat) should be preceded by a Query command\u2014though the EE does not need to enforce this.",{"@attributes":{"id":"p-0125","num":"0150"},"figref":["FIG. 10","FIG. 10"],"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":{"@attributes":{"id":"ul0013-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":["DEK management protocol Response Status\u20144 bytes\u2014[Out] possible returns are Success, Invalid HW State, No Memory, Busy, Invalid Range, Invalid Key, Association Exists, Association Overflow.","DEK management protocol Endpoint ID\u20148 bytes\u2014[In] Echoed from the EE's response to the initial Handshake command. Address of the EE for the Associate. The EE passes on an Associate command that does not contain the EE's Endpoint ID.","Association Handle\u20148 bytes\u2014[In\/Out]\n        \n        ","Data Encryption Key Parameters\u2014","The association handle is followed by offsets to various data items :\n        \n        ","These offsets , , ,  are followed by the following variable length parameters:","Key Blob \n        \n        ","Key ID\n        \n        ","LUN Map Count\u20144 bytes [In]\u2014Number of valid LUN Map entries being reported. It should be at least one. Implementations can restrict the number of LUN map entries supported.","LUN Map Array\u201416 to 960 bytes (up to 60 16-byte structures)\u2014[In] Specifies the LBA ranges on the Device Object to associate with the Key Blob  or Key ID. Sub-fields include starting LBA and a length or LBA-count. Unused map entries are set to zero.","Reserved bytes [variable-1535]\u2014Unused and undefined"]}}}},"Referring again to , upon successful completion of an Associate during step , an EE is ready to apply encryption\/decryption to the encrypted regions of a LU as defined in the LUN map, using the encryption metadata from the Key Blob and the application information. As long as the association remains active, subsequent read\/write commands directed to these regions employ decryption\/encryption using the encryption metadata. This operation is depicted in step .","The DEK management protocol may also employ Update and Disassociate commands. An Update command tells the EE to update the association for the Device Object with the Key Object and LUN map information in the protocol command block. It provides an atomic way for an EE to effectively delete and create an association in one step. It would be used, for example, to support resizing of an encrypted LU.","The Disassociate Command deletes the association that had been created with a previous Associate command for a Device Object. Subsequent read and write commands in the LBA range(s) covered for that association are no longer encrypted\/decrypted by the EE. Disassociate is used when the EE can no longer perform its duties and a switch to encrypting using the crypto kernel  is needed. Switching back happens through a new Associate command. An example, looking back at , would be if EHBA failed for some reason. D and D would still be reachable by EHBA and NHBA, respectively, but the Crypto kernel  would have to be used so the Disassociate would be sent on L. Both the Update (which, in some embodiments, is an Associate command containing a valid non-null handle) and Disassociate commands include an Association Handle to identify the subject association.","While various embodiments of the invention have been particularly shown and described, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, features and advantages will be apparent from the following description of particular embodiments of the invention, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, emphasis instead being placed upon illustrating the principles of various embodiments of the invention.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
