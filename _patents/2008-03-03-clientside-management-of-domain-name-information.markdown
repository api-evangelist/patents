---
title: Client-side management of domain name information
abstract: An exemplary method includes booting a computing device, in response to the booting, accessing a file that includes domain names and resolving at least one of the domain names by issuing a request to a server where the resolving occurs as a background process. An exemplary method includes receiving a notice to invalidate client DNS resolver cache information for a domain name, accessing a list of client subscribers to an invalidation service for the domain name and issuing an instruction to the client subscribers to invalidate their respective client DNS resolver cache information for the domain name. An exemplary method includes receiving a request to resolve a domain name, resolving the domain name and transmitting information for the resolved domain name and additional information for at least one other domain name. Other methods, devices and systems are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08966121&OS=08966121&RS=08966121
owner: Microsoft Corporation
number: 08966121
owner_city: Redmond
owner_country: US
publication_date: 20080303
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Many applications can connect to, or require connection to, remote resources on the Internet. For example, a web browser application allows a user to enter a domain name and then access a host server associated with the domain name. While the user is normally unaware of underlying processes required to connect to the host server, the user's experience is more favorable when these processes occur quickly. Unfortunately, issues like congestion stemming from rising Internet traffic (e.g., due to web innovations, globalization and increasing connectivity to billions of people in emerging markets) can increase significantly the amount of time required for underlying processes and hence diminish the user's experience.","Various exemplary methods, devices, systems, etc., described herein pertain to techniques for client-side management of domain name information that can enhance a user's Internet experience.","An exemplary method includes booting a computing device, in response to the booting, accessing a file that includes domain names and resolving at least one of the domain names by issuing a request to a server where the resolving occurs as a background process. An exemplary method includes receiving a notice to invalidate client DNS resolver cache information for a domain name, accessing a list of client subscribers to an invalidation service for the domain name and issuing an instruction to the client subscribers to invalidate their respective client DNS resolver cache information for the domain name. An exemplary method includes receiving a request to resolve a domain name, resolving the domain name and transmitting information for the resolved domain name and additional information for at least one other domain name. Other methods, devices and systems are also disclosed.","Various exemplary methods, devices, system, etc., described herein pertain to client-side management of domain name information in a Domain Name System (DNS). Domain name information may be information as included in a DNS Resource Record (RR) and\/or other information associated with a domain name. An exemplary client-side mechanism prefetches domain name information as a background process, for example, at boot during empty or unused cycles. Such a mechanism can enhance a user's experience when the user wants to connect to a host server for a domain name that the user connected to in a previous session. For example, the prefetch mechanism can access a persistent record or cache of a user's frequently requested domain names and then resolve at least some of these domain names as a background process during boot. Prefetching ensures that the client resolver cache has fresh information for the domain names and allows the user to connect to one or more appropriate host servers without having to wait for resolution by a DNS server.","Another exemplary mechanism allows for invalidation of client-side domain name information. A client-side DNS cache typically caches a Resource Record for a domain name for a period of time specified by a value, referred to as \u201ctime-to-live\u201d (TTL). When the TTL expires, a client-side DNS service (e.g., a resolver or name resolution service) makes a request to re-resolve the domain name. As short TTLs can increase network traffic, TTLs are typically long (e.g., a day). For any of a variety of reasons, relatively instantaneous invalidation of client-side domain name may be desired. An exemplary invalidation mechanism can invalidate client-side domain name information and cause a client DNS service to request fresh information. Alternatively, such a mechanism may simultaneously invalidate and refresh client-side domain name information.","Yet another exemplary mechanism allows for management of information for groups of domain names. In general, a client wants to avoid issuing requests for name resolution as such requests increase network traffic and require action by one or more servers. An exemplary grouping mechanism allows a client to acquire information for more than one domain name when issuing a request for resolution of a single domain name.","An exemplary client architecture optionally includes a failover module that fails over a client application to a new host server. An exemplary client architecture optionally includes an Internet Location Coordinate (ILC) module that operates in conjunction with an ILC enhanced DNS system with beacons that help provide information to participants about their respective \u201clocations\u201d in a network space. A participant in an ILC enhanced DNS system can be any resource on the network (e.g., a client, a server, etc.). In various examples, transmission of location information (e.g., ILCs) can occur via DNS and TXT records; via \u201cExtensions to DNS\u201d (EDNS) and explicit new record types; or entirely outside DNS but applied to select an address returned by a DNS query.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["102","108","102","104","114","126","130"]},"According to the method , in a boot block , a client computing device (\u201cclient\u201d) starts-up and loads \u201cold\u201d DNS information from a file (e.g., written before the client shut down) into the client's DNS resolver cache. In the boot block , the boot time is designated T and the age of the \u201cold\u201d DNS information is designated T, though the file will likely contain multiple domain names that were fetched at different times. In a request block , the client makes a request to resolve a domain name. In an access block , the client accesses its DNS resolver cache, which contains the \u201cold\u201d DNS information. A decision block  follows that decides if an IP address exists in the cache for the domain name. If the decision block  decides that no IP address exists in the cache, then the client resolves the domain name via a DNS server, per the resolution block  (see, e.g., description for method ). However, if an IP address exists for the domain name in the client-side DNS resolver cache, as preloaded, then the client connects to the associated host server per the connection block . In this branch, the domain information will only be considered \u201cfresh\u201d (and hence usable) if T\u2212T is less than the TTL for that domain name, where the TTL was returned along with the domain name's IP addresses in the DNS response message.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2","b":["200","200","102","108","200"]},"According to the method , in a boot block , a client computing device (\u201cclient\u201d) starts-up and loads \u201cold\u201d DNS information from a file into the client's DNS resolver cache. In the boot block , the boot time is designated T and the age of the \u201cold\u201d DNS information is designated T. In the example of , it is assumed that the file includes, at a minimum, one or more domain names. The file may optionally include other information such as in the method . When the file is loaded, a background process  commences that includes a resolution block  that resolves one or more domain names included in the file. In the example of , the domain name information acquired for a particular domain name by the resolution block  is assigned a time T\u2032. As already explained, a name resolution process issues a request to a DNS server to, for example, acquire a Resource Record for a domain name. In turn, information received from the DNS server is loaded into the client's DNS resolver cache. The background process  may execute during empty or unused cycles during start-up of the client computing device or at others times during the use of the computing device. The background process  may be limited in terms or execution time and the number of domain names to resolve or it may be limited to increase the total DNS traffic by no more than a constant factor over what the user's actions would have naturally incurred. For example, the process  may be restricted to the first five minutes after boot and\/or be limited to about twenty domain names. While such a process may be customized by a user, it may be programmed by default to execute automatically without user input or user awareness. The prioritization of domain names to fetch may be based on prior history of domain name requests, likely prioritizing those prior name requests that would not be served from the local DNS resolve cache if they recurred.","At some time after boot, per a request block , the client requests resolution of a domain name. At a time T, where T is greater than T\u2032, the client accesses its DNS resolver cache. A decision block  follows that decides if an IP address exists in the resolver cache for the domain name. If the decision block  fails to find an IP address, then a resolution block  resolves the domain name via a DNS server. According to this branch, the domain name was not amongst the one or more domain names resolved by the background process . If the decision block  finds an IP address for the domain name in the client's DNS resolver cache, then it is a \u201cfresh\u201d IP address, possibly acquired at time T\u2032. In other words, if the domain name specified in the request block  is a domain name resolved by the background process , then the domain name information is no older than T\u2032.","In comparison to the method , the method  enhances a user's experience as it can provide for quicker connections to network resources for one or more domain names. In comparison to the method , the method guarantees freshness of domain name information for one or more domain names.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 2"],"b":["300","200","300","310","312","314","310"]},"The kernel space includes various components that operate in conjunction with a TCP\/IP stack . Such a stack typically operates via a network driver interface specification (NDIS) to communicate with network resources via frames , . The TCP\/IP stack  includes a transport layer, a network layer and a framing layer. As shown, frame  carries an IP datagram and frame  carries an IP datagram and Internet Location Coordinate (ILC) information (see, e.g., ).","The architecture  may include the following APIs by which applications, services, or other system components access the TCP\/IP stack :","A Kernel-Mode API used by KM clients.","Sockets API used by Sockets-based applications and services. The Sockets API operates through an Ancillary Function Driver (AFD) to perform Socket functions with the TCP\/IP stack .","Transport Driver Interface (TDI) used by NetBIOS over TCP\/IP (NetBT) clients and other legacy TDI clients. A translation layer exists between TDI and the TCP\/IP stack .","The TCP\/IP stack  exposes an inspection API , which provides a consistent, general-purpose interface to perform deep inspection or data modification of packet contents. The Inspection API  is part of a filtering platform. The TCP\/IP stack  provides access to the packet processing path at the Network and Transport layers.","The architecture  includes an exemplary failover module , which may be configured in any of a variety of manners. For example, the failover module  may be configured to directly access information in the TCP\/IP stack . The module  may be configured to use the inspection API . The failover module  may also be configured to expose an API for user space applications. The failover module  may be part of, or function cooperatively with, the DNS service . For example, the failover module  may be a separate OS service that can retrieve information from the resolver cache  or resolver file .","The architecture  also includes an ILC module , which provides for processing Internet Location Coordinate (ILC) information. Such information is described in more detail with respect to . The ILC module  may be configured to operate in conjunction with the failover module . For example, failover may occur based at least in part on ILC information. The ILC module  may be part of, or function cooperatively with, the DNS service . For example, the ILC module  may store ILC information in a cache and\/or a file associated with the DNS service .","The architecture  includes the exemplary prefetch module , which may be configured in any of a variety of manners. For example, the prefetch module  may be configured to directly access information in the TCP\/IP stack . The module  may be configured to use the inspection API . The prefetch module  may also be configured to expose an API for user space applications. The prefetch module  may be part of, or function cooperatively with, the DNS service . For example, the prefetch module  may be a separate OS service that can retrieve information from the resolver cache  or resolver file . Alternatively, another cache or file may be available that maintains information between boots of a client computing device (i.e., a persistent information store).","The prefetch module  may be configured to operate in conjunction with the failover module  and\/or the ILC module . For example, the prefetch module  may fetch information for use by the failover module  and the prefetch module  may fetch information based at least in part on ILC information.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4","FIG. 4"],"b":["400","400","407","415","420","430","413","420","430"]},"The system  may depend on time, distance, network traffic, machine workload, bandwidth, etc. To understand better how such a system may be defined, consider a vehicle on a major interstate highway en route to an airport. At various locations along the highway, the state department of transportation transmits information to displays that provide information to vehicle operators. When the vehicle is at a display location, the department of transportation may transmit a travel time message that indicates how many minutes it will take for a vehicle at the display location to reach the airport. Such information is helpful as the vehicle operator may decide to take an alternate route. Further, the reasons for the stated travel time may be irrelevant to the vehicle operator. In other words, the vehicle operator may not care whether the travel time is lengthy due to road construction, holiday traffic, an accident, etc. While the department of transportation may choose to display a specific reason or reasons, such information may not add much value to the information conveyed by a simple travel time in minutes.","As described herein, in various examples, an Internet Location Coordinate (ILC) may be a number, a set of numbers, or a set of numbers where each one is associated with some additional information (e.g., a tuple for each beacon). An ILC may indicate a local position to a client where this position is with respect to a network logical space measuring \u201ctravel time\u201d or congestion, and not necessarily geographic location. ILCs may be compared to estimate \u201ctravel time\u201d or congestion between participants. Such simplicity is in-line with the DNS and such an ILC may be carried according to an existing DNS protocol.","Referring again to the system  of , the client  acquires information associated with three beacons _, _ and _. For example, a beacon can act as a reflector where the client  can send a packet to the beacon and receive a response packet. The client  can then determine the round trip time (RTT) to and from a beacon (e.g., a \u201ctravel time\u201d). As the client  performs the same process with multiple beacons (i.e., the beacons _, _ and _), the client  becomes more aware of its surroundings. In particular, the client  becomes aware of its own condition in the system where its own condition may be represented according to a number or a set of numbers, etc.","As mentioned, an ILC participant can be any resource on a network. Hence, the web servers _, _ and _ may be participants that can determine respective ILCs using the beacons . For example, the web server _ may transmit packets to the beacons _, _ and _ and receive corresponding return packets. As the web server _ may know, a priori, information about the beacons _, _ and _, it can now determine its position in the system (e.g., its ILC). While the example of  shows three beacons, other numbers of beacons may be used. Generally, two or more beacons may be used.","As described herein, the exemplary system  allows clients to determine their position in a network logical space. Such information can be used for a variety of purposes. For example, where the web servers _, _ and _ provide essentially identical services, such information can be used to allow the client  to connect to the \u201cbest\u201d web server (e.g., the \u201cclosest\u201d server based on ILCs).",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 5","b":["500","500","420","420","450","420"]},"In an entry block , a domain name is entered (e.g., www.msn.com). In turn, a DNS server may identify a plurality of servers associated with the domain name, for example, web server _, _ and _. As explained, each of the servers includes an ILC module to ascertain their respective ILCs. In a receipt block , the client  receives information about the group of servers along with the ILC for each of the servers in the group. In a determination block , the client  determines the optimal server based on the ILCs for the servers and its own ILC.","In the example of , the client  may be a user connected to the Internet and the domain name may be www.msn.com. This domain name has a plurality of associated servers at various geographical locations around the world. Given the exemplary architecture  where beacons  are scattered throughout the networked world, each of the servers for the www.msn.com domain name knows its own ILC. When the DNS communicates with each server, each server can respond by sending its ILC to the DNS server, which, in turn, transmits this information to the client . The ILC module  can then determine which server is the optimal server based on the client's  ILC and those of the servers. In general, the optimal server is the server that can provide the most efficient service to the client .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 6","FIG. 3"],"b":["380","380","380"]},"In the example of , the prefetch module  includes various components -. A priority frequency component  prioritizes prefetch based on frequency information. A priority last access component  prioritizes prefetch based on last access time information. A prefetch based on ILC component  prefetches information based at least in part on ILC information. A prefetch based on size component  prefetches information based at least in part on amount of information communicated. For example, a client may desire quicker access to a host server where the client normally downloads many files or large files from that host server. A prefetch based on TTL component  prefetches information based at least in part on one or more TTLs. A custom prefetch component  allows a user to customize prefetch, which may rely on any of a variety of information. For example, a prefetch method may include prioritizing domain names according to their respective likelihood of being invalid on a future domain name resolution request (e.g., resolution information invalid or even domain name invalid). The component  may also provide an API for a user to enable\/disable and\/or adjust other aspects of a prefetch process.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 7","FIG. 6","FIG. 7"],"b":["700","700","710","714","718","381","382","722","726"]},"At a later time, a boot block  boots the computer. Upon booting, a load block  is initiated that loads information from the file. An analysis block  analyzes information in the file, for example, to determine a prefetch order, number of domain names to prefetch, etc. A prefetch block  prefetches domain name information for one or more domain names (e.g., based at least in part on the analysis). For example, the prefetch block  may simply issue one or more domain name resolution requests to a DNS server and return a Resource Record (RR) for each domain name. A load block  loads the domain name information to a cache such as a client DNS resolver cache (see, e.g., the cache  of ).",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 8","FIG. 7","FIGS. 4 and 5","FIG. 5"],"b":["702","700","740","742","760","760","764","768","772","772","702","780","772","776","776","500","702"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 9","FIG. 9"],"b":["901","920","940","901","905","907","992","920","910","912","994","930","930","930"]},"According to the method , in a requirement block , notice is received for invalidation of client cache information for a domain name. In response, in a call block , the server-side invalidation module  calls for invalidation of caches of client subscribers. For example, the call block  may force client-side TTLs for a particular domain name to be changed to \u201c0\u201d, which, in turn, may cause the client  to immediately request new information for the domain name.","In the example of , a transmit block  transmits new information to the subscribing clients. On the client side, per the replacement block , the invalidation module  may manage invalidation and updating by replacing a DNS cache entry or entries. At some subsequent time, per a request block , the client DNS service  requests resolution of the domain name and relies on the new information stored in the cache  to connect to a host server associated with the domain name.","An exemplary method can include bundling invalidation of information with updated information. For example, if A sends an invalidation instruction to B for invalidating information for a domain name, and A knows that B is going to issue a request to resolve the domain name, A can jump ahead in the process by sending its response (e.g., providing new or updated resolution information for the domain name) along with the invalidation instruction.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 10","b":["1020","1040","1020","1021","1022","1022","1023","1023"]},"The client-side invalidation module  includes a subscription management component  that can subscribe a client or respond to server-side subscription management. A subscription list component  allows a client to create a list of domain names for use by an invalidation service. A DNS cache access component  allows an invalidation service to access a DNS cache for overwriting entries, controlling TTL settings, etc.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 11","FIG. 11"],"b":["1101","1120","1140","1101","1105","1107","1192","1120","1110","1112","1194","1130","930","1131"]},"The method  commences in a request block  where a client requests resolution of a domain name. In a transmit block , the client  transmits the domain name with cookie information to the DNS server  where the cookie information may be managed by the grouping module . The DNS server  resolves the domain name and the grouping module  analyzes the cookie information to determine if the DN server  should transmit information for one or more additional \u201cgroup\u201d domain names to the client . Per a construction block , the DNS server  constructs a packet with domain name information for at least the request domain name. In an update block , the client  updates its cache  with the information received from the DNS server .",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 12","b":["1220","1240","1220","1221","1222","1223"]},"The client-side grouping module  includes a subscription management component  that can subscribe a client or respond to server-side subscription management. A grouping services component  can allow a user to select URLs, construct filters or specify filter criteria to group domain names, generate cookies, hash group information, etc. A DNS cache access component  allows a grouping service to access a DNS cache for overwriting entries, controlling TTL settings, etc.","An exemplary method for grouping domain names and receiving group information upon issuing a name resolution request can include polling for changes. For example, a client may issue a request for resolution of a domain name and include a poll request for changes associated with a group of domain names. In response a receiving server may determine whether changes have occurred to any members of the group and transmit to the client information for only those members with changes.","An exemplary method optionally operates according to a cookie model where the client and server exchange a cookie. The cookie may be sent from a server to a client upon a request for resolution of a domain name. In turn, the grouping module on the client may store and populate the cookie with group information. Alternatively, a server may send a series of cookies to a client and the client-side grouping module may consolidate the cookies into a group cookie. Upon a request for resolution of a domain name in the group, the client may transmit the group cookie to the server. In turn, the grouping module on the server checks the change status of the domain name information for members of the group and returns updated information as appropriate.","An exemplary method optionally operates on an application specific basis. For example, a client may desire information for an email application and\/or a messenger application. In such an example, a single request can update domain name information for both applications. In instances where a user coordinates communications using both applications, the user's experience of both applications can be enhanced.","An exemplary method optionally relies on filtering techniques to define domain name groups. For example, a user that access several governmental agencies may use a filter that includes \u201c.gov\u201d as a criterion. As described herein, other filtering techniques (e.g., with prefixes\/suffixes, etc.) may be used. An exemplary method optionally relies on zone information, a SOA record, etc., to define group members.","Various exemplary grouping methods include client-server protocols to communicate information. An exemplary protocol optionally stores information in a packet according to a DNS protocol where a grouping module extracts the information for purposes of grouping domain names or receiving information about domain names in a group. Alternatively, a separate protocol is used where information may be extracted from a DNS packet, cache or file.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 13","FIG. 4"],"b":["1300","420","430","1300"]},"In a very basic configuration, computing device  typically includes at least one processing unit  and system memory . Depending on the exact configuration and type of computing device, system memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. System memory  typically includes an operating system , one or more program modules , and may include program data . The operating system  include a component-based framework  that supports components (including properties and events), objects, inheritance, polymorphism, reflection, and provides an object-oriented component-based application programming interface (API), such as that of the .NET\u2122 Framework marketed by Microsoft Corporation, Redmond, Wash. The device  is of a very basic configuration demarcated by a dashed line . Again, a terminal may have fewer components but will interact with a computing device that may have such a basic configuration.","Computing device  may have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by the computing device . Any such computer storage media may be part of device . The computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. These devices are well know in the art and need not be discussed at length here.","The computing device  may also contain communication connections  that allow the device to communicate with other computing devices , such as over a network. Communication connections  are one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data forms. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":["Non-limiting and non-exhaustive examples are described with reference to the following figures:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
