---
title: Isolating changes in dynamic systems
abstract: A software optimization system isolates an effect of a change in a control variable from effects of ongoing, unknown changes in other variables. The system discards effects due to noise so that effects of interest to a programmer are more easily visible. The software optimization system treats variations in one or more control variables and in the output of the system as signals. The system varies the control variable at a specific frequency unlikely to correlate with uncontrolled variations in external variables. The system uses digital signal processing (DSP) techniques to filter the output, isolating the frequency of the control variable variation. The system then compares the resulting filtered output to the input to determine the approximate effect of the variation in the control variable.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08903747&OS=08903747&RS=08903747
owner: Microsoft Corporation
number: 08903747
owner_city: Redmond
owner_country: US
publication_date: 20090618
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["In computing, optimization is the process of modifying a system to make some aspect of it work more efficiently or use fewer resources. For instance, a programmer may optimize a computer program so that the program executes more rapidly, is capable of operating with less memory or other resources, or draws less power. The system may be a single computer program, a collection of computers, or even an entire network such as the Internet. Although the word \u201coptimization\u201d shares the same root as \u201coptimal,\u201d it is rare for the process of optimization to produce a truly optimal system. The optimized system will typically only be optimal in one application or for one audience. One might reduce the amount of time that a program takes to perform some task at the price of making it consume more memory. In an application where memory space is at a premium, one might deliberately choose a slower algorithm in order to use less memory. Often there is no \u201cone size fits all\u201d design which works well in all cases, so engineers make trade-offs to optimize the attributes of greatest interest. Thus, a programmer may halt the process of optimization before a completely optimal solution has been reached.","Optimization can be automated or performed by programmers. Programmers usually undertake optimizing a whole system because it is too complex for automated optimizers. In this situation, programmers or system administrators explicitly change code so that the overall system performs better. Although manual optimization can produce better efficiency, it is far more expensive than automated optimizations. Programmers sometimes believe they have a clear idea of where the bottleneck is, but intuition is frequently wrong. Optimizing an unimportant piece of code will typically do little to help the overall performance. Programmers use applications called profilers (or performance analyzers) to find the sections of the program that are taking the most resources\u2014the bottleneck. When the bottleneck is localized, optimization usually starts with a rethinking of the algorithm used in the program: more often than not, a particular algorithm can be specifically tailored to a particular problem, yielding better performance than a generic algorithm. In many cases, it is difficult or impossible for a human to optimize a particular system, because he\/she may not know what resources will be available in the environment in which the program will actually run. For example, an Internet application developer does not know how much bandwidth will be available to each machine running the application, and in fact the availability of that particular resource is constantly changing. As another example, take an application with parts that can run in parallel, where the programmer wants to decide how many parts to run in parallel. He cannot optimize this statically, because he does not know at design time what machines the application will run on.","Algorithms that optimize the outputs of dynamic systems typically measure the effect of changes in the inputs that are under the algorithm's control (\u201ccontrol variables\u201d) on the output. The system may have many other inputs which are outside of the algorithm's control, but that have as much or more effect on the output of the system than the control variables. The value of each of these external inputs may not be known, and even if they were known, a programmer may not know how they would be reflected in the output the programmer is trying to optimize. Furthermore, the ability of the algorithm to obtain precise measurements of the system's output is often limited. This results in a \u201cnoisy\u201d view of the output data, making it even more difficult to measure the effect of an input change.","For example, in a dynamic thread pool, a control variable might be the number of threads in the pool (\u201cthread count\u201d), and the output to optimize might be the rate at which work completes on those threads (\u201cthroughput\u201d). A change in the number of threads will have an effect on the throughput, but so will a change in the workload being executed in the pool, a change in resource demands of other processes running on the machine, and so forth. Because these external variables are outside of our control, we cannot hold them constant while we measure the effect of a throughput change.","Another example would be optimizing throughput on a network by finding an optimal packet size. One would like to know how a change in packet size affects the network's throughput, but would have to isolate this from other changes due to external factors such as changes in user access patterns, variations in incoming external traffic, failure of load-balanced redundant systems, and so on. Noise may be introduced into any throughput measurement for similar reasons to the thread pool example.","A software optimization system is described herein that isolates an effect of a change in a control variable from effects of ongoing, unknown changes in other variables. The system discards effects due to noise so that effects of interest to a programmer are more easily visible. The software optimization system treats variations in one or more control variables and in the output of the system as signals. The system varies the control variable at a specific frequency unlikely to correlate with uncontrolled variations in external variables. The system uses digital signal processing (DSP) techniques to filter the output, isolating the frequency (or frequencies) of the control variable variation. The system then compares the resulting filtered output to the input to determine the approximate effect of the variation in the control variable. The system is useful for a wide variety of optimization problems that are becoming more and more common as engineers build more software that is self-optimizing without requiring user intervention. Thus, the software optimization system provides a programmer with information for optimizing software that clarifies the effects of particular changes to input variables based on their effects on output of a dynamic system by excluding effects due to noise.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","A software optimization system is described herein that isolates an effect of a change in a control variable from effects of ongoing, unknown changes in other variables. The system discards effects due to noise so that effects of interest to a programmer are more easily visible. The software optimization system treats variations in one or more control variables and in the output of the system as signals. The system varies the control variable at a specific frequency (or random known frequencies) unlikely to correlate with uncontrolled variations in external variables. For example, the system may vary a thread count of a thread pool once per minute and measure the throughput of the work completed by the thread pool. The system uses digital signal processing (DSP) techniques to filter the output, isolating the frequency (or frequencies) of the control variable variation. For example, the system can apply a frequency filter based on the known frequency at which the thread pool thread count is being varied so that output effects related to the thread pool count are more readily visible. The system then compares the resulting filtered output to the input to determine the approximate effect of the variation in the control variable.","Although such techniques are common in hardware signal processing, these techniques have not been applied to software, and in particular to the problem of measuring the effect of variations in one variable of a multi-variable dynamic system to filter out noise and external influences. As mentioned earlier, this is useful in a wide variety of optimization problems, which are becoming more and more common as engineers build more software that is self-optimizing without requiring user intervention. Thus, the software optimization system provides a programmer with information for optimizing software that clarifies the effects of particular changes to input variables based on their effects on output of a dynamic system by excluding effects due to noise from unrelated variations in the system.","As an example, suppose that a programmer wants to measure the effect on a system's output of changing a control variable from N to N+1. Rather than simply increasing the value of the variable, and measuring the output before and after (which would not isolate the effect of the change from the effects of other changes), the software optimization system may vary the input in a wave pattern, moving back and forth between N and N+1 over time. This creates a square wave in the input. The system may also vary the input in other ways, such as sine waves, triangle waves, or even random motion, so long as the system can construct a digital filter capable of isolating the input pattern in the output. At the same time, the system collects samples of the output. For example, in the case of the thread pool mentioned previously, the system may periodically measure the rate at which work has been completing. The system filters these output samples to find the component of the output signal that corresponds to the input signal. The system can then compare the magnitude of the output signal to that of the input to determine the extent to which the input changes affected the output.","For many problems, it is also helpful to measure the phase of the filtered output signal to compare the phase to that of the input signal. For example, in a thread pool it is sometimes the case that increasing the thread count will increase throughput up to a point beyond which increases in thread count will actually decrease the throughput. If the system looks only at the magnitude of the filtered throughput signal, the system will observe that the magnitude diminishes as thread count increases, until the magnitude reaches a point where it starts increasing again. The phase of the throughput signal may tell a programmer whether the throughput is increasing or decreasing. If variations in throughput are in phase with the variations in thread count, then increasing thread count is increasing throughput. If the signals are out of phase, then increasing thread count is having the opposite effect.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","110","120","130","140","150","160","170"]},"The input variation component  varies a value of an input variable of a dynamic software system to produce an input signal at a known frequency that can be detected in an output signal derived from measurements of an output value over time. For example, the input variation component may receive a variable from a programmer to attempt to automatically optimize by varying the variable's value over a specified range. The input variation component  sets the value of the input variable to various values within the range in a known pattern over time. The known pattern may be that of a square wave, sine wave, or even a random pattern so long as the pattern is saved for use in extracting the results of the input signal on the output signal.","The output measurement component  performs periodic measurement of the output value to determine the output signal. The output measurement component  may use performance counters, application programming interfaces (APIs), and other information sources to gather the output of a particular dynamic system. The measured output will contain both the effects of the varied input, as well as external factors (i.e., noise) not related to the input change.","The output filtering component  filters the output signal using digital signal processing to isolate the input signal and remove unwanted noise. For example, the output filtering component  may use the Goertzel or other algorithms to remove unwanted noise. The Goertzel algorithm is a DSP technique for identifying frequency components of a signal, published by Dr. Gerald Goertzel in 1958. While the general Fast Fourier transform (FFT) algorithm computes evenly across the bandwidth of the incoming signal, the Goertzel algorithm looks at specific, predetermined frequency. This can be useful for the software optimization system, which inputs a known input signal frequency. The system can also use implementations of the FFT algorithm, matched filters, band pass filters, and other types of filtering to isolate any effects of the input signal.","The input comparison component  compares the filtered output signal to the input signal to determine an approximate effect of the variation in the input variable on the output. For example, doubling the input value may quadruple the output value or other similar amplifications or suppressions of magnitude. There may also be a point at which an effect reverses, so that an increased input signal that once increased the magnitude of the output signal begins to decrease the magnitude of the output signal. Because of the ability of the system to highlight movement of the output signal due to changes in the input signal and remove unwanted noise from the output, the system makes it easier for a programmer to detect such turning points and other effects. Accordingly, the programmer can more effectively use such information to appropriately set the value of the input variable in a production system.","The phase detection component  detects shifts in phase between a change in the input signal and the resulting output signal. Some systems may display effects where an input signal has a delayed impact on the output signal. This manifests during analysis as a shift in the phase of the output signal when compared with the input signal. By using DSP techniques, the phase detection component  can determine the magnitude of any phase shift when comparing the input signal to the filtered output signal. A programmer may use the phase shift information to make decisions about an appropriate value for the input variable to produce a desired effect at the output.","The reporting component  displays reports to a user depicting the outcome of various phases of the analysis of the system. For example, the reporting component  may display the input signal, output signal, and filtered output signal as graphs that the user can view to interpret the effect of input signal variation on the output. The reporting component  may include options for configuring the type of information displayed as well as options for exporting report data to a file or other portable storage medium for further analysis.","The user interface component  interacts with the user to display reports and to receive configuration information from the user. The component  may receive information such as a selection of an input variable to vary, a range of values over which to vary the input signal, a type of variation (e.g., square wave, sine wave, and so forth), and other settings that affect the operation of the system . The user interface component  may also display information to the user about the status of the analysis, the present state of the system , and so forth.","The computing device on which the software optimization system is implemented may include a central processing unit, memory, input devices (e.g., keyboard and pointing devices), output devices (e.g., display devices), and storage devices (e.g., disk drives or other non-volatile storage media). The memory and storage devices are computer-readable storage media that may be encoded with computer-executable instructions (e.g., software) that implement or enable the system. In addition, the data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communication link. Various communication links may be used, such as the Internet, a local area network, a wide area network, a point-to-point dial-up connection, a cell phone network, and so on.","Embodiments of the system may be implemented in various operating environments that include personal computers, server computers, handheld or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, digital cameras, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and so on. The computer systems may be cell phones, personal digital assistants, smart phones, personal computers, programmable consumer electronics, digital cameras, and so on.","The system may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, and so on that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIGS. 2 through 8","FIG. 2","FIG. 3","FIG. 4"],"b":["210","310","410","410"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 5","FIG. 6","FIG. 5","FIG. 7"],"b":["510","0","2","520","520","510","610","610","710","720","730"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 8","b":["810","820","810","810"]},"There can be many reasons for periodically varying external influences. For example, a web server may have a slow ramp up time that shows up in a measurement of traffic as a slowly increasing workload. As another example, a thread pool may have work items such that every fourth work item is larger than the others are and thus takes longer to complete, so that a measurement of thread pool throughput shows a sinusoid or other pattern. The software optimization system attempts to vary the input signal at a frequency or pattern that is unlikely to naturally occur. In this way, the system can isolate effects due to external influences from effects due to changes in the input signal to get a measure of the true effect of input changes on the output of a dynamic system.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 9","b":["910","920"]},"Continuing in block , the component samples the output of the dynamic system. Sampling the output determines a current amplitude of the output, and can be used with past sampled values of the output to create a signal that represents the value of the output over time. Continuing in block , the component applies one or more signal processing functions to filter the output and isolate the amplitude due to the input value. For example, the component may apply the Goertzel or FFT algorithm to isolate changes in the output amplitude due to the input value. Continuing in block , the component determines a next midpoint for the input value. For example, the system may execute an optimization function to determine a next control setting based on the past control setting, input amplitude, and measured output amplitude.","Continuing in block , the component determines the next variance for the input value. The input is a wave that includes a midpoint and an amplitude that specifies the variance from the midpoint. The component determines the variance or amplitude based on a past estimate of the measured noise and a desired signal to noise ratio. The component selects an input value that is large enough to overcome any noise in the output signal. Continuing in block , the component determines the time at which to repeat the process and modify the input signal again. For example, the component may determine that it takes a certain amount of time for the input changes to be seen at the output, and may wait that amount of time before modifying the input signal again. Continuing in decision block , if the component receives an indication to end the analysis, then the component completes, else the component continues at block . Continuing in block , the component waits the amount of time determined in block , then loops to block  to select the next input value. After block , these steps conclude.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 10","b":["1010","1020"]},"Continuing in block , the software optimization system filters the output signal using a processing function that filters the output signal based on a frequency component of the input signal. For example, the software optimization system may apply an implementation of a Goertzel, FFT, or other algorithm that isolates frequency components of signals. The software optimization system selects an input signal frequency such that the filtered output will eliminate or reduce the input of extraneous effects on the analysis and clarify effects on the output related to the input signal. Continuing in block , the software optimization system compares the filtered output to the input signal and records the effects of the input signal on the amplitude and phase of the output signal. For example, the system may display a report that overlays the filtered output signal on the input signal and indicates any amplitude and phase differences between the two signals. After block , these steps conclude.","In some embodiments, the software optimization system provides a selectable input signal type. A programmer operating the system may be able to select from sinusoidal, square, triangle, and other wave patterns. In addition, the system may allow the programmer to select a random or feedback-based pattern selected by the system automatically. The use of different input signal patterns may allow the system to overcome various types of external noise and some pattern types may be more appropriate for certain types of input variables. For example, a Boolean or discrete value is difficult to vary sinusoidally, but lends itself nicely to a square wave pattern.","In some embodiments, the software optimization system selects input signal values based on a noise detection function. Detecting noise that affects a dynamic system allows the software optimization system to select values for the input signal that are of sufficient magnitude and appropriate character (e.g., frequency, amount, and so forth) to be distinguished from other components that affect the output signal. The system may determine, through spectrographic or other analysis, the frequency of noise or other external components before varying the input value to select a pattern for the input value that more effectively distinguishes it from any dominant existing noise.","In some embodiments, the software optimization system employs statistical analysis in place of or in addition to DSP techniques to analyze the effects of an input value on the output value. For example, the system may watch for stabilization of an output effect using statistical analysis. The system may also use curve fitting or other techniques to estimate the effect of an input value on the output.","From the foregoing, it will be appreciated that specific embodiments of the software optimization system have been described herein for purposes of illustration, but that various modifications may be made without deviating from the spirit and scope of the invention. For example, although specific algorithms have been used in examples, the system can use a variety of DSP processing functions and\/or statistical techniques for calculating noise, isolating effects of an input signal, dynamically setting the input value, and so forth. Accordingly, the invention is not limited except as by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
