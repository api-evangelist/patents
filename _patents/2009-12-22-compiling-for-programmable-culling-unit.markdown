---
title: Compiling for programmable culling unit
abstract: During compilation, the interval bounds for a programmable culling unit are calculated if possible. For each variable, interval bounds are calculated during the compilation, and the bounds together with other metadata are used to generate an optimized culling program. If not possible, then an assumption may be made and the assumption used to compile the code. If the assumption proves to be invalid, a new assumption could be made and the code may be recompiled in some embodiments.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09038034&OS=09038034&RS=09038034
owner: Intel Corporation
number: 09038034
owner_city: Santa Clara
owner_country: US
publication_date: 20091222
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["The present invention generally relates to digitally represented graphics and more particularly to improving the performance of generating digitally represented graphics.","In the 1980's and 1990's, display adapters for computers and game consoles appeared with graphics accelerators, offloading the Central Processing Unit (CPU) in graphics generation. Initially, the display adapters offered acceleration of 2D graphics, but eventually they also included support for accelerated 3D graphics. Modern display adapters use a processing unit often named a graphics processing unit (GPU).","Due to the complexity of 3D graphics, GPU's use a significant amount of their processing power to perform calculations related to 3D graphics. There are always new applications and games requiring higher frame rates (rendered screen images per second), higher resolutions and higher image quality, resulting in requirements that each screen image should be rendered in as short a time as possible. In other words, it is always important to increase performance.","Performance may be increased by increasing the processing power of the GPU's by enabling higher clock speeds, pipelining, or exploiting parallel computations. However, this often generates more heat, resulting in more power consumption and higher fan noise for cooling the GPU. Moreover, there are limits to the clock speeds of each GPU.","Referring to , a display adapter  may include a polygon setup block  that is responsible for setting up polygons as instructed by a connected central processing unit (CPU) , shown in . Although any polygon can be used, triangles are commonly used. For each polygon, a tile rasterizer  divides the polygon to be rendered into one or more tiles, where each tile is at least partly overlapped by the polygon. In general, a tile is a group of fragments. In one embodiment, a tile is a two-dimensional rectangle containing a number of fragments. Each of these fragments corresponds to a pixel and contains all data required to render the pixel and to test whether the pixel should be rendered on the screen. A common size of a tile is 8 by 8 fragments, although any tile size is within the scope of the invention.","A hierarchical depth culling block  performs hierarchical depth culling, which is culling based on depth buffering. Here, a conservative test may be performed to prove whether that tile is covered by the contents in the depth buffer. In other words, the test determines if there is another rendered object fully covering the polygon in the tile, from the viewer's perspective. If that is the case, the entire tile can be culled, i.e. singled out for less processing, e.g. skipped. This then may result in performance gains in some embodiments. The hierarchical depth culling may be performed either before or after the culling of a programmable culling unit . This unit may be a fixed function, which means that it does not execute a replaceable program in one embodiment.","In the programmable culling unit , culling is performed according to a replaceable culling program , also known as a replaceable culling module. The details of this culling program  and the effects are explained in more detail in conjunction with below.","In a fragment rasterizer , the tile processed by the programmable culling unit  is broken down into fragments, overlapping the polygon. Each of these fragments corresponds to a pixel and contains data to render the pixel and to test whether the pixel should be rendered on the screen. The fragment data may include raster position, depth, color, texture coordinates, stencil, alpha (used for blending), etc. For every pixel there may exist a plurality of fragment samples.","In the fragment program unit , the fragments output from the fragment rasterizer are processed using a fragment program . The purpose of this unit is to perform tasks such as combining previously evaluated color with textures, as well as to add effects such as fog, as well as to, when possible, identify fragments that do not need to be rendered, i.e. fragment culling.","A texture unit  is used for texture lookups, for example using one-dimensional, two-dimensional, three-dimensional, four-dimensional and cube map textures, and provides these to the programmable culling unit  and the fragment program unit .","The blend\/depth\/alpha unit  uses the fragments provided from the fragment program unit  to perform depth testing, alpha testing, and blending before the fragments are written to target buffers.","A combined program or compiler program , shown in , can be used to automatically generate a culling program  for use in the programmable culling unit  and a fragment program  for use in the fragment program unit . Optionally, a programmer can write individual culling and fragment programs , .","As an example, consider the pseudo code segment (1) of a combined program , originally written for use as a fragment program:\n\n3\n\n0\n\n201\n\nout.col,\u2003\u2003(1)\n","This program performs basic diffuse lighting by computing the dot product between the light (I) and normal (n) vectors into a result (d) using the DP3 instruction. The n and I vectors varies per fragment. The KIL instruction terminates all fragments where the surface normal does not face the light, indicated by d being less than 0. The TEX2D instruction performs a lookup of a two dimensional texture into c. Finally, the result (d) is multiplied by a diffuse material coefficient (c).","The KIL instruction is an opportunity for culling a whole tile of fragments. But in order to do so, it should be conservatively proven that the condition for the KIL instruction is fulfilled for the whole tile. In this example, it must also be possible to conservatively evaluate the DP3 instruction, since the KIL instruction depends on the result of that instruction. Furthermore, it must be possible to find conservative bounds of the input (the vectors for the normal n and light I in this case) for a whole tile, since the DP3 instruction in turn depends on these values.","In order to implement this chain of conservative evaluations, the programmable culling unit is based on the same instruction set as the fragment program unit. However, instead of floating-point variables as source and destination registers to an instruction, as is typical when processing fragments, intervals are used and the instruction is implemented using principles of interval arithmetic. As a simple example, consider a standard ADD instruction:\n\nADD \u2003\u2003(2)\n\nFor the corresponding programmable culling unit interval instruction, the operands are replaced by intervals, \u00e2,{circumflex over (b)},\u0109 where an interval, e.g. \u00e2, is defined as:\n\n\u2003\u2003(3)\n\nThe programmable culling unit ADD instruction is then:\n\nADD \u2003\u2003(4)\n\nwhere the interval addition operation is implemented as:\n\n\u2003\u2003(5)\n","As can be seen, the result of the interval addition contains all possible results of \u201cnormal\u201d additions, or more formally, it holds that a+b\u03b5\u00e2+{circumflex over (b)} given that a\u03b5 \u00e2 and b\u03b5{circumflex over (b)}. It is therefore conservatively correct. In similar fashion, the behavior of every instruction in the fragment program instruction set is redefined.","In addition to using interval instructions, the input may also be defined as intervals. Therefore, it must be possible to compute conservative bounds for quantities interpolated over an entire tile of fragments. It is to be noted that although interval arithmetic is used herein, any suitable arithmetic representing the whole tile can be used. For example, affine arithmetic or Taylor arithmetic can equally well be used within the scope of the present invention.","With the reasoning above, the culling program  can be automatically derived from the combined program (1). The derived culling program is:\n\n3\n\n0\u2003\u2003(6)\n","Furthermore, here the fragment program  is derived from the combined program (1), to be identical to the combined program . The fragment program is:\n\n3\n\n0\n\n201\n\nout.col,\u2003\u2003(7)\n","For an entire tile of fragments, assume that it is determined that the input interval  of its normals  is {circumflex over (n)}=([\u2212\u221a{square root over (3)}\/2,\u22121\/2],[1\/2,\u221a{square root over (3)}\/2]), and the interval  for its light vector  is \u00ce=([1\/\u221a{square root over (2)},1],[\u22121\/\u221a{square root over (2)},0]), as illustrated in . The z-coordinates are assumed to be zero, which simplifies this example. The dot product between these interval representations results in {circumflex over (d)}={circumflex over (n)}\u00b7\u00ce=[\u2212(\u221a{square root over (6)}+\u221a{square root over (3)})\/\u221a{square root over (8)},\u22121\/\u221a{square root over (8])}. It can thus be concluded that {circumflex over (d)} can be at most be =\u22121\/\u221a{square root over (8)}. Since this value is strictly less than zero, in the culling program explained above with reference to , this whole tile can be culled without executing the fragment program for every fragment, as will be explained in some further detail with reference to below. This is a source of a performance gain in some embodiments of the present invention.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 4","FIG. 1"],"i":"a ","b":["100","440","452"]},"In this embodiment, when the culling program requests input values, the process continues to provide input values to culling program step . The input values are values relating to a characteristic representing all fragments in the tile in some manner. For example, input values could be normals, position coordinates, light vectors, colors, texture coordinates, etc. The requested input values are calculated, in this embodiment, using interval arithmetic. In other words, the input values are only calculated when they are needed, according to a \u2018pull\u2019 mechanism, in contrast to the \u2018push\u2019 mechanism explained with reference to . The result of the culling program is whether the currently processed tile should be culled or not. This can be determined strictly, whereby the tile is culled only if the current polygon makes no contribution to the finally rendered image, in the region of the tile. Alternatively, lossy culling can be performed, whereby the tile is culled if a contribution of the current polygon to the finally rendered image falls below a certain threshold value, in the region of the tile.","When the culling program has finished processing, the process continues to a conditional culling condition true step . In this step, it is determined whether the culling should be performed for the currently processed tile or not according to the output of the culling program. If culling is to be performed, the process continues to an execute instruction set A step . Otherwise, the process continues to an execute instruction set B step . In one embodiment, if the culling condition is false, the tile is broken into several smaller tiles and the process returns to the select tile to process step . This can be repeated successively for smaller and smaller tiles, implementing a hierarchical, multilevel culling process.","The culling program may also output results other than a culling condition. These results may be sent down the graphics pipeline for further processing. An example of such an embodiment would comprise reversing the order of the hierarchical depth culling unit  () and the programmable culling unit  (). The programmable culling unit computes a bounds or interval of the depth values in a tile, and this interval is sent to the hierarchical depth culling unit. The hierarchical depth culling unit then performs culling based on depth values that are computed by a program.","In the execute instruction set A step , an instruction set A is performed for a subset of the tile, typically fragments. The fragments typically collectively cover all pixels of the tile, that overlaps the triangle being processed.","In the execute instruction set B step , an instruction set B is performed for a subset of the tile, typically fragments. This is typically a conventional processing of rendering of the fragments after the tile stage.","The instruction set A is typically less demanding than the instruction set B, resulting in a reduced number of instructions processed for the tile when the culling condition is determined to be true, resulting in increased performance. In one embodiment, the instruction set A is empty, leading to a considerable reduction in processing, i.e. increased performance. The flow continues to integrate until there are no more tiles at step .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"i":["b ","a","a. "],"b":["440","452","456","458","460","462"]},"However, the provide input values to culling program step is processed here before the culling program is executed. In this step, all relevant input values are calculated, in this embodiment using interval arithmetic, and provided so that the culling program can access these values. This implements a \u2018push\u2019 mechanism for the input value calculation.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5","FIG. 1","FIG. 1"],"b":["583","100","570","570","571","500","100","500","576","570","573","574","581","570","582","577","570","578","579","580"]},"It is to be noted that although a general purpose computer is described above to embody the invention, the invention can equally well be embodied in any environment where digital graphics, and in particular 3D graphics, is utilized, e.g. game consoles, mobile phones, mobile Internet devices (MIDs), MP3 players, etc. Any computer architecture may be used.","Input values may be calculated using interval arithmetic, in one implementation of the instruction set as described above. A culling program can then be executed for a whole tile of fragments. However, in order to do so, bounding intervals for the varying (or interpolated) inputs also need to be computed.","Initially, the value of the varying attribute is computed in all four corners of the tile using interpolation. Then the bounding interval of these four values is computed, and it is called \u00e2=[, ]. The bounding interval of the varying attribute at the triangle vertices are also computed, and called \u00e2=[, ]. The final bounding interval of the varying attribute over the tile can be computed as \u00e2=[max(,), min( , )]. There are other ways to compute the intervals, e.g. by considering all fragments overlapping a tile.","Finally, an exceptional case may be dealt with, which is illustrated in . Here, perspective correct interpolation over a triangle  is illustrated in form of a checkerboard texture . As can be seen, the texture is mirrored about a projection line , which is the line where the horizon of the triangle  would project if it was infinitely large. This mirroring effect is a form of back-projection caused by the division used in perspective correct interpolation. Now, assume that the bounding interval of some varying attribute is desired to be computed over a tile , which overlaps the projection line.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 6","i":["b ","a","d "],"b":["690","691","688","692","690"]},"This exceptional case may be dealt with by setting \u00e2to \u00e2as the bounding interval for tiles overlapping the projection line. In this embodiment, only tiles actually overlapping the triangle are traversed, and perspectively correct barycentric coordinates are used to do the interpolation.","The problematic tiles can easily be detected when computing perspectively correct barycentric coordinates for the corners of a tile. The perspectively correct barycentric coordinates are expressed as a rational function, and if the denominator is less than zero for any of the tile corners then the tile crosses the projection line.","N-dimensional texture lookups are performed as follows. The general idea is to provide a fast and efficient means of computing the bounding interval of the texture data over a given area. The remainder of this example will only consider two-dimensional textures, but generalization is straightforward.","We initially compute two mipmap pyramids for each texture that is subject to interval-based texture lookup. As shown in and , each element, e.g. element  in a mipmap is computed as the component-wise minimum, as shown in , or maximum, as shown in , value of the four corresponding texels, e.g. elements -, immediately under it in the pyramid. The final result can be seen as a mipmap pyramid of bounding intervals. This type of pre-computation can easily be handled by the driver, similarly to how standard mipmaps are auto-generated.","When performing a texture lookup, we wish to compute the bounding interval of the texture data over an axis-aligned bounding box, which is the texture coordinate interval. First, we compute an appropriate mipmap level as:\n\n|log(max( \u2212, ,\u2212))|\n\nwhere {circumflex over (t)}=({circumflex over (t)},{circumflex over (t)})t is a two-dimensional interval of the unnormalized integer texture coordinates (i.e., they include the dimensions of the texture). These are appropriately rounded such that  is floored and  is ceiled for i\u03b5{x,y}.\n","When transformed to this mipmap level, t will never be more than one texel wide in any dimension, and will be at least \u00bd texels wide in the widest dimension. Thus, we get four possible cases of texture coordinate intervals as illustrated in -. We always sample a square of 2\u00d72 texels from the texels  with the lower left corner at the texel of (,), in the access scheme used for normal linear interpolation. The result of the texture lookup is then computed as the bounds of the colors of the texels that actually overlap the texture coordinate interval. That is, we discard the texels shaded indicated by reference  -. Since the mipmap transformed t will be rounded to the nearest integer coordinates, this overlap test can be implemented very efficiently by comparing just the final bit. The texture lookup process is essentially as costly as a normal \u201ctrilinearly\u201d filtered texture lookup. The biggest differences is the need to sample from the same level in two different mipmap pyramids rather than two adjacent levels, and that we compute the final result as a bounds rather than using linear interpolation. This strategy natively supports different kinds of wrapping modes, such as clamp, repeat and mirrored repeat. The appropriate wrapping mode can simply be applied to the interval coordinates, after mipmap level computation, to get the expected result.","Only the mipmap levels that are actually used in the culling program may be created, in one embodiment. This optimization is particularly important for algorithms taking place in screen space such as, for instance, order independent transparency. In this case we know beforehand that we only need the texture at its base level, and the mipmap level that corresponds to a tile on the screen. The minimum and maximum depth values can for instance be found in the hierarchical depth culling unit. It is also possible (but less likely) that the min and max colors are already computed for compression purposes, otherwise we need to compute them.","The min\/max mipmap pyramid is computed for the cube map, using the same approach as for two-dimensional textures. For the edges, the mipmap color is computed as the min or max of four texels on both sides of the edge, and for the corners the mipmap color is coupled as the min or max of four texels on all three sides emanating from that corner. Texels on opposite sides of edges will therefore share the same colors in higher mipmap levels. Similarly, the three texels in a corner will also share a common color.","This mipmap pyramid may be used to do conservative cube map lookups with accesses to only one side of the cube. First, compute the interval based equivalent of the major axis. Given a texture coordinate interval {circumflex over (t)}=({circumflex over (t)},{circumflex over (t)},{circumflex over (t)}), define the major axis, i, as the axis where  and  have the same sign, and where min(||,| |) is maximized. If  and  have different signs over all axes, then a major axis cannot be found. However, this can only happen if the origin lies within the texture coordinate interval. In this case, the texture coordinate interval will project onto the entire cube map. This may be handled by choosing the highest mipmap level, and sample an arbitrary cube map face.","Once a major axis is found, the texture coordinate interval may be projected on the corresponding side of the cube map. The projection is done by projecting the bounds of each of the two remaining axes separately. Let us consider an example where x is the major axis and y is the axis for which we want to project the bounds. There are then six possible cases of texture coordinate intervals (note that no interval may cross the y-axis since the x-axis would not be a major axis in that case), and the extreme points we have to project to compute the bounds. It is sufficient to look at the signs of the texture coordinate interval, and through a table lookup get the extreme points.","The extreme points are projected for the remaining two axes to form a two-dimensional projected coordinate interval. This interval is used to compute a mipmap level and perform a two-dimensional texture lookup, identically to the method described in for the two-dimensional case above.","For improved performance, it is desirable to reduce the amount of work done in the cull shader and to increase the tightness of the computed bounds. In general, metadata about the interval instructions is used to generate optimized scalar instructions. The metadata can be interval bounds or even information about which side of the bounds is required, or higher level information about what operation is to be performed. For example, information about whether a square is to be done, instead of multiplication, can be an example of the type of metadata that can be used to generate optimized scalar instructions. Then the hounds may be tracked through the code at compile time to compute bounds for each variable and for each instruction. These bounds make it possible to make the code more efficient.","Thus, the culling program  is received and is subjected to static input bounds analysis at block  in . The bounds may be based on application programming interface standards in one embodiment.","An example of such standards includes expected values for certain kinds of inputs. The bounds may also be based on constants, variable types, and data types. For example, variable types may be an unsigned integer that is positive. A data type may be a value that must be in the range between zero and one. These bounds are known to be correct. If such bounds are non-existent, then the bound may be plus and minus infinity.","These bounds may be used as inputs to evaluate the cull program in interval fashion at compile time to determine possible bounds for each variable. Known mathematical results may be applied in order to narrow compile time bounds. Examples include the fact that absolute values are always positive, sines and cosines are in the range between \u22121 and 1, clamp operations limit the range of possible values. Thus, the code can be executed at compile time within interval ranges. The result is a range of valid values for each instruction in the culling program.","The gathered intervals may then be used at a low level to generate more efficient interval arithmic evaluation code, which may improve run time performance in some embodiments. For example, knowing that the two operands in an interval multiplication are non-negative reduces the cost of run time interval evaluation from ten instructions to only two. Thus, this compile time analysis can reduce the length of the culling program and improve performance. Static input bounds analysis provides an interval intermediate representation, together with input bounds.","Even if non-infinite bounds cannot be determined and the default bounds of plus and minus infinity are used, there may still be a benefit in tracking the \u201cinfinite\u201d bounds. In practice, a culling program has one or more inputs. For all or some of these inputs, stricter bounds may be determined in some cases. For example, consider y=sin(x), where x is an input to the culling program. If no bound other than x between plus and minus infinity is used, it may still be useful to track this bound through the code. For example, the output of sin(x) is always bounded by the range [\u22121,1]. This range may then be tracked to simplify other operations in the program.","The dynamic input bounds assumptions in block  may be used in some embodiments. They involve the use of assumptions based on domain specific knowledge to improve performance. For example, a domain specific knowledge may include the fact that a texture is usually in the range of zero to one. Dynamic assumptions can be made to further refine static bounds.","As an example, the result of a texture read may generally be entirely unknown at compile time. However, it is reasonable to make the assumption that the value will be within the zero and one range, as most textures are stored as unsigned normalized values. The shader compiler can automatically make that reasonable assumption based on the input format and use this information to generate faster culling programs in some embodiments. The faster code path will be valid so long as the inputs actually do fall within the assumed range.","However, if a floating point surface, for example, is bound to the shader, the zero to one range assumption may be violated. At run time, the shader execution mechanism will be aware of the erroneous assumption and may request a corrected culling shader. This may, if desired, be done asynchronously by skipping culling for that particular shader until the corrected version is available. Degradation can be done in several steps. In the case of textures, most images contain only non-negative values, even if the representations, such as floating point, can represent negative values. Violating the zero to one range can mean that the data is at least bounded by zero and infinity, which stills gives performance advantages over entirely unknown data.","The output from the dynamic input bounds assumption is, again, the interval intermediate representation plus the input bounds as supplemented, in some embodiments, by the dynamic input bounds assumptions.","In block , the bounds are tracked through the code at compile time to compute bounds for each variable. These bounds make it possible to generate more efficient code. The code is executed at compile time and each instruction is analyzed to determine its range of possible inputs and outputs. This process starts at the beginning with the static dynamic input bounds and propagates forward.","The output of block  is the interval intermediate representation and bounds for each instruction. In block , an optimization may be done for single sided bounds in some embodiments. In some cases, only the upper or lower bound of a result is needed. Instructions may be tagged to generate an output as single sided. This single sided tag may propagate information backwards to the extent possible.","The output of block  is the interval intermediate representation, the bounds, and the side information, either low, up, or both low and up.","Then, in block , the interval intermediate representation is converted to an optimized scalar intermediate representation. The bounds information and the side information may be used to replace each interval instruction with an optimized sequence of scalar instructions. Thus, instead of naively replacing each internal instruction by a general sequence of scalar instructions, bounds may be used to confine the extent supported by the scalar instructions. For example, if the input ranges of an interval multiplication are known to be strictly non-negative, the instruction may be replaced by a shorter sequence of scalar instructions, which has been optimized to only work on non-negative numbers.","Finally, in block , the scalar intermediate representation is used for standard compiler optimizations, such as dead code elimination, vectorization, and code generation. The executable code is output after block , and the flow transitions from compile time to run time.","At run time, the dynamic assumptions may be reassessed, as indicated in block . If the assumptions are valid, as determined in , the cull program may be run, as indicated in block .","Otherwise, various alternatives may be considered. For example, it may be decided that no culling can be done. Alternatively, a new cull program may be requested with more general assumptions. As still another alternative, a precompiled cull program with more general assumptions may be run, all as indicated in block . If several precompiled programs exist, the one with the most restrictive input assumptions that satisfy the current assumptions may be chosen.","In some embodiments, other bounded arithmetics, such as affine arithmetic or Taylor arithmetic, may be used. In these cases, the input\/output bounds may be replaced by higher-dimensional representations suitable for the chosen arithmetic.","In some embodiments, the sequence depicted in  may be implemented in software. In such case, the sequence may be embodied in instructions stored on a computer readable medium. That medium may be, for example, a semiconductor, optical, or magnetic storage. The instructions are executed by a computer including a controller or processor. For example, the controller and processor may be the CPU  in  or part of the display adapter . The storage that stores the instructions may, for example, be the memory  or storage  or .","The graphics processing techniques described herein may be implemented in various hardware architectures. For example, graphics functionality may be integrated within a chipset. Alternatively, a discrete graphics processor may be used. As still another embodiment, the graphics functions may be implemented by a general purpose processor, including a multicore processor. References throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d mean that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one implementation encompassed within the present invention. Thus, appearances of the phrase \u201cone embodiment\u201d or \u201cin an embodiment\u201d are not necessarily referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be instituted in other suitable forms other than the particular embodiment illustrated and all such forms may be encompassed within the claims of the present application.","While the present invention has been described with respect to a limited number of embodiments, those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of this present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIGS. 4","FIG. 1"],"i":["a ","b "],"b":"4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 6","FIG. 1"],"i":"a "},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 6","FIG. 6"],"i":["b ","a. "]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIGS. 7","FIG. 1"],"i":["a ","b "],"b":"7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIGS. 8","FIG. 1"],"i":["a","d "]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
