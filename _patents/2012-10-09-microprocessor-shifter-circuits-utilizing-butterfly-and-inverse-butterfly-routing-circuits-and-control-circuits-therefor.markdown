---
title: Microprocessor Shifter Circuits Utilizing Butterfly and Inverse Butterfly Routing Circuits, and Control Circuits Therefor
abstract: Microprocessor shifter circuits utilizing butterfly and inverse butterfly circuits, and control circuits therefor, are provided. The same shifter circuits can also perform complex bit manipulations at high speeds, including butterfly and inverse butterfly operations, parallel extract and deposit operations, group operations, mix operations, permutation operations, as well as instructions executed by existing microprocessors, including shift right, shift left, rotate, extract, deposit and multimedia mix operations. The shifter circuits can be provided in various combinations to provide microprocessor functional units which perform a plurality of bit manipulation operations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134953&OS=09134953&RS=09134953
owner: Teleputers, LLC
number: 09134953
owner_city: Princeton
owner_country: US
publication_date: 20121009
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","STATEMENT OF GOVERNMENT INTERESTS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation application of and claims the benefit of priority to U.S. patent application Ser. No. 12\/126,616 filed May 23, 2008, now U.S. Pat. No. 8,285,766, which claims the priority of U.S. Provisional Application Ser. No. 60\/931,493 filed May 23, 2007, the entire disclosures of which are expressly incorporated herein by reference.","The present invention was made with government support under Department of Defense Grant No. H98230-04-C-0496. Accordingly, the Government has certain rights to the present invention.","1. Field of the Invention","The present invention relates to circuitry for computer systems, and more specifically, to microprocessor shifter circuits utilizing butterfly and inverse butterfly circuits, and control circuits therefor.","2. Related Art","Bit manipulation operations are important features of modern microprocessors. Unfortunately, bit manipulation operations carried out by existing microprocessors are limited in terms of flexibility and ease of implementation at the hardware level. For example, bit manipulation operations performed by existing microprocessors are often limited to shift and rotate operations. Since a microprocessor is typically optimized around the processing of words (i.e., fixed-length groups of binary bits of information), it is not surprising that bit-level operations are not well-supported by current word-oriented microprocessors. Simple \u201cbit-parallel\u201d Boolean operations such as AND, OR, XOR, and NOT are usually supported as the \u201clogical\u201d operations of the Arithmetic-Logic Unit (ALU), the most fundamental functional unit of a microprocessor. However, only very simple non-bit-parallel operations are supported, such as shift and rotate operations, in which all bits of an operand move by the same amount. These operations are usually supported by separate shifter functional units.","A few microprocessor Instruction Set Architectures (ISAs) have more advanced bit operations. However, these operations are implemented by complex shifter functional unit circuitry, which appreciably adds to the size and complexity of the microprocessor. Examples of such operations include subword extract and deposit operations (e.g., \u201cpextrw\u201d and \u201cpinsrw\u201d operations in the INTEL IA-32 ISA), field extract and deposit operations (e.g., \u201cextr\u201d and \u201cdep\u201d operations in HEWLETT PACKARD PA-RISC or INTEL IA-64 ISAs), or rotate and mask operations (e.g., \u201crldimi\u201d in POWERPC ISA). These can be viewed as variants of the basic shift or rotate operation operations, with certain bits masked out and set to zeros, or sign bits replicated, or bits from a second operand merged into the result. Additionally, some instruction sets have multimedia permute operations that rearrange the subwords packed into one or more registers (e.g., \u201cmix\u201d operation in HEWLETT PACKARD PA-RISC 2.0 and INTEL IA-64 architectures).","There are also many emerging applications, such as cryptography, imaging, and bioinformatics, where even more advanced bit manipulation operations are needed. While circuitry to achieve these operations can be built by assembling simple logical and shift operation circuits, or by implementing same in firmware, such approaches often result in very large circuits or slow execution speeds. Applications using these advanced bit manipulation operations would thus be significantly sped-up if the processor were able to support more powerful bit manipulation instructions. Such operations include arbitrary bit permutations, bit gather operations (performing multiple bit-field extract operations in parallel), and bit scatter operations (performing multiple bit-field deposit operations in parallel).","Accordingly, what would be desirable, but has not yet been provided, are shifter circuits utilizing butterfly and inverse butterfly circuits, and control circuits therefor, which address the foregoing shortcomings of existing microprocessors.","The present invention relates to microprocessor shifter circuits utilizing butterfly and inverse butterfly circuits, and control circuits therefor. The shifter circuits can be implemented in existing microprocessors, and allow for complex bit manipulations to be performed by such microprocessors at high speeds. The shifter circuits can perform butterfly and inverse butterfly operations, parallel extract and parallel deposit operations, group operations, mix operations, bit permutation operations, as well as instructions executed by existing microprocessors. The shifter circuits can replace existing shifter circuits in microprocessors, so as to provide new ways for conducting existing shift, rotate, extract, deposit, and mix operations, as well as more advanced bit manipulation instructions. The shifter circuits can be implemented with a reduced amount of circuitry, thus conserving chip space. User applications relating to steganography, binary image morphology, transfer coding, bioinformatics, imaging, and integer compression techniques, among other applications, can be implemented using the shifter circuits of the present invention. The shifter circuits can be provided in various combinations to provide microprocessor functional units which perform a plurality of bit manipulation processes.","The present invention relates to microprocessor shifter circuits utilizing butterfly and inverse butterfly circuits, and control circuits therefore, for performing complex bit manipulations at high speeds. The shifter circuits can perform butterfly and inverse butterfly operations, parallel extract and parallel deposit operations, group operations, mix operations, permutation operations, as well as instructions executed by existing microprocessors. The shifter circuits can be provided in various combinations to provide microprocessor functional units which perform a plurality of bit manipulation processes.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 1","b":["10","10","12","14","16","18","20","10","12","20","14","18","14","14","14","16","16","16","18","18","10"],"i":["a","h","a","h","a","h"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 2","b":["22","14","18","18","12","14","20","16","18","14","22"]},"The shifter circuits  and  could be implemented in a microprocessor individually, or they could be connected to each other to form a Benes network, which is a general permutation network. The butterfly configuration of the circuit  is referred to herein as \u201cbfly,\u201d and the inverse butterfly configuration of the circuit  is referred to herein as \u201cibfly.\u201d A single execution of bfly followed by ibfly (or vice versa) can achieve any of the n! permutations of n bits in, at most, 2 instruction cycles of a microprocessor.","The circuits shown in  represent n-bit circuits of lg(n) stages, wherein each stage comprises n\/2 2-input switches (n being any desired bit width, generally a power of 2). Each of these circuits takes at most one processor cycle, since they are less complicated than an ALU of the same width (a processor cycle is assumed to be normalized to the latency of an ALU). Further, as discussed in greater detail below, each switch is composed of two 2:1 multiplexers, totaling n\u00d7lg(n) multiplexers for each circuit, which results in small circuit area.","Each of the circuit stages - of  has n\/2 switches, with a pair of inputs going into each switch and a pair of outputs coming out. For each switch, the inputs either pass through to the outputs, or they are swapped, as shown in  described below. In the ith stage (i starting from 1), the paired bits are n\/2positions apart for the butterfly circuit shown in , and 2positions apart for the inverse butterfly circuit shown in . A switch either passes through or swaps its inputs based on the value of a control bit. Thus, the operation requires n\/2\u00d7lg(n) control bits. For n=64, four 64-bit registers are required to hold the 64 data bits and the 32\u00d76 control bits.","An embodiment of the present invention provides an architecture that has only 2 source operands per instruction, and which utilizes 3 Application Registers (ar.b, ar.b, ar.b) associated with the functional unit to supply the control bits during the execution of these instructions. Application Registers are registers which are already available in some Instruction Set Architectures (also abbreviated ISAs), such as the INTEL IA-64 ISA. The control bits are determined either statically by a compiler, or dynamically by software. Other permutation primitives like \u201cgrp,\u201d discussed below, do not require Application Registers. An arbitrary permutation of the n bits within a register can be performed by a sequence of at most lg(n) grp instructions, or by a sequence of at most 2 instructions using bfly and ibfly instructions. The latter (bfly and ibfly) achieve arbitrary n-bit permutations in O(1) cycles, rather than O(lg(n)) cycles.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3","FIGS. 1-2","FIG. 2"],"b":["24","26","24","14","14","24","24","24","24"],"i":["a ","e "],"sub":["1 ","2","1 ","2","1","1","2","2","2","1","1","2"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 4","FIG. 3"],"b":["26","26","28","30","32","28","30","26"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 5","FIG. 2","FIGS. 3-4"],"b":["22","14","18","14","18"],"sub":["0","2 ","0","1 ","2 "]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 6","FIGS. 1-2","FIGS. 1-2","FIGS. 1-2","FIGS. 1-2","FIGS. 1-2","FIG. 6"],"b":["40","12","20","20","42","12","20","42"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"sub":["2 ","3"],"b":["44","46","12"],"sup":["0","1","2","3","4","5"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 9","FIG. 9","FIG. 9"],"b":["48","50","48","50"]},"The present invention can support a number of bit manipulation operations, which could be implemented as instructions which are added to the existing instruction set of a microprocessor. These instructions are summarized in Table 1 below:",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Instruction","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["rotr r= r, shamt","Right rotate of r. The rotate amount is an immediate in the opcode (shamt)."]},{"entry":["rotr r= r, r","Right rotate of r. The rotate amount is specified using a second source register r."]},{"entry":["rotl r= r, shamt","Left rotate of r. The rotate amount is an immediate in the opcode (shamt)."]},{"entry":["rotl r= r, r","Left rotate of r. The rotate amount is specified using a second source register r."]},{"entry":["shr r= r, shamt","Right shift of rwith vacated positions on the left filled with the sign bit (most"]},{"entry":[{},"significant bit of r). The shift amount is an immediate in the opcode."]},{"entry":["shr r= r, r","Right shift of rwith vacated positions on the left filled with the sign bit (most"]},{"entry":[{},"significant bit of r). The shift amount is specified using a second source register"]},{"entry":[{},"r."]},{"entry":["shr.u r= r, shamt","Right shift of rwith vacated positions on the left zero-filled. The shift amount is"]},{"entry":[{},"an immediate in the opcode."]},{"entry":["shr.u r= r, r","Right shift of rwith vacated positions on the left zero-filled. The shift amount is"]},{"entry":[{},"specified using a second source register r."]},{"entry":["shl r= r, shamt","Left shift of rwith vacated positions on the right zero-filled. The shift amount is"]},{"entry":[{},"an immediate in the opcode."]},{"entry":["shl r= r, r","Left shift of rwith vacated positions on the right zero-filled. The shift amount is"]},{"entry":[{},"specified using a second source register r."]},{"entry":["extr r= r, pos, len","Extraction and right justification of single field from rof length len from"]},{"entry":[{},"position pos. The high order bits are filled with the sign bit of the extracted field."]},{"entry":["extr.u r= r, pos, len","Extraction and right justification of single field from rof length len from"]},{"entry":[{},"position pos. The high order bits are zero-filled."]},{"entry":["dep.z r= r, pos, len","Deposit at position pos of single right justified field from rof length len."]},{"entry":[{},"Remaining bits are zero-filled."]},{"entry":["dep r= r, r, pos, len","Deposit at position pos of single right justified field from rof length len."]},{"entry":[{},"Remaining bits are merged from second source register r."]},{"entry":["mix {r, l} {0, 1, 2, 3, 4, 5} r= r, r","Select right or left subword from a pair of subwords, alternating between source"]},{"entry":[{},"registers rand r. Subword sizes are 2bits, for i = 0, 1, 2, . . ., 5, for a 64-bit"]},{"entry":[{},"processor."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"350pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"---------------------------------------------------------------------------------------------------------------------------------------------------"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bfly r= r, ar.b, ar.b, ar.b","Perform Butterfly permutation of data bits in r"]},{"entry":["ibfly r= r, ar.ib,ar.ib, ar.ib","Perform Inverse Butterfly permutation of data bits in r"]},{"entry":["pex r= r, r, ar.ib, ar.ib,","Parallel extract, static: Data bits in rselected by a pre-decoded mask rare"]},{"entry":["ar.ib","extracted, compressed and right-aligned in the result r"]},{"entry":["pdep r= r, r, ar.b, ar.b, ar.b","Parallel deposit, static: Right-aligned data bits in rare deposited, in order, in"]},{"entry":[{},"result rat bit positions marked with a \u201c1\u201d in the statically-decoded mask r"]},{"entry":["mov ar.x = r, r","Move values from GRs to ARs, to set controls (calculated by software) for pex,"]},{"entry":[{},"pdep, bfly or ibfly"]},{"entry":["pex.v r= r, r","Parallel extract, variable: Data bits in rselected by a dynamically-decoded"]},{"entry":[{},"mask rare extracted, compressed and right-aligned in the result r."]},{"entry":["pdep.v r= r, r","Parallel deposit, variable: Right-aligned data bits in rare deposited, in order, in"]},{"entry":[{},"bit positions marked with a \u201c1\u201d in the dynamically-decoded mask r."]},{"entry":["setib ar.ib, ar.ib, ar.ib= r","Set inverse butterfly circuit controls in associated ARs, using hardware decoder"]},{"entry":[{},"to translate the mask rto inverse butterfly controls."]},{"entry":["setb ar.b, ar.b, ar.b= r","Set butterfly circuit controls in associated ARs, using hardware decoder to"]},{"entry":[{},"translate the mask rto butterfly controls."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The conventional shifter instructions executed by existing microprocessors and listed in the top half of Table 1 above (i.e., above the dotted line in Table 1) can also be implemented by the present invention, since they are all based upon rotation operations. The additional functions implemented by the present invention are listed in the bottom half of Table 1 (i.e., below the dotted line in Table 1). An inverse butterfly circuit can achieve any rotation (cyclic shift) of its input, and can perform the following on its input: right and left shifts, extract operations, deposit operations, and mix operations. These operations can be modeled as a rotate operation with additional logic handling zeroing or sign extension from an arbitrary position, or merging bits from the second source operand (for deposit). Mix operations can be modeled as a rotate of one operand by the subword size and then a merge of subwords alternating between the two operands. Since inverse butterfly circuits only perform permutations without zeroing and without replication, an extra 2:1 multiplexer stage at the end of the shifter circuits of the present invention either selects the rotated bits as-is or other bits which are computed as either zero, or the sign bit (replicated), or the bits of the second source operand, depending on the operation.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 10","b":["52","54"]},"The generation of control bits for the shifter circuits of the present invention is now discussed with reference to . To achieve a right (or left) rotation by s positions, for s=0, 1, 2 . . . n\u22121, using the n-bit wide inverse butterfly circuit with lg(n) stages, the input must be right (or left) rotated by s mod 2within each 2-bit wide inverse butterfly circuit at each stage j. This is because from stage j+1 on, the inverse butterfly circuit can only move bits at granularities larger than 2positions (so the finer movements must have already been performed in the prior stages).","An n-bit inverse butterfly circuit can be viewed as two (lg(n)\u22121)-stage circuits followed by a stage that swaps or passes through paired bits that are n\/2 positions apart. To right_rotate the input {in. . . in} by s positions, the two (lg(n)\u22121)-stage circuits must have right_rotated their half inputs by s\u2032=s mod n\/2 and the input to stage lg(n) must be of the form:\n\n{in. . . inin. . . in\u2225in. . . inin. . . in}\u2003\u2003(1)\n\nwhich is true for s less than or greater than n\/2.\n","As shown at  in , when the rotation amount s is less than n\/2, then the bits that wrapped around in the (lg(n)\u22121)-stage circuits (indicated by hatching in ) must be swapped in the final stage to yield the input right_rotated by s:\n\n{in. . . inin. . . in\u2225in. . . inin. . . in}\u2003\u2003(2)\n\nWhen the rotation amount is greater than or equal to n\/2 then the bits that do not wrap in the (lg(n)\u22121)-stage circuits (solid) must be swapped in the final stage to yield the input right_rotated by s (as illustrated at  in ):\n\n{in. . . inin. . . in\u2225in. . . inin. . . in}\u2003\u2003(3)\n","For example, consider the 8-bit inverse butterfly circuit with right rotation amount s=5, depicted in . As s=5 is greater than n\/2=4, the bits that did not wrap in stage 2 are swapped in stage 3 to yield the final result. As the rotation amount through stage 2, s mod 2=5 mod 4=1, is less than n\/4=2, the bits that did wrap in stage 1 are swapped in stage 2 to yield the input to stage 3. As the rotation amount through stage 1, s mod 2=5 mod 2=1, is equal to than n\/8=1, the bits that did not wrap in the input, i.e., all the bits, are swapped in stage 1 to yield the input to stage 2.","One can mathematically derive recursive equations for the control bits, cb, j=1, 2, . . . lg(n), for achieving rotations on an inverse butterfly datapath. These equations yield the compact circuit shown in  for the rotation control bit generator. The process for generating these equations is now discussed.","From Equations 1-3 and , it is observed that the pattern for the control bits for the final stage, which is referred to as cb, for a rotate of s bits, is:",{"@attributes":{"id":"p-0067","num":"0066"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":"cb","mrow":{"mn":"1","mo":"\u2062","mrow":{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}}},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"msup":{"mn":"1","mi":"s"},"mo":"\u2062","mrow":{"mo":"\uf605","mrow":{"msup":{"mn":"0","mrow":{"mrow":{"mi":"n","mo":"\/","mn":"2"},"mo":"-","mi":"s"}},"mo":","}}}},{"mrow":{"mi":"s","mo":"<","mrow":{"mi":"n","mo":"\/","mn":"2"}}}]},{"mtd":[{"mrow":{"msup":{"mn":"0","mrow":{"mi":"s","mo":"-","mrow":{"mi":"n","mo":"\/","mn":"2"}}},"mo":"\u2062","mrow":{"mo":"\uf605","mrow":{"msup":{"mn":"1","mrow":{"mrow":[{"mi":"n","mo":"\/","mn":"2"},{"mo":["(",")"],"mrow":{"mi":"s","mo":"-","mrow":{"mi":"n","mo":"\/","mn":"2"}}}],"mo":"-"}},"mo":","}}}},{"mrow":{"mi":"s","mo":"\u2265","mrow":{"mi":"n","mo":"\/","mn":"2"}}}]}]}}}},{"mrow":{"mo":["(",")"],"mn":"4"}}]}}}},"br":{},"sup":"k "},{"@attributes":{"id":"p-0068","num":"0067"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":"cb","mrow":{"mn":"1","mo":"\u2062","mrow":{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}}},"mo":"=","mrow":{"mo":"{","mrow":{"mrow":[{"mtable":{"mtr":[{"mtd":[{"mrow":{"msup":{"mn":"1","mrow":{"mi":["s","mod"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":"n","mo":"\/","mn":"2"}}},"mo":"\u2062","mrow":{"mo":"\uf605","mrow":{"msup":{"mn":"0","mrow":{"mrow":[{"mi":"n","mo":"\/","mn":"2"},{"mo":["(",")"],"mrow":{"mi":"smodn","mo":"\/","mn":"2"}}],"mo":"-"}},"mo":","}}}},{"mrow":{"mrow":[{"mi":["s","mod","n"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},{"mi":"n","mo":"\/","mn":"2"}],"mo":"<"}}]},{"mtd":[{"mrow":{"msup":{"mn":"0","mrow":{"mi":"smodn","mo":"\/","mn":"2"}},"mo":"\u2062","mrow":{"mo":"\uf605","mrow":{"msup":{"mn":"1","mrow":{"mrow":[{"mi":"n","mo":"\/","mn":"2"},{"mo":["(",")"],"mrow":{"mi":"smodn","mo":"\/","mn":"2"}}],"mo":"-"}},"mo":","}}}},{"mrow":{"mrow":[{"mi":["s","mod","n"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},{"mi":"n","mo":"\/","mn":"2"}],"mo":"\u2265"}}]}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"msub":{"mi":"cb","mrow":{"mn":"1","mo":"\u2062","mrow":{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}}}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"msup":{"mn":"1","mrow":{"mi":"smodn","mo":"\/","mn":"2"}},"mo":"\u2062","mrow":{"mo":"\uf605","mrow":{"msup":{"mn":"0","mrow":{"mrow":[{"mi":"n","mo":"\/","mn":"2"},{"mo":["(",")"],"mrow":{"mi":"smodn","mo":"\/","mn":"2"}}],"mo":"-"}},"mo":","}}}},{"mrow":{"mrow":[{"mi":["s","mod","n"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},{"mi":"n","mo":"\/","mn":"2"}],"mo":"<"}}]},{"mtd":[{"mrow":{"mo":"~","mrow":{"mo":"(","mrow":{"mrow":{"msup":{"mn":"1","mrow":{"mi":"smodn","mo":"\/","mn":"2"}},"mo":"\u2062","mrow":{"mo":["\uf605",")"],"msup":{"mn":"0","mrow":{"mrow":[{"mi":"n","mo":"\/","mn":"2"},{"mo":["(",")"],"mrow":{"mi":"smodn","mo":"\/","mn":"2"}}],"mo":"-"}}}},"mo":","}}}},{"mrow":{"mrow":[{"mi":["s","mod","n"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},{"mi":"n","mo":"\/","mn":"2"}],"mo":"\u2265"}}]}]}}],"mo":"="}}}},{"mrow":{"mo":["(",")"],"mn":"5"}}]}}}},"br":{}},"Due to the recursive structure of the inverse butterfly circuit, Equation 5 can be generalized by substituting j for lg(n), 2for n and 2for n\/2:",{"@attributes":{"id":"p-0070","num":"0069"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":["cb","j"]},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"msup":{"mn":"1","mrow":{"mi":["s","mod"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":"\u2062","mrow":{"mo":"\uf605","mrow":{"mrow":{"msup":{"mn":"0","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}},"mo":"-","mrow":{"mo":["(",")"],"mrow":{"mi":["s","mod"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}},"mo":","}}}},{"mrow":{"mrow":{"mi":["s","mod"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msup":{"mn":"2","mi":"j"}},"mo":"<","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}]},{"mtd":[{"mrow":{"mo":"~","mrow":{"mo":"(","mrow":{"mrow":{"msup":{"mn":"1","mrow":{"mi":["s","mod"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":"\u2062","mrow":{"mo":["\uf605",")"],"msup":{"mn":"0","mrow":{"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"-","mrow":{"mo":["(",")"],"mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}}}}},"mo":","}}}},{"mrow":{"mrow":{"mi":["s","mod"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msup":{"mn":"2","mi":"j"}},"mo":"\u2265","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}]}]}}}},{"mrow":{"mo":["(",")"],"mn":"6"}}]}}}}},"There are j bits in s mod 2, with the most significant bit denoted s. The condition s mod 2<2is equivalent to sbeing equal to 0 and the condition s mod 2\u22672is equivalent to sbeing equal to 1:",{"@attributes":{"id":"p-0072","num":"0071"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":["cb","j"]},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"msup":{"mn":"1","mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":"\u2062","mrow":{"mo":["\uf605",")"],"msup":{"mn":"0","mrow":{"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"-","mrow":{"mo":["(",")"],"mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}}}}},"mo":","}},{"mrow":{"msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"=","mn":"0"}}]},{"mtd":[{"mrow":{"mo":"~","mrow":{"mo":"(","mrow":{"mrow":{"msup":{"mn":"1","mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":"\u2062","mrow":{"mo":["\uf605",")"],"msup":{"mn":"0","mrow":{"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"-","mrow":{"mo":["(",")"],"mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}}}}},"mo":","}}}},{"mrow":{"msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"=","mn":"1"}}]}]}}}},{"mrow":{"mo":["(",")"],"mn":"7"}}]}}}}},"Equation 7 can be rewritten as the pattern XORed with s:\n\n=(1\u22250)\u2295\u2003\u2003(8)\n","Since s mod k\u2266k\u22121, k\u2212(s mod k)\u22671 and hence the length of the string of zeros in Equation 8 is always \u22671 (k=2). Consequently, the least significant bit of the pattern (prior to XOR with s) is always \u201c0\u201d:\n\n=(1\u22250\u22250)\u2295\n\n=((1\u22250)\u2295)\u2225\u2003\u2003(9)\n","The bit pattern inside the inner parenthesis of the bottom Equation 9 is referred to as f(s, j), a string of 2\u22121 bits with the s mod 2leftmost bits set to \u201c1\u201d and the remaining bits set to \u201c0.\u201d This function is only defined for j\u22672 and returns the empty string for j=1:",{"@attributes":{"id":"p-0076","num":"0075"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"msup":{"mn":"1","mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":"\u2062","mrow":{"mo":"\uf605","mrow":{"msup":{"mn":"0","mrow":{"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":["-","-"],"mn":"1","mrow":{"mo":["(",")"],"mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}}},"mo":","}}}},{"mrow":{"mi":"j","mo":"\u2265","mn":"2"}}]},{"mtd":[{"mrow":{"mo":["{","}"]}},{"mrow":{"mi":"j","mo":"=","mn":"1"}}]}]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"10"}}]},{"mtd":[{"mrow":{"msub":{"mi":["cb","j"]},"mo":"=","mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},"mo":"\u2295","msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}}}},{"mo":"\uf605","msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}}}],"mo":"\u2062"}}},{"mrow":{"mo":["(",")"],"mn":"11"}}]}]}}}},"Note that one can derive f(s, j+1) from f(s, j):\n\n(1)=1\u22250\u2003\u2003(12)\n\nIf bit s=0 then s mod 2=s mod 2:\n",{"@attributes":{"id":"p-0078","num":"0077"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"+","mn":"1"}}}},{"msup":{"mn":"1","mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":"\u2062","mrow":{"mo":"\uf605","msup":{"mn":"0","mrow":{"msup":{"mn":"2","mi":"j"},"mo":["-","-"],"mn":"1","mrow":{"mo":["(",")"],"mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}}}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"msup":[{"mn":"1","mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}},{"mn":"0","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}],"mo":["\u2062","\u2062"],"mrow":{"mo":["\uf605","\uf606"],"msup":{"mn":"0","mrow":{"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":["-","-"],"mn":"1","mrow":{"mo":["(",")"],"mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}}}}}}}}]}},{"mrow":{"mo":["(",")"],"mn":"13"}}]},{"mtd":[{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"+","mn":"1"}}}},{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},"mo":"||","msup":{"mn":"0","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}],"mo":"="}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]}]}}},"br":{},"sub":"j\u22121","sup":["j","j\u22121","j\u22121"]},{"@attributes":{"id":"p-0079","num":"0078"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"+","mn":"1"}}}},{"msup":{"mn":"1","mrow":{"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"+","mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}},"mo":"\u2062","mrow":{"mo":"\uf605","msup":{"mn":"0","mrow":{"msup":{"mn":"2","mi":"j"},"mo":["-","-"],"mn":"1","mrow":{"mo":["(",")"],"mrow":{"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"+","mrow":{"mi":"smod","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}}}}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"msup":[{"mn":"1","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}},{"mn":"0","mrow":{"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":["-","-"],"mn":"1","mrow":{"mo":["(",")"],"mrow":{"mi":["s","mod"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}}}],"mo":["\u2062","\u2062"],"mrow":{"mo":["\uf605","\uf606"],"msup":{"mn":"1","mrow":{"mi":["s","mod"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}}}}}}}]}},{"mrow":{"mo":["(",")"],"mn":"14"}}]},{"mtd":[{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"+","mn":"1"}}}},{"msup":{"mn":"1","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}},"mo":"\u2062","mrow":{"mo":"\uf605","mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}}}}],"mo":"="}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]}]}}},"br":{}},{"@attributes":{"id":"p-0080","num":"0079"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"+","mn":"1"}}}},{"mo":"{","mrow":{"mrow":[{"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},"mo":"||","msup":{"mn":"0","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":","}},{"mrow":{"msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"=","mn":"0"}}]},{"mtd":[{"mrow":{"msup":{"mn":"1","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}},"mo":"\u2062","mrow":{"mo":"\uf605","mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},"mo":","}}}},{"mrow":{"msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"=","mn":"1"}}]}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"+","mn":"1"}}}}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},{"mo":["\uf605","\uf606"],"mn":"0"}],"mo":["\u2062","\u2062"],"msup":{"mn":"0","msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":","}},{"mrow":{"msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"=","mn":"0"}}]},{"mtd":[{"mrow":{"mrow":{"msup":{"mn":"1","mrow":{"msup":{"mn":"2","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"-","mn":"1"}},"mo":["\u2062","\u2062"],"mrow":[{"mo":["\uf605","\uf606"],"mn":"1"},{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}}]},"mo":","}},{"mrow":{"msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"=","mn":"1"}}]}]}}],"mo":"="}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"15"}}]}}}}},"Since f(s, j) is a string of 2\u22121 bits, we can replace the string of ones in the lower Equation 15 by f(s, j) ORed (+) with 0 or 1, respectively. Similarly, we can replace the string of zeros in Equation 15 by f(s, j) ANDed (\u00b7) with 0 or 1, respectively. The value of sdetermines whether 0 or 1 is used:",{"@attributes":{"id":"p-0082","num":"0081"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"+","mn":"1"}}}},{"mo":"{","mrow":{"mrow":[{"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},{"mn":"0","mo":["\u2062","\u2062"],"mrow":[{"mo":["\uf605","\uf606"],"mn":"0"},{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},"mo":"\u00b7","mn":"0"}]}],"mo":"+"},"mo":","}},{"mrow":{"msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"=","mn":"0"}}]},{"mtd":[{"mrow":{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},{"mn":"1","mo":["\u2062","\u2062"],"mrow":[{"mo":["\uf605","\uf606"],"mn":"1"},{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},"mo":"\u00b7","mn":"1"}]}],"mo":"+"},"mo":","}},{"mrow":{"msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"=","mn":"1"}}]}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"+","mn":"1"}}}}},{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},"mo":"+","msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}}}},{"mo":["\uf605","\uf606"],"msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}}},{"mo":["(",")"],"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},"mo":"\u00b7","msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"1"}}}}],"mo":["\u2062","\u2062"]}],"mo":"="}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"16"}}]}}}}},"From Equations 10 and 16 we obtain a simple recursive expression for f(s, j):",{"@attributes":{"id":"p-0084","num":"0083"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["s","j"],"mo":","}}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":"+","msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"2"}}}},{"mo":["\uf605","\uf606"],"msub":{"mi":"S","mrow":{"mi":"j","mo":"-","mn":"2"}}},{"mo":["(",")"],"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"s","mo":",","mrow":{"mi":"j","mo":"-","mn":"1"}}}},"mo":"\u00b7","msub":{"mi":"s","mrow":{"mi":"j","mo":"-","mn":"2"}}}}],"mo":["\u2062","\u2062"]},"mo":","}},{"mrow":{"mi":"j","mo":"\u2265","mn":"2"}}]},{"mtd":[{"mrow":{"mrow":{"mo":["{","}"]},"mo":","}},{"mrow":{"mi":"j","mo":"=","mn":"1"}}]}]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"17"}}]}}}}},"Equation 11 shows a method for getting the j\/2 control bits cbfor the switches in any stage j of the inverse butterfly circuit using a recursive function f(s, j) and a bit sfrom the shift amount s. This can also be seen in , described below. For a rotation, every bit moves by the same amount, namely the shift amount s. Hence, the control bits to subsets of switches, belonging to the smaller inverse butterfly circuits up to that stage, are the same.","Referring to , which show an 8-bit inverse butterfly circuit, the 1-bit control bits, cb, from  goes to four switches in stage 1 that pair bits that are 1 bit apart, which represent four 2-bit inverse butterfly circuits. The 2-bit control bits, cb, for stage 2 go to four switches that pair bits that are 2 bits apart, which together with stage 1 represent two 4-bit inverse butterfly circuits. The 4-bit control bits, cb, for stage 3 go to four switches that pair bits that are 4 bits apart, which together with stages 1 and 2 represent the 8-bit inverse butterfly circuit. Equation 11 and  show how these control bits cbor each stage j can be generated using the recursive function f(s,j) described in Equation 17.","Equation 11 provides that the control bits cbare generated by taking the recursive function f(s,j) and Exclusive-OR it with a bit from the shift amount, s, and concatenate the result with s. Equation 17 then describes how the function f(s,j) can be recursively generated from the same function for the previous stage, f(s, j\u22121). This uses the OR function, +, and the AND function with f(s, j\u22121). The recursive function f(s,j) is derived by f(s, j\u22121) OR with s, concatenated with s, then concatenated with f(s, j\u22121) AND with s. This can also be seen in the hardware realization in , described below. It should be clear that other embodiments of control bit generation for doing rotations on an inverse butterfly circuit, or on a butterfly circuit, are possible.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 13","sub":["1","2","3","4 ","5","j "]},"Discussion of the use of these equations is now provided with the example of , the 8-bit inverse butterfly circuit with right rotation amount s=5 (sss=101). The first stage control bit, cb, replicated for the four 2-bit circuits, is given by Equations 11 and 17 and expressed as follows:\n\n=((5,1)\u2295)\u2225=1.\u2003\u2003(18)\n","The second stage control bits, cb, replicated for the two 4-bit circuits, are given by:",{"@attributes":{"id":"p-0091","num":"0090"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"msub":{"mi":"cb","mn":"2"},"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["5","2"],"mo":","}}},"mo":"\u2295","msub":{"mi":"s","mn":"1"}}},{"mo":"\uf605","msub":{"mi":"s","mn":"1"}}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["5","1"],"mo":","}}},{"msub":{"mi":"s","mn":"0"},"mo":["\u2062","\u2062"],"mrow":[{"mo":["\uf605","\uf606"],"msub":{"mi":"s","mn":"0"}},{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["5","1"],"mo":","}}},"mo":"\u00b7","msub":{"mi":"s","mn":"0"}}]}],"mo":"+"}},"mo":"\u2295","msub":{"mi":"s","mn":"1"}}},{"mo":"\uf605","msub":{"mi":"s","mn":"1"}}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mo":["{","}"]},{"msub":{"mi":"s","mn":"0"},"mo":["\u2062","\u2062"],"mrow":[{"mo":["\uf605","\uf606"],"msub":{"mi":"s","mn":"0"}},{"mrow":{"mo":["{","}"]},"mo":"\u00b7","msub":{"mi":"s","mn":"0"}}]}],"mo":"+"}},"mo":"\u2295","msub":{"mi":"s","mn":"1"}}},{"mo":"\uf605","msub":{"mi":"s","mn":"1"}}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"msub":[{"mi":"s","mn":"0"},{"mi":"s","mn":"1"}],"mo":"\u2295"}},{"mo":"\uf605","msub":{"mi":"s","mn":"1"}}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mn":["1","0"],"mo":"\u2295"}},{"mo":"\uf605","mn":"0"}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mn":"10."}}}]}},{"mrow":{"mo":["(",")"],"mn":"19"}}]}}}}},"Note that f(5,2)=1 in the above. The final stage control bits, cb, are given by:",{"@attributes":{"id":"p-0093","num":"0092"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"msub":{"mi":"cb","mn":"3"},"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["5","3"],"mo":","}}},"mo":"\u2295","msub":{"mi":"s","mn":"2"}}},{"mo":"\uf605","msub":{"mi":"s","mn":"2"}}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["5","2"],"mo":","}}},{"msub":{"mi":"s","mn":"1"},"mo":["\u2062","\u2062"],"mrow":[{"mo":["\uf605","\uf606"],"msub":{"mi":"s","mn":"1"}},{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["5","2"],"mo":","}}},"mo":"\u00b7","msub":{"mi":"s","mn":"1"}}]}],"mo":"+"}},"mo":"\u2295","msub":{"mi":"s","mn":"2"}}},{"mo":"\uf605","msub":{"mi":"s","mn":"2"}}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"+","mrow":{"msub":{"mi":"s","mn":"1"},"mo":["\u2062","\u2062"],"mrow":[{"mo":["\uf605","\uf606"],"msub":{"mi":"s","mn":"1"}},{"mn":"1","mo":"\u00b7","msub":{"mi":"s","mn":"1"}}]}}},"mo":"\u2295","msub":{"mi":"s","mn":"2"}}},{"mo":"\uf605","msub":{"mi":"s","mn":"2"}}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"+","mrow":{"mn":"0","mo":["\u2062","\u2062"],"mrow":[{"mo":["\uf605","\uf606"],"mn":"0"},{"mn":["1","0"],"mo":"\u00b7"}]}}},"mo":"\u2295","mn":"1"}},{"mo":"\uf605","mn":"1"}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":"~","mrow":{"mo":["(",")"],"mn":"100"}},{"mo":"\uf605","mn":"1"}],"mo":"\u2062"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mn":"0111."}}}]}},{"mrow":{"mo":["(",")"],"mn":"20"}}]}}}}},{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 12"},"The other operations (shifts, extract, deposit, and mix) shown in Table 1 above can be modeled as a rotation part plus a masked-merge part with zeroes, sign bits or second source operand bits. The rotation part can use the same rotation control bit generator described above to configure the inverse butterfly circuit datapath. The masked-merge part can be achieved by using an enhanced inverse butterfly datapath with an extra multiplexer stage added as the final stage. The mask control bits are \u201c0\u201d when selecting the rotated bits and \u201c1\u201d when selecting the merge bits.","For a right shift by s, the s sign or zero bits on the left are merged in. This requires a control string 1\u22250for the extra multiplexer stage. From the definition of f(s, j), it can be seen that f(s, lg(n)+1) is the string 1\u22250. Thus, the desired control string is given by f(s, lg(n)+1)\u22250 (recall that s<n therefore the least significant bit is always \u201c0\u201d, i.e., the least significant bit is always selected from the inverse butterfly datapath). f(s, lg(n)+1) can easily be produced by extending the rotation control bit generator by one extra stage. For left shift, which can be viewed as the left-to-right reversal of right shift, the control bits for the extra stage are obtained by reversing left-to-right the right shift control string to yield 0\u22251.","For extract operations, which are like right shift operations with the left end replaced by the sign bit of the extracted field or zeros, the inverse butterfly circuit of the present invention selects in its extra multiplexer stage the rotated bits or zeros or the sign bit of the extracted field i.e., the bit in position pos+len\u22121 in the source register (see  at ). The bit can be selected using an n:1 multiplexer. The control bit pattern for this stage is n-len \u201c1\u201ds followed by len \u201c0\u201ds (1\u22250) to propagate the sign bit of the extracted field in the output (which is in position len-1) to the high order bits. Note that cb(len)={f(len, lg(n)+1)\u2295len\u2225len} is 1\u22250(as len ranges from 0 to n and has lg(n)+1 bits: len) So, reversing left-to-right cb(len) yields 0\u22251and then negating it produces 1\u22250, the correct bit pattern for stage lg(n)+1.","For deposit operations, which are like left shift operations with the right and left ends replaced by zeros or bits from the second operand, the inverse butterfly circuit of the present invention selects in its extra multiplexer stage the rotated bits or zeros or bits from the second input operand. The correct pattern is a string of n-pos\u2212len \u201c1\u201ds followed by len \u201c0\u201ds followed by s=pos \u201c1\u201ds (1\u22250\u22251) merge in bits on the right and left around the deposited field. cb(pos+len)={f(pos+len, lg(n)+1)\u2295(pos+len)\u2225(pos+len)} is 1\u22250(as pos+len ranges from 0 to n and has lg(n)+1 bits: (pos+len).). Reversing left-to-right this string yields 0\u22251and then negating it produces 1\u22250. Bitwise ORing this with the left shift control string, 0\u22251, yields 1\u22250\u22251, the correct pattern for the masked-merge part of the deposit operation is produced.","For mix operations, the enhanced inverse butterfly circuit of the present invention selects in its extra multiplexer stage the rotated bits or the bits from the second input operand. The control bit pattern is simply a pattern of alternating strings of \u201c0\u201ds and \u201c1\u201ds, the precise pattern depending on the subword size and whether mix left or mix right is executed. These patterns can be hard coded in the circuit for the 12 mix operations (6 operand sizes\u00d72 directions).","The foregoing mask-merged bit patterns and mask control are summarized in Table 2 below:",{"@attributes":{"id":"p-0101","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Instruction","Merge Bits"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"rotr\/rotl","\u2014"]},{"entry":[{},"shr","(sign bit)"]},{"entry":[{},"shr.u","0"]},{"entry":[{},"shl","0"]},{"entry":[{},"extr","(r[pos + len \u2212 1])"]},{"entry":[{},"extr.u","0"]},{"entry":[{},"dep.z","0"]},{"entry":[{},"dep","r"]},{"entry":[{},"mix.r","r"]},{"entry":[{},"mix.l","r"]},{"entry":[{},"bfly\/ibfly","\u2014"]},{"entry":[{},"pex\/pex.v","\u2014"]},{"entry":[{},"pdep\/pdep.v","0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Instruction","Mask Control"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"rotr\/rotl","0"]},{"entry":[{},"Shr","1|| 0"]},{"entry":[{},"Shr.u","1|| 0"]},{"entry":[{},"Shl","0|| 1"]},{"entry":[{},"extr","1|| 0"]},{"entry":[{},"extr.u","1|| 0"]},{"entry":[{},"dep.z","1|| 0|| 1"]},{"entry":[{},"dep","1|| 0|| 1"]},{"entry":[{},"mix.r","(0|| 1), k = 1, 2, 4, 8, 16, 32"]},{"entry":[{},"mix.l","(1|| 0), k = 1, 2, 4, 8, 16, 32"]},{"entry":[{},"bfly\/ibfly","0"]},{"entry":[{},"pex\/pex.v","0"]},{"entry":[{},"pdep\/pdep.v","r"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The inverse butterfly circuit implemented by the present invention can perform a parallel extract (pex) operation. The inverse butterfly circuit is decomposed into even and odd subcircuits. As shown in , the even subcircuits are shown with dotted lines and the odd subcircuits with solid lines. These can also be called right and left subcircuits. For simplicity and clarity of notation even subcircuits are referred to herein as R (right) and odd subcircuits as L (left). The circuit  of  is similar to the inverse butterfly circuit shown in , and includes a register input  and three circuit stages -. The proof in support of implementing pex on an inverse butterfly circuit is provided as follows:","Fact 1. Any single data bit can be moved to any result position by just moving it to the correct R or L subcircuit of the intermediate result at every stage of the inverse butterfly circuit.","Proof. This can be proved by induction on the number of stages. At stage 1, the data bit is moved to its final position mod 2 (i.e., to R or L). At stage 2, it is moved to its final position mod 4, and so on. At stage lg(n), it is moved to its final position mod 2=n, which is its final result position.","Fact 2. A permutation is routable on an inverse butterfly circuit if the destinations of the bits constitute a complete set of residues mod m (i.e., the destinations equal 0, 1, . . . , m\u22121 mod m) for each subcircuit of width m.","Proof. Based on Fact 1, bits are routed on the inverse butterfly circuit by moving them to the correct position mod 2 after the first stage, mod 4 after the second stage, etc. Consequently, if the two bits entering stage 1, (with 2-bit wide inverse butterfly circuits as shown in ), have destinations equal to 0 and 1 mod 2 (i.e., one is going to R and one to L), Fact 1 can be satisfied for both bits and they are routable through stage 1 without conflict. Subsequently, the four bits entering stage 2 (with the 4-bit wide butterfly circuits) must have destinations equal to 0, 1, 2 and 3 mod 4 to satisfy Fact 1 and be routable through stage 2 without conflict. A similar constraint exists for each stage.","Theorem 1. Any Parallel Extract instruction on n=2bits can be implemented with one pass through an inverse butterfly circuit of lg(n) stages without path conflicts (with the un\u2212selected bits on the left zeroed out).","Proof. The pex operation compresses bits in their original order into adjacent bits in the result. Consequently, two adjacent selected data bits that enter the same stage 1 subcircuit must be adjacent in the output. In other words, one bit has a destination equal to 0 mod 2 and the other has a destination equal to 1 mod 2\u2014the destinations constitute a complete set of residues mod 2 and thus are routable through stage 1. The selected data bits that enter the same stage 2 subcircuit must be adjacent in the output and thus form a set of residues mod 4 and are routable through stage 2. A similar situation exists for the subsequent stages, up to the final n-bit wide stage. No matter what the bit mask of the overall pex operation is, the selected data bits will be adjacent in the final result. Thus the destination of the selected data bits will form a set of residues mod n and the bits will be routable through all lg(n) stages of the inverse butterfly circuit.","Parallel deposit can be performed using the butterfly circuit of the present invention, since the parallel deposit operation is the inverse of the parallel extract operation. Also, the grp operation discussed above can be mapped to two parallel inverse butterfly circuits, since grp is a combination of a grp_right (or pex) and a grp_left (a mirrored pex).","A decoder for the parallel extract (and parallel deposit) instruction takes as its input the n-bit mask and produces the n\/2\u00d7lg(n) control bits for the inverse butterfly (or butterfly) circuit. The decoder can be designed to consist of only two types of operations that can be performed in software or implemented as circuits: a parallel prefix population counter, which counts the ones from position 0 (on the right) to every bit position from 0 to n\u22122, and a set of left rotators that complement bits upon wraparound (LROTC\u2014Left ROTate and Complement). The theoretical underpinnings for a parallel extract decoder are discussed below in connection with .",{"@attributes":{"id":"p-0111","num":"0110"},"figref":["FIG. 15","FIG. 14"]},"X is the rightmost bits of R, as the output of pex is the selected data bits compressed and right justified in the result. Y is rotated left from the midpoint by the size of X, |X|, at the input to the final stage so that when it is swapped into R in the final stage it is contiguous to X on its right. Z is the rightmost bits in L at the input to the final stage, so that when it is passed through in L, it is contiguous with the bits in R. Thus, the control bit pattern for the final stage is 1\u22250, where \u201c1\u201d denotes swap, and \u201c0\u201d denotes pass-through of the paired bits in L and R, in the last stage. |X| is equal to the count of \u201c1\u201ds in the right half of the bit mask as all the selected data bits in the right half of the input have already been compressed and right justified prior to the input to the final stage. This pattern can be generated by a left rotate and complement on wraparound (LROTC) operation of the one string of length n\/2. For every position in the rotation, a \u201c1\u201d is wrapped around from the left and complemented to obtain a \u201c0\u201d on the right. The end result, after a LROTC by |X| bits, is a string with the |X| rightmost bits set to \u201c0\u201d and the rest set to \u201c1.\u201d","Referring to the top row of , Y and Z can be viewed as having been left rotated by |X| from being the rightmost bits of L at the output of stage lg(n)\u22121. Consequently, it is possible to iterate backwards through the stages, performing a pex operation within each half subcircuit and then explicitly left rotate each local L at the input of the next stage by the number of selected data bits in the local R at the input of the next stage prior to the swapping or passing through of bits in this next stage.","Rather than rotating the data bits explicitly, it is possible to compensate for the rotation by modifying the routing through the subsequent stages. This can be achieved by rotating the control bits by the same number of positions, complementing upon wraparound (LROTC). These rotations are propagated forward. Consequently, the control bits for a stage, obtained by a LROTC of the one string by the count of \u201c1\u201ds in the right half of the local bit mask, are further modified by a LROTC operation by the count of \u201c1\u201ds in the right half of the next larger local bit mask, and so on. The result is a single LROTC operation of the one string by count of \u201c1\u201ds in the right half the local bit mask through bit 0, the least significant bit. Overall, the counts are needed of the k rightmost bits, for k=0 to n\u22122\u2014the set of prefix population counts.","The counting of the number of \u201c1\u201ds is done in parallel by the Parallel Prefix Population Count operation, while the rotation is done by the LROTC operation at each stage. The full decoding algorithm (which could be performed in hardware or software) is given below:",{"@attributes":{"id":"p-0116","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002Algorithm 1:","To generate the nlg(n)\/2 inverse butterfly (or butterfly) "]},{"entry":[{},"control bits from the n-bit mask."]},{"entry":["\u2002Input: ","mask; the pex (or pdep) bitmask"]},{"entry":["\u2002Output:","ibcb; the lg(n) \u00d7 n\/2 matrix containing the inverse "]},{"entry":[{},"butterfly control bits"]},{"entry":[{},"bcb; the lg(n) \u00d7 n\/2 matrix containing the "]},{"entry":[{},"butterfly control bits"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2002Let x\u2225y indicate the concatenation of bit patterns x and y. "},{"entry":"PP_POPCNT(a) is the parallel prefix population count of \u201c1\u201ds "},{"entry":"in bitfield a. mask{h:v} is the bitfield from bit h to bit v of the mask. "},{"entry":"1indicates a bit-string of k ones. LROTC(a, rot) is a \u201cleft rotate and "},{"entry":"complement on wrap\u201d operation, where a is the input and rot is the "},{"entry":"rotation amount."},{"entry":"\u20021. Calculate the prefix population counts:"},{"entry":"\u2003\u2003For i = 1, 2, . . . , n \u2212 2"},{"entry":"\u2003\u2003\u2003pc[i] = PP_POPCNT(mask{i:0})"},{"entry":"\u20022. Calculate the inverse butterfly (and butterfly) control bits for"},{"entry":"\u2003\u2002each stage by performing LROTC(0, pc[m]), where k is the size "},{"entry":"\u2003\u2002of the local R and m is the set of the leftmost bit positions of "},{"entry":"\u2003\u2002the local R's:"},{"entry":"\u2003\u2003ibcb = bcb = { }"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"right"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003For i = 1, . . . , lg(n)","\/\/for each stage"]},{"entry":["\u2003\u2003\u2003k = n\/2","\/\/number of bits in local R"]},{"entry":["\u2003\u2003\u2003For j = 1, 3, 5, . . . 2\u2212 1","\/\/for each local R"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"right"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"m = j \u00d7 k \u2212 1","\/\/the leftmost bit position of the local R"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"temp = LROTC(1, pc[m])"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"right"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ibcb[lg(n) \u2212 i + 1] = ","\/\/for inverse butterfly datapath"]},{"entry":[{},"temp \u2225 ibcb[lg(n) \u2212 i + 1]",{}]},{"entry":[{},"bcb[i] = temp \u2225 bcb[i]","\/\/for butterfly datapath"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 16","b":["70","70","72","73","74","76","78","80","82","70","70"]},"It is noted that three classes of parallel extract and parallel deposit instructions can be handled by the present invention. The first consists of static versions of these instructions, where software or the compiler \u201cpre-decodes\u201d the mask in the second source register into control bits for the datapath, and moves the control bits into the Application Registers (ARs), or any registers that may be used to control the ibfly circuit. This uses the mov instruction in Table 1, followed by the pex or pdep instructions. The second class is dynamic mask decoding by a hardware implementation of the decoder of . This uses the pex.v or pdep.v instructions in Table 1. The third class is loop-invariant pex and pdep. Here, the mask is known only at runtime but remains fixed for a long input stream. The hardware decoder of  can output the control bits to the application registers once, and subsequently the static versions of pex and pdep are used. This uses the setib and setb instructions in Table 1, followed by static pex or pdep instructions.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 17A","FIG. 13"],"b":["90","90","90","96","98","100","102","108"]},{"@attributes":{"id":"p-0120","num":"0119"},"figref":["FIG. 17B","FIG. 17A","FIG. 18A"],"b":["110","110","96","98","104","102","90","92","94","101","106","101","110","106","106"]},{"@attributes":{"id":"p-0121","num":"0120"},"figref":["FIG. 18A","FIG. 17A","FIG. 13"],"b":["100","126","130"]},{"@attributes":{"id":"p-0122","num":"0121"},"figref":["FIG. 18B","FIG. 17B","FIG. 13","FIG. 16"],"b":["101","126","122","128","122","122","126","124","130"],"sub":"lg(n)"},"The merge and mask control bits implemented by masked merge unit  of  include those summarized in Table 2 above. The merge bits can be:\n\n","Table 3 below presents a high level comparison of the present invention to known barrel and log shifter designs:",{"@attributes":{"id":"p-0125","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Barrel Shifter","Log Shifter","Our IBFLY Shifter"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["# Elements","n","n \u00d7 lg(n) or","n \u00d7 lg(n)"]},{"entry":[{},{},"n \u00d7 log(n)"]},{"entry":["# Control","n","lg(n)","n\/2 \u00d7 lg(n)"]},{"entry":"Lines"},{"entry":["Gate delay","1","lg(n) or","lg(n)"]},{"entry":["(Datapath)",{},"log(n)"]},{"entry":["Mux width","n","2 or 4","2"]},{"entry":"(Capacitance)"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The first two lines of Table 3 contain the components that contribute to circuit area. Both the log shifter and the inverse butterfly version of the present invention have n\u00d7lg(n) elements, while the barrel shifter has nelements. The log shifter also has the fewest control lines (lg(n)) while the present invention has the most as each switch, or pair of elements, requires an independent control bit. The next two lines pertain to latency. The datapath of the barrel shifter has a single gate delay while the log shifter and the present invention have lg(n) gate delay. However, both the log shifter and the present invention utilize narrow multiplexers with lower capacitance at output nodes.","The method of logical effort was first used to compare the delay along the critical paths for the barrel shifter, the log shifter, and the inverse butterfly shifter. This estimated the critical path in terms of FO4 gate equivalents, which is the delay of an inverter driving 4 similar inverters. The latency of only the basic shifter operations on these datapaths was compared. As the 64-bit barrel shifter is impractical due to the capacitance on the output lines, a 64-bit shifter was implemented as an 8-byte barrel shifter followed by an 8-bit barrel shifter, which limits the number of transmission gates tied together to 8. The delay only from the input to the decoder through the two shifter levels for the barrel shifter and through the three shifter levels for the log shifter was considered.","For the present invention, the delay from the input to the control bit generator (i.e., the rotation control bit generator of ) through the output of the inverse butterfly circuit was considered. According to the logical effort calculations, the delay for the barrel shifter is 15.1 FO4 and the delay for the log shifter is 13.0 FO4, while the delay for inverse butterfly shifter is 15.5 FO4. Thus, the delay along the critical path for the barrel shifter and the present invention is comparable, and the present invention is 19% slower than a log shifter. Note that this is only a rough estimation of delay along the critical path without circuit optimization. Custom circuit design of the present invention will result in a much faster circuit.","Since the log shifter is the faster and more compact of the two current shifter designs, it was implemented for testing purposes along with the present invention, using a standard cell library. All designs were synthesized to gate level, optimizing for shortest latency, using Design Compiler mapping to a TSMC 90 nm standard cell library. The results are summarized in Tables 4-6 below.",{"@attributes":{"id":"p-0130","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Functional","Latency","Relative","Area","Relative"]},{"entry":["Unit","(ns)","Latency","(NAND gates)","Area"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Log Shifter","0.30","1","6.2K","1"]},{"entry":["Our","0.35","1.18","4.3K","0.69"]},{"entry":"IBFLY shifter"},{"entry":["ALU","0.38","1.27","8.2K","1.31"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Table 4 shows the result of a basic shifter that only implements shift and rotate instructions. For the log shifter, parallel datapaths were implemented for left and right shifts. The present invention has 1.18\u00d7the latency of the log shifter, which is similar to the logical effort calculation. The present invention is also smaller than the log shifter, at approximately 70% of the area (note that a single datapath log shifter would have smaller area; additionally, accounting for the wires will increase the area for the ibfly-based shifter relative to the log shifter, as mentioned). For comparison, we also implemented an ALU (supporting add, subtract, and, or, not, xor with register or immediate operands) synthesized using the same standard cell library. The present invention is faster (92% latency) and smaller (52% area) than this ALU.",{"@attributes":{"id":"p-0132","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Functional","Latency","Relative","Area","Relative"]},{"entry":["Unit","(ns)","Latency","(NAND gates)","Area"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Log Shifter","0.41","1","6.2K","1"]},{"entry":["Our","0.42","1.03","5.3K","0.83"]},{"entry":"IBFLY shifter"},{"entry":["ALU","0.40","0.99","6.6K","1.03"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Table 5 shows the result when both shifter architectures are enhanced to support extract, deposit, and mix instructions. The critical path of the log shifter is now through the extract sign bit propagation, so the latency is now comparable to that of the inverse butterfly-based shifter of the present invention. The present invention is still only 83% of the area of the log shifter. The results for an ALU of similar latency are also included (which has a comparable circuit area, in NAND gate equivalents).",{"@attributes":{"id":"p-0134","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Functional","Latency","Relative","Area","Relative"]},{"entry":["Unit","(ns)","Latency","(NAND gates)","Area"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Log Shifter","0.41","1","6.4K","1"]},{"entry":["ibfly, pex","0.48","1.18","8.2K","1.29"]},{"entry":[{},{},{},"(1.2K for ARs)"]},{"entry":["ibfly, bfly,","0.49","1.20","11.9K","1.87"]},{"entry":["pex, pdep",{},{},"(2.5K for ARs)"]},{"entry":["bfly, pdep","0.48","1.19","3.6K","0.57"]},{"entry":["(no snifter)",{},{},"(1.5K for ARs)"]},{"entry":["ALU","0.49","1.20","5.3K","0.83"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Table 6 shows the results when support is added to the present invention for advanced bit manipulation operations, but not to the log-shifter. The first line in table 6 represents the log shifter circuit from Table 5, included as the baseline. The second line is a unit that supports the ibfly and static pex instructions. The functionality of the butterfly circuit can be emulated using inverse butterfly, albeit with a multi-cycle penalty. The latency increases are due to extra multiplexing for the control bits and output. The area increases due to the ARs, the extra multiplexers, and the pex masking. This unit has 1.18\u00d7 the latency and 1.29\u00d7 the area of the log shifter. The third line in Table 6 is a unit that also supports butterfly and static pdep. The latency increases slightly due to output multiplexing and the area increases due to the second (butterfly) datapath and second set of three ARs. This unit has 1.20\u00d7 the latency and 1.87\u00d7 the area of the log shifter. Alternatively, a separate unit can be added to perform just bfly and pdep (line 4 in Table 6), thereby enabling simultaneous superscalar execution with the ibfly-pex-shifter unit (line 2 in Table 6). It can be seen that the shift-permute unit of the present invention (line 3 in Table 6) can be split into two units at no additional increase in area. The results for an ALU of similar latency are also included, wherein the ALU is smaller than the log shifter due to the relaxed latency constraint. The shift-permute unit (line 3) now has 2.25\u00d7 the area of the ALU, but smaller sizes are possible.",{"@attributes":{"id":"p-0136","num":"0142"},"figref":["FIGS. 19A-31","FIGS. 19A-30","FIG. 10"]},{"@attributes":{"id":"p-0137","num":"0143"},"figref":["FIG. 19A","FIG. 19B","FIG. 20"]},"In each half of stage 2 we transfer from the local R to the local L the bits whose final destination is in the local L. So in R, we transfer g to Rand in L we transfer d to L. Prior to stage 3, we right rotate the bits to right justify them in their original order in their new subnetworks. So d0 is right rotated by 1, the number of bits that stayed in L, to yield 0d, and gf is right rotated by 1, the number of bits that stayed in R, to yield fg.","In each subnetwork of stage 3 we again transfer from the local R to the local L the bits whose final destination is in the local L. So in Lwe transfer d and in Lwe transfer e. After stage 3 we have transferred each bit to its correct final destination: d0e0fg0h. Note that we use a control bit of \u201c0\u201d to indicate a swap, and a control bit of \u201c1\u201d to indicate a pass through operation. Rather than explicitly right rotating the data bits in the L half after each stage, we can compensate by modifying the control bits. This is shown in .","Provided below is an explanation as to how the pdep operation can be mapped to the butterfly circuit:","Fact 3: Any single data bit can be moved to any result position by moving it to the correct half of the intermediate result at every stage of the butterfly circuit.","This can be proved by induction on the number of stages. At stage 1, the data bit is moved within n\/2 positions of its final position. At stage 2, it is moved within n\/4 positions of its final result, and so on. At stage lg(n), it is moved within n\/2=1 position of its final result, which is its final result position. Referring back to , Fact 3 is utilized to decide which bits to keep in R and which to transfer from R to L at each stage.","Fact 4: If the mask has k \u201c1\u201ds in it, the k rightmost data bits are selected and moved, i.e., the selected data bits are contiguous. They never cross each other in the final result.","This fact is by definition of the pdep instruction. See the example of , where there are 5 \u201c1\u201ds in the mask and the selected data bits are the 5 rightmost bits, defgh; these bits are spread out to the left maintaining their original order, and thus never crossing each other in the result.","Fact 5: If a data bit in the right half (R) is swapped with its paired bit in the left half (L), then all selected data bits to the left of it will also be swapped to L (if they are in R) or stay in L (if they are in L).","Since the selected data bits never cross each other in the final result (Fact 4), once a bit swaps to L, the selected bits to the left of it must also go to L. Hence, if there is one \u201c1\u201d in the mask, the one selected data bit, d, can go to R or L. If there are two \u201c1\u201ds in the mask, the two selected data bits, dd, can go to RR or LR or LL. That is, if the data bit on the right stays in R, then the next data bit can go to R or L, but if the data bit on the right goes to L, the next data bit must also go to L. If there are three \u201c1\u201ds, the three selected data bits, ddd, can go to RRR, LRR, LLR or LLL. For example, in stage 1 of , the five bits have the pattern LLRRR as e is transferred to L and d must then stay in L.","Fact 6: The selected data bits that have been swapped from R to L, or stayed in L, are all contiguous mod n\/2 in L.","From Fact 5, the destinations of the k selected data bits d. . . dmust be of the form L . . . LR . . . R, a string of zero or more L's followed by zero or more R's. Define X as the bits staying in R, Y as the bits going to L that start in R and Z as the bits going to L that start in L. It is possible that:\n\n","When X alone exists (i), there are no bits that go to L, so Fact 6 is irrelevant.","The structure of the butterfly circuit requires that when bits are moved in a stage, they all move by the same amount. Fact 4 states that the selected data bits are contiguous. Together these imply that when Y alone exists or X and Y exist (ii and iii), Y is moved as a contiguous block from R to L and Fact 6 is trivially true.","When X and Z exist (iv), Z is a contiguous block of bits that does not move so again Fact 6 is trivially true.","When X, Y and Z exist (v), Y comprises the leftmost bits of R, and Z the rightmost bits in L since they are contiguous across the midpoint of the stage (Fact 4). When Y is swapped to L, since the butterfly circuit moves the bits by an amount equal to the size of L or R in a given stage, Y becomes the leftmost bits of L. Thus Y and Z are now contiguous mod n\/2, i.e., wrapped around, in L, as shown in . Thus, Fact 6 is true in all cases.","For example, in  at the input to stage 1, X is bits fgh, Y is bit e and Z is bit d. Y is the leftmost bit in R and Z is the rightmost bit in L. After stage 1, Y is the leftmost bit in L and is contiguous with Z mod 4, within L, i.e., de is contiguous mod 4 in e00d.","Fact 7: The selected data bits in L can be rotated so that they are the rightmost bits of L, and in their original order.","From Fact 6, the selected data bits are contiguous mod n\/2 in L. At the output of stage 1 in , these bits are offset to the left by the size of X (the number of bits that stayed in R), denoted by |X|. Thus, if we explicitly rotate right the bits by |X|, the selected data bits in L are now the rightmost bits of L in their original order (see ). In , Fact 7 was utilized prior to stages 2 and 3.","At the end of this step, we have two half-sized butterfly circuits, L and R, with the selected data bits right-aligned and in order in each of L and R (last row of ). The above can now be repeated recursively for the half-sized butterfly circuits, L and R, until each L and R is a single bit. This is achieved after lg(n) stages of the butterfly circuit (see the final output in ).","The selected data bits emerge from stage 1 in  rotated to the left by |X|. In Fact 7, the selected data are explicitly rotated bits back to the right by |X|. Instead, we can compensate for the rotation by modifying the control bits of the subsequent stages to limit the rotation within each subnetwork. For example, if the n-bit input to stage 1 is rotated by k positions, the two n\/2-bit inputs to the L and R subnetworks are rotated by k (mod n\/2) within each subnetwork. At the output of stage lg(n), the subnetworks are 1-bit wide so the rotations are absorbed.","Fact 8: If the data bits are rotated by x positions left (or right) at the input to a stage of a butterfly circuit, then at the output of that stage we can obtain a rotation left (or right) by x positions of each half of the output bits by rotating left (or right) the control bits by x positions and complementing upon wrap around.","Consider again the example of . The selected data bits emerge from stage 1 left rotated by 3 bits, i.e., L is e00d, left rotated by 3 positions from 00de. In , we explicitly rotated the data bits back to the right by 3. Instead, we can compensate for this left rotation by left rotating and complementing upon wrap around by 3 positions the control bits of the subsequent stages. This is shown in . For stage 2, the control bit pattern of L, after left rotate and complement by 3, becomes 01\u219211\u219210\u219200. The rotation by 3 is limited to a rotation by 3 mod 2=1 within each half of the output of L of stage 2. In , we show the explicit rotation of the output of stage 2 before it is input to stage 3 to transform from d0,0e in  to 0d,e0. For stage 3, the rotation and complement by 3 of the two single control bits in L become three successive complements: 0\u21921\u21920\u21921, and the left rotation of L is absorbed as the overall output is still d0e0. Hence,  shows how the control bits in stages 2 and 3 compensate for the left rotate by 3 bits at the output of stage 1 (compare with ).",{"@attributes":{"id":"p-0160","num":"0171"},"figref":["FIG. 21","FIG. 23","FIG. 21","FIG. 20","FIG. 20"],"sub":["L ","L","L ","L "]},"An explanation is now provided as to why the control bits are complemented when they wrap around. The goal is to keep the data bits in the half they were originally routed to at each stage of the butterfly circuit, in spite of the rotation of the input.  shows a pair of bits, a and b, that were originally passed through. It is desired to route a to L and b to R in spite of any rotation. As the bits are rotated (see ), the control bit is rotated with them, keeping a in L and b in R, as desired. When the bits wrap around, (see ), a wraps to R and b crosses the midpoint to L. If the control bit is simply rotated with the paired bits, then a is now passed through to R and b is passed through to L, which is contrary to the originally desired behavior. If instead the control bit is complemented when it wraps around (see ), then a is swapped back to L and b is swapped back to R, as is desired.","Similarly, if a and b were originally swapped (see ), a should be routed to R and b to L. As the bits rotate (see ), we simply rotate the control bit with them. When the bits wrap around (see ), input a wraps to R and b crosses to L. When they are swapped, a is routed to L and b to R, contrary to their original destinations. If the control bit is complemented on wraparound, a is passed through to R and b is passed through to L, conforming to the originally desired behavior.","Thus, complementing the control bit when it wraps (see ) causes each of the pair of bits to stay in the half it was originally routed to despite the rotation of the input pushing each bit to the other half. This limits the rotation of the input to be within each half of the output and not across the entire output.","Provided below is a theorem to formalize the overall result:","Theorem 2: Any parallel deposit instruction on n bits can be implemented with one pass through a butterfly circuit of lg(n) stages without path conflicts (with the bits that are not selected zeroed out externally).","Proof: Assume there are k \u201c1\u201ds in the right half of the bit mask. Then, based on Fact 3, the k rightmost data bits (block X) must be kept in the right half (R) of the butterfly circuit and the remaining contiguous selected data bits must be swapped (block Y) or passed through (block Z) to the left half (L). This can be accomplished in stage 1 of the butterfly circuit by setting the k rightmost configuration bits to \u201c1\u201d (to pass through X and Z), and the configuration bits of the remaining selected bits to \u201c0\u201d (to swap Y).","At this point, the selected data bits in the right subnetwork (R) are right-aligned but those in the left subnetwork (L) are contiguous mod n\/2, but not right aligned (Fact 4, ); they are rotated left by the size of block X or the number of bits kept in R. We can compensate for the left rotation of the bits in L and determine the control bits for subsequent stages as if the bits in L were right aligned. This is accomplished by left rotating and complementing upon wraparound the control bits in the subsequent stages of L by the number of bits kept in R (once these control bits are determined pretending that the data bits in L are right aligned). Modifying the control bits in this manner will limit the rotation to be within each half of the output until the rotation is absorbed after the final stage (Fact 8).","Now the process above can be repeated on the left and right subnets, which are themselves butterfly networks: count the number of \u201c1\u201ds in the local right half of the mask and then keep that many bits in the right half of the subnetwork, and swap the remaining selected data bits to the left half Account for the rotation of the left half by modifying subsequent control bits. This can be repeated for each subnetwork in each subsequent stage until the final stage is reached, where the final parallel deposit result will have been achieved (see ).","Various functional units can be constructed in accordance with the present invention, for implementing any desired combinations of parallel extract, parallel deposit, butterfly permutations, and inverse butterfly permutations. Examples of such functional units will now be discussed with reference to .",{"@attributes":{"id":"p-0170","num":"0181"},"figref":["FIG. 32","FIG. 16"],"b":["140","140","146","142","148","144","144","140","144","144","146"]},{"@attributes":{"id":"p-0171","num":"0182"},"figref":"FIG. 33","b":["150","150","152","154","158","156","156"]},{"@attributes":{"id":"p-0172","num":"0183"},"figref":"FIG. 34","b":["160","160","162","176","164","174","166","172","168","170"]},{"@attributes":{"id":"p-0173","num":"0184"},"figref":["FIG. 35","FIG. 34","FIG. 34"],"b":["180","160","182","190","198","160","180","184","194","186","200","188","202","192","196","160","180","182","182"]},"The decoder circuit  can be used for both pex and pdep with the caveat that the ordering of the stages that control bits are routed to is reversed (the circular arrow in  indicates reversing the stages).",{"@attributes":{"id":"p-0175","num":"0186"},"figref":["FIG. 36","FIG. 35"],"b":["210","180","212","220","232","216","236","218","234","210","214","226","222","230","224","228"]},{"@attributes":{"id":"p-0176","num":"0187"},"figref":["FIG. 37","FIG. 36"],"b":["240","242","264","262","266","258","244","246","260","256","268","248","252","272","276","250","274","254","270","210"]},"The various functional units discussed above in connection with  can implement a wide variety of advanced bit manipulation instructions. Table 7 below summarizes these instructions, as well as the processor cycles required for each instruction. Note that Table 7 is similar to the bottom half of Table 1, with the addition of the grp instruction and associated cycle counts. A 64-bit word size, without loss of generality, is assumed:",{"@attributes":{"id":"p-0178","num":"0189"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Instruction","Description","Cycles"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bfly r= r, ar.b, ar.b, ar.b","Perform Butterfly permutation of data bits using controls in associated ARs","1"]},{"entry":["ibfly r= r, ar.ib, ar.ib, ar.ib","Perform Inverse Butterfly permutation of data bits using controls in associated ARs","1"]},{"entry":["pex r= r, r, ar.ib, ar.ib, ar.ib","Parallel extract, static: Data bits in rselected by a mask rare extracted,","1"]},{"entry":[{},"compressed and right-aligned in the result r, using datapath controls which have"]},{"entry":[{},"been pre-decoded from the mask and placed in the associated ARs"]},{"entry":["pdep r= r, r, ar.b, ar.b, ar.b","Parallel deposit, static: Right-aligned data bits in rare deposited, in order, in result","1"]},{"entry":[{},"rin bit positions marked with a \u201c1\u201d in the mask r, which has been pre-decoded to"]},{"entry":[{},"give datapath controls placed in the associated ARs."]},{"entry":["mov ar.x = r, r","Move values from GRs to ARs, to set datapath controls (calculated by software) for","1"]},{"entry":[{},"pex, pdep, bfly or ibfly"]},{"entry":["pex.v r= r, r","Parallel extract, variable: Data bits in rselected by a dynamically-decoded mask","3"]},{"entry":[{},"rare extracted, compressed and right-aligned in the result r."]},{"entry":["pdep.v r= r, r","Parallel deposit, variable: Right-aligned data bits in rare deposited, in order, in","3"]},{"entry":[{},"result rin bit positions marked with a \u201c1\u201d in the dynamically-decoded mask r."]},{"entry":["setib ar.ib, ar.ib, ar.ib= r","Set inverse butterfly datapath controls in the associated ARs, using hardware","2"]},{"entry":[{},"decoder to translate the mask rto inverse butterfly controls."]},{"entry":["setb ar.b, ar.b, ar.b= r","Set butterfly datapath controls in the associated ARs, using hardware decoder to","2"]},{"entry":[{},"translate the mask rto butterfly controls."]},{"entry":["grp r= r, r","Perform Group permutation (variable): Data bits in rcorresponding to \u201c1\u201ds in r","3"]},{"entry":[{},"are grouped to the right, while those corresponding to \u201c0\u201ds are grouped to the left."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"For bfly and ibfly, the data bits in GR rare permuted and placed in the destination register GR r. Application registers ar.band ar.ib, i=1, 2, 3, are used to hold the configuration bits for the butterfly or inverse butterfly datapath, respectively, and these registers must first be loaded by the mov_ar instruction. The mov_ar instruction in Table 7 is used to move the contents of two general-purpose registers to the application registers. The sub-opcode, x, indicates which application register, or pair of application registers, are written.","Static versions of pex and pdep are used when desired mask patterns are known at compile time. In the static version of the pex instruction, GR ris and'ed with mask GR r, then permuted using inverse butterfly application registers ar.ib, with the result placed in GR r. For static pdep, GR ris permuted using butterfly application registers ar.b, then and'ed with mask GR r, with the result placed in GR r.","Dynamic or variable versions of pex and pdep are used when desired mask patterns are only known at runtime. In the pex.v instruction, the data bits in GR rselected by the \u201c1\u201d bits in the mask GR rare placed, in the same order, in GR r. In the pdep.v instruction, the right justified bits in GR rare placed in the same order in GR r, in the positions selected by \u201c1\u201ds in mask GR r. For both instructions, the mask ris translated dynamically by a decoder into control bits for an inverse butterfly or butterfly circuit.","Suppose the particular pattern of bit scatter or gather is determined at execution time, but this pattern remains the same over many iterations of a loop. This is referred to as a loop-invariant pex or pdep operation. The setib and setb instructions invoke a hardware decoder to dynamically translate the bitmask GR rto control bits for the datapath stages; these control bits are written to the inverse butterfly or butterfly application registers, respectively, for later use in static pex and pdep instructions. Table 7 also shows the grp instruction which can perform arbitrary n-bit permutations. It is noted that the grp instruction can be emulated by a short sequence of pex and Boolean instructions.","The last column of Table 7 shows the expected number of cycles taken for the execution of the instruction. All static instructions (with pre-loaded ARs) take a single cycle, comparable to the time taken for an add instruction. The hardware decoder takes about 2 cycles, hence the setib and setb instructions take 2 cycles each. The variable pex.v and pdep.v and grp instructions each take up to 3 cycles each because they have to go through the hardware decoder first and then incur some additional datapath latency through the inverse butterfly or butterfly circuits and the output multiplexers. It is noted that the cycle counts depend on what a given processor uses to determine the cycle time. Here, it is assumed, without loss of generality, that the latency of an ALU is used to determine the cycle time. Also, it is noted that these cycle counts can change depending on the circuit optimization performed.","Table 8 summarizes applications in which the present invention can be implemented. Check marks indicate definite usage, check marks in parenthesis indicate usage in alternative algorithms and question marks indicate potential usage. The use of the mov ar instruction is assumed (but not shown in Table 8) whenever the bfly, ibfly, or static pex and pdep instructions are used. Note that these are just representative applications and do not constrain the use of the proposed instructions and shifter circuits in other applications or in different ways in these applications.",{"@attributes":{"id":"p-0185","num":"0196"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"center"}}],"thead":{"row":{"entry":[{},"TABLE 8"]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"Instruction"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"bfly and",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Application","ibfly","pex","setib","pdep","setb","pex.v","pdep.v","grp"]},{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Cryptology","\u2713","?","?","?","?","?","?","(\u2713)"]},{"entry":["Binary Compression",{},"\u2713"]},{"entry":["Binary Decompression\/Expansion",{},{},{},"\u2713"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LSB Steganography","Encoding",{},{},{},"\u2713","\u2713",{},{},{}]},{"entry":[{},"Decoding",{},"\u2713","\u2713"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Binary Image Morphology",{},"\u2713",{},{},{},"(\u2713)",{},{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Transfer Coding","Encoding",{},{},{},"\u2713",{},{},{},{}]},{"entry":[{},"Decoding",{},"\u2713"]},{"entry":["Bioinformatics","Compression",{},"\u2713"]},{"entry":[{},"Reversal","\u2713"]},{"entry":[{},"Translation",{},{},{},"\u2713"]},{"entry":[{},"Alignment",{},"\u2713"]},{"entry":["Compressed Integers","Encoding",{},{},{},"\u2713"]},{"entry":[{},"Decoding",{},"\u2713"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Random Number Generation",{},{},{},{},{},"\u2713"]},{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}}]}}]}}},"Table 8 shows that static pex and pdep are the most frequently used. The variable pdep.v is not used at all, and the variable pex.v is only used twice. The loop-invariant pex and pdep instructions, indicated by the use of setib and setb instructions, are only used for the LSB Steganography application. The grp instruction is only used in a block cipher.",{"@attributes":{"id":"p-0187","num":"0198"},"figref":"FIG. 38"},"The SSE instruction pmovmskb serves a similar purpose; it creates an 8- or 16-bit mask from the most significant bit from each byte of a MMX or SSE register and stores the result in a general purpose register. However, pex offers greater flexibility than the fixed pmovmskb, allowing the mask, for example, to be derived from larger subwords, or from subwords of different sizes packed in the same register.","Similarly, binary image compression performed by MATLAB's bwpack function benefits from pex. Binary images in MATLAB are typically represented and processed as byte arrays\u2014a byte represents a pixel and has permissible values 0x00 and 0x01. However, certain optimized algorithms are implemented for a bitmap representation, in which a single bit represents a pixel.","To produce one 64-bit output word requires only 8 static pex instructions to extract 8 bits in parallel from 8 bytes and 7 dep instructions to pack these eight 8-bit chunks into one output word (see ). For decompression, as with the bwunpack function, only 7 extra instructions are required to pull out each byte and only 8 pdep instructions to scatter the bits of each byte to byte boundaries.",{"@attributes":{"id":"p-0191","num":"0202"},"figref":"FIG. 39"},"LSB steganography is an example of an application that utilizes the loop-invariant versions of the pex and pdep instructions. The sample size and the number of bits replaced are not known at compile time, but they are constant across a single message.  depicts an example LSB steganography encoding operation in which the 4 least significant bits from each 16-bit sample of PCM encoded audio is replaced with secret message bits.",{"@attributes":{"id":"p-0193","num":"0204"},"figref":"FIG. 40"},"If the images are processed in bitmap form, a single pex instruction extracts the entire index at once (assuming a 64-bit word contains an 8\u00d78 block of 1-bit pixels, illustrated at  in ). As the algorithm steps through the pixels, the neighborhood moves (illustrated at  in ). This means that the bitmask for extracting the neighborhood is shifted and a dynamic pex.v instruction may be needed. Alternatively, the data might be shifted, rather than the mask, such that the desired neighborhood always exists in a particular set of bit positions. In this case, the mask is fixed, and only a static pex is needed. Table 8 indicates the latter\u2014with pex indicated by a check mark and pex.v in parenthesis for the alternative algorithm.",{"@attributes":{"id":"p-0195","num":"0206"},"figref":["FIG. 41","FIG. 41"]},{"@attributes":{"id":"p-0196","num":"0207"},"figref":["FIGS. 42-44","FIG. 42"],"b":["2","1"]},"A strand of DNA is a double helix\u2014there are really two strands with the complementary nucleotides, A\u21c4T and C\u21c4G, aligned. When performing analysis on a DNA string, often the complementary string is analyzed as well. To obtain the complementary string, the bases are complemented and the entire string is reversed, as the complement string is read from the other end. The reversal of the DNA string amounts to a reversal of the ordering of the pairs of bits in a word. This is a straightforward bfly or ibfly permutation.","The DNA sequence is transcribed by the cell into a sequence of amino acids or a protein. Often, the analysis of the genetic data is more accurate when performed on a protein basis, such as is done by the BLASTX program. A set of three bases, or 6 bits of data, corresponds to a protein codon. Translating the nucleotides to a codon requires a table lookup operation using each set of 6 bits as an index. An efficient algorithm can use pdep to distribute eight 6-bit fields on byte boundaries, and then use the result as a set of table indices for a parallel table lookup (ptlu) instruction to translate the bytes, as shown in . A parallel table lookup instruction takes as input a word consisting of packed indices, each index being used to read out an entry of a table. For example, with a 32 bit register word, and tables each of which have 256 entries, 8 bit indices can be packed into the word to read out 4 different tables in parallel. These 4 results can be used immediately as in , or they can be combined by combinatorial logic to provide one result word which can then be stored back into the processor's register file. The pdep instruction of the present invention is used in  to expand bits from a bit string into the 8 bit indices used for the parallel table lookup. Also, the pex instruction of the present invention could be utilized to implement retrieving the packed indices for the operand input for such a parallel table lookup instruction.","For example, to match a pattern comprising many features where \u201c1\u201d indicates a match and \u201c0\u201d indicates no match, arbitrary subsets of the binary \u201c1's\u201d can be efficiently collected and compressed with this parallel extract instruction. The resulting compressed bits can be used as indices into the parallel table lookup instruction. This enables very fast action depending on which patterns are matched.","When aligning two DNA sequences, certain algorithms such as the known BLASTZ program use a \u201cspaced seed\u201d as the basis of the comparisons. This means that n out of m nucleotides are used to start a comparison rather than a string of n consecutive nucleotides. The remaining slots effectively function as wild cards, often causing the comparison to yield better results. For example, BLASTZ uses 12 of 19 (or 14 of 22 nucleotides) as the seed for comparison. The program compresses the 12 bases and uses the seed as an index into a hash table. This compression is a pex operation selecting 24 of 38 bits, as illustrated in .",{"@attributes":{"id":"p-0201","num":"0212"},"figref":["FIG. 45","FIG. 45"]},"The present invention can also be used in random number generation and cryptology applications. Random numbers are very important in cryptographic computations for generating nonces, keys, random values, etc. Random number generators contain a source of randomness (such as a thermal noise generator) and a randomness extractor that transforms the randomness so that it has a uniform distribution. The INTEL random number generator uses a von Neumann extractor. This extractor breaks the input random bits, X=xxx. . . , into a sequence of pairs. If the bits in the pair differ, the first bit is output. If the bits are the same, nothing is output. This operation is equivalent to using a pex.v instruction on each word X from the randomness pool with the mask:\n\nMask=\u22250\u2225\u22250\u2225\u2003\u2003(21)\n\nor equivalently,\n\nMask=(\u2295(1))& 0\u2003\u2003(22)\n","A number of popular ciphers, such as DES, have permutations as primitive operations. Inclusion of permutation instructions such as bfly, ibfly (or grp) can greatly improve the performance of the inner loop of these functions. Also, these instructions can be used as powerful primitive operations in the design of the next generation of ciphers and hash functions (especially for the Cryptographic Hash Algorithm Competition (SHA-3)). Since all the pex and pdep instructions\u2014static, loop-invariant and variable\u2014are also very likely to be useful for cryptanalysis algorithms, they are indicated as \u201c?\u201d in Table 8.","Kernels for the above binary compression and decompression, steganography, transfer coding, bioinformatics translate, integer compression, and random number generation applications were coded and simulated using the SimpleScalar Alpha simulator enhanced to recognize our new instructions. The latencies of the instructions in the simulator are as given in Table 7.  shows performance results, normalized to the baseline Alpha ISA cycle counts. The processor with pex and pdep instructions exhibits speedups over the base ISA ranging from 1.13\u00d7 to 10.04\u00d7, with an average of 2.29\u00d7(1.94\u00d7 excluding the mg benchmark).","Random number generation exhibited the greatest speedup due to the fact that a variable pex.v operation is performed. A single pex.v instruction replaces a very long sequence of instructions that loops through the data and mask and conditionally shifts each bit of the input to the correct position of the output based on whether the corresponding bit of the mask is \u20180\u2019 or \u20181\u2019. Of the benchmarks for static pex and pdep, the simple bit compression and decompression functions exhibited the greatest speedup as these operations combine many basic instructions into one pex or pdep. The speedup is lower in the steganography encoding case because there are only 4 fields per word, and also in the uudecode and BLASTX translate case because there are fewer fields overall. The lowest speedups were for integer compression cases as a smaller fraction of the runtime is spent on compression or decompressing bit fields.","To evaluate the cost of implementing the advanced bit manipulation functional units described above in connection with , it is necessary to understand the implementation of the major components in such a functional unit. The most complex component is the hardware decoder that takes a register value (representing a bitmask) and turns it into the control bits of the stages of the butterfly or inverse butterfly datapath. Therefore, in order to evaluate the functional unit circuit latency and area, we must first define what is contained within the hardware decoder component. Provided below is an algorithm to obtain the n\/2\u00d7lg(n) butterfly or inverse butterfly control bits from the n-bit pdep or pex bitmask. A hardware decoder circuit can then be constructed which implements this algorithm. In the case of static pex or pdep instructions, the algorithm can be used by the compiler to generate the control bits for the inverse butterfly or butterfly datapath. In the case of dynamic or loop-invariant pex and pdep instructions, the hardware decoder is used.","The steps in the proof to Theorem 2 give an outline for how to decode the n-bit bitmask into controls for each stage of a butterfly datapath. For each right half of a stage of a subnetwork, we count the number of \u201c1\u201ds in that local right half of the mask, say k \u201c1\u201ds, and then set the k rightmost control bits to \u201c1\u201ds and the remaining bits to \u201c0\u201ds. This serves to keep block X in the local. R half and export Y to the local L half We then assume that we explicitly rotate Y and Z to be the rightmost bits in order in the local L half. Then, we iterate through the stages and come up with an initial set of control bits. After this, we eliminate the need for explicit rotations of Y and Z by modifying the control bits instead. This is accomplished by a left rotate and complement upon wrap around (LROTC) operation, rotating the control bits by the same amount obtained when assuming explicit rotations.","This process can be considerably simplified, as follows. First, note that when we modify control bits to compensate for a rotation in a given stage, we do so by propagating the rotation through all the subsequent stages. This means that when the control bits of a local L are modified, they are rotated and complemented upon wrap around by the number of \u201c1\u201ds in the local R, and by the number of \u201c1\u201ds in the local R of the preceding stage, and by the number of \u201c1\u201ds in all the local R\u2032s of all preceding stages up to the R in the first stage. In other words, the control bits of the local L are rotated by the total number of \u201c1\u201ds to its right in the bitmask.","Consider the example of . The control bit in stage 3 in the Lsubnetwork is initially a \u201c0\u201d when we assumed explicit rotations. We first rotated and complemented this bit by 3, the number of \u201c1\u201ds in R of the bitmask: 0\u21921\u21920\u21921 (). We then rotated and complemented this bit by another 1 position, the number of \u201c1\u201ds in Lof the bitmask: 1\u21920. This yielded the final control bit in . Overall we rotated this bit by 4, the total number of \u201c1\u201ds to the right of Lor to the right of bit position 6. This is a Parallel Prefix Population Count (PP_PP_POPCNT) of the bitstring from the rightmost bit to bit position 6.","Second, it is necessary to produce a string of k \u201c1\u201ds from a count (in binary) of k, to derive the initial control bits assuming explicit rotations. This can also be done with a LROTC operation, as illustrated in . We start with a zero string of the correct length and then for every position in the rotation, and we wrap around a \u201c0\u201d from the left and complement it to get a \u201c1\u201d on the right. The end result, after a LROTC by k bits, is a string of the correct length with k rightmost bits set to \u201c1\u201d and the rest set to \u201c0\u201d.","It is possible to combine these two facts: the initial control bits are obtained by a LROTC of a zero string the length of the local R by the PP_POPCNT of the bits in the bitmask in the local R and all bits to the right of it. We denote a string of k \u201c0\u201ds as 0. We specify a bitfield from bit h to bit v as {h:v}, where v is to the right of h. So,\n\n","Verification of the correctness of this approach is provided with reference to  as follows:\n\n","One interesting point is that, for stage 1, the population count of the odd multiples of n\/2bits is needed, for stage 2 the population counts of the odd multiples of n\/2bits is needed, for stage 3 the population counts of the odd multiples of n\/2bits is needed, and so on. Overall, the counts are needed of the k rightmost bits, for k=0 to n\u22122. Such counts can be provided using the prefix population counter of the present invention, discussed above.","The control bits for the inverse butterfly for a pdep or a pex operation can be obtained using Algorithm 1, with the one caveat that the controls for stage i of the butterfly datapath are routed to stage lg(n)\u2212i+1 in the inverse butterfly datapath. This can be shown using an approach similar to that shown earlier, except for working backwards from the final stage. Algorithm 1 decites the n mask bits into the nlg(n)\/2 control bits for pdep and pex.","The execution time of Algorithm 1 in software is approximately 1200 cycles on an Intel Pentium-D processor. This software routine is useful for static pex or pdep operations and perhaps for loop invariant pex or pdep if the amount of processing in the loop dwarfs the 1200 cycle execution time. However, for dynamic pex.v and pdep.v a hardware decoder is required which implements Algorithm 1 in order to achieve a high performance. Fortunately, Algorithm 1 just contains two basic operations, population_count and LROTC, both of which have straightforward hardware implementations.","The first stage of the decoder is the parallel prefix population counter, discussed above. This is a circuit that computes in parallel all the population counts of step 1 of Algorithm 1. The circuit is a parallel prefix network with each node performing carry-save addition (i.e. a set of full adders). The counters resemble carry shower counters in which the inputs are grouped into sets of three lines which are input into full adders. The sum and carry outputs of the full adders are each grouped into sets of three lines which are input to another stage of full adders and so on. The parallel prefix architecture resembles radix-3 Han-Carlson, a parallel prefix look-ahead carry adder that has lg(n)+1 stages with carries propagated to the odd positions in the extra final stage. The radix-3 nature stems from the carry shower counter design, as we group 3 lines to input to a full adder at each level. The similarity to Han-Carlson is due to the 1- and 2-bit counts being deferred to the end, similar to odd carries being deferred in the Han-Carlson adder. Thus, the counter has log(n)+2 stages.  depicts a dot diagram of the parallel prefix network.","One simplification of the counter is based on the properties of rotations\u2014that they are invariant when the rotation amount differs by the period of rotation. Thus, for the ith stage of the butterfly network, the PP_POPCNTs are only computed mod n\/2. For example, for the 64-bit hardware decoder, for the 32 butterfly stage 6 PP_POPCNTs corresponding to the odd multiples of n\/64, it is necessary only compute the PP_POPCNTs mod 2\u2014only the least significant bit; for the 16 butterfly stage 5 PP_POPCNTs, we need only compute the PP_POPCNTs mod 4\u2014the two least significant bits; and so on. Only the PP_POPCNT of 32 bits for stage 1 requires the full lg(n)-bit PP_POPCNT.",{"@attributes":{"id":"p-0218","num":"0239"},"figref":["FIGS. 49-50","FIG. 49","FIG. 49","FIG. 50"],"b":"2","sup":["m","m ","k"]},"The outputs from the decoders shown in  can be routed to the butterfly circuit and its application registers, and can be used for controls for butterfly circuit to perform the pdep instruction. Additionally, the outputs are routed to the inverse butterfly circuit and its application registers, reversing the order of the stages, to be used for the pex instruction.","The functional units shown in , , and  were tested for timing and circuit area. These functional units support static pex and pdep only (), loop invariant and dynamic pex.v and pdep.v as well (), and grp as well (). All three also support bfly and ibfly permutation instructions. The circuits in  are implemented with a 3-stage pipeline. The hardware decoder occupies the first 2 pipeline stages due to its slow parallel prefix population counter. The butterfly (or inverse butterfly) circuit is in the third stage.","The various functional units were coded in Verilog and synthesized using Synopsys Design Compiler mapping to a TSMC 90 nm standard cell library. The designs were compiled to optimize timing. The decoder circuit was initially compiled as one stage and then Design Compiler automatically pipelined the subcircuit. Timing and area figures are as reported by Design Compiler. We also synthesized a reference ALU using the same technology library as a reference for latency and area comparisons.","Table 9 below summarizes the timing and area for the circuits. This shows that the 64-bit functional unit in  supporting static pex and pdep has a shorter latency than that of a 64-bit ALU and about 90% of its area (in NAND-gate equivalents). However, to support variable and loop-invariant pex and pdep (as in ), which requires a hardware decoder (as described in detail above), the advanced bit manipulation functional unit will be 16% slower than an ALU and 2.25\u00d7 larger. To also support a fast implementation of the grp instruction, the proposed new unit will be 23% slower than an ALU and about 3.2\u00d7 larger in area.",{"@attributes":{"id":"p-0223","num":"0244"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Cycle","Relative","Area (NAND","Relative"]},{"entry":["Unit","time","cycle time","gate equiv.)","Area"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ALU","0.50 ns","1","\u20027.5K","1"]},{"entry":["FIG. 34:","0.48 as","0.95","\u20026.8K","0.90"]},{"entry":"pex, pdep"},{"entry":["FIG. 36:","0.58 ns","1.16","16.9K","2.25"]},{"entry":"pex.v, pdep.v"},{"entry":["FIG. 37: grp","0.62 ns","1.23","24.2K","3.22"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Table 10 shows the number of different circuit types, to give a sense for why the functional units supporting variable pex.v, pdep.v and grp are so much larger. It shows that supporting variable operations comes at a high price. The added complexity is due to the complex decoder combinational logic and to the additional pipeline registers and multiplexer logic. This explains why in Table 10, the variable circuits () have approximately 22-29% longer cycle time latencies compared to the static case (), due to the decoder complexity and pipeline overhead. They are also 2.5 to 3.6 times larger than the static case.",{"@attributes":{"id":"p-0225","num":"0246"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},"Butterfly and",{},{}]},{"entry":[{},"Pipeline","Inverse Butterfly"]},{"entry":["Unit","Registers","Circuits","Decoders","MUXes"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FIG. 34","0","2","0","1"]},{"entry":["FIG. 36","~9.25","2","1","13"]},{"entry":["FIG. 37","~14.5","3","2","14"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0226","num":"0247"},"figref":"FIG. 51","b":["300","300"]},{"@attributes":{"id":"p-0227","num":"0248"},"figref":"FIG. 52","b":["310","310","320","322","324","324"]},"Having thus described the invention in detail, it is to be understood that the foregoing description is not intended to limit the spirit or scope thereof. What is desired to be protected is set forth in the following claims."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing features of the invention will be apparent from the following Detailed Description of the Invention, taken in connection with the accompanying drawings, in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 3-4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 11-12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 17A-17B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIGS. 18A-18B","FIG. 17A-17B"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 19A-31"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 32-37"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 42-44"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIGS. 49-50"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 52"}]},"DETDESC":[{},{}]}
