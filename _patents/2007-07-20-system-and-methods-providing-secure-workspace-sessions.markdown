---
title: System and methods providing secure workspace sessions
abstract: System and methods providing secure workspace sessions is described. In one embodiment a method for providing multiple workspace sessions for securely running applications comprises steps of: initiating a first workspace session on an existing operating system instance running on the computer system, the first workspace session having a first set of privileges for running applications under that session; while the first workspace session remains active, initiating a second workspace session on the existing operating system instance running on the computer system, the second workspace session having a second set of privileges for running applications under the second workplace session; and securing the second workspace session so that applications running under the second workplace session are protected from applications running outside the second workspace session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08769268&OS=08769268&RS=08769268
owner: Check Point Software Technologies, Inc.
number: 08769268
owner_city: Redwood City
owner_country: US
publication_date: 20070720
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","COPYRIGHT STATEMENT","APPENDIX DATA","BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["The present application is related to the following commonly-owned, presently-pending application(s): application Ser. No. 11\/163,343, filed Oct. 14, 2005, entitled \u201cSystem and Methodology Providing Secure Workspace Environment\u201d. The disclosure of the foregoing application is hereby incorporated by reference in its entirety, including any appendices or attachments thereof, for all purposes.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","Computer Program Listing Appendix under Sec. 1.52(e): This application includes a transmittal under 37 C.F.R. Sec. 1.52(e) of a Computer Program Listing Appendix. The Appendix, which comprises text file(s) that are IBM-PC machine and Microsoft Windows Operating System compatible, includes the below-listed file(s). All of the material disclosed in the Computer Program Listing Appendix can be found at the U.S. Patent and Trademark Office archives and is hereby incorporated by reference into the present application.","Object Description: SourceCode.txt, size: 93774 Bytes, created: Jul. 11, 2007 12:40:42 PM; Object ID: File No. 1; Object Contents: Source code.","1. Field of the Invention","The present invention relates generally to computers and data processing applications and, more particularly, to system and methodology providing a secure workspace environment.","2. Description of the Background Art","Growth of Internet-based remote access technologies has lead to an increasing number of users working in unprotected or untrusted environments. Home users connect to their corporate networks via different VPN clients. People on vacation check their emails via public kiosks. Sales agents connect to their databases via wireless services in airports. Large networks now are not just broadband lines that connect offices in several states or countries, they are far more complicated and far less controlled at the end-points (e.g., at individual personal computers). As the number of mobile users grows, the number of potential threats also grows. Potential threats include, but are not limited to, phishing attacks, identity theft, trade secrets theft, and the like.","A network of the typical large organization can be protected with various tools. For example, a firewall is installed to protect a company's gateway. Anti-virus software is installed on the company's mail server to scan incoming and outgoing email. Anti-virus software can be also installed on individual end user computers. For remote users, SSL VPN or IPSEC VPN is available to connect to the company's network from remote sites. For managing these environments, IT departments typically develop and deploy a set of security rules (security policy) to endpoints. Notwithstanding the availability of these foregoing tools, corporate IT departments today still face difficulties in protecting managed computers within the corporations from the threats from the Internet.","Consider for instance a firm, XYZ trading firm, which employs a clerk named John Doe. John works with a firm-owned personal computer to connect to a business client-server application running on another one of the firm's computers. This \u201cbusiness application\u201d allows him to access all-important data: customer information, invoices, and inventory availability of items. Most of the data available to John is confidential. Sometimes John stays after work to browse and download free music from web sites. Recently, he downloaded and installed (without permission) a Tetris game for his own amusement during free time. Both of these seemingly innocent activities of John can lead to the leakage of important data, however. For example, many free music sites contain \u201cspyware,\u201d \u201cadware,\u201d or other malicious software (\u201cmalware\u201d). Free game downloads (e.g., Tetris download) in particular often conceal malware intended to steal confidential data. In this scenario, corporate firewall and antivirus software installed on an employee's computer often will not help. Corporate firewalls, for example, are frequently configured to allow HTTP traffic (i.e., port 80 is open); the HTTP protocol, in turn, can be used to download files, including unintentional (or intentional) downloading of malware. Importantly, antivirus (AV) software that may be running (e.g., on John's machine) is not guaranteed to detect spyware programs, especially those particularly developed to bypass the antivirus software.","Given the risks posed by the above, some attempts have been made to address the problem. The simplest way is to apply a strict security policy: prohibit Internet traffic for computers where important business applications are installed. In many cases this will not work, however, since Internet connectivity is a daily tool for many people. Employees need Internet access in order to get news, search information, visit site of competitors, get email, use online applications and services, and so forth. The simplest approach is therefore not a practical solution for most firms.","Another approach is to use two computers, one for internal business applications and one to access the Internet. This is the most secure approach, but also the most expensive and inconvenient. The cost grows not only because of the hardware duplication, but management of the firm's IT (information technology) infrastructure becomes more complex and expensive. The total cost of ownership (TCO) eventually grows to an unsustainable level. For example, consider how an employee or clerk should send and receive email. If email (client) software is installed on the same computer where an important business application is installed, special precautions must be taken to prevent malicious software distributed by email. Although the firm's system administrator may install antivirus to scan email on-the-fly, malware can easily bypass such protections; for example, malware may be hidden in a password protected archive (e.g., ZIP) file. If the email client is installed on the computer with HTTP access enabled, the system administrator must also worry about how data may be safely imported from the email system into the business application. Given these shortcomings, the approach is reserved for situations where high costs and inconvenience can be justified, for example in banking and military deployments.","Another approach involves the use of separate user profiles. When working with the business application, the employee (e.g., John) is required to use a special OS (operating system) profile\u2014that is, one requiring that he log-in under a username with special privileges. When working with Internet, he would use another profile. Microsoft\u00ae Windows XP supports somewhat fast profile switching. In spite of these improvements in this area, this approach is not widely used, perhaps for obvious reasons: interference with usability and difficulty of configuration make the approach relatively unattractive.","What is needed is a solution that protects unmanaged computers from threats posed by Internet connectivity. For example, such a solution should allow a user to do online payments from his home personal computer without the worry of Internet-borne threats. However, such a solution should provide this protection without high costs or inconvenience. The present invention fulfills this and other needs.","System and methods providing secure workspace sessions is described. In one embodiment, for example, in a computer system, a method of the present invention is described for providing multiple workspace sessions for securely running applications, the method comprises steps of: initiating a first workspace session on an existing operating system instance running on the computer system, the first workspace session having a first set of privileges for running applications under that session; while the first workspace session remains active, initiating a second workspace session on the existing operating system instance running on the computer system, the second workspace session having a second set of privileges for running applications under the second workplace session; and securing the second workspace session so that applications running under the second workplace session are protected from applications running outside the second workspace session.","In another embodiment, for example, a system of the present invention providing that allows users to run software programs in a plurality of workspace sessions subject to separate security rules of a security policy is described that comprises: a computer running under an operating system; a plurality of software programs for use by users of the computer; a configurable security policy specifying security rules applicable to the software programs; a session manager for creating a plurality of workspace sessions under the operating system with each of the sessions subject to separate security rules of the security policy and isolated from other workspace sessions, thereby allowing software programs to run in a secure manner subject to the separate security rules; and a module for enforcing compliance with security rules of the security policy by software programs running in each of the workspace sessions.","Glossary","The following definitions are offered for purposes of illustration, not limitation, in order to assist with understanding the discussion that follows.","Firewall: A firewall is a set of related programs, typically located at a network gateway server, that protects the resources of a private network from other networks by controlling access into and out of the private network. (The term also implies the security policy that is used with the programs.) A firewall, working closely with a router program, examines each network packet to determine whether to forward it toward its destination. A firewall may also include or work with a proxy server that makes network requests on behalf of users. A firewall is often installed in a specially designated computer separate from the rest of the network so that no incoming request directly accesses private network resources.","HTTP: HTTP is the acronym for HyperText Transfer Protocol, which is the underlying communication protocol used by the World Wide Web on the Internet. HTTP defines how messages are formatted and transmitted, and what actions Web servers and browsers should take in response to various commands. For example, when a user enters a URL in his or her browser, this actually sends a HTTP command to the Web server directing it to fetch and transmit the requested Web page. Further description of HTTP is available in \u201cRFC 2616: Hypertext Transfer Protocol\u2014HTTP\/1.1,\u201d the disclosure of which is hereby incorporated by reference. RFC 2616 is available from the World Wide Web Consortium (W3C), and is available via the Internet (e.g., currently at www.w3.org\/Protocols\/). Additional description of HTTP is available in the technical and trade literature, see e.g., Stallings, W., \u201cThe Backbone of the Web,\u201d BYTE, October 1996, the disclosure of which is hereby incorporated by reference.","Network: A network is a group of two or more systems linked together. There are many types of computer networks, including local area networks (LANs), virtual private networks (VPNs), metropolitan area networks (MANs), campus area networks (CANs), and wide area networks (WANs) including the Internet. As used herein, the term \u201cnetwork\u201d refers broadly to any group of two or more computer systems or devices that are linked together from time to time (or permanently).","Portal: A portal provides an individualized or personalized view of multiple resources (e.g., Web sites) and services. A portal typically offers a single access point (e.g., browser page) providing access to a range of information and applications. A portal assembles information from a number of different sources (e.g., Web sites and applications) enabling a user to quickly receive information without having to navigate to a number of different Web sites. A portal also typically enables a user to obtain a personalized view of information and applications by organizing and grouping information and services for presentation to users.","TCP\/IP: TCP\/IP stands for Transmission Control Protocol\/Internet Protocol, the suite of communications protocols used to connect hosts on the Internet. TCP\/IP uses several protocols, the two main ones being TCP and IP. TCP\/IP is built into the UNIX operating system and is used by the Internet, making it the de facto standard for transmitting data over networks. For an introduction to TCP\/IP, see e.g., \u201cRFC 1180: A TCP\/IP Tutorial\u201d, the disclosure of which is hereby incorporated by reference. A copy of RFC 1180 is available via the Internet (e.g., currently at www.ietf.org\/rfc\/rfc1180.txt).","Thread: A thread refers to a single sequential flow of control within a program. Operating systems that support multi-threading enable programmers to design programs whose threaded parts can execute concurrently. In some systems, there is a one-to-one relationship between the task and the program, but a multi-threaded system allows a program to be divided into multiple tasks. Multi-threaded programs may have several threads running through different code paths simultaneously.","URL: URL is an abbreviation of Uniform Resource Locator, the global address of documents and other resources on the World Wide Web. The first part of the address indicates what protocol to use, and the second part specifies the IP address or the domain name where the resource is located.","Winsock: Windows Sockets 2 (Winsock) is a Microsoft-provided interface that enables programmers to create advanced Internet, intranet, and other network-capable applications to transmit application data across the wire, independent of the network protocol being used. With Winsock, programmers are provided access to advanced Microsoft Windows networking capabilities such as multicast and Quality of Service (QOS). Winsock follows the Windows Open System Architecture (WOSA) model; it defines a standard service provider interface (SPI) between the application programming interface (API), with its exported functions and the protocol stacks. It uses the sockets paradigm that was first popularized by Berkeley Software Distribution (BSD) UNIX. It was later adapted for Windows in Windows Sockets 1.1, with which Windows Sockets 2 applications are backward compatible. Winsock programming was previously centered around TCP\/IP. Some programming practices that worked with TCP\/IP do not work with every protocol. As a result, the Windows Sockets 2 API adds functions where necessary to handle several protocols. For further information regarding Winsock, see e.g., \u201cWinsock Reference\u201d, available from Microsoft Corporation, the disclosure of which is hereby incorporated by reference. A copy of this documentation is available via the Internet (e.g., currently at msdn.microsoft.com\/library\/default.asp?url=\/library\/en-us\/winsock\/winsock\/winsock_reference.asp).","XML: XML stands for Extensible Markup Language, a specification developed by the World Wide Web Consortium (W3C). XML is a pared-down version of the Standard Generalized Markup Language (SGML), a system for organizing and tagging elements of a document. XML is designed especially for Web documents. It allows designers to create their own customized tags, enabling the definition, transmission, validation, and interpretation of data between applications and between organizations. For further description of XML, see e.g., \u201cExtensible Markup Language (XML) 1.0\u201d, (2nd Edition, Oct. 6, 2000) a recommended specification from the W3C, the disclosure of which is hereby incorporated by reference. A copy of this specification is available via the Internet (e.g., currently at www.w3.org\/TR\/REC-xml).","Introduction","Referring to the figures, exemplary embodiments of the invention will now be described. The following description will focus on the presently preferred embodiment of the present invention, which is implemented in desktop and\/or server software (e.g., driver, application, or the like) operating in an Internet-connected environment running under an operating system, such as the Microsoft Windows operating system. The present invention, however, is not limited to any one particular application or any particular environment. Instead, those skilled in the art will find that the system and methods of the present invention may be advantageously embodied on a variety of different platforms, including Macintosh, Linux, Solaris, UNIX, FreeBSD, and the like. Therefore, the description of the exemplary embodiments that follows is for purposes of illustration and not limitation. The exemplary embodiments are primarily described with reference to block diagrams or flowcharts. As to the flowcharts, each block within the flowcharts represents both a method step and an apparatus element for performing the method step. Depending upon the implementation, the corresponding apparatus element may be configured in hardware, software, firmware, or combinations thereof.","Computer-Based Implementation","Basic System Hardware and Software (e.g., for Desktop and Server Computers)","The present invention may be implemented on a conventional or general-purpose computer system, such as an IBM-compatible personal computer (PC) or server computer.  is a very general block diagram of a computer system (e.g., an IBM-compatible system) in which software-implemented processes of the present invention may be embodied. As shown, system  comprises a central processing unit(s) (CPU) or processor(s)  coupled to a random-access memory (RAM) , a read-only memory (ROM) , a keyboard , a printer , a pointing device , a display or video adapter  connected to a display device , a removable (mass) storage device  (e.g., floppy disk, CD-ROM, CD-R, CD-RW, DVD, or the like), a fixed (mass) storage device  (e.g., hard disk), a communication (COMM) port(s) or interface(s) , a modem , and a network interface card (NIC) or controller  (e.g., Ethernet). Although not shown separately, a real time system clock is included with the system , in a conventional manner.","CPU  comprises a processor of the Intel Pentium family of microprocessors. However, any other suitable processor may be utilized for implementing the present invention. The CPU  communicates with other components of the system via a bi-directional system bus (including any necessary input\/output (I\/O) controller circuitry and other \u201cglue\u201d logic). The bus, which includes address lines for addressing system memory, provides data transfer between and among the various components. Description of Pentium-class microprocessors and their instruction set, bus architecture, and control lines is available from Intel Corporation of Santa Clara, Calif. Random-access memory  serves as the working memory for the CPU . In a typical configuration, RAM of sixty-four megabytes or more is employed. More or less memory may be used without departing from the scope of the present invention. The read-only memory (ROM)  contains the basic input\/output system code (BIOS)\u2014a set of low-level routines in the ROM that application programs and the operating systems can use to interact with the hardware, including reading characters from the keyboard, outputting characters to printers, and so forth.","Mass storage devices ,  provide persistent storage on fixed and removable media, such as magnetic, optical or magnetic-optical storage systems, flash memory, or any other available mass storage technology. The mass storage may be shared on a network, or it may be a dedicated mass storage. As shown in , fixed storage  stores a body of program and data for directing operation of the computer system, including an operating system, user application programs, driver and other support files, as well as other data files of all sorts. Typically, the fixed storage  serves as the main hard disk for the system.","In basic operation, program logic (including that which implements methodology of the present invention described below) is loaded from the removable storage  or fixed storage  into the main (RAM) memory , for execution by the CPU . During operation of the program logic, the system  accepts user input from a keyboard  and pointing device , as well as speech-based input from a voice recognition system (not shown). The keyboard  permits selection of application programs, entry of keyboard-based input or data, and selection and manipulation of individual data objects displayed on the screen or display device . Likewise, the pointing device , such as a mouse, track ball, pen device, or the like, permits selection and manipulation of objects on the display device. In this manner, these input devices support manual user input for any process running on the system.","The computer system  displays text and\/or graphic images and other data on the display device . The video adapter , which is interposed between the display  and the system's bus, drives the display device . The video adapter , which includes video memory accessible to the CPU , provides circuitry that converts pixel data stored in the video memory to a raster signal suitable for use by a cathode ray tube (CRT) raster or liquid crystal display (LCD) monitor. A hard copy of the displayed information, or other information within the system , may be obtained from the printer , or other output device. Printer  may include, for instance, an HP Laserjet printer (available from Hewlett Packard of Palo Alto, Calif.), for creating hard copy images of output of the system.","The system itself communicates with other devices (e.g., other computers) via the network interface card (NIC)  connected to a network (e.g., Ethernet network, Bluetooth wireless network, or the like), and\/or modem  (e.g., 56K baud, ISDN, DSL, or cable modem), examples of which are available from 3Com of Santa Clara, Calif. The system  may also communicate with local occasionally-connected devices (e.g., serial cable-linked devices) via the communication (COMM) interface , which may include a RS-232 serial port, a Universal Serial Bus (USB) interface, or the like. Devices that will be commonly connected locally to the interface  include laptop computers, handheld organizers, digital cameras, and the like.","IBM-compatible personal computers and server computers are available from a variety of vendors. Representative vendors include Dell Computers of Round Rock, Tex., Hewlett-Packard of Palo Alto, Calif., and IBM of Armonk, N.Y. Other suitable computers include Apple-compatible computers (e.g., Macintosh), which are available from Apple Computer of Cupertino, Calif., and Sun Solaris workstations, which are available from Sun Microsystems of Mountain View, Calif.","A software system is typically provided for controlling the operation of the computer system . The software system, which is usually stored in system memory (RAM)  and on fixed storage (e.g., hard disk) , includes a kernel or operating system (OS) which manages low-level aspects of computer operation, including managing execution of processes, memory allocation, file input and output (I\/O), and device I\/O. The OS can be provided by a conventional operating system, Microsoft Windows NT, Microsoft Windows 2000, Microsoft Windows XP, or Microsoft Windows Vista (Microsoft Corporation of Redmond, Wash.) or an alternative operating system, such as the previously mentioned operating systems. Typically, the OS operates in conjunction with device drivers (e.g., \u201cWinsock\u201d driver\u2014Windows' implementation of a TCP\/IP stack) and the system BIOS microcode (i.e., ROM-based microcode), particularly when interfacing with peripheral devices. One or more application(s), such as client application software or \u201cprograms\u201d (i.e., set of processor-executable instructions), may also be provided for execution by the computer system . The application(s) or other software intended for use on the computer system may be \u201cloaded\u201d into memory  from fixed storage  or may be downloaded from an Internet location (e.g., Web server). A graphical user interface (GUI) is generally provided for receiving user commands and data in a graphical (e.g., \u201cpoint-and-click\u201d) fashion. These inputs, in turn, may be acted upon by the computer system in accordance with instructions from OS and\/or application(s). The graphical user interface also serves to display the results of operation from the OS and application(s).","The above-described computer hardware and software are presented for purposes of illustrating the basic underlying desktop and server computer components that may be employed for implementing the present invention. For purposes of discussion, the following description will present examples in which it will be assumed that there exists at least one computer that communicates with other computers over a network, such as one or more \u201cclients\u201d (e.g., desktop computers) that communicate with various \u201cservers\u201d (e.g., Web servers) over the Internet. The present invention, however, is not limited to any particular environment or device configuration. In particular, a client\/server distinction is not necessary to the invention, but is used to provide a framework for discussion. Instead, the present invention may be implemented in any type of system architecture or processing environment capable of supporting the methodologies of the present invention presented in detail below.","Overview of Base Secured Workspace","In accordance with the present invention, a fully secured environment is provided in the framework of the user's usual operating system (host OS, such as Microsoft Windows). The main Input\/Output (I\/O) functions of the host OS are hooked or intercepted so that all information, including session information that applications save to disk, is really stored in encrypted form to prevent unauthorized access. In this manner, unauthorized or malicious users, even those that have full access to the host OS, are prevented from accessing the information or data created in the secured environment.","This process occurs in a fashion that is fully transparently for both applications and users. Applications think that they are working with usual OS functions and that they are storing information to usual storages. The user sees the secured environment as a \u201cvirtual desktop,\u201d a Secured Desktop. The user can easily switch between secured and not secured (usual) desktops, for example by hotkeys or GUI elements. By intercepting all (relevant) OS functions, the approach of the present invention can control all applications running on the Secured Desktop, allowing or denying them the ability to do any specified action. This approach is used in conjunction with a configurable security policy that specifies behavior or actions of software programs that are, or are not, permitted. For example, it is possible to specify what applications can be run on the virtual desktop at all. In this manner, the present invention may prevent the launching of any noncompliant software (i.e., computer programs that would violate the policy), including banning malicious software (e.g., spyware and computer viruses) that can steal information or even damage the system.","In the currently preferred embodiment, a Secure Workspace System (SWS) is provided that gives the user a secured area for web sessions, with a clear visual separation from non-secure areas. The workspace protects sensitive session information while a given session is active and performs total clean up after the session is finished. The workspace enables protection in user space mode, without developing device drivers (guest user rights are needed to run the Secure Workspace System). The workspace performs API hooking at the lowest possible level in the user space (e.g., native Windows NT API (NTDLL)), so that applications that work directly with this layer will not bypass the hooking mechanism.","System Components","The Secure Workspace System (SWS) works at the application level on the client side and prevents unauthorized access to a user's confidential information. The SWS creates a new secured, virtual desktop, which the user can work on, and intercepts file\/registry operations for all applications started on this desktop. The system saves all sensitive user data on the user's local machine in encrypted form and deletes it when the session is terminated.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 2A","b":["200","210","220","225","227","227","227"]},"During operation, the manager  starts a usual Windows shell (e.g., explorer.exe) with an injection of the hooks engine  (cpsws.dll) on the created desktop. The injected hooks engine  in turn hooks \u201cprocess creation\u201d routines and automatically injects itself into all newly created processes. In this manner, each application  on the secure desktop receives a workspace hook . In the Microsoft Windows environment, for example, the injected DLL hooks API calls (invocations) by overwriting hooked NTDLL routines entry points with JMP instructions, thus redirecting them to code inside the cpsws.dll. In this fashion, the system can be assured that any kind of call to NTDLL API (including from Win32 DLL, and from the application itself with GetProcAddress or import table) will be first intercepted by the SWS. This allows the SWS  to control each application's interaction with the underlying operating system , including the operating system's information storage  (e.g., Windows' registry, file system, and Clipboard).","In the currently preferred embodiment, the hooks engine  monitors the following API functions:","ZwClose","ZwQueryObject","ZwQueryVolumeInformationFile","ZwSetVolumeInformationFile","ZwQueryQuotaInformationFile","ZwSetQuotaInformationFile","ZwDuplicateObject","ZwCreateFile","ZwOpenFile","ZwDeleteFile","ZwFlushBuffersFile","ZwCancelloFile","ZwReadFile","ZwReadFileScatter","ZwWriteFile","ZwWriteFileGather","ZwLockFile","ZwUnlockFile","ZwQueryAttributesFile","ZwQueryFullAttributesFile","ZwQueryInformationFile","ZwSetInformationFile","ZwQueryDirectoryFile","ZwNotifychangeDirectoryFile","ZwFsControlFile","ZwQueryEaFile","ZwSetEaFile","ZwCreateSection","ZwOpenSection","ZwQuerySection","ZwExtendSection","ZwMapViewOfSection","ZwUnmapViewOfSection","ZwAreMappedFilesTheSame","ZwCreateProcess","ZwOpenProcess","ZwTerminateProcess","ZwCreateMutant","ZwOpenMutant","ZwCreateSemaphore","ZwOpenSemaphore","ZwCreateEvent","ZwOpenEvent","CreateProcessW","CreateProcessA","WinExec","ExitWindowsEx","StartDocA","StartDocW","ZwCreateKey","ZwOpenKey.","CoGetClassObject","CoLoadLibrary","CoCreateInstance","CoCreateInstanceEx","SetClipboardData","GetClipboardData","Access to different system resources are allowed or denied based on the policy (cpsws.xml). The hooks engine  allows applications started on the secure desktop to create files and registry keys only inside a secure user profile. These items will be encrypted on the host file system and will be deleted when the given session is terminated.",{"@attributes":{"id":"p-0110","num":"0109"},"figref":["FIG. 2B","FIG. 2A","FIG. 2A","FIG. 2B"],"b":["210","225","227"]},"As illustrated in the diagram, every loaded in-process module, including usual system modules such as kernel32.dll, shell32.dll, and the like (even main application executable), can communicate with the NT kernel via ntdll.dll calls. Use of the mechanism of ntdll.dll hooking allows maximum possible in user-space control of all data flows between a given secured application and hardware persistent storage. In this manner, the cpsws.dll can dispatch all files-related functions, including those used by the application. The cpsws.dll encrypts all data on-the-fly, and stores it to the target persistent storage in encrypted form.","The cpsws.dll also controls creation of out-of-process COM objects. It does this by hooking the particular ole32.dll functions that are used for object creation. It intercepts creating out-of-process COM servers and creates their processes itself. Some user32.dll functions, such as SetClipboardData and GetClipboardData, also may be hooked to allow on-the-fly encryption of data copied to clipboard by secured applications. In the currently preferred embodiment, additional kernel32.dll and shell32.dll functions are hooked to control process creation and file operations at a higher level. In this manner, the SWS may, for example, show user alert messages about rejected operations, including denied program startup, denied saving files to non-secured locations, and the like.","Initializing the Secure Desktop\/Workspace",{"@attributes":{"id":"p-0114","num":"0113"},"figref":"FIGS. 3A-B","b":["300","301","227"]},"\/url=\u201cmain_page_url\u201d\u2014URL, that will be opened in default browser after secured desktop starts;","\/cookie=\u201cserver;cookiename=cookievalue\u201d\u2014secured cookie, that will be inserted into each HTTP(-S) request to the defined server; and","\/shell=\u201cshell_id\u201d\u2014shell identifier; refers to corresponding tag in the secured workspace policy; defines a shell that will be started on secure desktop (explorer.exe by default).","The policy file (cpsws.xml) may now be loaded, at step . At step , the secure workspace manager (cpsws.exe) creates a pipe server that will listen and dispatch requests from injected applications. The pipe server uses a secure cookie as an authorization password on every client connect, so only processes that started with the SWS's dll can use this pipe. Next, at step , the hooks engine  (cpsws.dll) is loaded into the SWS; this process is referred to herein as \u201cself-injection.\u201d The hooks engine (cpsws.dll) hooks all necessary API (for example, for Windows: ntdll.dll, kernel32.dll, ole32.dll, user32.dll, and the like), and also injects itself into every child process that is created by an already-injected process. This is illustrated at step .","As shown at step , the method proceeds to create a virtual user profile (according to the policy), as follows:","Set files directory to: %USERPROFILE%\\CPSecured;","Set Registry to: HKCU\\CPSecured;","Initialize shortcuts;","Import files from original profile; and","Create profile files for Mozilla Firefox.","At step , the method creates a virtual desktop, for example, via Windows' CreateDesktop( ) WinAPI function. The method proceeds, at step , to create and initialize an empty Discretionary Access Control List (DACL) security descriptor and assign it to the new desktop. This disallows any other application from starting or installing input hooks on the secure desktop. Any additional initialization may now be performed (e.g., get current wallpaper), as indicated at step . The machine's shell (e.g., explorer.exe) is started on the created virtual desktop, at step . Since injection occurred via the hooks engine (cpsws.dll), the shell (explorer.exe) will be injected by the hooks engine (cpsws.dll) on startup. This allows the system of the present invention to control applications that will be started on the virtual desktop. Finally, at step , the method  switches operation of the machine to the just-created desktop, if all preceding operations have succeeded.","API Hooks","(a) API Hooks Initialization (dll)","During processing of a Windows' DllMain function (i.e., the optional entry point into a Windows dynamic-link library (DLL)), the hooks engine (cpsws.dll) hooks to a list of functions of ntdll.dll, kernel32.dll, ole32.dll, and user32.dll (i.e., operating system applications programming interface (API) executable files). Then it waits while the parent process writes a secure cookie to its memory (e.g., using WriteMemory API). This allows the system of the present invention to further distinguish pipe clients in the SWS.","(b) API Hooks Processing (dll)","The API hooks processing proceeds as follows. Every created thread of the already-secured application is switched to the secure desktop. The desktop handle is retrieved from the hooks engine (cpsws.dll) using Windows DLL thread attachment program logic (i.e., specifying the Windows DLL_THREAD_ATTACH flag). The \u201cprocess creation\u201d functions (e.g., Windows' CreateProcessW, CreateProcessA functions) are hooked to allow injection of cpsws.dll at the point when a new process is going to start. When such a new process has been created, the hooks engine (cpsws.dll) writes a secure token to its memory. A child process may use this as an authorization password for the pipe server.","File functions are intercepted to allow \u201cvirtualization\u201d and encryption of the file system, as follows. When an application asks the system to create file, the hooks engine (cpsws.dll) checks the file path in order to determine if creating a file in this directory is allowed by policy. If it is allowed, the secure workspace manager (cpsws.exe) generates a random string that will correspond to requested file name, thus allowing the file to be physically created with a secure name.","On write operation, the hooks engine (cpsws.dll) checks the user's rights to change files in the given target directory, according to the policy file. If sufficient rights exist, the SWS encrypts all data \u201con-the-fly\u201d and writes it to a real file in secure form. Additional information is written to file, including for example encryption algorithm ID and real size of file (recorded as housekeeping information, for use with encryption algorithms that can encrypt data only by blocks with constant length). This additional data is not visible to the application, but is instead used by the hooks engine (cpsws.dll) internally.","On read operation, the hooks engine (cpsws.dll) reads information from the file header, and reads a corresponding fragment of data from the file (which can be larger than requests, due to block encryption). The file information may now be decrypted and returned as decrypted data to the requesting application. In response to a \u201cfiles listing\u201d request, the hooks engine (cpsws.dll) checks the user's rights to list the particular directory. If the user has sufficient rights, the SWS reads corresponding information from the file headers and returns the real filename and size (which recall was written as a field of the file header).","When an application creates a memory-mapped section of a file, the SWS creates a corresponding in-memory section, with size of file. The system may now read decrypted content of the file to this section and give the calling application (caller) a corresponding handle to this section. If an application specifies a \u201csection name\u201d in the call, the hooks engine (cpsws.dll) can change the name to separate sections created on the respective secure and default desktops. Desired behavior is preferably configured in the policy file (cpsws.xml). When an application calls usual ReadFile (Windows API function to read data from a file) or WriteFile (Windows API function to write data to a file) functions for files that are mapped to memory, the SWS satisfies the calls with simple read\/write of data from section memory. When an application requests closing of the section, data stored in the section is flushed to the corresponding file and the section is closed.","De-Initialization of the Secure Desktop\/Workspace","In response to a proper request, the SWS of the present invention may be shutdown. Before closing, it optionally queries all running applications for shutdown, terminates all secured application(s), and then deletes all secured data from local storages, to prevent information leaks and quits. (Specific method steps for effecting de-initialization are described in detail below.)","Security Analysis","The prevention of information leaks from the SWS will now be discussed.","System Swap File","The underlying operating system (OS) may save memory pages of applications running on secure desktop into a global system swap file. The SWS itself does not presently solve this problem in the currently preferred embodiment. However, the issue may be addressed by changes elsewhere. For example, the swap file itself may be written to an OS-supported volume encryption (e.g., Microsoft Windows Vista Windows full volume encryption). Additionally, in those deployments already employing large amounts of physical memory (RAM), the amount of data paged to disk for virtual memory management (VMM) may constitute a rather insignificant amount of application data. Further, those skilled in the art will appreciate that the SWS may be designed to include kernel-level logic to supplant the OS's native swap file with an encrypted one.","Registry Keys","In the currently preferred embodiment, the SWS does not encrypt registry entries created by applications on the secure desktop. These are deleted when a given session is terminated. However, it is possible that during unexpected session termination sensitive data will be left in the current user file (ntuser.dat). The issue may be addressed by encrypting registry items in the same way as files.","Analyzing Secure User Profile","Content and names of files created on the secure desktop are encrypted on the host file system. However, the corresponding encryption\/decryption key is stored in memory (subject to swapping via the swap file); similarly, the directory structure is potentially visible outside the secure desktop. In embodiments contemplating use of electronic codebook (ECB) mode, there is the potential disadvantage that identical plaintext blocks are encrypted to identical ciphertext blocks; the approach does not hide data patterns. The issue may be addressed by using cipher-block chaining (CBC) mode. In the cipher-block chaining (CBC) mode, each block of plaintext is XORed with the previous ciphertext block before being encrypted. This way, each ciphertext block is dependent on all plaintext blocks up to that point. Further, use of a fully-virtual file system without correlation with host PC real file system provides additional protection.","Leaks Through Non-Controlled API","Applications running on the secure desktop can exchange sensitive data through non-controlled API with non-secured applications on the default desktop (e.g., non-hooked out-of-process COM servers started by main system SVCHOST.EXE service). This issue may be addressed by hooking all API calls that can exchange sensitive information. In this manner, the SWS does not allow applications that can leak information to be started on the secure desktop.","Detailed Internal Operation","The following description presents method steps\/program logic that may be implemented using processor-executable instructions, for directing operation of a device under processor control. The processor-executable instructions may be stored on a computer-readable medium, such as CD, DVD, flash memory, or the like. The processor-executable instructions may also be stored as a set of downloadable processor-executable instructions, for example, for downloading and installation from an Internet location (e.g., Web server).","Additional DLL Loader","The present invention includes an additional DLL loader that provides a mechanism to start new processes with forced loading of an additional DLL in the address space of the new process. This is done by creating a new process in suspended state, allocating a small memory location in its address space, and writing to it the code that loads the necessary DLL and that jumps to beginning of process execution code. The context of the main thread of the created process is then changed, so that the computer processor's instruction pointer register (e.g., Intel x86 Extended Instruction Pointer (EIP) register) points to this created code. The thread is now resumed. After resuming, the process' thread executes code that loads the necessary DLL into the process (space) and continues usual processing of executable code. This may be implemented as follows (e.g., illustrated by the following pseudocode snippets):",{"@attributes":{"id":"p-0144","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1: typedef struct DLL_LOADER",{}]},{"entry":["2: {",{}]},{"entry":["3: unsigned char LoaderCode[LOADER_CODE_SIZE];",{}]},{"entry":["4: char DllPathName[MAX_PATH];",{}]},{"entry":["5: }DLL_LOADER, *PDLL_LOADER;",{}]},{"entry":["6:",{}]},{"entry":["7: void",{}]},{"entry":["8: AddAsmInstruction",{}]},{"entry":["9: (PBYTE &pTemp, int InstructionId, int InstructionOperand)",{}]},{"entry":["10: {",{}]},{"entry":["11: memcpy(pTemp, asm_instruction_code_table[InstructionId],",{}]},{"entry":["asm_instruction_code_size[InstructionId]);",{}]},{"entry":["12: pTemp += asm_instruction_code_size[InstructionId]",{}]},{"entry":["13: memcpy(pTemp, &InstructionOperand,sizeof(int));",{}]},{"entry":["14: pTemp += sizeof(int);",{}]},{"entry":["15: }",{}]},{"entry":["16:",{}]},{"entry":["17: void",{}]},{"entry":["18: StartProcessWithDll",{}]},{"entry":["19: (LPTCSTR pszProcessImage, LPTCSTR pszDllPathName)",{}]},{"entry":["20: {",{}]},{"entry":["21: STARTUPINFO si;",{}]},{"entry":["22: PROCESS_INFORMATION pi;",{}]},{"entry":["23: CreateProcess(pszProcessImage, pszProcessImage, NULL, NULL,",{}]},{"entry":["FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);",{}]},{"entry":["24: CONTEXT context;",{}]},{"entry":["25: GetThreadContext(pi.hThread, &context);",{}]},{"entry":["26: PVOID pDllLoaderRemote=VirtualAllocEx(pi.hProcess, NULL,",{}]},{"entry":["sizeof(DLL_LOADER), NEW_CODE,",{}]},{"entry":["PAGE_EXECUTE_READWRITE);",{}]},{"entry":["27: DLL_LOADER DllLoaderLocal;",{}]},{"entry":["28: strcpy(DllLoaderLocal.DllPathName,pszDllPathName);",{}]},{"entry":["29: PBYTE pTemp=(PBYTE)&pDllLoaderLocal;",{}]},{"entry":["30: AddAsmInstruction(pTemp, ASM_PUSH, pDllLoaderRemote +",{}]},{"entry":["LOADER_CODE_SIZE);\/\/push pointer to DllPathName to stack",{}]},{"entry":["31: AddAsmInstruction(pTemp, ASM_CALL, &LoadLibrary);",{}]},{"entry":["\/\/call LoadLibrary with pushed parameter",{}]},{"entry":["32: AddAsmInstruction(pTemp, ASM_JMP, context.eip);\/\/jmp to",{}]},{"entry":["original process code",{}]},{"entry":["33: WriteProcessMemory(pi.hProcess, pDllLoaderRemote,",{}]},{"entry":["&pDllLoaderLocal, sizeof(pDllLoaderLocal), NULL);",{}]},{"entry":["34: context.eip = pDllLoaderRemote;",{}]},{"entry":["35: ResumeThread(pi.hThread);",{}]},{"entry":"36: }"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Of particular interest, the AddAsmInstruction (helper) method call at line 30 serves to push a pointer to the DLL path name onto the current stack (e.g., x86 stack). Now, the helper method is again invoked at line 31 for purposes of calling the LoadLibrary (Windows API call) with the pushed parameter, thereby forcing the loading of the DLL (whose name is referenced at line 30). Then, at line 32, the helper method is invoked for purposes of effecting a jump (JMP instruction) back to the original process code.","Hooks Engine","The hooks engine provides a generic DLL that functions as an interception mechanism in its own processes. The basic approach is to overwrite part of the DLL code in memory, so that a given target function instead calls wrapper code immediately upon execution. Here, the start of the target DLL function is disassembled, with its old (original) code being saved in a newly allocated memory block. The original site of this code is overwritten with a simple jump (JMP) instruction that calls the wrapper function. In this manner, the wrapper function gains control, and can process the API call itself or call the original DLL function with optionally changed input parameters. Core functionality of the hooks engine may be implemented as follows (e.g., illustrated by the following pseudocode snippets):",{"@attributes":{"id":"p-0148","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1:","typedef struct ORIGINAL_CALL"]},{"entry":["2: ","{"]},{"entry":["3: ","unsigned char OriginalCode[MAX_ORIGINAL_CODE_SIZE];"]},{"entry":["4:","unsigned char"]},{"entry":[{},"JmpToOtherOriginalCode[asm_instruction_code_size[ASM_JMP]+"]},{"entry":[{},"sizeof(int)]"]},{"entry":["5:","}ORIGINAL_CALL, *PORIGINAL_CALL;"]},{"entry":["6:",{}]},{"entry":["7:","#define NOP_CODE 0x90"]},{"entry":["8:",{}]},{"entry":["9:","void"]},{"entry":["10:","HookDllFunction(LPTCSTR pszDllName,"]},{"entry":[{},"LPTCSTR pszFunctionName, PVOID pFunctionWrapper,"]},{"entry":[{},"PVOID &pOriginalCall)"]},{"entry":["11:","{"]},{"entry":["12:","HMODULE hDll = GetModuleHandle(pszDllName);"]},{"entry":["13:","PBYTE pFunction = GetProcAddress(hDll, pszFunctionName);"]},{"entry":["14:","pOriginalCall = VirtualAlloc(NULL, sizeof(ORIGINAL_CALL),"]},{"entry":[{},"MEM_COMMIT, PAGE_EXECUTE_READWRITE);"]},{"entry":["15:",{}]},{"entry":["16:","int NeedSize = sizeof(ORIGINAL_CALL);"]},{"entry":["17:","int ReplacedSize ="]},{"entry":[{},"DisasmAndCalculateAsmIntstructionsSize(pOriginalCall, NeedSize);"]},{"entry":["18:","memcpy(&pOriginalCall.OriginalCode,pFunction,ReplacedSize);"]},{"entry":[{},"\/\/replaced piece of instruction"]},{"entry":["19:","memset(&pOriginalCall.OriginalCode + ReplacedSize,"]},{"entry":[{},"NOP_CODE, MAX_ORIGINAL_CODE_SIZE \u2212"]},{"entry":[{},"ReplacedSize);\/\/fill not used space with NOP"]},{"entry":[{},"instructions"]},{"entry":["20:","AddAsmInstruction(&pOriginalCall.JmpToOtherOriginalCode,"]},{"entry":[{},"ASM_JMP, pFunction + ReplacedSize);\/\/generate"]},{"entry":[{},"jump to other real function code"]},{"entry":["21:",{}]},{"entry":["22:","AddAsmInstruction(pFunction, ASM_JMP, pFunctionWrapper);"]},{"entry":[{},"\/\/generate jump to hook code in the beginning of DLL exported function"]},{"entry":["23:","}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"As shown, at line 18, the code performs a memory copy (memcpy) operation for overwriting the original code as described above. Unused byte locations are padded out with NOP (no operation) instructions (e.g., 0x90 bytes), as shown at line 19. At line 20, the AddAsmInstruction helper function is again invoked for generating a jump (instruction) to the other real function code, and at line 22 the helper function is invoked for generating a jump to hook code at the beginning of the DLL (exported) function.","File System Processing Engine","A file system processing engine of the present invention provides a mechanism for serving file system calls, such as files and directories enumeration, creating and deleting files, and reading and writing file data. When a secured application tries to read or write a user's profile files, it serves I\/O requests, allowing on-the-fly encryption of file names and content. When the application tries to write to any restricted location (e.g., specified in policy), the engine prevents any unauthorized write or even access operations, returning an \u201cAccess Denied\u201d error; in this manner, the SWS ensures that no private data is left on the system after the SWS is closed down. File content encryption is designed for use with block-ciphers in ECB mode, with the option of including salt (i.e., additional piece of information added to the hash) that can be dependent of data-offset. Private user's file names are similarly secured in a manner to allow both good security and fast accessing directories tree. When a given application creates a file (which must be secured), the engine parses the path, splits it into corresponding names components, and generates a random character string (corresponding to real names). The file is physically stored by path, which is combined from random-names components. When the application opens this file or tries to enumerate names of the secured file, the engine extracts the corresponding logical file names from an internal look-up table that is stored only in memory.","Memory-mapped file sections support can be considered as additional sub-functionality of the file system processing engine. When an application tries to create a file section in a secured file, the engine creates memory-stored section with corresponding attributes and decrypts the file's content to it. If the application specifies a section name during creation or opens an existing section by name, the engine can optionally change the section name to divide sections opened by applications on default and secured desktops. The particular section names that should be changed can be specified in policy. On every subsequent read\/write request of the file, the engine performs simple copy of memory data from section memory to I\/O buffer. Flushing of the section to physical storage occurs on closing the file's handle. The below two pseudocode samples illustrate program logic implementing file processing features.","The first sample illustrates program code from a ZwCreateFile wrapper that changes file name or analyzes requested access rights:",{"@attributes":{"id":"p-0154","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1:","NTSTATUS _stdcall _wrapperZwCreateFile("]},{"entry":["2:","\u2003PHANDLE FileHandle,"]},{"entry":["3:","\u2003ACCESS_MASK DesiredAccess,"]},{"entry":["4:","\u2003POBJECT_ATTRIBUTES ObjectAttributes,"]},{"entry":["5:","\u2003PIO_STATUS_BLOCK IoStatusBlock,"]},{"entry":["6:","\u2003PLARGE_INTEGER AllocationSize,"]},{"entry":["7:","\u2003ULONG FileAttributes,"]},{"entry":["8:","\u2003ULONG ShareAccess,"]},{"entry":["9:","\u2003ULONG CreateDisposition,"]},{"entry":["10:","\u2003\u2009ULONG CreateOptions,"]},{"entry":["11:","\u2003\u2009PVOID EaBuffer,"]},{"entry":["12:","\u2003\u2009ULONG EaLength)"]},{"entry":["13:","\u2003{"]},{"entry":["14:","\u2003\u2009NTSTATUS rv=STATUS_SUCCESS;"]},{"entry":["15:","\u2003\u2009bool need_original=true;"]},{"entry":["16:","\u2003\u2009if(_threads_lock.EnterThread(_LINE_))"]},{"entry":["17:","\u2003\u2009{"]},{"entry":["18:",{}]},{"entry":["19:","\/\/Extract file path name from ObjectAttribute structure, with"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"conversion of it to a long form if necessary"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["20:","\u2003\u2003std::string strFileName ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"ExtractLongPathName(ObjectAttributes);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["21:",{}]},{"entry":["22:","\/\/Check is protection is enabled for current application"]},{"entry":["23:","\u2003\u2003if(_Module::g_ProtectedApplication != paUnknown)"]},{"entry":["24:","\u2003\u2003{"]},{"entry":["25:","\/\/Check for denied file path."]},{"entry":["26:",{}]},{"entry":["27:","\u2003\u2003\u2009if"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(g_module.get_protection( ).CheckForbiddenLocation(strFileName))"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["28:","\u2003\u2003\u2009{"]},{"entry":["29:","\u2003\u2003\u2003_threads_lock.LeaveThread(0);"]},{"entry":["30:","\u2003\u2003\u2003return STATUS_ACCESS_DENIED;"]},{"entry":["31:","\u2003\u2003\u2009}"]},{"entry":["32:",{}]},{"entry":["33:","\u2003\u2003\u2009std::string virtualFileName(strFileName);"]},{"entry":["34:","\/\/Check is this file should be secured (encrypted), with converting"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"its file path to the secured form if necessary"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["35:",{}]},{"entry":["36:","\u2003\u2003\u2009if(g_module.get_protection( ).IsProtectedFile(strFileName))"]},{"entry":["37:","\u2003\u2003\u2009{"]},{"entry":["38:","\u2003\u2003\u2003need_original=false;"]},{"entry":["39:","\u2003\u2003\u2003POBJECT_ATTRIBUTES"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"OurObjectAttributes=NameInitObjectAttributes(ObjectAttributes,"},{"entry":"strFileName);"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["40:",{}]},{"entry":["41:","\/\/Call original ZwCreateFile with encrypted file path and some"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"flags modified (we always need read access to the file)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["42:","\u2003\u2003\u2003rv = _originalZwCreateFile("]},{"entry":["43:","\u2003\u2003\u2003\u2009FileHandle,"]},{"entry":["44:",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"DesiredAccess=="},{"entry":"FILE_ALL_ACCESS?DesiredAccess:DesiredAccess|"},{"entry":"FILE_READ_DATA,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["45:","\u2003\u2003\u2003\u2003OurObjectAttributes,"]},{"entry":["46:","\u2003\u2003\u2003\u2003IoStatusBlock,"]},{"entry":["47:","\u2003\u2003\u2003\u2003AllocationSize,"]},{"entry":["48:","\u2003\u2003\u2003\u2003FileAttributes,"]},{"entry":["49:",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"FILE_SHARE_READ|FILE_SHARE_WRITE|"},{"entry":"FILE_SHARE_DELETE,\/\/ShareAccess,\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["50:","\u2003\u2003\u2003\u2003CreateDisposition,"]},{"entry":["51:","\u2003\u2003\u2003\u2003CreateOptions,"]},{"entry":["52:","\u2003\u2003\u2003\u2003EaBuffer,"]},{"entry":["53:","\u2003\u2003\u2003\u2003EaLength);"]},{"entry":["54:",{}]},{"entry":["55:",{}]},{"entry":["56:",{}]},{"entry":["57:","\u2003\u2003\u2003NameFreeObjectAttributes(OurObjectAttributes);"]},{"entry":["58:","\u2003\u2003\u2003if(rv==STATUS_SUCCESS)"]},{"entry":["59:","\u2003\u2003\u2003{"]},{"entry":["60:","\/\/Call CryptedFile::PostOpenInitalize routine, that perfoms"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"initialization encryption header of file, if it doesn't have header"},{"entry":"yet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["61:",{}]},{"entry":["62:","\u2003\u2003\u2003\u2003CryptedFile::PostOpenInitalize(*FileHandle,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"strFileName);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["63:","\u2003\u2003\u2003\u2003OurHandles::HNDINFO info;"]},{"entry":["64:","\u2003\u2003\u2003\u2003info.Flags=0;"]},{"entry":["65:","\u2003\u2003\u2003\u2003info.RefCnt=1;"]},{"entry":["66:","\u2003\u2003\u2003\u2003info.Name=StdStrToLower(virtualFileName);"]},{"entry":["67:","\/\/Store opened handle in our handles cache"]},{"entry":["68:","\u2003\u2003\u2003\u2003OurHandles::PutHandle(*FileHandle,info);"]},{"entry":["69:","\u2003\u2003\u2003\u2009}"]},{"entry":["70:","\u2003\u2003\u2003}else"]},{"entry":["71:","\u2003\u2003\u2003{"]},{"entry":["72:","\/\/if file is not encrypted, but can be opened for write by app then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"simple pass call to original ZwCreateFile"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["73:","\u2003\u2003\u2003\u2009if"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(g_module.get_protection( ).CheckWritablePath(strFileName))"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["74:","\u2003\u2003\u2003\u2009{"]},{"entry":["75:",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"SWSUtils::EnsurePathExists(strFileName.substr(4,strFileName.size( )\u22124));"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["76:","\u2003\u2003\u2003\u2003rv = _originalZwCreateFile("]},{"entry":["77:","\u2003\u2003\u2003\u2003\u2003FileHandle,"]},{"entry":["78:","\u2003\u2003\u2003\u2003\u2003DesiredAccess,"]},{"entry":["79:","\u2003\u2003\u2003\u2003\u2003ObjectAttributes,"]},{"entry":["80:","\u2003\u2003\u2003\u2003\u2003IoStatusBlock,"]},{"entry":["81:","\u2003\u2003\u2003\u2003\u2003AllocationSize,"]},{"entry":["82:","\u2003\u2003\u2003\u2003\u2003FileAttributes,"]},{"entry":["83:","\u2003\u2003\u2003\u2003\u2003ShareAccess,"]},{"entry":["84:","\u2003\u2003\u2003\u2003\u2003CreateDisposition,"]},{"entry":["85:","\u2003\u2003\u2003\u2003\u2003CreateOptions,"]},{"entry":["86:","\u2003\u2003\u2003\u2003\u2003EaBuffer,"]},{"entry":["87:","\u2003\u2003\u2003\u2003\u2003EaLength);"]},{"entry":["88:","\u2003\u2003\u2003\u2003need_original=false;"]},{"entry":["89:","\u2003\u2003\u2003}else"]},{"entry":["90:","\u2003\u2003\u2003{"]},{"entry":["91:","\/\/if app tried to create file in read-only location, pass FILE_OPEN"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"flag to ZwCreateFile routine to check if file already exist and"},{"entry":"return STATUS_OBJECT_NAME_COLLISION if this case or"},{"entry":"STATUS_ACCESS_DENIED, signaling app file is not exists, but app"},{"entry":"has no write access to specified location"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["92:","\u2003\u2003\u2003\u2003if(CreateDisposition==FILE_CREATE)"]},{"entry":["93:","\u2003\u2003\u2003\u2003{"]},{"entry":["94:","\u2003\u2003\u2003\u2003\u2009rv = _originalZwCreateFile("]},{"entry":["95:","\u2003\u2003\u2003\u2003\u2003\u2009FileHandle,"]},{"entry":["96:","\u2003\u2003\u2003\u2003\u2003\u2009DesiredAccess,"]},{"entry":["97:","\u2003\u2003\u2003\u2003\u2003\u2009ObjectAttributes,"]},{"entry":["98:","\u2003\u2003\u2003\u2003\u2003\u2009IoStatusBlock,"]},{"entry":["99:","\u2003\u2003\u2003\u2003\u2003\u2009AllocationSize,"]},{"entry":["100:","\u2003\u2003\u2003\u2003\u2003\u2002FileAttributes,"]},{"entry":["101:","\u2003\u2003\u2003\u2003\u2003\u2002ShareAccess,"]},{"entry":["102:","\u2003\u2003\u2003\u2003\u2003\u2002FILE_OPEN,"]},{"entry":["103:","\u2003\u2003\u2003\u2003\u2003\u2002CreateOptions,"]},{"entry":["104:","\u2003\u2003\u2003\u2003\u2003\u2002EaBuffer,"]},{"entry":["105:","\u2003\u2003\u2003\u2003\u2003\u2002EaLength);"]},{"entry":["106:","\u2003\u2003\u2003\u2003\u2009if(rv==STATUS_SUCCESS)"]},{"entry":["107:","\u2003\u2003\u2003\u2003\u2009{"]},{"entry":["108:","\u2003\u2003\u2003\u2003\u2003\u2002_originalZwClose(*FileHandle);"]},{"entry":["109:",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"rv=IoStatusBlock->Status=STATUS_OBJECT_NAME_COLLISION;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["110:","\u2003\u2003\u2003\u2003\u2009}else"]},{"entry":["111:","\u2003\u2003\u2003\u2003\u2009{"]},{"entry":["112:","\u2003\u2003\u2003\u2003\u2003\u2002g_logger->LogInfo(\u201c_wrapperZwCreateFile"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"FILE_CREATE access denied for \u2018%s\u2019\u201d,strFileName.c_str( ));"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["113:","\u2003\u2003\u2003\u2003\u2003\u2002rv=IoStatusBlock-"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":">Status=STATUS_ACCESS_DENIED;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["114:","\u2003\u2003\u2003\u2003\u2009}"]},{"entry":["115:","\u2003\u2003\u2003\u2003\u2009need_original=false;"]},{"entry":["116:","\u2003\u2003\u2003\u2003}else"]},{"entry":["117:","\u2003\u2003\u2003\u2003{"]},{"entry":["118:","\u2003\u2003\u2003\u2003\u2002CreateDisposition=FILE_OPEN;"]},{"entry":["119:",{}]},{"entry":["120:","\/\/If app simple opens file, then adjust access rights as specified"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"in policy"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["121:","DesiredAccess=GetMaxAccess(strFileName,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CreateOptions,DesiredAccess);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["122:","\u2003\u2003\u2003\u2009}"]},{"entry":["123:","\u2003\u2003\u2003}"]},{"entry":["124:",{}]},{"entry":["125:","\u2003\u2003\u2009}"]},{"entry":["126:","\u2003\u2003}"]},{"entry":["127:",{}]},{"entry":["128:","\u2003\u2003_threads_lock.LeaveThread(0);"]},{"entry":["129:",{}]},{"entry":["130:","\u2003\u2009}"]},{"entry":["131:",{}]},{"entry":["132:","\u2003\u2009if(need_original)"]},{"entry":["133:","\u2003\u2003rv = _originalZwCreateFile("]},{"entry":["134:","\u2003\u2003FileHandle,"]},{"entry":["135:","\u2003\u2003DesiredAccess,"]},{"entry":["136:","\u2003\u2003ObjectAttributes,"]},{"entry":["137:","\u2003\u2003IoStatusBlock,"]},{"entry":["138:","\u2003\u2003AllocationSize,"]},{"entry":["139:","\u2003\u2003FileAttributes,"]},{"entry":["140:","\u2003\u2003ShareAccess,"]},{"entry":["141:","\u2003\u2003CreateDisposition,"]},{"entry":["142:","\u2003\u2003CreateOptions,"]},{"entry":["143:","\u2003\u2003EaBuffer,"]},{"entry":["144:","\u2003\u2003EaLength);"]},{"entry":["145:",{}]},{"entry":["146:","\u2003\u2009return rv;"]},{"entry":["147:","\u2003}"]},{"entry":"148:"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The second sample illustrates the processing of ZwWriteFile calls:",{"@attributes":{"id":"p-0156","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"1: \/\/ Sample code that processes ZwWriteFile call (also from SWS):"},{"entry":"2: \u2002NTSTATUS _stdcall _wrapperZwWriteFile("},{"entry":"3: \u2003HANDLE FileHandle,"},{"entry":"4: \u2003HANDLE Event,"},{"entry":"5: \u2003PIO_APC_ROUTINE ApcRoutine,"},{"entry":"6: \u2003PVOID ApcContext,"},{"entry":"7: \u2003PIO_STATUS_BLOCK IoStatusBlock,"},{"entry":"8: \u2003PVOID Buffer,"},{"entry":"9: \u2003ULONG Length,"},{"entry":"10: \u2003\u2002PLARGE_INTEGER ByteOffset,"},{"entry":"11: \u2003\u2002PULONG Key)"},{"entry":"12: \u2002{"},{"entry":"13: \u2003\u2002OurHandles::HNDINFO info;"},{"entry":"14: \/\/check is specified handle is stored in our handles cache, retrieve"},{"entry":"some info about it if so"},{"entry":"15: \u2003\u2002if(OurHandles::IsOurHandle(FileHandle,info))"},{"entry":"16: \u2003\u2002{"},{"entry":"17: \/\/check if memory-mapping section object was opened for this file, if"},{"entry":"so then copy data also to section address space"},{"entry":"18: HANDLE"},{"entry":"SectionHandle="},{"entry":"OurSectionByName(SectionNameByFileName(info.Name), false);"},{"entry":"19: \u2003\u2003NTSTATUS rv;"},{"entry":"20: \u2003\u2003SyncUtils::WaitMutant(sect_mtx,INFINITE);"},{"entry":"21: \u2003\u2003if(SectionHandle)"},{"entry":"22: \u2003\u2002{"},{"entry":"23: \u2003\u2003OurHandles::HNDINFO sectioninfo;"},{"entry":"24: \u2003\u2003if(OurHandles::IsOurHandle(SectionHandle,sectioninfo))"},{"entry":"25: \u2003\u2003{"},{"entry":"26: \u2003\u2003\u2002IO_STATUS_BLOCK isb;"},{"entry":"27: \u2003\u2003\u2002FILE_POSITION_INFORMATION fpi={0,0};"},{"entry":"28:"},{"entry":"_originalZwQueryInformationFile(FileHandle,&isb,&fpi,sizeof(fpi),"},{"entry":"FilePositionInformation);"},{"entry":"29:"},{"entry":"30: \u2003\u2003\u2002if(fpi.CurrentByteOffset.QuadPart<sectioninfo.ViewSize)"},{"entry":"31: \u2003\u2003\u2002{"},{"entry":"32: \u2003\u2003\u2003DWORD"},{"entry":"pos=ByteOffset?fpi.CurrentByteOffset.LowPart\u2212sizeof("},{"entry":"VD_CRYPT_HEADER):ByteOffset->LowPart,len=Length;"},{"entry":"33: \u2003\u2003\u2003if(len>(sectioninfo.ViewSize\u2212pos))"},{"entry":"34: \u2003\u2003\u2003{"},{"entry":"35: \u2003\u2003\u2003\u2002len=(DWORD)sectioninfo.ViewSize\u2212pos;"},{"entry":"36: \u2003\u2003\u2003}"},{"entry":"37: \u2003\u2003\u2003memcpy(((unsigned char"},{"entry":"*)sectioninfo.PrimaryMapView)+pos,Buffer,len);"},{"entry":"38:"},{"entry":"39: \u2003\u2003\u2002}"},{"entry":"40: \u2003\u2003}"},{"entry":"41: \u2003\u2002}"},{"entry":"42:"},{"entry":"43: \u2003\u2002LARGE_INTEGER WriteOffset;"},{"entry":"44: \u2003\u2002if(!ByteOffset)"},{"entry":"45: \u2003\u2002{"},{"entry":"46: \u2003\u2003IO_STATUS_BLOCK isb;"},{"entry":"47: \u2003\u2003FILE_POSITION_INFORMATION fpi={0,0};"},{"entry":"48:"},{"entry":"_originalZwQueryInformationFile(FileHandle,&isb,&fpi,sizeof(fpi),"},{"entry":"FilePositionInformation);"},{"entry":"49: \u2003\u2003WriteOffset=fpi.CurrentByteOffset;"},{"entry":"50: \u2003\u2002}else"},{"entry":"51:"},{"entry":"WriteOffset.QuadPart="},{"entry":"ByteOffset->QuadPart+sizeof(VD_CRYPT_HEADER);"},{"entry":"52:"},{"entry":"53: \/\/call CryptedFile::WriteFile to perfom writing content with"},{"entry":"encryption to physical file"},{"entry":"54: \u2003\u2002rv=CryptedFile::WriteFile(FileHandle, IoStatusBlock, Buffer,"},{"entry":"Length,&WriteOffset,Key);"},{"entry":"55: \u2003\u2002\/\/\/\/\/\/\/\/\/\/"},{"entry":"56: \u2003\u2002IO_STATUS_BLOCK isb;"},{"entry":"57: \u2003\u2002FILE_POSITION_INFORMATION fpi={0,0};"},{"entry":"58:"},{"entry":"_originalZwQueryInformationFile(FileHandle,&isb,&fpi,sizeof(fpi),"},{"entry":"FilePositionInformation);"},{"entry":"59: \u2003\u2002SyncUtils::ReleaseMutant(sect_mtx);"},{"entry":"60: \u2003if(Event)SetEvent(Event);"},{"entry":"61: \u2003return rv;"},{"entry":"62: \u2002}"},{"entry":"63:"},{"entry":"64: \/\/pass call to original ZwWriteFile routine if specified handle is"},{"entry":"unknown for us"},{"entry":"65: return _originalZwWriteFile(FileHandle, Event, ApcRoutine,"},{"entry":"ApcContext,"},{"entry":"66: \u2003IoStatusBlock, Buffer, Length, ByteOffset, Key);"},{"entry":"67: \u2002}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Synchronization Objects Virtualization","A synchronization objects virtualization engine is provided that can optionally change names of named synchronization objects (mutexes, semaphores, events, and the like) that are created by secured applications, thus allowing independent applications to function on secure and default desktops. For example, Adobe Acrobat Reader (acrord32.exe) creates certain named objects, the existence of which it uses to determine whether an instance of the Reader is already running (and thus a second instance should not be started). The specification of its names in the policy (XML) file makes possible to ensure acrord32.exe is the only running application instance in system.","Registry Processing Engine","A Registry processing engine is provided that allows flexible virtualization and protection of selected registry keys (which can be customized in the policy). Write-protection of selected keys is done by analyzing parameters of ZwCreateKey and ZwOpenKey routines and returning \u201cAccess Denied\u201d status, if any modification access is requested. Virtualization is done by creating an additional registry subkey (HKCU\\CPSecured) and changing all absolute paths requested by secured applications to really point to this key. Also a Copy-On-Access feature is provided to allow access to registry keys and values without noticeable delays for importing values from the original keys.","Exemplary wrapper code, ZwCreateKey, may be implemented as follows:",{"@attributes":{"id":"p-0162","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"1: NTSTATUS _stdcall _wrapperZwCreateKey(PHANDLE KeyHandle,ACCESS_MASK"},{"entry":"DesiredAccess,"},{"entry":"2: \u2003\u2003\u2003\u2003POBJECT_ATTRIBUTES ObjectAttributes,ULONG TitleIndex,"},{"entry":"3: \u2003\u2003\u2003\u2003PUNICODE_STRING Class,ULONG CreateOptions,PULONG"},{"entry":"Disposition)"},{"entry":"4: \u2002{"},{"entry":"5: \/\/check is protection enabled for current application"},{"entry":"6: \u2003\u2002if((_Module::g_ProtectedApplication !="},{"entry":"paUnknown)&&_threads_lock.EnterThread(_LINE_))"},{"entry":"7: \u2003{"},{"entry":"8: \u2003\u2002std::string"},{"entry":"keypath=UNCStr2String(ObjectAttributes->ObjectName);"},{"entry":"9: \u2003\u2002std::string Ikeypath=StdStrToLower(keypath);"},{"entry":"10:"},{"entry":"11: \u2003\u2002NTSTATUS rv;"},{"entry":"12: \/\/ TranslateHKEY routine checks is specified path belongs to HKCU"},{"entry":"hive, converting it to virtual key path and returning true in this"},{"entry":"case, if path is read-only HKLM path it return false and don't change"},{"entry":"key path"},{"entry":"13: \u2003\u2002bool"},{"entry":"mode=RegUtils::TranslateHKEY(ObjectAttributes->RootDirectory,keypath);"},{"entry":"14: \u2003\u2002if(mode)"},{"entry":"15: \u2003\u2002{"},{"entry":"16: \/\/if path is points to virtualized key, then call original"},{"entry":"ZwCreateKey routine with path, relative to HKCU\\CPSecured location"},{"entry":"17: \u2003\u2003POBJECT_ATTRIBUTES"},{"entry":"OurObjectAttributes=NameInitObjectAttributes(ObjectAttributes,"},{"entry":"keypath);"},{"entry":"18: \u2003\u2003OurObjectAttributes->RootDirectory=NULL;"},{"entry":"19:"},{"entry":"20:"},{"entry":"rv=_originalZwCreateKey(KeyHandle,DesiredAccess,OurObjectAttributes,"},{"entry":"TitleIndex,Class,CreateOptions,Disposition);"},{"entry":"21:"},{"entry":"22: \u2003\u2003NameFreeObjectAttributes(OurObjectAttributes);"},{"entry":"23: \u2003\u2002}else"},{"entry":"24: \u2003\u2002{"},{"entry":"25: \/\/if path is read-only and app tried to get write access to this key"},{"entry":"then just return access denied to it"},{"entry":"if((DesiredAccess&KEY_SET_VALUE)||("},{"entry":"DesiredAccess&KEY_CREATE_SUB_KEY)||((DesiredAccess&KEY_ALL_ACCESS)=="},{"entry":"KEY_ALL_ACCESS))"},{"entry":"26: \u2003\u2003{"},{"entry":"27: \u2003\u2003\u2002_threads_lock.LeaveThread(STATUS_ACCESS_DENIED);"},{"entry":"28: \u2003\u2003\u2002return STATUS_ACCESS_DENIED;"},{"entry":"29: \u2003\u2003}"},{"entry":"30:"},{"entry":"31: \u2003\u2003DesiredAccess=KEY_READ;"},{"entry":"32:"},{"entry":"33: \/\/call original ZwCreateKey routine for read access"},{"entry":"34:"},{"entry":"rv=_originalZwCreateKey(KeyHandle,DesiredAccess,ObjectAttributes,"},{"entry":"TitleIndex,Class,CreateOptions,Disposition);"},{"entry":"35:"},{"entry":"36: \u2003\u2002}"},{"entry":"37:"},{"entry":"38: \u2003\u2002_threads_lock.LeaveThread(rv);"},{"entry":"39: \u2003\u2002return rv;"},{"entry":"40: \u2003}else"},{"entry":"41: \u2003\u2002return"},{"entry":"_originalZwCreateKey(KeyHandle,DesiredAccess,ObjectAttributes,"},{"entry":"TitleIndex,Class,CreateOptions,Disposition);"},{"entry":"42: \u2002}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"For example, beginning with the program logic at line 6 the function checks whether protection is enabled for current application (under consideration). At line 13, the TranslateHKEY routine is invoked to check whether the specified path belongs to HKCU (HKEY_CURRENT_USER) hive. If so, the routine converts it to a virtual key path and returns \u201ctrue.\u201d If the path is read-only (HKLM (HKEY_LOCAL_MACHINE) path), the routine returns \u201cfalse\u201d and the key path remains unchanged. At line 17, if the path points to a virtualized key, then the original ZwCreateKey routine is called with the path (relative to the HKCU\\CPSecured location). At line 25, if the path is read-only and the application tries to get write access to this key, the program logic returns \u201cAccess Denied\u201d (for denying access to the key). Line 34 demonstrates a call to the original ZwCreateKey routine, for providing read access.","OLE32 Calls Filtering","OLE32 calls filtering is provided to intercept the OS' COM server's creation requests. When an application asks OLE32 to create an out-of-process COM server, the wrapper checks the COM server presence in the SWS. The path is extracted to an executable image of the COM server from the registry HKCR (HKEY_CLASSES_ROOT) hive. The server starts itself, if the server was not already started before. Such an approach allows the starting of secured COM servers. The following program logic illustrates main aspects of this functionality:",{"@attributes":{"id":"p-0166","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u20091: bool Ole32APIWrapper::CheckIsServerStarted(std::string server)"},{"entry":"\u20092: {\/\/this function checks if specified image process is already started"},{"entry":"in secured mode, if so we don't need to start it one more time"},{"entry":"\u20093: \u2002bool out=false;"},{"entry":"\u20094: \u2002typedef std::set<DWORD> \u2003PROCSET;"},{"entry":"\u20095: \u2002PROCSET procs;"},{"entry":"\u20096: \u2002HANDLE snt ="},{"entry":"\u2003\u2002\u2009 CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);"},{"entry":"\u20097: \u2002if(snt!=INVALID_HANDLE_VALUE)"},{"entry":"\u20098: \u2002{"},{"entry":"\u20099: \u2003PROCESSENTRY32 pe32={sizeof(PROCESSENTRY32),0};"},{"entry":"10:"},{"entry":"11: \/\/prepare full list of active secured processes"},{"entry":"12: \u2003if(Process32First(snt,&pe32))"},{"entry":"13: \u2003{"},{"entry":"14: \u2003\u2002do {"},{"entry":"15:"},{"entry":"if(VDPipeClient::IsPidSecured(pe32.th32ProcessID))procs.insert(pe32."},{"entry":"th32ProcessID);"},{"entry":"16: \u2003\u2002} while(Process32Next(snt,&pe32));"},{"entry":"17: \u2003}"},{"entry":"18: \u2003CloseHandle(snt);"},{"entry":"19: \u2002}"},{"entry":"20:"},{"entry":"21:"},{"entry":"22: \u2002std::string ShortServer = StdStrToLower(ShortPathName(server));"},{"entry":"23:"},{"entry":"24: \/\/compare image path names of secured processes with requested path,"},{"entry":"if found matching path - return true, else - return false"},{"entry":"25:"},{"entry":"26: \u2002for(PROCSET::iterator i=procs.begin( );i!=procs.end( );++i)"},{"entry":"27: \u2002{"},{"entry":"28: \u2003ics::handle prc="},{"entry":"\u2003\u2003\u2009 OpenProcess(PROCESS_ALL_ACCESS,FALSE,*i);"},{"entry":"29: \u2003std::vector<HINSTANCE> modarray(255);"},{"entry":"30: \u2003DWORD needsize=sizeof(HINSTANCE)*modarray.size( );"},{"entry":"31: \u2003BOOL"},{"entry":"modenumok=EnumProcessModules(prc,&modarray[0],needsize,-"},{"entry":"&needsize);"},{"entry":"32: \u2003if(needsize>(sizeof(HINSTANCE)*modarray.size( )))"},{"entry":"33: \u2003{"},{"entry":"34: \u2003\u2002needsize+=512;"},{"entry":"35: \u2003\u2002modarray.resize(needsize\/sizeof(HINSTANCE));"},{"entry":"36:"},{"entry":"modenumok=EnumProcessModules(prc,&modarray[0],needsize,-"},{"entry":"&needsize);"},{"entry":"37: \u2003}"},{"entry":"38: \u2003if(!modenumok)"},{"entry":"39: \u2003\u2002continue;"},{"entry":"40:"},{"entry":"41: \u2003needsize\/=sizeof(HINSTANCE);"},{"entry":"42: \u2003for(size_t j=0;j<needsize;j++)"},{"entry":"43: \u2003{"},{"entry":"44: \u2003\u2002char modpath[MAX_PATH+1];"},{"entry":"45: \u2003\u2002DWORD"},{"entry":"modlen=GetModuleFileNameEx(prc,modarray[j],modpath,MAX_PATH);"},{"entry":"46: \u2003\u2002if(modlen&&(modlen<=MAX_PATH))"},{"entry":"47: \u2003\u2002{"},{"entry":"48: \u2003\u2003std::string"},{"entry":"CurServer=StdStrToLower(ShortPathName(std::string(modpath,modlen)));"},{"entry":"49: \u2003\u2003if(ShortServer == CurServer)"},{"entry":"50: \u2003\u2003{"},{"entry":"51: \u2003\u2003\u2002out = true;"},{"entry":"52: \u2003\u2003\u2002break;"},{"entry":"53: \u2003\u2003}"},{"entry":"54: \u2003\u2002}"},{"entry":"55: \u2003}"},{"entry":"56:"},{"entry":"57: \u2002}"},{"entry":"58: \u2002return out;"},{"entry":"59: }"},{"entry":"60: ......"},{"entry":"61: bool Ole32APIWrapper::CreateLocalServer(std::string server)"},{"entry":"62: {"},{"entry":"63: \/\/check if server already started, in this case do nothing"},{"entry":"64: if(EnsureServerStartedAndInjected(server))"},{"entry":"65: \u2003return true;"},{"entry":"66:"},{"entry":"67: \u2002STARTUPINFO si={sizeof(STARTUPINFO),0};"},{"entry":"68: \u2002PROCESS_INFORMATION pin={0};"},{"entry":"69: \u2002std::string cmd(\u201c\\\u201d\u201d);"},{"entry":"70: \u2002cmd.append(server);"},{"entry":"71: \u2002cmd.append(\u201c\\\u201d -Embedding\u201d);"},{"entry":"72: \/\/start COM server process with -Embedding parameter"},{"entry":"73:"},{"entry":"if(CreateProcess(server.c_str( ),(char*)cmd.c_str( ),"},{"entry":"NULL,NULL,FALSE,0,NULL,NULL,&si,&pin))"},{"entry":"74: \u2002{"},{"entry":"75: \u2003WaitForInputIdle(pin.hProcess,5000);"},{"entry":"76: \u2003Sleep(500);"},{"entry":"77: \u2003CloseHandle(pin.hProcess);"},{"entry":"78: \u2003CloseHandle(pin.hThread);"},{"entry":"79: \u2002}"},{"entry":"80: \u2002return true;"},{"entry":"81: }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The CheckIsServerStarted function checks whether the specified image process is already started in secured mode (so that is not necessary to start it one more time). At line 14, a \u201cdo\/while\u201d loop is established to prepare a full list of active secured processes. At line 26, a \u201cfor\u201d loop compares the image path names of secured processes with the requested path. If the comparison finds a matching path, the program logic returns \u201ctrue\u201d; otherwise, it returns \u201cfalse.\u201d If the server is already started (tested at line 64), then the function does no additional work and simply returns \u201ctrue.\u201d Otherwise, the function proceeds to start the COM server process with embedding parameter.","Exemplary ole32.dll wrappers that intercept attempts to create COM servers may be constructed as follows:",{"@attributes":{"id":"p-0169","num":"0168"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u20021: ...................."},{"entry":"\u20022: \/\/ole32.dll wrappers, that intercepts\/attempts to create COM servers"},{"entry":"\u20023: bool Ole32APIWrapper::CreateLocalServer(REFCLSID rclsid)"},{"entry":"\u20024: {"},{"entry":"\u20025: \u2002std::string strServerName ="},{"entry":"\u2003\u2002\u2009 Ole32APIWrapper::ServerByCLSID(rclsid);"},{"entry":"\u20026: \u2002if (!strServerName.empty( ))"},{"entry":"\u20027: \u2002{"},{"entry":"\u20028: \u2003\u2002return Ole32APIWrapper::CreateLocalServer(strServerName);"},{"entry":"\u20029: \u2002}"},{"entry":"10: \u2003return true;"},{"entry":"11: }"},{"entry":"12: ............."},{"entry":"13: HRESULT _stdcall _wrapperCoCreateInstanceEx("},{"entry":"14: \u2003REFCLSID rclsid,"},{"entry":"15: \u2003IUnknown * punkOuter,"},{"entry":"16: \u2003DWORD dwClsCtx,"},{"entry":"17: \u2003COSERVERINFO * pServerInfo,"},{"entry":"18: \u2003ULONG cmq,"},{"entry":"19: \u2003MULTI_QI * pResults)"},{"entry":"20: {"},{"entry":"21: \u2003\u2002if(!Ole32APIWrapper::CreateLocalServer(rclsid))"},{"entry":"22: \u2003\u2002return E_NOINTERFACE;"},{"entry":"23:"},{"entry":"24: \u2003HRESULT rv = _originalCoCreateInstanceEx(rclsid, punkOuter,"},{"entry":"dwClsCtx, pServerInfo, cmq, pResults);"},{"entry":"25:"},{"entry":"26: \u2003if (_Module::g_ProtectedApplication != paUnknown)"},{"entry":"27: \u2003{"},{"entry":"28: \u2003\u2002Ole32APIWrapper::TraceObjectNameByCLSID(rclsid,"},{"entry":"\u201cCoCreateInstanceEx\u201d);"},{"entry":"29: \u2003\u2002Ole32APIWrapper::CatchLocalServer(rclsid);"},{"entry":"30: \u2002}"},{"entry":"31:"},{"entry":"32: \u2003return rv;"},{"entry":"33: }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Clipboard Processing Engine","A \u201cClipboard\u201d processing engine is provided to serve as a mechanism to intercept saving data to and retrieving data from the OS' clipboard by secured application(s), thereby allowing on-the-fly encryption of private data stored to clipboard. In Windows OS, for example, this can be achieved by intercepting only three functions\u2014GetClipboardData, SetClipboardData and CloseClipboard\u2014that are exported by Windows' user32.dll. For example, a GetClipboardData wrapper may be implemented as follows:",{"@attributes":{"id":"p-0172","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"1: HANDLE _stdcall _wrapperGetClipboardData( UINT uFormat)"},{"entry":"2: {"},{"entry":"3: \u2002return globalDecrypt(_originalGetClipboardData(uFormat));"},{"entry":"4: }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As shown, this works in conjunction with a globalDecrypt function to decrypt the data for reconstituting the original Clipboard data. The globalDecrypt function itself may be constructed as follows:",{"@attributes":{"id":"p-0174","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u20021: HANDLE globalDecrypt(HANDLE src)"},{"entry":"\u20022: {"},{"entry":"\u20023: \u2002if(!src)return src;"},{"entry":"\u20024: \u2002size_t sz=GlobalSize(src);"},{"entry":"\u20025: \u2002if(sz<2)return src;"},{"entry":"\u20026:"},{"entry":"\u20027: \u2002char *sbuff=(char *)GlobalLock(src);"},{"entry":"\u20028: \u2002if(!sbuff)return src;"},{"entry":"\u20029: \u2002HANDLE out=src;"},{"entry":"10: \u2002if((sbuff[0]==0x07)&&(sbuff[1]==0x10))"},{"entry":"11: \u2002{"},{"entry":"12: \u2003unsigned int dstlen=0;"},{"entry":"13: \u2003VDCryptUtils::DecryptRAWBufferFromString(sbuff+2, sz\u22122,"},{"entry":"NULL, dstlen);"},{"entry":"14:"},{"entry":"15: \u2003if(dstlen)"},{"entry":"16: \u2003{"},{"entry":"17: \u2003\u2002out=GlobalAlloc(GMEM_MOVEABLE,dstlen);"},{"entry":"18: \u2003\u2002char *dbuff=(char *)GlobalLock(out);"},{"entry":"19: \u2003\u2002VDCryptUtils::DecryptRAWBufferFromString(sbuff+2, sz\u22122,"},{"entry":"dbuff, dstlen);"},{"entry":"20: \u2003\u2002GlobalUnlock(out);"},{"entry":"21: \u2003}"},{"entry":"22: \u2002}"},{"entry":"23: \u2002GlobalUnlock(src);"},{"entry":"24: \u2002return out;"},{"entry":"25: }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Print Interceptor","A print interceptor engine is provided to hook the Windows StartDocW and StartDocA functions exported by gdi32.dll. These StartDoc functions start a print job in Windows. By intercepting these functions, the SWS may deny any print operations. Additionally, the feature can be configured by the policy file.","Process Creation Interceptor","A process creation interceptor is also provided. When a secured application tries to create a new process, it executes hooking engine code that hooks all necessary API calls of the created child process. It also writes some secure data (secure token) directly to memory of the created process that allows the SWS to further distinguish between a secured application and malicious applications (which may try to use SWS functionality to access secured data). Sample pseudocode, illustrating main features of process creation wrapper, is as follows:",{"@attributes":{"id":"p-0179","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u20021: BOOL WINAPI _wrapperCreateProcessW"},{"entry":"\u20022: ("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20023: wchar_t *IpApplicationName,","\/\/ name of executable"]},{"entry":["module",{}]},{"entry":["\u20024: wchar_t *IpCommandLine,","\/\/ command line string"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u20025: LPSECURITY_ATTRIBUTES IpProcessAttributes, \/\/ SD"},{"entry":"\u20026: LPSECURITY_ATTRIBUTES IpThreadAttributes, \u2002\/\/ SD"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20027: BOOL bInheritHandles,","\/\/ handle inheritance"]},{"entry":["option",{}]},{"entry":["\u20028: DWORD dwCreationFlags,","\u2003\/\/ creation flags"]},{"entry":["\u20029: LPVOID IpEnvironment,","\/\/ new environment block"]},{"entry":["10: wchar_t *IpCurrentDirectory,","\u2003\u2002\/\/ current directory name"]},{"entry":["11: LPSTARTUPINFOW IpStartupInfo,","\u2003\u2003\u2002\/\/ startup information"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"12: LPPROCESS_INFORMATION IpProcessInformation \/\/"},{"entry":"\u2003\u2009 process information"},{"entry":"13: )"},{"entry":"14: {"},{"entry":"15: if (!CheckPolicyExecAllowed (IpApplicationName))"},{"entry":"16: {"},{"entry":"17: SetLastError(ERROR_ACCESS_DENIED);"},{"entry":"18: ShowAlert(\u201cExecute denied by policy\u201d);"},{"entry":"19: return FALSE;"},{"entry":"20: }"},{"entry":"21:"},{"entry":"22: BOOL bRes = StartProcessWithDll(IpApplicationName,"},{"entry":"CpSwsDllPathName, IpStartupInfo,IpProcessInformation);"},{"entry":"23: if(!bRes)return FALSE;"},{"entry":"24:"},{"entry":"25: PVOID remoteSecureCookiePtr ="},{"entry":"GetRemoteSecureCookiePtr(IpProcessInformation->hProcess);"},{"entry":"26: WriteProcessMemory(IpProcessInformation->hProcess,"},{"entry":"remoteSecureCookiePtr,&SecureCookie,sizeof(SecureCookie),NULL);"},{"entry":"27: return TRUE;"},{"entry":"28: }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Importantly, if the policy does not allow the executable, then the function returns \u201cfalse\u201d at line 19. Otherwise, the function will proceed to allow process creation (at line 22).","Encryption","Encryption functionality implemented in the present invention is designed to be flexible and easy to configure. It allows, for example, the use of different cryptographic algorithms for encrypting objects of a given type. The particular encryption algorithm used is noted (via a stored ID) in the stored object, via an opaque header. The header also stores other housekeeping information, such as real data length. In the currently preferred embodiment, encryption functionality is implemented using the following interface:",{"@attributes":{"id":"p-0183","num":"0182"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1: class IVDCrypt"]},{"entry":[{},"2: {"]},{"entry":[{},"3: public:"]},{"entry":[{},"4: \u2002virtual bool EncryptBuffer(char *Buffer, unsigned _int64"]},{"entry":[{},"Offset,unsigned int Length)=0;"]},{"entry":[{},"5: \u2002virtual bool DecryptBuffer(char *Buffer, unsigned _int64"]},{"entry":[{},"Offset,unsigned int Length)=0;"]},{"entry":[{},"6: \u2002virtual unsigned int Align( )=0;"]},{"entry":[{},"7: };"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Every time engine functionality requests to encrypt or decrypt some blocks of data, the engine creates an instance (of implementation) of the particular preferred crypto algorithm, by giving the preferred algorithm ID to the encryption engine. If the engine detects that data is not encrypted yet, it will proceed to use the specified algorithm. If data is already encrypted, however, the engine will use the algorithm ID that is specified in encrypted data header. The particular encryption key employed is currently randomly generated, on session initialization.","URL Secure Cookie Injector","A URL secure cookie injector is provided for injecting a variable count of secure cookies into HTTP requests. Thus, the SWS can inject one or more additional secure cookies into every secured process using the Windows' lnternetSetCookie API function. The SWS also creates Mozilla Firefox profile files with secure cookies during initialization. HTTP URL and corresponding secure cookie data is given to the secure workspace manager (cpsws.exe) by the launcher, as command-line parameters. The manager (cpsws.exe) cleans up the command-line after startup to prevent leaking of this information. This allows the corresponding HTTP server of the enterprise portal to distinguish HTTP requests from secured and unsecured applications (e.g., using GWLIB API).","Configuration Loader","A configuration loader (with storage class) is provided that loads and analyzes the policy (cpsws.xml file), in which configuration and policy settings are stored. The loader provides an interface for other functionality parts to access their policies and configuration. It is possible to configure in the XML file what registry keys should be initialized and what values they should have for the SWS environment.","Inter-Process Communication (IPC) Channel","An inter-process communication (IPC) channel is provided to serve as a generic mechanism for low-level safe and secure communication between SWS functionality parts loaded into different processes. It is implemented as a pipe server that is started in the cpsws.exe core process on the early stage of initialization; given pipe clients that connect to the server from cpsws.dll instances are loaded into secured applications. The server expects a secure token as the first data sent from a given client via pipe. If it receives any other data, it closes the pipe connection after waiting a prescribed period of time (as an anti-hacker delay). A secure token is written directly to secured process memory on its creation, so no one else can use the IPC channel\/engine.","Desktop Initialization and Security","Desktop initialization and security uses the Windows' CreateDesktop API both with NT security features to achieve maximum possible control of user-space prevention, and to prevent keyboard loggers and screen-shooters from accessing private information. The CreateDesktop API function creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread. The virtual desktop, which is created by the CreatesDesktop API function, can be optionally equipped with special Security Descriptor that ensures no one can launch an application on the secured desktop or install a keyboard hook into it (and even make it impossible to get a desktop handle to this desktop). During initialization the manager (cpsws.exe) creates a desktop and assigns to it security descriptor with an empty DACL. The security descriptor creation and initialization code may, for example, be implemented along the following lines:",{"@attributes":{"id":"p-0193","num":"0192"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u20021: void DesktopSecurity::Secure( )"},{"entry":"\u20022: {"},{"entry":"\u20023: \u2002PSECURITY_DESCRIPTOR"},{"entry":"\u2003\u2002\u2009 sd=(PSECURITY_DESCRIPTOR)new char[0xffff];"},{"entry":"\u20024: \u2002InitializeSecurityDescriptor(sd,"},{"entry":"\u2003\u2002\u2009 SECURITY_DESCRIPTOR_REVISION);"},{"entry":"\u20025: \u2002ACL a;"},{"entry":"\u20026: \u2002if (InitializeAcl(&a,sizeof(ACL),ACL_REVISION)&&"},{"entry":"\u2003\u2002\u2009 IsValidAcl(&a))"},{"entry":"\u20027: \u2002{"},{"entry":"\u20028: \u2003ApplySD(sd);"},{"entry":"\u20029: \u2003SECURITY_INFORMATION"},{"entry":"\u2003\u2003\u2009 si=DACL_SECURITY_INFORMATION;"},{"entry":"10: \u2003\u2002SetSecurityDescriptorDacl(sd,TRUE,&a,FALSE);"},{"entry":"11: \u2003\u2002ApplySD(sd);"},{"entry":"12: \u2002}"},{"entry":"13: \u2002delete[ ] (char *)sd;"},{"entry":"14: }"},{"entry":"15:"},{"entry":"16: \/\/ ..."},{"entry":"17:"},{"entry":"18: void DesktopSecurity::ApplySD(PSECURITY_DESCRIPTOR sd)"},{"entry":"19: {"},{"entry":"20: \u2002SECURITY_INFORMATION"},{"entry":"\u2003\u2002\u2009 si=DACL_SECURITY_INFORMATION;"},{"entry":"21: \u2002SetUserObjectSecurity(_desk,&si,sd);"},{"entry":"22: }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"User and Application Specific Initialization Routines","Since the SWS performs HKCU hive and user's profile virtualization, it is possible to enforce some user-interface predefinitions for applications running under SWS. Examples include disabling or extending some shell features, adding configuration shortcuts on Desktop or Start Menu, importing some files from the original profile, and the like. Also, the SWS performs automatic changing of desktop background wallpaper when switching from default desktop to secured one and vice versa.","Additional User-Interface Features","After creating a virtual desktop, the SWS creates notification area (tray) icons both on secured and default desktops. These icons allow switching between desktops and closing of the SWS. The notification icon on the secure desktop is used also to display some user information messages and security warnings (e.g., as information balloons). The SWS draws a special icon on the right side of titles for all secured applications, to provide user feedback\/psychological conviction that he or she is working in a secure workspace.","De-Initialization","On the exit command (that can be given directly from the notification icon menu or by ExitWindowsEx API call invoked from any secured application), the SWS starts the de-initialization procedure or method.  is a flowchart illustrating a method  of the present invention for de-initialization. At step , the method queries all applications currently running in the SWS for shutdown, by sending them WM_QUERYENDSESION and WM_ENDSESSION messages. This allows applications to ask the user to save any information before shutdown. Next, at step , all running SWS applications are terminated. The pipe server is closed at step , and all encrypted files are deleted from virtual user profile at step . Finally, at step , the method  concludes by deleting HKCU\\CPSecured registry key.","Overview of Enhanced Secured Workspace","The present invention enhances the secure workspace system to protect web sessions on unmanaged computers. Consider, for example, a user who wants to do online payments from his or home personal computer.  is a block diagram illustrating an unmanaged computer  that has established Internet connectivity a session with a protected web resource (e.g., company portal ). Here, \u201cunmanaged\u201d means that the computer is largely (if not exclusively) under control of the user, without active oversight by a system administrator. The unmanaged computer  is provided with a virtualized \u201csecure workspace\u201d session (SWS)  that blocks malware threats to applications running in the SWS, thereby allowing the unmanaged computer  to safely and securely communicate with the protected web resource . As shown, in the secure workspace  secures the session from a malware threat already present on the unmanaged computer itself.","The present invention also enhances the secure workspace to protect computers (typically, corporate or \u201cmanaged\u201d computers) from Internet-based threats.  is a block diagram illustrating a managed computer  that has Internet connectivity, for example to connect to a company portal . The managed computer  is provided with an enhanced secure desktop  that secures the computer  from Internet threats, such as bad or malicious websites . Significantly, the enhancements to the secure workspace include the following features.","Separation of Privileges","Two OS (e.g., Windows) sessions are created on the computer. One is a default session (e.g., normal Windows desktop that user usually sees when he logins to the Windows); the other session (sometimes referred to herein as a secure workspace session) is shown inside the normal desktop as a window running another desktop. In other words, two \u201cusers\u201d with different privileges are simultaneously logged into the operating system at the same time. One of the sessions (\u201chosted session\u201d) is shown as a window inside another session (\u201cdefault session\u201d). System privileges for the user in the hosted session are different from the user in default session. In addition, the hosted session uses SWS virtualization technology previously described in this document so as to secure software applications running in the hosted session from other applications (e.g., malware) outside the hosted session.","Application of Security Policy","The system administrator may create a security policy for which includes applying different rules to each of the workspace sessions (e.g., the default session, the hosted session and\/or other workspace sessions created as described herein). An example of such policy for a simple scenario involving a default session and a hosted session as described above can include:","1. Default session can access Intranet only, but not Internet.","2. Business applications can run only in the default session.","3. All instant messaging applications, peer-to-peer (P2P) software and web browsers can be started only in hosted session.","4. Hosted session required to be virtualized; all changes are done not in real file system but in virtual (temporary) one, all changes to the registry are also done in virtual (temporary) registry storage.","5. Hosted session (optionally) is required to be flushed when the user logs off; all temporary data, files and registry changes that happened during the hosted session are discarded.","6. Log file (optionally) created for the user sessions, so that system administrator can review it.","Those skilled in the art will appreciate that the foregoing is only one example of some possible rules of a security policy. Users may implement security policies including a wide variety of rules and security measures applicable to software applications running in one of the workspace sessions. In addition, although the above example references two sessions (default session and hosted session), it should be understood that a plurality of secure workspace sessions may be created in accordance with the methodology of the present invention. Each said secure workspace session may be subject to different privileges, security rules, security measures and the like and secured against access from other sessions or external threats as described herein.","User Interface","1. Concurrent Session",{"@attributes":{"id":"p-0215","num":"0214"},"figref":"FIG. 6","b":["610","600"]},"2. Multiple Hosted Sessions","As an alternative approach to the design of the user interface, multiple sessions may be concurrently hosted, with each secure workspace session serving a particular purpose. In that alternative design, the default desktop is configured to include shortcuts to run hosted sessions for different purposes, such as:","Browse the Web (Internet)","Browse Intranet","Read confidential documents","Run business application","Run personal application","Evaluate software","Securely connect to remote site (e.g., using VPN)","Different backgrounds or logos may be selected to distinguish each hosted (secure workspace) session, to further improve user experience or position company brand information.","Additional enhancements may be performed as follows:","(1) Apply additional security measures on a per session basis, such as anti-keylogger and anti-screen-grabber to a particular hosted session.","(2) Apply additional file scanning and antivirus measures on a per session basis, including (optionally) flushing any hosted session where a bad file is detected.","(3) Stream (preinstall) particular applications into a hosted session; for example, a default session need not include a web browser and instant messaging application as installed software, but may make such applications available in a particular hosted session (i.e., applications are streamed to the hosted session).","(4) Stream documents or data files (e.g., .PDF, .XLS, .DOC, or the like) into a hosted session.","(5) Create a security policy-based login account for a particular hosted session, including streaming business applications (with or without data) into the hosted session pursuant to the policy.","(6) Create firewall rules that are session specific, such as different rules for default and hosted sessions.","(7) Set up VPN connection to the remote site inside hosted session. In this case user experience can be further improved with created shortcut on the default desktop, such as \u201cConnect to the main office network\u201d.","(8) Invoke hosted session after a special event is detected. Exemplary events may include (but not limited to): invoking browser software, going to the web site with SSL support, and clicking on the web link inside email letter or IM message.","(9) Programmatically set up encryption key for a hosted session. In this case, sensitive data will be protected and can be restored by the system administrator later.","(10) Configure hosted session to save document files (e.g., .PDF, .DOC, .XLS) on the network drive. In such cases, confidential files can be easily archived and audited.","(11) Configure hosted session to save executable files on the network drive. There, they can be easily scanned by (corporate) antivirus software.","(12) Restrict access to peripheral devices from a hosted session. Such devices can include: PDAs, smartphones, flash drives, and the like. Such restrictions will provide greater protection for sensitive information.","Detailed Internal Operation","Introduction","The SecureDesktop (SD) system of the present invention allows one to work with several user accounts (secure workspace sessions) simultaneously. In the currently preferred embodiment (operating on the Microsoft Windows platform), this is achieved through Microsoft Windows' Remote Desktop Connection (RDP)\u2014that is, the way Microsoft Windows achieves remote control of a machine. The SD system of the present invention uses the same API as RDP does, but does so in a manner that bypasses two restrictions: a) RDP does not allow connection to the machine where it is started, and b) Microsoft Windows license may prevent a user from opening more than one session at a time except on Windows Server platforms.","In order to understand how the SD system of the present invention is organized, it is instructive to look at how a session is represented in Windows OS, including understanding how different components interoperate. The components of interest include: Subsystem, Base named objects (BNO), Session space, Raw Input Thread (RIT), Console, Initial Command, Session, and Session manager. These will be explained in turn.","Subsystem refers to the part of the OS (operating system) providing a subset of its API. Microsoft Windows OS, for example, includes different subsystems: Win32 user API (as opposed to Win32 kernel API, user part is provided by user32.dll at a higher level), POSIX API, more may be added. Process csrss.exe is responsible for providing this API.","Base named objects (BNO) collectively represents a directory (kernel object, not a file system directory), containing all named IPC (inter-process communication) objects.","Session space is a special range of virtual addresses in high part of memory (above 0x80000000). Windows memory manager maps them to specific physical pages based on the session currently active. The exact address limits depend on OS version used. All session-specific modules and data (e.g., video drivers) reside in this memory area.","Raw Input Thread (RIT) is a thread responsible for providing user input (key presses, mouse movements, and the like) to user applications. This thread communicates directly with input device drivers.","Console is a set of output and input devices.","Initial Command is a process responsible for user authentication, launching all other processes, managing UI objects, and so forth; typically, this is winlogon.exe for a default Windows session. For creation of secure workspace sessions (hosted sessions), the initial command process operates as hereinafter described.","Session is a structure characterizing a session. It is associated with its own subsystem process, initial command process, unique session id (numerical, where initial session is id of 0, and thereafter incremented for later sessions), BNO, own session space (and as such own video driver, a Win32 subsystem specific), RIT (Win32 subsystem specific), and console (Win32 subsystem specific).","Session manager (smss.exe) is a process or module of the present invention which is responsible for creating and destroying sessions. For that purpose, it exposes an API for managing sessions via LPC port.","Service descriptor table is an indexed array, where the index is the number of an OS kernel function and the value is a pointer to the OS kernel function.","In accordance with the present invention, the SD provides the user with an additional session and a virtual console represented with a window on a screen in a user's default session. To achieve this, the SD starts a session, provides video driver redirecting its output to a window, and provides input devices that take and get input data from a window. The description which follows focuses on implementation details of this process.","Session Creation",{"@attributes":{"id":"p-0253","num":"0252"},"figref":"FIG. 7A","b":["700","701","703","701","705","702","704","702"]},"SessionPortServer.cpp:SessionPortServer::createSession","Native Windows logon (winlogon) is not used, as it requires extra authentication and the user may not be licensed to run two active sessions on non-server OS'es. As shown at , the session request from the user program  is routed through the Session Port Server (CPSMSERV)  to the Session Manager (SMSS)  through the SmApiPort . The Session Port Server  is responsible for creating and terminating sessions by calling the Session Manager  through the SmApiPort . In response to the above session request, the Session Manager (SMSS)  creates a session (hosted session)  and starts two processes inside it: Win  subsystem (csrss.exe)  and CPLogon (initial command) . The Session Port Server  is also responsible for controlling the Win32 subsystem (csrss.exe)  state and session devices (indirectly through csrss.exe) as hereinafter described. In addition, the Session Port Server  enables one-time interception through a helper driver as discussed below.",{"@attributes":{"id":"p-0256","num":"0255"},"figref":["FIG. 7B","FIG. 7B","FIG. 7B","FIG. 7B","FIG. 7C"],"b":["720","711","711","727","726","711","727","728","722","729","711","702","725","722","728","727","727","702","728","711","728","711","702","711","721","721","722","702","725","711","727","711","715","725","702","728"]},{"@attributes":{"id":"p-0257","num":"0256"},"figref":"FIG. 7C","b":["730","733","715","711"]},"The SD's mouse  and keyboard device  are implemented as a shared queue of input events (vmouse.c:VMouseCreateDevice, vkbd.c:VKbdCreateDevice). The queue is a shared memory block with two signals (filled\/empty), shared between userspace and kernel mode. The subsystem starts the Raw Input Thread (RIT) , which connects to the SD's mouse  and keyboard  using handles obtained through helper driver  during the previous initialization stage depicted at . The RIT  reads events, which results in polling the queue (sharedrwqueue.c:SharedRWQueueReadIntolrp). These operations are described in further detail below.","Initial Command","The initial command serves to login a user, create required UI objects and adjust kernel object privileges for the hosted session. It also starts a shell process. If virtualization is required for the session, the shell process will be suspended and its handle will be duplicated to a virtualization manager.",{"@attributes":{"id":"p-0261","num":"0260"},"figref":["FIG. 7D","FIG. 7D"],"b":["740","713","715","741","715"]},"As subsequent operations involve Win32 user API, before proceeding a check is made to make sure the subsystem process has completed initialization. When the subsystem status is <<idle>>, subsystem initialization is complete and initial command received credentials (username\/password) for a new session as shown at  at . The credentials are chosen by a user when a session is about to be started. Alternatively, the credentials may comprise predefined values for a limited account when used for a virtual session (Session.cpp:Session::Session for request, SessionPortServer.cpp:SessionPortServer::respondWithSessionInfo for response). The credentials are used for user logon (UserToken.cpp:UserToken::UserToken) and its profile is loaded (UserToken.cpp:UserToken::loadProfile).","The user account that has been created is now granted access to session BNO (BaseNamedObjects)  as illustrated at  at , so that new processes can use named IPC (inter-process communication) objects (UserAuth.cpp:UserAuth::grantAccessToObjectsDirectory). A window station is created as shown at  and two desktops are allocated as shown at  at : a limited logon desktop and a user desktop (Session.cpp:Session::executeShell). User privileges are granted to the window station and desktop, so that new processes can manipulate UI objects. A notification window is also created (Session.cpp:Session::notificationThread) and registered with the help of driver (desktopui.c:SetLogonNotifyWnd). This notification window will receive shutdown notification when session termination is requested. Next, user profile settings are updated (UserAuth.cpp:UserAuth::updateSystemInfoForUser) and user themes are applied (UserAuth.cpp:UserAuth::enableThemes). Finally, a shell launcher (userinit.exe)  is started with privileges provided by previously retrieved credentials (as described above and illustrated at  at ). This involves authenticating a user, creating an environment block for a user, appending profile variables (UserAuth.cpp:UserAuth::appendProfileData) and starting a process (UserAuth.cpp:UserAuth::launchProcess).","Getting Video Output from Session","At this point, a user is running in another session on another desktop. To obtain video output from the session, another application is started that simply maps the video memory file created by the video driver and copies it onto a window (videomemory.c:VideoMemory_GetSharedMemory, virtualmonitor.c:VirtualMonitor_Update).","Providing Mouse and Keyboard Input for the Session","The same application used to display session screen handles also passes input events to another session. For these purposes, low-level keyboard and mouse hooks are enabled as soon as application window(s) becomes active (appmon.c:InitAllHooks, appmon.c:EnableInputHook). These hooks are disabled as soon as input focus leaves application window(s) (appmon.c:StopInputHook). Hook functions translate window messages to driver-level input event structures and pass them to virtual keyboard\/mouse devices set up earlier by the driver via shared queue (hookmouse.cpp:MouseHook, TranslateEventToInputData; hookkbd.cpp:KbdHook).","Terminating Session","Termination of the session involves two general stages. The first stage involves telling the subsystem to stop.  is a block diagram  illustrating the first stage of session termination. Using the same external user program  used to start the session (i.e., as shown at ), an <<exit windows>> message (ExitWindowsClientState.cpp:ExitWindowsClientState::replyToMessage) is sent to the Win32 subsystem (csrss.exe)  as shown at , at . This message causes the subsystem  to send shutdown notification as illustrated at  to the registered window of initial command . In turn, initial command  calls ExitWindowsEx requesting system shutdown as shown at  at . It will correctly stop all processes running inside the session, except for the subsystem process  and initial command . Initial command  is then responsible for cleaning up all UI objects and for notification to CPSMSERV  that the first stage of the shutdown process is complete (Session.cpp:Session::disconnect) as shown at  at .",{"@attributes":{"id":"p-0270","num":"0269"},"figref":["FIG. 8B","FIG. 8B","FIG. 8B"],"b":["820","711","702","821","711","825","702","701","703","823"]},"While the invention is described in some detail with specific reference to a single-preferred embodiment and certain alternatives, there is no intent to limit the invention to that particular embodiment or those specific alternatives. For instance, those skilled in the art will appreciate that modifications may be made to the preferred embodiment without departing from the teachings of the present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2B","FIG. 2A"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 3A-B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 7C"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7D"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8B"}]},"DETDESC":[{},{}]}
