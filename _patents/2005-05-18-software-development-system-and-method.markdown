---
title: Software development system and method
abstract: A computer design model processing system and methods are described that can create visual models of computer systems, store versions of design models in a centralized repository, automatically generate and deploy computer software systems in response to the stored computer design models, define dependencies between computer design models, and automate and assist the development of multiple, possibly dependent, computer design models by multiple developers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07735062&OS=07735062&RS=07735062
owner: OutSystemsâ€”Software em Rede, S.A.
number: 07735062
owner_city: Linda-a-Velha
owner_country: PT
publication_date: 20050518
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY","FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Visual Modeling","Entity-Relationship Sub-Models","User Navigation Sub-Models","Business Rule Sub-Models","Visual Modeling Environment","Design Model Descriptions","Entities","Structures","Actions","Screen Flows","Model Versions Repository","Version Tags","Generation and Deployment of Computer Software Systems","Design Model References","Model References and Interfaces","Managing References Among Design Models","Adding, Removing, and Updating References","Operation of Design Model References","Generation and Deployment of Public Elements","Automated Modification of Design Models","Opening Design Models","Merging Model Versions","Merging of Design Models","Retrieving a Model","Submitting a Model","Ramifications and Scope"],"p":["This application claims the benefit of U.S. Provisional Patent Application Ser. No. 60\/646,112, filed Jan. 21, 2005, entitled \u201cWeb Services Implementation System.\u201d","The present invention relates to the development of computer software systems, specifically to those developed using computer design models. More particularly, the invention relates to facilitating the modification of multiple interrelated computer software design models.","Development of web-based computer software systems can be very complicated, and therefore difficult to accomplish. Developers of such systems often need to be familiar with a wide range of technologies for describing and implementing complex software systems, including modern object-oriented programming languages, XML and specific schemas, specific query's and transformations schemes, scripting languages, interface definition languages, process description languages, database definition and query languages, and more. For example, a typical web-based computer software system might include application logic written in an object-oriented programming language, XML for transmission of data between computer software sub-systems, SQL for storing and retrieving data in databases, and WSDL for describing the interfaces to web-based services. There are complexities, involved in getting such technologies to work effectively together, without even considering the business problem to be solved for the end user.","Translating from the requirements of a business problem to an implemented distributed solution using these technologies typically requires a good understanding of each of the various architectures and protocols that make up the solution. Furthermore, end-users expect the resulting software system to be fast, available, scalable, and secure even in the face of unpredictable demand and unreliable network connections.","In areas other than software development, such as electronic consumer products, industrial manufacturing processes have enabled manufacturers to deliver products that have a high degree of reliability at low cost, coupled increasingly in many cases with the ability to have items customized to satisfy individual needs. Building mechanical or electronic systems involves the coordination of a complex chain of manufacturing steps, many of which are wholly or partially automated. It can be useful for computer software system developers to apply manufacturing-like principles to the construction of software.","This can be accomplished, at least in part, by raising the level of abstraction for describing computer software systems. Abstractions can be used in connection with a modeling language to build computer design models that represent a problem domain that is being addressed by a particular computer software system, instead of focusing on one particular technological problem, such as programming, data interchange or data storage. Generally speaking, a model is a computerized representation in which each element in the representation corresponds to an element or concept in a given domain. Models allow a problem to be precisely described in a manner that avoids delving into technological detail, and they allow the problem to be described using terms and concepts that are familiar to people who work in the domain of the problem, rather than in terms only familiar to information technology experts. Models thus can be used to help bridge the gap between business and technology.","In embodiments of the invention, models are used to capture high-level information that is otherwise typically expressed informally. Models can be used to facilitate the manual development of executable programs, or can be used to automatically implement executable programs. The latter is beneficial because with the manual approach, high-level information can get lost in low level artifacts, such as source code files, where it is difficult to track, maintain or enhance consistently.","Furthermore, information captured by models can be used to efficiently assist the creation and modification of interrelated computer designs by concurrent developers. One implementation of the present invention, includes a visual modeling environment that provides computer software system developers the ability to easily create computer design models that express the behavior of an intended computer software system. The implementation also includes a application generator that further translates the computer design models into an actual computer software system. Each design model is structured and transmitted between the visual modeling environment and an application generator in XML format. Each model typically includes a set of sub-models expressing distinct aspects of the system, including (a) a set of user navigation sub-models that define the way end-users will interact with the computer software system; (b) a set of business rule sub-models that define the data processing rules to be executed upon user interaction; (c) a set of data transmission sub-models that define data message formats to be carried among models and sub-models within a computer software system; (d) and a set of entity-relationship sub-models that define how data is structured in persistent repositories.","Each of the sub-models and their component elements can be translated by the application generator into appropriate artifacts to be jointly deployed into an application server system and a relational database management system for execution, as appropriate. The visual modeling environment provides computer design model developers the ability to easily identify and accept or reject modifications to a computer design model or other related computer design models, using an intuitive graphical user interface, prior or after regenerating the computer design model into a new actual implementation of the intended computer software system. These and other advantages of the invention will appear more clearly from the following detailed description.","In general, in one aspect, an embodiment of a method for facilitating the modification of computer design models that each define a software program facilitates the modification of design models that are affected by a change to another design model. The method includes receiving a modified computer design model that is a modification of an original design model. The method includes comparing the modified design model with the original to identify changed elements, and identifying design models other than the modified design model that are dependent on the changed elements of the modified design model. The method also includes facilitating the modification of the identified other design models to accommodate the changed elements. Various embodiments can include the following details and variations.","The method can include, prior to the receiving step, the step of facilitating the modification of a computer design model by displaying a graphical representation of the design model. The graphical representation can enable changes to be made to the model. The method can include, prior to the receiving step, the step of creating referencing elements to other computer design models from the said computer design model. For example, a model can reference elements of another model, and these referencing elements can be specified.","The method can include, prior to the receiving step, the step of storing information about the design model in file, for example an XML format file. The method can also include the step of automatically generating an executable program for use in an application server system in response to the modified design model. The method can also include automatically generating a persistent data structure description, for example, a database schema and\/or database table, for use in a relational database system in response to the modified design model.","In one embodiment, the computer design model includes a data persistency sub-model containing entity elements that define one or more data structures for storing data operated on by the said software program, a data structure sub-model containing structure elements defining one or more hierarchical data structures for transmitting information from and to the said software program, and a behavior sub-model containing action elements that define a set of sequential and conditional instructions that define a business rule of the said software program.","In one embodiment, the method includes, prior to the comparing step, the step of storing the modified computer design model in a source control repository. This can be accomplished by one or more of the following steps: creating a new version record in the source control repository; storing an XML file in the source control repository such that it is attached or related to the new version record; extracting the design model interface specifications in XML format; storing the design model interface specification in the source control repository attached to the new version record; extracting a list of other design models to which the design model includes references to; and storing the list of other design models to which the design model includes references to, attached to the new version record.","The source control repository can be based on a relational database. The step of extracting the design model interface specifications in XML format can include one or more of the following sub-steps: generating an in memory representation of the model; searching the in memory representation of the model to find elements defined as interface elements; creating an XML element in the said design model interface specification for each entity interface; creating an XML element in the said design model interface specification for each structure interface; and creating an XML element in the said design model interface specification for each action interface.","The step of extracting a list of other design model models to which the design model includes references to can include creating an in memory representation of the model; searching the in memory representation of the model to find referencing elements; and querying the source control system about the referenced other computer design model in response to the referencing elements.","The step of comparing the modified design model includes the sub-steps of retrieving the original design model interface specification, parsing the original design model interface specification to create a first in memory representation of the design model interface specification; retrieving the modified design model interface specification; parsing the modified design model interface specification to create a second in memory representation of the design model interface specification; comparing the first and the second in memory representations to identify any elements that are deleted in the representation of the modified design model; and comparing the first and the second in memory representations to identify any elements that are changed in the representation of the modified design model.","The step of identifying design models other than the modified design model that are dependent on the changed elements can include one or more of the following steps: receiving a list of deleted or changed elements in the modified version of the design model; retrieving a list of other design models that include references to the original design model from the source control system; and determining which other design models include references to the deleted or changed elements in the modified version of the design model.","The step of facilitating the modification of the identified other design models can include one or more of the following steps: receiving a list of other design models that depend on the deleted or changed elements in the modified version of the design model; displaying the list of design models for review and selection; and upon user command, providing each of the design models for modification of said referencing elements.","A system for implementing the method can include software running on a programmable computer. For example, the system can includes a receiving module for receiving a modified computer design model that is a modification of an original design model. The system also can includes a comparison module for comparing the modified design model with the original to identify changed elements, and and identification module for identifying design models other than the modified design model that are dependent on the changed elements of the modified design model. The system also can include a facilitation module for facilitating the modification of the identified other design models to accommodate the changed elements. Each of these modules can be implemented in software and or hardware, on the same or on different computers, as appropriate for the implementation. These modules can also be provided in the form of computer code stored in a computer-readable medium.","In general, in another aspect, a method for providing a first computer design model includes determining whether any references are changed or missing. This allows a developer to be notified about the changed or missing references, for example, at the time that the first computer design model is provided.","In one embodiment, a method for providing a first computer design model includes identifying references in the first computer design model to elements of other computer design models; locating the most current interface specifications for the identified references to elements of other computer design models; comparing the most current interface specification for the elements of other computer design models with previous interface specifications for the elements of other computer design models; and determining, in response to the comparing step, whether any references in the first computer design model to elements of other computer design models are changed or missing.","The first computer design model may be stored in a source control repository. The first computer design model may include referencing elements to other computer design models.","The method also includes, prior to the step of identifying references, the step of specifying a version of a computer design model to be provided, by displaying a graphical representation of the source control repository content.","In one embodiment, the step of identifying references includes retrieving the first computer design model from the source control repository; and parsing the first computer design model to list said referencing elements to other computer design models.","In one embodiment, the step of locating the most current interface includes receiving a list of referencing elements to other computer design models; querying the source control repository for the list of other design models, whose interface is being referenced; and retrieving the interface specification of the most recent version of each of the other design models.","In one embodiment, the step of comparing the most current interface step includes receiving the current interface specification for each of the referenced other design models and parse them to create in memory representation of the other design models interface specification; extracting the first design model element interface specifications and parse them to create an in memory representation of the first design model expected interface specifications to referenced elements; and comparing the first design model element interface specifications with the other referenced design models interface specifications.","In one embodiment, the step of determining whether any references are changed or missing step includes receiving the other design models current element interface specifications that are changed or missing; facilitating the substitution of the interface specifications to referenced elements in the first design model with the current interface specification to referenced elements in other design models; and automating the substitution of the references to the interface specifications accordingly to the current interface specifications.","A system for implementing the method can be implemented with software running on a programmable computer. For example, the system can include an identification module for identifying references in the first computer design model to elements of other computer design models; a location module for locating the most current interface specifications for the identified references to elements of other computer design models; a comparison module for comparing the most current interface specification for the elements of other computer design models with previous interface specifications for the elements of other computer design models; and a determination module for determining, in response to the comparing step, whether any references in the first computer design model to elements of other computer design models are changed or missing. Each of these modules can be implemented in software and or hardware, on the same or on different computers, as appropriate for the implementation. These modules can also be provided in the form of computer code stored in a computer-readable medium.","In general, in one aspect, a method for facilitating collaborative use of a computer design model, includes receiving a specification for a file containing a computer design model. The specification identifies the file's computer network location. The method also includes determining whether the computer design model in the specified file is the version most recently stored in a repository. The most recently stored version may be the most recently published version, meaning that the executable code generated from that model is published to the web site and may be in operation. If the version of the computer design model in the specified file is not the most recently stored, the method includes facilitating the selection of elements of the computer design model in the specified file, and elements of the most recently stored version.","In one embodiment, upon determination that the computer design model in the specified file is the not the most recently stored in a source control repository, the user is provided with the choices of editing the version of the computer design model in the specified file, downloading the most recently stored version, and merging the version of the computer design model in the specified file with the most recently stored version. In one embodiment, the step of facilitating the selection of elements is performed upon the user choice of merging the version of the computer design model in the specified file with the most recently published version.","Optionally, prior to the step of determining whether the computer design model is the most recently stored, the method can include facilitating the selection of a repository by prompting the user to select a repository available on a computer network.","In various implementations, the file can include any useful data for the purposes described here. In one implementation, a file containing a computer design model includes a list of design model history descriptors, each of them comprising information about a user who provided the design model version to be stored, a moment in time when the design model version was provided to be stored; and a repository where the design model version was stored.","In one embodiment, the method includes annotating a computer design model with version information, for example by assigning a global unique identifier to the design model and\/or by annotating the design model with a history descriptor, including a timestamp of the creation, a base version number and an identification of the user who created the design model.","In one embodiment, the method includes determining whether the computer design model is the most recently published by retrieving the file comprising the computer design model from a specified computer network location, parsing the file to extract a design model global unique identifier and a first design model history descriptor, querying a repository for the most recently stored version of the design model using the extracted design model global unique identifier, parsing the most recently stored version of the design model to extract a second design model history descriptor, and comparing the first history descriptor with the second history descriptor to determine whether the computer design model in the specified file is different from the most recently stored version.","In one embodiment, the step of facilitating the selection of elements of the most recently published version also may include presenting a comparison of the elements of the first computer design model with the elements of the second computer design model, facilitating selection of elements in the second model for merging into the first model, presenting an indication of the merging action to be taken for each selected element, and taking the indicated action, thereby merging the first version with the second version. Facilitating the selection of elements of the most recently published version may include presenting a visual comparison of the elements, for example, a visual indication of new elements, changed elements, and deleted elements. The indicated action may be taken upon user confirmation.","A system for facilitating collaborative use of a computer design model when opening the design model may include software and\/or hardware implementations of any or all of the above elements. For example, the system can be implemented with software modules running on a computer. The system may include a receiving module for receiving a specification for a file containing a computer design model, a determining module for determining whether the computer design model in the specified file is the version most recently stored in a repository, and a facilitation module that, upon a determination that the version of the computer design model in the specified file is not the most recently stored, facilitates the selection of elements of the computer design model in the specified file, and elements of the most recently stored version.","In general, in another aspect, a method for merging a first version of a computer design model with a second version of a computer design model includes presenting a comparison of the elements of the first computer design model with the elements of the second computer design model, facilitating selection of elements in the second model for merging into the first model, presenting an indication of the action to be taken for each selected element, and taking the indicated action, thereby merging the first version with the second version.","The computer design model may contain one or elements that can be merged, and can include a data persistency model comprising entity and attribute elements that define a data structure for storing data from the software program, a data structure model containing structure and attribute elements that define an hierarchical data structure for transmitting information from and to the software program, a behavior model containing action elements that define a set of sequential and conditional instructions that define a business rule of the software program, and a user navigation model containing screen elements that define the visual and interactive content for presenting information to the end-user of the software program.","The elements can be presented visually, for example as a list of new elements, a list of deleted elements, a list of local changed elements, a list of foreign changed elements and a list of conflict elements. The elements of the first version may be presented in a first visual list, and the elements of the second version in a second visual list. The elements of the first and second lists may be annotated with specific visual marks that denote the element status, as one of new, changed or conflict, and the elements of the first and second lists annotated with specific visual marks that denote non-existing elements, including marks in the first list for elements that are deleted in the second list and marks in the second list for elements that are new in the first list. The method may also include selecting all the elements of the first list automatically, and upon user selection of elements or non-existing elements in the second list, updating the first list with specific visual marks that denote the merge action to be taken, as one of merge, remove or replace.","Taking the indicated action, thereby merging the first version with the second version may include determining which new elements of the second list are selected, merging the corresponding element of the second version into the first design model version, determining which deleted elements of the second list are selected, removing the corresponding element from the first version, and determining which changed or conflict elements of the second list are selected, replacing the corresponding element of the first version with the corresponding element of the second version.","A computer design model can be stored in a persistent repository. Upon creation, a global unique identifier may be assigned to the model, as well as history descriptor information. The computer design model can be annotated with version information upon modification, and annotated with history descriptor information that includes a timestamp of the modification and an increment to the version number of the previous most recent history descriptor.","Elements can also be annotated with version information, such as a global unique identifier and a version tag, the version tag including, for example, a timestamp of the creation and a base version number. Upon modification, a computer design model element can be annotated with version information, replacing the version tag of the element with a new version tag, for example, including a timestamp of the modification and an increment to the previous version number.","The visual comparison of elements described above can be performed by receiving the second version of the computer design model, comparing the version history descriptors of the first and second versions to obtain a baseline history descriptor, and comparing the version tags of the elements of the first and second versions to provide a list of new elements, a list of deleted elements, a list of local changed elements, a list of foreign changed elements and a list of conflict elements. The step of comparing the version history descriptors may include parsing the first version to extract a first list of version history descriptors, parsing the second version to extract a second list of version history descriptors, and comparing the first and the second lists of version history descriptors to determine the baseline history descriptor as the most recent history descriptor that is present in both lists.","The step of comparing the version tags of the elements may include parsing the first version to extract a first list of elements, comprising all elements in the first version, parsing the second version to extract a second list of elements, comprising all elements in the second version, and comparing the global unique identifiers of the elements in the first and second lists to obtain the list of new elements, including all elements that are exclusively present in the first list, comparing the global unique identifiers of the elements in the first and second lists to obtain the list of deleted elements, including all elements that are exclusively present in the second list, comparing the first and the second lists to obtain the list of local changed elements, including all elements that are present in both the first and the second lists, where the timestamp in the version tag of the element in the first list is ulterior to the baseline version history descriptor timestamp and the timestamp in the version tag of the element in the second list is prior to the baseline version history descriptor timestamp, comparing the first and the second lists to obtain the list of foreign changed elements, including all elements that are present in both the first and the second lists, where the timestamp in the version tag of the element in the first list is prior to the baseline version history descriptor timestamp and the timestamp in the version tag of the element in the second list is ulterior to the baseline version history descriptor timestamp; and comparing the first and the second lists to obtain the list of conflict elements, including the elements that are present in the first and the second lists, where both the timestamps of the version tags of the element in the first and the second lists are ulterior to the baseline version history descriptor timestamp.","A system for facilitating collaborative use of a computer design model when opening the design model may include software and\/or hardware implementations of any or all of the above elements. For example, a system for merging a first version of a computer design model with a second version of a computer design model includes comparison module for presenting a comparison of the elements of the first computer design model with the elements of the second computer design model, a selection module for facilitating selection of elements in the second model for merging into the first model, and indication module for presenting an indication of the action to be taken for each selected element, and an action module for taking the indicated action, thereby merging the first version with the second version.","In the following description, numerous specific details are set forth in order to provide a more thorough understanding of the present invention. It will be apparent, however, to one skilled in the art, that the present invention may be practiced without, or with a variation on, these specific details.","Moreover, the system and methods can be implemented using software that is stored on one or more processor-readable storage mediums and executed using one or more processors. Each of the identifiable software components can be executed by the same or distinct processors communicating across a distributed network of computers, or some combination. For example, the visual modeling environment described below can be executing using a processor and the application generator described below can be executed using another processor.","Reference in this specification to \u201cone case\u201d (e.g. one embodiment, one implementation, etc.) means that a particular feature, structure, or characteristic described in connection with the case is included in at least one case of the invention. The appearances of the phrase \u201cin one case\u201d in various places in the specification are not necessarily all referring to the same case, nor are separate or alternative cases mutually exclusive of other cases. Moreover, various features are described which may be exhibited by some cases and not by others. Similarly, various requirements are described which may be requirements for some cases but not other cases.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 1","b":["99","100","101","101","101","101","100","101"]},"Computer design models  describe, using abstractions, the intended behavior of a computer software system. Examples of functionality provided by such computer software systems include: login verification, notification, database storage, order processing, electronic wallet, calendar\/scheduler, directories, news and information, and so on. This functionality can be combined with other functionality to support business processes. Using the modeling environment , it is possible for a developer , to model distinct aspects of a computer software system, such as (a) the user navigation and user interface content to be presented to end-users; (b) the business rules that apply to the execution of the interactive events triggered by the end-user; (c) and the data transmission and data repository formats and relationships that support the execution of the application. These distinct aspects, in some implementations, can describe the intended behavior of the computer software system.","Once a model is designed, it is compiled into a model description document  to be submitted to a model version repository . The visual representations of the models in the modeling environment  are translated into a structured representation used for processing by other components of the system . The modeling environment  is responsible for creating a model description  document from visual representations. As described below, the model description document  can be generated at various times, for example when a developer  triggers the submission of a model to the model version repository .","In one embodiment, the model description  document is structured using XML (extensible Markup Language). XML is a language that can be used to describe information, or to make information self describing, and which can facilitate mapping of visual models into a structured representation that can be parsed by other components of the system .","The version repository  stores the model descriptions . By storing versions as development progresses, the repository retains information about how and when a computer design model changed over time. For each model, a model description  is stored along with information about the evolution of the model. At any point in time, an authorized developer  can add a new version of a model to the version repository . Additionally, the version repository  is integrated with the visual modeling environment  to support collaboration among concurrent developers . In the simplest case, one single developer  adds revised versions of a computer design model to the version repository . In more complex implementations, multiple developers  retrieve and add distinct versions of a computer design model to and from the version repository . In such scenario, the modeling environment  can assist the developers  to accept or reject modifications performed by others such that a coherent version is stored in the version repository  that can supersede other versions.","The model version repository  is preferably based on a database server such as Microsoft SQL Server or Oracle Database and accessed via software services hosted in an application server system. These software services provide to the modeling environment  means to submit and retrieve models as well as to submit and retrieve information about repository  content.","In the context of the model processing system , an application generator  may be used to translate computer design models into an implementation of a computer software system. An implemented computer software system may include: an executable program  to run into an application server system , and a database definition  to be hosted in a relational database system . The user navigation and user interface aspects, as well as the business rule and data transmission aspects of the model, are translated into the executable program . The executable program can be any executable or interpreted program, for example a web application targeting the .NET.\u2122 platform from Microsoft Corporation or the Java 2 Enterprise Edition (J2EE) platform developed by Sun Microsystems.","The data repository aspects of the computer software system are translated into a database . The database can be any sort of relational database, for example a Microsoft SQL Server or an Oracle database. Given the nature of the intended computer software systems, and the level of abstraction provided, the generated Executable Program  is automatically configured to access the Database  according to the computer design model specifications.","Once the executable program  and the database  are available on the model processing system , respectively in the target application server system  and the relational database system , the application server system  can handle requests from end-users , for example, using a Hyper Text Transfer Protocol (HTTP) client , typically a Web Browser. This means that the elements in the model that denote the way end-users see and interact with the computer software system are generated as code, for example web pages that are hosted in an application server system  and served via HTTP to a client . A request generates a response that takes the form of a graphical user interface to be displayed in the client system . Some controls embedded in the graphical user interface may react to subsequent user generated events, and cause the browser to generate subsequent requests back to the application server system . For example, when a user presses a button visible in the client system , a form may be submitted to the application server system  that in response provides the content of a new interactive form to the client system .","In one embodiment, three types of sub-models are used to model a computer software system: (a) entity-relationship sub-models; (b) user-navigation sub-models; (c) business rule sub-models. Each of these sub-models contain details about the intended computer software system behavior, each of them modeling a different perspective with accurate abstractions that are directly related with the business domain and can be translated into an actual implementation to be hosted in a system including an application server system and a database system.","In order to better illustrate the present invention, an exemplary problem domain is presented, namely a computer software system to handle the registration of citizens of a country to store information about persons and cities and information about which persons live in which cities. The system also stores each person's name and age, as well as each city's name and population. The system enables listing, inserting and editing persons into a database using a graphical user interface. Every time a new person is inserted the population of the city where the person lives is incremented.","In one embodiment, a computer software system model can be composed of several sub-models, each of them providing one perspective of the computer software system under development, modeled using distinct modeling languages. The underlying model integrates such perspectives so that a self-consistent computer software system can be analyzed and built.","In the case of the illustrative example, the complete problem is expressed within a model composed of three sub-models. The complete design model for the intended computer software system includes, at least, an entity relationship sub-model (as presented in ), a user interface navigation sub-model (as presented in ) and a business rule sub-model (as presented in ).","Referring to , a type of model sometimes used to model a business domain is the entity-relationship diagram.","An entity-relationship diagram, like the example shown, is a specialized graph that can illustrate, for example, the structure for a persistent database, resembling the graphical breakdown of a sentence into its grammatical parts. Entities are rendered as rectangles  and . Relationships are portrayed as lines  connecting the rectangles  and . In a logical sense, entities are the equivalent of grammatical nouns, such as persons or cities. Relationships are the equivalent of verbs or associations, such as the act a person living in a city. Therefore, the problem domain of \u201cstoring information about all persons and cities and the information about which persons live in which cities\u201d can be modeled with a diagram such shown in the figure. The \u201cPerson\u201d entity  and the \u201cCity\u201d entity  are connected by means of the \u201clives in\u201d relationship , associating each \u201cPerson\u201d with a \u201cCity\u201d.","The figure also shows the data to be associated with each entity as entity attributes (, ,  and ). The entity \u201cPerson\u201d  contains two attributes: the \u201cName\u201d  and the \u201cAge\u201d . The entity \u201cCity\u201d  contains two attributes: the \u201cName\u201d  and the \u201cPopulation\u201d .","The same problem domain could have been expressed correctly using the Standard Query Language (SQL) as presented below, which is commonly used in conjunction with relational database management systems (RDBMS) to handle persistent data representations.",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CREATE TABLE CITY {"]},{"entry":[{},"\u2003\u2003NAME CHAR (200),"]},{"entry":[{},"\u2003\u2003POPULATION INT,"]},{"entry":[{},"\u2003\u2003CONSTRAINT CITY_ID PRIMARY KEY ("]},{"entry":[{},"\u2003\u2003\u2003\u2003NAME"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"};"]},{"entry":[{},"CREATE TABLE PERSON ("]},{"entry":[{},"\u2003\u2003NAME CHAR (200),"]},{"entry":[{},"\u2003\u2003AGE INT,"]},{"entry":[{},"\u2003\u2003LIVESIN CHAR (200),"]},{"entry":[{},"\u2003\u2003CONSTRAINT PERSON_LIVES_IN FOREIGN KEY ("]},{"entry":[{},"\u2003\u2003\u2003\u2003LIVESIN"]},{"entry":[{},"\u2003\u2003) REFERENCES CITY ("]},{"entry":[{},"\u2003\u2003\u2003\u2003NAME"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Unlike the visual model in , the SQL textual representation is bound to the technical implementation of a RDBMS. There is no direct mapping for nouns and verbs into an SQL construct. Using a model processing system, such as the system of the present invention, it is possible to define a direct mapping between the visual representations in the entity-relationship graph into an SQL textual representation, enabling developers to create, read, test and modify concrete computer software systems directly from design models in a much more efficient way, focusing on the business domain (like an entity-relationship diagram) instead of the technology domain (like SQL and RDBMS).","Entity-relationship diagrams may not be enough to model an entire computer software system since they are only sufficient to represent how the several entities that support the execution of that computer software system are organized and interrelated in a persistent repository.","A developer  benefits from being able to express how data shall be presented and organized to the end-user of a computer software system, for instance in a web page. A developer also benefits from an ability to express which business activity the computer software system shall take in response to user interaction. It also can be useful to model other parts of the problem domain such as: \u201clisting, inserting and editing persons into the database using a graphical user interface\u201d and \u201cevery time a new person is inserted the population of the city where the person lives must be incremented\u201d.","The user navigation sub-model of  comprises two nodes  and  that represent two web pages, a first web page , called \u201cList Persons\u201d for listing \u201cPerson\u201d entity data and a second web page  called \u201cEdit Person\u201d for editing an individual record of \u201cPerson\u201d entity data. The sub-model also includes four relationships representing transitions between pages upon user interaction. The transition , called \u201cSearch\u201d, from the first page to the same first page, presents a new result set of person records upon a search criteria input by the end user. A second transition  called \u201cNew\u201d from the first web page to the second web page, presents an edit form to input a new \u201cPerson\u201d entity record. A third transition , called \u201cEdit\u201d from the first to the second web page, presents an edit form to update one \u201cPerson\u201d entity data record. A fourth transition , called \u201cSave\u201d from the second to the first web page, stores a \u201cPerson\u201d entity data record according to data input in the second web page.","Referring briefly again to , the user navigation sub-model describes how an end-user  interacts with the application server system  to perform the intended business functions of the computer software system. Using a computer software system derived from the sub-model in , the application server system  could, for example, handle requests from an end-user  using a Hyper Text Transfer Protocol (HTTP) based client system , like a Web Browser. A request generates a response that takes the form of a graphical user interface to be displayed in the client system . The returned user interfaces are directly derived from the modeled content of a sub-model node (representing a web page) in the user navigation sub-model. Some of the embedded controls react to subsequent user generated events, and cause the client system  to generate subsequent HTTP requests back to the application server system . These subsequent requests will trigger a transition expressed in the user navigation sub-model. In response to the new request a new response is sent, containing the content of web page node that is the destination of the represented transition.","For example, given the sub-model in , an end-user  posts an initial request to the application server system , requesting access to web page , indicating a well-known Unified Resource Locator (URL), like for example, http:\/\/server\/citizens\/listpersons.aspx. The application server system  directs the request to the executable program  that implements the corresponding computer design model. The executable program renders the content of the web page  and sends it to the end-user's client system . The end-user  interacts with the web page. For example, if the end-user  presses the \u201cNew\u201d button, a request is submitted back to the application server system  to be directed to the executable program , given that the model expresses a transition to web page . The executable program  renders the content of the edit web page  and sends it back to the end-user's client system .","An example business rule shown in  is associated with the \u201cSave\u201d transition  in . When the end-user presses the \u201cSave\u201d button in the \u201cEdit Person\u201d web page resulting from node  of the user-navigation sub-model in , the business rule represented by the sub-model in  will be executed by the executable program . The business rule sub-model demonstrated in , includes four nodes , ,  and  that represent instructions about how the computer software system updates the database data upon user navigation from the first web page  to the second web page , upon selection of the \u201cSave\u201d operation  by pressing a button or a hyperlink. The relationships among the nodes in  represent the sequence of execution of the instructions in the context of the business rule. The example business rule is as follows: (a) create a new person record, invoking \u201cCreatePerson\u201d ; (b) step through to obtain the current data about the city where the person lives invoking \u201cGetCity\u201d ; (c) increment the population attribute of the city record\u201d (e.g.) instruction \u201ccity.population:=city.population+1,\u201d ; and (d) store the updated record of the city in the database invoking \u201cUpdateCity\u201d .","The execution of business rule sub-models is associated with events represented in the user navigation sub-model.","Some of the elements available in a business rule modeling language can enable the easy handling and transformation of data according to the entity-relationship sub-models. In the example of , the elements ,  and  represent data access instructions. Element  enables the creation of record of data into a database table derived from the \u201cPerson\u201d entity  in . Element  enables the retrieval of one record of data from the database table derived from the \u201cCity\u201d entity  in . Element  enables the update of one record of data into the database table derived from the \u201cCity\u201d entity  in .","Referring again to , as the end-user  posts requests to the application server system  triggering events using the user interface presented in the client system , if any business rule is associated with the triggered event, the corresponding implementation in the executable program  will be executed.","In one embodiment, a modeling environment  () presents computer design model and sub-models using a visual paradigm and stores the computer design models in a model description documents .","In one implementation of the visual application modeling environment, here shown in , editing a model comprises editing each of the sub-models that compose the model, one at a time, within a model canvas , that presents the sub-model according to a modeling language. Each type of sub-model may be described using a distinct modeling language.","In order to create the sub-models, the developer  uses a set of available constructs in a palette . These constructs can be dragged from the palette  into the model canvas  to create a new element in the sub-model. Once created in the model canvas , elements can be connected to establish relationships according to the modeling language. Depending on the type of sub-model being edited in the model canvas , the palette will only present the relevant specific constructs for the specific modeling language. For example, while editing a user-navigation sub-model, the palette will include constructs such as screens.","Following the example presented in , the model canvas  displays a graph depicting a series of web pages (the nodes) and possible navigation paths (the line connectors) among the web pages. Double-clicking the elements in the model canvas  results in the presentation of, dedicated editors that allow the developer to further define the behavior and semantics of the element. In the example of , the content of each web page in the model canvas  is not presented in detail. The content can be edited by selecting (e.g., double-clicking), each of the nodes of the graph that represent each of the web pages. In such a situation, the model canvas can include a \u201cWhat You See Is What You Get\u201d (WYSIWYG) representation for the content of the web page.","In the example implementation of , all elements created in the model canvas  are catalogued in model tree . Using the model tree , a developer can locate and select the context to be presented in model canvas , by selecting (e.g., double-clicking), a node of the model tree . The model tree  is especially useful when editing complex models comprising several sub-models of several types.","Depending on the type of sub-model selected, the context in the model canvas  will change. Some of the elements' properties are editable within a property editor , allowing the developer to quickly change the element behavior or semantics without having to change the context in the model canvas . The property editor  is especially useful when editing complex elements of a model that otherwise would have to be visually annotated in the model canvas to describe every detailed aspect of the elements behavior. For example, when specifying a web page, a developer may want to define whether the web page requires automatic end-user authentication, if the content is to be transmitted using encryption, and other specifics.","Computer design models have proven to be well matched with human expressive patterns, but typically they have not lent themselves to the process of automated processing. It is useful to store the results of editing a model in a well structured format to enable transmitting, versioning, archiving, validating, and transforming the design model into a computer software system. XML (eXtensible Markup Language) can be used to fill that need, by providing the building blocks for storing a visual representation in an open document. Such a document can be used to exchange the variety of data captured in the models and sub-models across the different components of the processing system in , e.g., the modeling environment , the version repository , and the application generator .","In one embodiment, a model description document  has a root element called a \u201cModel\u201d. The \u201cModel\u201d element contains a set of sub-elements (submodels) that may group the sub-models that define the computer software system. These sub-models include: \u201cEntities,\u201d \u201cStructures,\u201d \u201cScreenFlows,\u201d and Actions\u201d elements. \u201cEntities\u201d elements represent entity-relationship sub-models. \u201cScreenFlows\u201d elements represent user interface navigation sub-models. \u201cActions\u201d elements represent business rule sub-models; \u201cStructures\u201d elements represent data transmission sub-models. As a demonstrative example, the XML below contains some elements that can be found in a model description document .",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201d1.0\u201d?>"},{"entry":"<Model name=\u201dsample\u201d id = \u201cModelA\u201d>"},{"entry":"\u2003<ScreenFlows\/>"},{"entry":"\u2003<Actions\/>"},{"entry":"\u2003<Structures\/>"},{"entry":"\u2003<Entities>"},{"entry":"\u2003\u2003<Entity Id = \u201cEntity1\u201d name = \u201cPerson\u201d primaryKey ="},{"entry":"\u2003\u2003\u201cAttribute1\u201d version=\u201d1\u201d"},{"entry":"\u2003\u2003\u2003\u2003stamp=\u201d20050101100000\u201d>"},{"entry":"\u2003\u2003\u2003<Attribute id = \u201cAttribute1\u201d name = \u201dName\u201d type = \u201cText\u201d \/>"},{"entry":"\u2003\u2003\u2003<Attribute id = \u201cAttribute2\u201d name = \u201cAge\u201d type = \u201cInteger\u201d \/>"},{"entry":"\u2003\u2003\u2003<Attribute id = \u201cAttribute3\u201d name = \u201cLivesIn\u201d type = \u201cEntity2\u201d \/>"},{"entry":"\u2003\u2003<\/Entity>"},{"entry":"\u2003\u2003<Entity Id = \u201cEntity2\u201d name = \u201cCity\u201d primaryKey ="},{"entry":"\u2003\u2003\u201cAttribute4\u201d version=\u201d1\u201d>"},{"entry":"\u2003\u2003\u2003<Attribute id = \u201cAttribute4\u201d name = \u201cName\u201d type = \u201cText\u201d \/>"},{"entry":"\u2003\u2003\u2003<Attribute id = \u201cAttribute5\u201d name = \u201cPopulation\u201d type ="},{"entry":"\u2003\u2003\u2003\u201cInteger\u201d \/>"},{"entry":"\u2003\u2003<\/Entity>"},{"entry":"\u2003<\/Entities>"},{"entry":"<\/Model>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The \u201cEntities\u201d element of a design model contains a set of individual \u201cEntity\u201d elements. A design model can have any number of \u201cEntity\u201d elements, where each \u201cEntity\u201d represents a persistent data repository. Groups of logically associated entities are modeled in an entity-relationship sub-model.","When an application generates a computer software system, it creates a database table that stores the data about the described entity. The table definition is inferred from the \u201cEntity\u201d definition in the model description document. Each \u201cEntity\u201d generates a database table, whose columns are generated from each of the \u201cAttribute\u201d elements within the \u201cEntity\u201d.","An \u201cEntity\u201d element for example, can contain the following XML elements:",{"@attributes":{"id":"p-0109","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Model ...>"},{"entry":"\u2003..."},{"entry":"\u2003<Entities>"},{"entry":"\u2003\u2003<Entity id = \u201c...\u201d name=\u201d\u201d description=\u201d...\u201d primaryKey = \u201c...\u201d"},{"entry":"\u2003\u2003version = \u201c...\u201dstamp=\u201d...\u201d >"},{"entry":"\u2003\u2003\u2003<Attribute id = \u201c...\u201d name = \u201c...\u201d description = \u201c...\u201d type = \u201c...\u201d\/>"},{"entry":"\u2003\u2003\u2003..."},{"entry":"\u2003\u2003<\/Entity>"},{"entry":"\u2003\u2003..."},{"entry":"\u2003<\/Entities>"},{"entry":"<\/Model>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, an \u201cEntity\u201d is defined by a name, which is unique to the \u201cModel\u201d, an id that is virtually unique to the entire \u201cModel\u201d universe; a primary key that identifies a key \u201cAttribute\u201d of the \u201cEntity\u201d that will uniquely identify an \u201cEntity\u201d record within a database; a version identifier that is used to support model version comparison, that is incremented whenever any of the \u201cEntity\u201d or \u201cAttribute\u201d attribute value is modified; and a time stamp representing the moment of modification.","Each \u201cAttribute\u201d is defined by: a name, which is unique to the \u201cEntity\u201d; an id that is virtually unique to the entire \u201cModel\u201d universe; and a data type that defines a constraint to the type of data that can be stored in the database column corresponding to the Attribute. Example data types are number, text and date.","A relationship in a design model that relates one first \u201cEntity\u201d with a second \u201cEntity\u201d is stored as an additional \u201cAttribute\u201d of the first \u201cEntity.\u201d In such case, the relationship is denoted by the type of that \u201cAttribute,\u201d constraining the values that can be stored in the first \u201cEntity,\u201d to the existing values of the primary key column records in the table implementing the second \u201cEntity\u201d. The following XML excerpt illustrates how relationships can be represented:",{"@attributes":{"id":"p-0113","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Model ...>"},{"entry":"\u2003\u2003..."},{"entry":"\u2003\u2003<Entities>"},{"entry":"\u2003\u2003\u2003\u2003<Entity Id = \u201cEntity1\u201d ... >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003..."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<Attribute id = \u201c...\u201d name = \u201c...\u201d type = \u201cEntity2\u201d \/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003..."},{"entry":"\u2003\u2003\u2003\u2003<\/Entity>"},{"entry":"\u2003\u2003\u2003\u2003<Entity Id = \u201cEntity2\u201d ... >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003..."},{"entry":"\u2003\u2003\u2003\u2003<\/Entity>"},{"entry":"\u2003\u2003<\/Entities>"},{"entry":"<\/Model>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Looking at the example in , it can be noticed that the description of depicted sub-model includes two \u201cEntity\u201d elements, the first named \u201cPerson\u201d and the second named \u201cCity.\u201d \u201cPerson\u201d has three \u201cAttribute\u201d elements called \u201cName,\u201d \u201cAge,\u201d and \u201cLivesIn.\u201d \u201cCity\u201d has two \u201cAttribute\u201d elements called \u201cName\u201d and \u201cPopulation.\u201d","The \u201cStructures\u201d element of a design model contains a set of individual \u201cStructure\u201d elements. A design model can have any number of \u201cStructure\u201d elements. Each \u201cStructure\u201d element defines a data structure that can be used to transmit data among elements of a computer design model. Such a data structure can be composed of the definitions of other \u201cStructure\u201d elements, meaning that unlike an \u201cEntity\u201d, a \u201cStructure\u201d can define a hierarchical data structure. An example of the use of a \u201cStructure\u201d is a definition for an order processing system. In such an exemplary computer software system, an order is represented by an identifier, a customer record and a list of items being ordered, given that a customer is further represented by a name and customer identifier and that each item is represented by a product identifier, a quantity and an amount. In such case, a \u201cStructure\u201d can be defined to support the transmission of complete order records among sub-models of a model or even to other computer software systems.","Once the application generator  generates the computer software system, it creates a series of data definitions that can be used to transmit data among web pages and business rules using the most appropriate format. These formats include web page forms, XML data structures or any other adequate definitions of data tokens to be processed by an implementation of a sub-model or by a third-party computer software system.","The Structure element contains, for example, the following XML elements and attributes:",{"@attributes":{"id":"p-0118","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Model ...>"},{"entry":"\u2003..."},{"entry":"\u2003<Structures>"},{"entry":"\u2003\u2003<Structure name=\u201d...\u201d description=\u201d...\u201d id = \u201c...\u201d version = \u201c...\u201d"},{"entry":"\u2003\u2003stamp = \u201c...\u201d>"},{"entry":"\u2003\u2003\u2003<Attribute id = \u201c...\u201d name = \u201c...\u201d description = \u201c...\u201d"},{"entry":"\u2003\u2003\u2003type = \u201c...\u201d id = \u201c...\u201d\/>"},{"entry":"\u2003\u2003\u2003..."},{"entry":"\u2003\u2003<Structure\/>"},{"entry":"\u2003\u2003..."},{"entry":"\u2003<\/Structures>"},{"entry":"<\/Model>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In this example, a \u201cStructure\u201d element is defined by a name, which is unique to the \u201cModel\u201d; and an id that is virtually unique to the entire models universe.","Likewise, each \u201cAttribute\u201d of the \u201cStructure\u201d is defined by a name, which is unique to the \u201cStructure,\u201d an id that is virtually unique to the entire models universe; a data type that defines a constraint to the type of data that can be transmitted according to the \u201cStructure\u201d definition; a version identifier used to support model version comparison that is incremented whenever any of the \u201cStructure\u201d or \u201cAttribute\u201d attribute value is modified; and a time stamp representing the moment of modification.","A \u201cStructure\u201d element can be defined by composition of one or more other \u201cStructure\u201d elements if one or more \u201cAttribute\u201d elements of a first \u201cStructure\u201d are of a type defined as \u201cRecord of Structure\u201d or a type defined as \u201cRecordList of Structure.\u201d Record types define an inclusion of one record of the data defined by the indicated Structure. RecordList types define an inclusion of a sequence of zero or more records of the data defined by the indicated Structure. These constructs can be applied recursively, thus meaning that a \u201cStructure\u201d can define a hierarchical data structure to be transmitted.","The inclusion of a sequence of records of a first \u201cStructure\u201d element within a second \u201cStructure\u201d element is stored as an additional \u201cAttribute\u201d element of the second \u201cStructure\u201d element, whose data type refers to the first \u201cStructure\u201d element. For example:",{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Model ...>"},{"entry":"\u2003..."},{"entry":"\u2003<Structures>"},{"entry":"\u2003\u2003<Structure Id = \u201cStructure1\u201d ...>"},{"entry":"\u2003\u2003\u2003..."},{"entry":"\u2003\u2003<\/Structure>"},{"entry":"\u2003\u2003<Structure Id = \u201cStructure2\u201d ...>"},{"entry":"\u2003\u2003\u2003..."},{"entry":"\u2003\u2003\u2003<Attribute id = \u201c...\u201d name = \u201c...\u201d type = \u201cRecordListStructure1\u201d \/>"},{"entry":"\u2003\u2003\u2003..."},{"entry":"\u2003\u2003<\/ Structure>"},{"entry":"\u2003<\/ Structures>"},{"entry":"<\/Model>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Given again the order processing system example, an order structure could include an Attribute of type \u201cRecordCustomer\u201d and an Attribute of type \u201cRecordListItem.\u201d","The \u201cActions\u201d element of a design model contains a set of individual \u201cAction\u201d elements. A design model can have any number of \u201cAction\u201d elements. Each \u201cAction\u201d element represents a sequence of procedural rules to be applied to data to be presented, stored or transmitted by the computer software system. Each \u201cAction\u201d defines a business rule sub-model.","When the application generator  generates the computer software system, it creates a class method that implements the behavior expressed in the \u201cAction\u201d element design sub-model. An \u201cAction\u201d element, for example, can contain the following XML elements and attributes:",{"@attributes":{"id":"p-0127","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Model ...>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003<Actions>"]},{"entry":[{},"\u2003\u2003<Action name=\u201d...\u201d description=\u201d...\u201d id = \u201c...\u201d version = \u201c...\u201d"]},{"entry":[{},"\u2003\u2003stamp = \u201c...\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<Parameters>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003<InputParameter id = \u201c...\u201d name = \u201c...\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003description = \u201c...\u201d type = \u201c...\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003<OutputParameter id = \u201c...\u201d name = \u201c...\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003description = \u201c...\u201d type = \u201c...\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003<\/Parameters>"]},{"entry":[{},"\u2003\u2003\u2003<Nodes>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003<\/Nodes>"]},{"entry":[{},"\u2003\u2003<\/Action>"]},{"entry":[{},"\u2003<\/Actions>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"<\/Model>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this example, an Action is defined by a name, which is unique to the Model; an id that is virtually unique to the entire Models universe; zero or more \u201cInputParameter\u201d elements and zero or more \u201cOutputParameter\u201d elements. These define a data transmission interface that input the \u201cAction\u201d with the universe of data to be processed during its execution (InputParameter elements) and the definition of the expected data to be transmitted back at the end of the processing (OutputParameter elements); a version identifier that is incremented whenever any of the \u201cAction\u201d, \u201cInputParameter\u201d or \u201cOutputParameter\u201d attribute value is modified; a time stamp representing the moment of modification; and a series of \u201cNode\u201d elements that express the several instructions to be executed within the action and the sequence of their execution.","The \u201cScreenFlows\u201d element of a design model contains a set of individual \u201cScreenFlow\u201d elements. A design model can have any number of \u201cScreenFlow\u201d elements. Each \u201cScreenFlow\u201d contains a set of possibly interrelated \u201cScreen\u201d elements. A \u201cScreenFlow\u201d can have any number of \u201cScreen\u201d elements. Each \u201cScreen\u201d element represents a web page providing content and possible transitions to other web pages.","Once the application generator  generates the computer software system, it creates a dynamic web page (like an Active Server Page or Java Server Page) to be rendered by the application server system. The implementation of the dynamic web page is created given the \u201cScreen\u201d element definition.","The \u201cScreenFlow\u201d and \u201cScreen\u201d elements can contain the following XML elements and attributes:",{"@attributes":{"id":"p-0132","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Model ...>"},{"entry":"\u2003..."},{"entry":"\u2003<ScreenFlows>"},{"entry":"\u2003\u2003<ScreenFlow id = \u201c...\u201d name = \u201c...\u201d description = \u201c...\u201d>"},{"entry":"\u2003\u2003\u2003..."},{"entry":"\u2003\u2003\u2003<Screen id = \u201c...\u201d name = \u201d...\u201d description = \u201d...\u201d version = \u201c...\u201d"},{"entry":"\u2003\u2003\u2003stamp = \u201c...\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<Parameters>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<InputParameter id = \u201c...\u201d name = \u201c...\u201d description = \u201c...\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003type = \u201c...\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003..."},{"entry":"\u2003\u2003\u2003\u2003<\/Parameters>"},{"entry":"\u2003\u2003\u2003\u2003<Content>"},{"entry":"\u2003\u2003\u2003\u2003\u2003..."},{"entry":"\u2003\u2003\u2003\u2003<\/Content>"},{"entry":"\u2003\u2003\u2003\u2003<Links>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<Link destination = \u201c...\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003..."},{"entry":"\u2003\u2003\u2003\u2003<\/Links>"},{"entry":"\u2003\u2003\u2003<\/Screen>"},{"entry":"\u2003<\/ScreenFlows>"},{"entry":"\u2003..."},{"entry":"<\/Model>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In this example, a \u201cScreen\u201d is defined by: a name, which is unique to the model; an id that is virtually unique to the entire models universe; zero or more \u201cInputParameter\u201d element declarations, each of them defining a data transmission interface that indicates to the \u201cScreen\u201d element, the universe of data to be used for presentation during its rendering; a version identifier that is incremented whenever any of the \u201cScreen\u201d or \u201cInputParameter\u201d attribute value is modified; a time stamp representing the moment of modification; a \u201cContent\u201d element that contains all information required by the application generator to create an implementation of an executable program capable of presenting the end-user with a user interface that reassembles the content expressed in the model and supports the user interaction with event triggering controls like buttons and links; and a \u201cLinks\u201d section that includes the definitions of user navigation transitions in the models, referring the destination of the transition.","Referring again to , a developer  using the modeling environment  may decide to save a model description document  using the model version repository . The processing system  allows developers to integrate changes and additions to their models. In some embodiments, the model version repository  of the present invention enables developers  to use the visual modeling environment  to retrieve existing versions of a computer design model; submit new versions of a computer design model; and obtain multiple versions of one design model for visual comparison and merge of elements of both.","The model repository  also can be used by the application generator  to retrieve a computer design model in order to generate an executable program  to be published in the application server system  and to apply changes to the database .","The model repository  can store information about each known design model; each known design model version; and each design model developer and his access rights to each design model.","For each design model, the model version repository  stores a model's global unique identifier; a version tag of the most recent version of the model used by the application generator  to create an executable program ; and a Boolean indicator about whether the design model is active for retrieval by the visual modeling environment and generation by the application generator.","For each design model version, the model version repository  stores the design model to which the version is an implementation of; a version tag as a number that is incremented whenever a new version of the model is submitted to the repository; the submitted model description document ; an identifier of the developer  who submitted the version; the moment when the version was submitted; and an history of other versions of the model from which the current version was modified.","For each developer , the model repository  stores a username and an encrypted password for authentication.","For each access right definition, the model repository  stores a username, a model identifier and a grant to an access right. For each user\/model pair, rights can be granted to allow a developer  to retrieve existing versions of a design model or additionally to submit new versions of the design model.","Referring now to , a demonstrative example of the progression of a design model in the model version repository shows a first version  (tagged as \u201cv1\u201d) that was created and submitted by the developer with username \u201cdev1.\u201d A second version  (tagged as \u201cv2\u201d) was also submitted by dev1 and was developed after retrieval of version with tag \u201cv1.\u201d The third version  (tagged as \u201cv3\u201d) was submitted by \u2018dev2,\u2019 who started the modifications after retrieving version tagged as \u201cv1.\u201d This third version (\u201cv3\u201d) supersedes the modifications submitted by \u201cdev1\u201d to \u201cv1.\u201d A fourth version  (tagged as \u201cv4\u201d) is submitted by \u201cdev1\u201d who started the modifications after retrieval of version tagged as \u201cv3.\u201d","In some embodiments, the modeling environment  facilitates submission of a new version of a design model after modification. The modeling environment  also provides developers  the ability to retrieve an existing version of a design model for modification, also using the modeling environment .","As shown in , the history of the versions of a design model can be tracked within the model repository . In order to allow the modeling environment  to identify conflicts between versions, a version history is also maintained inside the model description  within a \u201cVersions\u201d element. The \u201cVersions\u201d element contains a set of individual \u201cVersion\u201d elements. A design model can have any number of \u201cVersion\u201d elements. Each \u201cVersion\u201d element represents a tagged version of the design model, including a tag number and the date of submission.","The history information can be maintained, for example, using the following structured XML format:",{"@attributes":{"id":"p-0145","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Model ...>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"\u2003\u2003<Versions>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Version tag = \u201c...\u201c date=\u201d...\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003<\/Versions>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"<\/Model>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For example, when retrieving a model such as the example having the depicted progression, the model description document will include four \u201cVersion\u201d elements, each of them representing one of the previously submitted model versions.","The information available within the \u201cVersions\u201d element of the model can be used to detect possible conflicts prior and after the submission of a design model version to the model repository .","Referring to , a computer design model edited using the modeling environment, can be used to generate and deploy a fully functional computer software system, and this process of generating and deploying the computer software system given a model is supported by the sub-system shown. Referring briefly again to , the sub-system use can be triggered upon a developer  request to generate and deploy a model using the modeling environment  or upon application manager  request to generate and deploy a model, for example using the management console .","The process starts by retrieving a model description document  from the model repository  and providing that document  to the application generator . The application generator  is responsible for parsing the XML content of the model description  document into an internal representation. From there on, the application generator  applies a series of built-in generation rules and templates that directly support the translation of the model element definitions into source code of a corresponding executable program . Depending on the sub-models included in the model description document  and translation rules built-in the application generator , the source code is output and organized in several files, each containing the source code of the implementation of the several sub-models within a model.","In one example implementation, which targets the Microsoft .NET.\u2122 application server system, user navigation sub-models are transformed into active server pages, business rule sub-models are transformed into C# classes, and entity-relationship sub-models, are transformed into a database modification script  to be applied to the RDBMS . In the same example implementation, the database modification script contains SQL statements that create the database tables with columns and constraints corresponding to the entity-relationship sub-models.","Right after generating the source code of executable program , a native source code compiler  is used to create the executable binary files  that actually implement the computer software system behavior in a format that can be hosted and managed by an application server system . In the example implementation targeting the Microsoft NET.\u2122 application server system, the native C# classes and active server pages are compiled using a reference implementation of a C# language compiler.","Given a database modification script , the application generator  accesses the RDBMS  to create or modify the application database .","Once the executable binary files  are generated, a deployment service  is used to execute all steps of transferring, installing and configuring for execution the executable binary files  into the application server system . In one example implementation, targeting the Microsoft NET.\u2122 application server system, the deployment service  transmits a compressed file comprising all executable binary files  to the application server system ; decompresses the executable binary files after arrival; creates an application inside the application server system ; copies the executable binary files  to the target folder into the application server system ; and configures the application to be accessed by concurrent client systems .","From there on, the application server system  will handle requests from end-users using a Hyper Text Transfer Protocol (HTTP) client system , like a web browser. When a request is received, the executable program  running in the application server system  processes the request, and generates a response. The response can be in HTML or any other adequate markup language or protocol supported by the client system . A request generates a response that takes the form of a graphical user interface to be displayed in the client system . The returned user interfaces often have embedded controls in them that react to subsequent user generated events, and cause the browser to generate subsequent HTTP requests back to the application server system . Taking advantage of the application server system  architecture, it is possible for a single client system  that the application server system  maintains its state throughout a number of interactions with different requests, generated by different user interfaces. For example, it is possible for an executable program  hosted in an application server system  to generate an initial page as the response to the initial request. This initial page could contain a button. When the user presses the button, the client system generates a new request targeted against the same executable program . The application server system enables the existing executable program  to process the request and generate another user interface page.","In one embodiment, elements in one design model can be used in other design models. Sharing elements of design models enhances the ability of developers to reuse available functionality. The processing system  can facilitate sharing of one or more elements of a computer design model, allowing these elements to be transparently used from other computer design models as if they are part of those other design models. Elements shared by a design model are referred to here as Public elements.","Using the citizen registration example presented earlier, one can imagine a need for the same organization to create a new computer software system that manages information about weddings. The new computer software system would need to handle information about the husband and wife in a wedding and the city where the wedding takes place, sharing the repository for \u201cCity\u201d data management with the one already existing computer software system.","Referring to , two exemplary design models for the two presented problem domains are shown; in which model A  expresses the entities and relationships that describe the problem domain of registering persons as residents of the cities in a country; and model B  expresses the entities and relationships that describe the problem domain of registering weddings in the same country.","Given Model A , the developer of Model B  may decide to reuse the existing \u201cPerson\u201d and \u201cCity\u201d entities from Model A  both to decrease the time required to design Model B , and to ensure the data integrity of several models for different problem domains.","As shown, Model B defines the \u201cWedding\u201d entity, which includes one attribute (Date) that records the date of each wedding, and three relationships with entities of Model A. The \u201chusband\u201d relationship  indicates the person that was the husband for the wedding, the \u201cwife\u201d relationship  indicates which person was the wife for the wedding, and the \u201coccurred at\u201d relationship  indicates the city in which the wedding occurred.","Models that include references to elements of other models (like Model A to Model B in the above example) are referred to as consumer models. Models that include elements that are referenced from other design models (like Model A) are referred to as producer models. One model can be simultaneously a producer and a consumer. These names are used for illustrative purposes, to better identify each model involved from a particular point-of-view.",{"@attributes":{"id":"p-0161","num":"0160"},"figref":"FIG. 9"},"A developer identifies and models the entities and relationships required in Model A (STEP ), for example to achieve the result presented in . The developer identifies (STEP ) the need to use the entities in Model A from Model B design models, and thus sets the relevant model elements as \u201cPublic.\u201d The developer submits (STEP ) the Model A version to the model repository.","For example, the model description resulting from step  could include the following XML:",{"@attributes":{"id":"p-0164","num":"0163"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Model>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"\u2003\u2003<Entities>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Entity name=\u201dPerson\u201d ... public=\u201dtrue\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/Entity>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003<\/Entities>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"<\/Model>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The same or another developer (STEP ) uses the modeling environment to edit Model B. The developer browses (STEP ) with a user interface, public elements of other models and selects the public elements in Model A to be referenced from Model B. The developer models (STEP ) the new \u201cWedding\u201d entity in Model B, referencing entities in Model A, already added as references to Model B during step . The developer includes (STEP ) new functionality in Model A to handle data in any of the three entities according to the expressed relationships and constraints just as if they were part of a single model.","The model description document of the consumer design model resulting from step  would include a new section that includes all referenced elements from other models, for example:",{"@attributes":{"id":"p-0167","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Model id = \u201cModelB\u201d>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003<References>"]},{"entry":[{},"\u2003\u2003<Reference ModelId = \u201cModelA\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<Entities>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Entity Id = \u201cEntity1\u201d name = \u201cPerson\u201d primaryKey ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cAttribute1\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<Attribute id = \u201cAttribute1\u201d name = \u201dName\u201d type ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u201cText\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<Attribute id = \u201cAttribute2\u201d name = \u201cAge\u201d type ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u201cInteger\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<Attribute id = \u201cAttribute3\u201d name = \u201cLivesIn\u201d type ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u201cEntity2\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/Entity>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Entity Id = \u201cEntity2\u201d name = \u201cCity\u201d primaryKey ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cAttribute4\u201d >"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<Attribute id = \u201cAttribute4\u201d name = \u201cName\u201d type ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u201cText\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<Attribute id = \u201cAttribute5\u201d name = \u201cPopulation\u201d type ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u201cInteger\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/Entity>"]},{"entry":[{},"\u2003\u2003\u2003<\/Entities>"]},{"entry":[{},"\u2003\u2003\u2003<Actions> ... <\/Actions>"]},{"entry":[{},"\u2003\u2003\u2003<Structures> ... <\/Structures>"]},{"entry":[{},"\u2003\u2003<\/Reference>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"\u2003<\/References>"]},{"entry":[{},"<\/Model>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The \u201cReferences\u201d element of a design model contains a set of individual \u201cReference\u201d elements. A design model can have any number of \u201cReference\u201d elements. Each reference indicates in a consumer model the public elements of a producer model that can be used in the consumer model. From within a consumer model, any number of public elements of a producer model can be referenced, as long as the developer editing the consumer model is granted access to the producer model.","Given that the definition of an element of a producer model cannot be edited from the consumer model, the \u201cReferences\u201d section of a consumer model will only include a subset of the definitions of the element, the element's interface, which includes the subset of the definitions of an element that is required to use an element from a consumer model.","The design model elements that can be declared as public are: Actions, Entities and Structures.","\u201cEntity\u201d element interfaces, as present in the \u201cReference\u201d sections of a consumer model, can include the information below:",{"@attributes":{"id":"p-0171","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Model ...>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003<References >"]},{"entry":[{},"\u2003\u2003<Reference ...>"]},{"entry":[{},"\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003<Entity id = \u201c...\u201d name=\u201d...\u201d description=\u201d...\u201d primaryKey ="]},{"entry":[{},"\u2003\u2003\u2003\u201c...\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Attribute id = \u201c...\u201d name = \u201c...\u201d description = \u201c...\u201d type ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201c...\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003<Entity\/>"]},{"entry":[{},"\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003<\/Reference>"]},{"entry":[{},"\u2003<\/References>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"<\/Model>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"\u201cStructure\u201d interfaces, as present in the \u201cReference\u201d sections of a consumer model, can include the information below:",{"@attributes":{"id":"p-0173","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Model ...>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003<References >"]},{"entry":[{},"\u2003\u2003<Reference ...>"]},{"entry":[{},"\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003<Structure name=\u201d...\u201d description=\u201d...\u201d id = \u201c...\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Attribute id = \u201c...\u201d name = \u201c...\u201d description = \u201c...\u201d type ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201c...\u201d id = \u201c...\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003<Structure\/>"]},{"entry":[{},"\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003<\/Reference>"]},{"entry":[{},"\u2003<\/References>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"<\/Model>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"\u201cAction\u201d interfaces, as present in the \u201cReference\u201d sections of a consumer model, can include the information below:",{"@attributes":{"id":"p-0175","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Model ...>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003<References >"]},{"entry":[{},"\u2003\u2003<Reference ...>"]},{"entry":[{},"\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003<Action name=\u201d\u201d description=\u201d\u201d id = \u201c\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Parameters>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<InputParameter id = \u201c...\u201d name = \u201c...\u201d description ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u201c...\u201d type = \u201c...\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<OutputParameter id = \u201c...\u201d name = \u201c...\u201d description ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u201c...\u201d type = \u201c...\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/Parameters>"]},{"entry":[{},"\u2003\u2003\u2003<\/Action>"]},{"entry":[{},"\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003<\/Reference>"]},{"entry":[{},"\u2003<\/References>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"<\/Model>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In some implementations, the Nodes section need not be included in the interface, since the information about the actual behavior of the action is not required by a consumer model in order to use the node. The consumer needs only, its identification, inputs and outputs.","Referring again to , having completed step , the developer executes step  to trigger the execution of the application generator to obtain an executable program to be hosted in the application server system and a database that implement the computer software system represented within Model A. Similarly, having completed step , a developer may execute step  to trigger the execution of the application generator to obtain an executable program. In the case of computer software system derived from Model B, it will actually implement the behavior and semantics of all elements of Model B, as well as the implementation of the referenced elements of Model A from Model B.","Referring to , the operations performed by the processing system  when adding, removing or updating the references of a consumer model can begin with a developer deciding (STEP ) to add or remove references from a consumer design model opened with the modeling environment. The modeling environment verifies (STEP ) that the user is connected and logged on to the model version repository, and if that is not the case, (STEP ) the user is prompted with a logon window requiring, for example, his username and password. Once the user is authorized by the model repository (STEP ), the modeling environment retrieves (STEP ) public element information about producer design models from the model version repository. This information can include the list of design models the user is allowed access to, the list of public elements for each of the listed design models, and the public elements interface specification in the same XML format used within the model description document \u201cReferences\u201d section. In addition, the modeling environment loads into memory the list of design model elements that are referenced from the current design model as expressed in the model description. This is the information for the version that is being edited by the developer. This information is used to mark which elements of the producer design models are referenced from the consumer design model.","The modeling environment performs a series of conflict checks (STEP ) to modified elements in the information retrieved from the model repository, performing a comparison between the definition of the elements interface that is retrieved from the model version repository and the definition of the elements interface that is available within the model description of the consumer model. The comparison of reference definitions sequence includes detecting if one producer design model is listed only in the consumer design model description; detecting if one element in a producer design model is listed only in the consumer design model description; and a textual comparison of the XML attributes of the reference present within the consumer model description document and the corresponding definition retrieved from the model version repository in step . In addition, the results of the comparison are compiled to identify references to elements of a design model that are not present in the model repository, or to elements of a design model that doesn't contain such public elements in its most recent version, or to elements of a design model that were deleted or that are not public anymore, referred to as \u201cMissing\u201d references; and references to elements of a design model which interface definition is different in the most recent version.","The developer is provided with the results from the comparisons in STEPS  and . Displayed are: the list of design models the user is granted access to; the list of public elements for each of the listed design models; visual marks denoting which of the listed public elements are already referenced from the design model; visual marks denoting which of the listed design models are \u201cMissing\u201d; and visual marks denoting which of the listed elements of the design models are \u201cMissing\u201d; and visual marks denoting which of the listed elements of the design models are \u201cModified.\u201d","This automated detection of conflicts is beneficial for distributed teams of developers who are collaborating by means of sharing model elements among them, particularly whenever the producer design models are prone to changes.","Referring to , in one exemplary implementation of the visual modeling environment, a user interface prompts and enables developers to check, add and remove references from a computer design model, such as with the flow chart in .","Using the example implementation in , the list of design models that the user has access to is presented in the left pane . In the example screenshot, the developer is granted access to two design models, named \u201cCalendar\u201d and \u201cCustomer,\u201d respectively. The list of public elements of the selected design model  (\u201cCustomer\u201d) is listed in the right pane . In the example screenshot, there are three public elements: the \u201cCreate_RentalCo_Customer\u201d Action, the \u201cCustomer\u201d Entity and the \u201cCustomer_Report\u201d Structure. Each of the public elements is labeled with a visual mark, in this case a check mark , identifying which of them are referenced from the design model being edited. In the example screenshot, there are two references to the \u201cCustomer\u201d design model: one to the \u201cCreate_RentalCo_Customer\u201d Action and other to the \u201cCustomer\u201d Entity. The \u201cCustomer_Report\u201d public Structure is not referenced.","Referring also again to , during STEP  for example, the developer interactively selects pubic elements from the listed design models to be referenced or unselects them to be unreferenced. One implementation having the form of the example user interface presented in  allows the developer to click the visual mark  to alter the selection of the elements individually. Additionally, for those elements that are \u201cMissing\u201d or \u201cModified\u201d, the developer will interactively decide whether to update the interfaces of the references in the consumer design model according to the definition retrieved from the model repository or to keep the existing interface definition.","After choosing elements to be referenced (STEP ), the developer may accept the selections to proceed editing the design model using the selected set of references. The visual modeling environment will update the \u201cReferences\u201d section of the model description of the consumer model (STEP ). The update of References section can, for example, find all design model elements selected (e.g., in step ), and for each of them, add the corresponding \u201cEntity\u201d, \u201cAction\u201d or \u201cStructure\u201d section to the \u201cReferences\u201d section of the corresponding design model. If the \u201cReferences\u201d section does not include a \u201cReference\u201d for the corresponding design model yet, a new \u201cReference\u201d section can be added. All design model elements unselected in step  can be identified, and for each of them, the corresponding \u201cEntity\u201d, \u201cAction\u201d or \u201cStructure\u201d section to the \u201cReference\u201d section of the corresponding design model removed. Further, the system can identify \u201cMissing\u201d design models detected in step  and updated in step , and remove the corresponding \u201cReference\u201d section; find \u201cMissing\u201d elements of design models detected in step  and updated in step ; remove the corresponding \u201cEntity\u201d, \u201cAction\u201d or \u201cStructure\u201d sections. The system also can find \u201cModified\u201d elements of the design models detected in step  and updated in step .","As described, the use of computer design models to define large scale computer software systems is significantly enhanced using references among computer design models. Further enhancement is achieved automating the process of generation and deployment of executable programs from interrelated computer design models. Referring to , the flow of generation of the executable programs is shown for, two exemplary interrelated design models, Model A  and Model B , where Model B includes references elements in Model A. Model A is provided to the Application Generator and two sets of source files are generated: the source code files for the private elements of Model A ; and the source code files for the public elements of Model A .","Both sets of source files ( and ) are provided to the source code compiler to generate two new sets of binary executable files: the binary executables for the private elements of Model A , and the binary executables for the public elements of Model A . Considering that Model A doesn't include references to other design models, the deployment of Model A would involve the direct deployment of the outputs  and  of the source code compiler. Model B differs from Model A in the sense that it includes \u201cReference\u201d elements. In such case, Model B is provided to the application generator and two sets of source files are generated; namely, the source code files for the interfaces that reference Model A , and the source code files for the private elements of Model B.","The source code files for the interfaces of Model A  are implemented with a proxy that accesses the functionality provided by the actual implementation of Model B. Again, the source code compiler is applied to the sources output from the application generator. Then, the deployment service deploys the executable program for Model B. Deployment of Model B involves not only the output from the source code compiler  and , but also the actual implementation of the public elements of Model A . Thus, the resulting executable program for Model A includes the binaries  and , and the resulting executable program for Model B includes the binaries ,  and .","Given the high productivity rates that developers  desire to attain, the time to implement and maintain computer design models can be reduced if the complexity induced by version and dependency management complexity can be removed or at least reduced.","Referring again to , in some embodiments, the processing system  automates and assists a developer to detect and apply design model modifications made by other developers to a design model or to other dependent design models. The modeling environment presents relevant information and tools to support this effort, for example when opening a design model, merging two versions of a design model, retrieving a design model from the model repository, and submitting a design model to the model repository.","Assisted modification of design models is beneficial when opening a design model that is not retrieved from the model repository. Often, developers disconnected from the model repository store the result of their work on a local hard disk drive. Another scenario is having distributed developers working in different instances of the computer design model processing system, exchanging design model description documents among themselves.","In order to assist developers in such cases, the system can notify a developer if the model description document being opened is not up-to-date according to the model versions stored in the model repository, and allow the developer to select how to proceed with design model. Options include opening the local version of the design model, discarding the local version of the design model, retrieving the most recent version from the model version repository; or calculating differences and merging the local version of the design model with the most recent version of the design model stored in the model version repository.","Referring to , the system can facilitate management of model versioning by taking steps, for example, upon opening a model description document using the visual modeling environment.","A developer selects (STEP ) a design model description to be opened, possibly by browsing a file system. The modeling environment verifies (STEP ) if the developer is already connected and logged on to the model version repository. If that is not the case, the developer is authenticated (e.g., prompted with a logon window requiring his username and password). Once the user is authorized by the model repository the modeling environment can either open a local version or the modeling environment retrieves a list of versions of the design model from the model repository for comparison with the information available within the model description being opened. The list of versions retrieved from the model repository is compared with the list of versions present in the \u201cVersions\u201d section of the model description (STEP ). If at least one of the versions retrieved from the model repository is more recent than the most recent version present in the \u201cVersions\u201d section of the model description, it means that there are more recent versions of the model than the one that the developer is trying to open. In such case, the visual modeling environment will proceed to step , otherwise the local copy of the design model document is used (STEP ).","If there is a more recent version in the model version repository, the developer is prompted with three options available for decision: (1) opening the design model document selected in step , and proceeding with the older version (STEP ); (2) retrieving the most recent version of the design model stored in the model version repository, and updating references as explained below with reference to ; (3) comparing and merging the design model document selected in step  with the most recent version of the design model stored in the model version repository, as described below with reference to .","In step , the visual modeling environment parses the complete design model description and creates an in-memory representation suitable for visual editing of the models.","Often, multiple developers editing the same design model diverge in the modifications they perform in parallel. At the end, unlike with what happens with source code, design models cannot be easily compared and merged by using simple textual comparisons.","There is a benefit, then, to assisting a developer editing a model whenever there are other model versions that she wants to merge with her current version.","Referring to , a developer can merge two different model versions, by first deciding to merge two versions of a design model (STEP ). In this example, the two versions are the currently open computer design model and a selected second model description for example, one that the system identified in STEP  above. The first and the second versions of the design model are parsed (STEP ), loading into memory a list of elements in each model version, each of them tagged with the version number expressed in the \u201cVersion\u201d attribute of the element, as available in the model description. The content of the \u201cVersions\u201d element in the model description documents of each of the versions is also parsed and loaded into a in-memory representation. A sequence of sub-steps is then executed to calculate the differences between the first and the second versions. The first and the second lists are compared to determine the most recent version record that is present in both lists, referred to as a baseline. The first and the second lists of elements are compared to detect which of them exist only in the first, and if the stamp of the element in the first list is ulterior to the baseline, add the element to a list of \u201cNew\u201d local elements. If the stamp of the element in the first list is prior or equal to the baseline, add the element to a list of \u201cDeleted\u201d local elements. The first and the second lists of elements are compared to detect which of them exist only in the second, and if the stamp of the element in the second list is ulterior to the baseline, add the element to a list of \u201cNew\u201d foreign elements. If the stamp of the element in the second list is prior or equal to the baseline, add the element to a list of \u201cDeleted\u201d foreign elements. The first and the second lists of elements are compared to detect which of them exist in both but are marked with different version numbers. If the stamp of the element in the first list is ulterior to the baseline and the stamp of the second is prior or equal to the baseline, add the first element to a list of \u201cChanged\u201d local elements. If the stamp of the element in the second list is ulterior to the baseline and the stamp of the first is prior or equal to the baseline, add the second element to a list of \u201cChanged\u201d foreign elements; Given the lists resulting these comparisons, the modeling environment will prompt the developer with visual representation of the two lists of elements, each presenting visual marks about \u201cNew\u201d, \u201cChanged\u201d and \u201cDeleted\u201d elements (STEP ).","In one example implementation of the modeling environment, the user interface that prompts and enables developers to compare and merge elements of two design model versions is presented in . Using such interface, a developer comparing two versions of design model will be presented with the elements of the first in the left pane  and the elements of the second in the right pane . In the example screenshot, the design model being compared includes two \u201cScreenFlow\u201d elements with several \u201cScreen\u201d elements each and four \u201cAction\u201d elements.","Following again the steps in  with the example of  to better understand the use of the described user interface, given the output from step , the lists include visual marks about the differences detected. The example screenshot in has, an example of a visual mark  for a \u201cChanged\u201d element and an example of a visual mark  for a \u201cDeleted\u201d element.","When prompted with the differences of the two model version, the developer proceeds interactively with step  to decide which version of each element is going to be included in the final resulting merged version. In this example, a default selection includes the element versions from the first version. If the developer decides to choose an element version from the second version, the selection is performed pressing the button  available upon selection of each of elements in the right pane .","In step , the developer reviews and confirms the selection of elements to be present in the resulting merged model version. In this example, additional visual marks are presented to help the developer performing step  within the same user interface.","In step , a new version of the design model is produced according to the following sub-steps:\n\n","Following the execution of step , the developer can proceed editing the resulting merged version using the visual modeling environment.","Often, when a design model is referenced by others, the responsibility to accept and apply modifications to the dependable models is a distributed responsibility among the developers that maintain each of them. In such case, the assisted verification of modifications of the dependable design models is supported by a method of the present invention that assists a developer to interactively retrieve a design model version from the model version repository, obtaining immediate information about the modifications to the models it references.","The method for assisting the developer retrieving a model version from the model version repository is depicted by the flow chart in , including the following steps:","In step , the developer selects the retrieve option in the modeling environment.","In step , the modeling environment verifies if the developer is already connected and logged on to the model repository.","If the developer is not connected, proceed with step , prompting a logon window requiring the developer username and password and step  verifying the logon operation.","If the developer is connected and is authorized by the model repository in step  or step , proceed to step .","In step , the modeling environment retrieves a list of available models in the model version repository to which the developer is granted access to.","In step , prompt the list of models to the developer, further including an option to browse all versions of a specific model.","In step , if the developer selects a model directly, the modeling environment proceeds to step , otherwise proceeds to step .","In step , the modeling environment retrieves a list of versions of the selected design model.","In step , the list of versions of a model retrieved in step.","In step , the modeling environment retrieves the model description for the selected version of the selected design model. If stepping from step  to step , the most recent version is retrieved.","In step , for each of the referenced design models from the retrieved design model, the modeling environment retrieves the interface specification of the public elements.","In step , the same the same sub-steps of step  in  are executed for detecting conflicts between the expected interfaces specification and most recent interface specification.","In step , the modeling environment verifies if any missing or modified references are found. In such case, prompts the user with the list of missing and modified elements and executes the same sub-steps of flow chart in , thus allowing the developer to immediately review and eventually accept the modifications performed in the referenced models minimizing the probability of having different specifications of interfaces being used for one element definition.","Referring to , mentioned, another method of the present invention assists a developer to interactively submit a design model version to the model repository, obtaining immediate information about the models affected by the modifications executed. This method is demonstrated by the flow chart shown in step , the developer selects the submit option in the modeling environment.","In step , the modeling environment verifies if the developer is already connected and logged on to the model repository.","If the developer is not connected, proceed with step  and a logon window is prompted requiring his username and password.","In case the user is already connected authorized by the model repository in step  or , the modeling environment will proceed to step .","In step , the modeling environment uploads the model description to the model repository.","In step , the model repository retrieves the \u201cVersions\u201d section from the model description.","In step , determine whether the most recent version in the repository is included in the \u201cVersions\u201d section, meaning that the version being submitted is based on the most recent version already submitted.","In the case that the most recent version is included in the \u201cVersions\u201d section, proceed with step , immediately adding the new version to the model repository.","In the case that the most recent version is not included in the \u201cVersions\u201d section, proceed with step , prompting the developer with two options: a) proceed submitting the model version even considering that a possibly conflicting version was already submitted; or b) merge the model version being submitted with the most recent version of the model existing in the model version repository.","Upon user selection of option b) in step , the modeling environment interrupts the flow execution and triggers, for example, the execution of flow chart in  to merge the version being submitted with the most recent version available in the repository.","In steps  and  respectively, a new version record is created in the model repository and the model description is stored.","Although the present invention has been described with reference to specific exemplary embodiments, it will be evident that various modifications and changes can be made to these embodiments without departing from the broader spirit of the invention as set forth in the claims.","Accordingly, the reader will see that the system of the present invention can be used to process computer design models with any degree of complexity, given that they can be expressed in a structured and hierarchical format. Examples of sub-models that may extend the presented computer design models include: class sub-models, object sub-models, component sub-models, deployment sub-models, use case sub-models, state chart sub-models, collaboration sub-models, storyboard sub-models or any other that describe the behavior of computer software systems.","Additionally, it will also be evident that other types of design models that can be similarly be processed using such methods if they can be expressed in a structured and hierarchical format. For example, electronic design models could be automatically processed to produce compound electronic circuits. Using the methods of the present invention, the modification of those models could be significantly improved.","Thus, the scope of the invention should be determined by the appended claims and their legal equivalents, rather than by the examples given."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present invention are illustrated by way of example, and not limitation, in the following figures. The drawings are not necessarily to scale, emphasis instead generally being placed upon illustrating the principles of the invention.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
