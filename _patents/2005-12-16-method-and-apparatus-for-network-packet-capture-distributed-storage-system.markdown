---
title: Method and apparatus for network packet capture distributed storage system
abstract: This is invention comprises a method an apparatus for Infinite Network Packet Capture System (INPCS). The INPCS is a high performance data capture recorder capable of capturing and archiving all network traffic present on a single network or multiple networks. This device can be attached to Ethernet networks via copper or SX fiber via either a SPAN port () router configuration or via an optical splitter (). By this method, multiple sources or network traffic including gigabit Ethernet switches () may provide parallelized data feeds to the capture appliance (), effectively increasing collective data capture capacity. Multiple captured streams are merged into a consolidated time indexed capture stream to support asymmetrically routed network traffic as well as other merged streams for external consumption.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07855974&OS=07855974&RS=07855974
owner: Solera Networks, Inc.
number: 07855974
owner_city: South Jordan
owner_country: US
publication_date: 20051216
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation of U.S. Provisional Patent Application Ser. No. 60\/638,707, filed Dec. 23, 2004, which is incorporated herein by reference.","The present invention relates to capturing and archiving computer network traffic. Networks allowing computer users to communicate and share information with one another are ubiquitous in business, government, educational institutions, and homes. Computers communicate with one another through small and large local area networks (LANs) that may be wireless or based on hard-wired technology such as Ethernet or fiber optics. Most local networks have the ability to communicate with other networks through wide area networks (WANs). The interconnectivity of these various networks ultimately enables the sharing of information throughout the world via the Internet. In addition to traditional computers, other information sharing devices may interact with these networks, including cellular telephones, personal digital assistants (PDAs) and other devices whose functionality may be enhanced by communication with other persons, devices, or systems.","The constant increase in the volume of information exchanged through networks has made network management both more important and more difficult. Enforcement of security, audit, policy compliance, network performance and use analysis policies, as well as data forensics investigations and general management of a network may require access to prior network traffic. Traditional storage systems, generally based on magnetic hard disk drive technology, have not been able to keep pace with expanding network traffic loads due to speed and storage capacity limitations. Use of arrays of multiple hard disks, increases speed and capacity but even the largest arrays based on traditional operating system and network protocol technologies lack the ability to monolithically capture and archive all traffic over a large network. Capture and archive systems based on current technologies also become part of the network in which they function, rendering them vulnerable to covert attacks or \u201chacking\u201d and thus limiting their security and usefulness as forensic and analytical tools.","To overcome these limitations, a robust network packet capture and archiving system must utilize the maximum capabilities of the latest hardware technologies and must also avoid the bottlenecks inherent in current technologies. Using multiple gigabit Ethernet connections, arrays of large hard disk drives, and software that by-passes traditional bottlenecks by more direct communication with the various devices, it is possible to achieve packet capture and archiving on a scale capable of handling the traffic of the largest networks.","The present invention describes an Infinite Network Packet Capture System (INPCS). The INPCS is a high performance data capture recorder capable of capturing and archiving all network traffic present on a single network or multiple networks. The captured data is archived onto a scalable, infinite, disk based LRU (least recently used) caching system at multiple gigabit (Gb) line speeds. The INPCS has the ability to capture and stream to disk all network traffic on a gigabit Ethernet network and allows this stored data to be presented as a Virtual File System (VFS) to end users. The file system facilitates security, forensics, compliance, analytics and network management applications. The INPCS also supports this capability via T1\/T3 and other network topologies that utilize packet based encapsulation methods.","The INPCS does not require the configuration of a protocol stack, such as TCIP\/IP, on the network capture device. As a result, the INPCS remains \u201cinvisible\u201d or passive and thus not detectable or addressable from network devices being captured. Being undetectable and unaddressable, INPCS enhances security and forensic reliability as it cannot be modified or \u201chacked\u201d from external network devices or directly targeted for attack from other devices on the network.","INPCS also provides a suite of tools and exposes the captured data in time sequenced playback, as a virtual network interface or virtual Ethernet device, a regenerated packet stream to external network segments and as a VFS file system that dynamically generates industry standard LIBPCAP (TCPDUMP) file formats. These formats allow the capture data to be imported into any currently available or custom applications that that support LIBPCAP formats. Analysis of captured data can be performed on a live network via INPCS while the device is actively capturing and archiving data.","In its basic hardware configuration, the INPCS platform is rack mountable device capable of supporting large arrays of RAID 0\/RAID 5 disk storage with high performance Input\/Output (I\/O) system architectures. Storage of high-density network traffic is achieved by using copy-less Direct Memory Access (DMA). The INPCS device can sustain capture and storage rates of over 350 MB\/s (megabytes per second). The device can be attached to Ethernet networks via, copper or fiber via either a SPAN port router configuration or via an optical splitter. The INPCS also supports the ability to merge multiple captured streams of data into a consolidated time indexed capture stream to support asymmetrically routed network traffic as well as other merged streams for external access, facilitating efficient network management, analysis, and forensic uses.","The INPCS software may be independently used as a standalone software package compatible with existing Linux network interface drivers. This offering of the INPCS technology provides a lower performance metric than that available in the integrated hardware\/software appliance but has the advantage of being portable across the large base of existing Linux supported network drivers. The standalone software package for INPCS provides all the same features and application support as available with the appliance offering above described, but does not provide the high performance disk I\/O and copy-less Direct Memory Access (DMA) switch technology of the integrated appliance.","Captured network traffic can be exposed to external appliances and devices or appropriate applications running on the INPCS appliance utilizing three primary methods: a VFS file system exposing PCAP formatted files, a virtual network interface (Ethernet) device and through a regenerated stream of packets to external network segments feeding external appliances. The INPCS file system acts as an on-disk LRU (least recently used) cache and recycles the oldest captured data when the store fills and allows continuous capture to occur with the oldest data either being recycled and overwritten or transferred to external storage captured network traffic. This architecture allows for an infinite capture system. Captured packets at any given time in the on-disk store represents a view in time of all packets captured from the oldest packets to the newest. By increasing the capacity of the disk array, a system may be configured to allow a predetermined time window on all network traffic from a network of a predetermined traffic capacity. For example a business, government entity, or university can configure an appliance with sufficient disk array storage to allow examination and analysis of all traffic during the prior 24 hours, 48 hours, or any other predetermined time frame.","The INPCS is a high performance data capture recorder capable of capturing all network traffic present on a network or on multiple networks and archiving the captured data on a scalable, infinite, disk based LRU (least recently used) caching system, as is known in the art, at multiple gigabit (Gb) line speeds. INPCS has the ability to capture and stream to disk all network traffic on a gigabit Ethernet network and to present the data as a Virtual File System (VFS). End users may access information by retrieving it from the VFS to facilitate network security, forensics, compliance, analytics and network management applications as well as media applications utilizing video or audio formats. INPCS also supports this capability via T1\/T3 and other topologies known in the art that utilize packet based encapsulation methods.","The INPCS does not require the configuration of a protocol stack, such as TCP\/IP, on the capture network device. This makes the INPCS \u201cinvisible\u201d or passive and not addressable from the capture network segment. In this way, the device can't be targeted for attack since it can't be addressed on the network. The INPCS also provides a suite of tools to retrieve the captured data in time sequenced playback, as a virtual network interface or virtual Ethernet device, a regenerated packet stream to external network segments, or as a VFS that dynamically generates LIBPCAP (Packet Capture file format) and TCPDUMP (TCP protocol dump file format), CAP, CAZ, and industry standard formats that can be imported into any appropriate application that supports these formats. LIBPCAP is a system-independent interface for user-level packet capture that provides a portable framework for low-level network monitoring. Applications include network statistics collection, security monitoring, network debugging. The INPCS allows analysis of captured data while the device is actively capturing and archiving data.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 1","b":["101","102","103","104"]},"The merged data stream is archived to an FC-AL SAN (Fiber Channel Arbitrated Loop Storage Area Network) as is known in the art. The FC-AL switch  shown in  offers eight ports with dedicated non-blocking 100 MB\/second or 1 GB\/second point-point parallel connections. These ports direct the captured network traffic to multiple FL-AL RAID Arrays . The depicted arrays each provide a total storage capacity of 7 Terabyte and may be configured using standard RAID configurations as known in the art. The present embodiment provides a controller that supports RAID 0 (striping without redundancy) or RAID 5 (distributed parity), RAID 0+1 (mirrors with stripes), RAID 1 (mirrors) as the preferred storage modes.  depicts a typical appliance chassis (U configuration) designed to hold up to 8 standard 3-inch hard disk drives, and the associated hardware, firmware, and software. In the current embodiment of the invention, each chassis would contain eight 400 GB hard disk drives for a total storage capacity of 3.2 Terabytes per chassis.","The INPCS platform is a UL\/TUV and EC certified platform and is rated as a Class A FCC device. The INPCS unit also meets TUV-1002, 1003, 1004, and 1007 electrostatic discharge immunity requirements and EMI immunity specifications. The INPCS platform allows console administration via SSH (Secure Shell access) as well as by attached atty and tty serial console support through the primary serial port ensuring a secure connection to the device. The unit supports hot swapping of disk drives and dynamic fail over of IDE devices via RAID 5 fault tolerant configuration. The unit also supports a high performance RAID 0 array configuration for supporting dual 1000 Base T (1 Gb) stream to disk capture.","Captured network traffic stored on the SAN can be exposed to external appliances and devices or appropriate applications running on the INPCS appliance utilizing three primary methods: a VFS filesystem exposing PCAP formatted files, a virtual network interface (Ethernet) device and through a regenerated stream of packets to external network segments feeding external appliances. The INPCS file system acts as an on-disk LRU (least recently used) cache and recycles the oldest captured data when the store fills and allows continuous capture to occur with the oldest data either being recycled and overwritten or transferred to external storage for permanent archive of captured network traffic. This architecture allows for an infinite capture system.","In the VFS filesystem, files are dynamically generated by an implemented Linux VFS, known in the art, that resides on top of the disk LRU that INPCS employs to capture network traffic to the disk. Since INPCS presents data via a standard VFS, this allows this data to be easily imported or accessed by applications or to be exported to other computer systems on using network standards such as scp (secure copy), HTTPS (secure Hyper Text Transport Protocol), SMB (Microsoft's Server Message Block protocol) or NFS (the Unix Network File System protocol. This allows the INPCS device to be installed in a wide range of disparate networking environments. Additionally, exposing the captured network traffic through a filesystem facilitates transfer or backup to external devices including data tapes, compact discs (CD), and data DVDs. A filesystem interface for the captured traffic allows for easy integration into a wide range of existing applications that recognize and read such formats.","The INPCS allows the archived data to be accessed as Virtual Network Interface using standard Ethernet protocols. Many security, forensics and network management applications have interfaces that allow them to open a network interface card directly, bypassing the operating system. This allows the application to read packets in their \u201craw\u201d form from the network segment indicated by the opened device. The INPCS virtual internet device may be mapped onto the captured data store such that the stored data appear to the operating system as one or more physical network devices and the time-stamped stored data appears as if it were live network traffic. This allows existing applications to mimic their inherent direct access to network interface devices but with packets fed to the device from the captured packets in the INPCS. This architecture allows for ready integration with applications that are designed to access real-time network data, significantly enhancing their usability by turning them into tools that perform the same functions with historical data.","The Virtual Network Interface also allows analysts to configure the behavior of the INPCS virtual Ethernet device to deliver only specific packets desired. For example, since the INPCS device is a virtual device a user may program its behavior. Tools are provided whereby only packets that meet predetermined requirements match a programmed filter specification (such as by protocol ID or time domain). Additionally, while physical Ethernet devices that are opened by an application are rendered unavailable to other applications, the virtual interface employed by INPCS allows for multiple applications to read from virtual devices (which may be programmed to select for the same or different packet subsets) without mutual exclusion and without any impact on real-time network performance.","While it may be used to examine historical data, the virtual interface capability also enables near real time monitoring of captured data for these applications by providing them with a large network buffer to run concurrently with full data archiving and capture of analyzed data, while providing alerts and live network analysis with no packet loss as typically happens with applications analyzing packets running on congested networks as standalone applications.","The INPCS also facilitates data access through regeneration. Captured packets in the INPCS store can be re-transmitted to external devices on attached network segments. This allows for a \u201cregeneration\u201d of packets contained in the store to be sent to external appliances, emulating the receipt of real-time data by such appliances or applications. The INPCS includes tools to program the behavior of regeneration. For instance, packets can be re-transmitted at defined packet rates or packets that meet particular predetermined criteria can be excluded or included in the regenerated stream.","External appliances receiving packets regenerated to them by the INPCS appliance are unaware of the existence of the INPCS appliance, thus integration with existing or future appliances is seamless and easy, including applications where confidentiality and security are of paramount importance.","This regeneration method also facilitates \u201cload balancing\u201d by retransmitting stored packet streams to external devices that may not be able to examine packets received into the INPCS appliance at the real-time capture rate. Additionally, this method can make external appliances more productive by only seeing packets that a user determines are of interest to current analysis. Regeneration has no impact on the primary functions of the INPCS as it can be accomplished while the INPCS appliance is continuing to capture and store packets from defined interfaces.","The INPCS file system acts as an on-disk LRU (least recently used) cache, as is known in the art and recycles the oldest captured data when the store fills and allows continuous capture to occur with the oldest data either being recycled and overwritten or pushed out onto external storage for permanent archive of capture network traffic. This architecture allows for an infinite capture system. Captured packets at any given time in the on-disk store represents a view in time of all packets captured from the oldest packets to the newest.","The INPCS software is implemented as loadable modules loaded into a modified Linux operating system kernel. This module provides and implements the VFS, virtual network device driver (Ethernet), and the services for regeneration of packets to external network segments, as described above. INPCS uses a proprietary file system and data storage. The Linux drivers utilized by the INPCS modules have also been modified to support a copyless DMA switch technology that eliminates all packet copies. Use of the copyless receive and send methodology is essential to achieving the desired throughput of the INPC. Copyless sends allow an application to populate a message buffer with data before sending, rather than having the send function copy the data.","Captured packets are DMA (direct memory access) transferred directly from the network ring buffers into system storage cache without the need for copying or header dissection typical of traditional network protocol stacks. Similar methods are used for captured packets scheduled for writing to disk storage. These methods enable extremely high levels of performance and allows packet data to be captured and then written to disk at speeds of over 350 MB\/s and allows support for lossless packet capture on gigabit networks. This enables the INPCS unit to capture full line rate gigabit traffic without any packet loss of live network data. This architecture allows real time post analysis of captured data by applications such as the popular Intrusion Detection System (IDS) software Snort, without the loss of critical data (packets). Additionally, should further research be desired, such as for session reconstruction, the full store of data is available to facilitate error free reconstruction.","These methods are superior to the more traditional \u201csniffer\u201d and network trigger model that would require users and network investigators to create elaborate triggers and event monitors to look for specific events on a network. With INPCS, since every network packet is captured from the network, the need for sophisticated trigger and event monitor technology is obsoleted since analysis operations are simply a matter of post analysis of a large body of captured data. Thus, INPCS represents a new model in network troubleshooting and network forensics and analysis since it allows analysts an unparalleled view of live network traffic and flow dynamics. Since the unit captures all network traffic, it is possible to replay any event in time which occurred on a network. The device creates, in essence, a monolithic \u201cnetwork buffer\u201d that contains the entire body of network traffic.","In one embodiment, INPCS exposes the capture data via a VFS file system (DSFS) as PCAP files. The mounted DSFS file system behaves like traditional file systems, where files can be listed, viewed, copied and read. Since it is a file system, it can be exported via the Linux NFS or SMBFS to other attached network computers who can download the captured data as a collection time-indexed slot files or as consolidated capture files of the entire traffic on a network. This allows analysts the ability to simply copy those files of interest to local machines for local analysis. These capture PCAP files can also be written to more permanent storage, like a CD, or copied to another machine.","The INPCS File System (DSFS) also creates and exposes both time-replay based and real-time virtual network interfaces that map onto the capture packet data, allowing these applications to process captured data in real time from the data storage as packets are written into the DSFS cache system. This allows security applications, for instance, to continuously monitor capture data in real time and provide IDS and alert capability from a INPCS device while it continues to capture new network traffic without interruption. This allows existing security, forensics, compliance, analytics and network management applications to run seamlessly on top of the INPCS device with no software changes required to these programs, while providing these applications with a lossless method of analyzing all traffic on a network.","The INPCS unit can be deployed as a standalone appliance connected either via a Switched Port Analyzer (SPAN) or via an optical splitter via either standard LX or SX fiber optic connections. The unit also supports capture of UTP-based Ethernet at 10\/100\/1000 Mb line rates.","The INPCS unit can also be configured to support asymmetrically routed networks via dual SX fiber to gigabit Ethernet adapters with an optical splitter connecting the TX\/RX ports to both RX ports of the INPCS device.","In SPAN configurations the INPCS unit is connected to a router, then the router is configured to mirror selected port traffic into the port connected to the INPCS Unit.  depicts schematically the use of the INPCS appliance in a SPAN configuration. In this configuration, the INPCS appliance is connected to a router port, and the router is configured to mirror (i.e. to copy) packets from other selected ports to the SPAN configured port on the host router. This method does degrade performance of the router to some extent, but is the simplest and most cost effective method of connecting a INPCS appliance to a network for monitoring purposes.","One distinct advantage of using a SPAN configuration relates to multi-router networks that host large numbers of routers in a campus-wide networked environment such as those that exist at universities or large business establishments. Routers can be configured to mirror local traffic onto a specific port and redirect this traffic to a central router bank to collect data on a campus-wide wide basis and direct it to a specific router that hosts an INPCS data recording appliance. This deployment demonstrates that even for a very large network utilizing gigabit Ethernet segments, this method is both deployable, and practical. At a University of 30,000 or more students with workstations and servers using Windows, Unix, Linux, and others operating systems, serving faculty, staff, labs and the like, average network traffic in and out of the university may be expected to continue at a sustained rate of approximately 55 MB\/s with peaks up to 80 MB\/s across multiple gigabit Ethernet segments. A deployment of the INCPS appliance utilizing a SPAN configuration can be effected without noticeable effect on the network and the INCPS can readily capture all network traffic at these rates and thus keep up with capture of all network traffic in and out of the university or similar sized enterprise.","The INPCS appliance can be configured to support capture of network traffic via an in-line optical splitter that diverts RX (receive) and TX (transmit) traffic in a configuration that feeds into two SX gigabit Ethernet adapters within the INPCS appliance.  depicts the use of the INPCS appliance in such an asymmetric routed configuration. In this configuration, the INPCS appliance is connected to an optical splitter that supports either SX (multi-mode) or LX (single mode long haul) fiber optic gigabit cables. This method provides very high levels of performance and is non-intrusive. The non-intrusive nature of this configuration method renders the INPCS appliance totally invisible on the customer network since the unit is completely shielded from view of any outside network devices.","There are further advantages related to support of asymmetric routing. In some large commercial networks RX and TX channels that carry network traffic between routers can be configured to take independent paths through the network fabric as a means of increasing the cross-sectional bandwidth of a network. Networks maintained in large financial markets, for example, may configure their networks in this manner. With this approach, it is required (in both the optical splitter configuration and in configurations involving SPAN port deployment) to re-integrate the captured traffic from one or more capture chains into a consolidated chain so that the network traffic can be reassembled and viewed in a logical arrival order.","The INPCS appliance supports both of these modes and also provides the ability to present the view of the captured network traffic as a merged and consolidated chain of captured packets.  shows the INPCS appliance in an optical splitter configuration. By default, the INPCS supports only SX fiber in the appliance chassis. For users requiring LX fiber support, optical splitters and converters may be added to the configuration to allow LX to SX fiber connections via an external network tap device.","The INPCS provides several utilities that allow configuration of virtual interfaces, starting and stopping data capture on physical adapters, mapping of virtual network interfaces onto captured data in the data store, and monitoring of network interfaces and capture data status. In addition, the entire captured data store is exported via a virtual file system that dynamically generates LIBPCAP files from the captured data as it is captured and allows these file data sets to be viewed and archived for viewing and forensic purposes by any network forensics programs that support the TCPDUMP LIBPCAP file formats for captured network traffic.","The DSCAPTURE utility configures and initiates capture of network data and also allows mapping of virtual network interfaces and selection of specific time domains based on packet index, date and time, or offset within a captured chain of packets from a particular network adapter or network segment.","The utility provides the following functions as they would appear in a command line environment:",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003[root@predator pfs]#"]},{"entry":[{},"\u2003\u2003[root@predator pfs]# dscapture"]},{"entry":[{},"\u2003\u2003USAGE: dscapture start <interface>"]},{"entry":[{},"\u2003\u2003\u2003\u2003dscapture stop <interface>"]},{"entry":[{},"\u2003\u2003\u2003\u2003dscapture init"]},{"entry":[{},"\u2003\u2003\u2003\u2003dscapture map show"]},{"entry":[{},"\u2003\u2003\u2003\u2003dscapture map <virtual interface> <capture interface>"]},{"entry":[{},"\u2003\u2003\u2003\u2003dscapture set time <virtual interface> \u201cMM-DD-YYYY"]},{"entry":[{},"HH:MM:SS\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003dscapture set index <virtual interface> <packet #>"]},{"entry":[{},"\u2003\u2003\u2003\u2003dscapture set offset <virtual interface> <offset>"]},{"entry":[{},"\u2003\u2003[root@predator pfs]#"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The function DSCAPTURE INIT will initialize the INPCS capture store. DSCAPTURE START and DSCAPTURE STOP start and stop packet capture of network traffic, respectively, onto the local store based on network interface name. By default, Linux names interfaces eth0, eth1, eth2, etc. such that control code would resemble the following:",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]# dscapture stop eth1"]},{"entry":[{},"dscapture: INPCS stop interface eth1 (0)"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]# dscapture start eth1"]},{"entry":[{},"dscapture: INPCS start interface eth1 (0)"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The DSCAPTURE MAP and DSCAPTURE MAP SHOW functions allow specific virtual network interfaces to be mapped from physical network adapters onto captured data located in the store. This allows SNORT, TCPDUMP, ARGUS, and other forensic applications known in the art to run on top of the INPCS store in a manner identical to their functionality were running on a live network adapter. This facilitates the use of a large number of existing or custom-designed forensic applications to concurrently analyze captured traffic at near real-time performance levels. The virtual interfaces to the captured data emulating a live network stream will generate a \u201cblocking\u201d event when they encounter the end of a stream of captured data from a physical network adapter and wait until new data arrives. For this reason, these applications can be used in unmodified form on top of the INPCS store while traffic is continuously captured and streamed to these programs in real time with concurrent capture of network traffic to the data store, as shown in the following command line sequence:",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]# dscapture map show"]},{"entry":[{},"\u2003Device\u2003\u2003Type\u2003\u2003Last Replay Date\/Time .microseconds"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"lo"]},{"entry":[{},"sit0"]},{"entry":[{},"eth0"]},{"entry":[{},"eth1"]},{"entry":[{},"ifp0\u2003[ Virtual ]"]},{"entry":[{},"ifp1\u2003[ Virtual ]"]},{"entry":[{},"ifp2\u2003[ Virtual ]"]},{"entry":[{},"ifp3\u2003[ Virtual ]"]},{"entry":[{},"ift0\u2003[ Time Replay ]"]},{"entry":[{},"ift1\u2003[ Time Replay ]"]},{"entry":[{},"ift2\u2003[ Time Replay ]"]},{"entry":[{},"ift3\u2003[ Time Replay ]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003Virtual Interface Mappings"]},{"entry":[{},"\u2003Virtual Physical"]},{"entry":[{},"\u2003ifp0\u2003->\u2003eth1\u2003start time : Tue May 11 09:43:24 2004 .0"]},{"entry":[{},"\u2003ift0\u2003->\u2003eth1\u2003start time : Tue May 11 09:43:24 2004 .0"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The DSCAPTURE function also allows the mapping of specific virtual interfaces to physical interfaces as shown in the following command line sequence and display:",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]# dscapture map ift2 eth1"]},{"entry":[{},"dscapture: virtual interface [ift2] mapped to [eth1]"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The DSCAPTURE MAP SHOW function will now display:",{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator pfs]# dscapture map show"]},{"entry":[{},"\u2003Device\u2003\u2003Type\u2003\u2003Last Replay Date\/Time .microseconds"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"lo"]},{"entry":[{},"sit0"]},{"entry":[{},"eth0"]},{"entry":[{},"eth1"]},{"entry":[{},"ifp0\u2003[ Virtual ]"]},{"entry":[{},"ifp1\u2003[ Virtual ]"]},{"entry":[{},"ifp2\u2003[ Virtual ]"]},{"entry":[{},"ifp3\u2003[ Virtual ]"]},{"entry":[{},"ift0\u2003[ Time Replay ]"]},{"entry":[{},"ift1\u2003[ Time Replay ]"]},{"entry":[{},"ift2\u2003[ Time Replay ]"]},{"entry":[{},"ift3\u2003[ Time Replay ]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003Virtual Interface Mappings"]},{"entry":[{},"\u2003Virtual Physical"]},{"entry":[{},"\u2003\u2003ifp0\u2003->\u2003eth1\u2003start time : Tue May 11 09:43:24 2004 .0"]},{"entry":[{},"\u2003\u2003ift0\u2003->\u2003eth1\u2003start time : Tue May 11 09:43:24 2004 .0"]},{"entry":[{},"\u2003\u2003ift2\u2003->\u2003eth1\u2003start time : Tue May 11 09:43:24 2004 .0"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"There are two distinct types of virtual network interfaces provided by INPCS. ifp<#> and ift<#> named virtual network interfaces. the ifp<#> named virtual interfaces provide the ability to read data from the data store at full rate until the end of the store is reached. The ift<#> named virtual interfaces provide time sequenced playback of captured data at the identical time windows the data was captured from the network. This second class of virtual network interface allows data to be replayed with the same timing and behavior exhibited when the data was captured live from a network source. This is useful for viewing and analyzing network attacks and access attempts as the original timing behavior is fully preserved. The DSCAPTURE function also allows the virtual network interfaces to be indexed into the store at any point in time, packet number, or data offset a network investigator may choose to review, as in the follow command line sequence:",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"dscapture set time <virtual interface> \u201cMM-DD-YYYY HH:MM:SS\u201d"},{"entry":"dscapture set index <virtual interface> <packet #>"},{"entry":"dscapture set offset <virtual interface> <offset>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"These commands allow the user to configure where in the stream the virtual interface should start reading captured packets. In a large system with over two terabytes of captured data, the investigator may only need to examine packets beginning at a certain date and time. This utility allows the user to set the virtual network interface pointer into the capture stream at a specific location. When the virtual device is then opened, it will begin reading packets from these locations rather that from the beginning of the capture stream.","The DSMON utility allows monitoring of a INPCS device from a standard Linux console, afty, or xterm window connected to the device via serial port, SSH (Secure Shell Login), or via a Terminal Window via an xterm device as is known in the art. This program provides comprehensive monitoring of data capture status, captured data in the store, network interface statistics, and virtual interface mappings.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 6"},"Described below are typical excerpts from several DSMON panels detailing some of the information provided by this utility to network administrators and forensic investigators from the INPCS appliance and standalone software package.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 9"},"The INPCS data recorder exposes captured data via a custom Virtual File System (DSFS) that dynamically generates LIBPCAP formatted files from the slots and slot chains in the data store. This data can be accessed via any of the standard file system access methods allowing captured data to be copied, archived and reviewed or imported into any programs or applications that support the LIBPCAP formats. By default, the INPCS system exposes a new file system type under the Linux Virtual File System (VFS) interface as follows:",{"@attributes":{"id":"p-0101","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator predator]# cat \/proc\/filesystems"]},{"entry":[{},"nodev\u2003rootfs"]},{"entry":[{},"nodev\u2003bdev"]},{"entry":[{},"nodev\u2003proc"]},{"entry":[{},"nodev\u2003sockfs"]},{"entry":[{},"nodev\u2003tmpfs"]},{"entry":[{},"nodev\u2003shm"]},{"entry":[{},"nodev\u2003pipefs"]},{"entry":[{},"nodev\u2003binfmt_misc"]},{"entry":[{},"\u2003\u2003ext3"]},{"entry":[{},"\u2003\u2003ext2"]},{"entry":[{},"\u2003\u2003minix"]},{"entry":[{},"\u2003\u2003msdos"]},{"entry":[{},"\u2003\u2003vfat"]},{"entry":[{},"iso9660"]},{"entry":[{},"nodev\u2003nfs"]},{"entry":[{},"nodev\u2003autofs"]},{"entry":[{},"nodev\u2003devpts"]},{"entry":[{},"nodev\u2003usbdevfs"]},{"entry":[{},"\u2003\u2003dsfs"]},{"entry":[{},"[root@predator predator]#"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The DSFS registers as a device based file system and is mounted as a standard file system via the mount command under standard System V Unix systems and systems that emulate the System V Unix command structure. This file system can be exposed to remote users via such protocols as NFS, SAMBA, InterMezzo, and other remote file system access methods provided by standard distributions of the Linux operating system. This allows the DSFS file system to be remotely access from Windows and Unix workstation clients from a central location.","DSFS appears to the operating system and remote users as simply another type of file system supported under the Linux Operating System, as shown in the command line sequence below:",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator predator]# mount"]},{"entry":[{},"\/dev\/hda5 on \/ type ext3 (rw)"]},{"entry":[{},"none on \/proc type proc (rw)"]},{"entry":[{},"usbdevfs on \/proc\/bus\/usb type usbdevfs (rw)"]},{"entry":[{},"\/dev\/hda1 on \/boot type ext3 (rw)"]},{"entry":[{},"none on \/dev\/pts type devpts (rw,gid=5,mode=620)"]},{"entry":[{},"none on \/dev\/shm type tmpfs (rw)"]},{"entry":[{},"\/dev\/hda4 on \/dos type vfat (rw)"]},{"entry":[{},"\/dev\/sda1 on \/pfs type dsfs (rw)"]},{"entry":[{},"[root@predator predator]#"]},{"entry":[{},"[root@predator predator]#"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 10"},"Only the underlying capture engine subsystem can write and alter data in the DSFS file system. Beyond the assignment of user permissions to specific files, DSFS prohibits alteration of the captured data by any user, including the system administrator. This ensures the integrity of the captured data for purposes of chain of custody should the captured data be used in criminal or civil legal proceedings where rules of evidence are mandatory.","By default, the read-write nature of the DSFS file system is read only for users accessing the system from user space, and the Unix \u2018df\u2019 command will always report the store as inaccessible for writing, as shown in the following example of a command line sequence:",{"@attributes":{"id":"p-0108","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator predator]#"]},{"entry":[{},"[root@predator predator]# df -h"]},{"entry":[{},"Filesystem\u2003\u2003\u2003Size\u2003Used Avail Use % Mounted on"]},{"entry":[{},"\/dev\/hda5\u2003\u2003\u2003\u200934G\u20035.5G\u200327G\u200318% \/"]},{"entry":[{},"\/dev\/hda1\u2003\u2003\u2003190M\u200321M\u2003160M\u200312% \/boot"]},{"entry":[{},"none\u2003\u2003\u2003\u20031.5G\u2003\u20020\u20031.5G\u20030% \/dev\/shm"]},{"entry":[{},"\/dev\/hda4\u2003\u2003\u20032.0G 219M\u20031.8G\u200311% \/dos"]},{"entry":[{},"\/dev\/sda1\u2003\u2003\u20031.7T\u20031.7T\u2003\u20020 100% \/pfs"]},{"entry":[{},"[root@predator predator]#"]},{"entry":[{},"[root@predator predator]#"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The DSFS File System is organized into the following directory structure:",{"@attributes":{"id":"p-0110","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator pfs]# ls -l"]},{"entry":[{},"total 890"]},{"entry":[{},"-r--------\u20031 root\u2003root\u20031285179 May 11 12:49 12-eth1"]},{"entry":[{},"-r--------\u20031 root\u2003root\u2003532263 May 11 12:49 12-eth1-slice"]},{"entry":[{},"dr-x------\u20032 root\u2003root\u2003\u2003\u20020 May 11 12:49 merge"]},{"entry":[{},"dr-x------\u20033 root\u2003root\u2003\u200336 May 11 12:49 slice"]},{"entry":[{},"dr-x------\u20033 root\u2003root\u2003\u200336 May 11 12:49 slots"]},{"entry":[{},"dr-x------\u20038 root\u2003root\u2003\u20021536 May 11 12:49 stats"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"By default, DSFS exposes captured slot chains in the root DSFS directory by adapter number and name in the system as a complete chain of packets that are contained in a LIBPCAP file. If the captured adapter contains multiple slots within a chain, the data is presented as a large contiguous file in PCAP format with the individual slots transparently chained together. These files can be opened either locally or remotely and read into any program that is designed to read LIBPCAP formatted data.","These master slot chains are in fact comprised of sub chains of individual slots that are annotated by starting and ending date and time. There are two files created by default for each adapter. One file contains the full payload of network traffic and another file has been frame sliced. Frame slicing only presents the first 96 bytes of each captured packet, and most Network Analysis software is only concerned with the payload of the network headers, and not the associated data within a packet. Providing both files reduces the amount of data transferred remotely over a network during network analysis operations since a frame sliced file is available for those applications that do not need the full network payload.","There are also several subdirectories that present the individual slots that comprise each slot chain represented in the root directory of the DSFS volume. These directories allow a more granular method of reviewing the captured data and are stored by slot and network adapter name along with the start and end capture times for the packets contain in each individual slot. A directory called \u201cslots\u201d is created that presents the full network payload of all packet data and a directory called \u201cslice\u201d that presents the same slot data in frame-sliced format. These slot files are also dynamically generated LIBPCAP files created from the underlying DSFS data store.","A SLOTS directory entry with individual slots for eth1 with full payload would appear as in the following command line sequence:",{"@attributes":{"id":"p-0115","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator slots]#"]},{"entry":[{},"[root@predator slots]# ls -l"]},{"entry":[{},"total 650"]},{"entry":[{},"-r--------\u20031 root\u2003root \u20031293948 May 11 13:00 0-12-eth1-"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u200305112004-094313-05112004-130005"]},{"entry":[{},"-r--------\u20031 root\u2003root \u200335881 May 11 13:02 1-12-eth1-"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u200305112004-130212-05112004-130228"]},{"entry":[{},"[root@predator slots]#"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A SLICE directory entry with individual slots for eth1 with frame sliced payload would appear as follows:",{"@attributes":{"id":"p-0117","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator slice]#"]},{"entry":[{},"[root@predator slice]# ls -l"]},{"entry":[{},"total 285"]},{"entry":[{},"-r--------\u20031 root\u2003root \u2003538671 May 11 13:00 0-12-eth1-"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u200305112004-094313-05112004-130005-slice"]},{"entry":[{},"-r--------\u20031 root\u2003root \u200343321 May 11 13:03 1-12-eth1-"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u200305112004-130212-05112004-130309-slice"]},{"entry":[{},"[root@predator slice]#"]},{"entry":[{},"[root@predator slice]#"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"These files can be imported into TCPDUMP or any other LIBPCAP based application from the DSFS File System, as follows:",{"@attributes":{"id":"p-0119","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator slots]#"]},{"entry":[{},"[root@predator slots]#"]},{"entry":[{},"[root@predator slots]# tcpdump -r 0-12-eth1-05112004-094313-"]},{"entry":[{},"\u2003\u200305112004-130005 | more"]},{"entry":[{},"09:43:29.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:31.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:33.219701 192.168.20.17.netbios-ns >"]},{"entry":[{},"\u2003\u2003192.168.20.255.netbios-ns: NBT UDP PACKET(137):"]},{"entry":[{},"\u2003\u2003QUERY; REQUEST; BROADCAST (DF)"]},{"entry":[{},"09:43:33.219701 arp who-has 192.168.20.17 tell 192.168.20.34"]},{"entry":[{},"09:43:33.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The master slot chain files can also be imported from the root DSFS directory in the same manner and can be copied and archived as simple system files to local or remote target directories for later forensic analysis, as shown in the following command line example:",{"@attributes":{"id":"p-0121","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator pfs]# ls -l"]},{"entry":[{},"total 164"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"-r--------","1 root","root","182994 May 11 13:18 12-eth1"]},{"entry":[{},"-r--------","1 root","root","147295 May 11 13:18 12-eth1-slice"]},{"entry":[{},"dr-x------","\u20022 root","\u2002root","\u2003\u20020 May 11 13:18 merge"]},{"entry":[{},"dr-x------","\u20024 root","\u2002root","\u200372 May 11 13:03 slice"]},{"entry":[{},"dr-x------","\u20024 root","\u2002root","\u200372 May 11 13:02 slots"]},{"entry":[{},"dr-x------","\u20028 root","\u2002root","\u20021536 May 11 13:12 stats"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator pfs]#"]},{"entry":[{},"[root@predator pfs]# tcpdump -r 12-eth1 | more"]},{"entry":[{},"09:43:29.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:31.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:33.219701 192.168.20.17.netbios-ns >"]},{"entry":[{},"\u2003\u2003192.168.20.255.netbios-ns: NBT UDP PACKET(137):"]},{"entry":[{},"\u2003\u2003QUERY; REQUEST; BROADCAST (DF)"]},{"entry":[{},"09:43:33.219701 arp who-has 192.168.20.17 tell 192.168.20.34"]},{"entry":[{},"09:43:33.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:35.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:37.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:37.629701 802.1d cofig 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"It is also possible to copy these files like any other system file for purposes of archiving captured network traffic using the following commands:",{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator slots]#"]},{"entry":[{},"[root@predator slots]# ls -l"]},{"entry":[{},"total 680"]},{"entry":[{},"-r--------\u20031 root\u2003root \u20031293948 May 11 13:00 0-12-eth1-"]},{"entry":[{},"\u2003\u2003\u200305112004-094313-05112004-130005"]},{"entry":[{},"-r--------\u20031 root\u2003root \u200396276 May 11 13:09 1-12-eth1-"]},{"entry":[{},"\u2003\u2003\u200305112004-130212-05112004-130917"]},{"entry":[{},"[root@predator slots]#"]},{"entry":[{},"[root@predator slots]#"]},{"entry":[{},"[root@predator slots]# cp 0-12-eth1-05112004-094313-05112004-"]},{"entry":[{},"\u2003\u2003\u2003130005 \/pcap"]},{"entry":[{},"[root@predator slots]#"]},{"entry":[{},"[root@predator slots]#"]},{"entry":[{},"[root@predator slots]#"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The DSFS \u201cstats\u201d directory contains text files that are dynamically updated with specific statistics information similar to the information reported through the DSMON utility. These files can also be opened and copied; thereby, providing a snapshot of the capture state of the INPCS system for a particular time interval, as shown:",{"@attributes":{"id":"p-0125","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator stats]# ls -l"]},{"entry":[{},"total 23"]},{"entry":[{},"-r--------\u20031 root\u2003root \u200311980 May 11 13:12 diskspace"]},{"entry":[{},"-r--------\u20031 root\u2003root \u20038375 May 11 13:12 diskspace.txt"]},{"entry":[{},"-r--------\u20031 root\u2003root \u20035088 May 11 13:12 network"]},{"entry":[{},"-r--------\u20031 root\u2003root \u20038375 May 11 13:12 network.txt"]},{"entry":[{},"-r--------\u20031 root\u2003root \u20035132 May 11 13:12 slots"]},{"entry":[{},"-r--------\u20031 root\u2003root \u20034456 May 11 13:12 slots.txt"]},{"entry":[{},"[root@predator stats]#"]},{"entry":[{},"[root@predator stats]#"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"For example, the file slot.txt contains the current cache state of all slot buffers in the DSFS system and can be displayed and copied as a simple text file with the following command line sequence:",{"@attributes":{"id":"p-0127","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"[root@predator stats]#"},{"entry":"[root@predator stats]# cat slots.txt"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["slot total",": 16"]},{"entry":["slot readers","\u2002: 0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["capture buffers",": 32784"]},{"entry":["capture buffer size","\u2002: 65536"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["slot io posted",": 0"]},{"entry":["slot io pending","\u2002: 0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["slot_memory_in_use",": 2202235904 bytes"]},{"entry":["slot_memory_allocated","\u2002: 2202235904 bytes"]},{"entry":["slot_memory_freed",": 0 bytes"]},{"entry":["Network Interface",": lo (1)"]},{"entry":["active slot 0\/00000000","packets-0 ringbufs-0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"total_bytes-0 metadata-0"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Network Interface",": sit0 (2)"]},{"entry":["active slot 0\/00000000","packets-0 ringbufs-0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"total_bytes-0 metadata-0"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Network Interface",": eth0 (11)"]},{"entry":["active slot 0\/00000000","packets-0 ringbufs-0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003total_bytes-0Network Interface \u2003: eth1 (12)"},{"entry":"\u2003\u2003active slot 1\/728A0000 packets-1177 ringbufs-512"},{"entry":"\u2003\u2003total_bytes-125125 metadata-65912"},{"entry":"\u2003\u2003Slot Cache Buffer State"},{"entry":"\u2003\u2003slot 0000001\/728A0000 i:12 l:01 (VALID DIRTY UPTD LOCK"},{"entry":"HASHED )"},{"entry":"\u2003\u2003slot 0000000\/7279C000 i:12 l:00 (VALID UPTD HASHED )"},{"entry":"\u2003\u2003slot 0000000\/72798000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72794000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72790000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/7278C000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72788000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72784000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72780000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/7277C000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72778000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72774000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72770000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/7276C000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72768000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003slot 0000000\/72764000 i:00 l:00 (FREE )"},{"entry":"\u2003\u2003Slot Cache Buffer Detail"},{"entry":"\u2003\u2003slot 0000001\/728A0000 i:12 l:01 (VALID DIRTY UPTD LOCK )"},{"entry":"\u2003\u2003\u2003time\/age-40A12340\/40A125BB start-0\/0 last-1693\/0"},{"entry":"\u2003\u2003\u2003packets-1182 ring-512 bytes-126639 meta-66192 io-0"},{"entry":"\u2003\u2003slot 0000000\/7279C000 i:12 l:00 (VALID UPTD )"},{"entry":"\u2003\u2003\u2003time\/age-40A0F49E\/00000000 start-0\/0 last-0\/0"},{"entry":"\u2003\u2003\u2003packets-6011 ring-0 bytes-1197748 meta-336616 io-0"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In addition, an existing \u201cmerge\u201d directory allows files to be dynamically created to provide merged slot chains for support of asymmetric routed traffic and optical tap configurations of captured data.","All of the standard applications that support network interface commands can be deployed with INPCS through the use of virtual network interface.  depicts the use of the INPPCS in conjunction with a number of standard network analysis and forensic tools known in the art. TCPDUMP can be configured to run on top of INPCS by utilizing Virtual Network Interfaces, as in the following command line sequence:",{"@attributes":{"id":"p-0130","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[root@predator \/]#"]},{"entry":[{},"[root@predator \/]# tcpdump -i ifpd | more"]},{"entry":[{},"tcpdump: WARNING: ifp0: no IPv4 address assigned"]},{"entry":[{},"tcpdump: listening on ifp0"]},{"entry":[{},"09:43:29.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:31.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:33.219701 192.168.20.17.netbios-ns >"]},{"entry":[{},"\u2003\u2003192.168.20.255.netbios-ns: NBT UDP PACKET(137):"]},{"entry":[{},"\u2003\u2003QUERY; REQUEST; BROADCAST (DF)"]},{"entry":[{},"09:43:33.219701 arp who-has 192.168.20.17 tell 192.168.20.34"]},{"entry":[{},"09:43:33.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:35.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:37.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":[{},"09:43:39.629701 802.1d config 8000.02:e0:29:0a:fb:33.8000 root"]},{"entry":[{},"\u2003\u20038000.02:e0:29:0a:fb:33 pathcost 0 age 0 max 8 hello 2"]},{"entry":[{},"\u2003\u2003fdelay 5"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The SNORT Intrusion Detection System can be run with no software changes on top of the INPCS data recorder through the same use of the virtual network interfaces provided by the INPCS appliance. Since the Virtual Interfaces block when they reach the end of store data, SNORT can run in the background in real time reading from data captured and stored in a INPCS appliance as it accumulates. The procedure for invoking and initializing SNORT appears as shown in the following command line sequence and display:",{"@attributes":{"id":"p-0132","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"[root@predator snort]#"},{"entry":"[root@predator snort]# snort -i ifp0"},{"entry":"Running in IDS mode with inferred config file: .\/snort.conf"},{"entry":"Log directory = \/var\/log\/snort"},{"entry":"Initializing Network Interface ifp0"},{"entry":"OpenPcap( ) device ifp0 network lookup:"},{"entry":"\u2003\u2003ifp0: no IPv4 address assigned"},{"entry":"\u2003\u2003--== Initializing Snort ==--"},{"entry":"Initializing Output Plugins!"},{"entry":"Decoding Ethernet on interface ifp0"},{"entry":"Initializing Preprocessors!"},{"entry":"Initializing Plug-ins!"},{"entry":"Parsing Rules file .\/snort.conf"},{"entry":"+++++++++++++++++++++++++++++++++++++++++++++++++++"},{"entry":"Initializing rule chains . . ."},{"entry":",-----------[Flow Config]----------------------"},{"entry":"| Stats Interval: 0"},{"entry":"| Hash Method:\u2003\u20032"},{"entry":"| Memcap: \u2003\u2003\u2003\u200210485760"},{"entry":"| Rows : \u2003\u2003\u2003\u20024099"},{"entry":"| Overhead Bytes: 16400(%0.16)"},{"entry":"\u2018----------------------------------------------"},{"entry":"No arguments to frag2 directive, setting defaults to:"},{"entry":"\u2003Fragment timeout: 60 seconds"},{"entry":"\u2003Fragment memory cap: 4194304 bytes"},{"entry":"\u2003Fragment min_ttl: \u20030"},{"entry":"\u2003Fragment ttl_limit: 5"},{"entry":"\u2003Fragment Problems: 0"},{"entry":"\u2003Self preservation threshold: 500"},{"entry":"\u2003Self preservation period: 90"},{"entry":"\u2003Suspend threshold: 1000"},{"entry":"\u2003Suspend period: 30"},{"entry":"Stream4 config:"},{"entry":"\u2003Stateful inspection: ACTIVE"},{"entry":"\u2003Session statistics: INACTIVE"},{"entry":"\u2003Session timeout: 30 seconds"},{"entry":"\u2003Session memory cap: 8388608 bytes"},{"entry":"\u2003State alerts: INACTIVE"},{"entry":"\u2003Evasion alerts: INACTIVE"},{"entry":"\u2003Scan alerts: INACTIVE"},{"entry":"\u2003Log Flushed Streams: INACTIVE"},{"entry":"\u2003MinTTL: 1"},{"entry":"\u2003TTL Limit: 5"},{"entry":"\u2003Async Link: 0"},{"entry":"\u2003State Protection: 0"},{"entry":"\u2003Self preservation threshold: 50"},{"entry":"\u2003Self preservation period: 90"},{"entry":"\u2003Suspend threshold: 200"},{"entry":"\u2003Suspend period: 30"},{"entry":"Stream4_reassemble config:"},{"entry":"\u2003Server reassembly: INACTIVE"},{"entry":"\u2003Client reassembly: ACTIVE"},{"entry":"\u2003Reassembler alerts: ACTIVE"},{"entry":"\u2003Zero out flushed packets: INACTIVE"},{"entry":"\u2003flush_data_diff_size: 500"},{"entry":"\u2003Ports: 21 23 25 53 80 110 111 143 513 1433"},{"entry":"\u2003Emergency Ports: 21 23 25 53 80 110 111 143 513 1433"},{"entry":"HttpInspect Config:"},{"entry":"\u2003GLOBAL CONFIG"},{"entry":"\u2003\u2003Max Pipeline Requests:\u20030"},{"entry":"\u2003\u2003Inspection Type:\u2003\u2003\u2002STATELESS"},{"entry":"\u2003\u2003Detect Proxy Usage:\u2003\u2003NO"},{"entry":"\u2003\u2003IIS Unicode Map Filename: .\/unicode.map"},{"entry":"\u2003\u2003IIS Unicode Map Codepage: 1252"},{"entry":"\u2003DEFAULT SERVER CONFIG:"},{"entry":"\u2003\u2003Ports: 8\u2003Flow Depth: 300"},{"entry":"\u2003\u2003Max Chunk Length: 500000"},{"entry":"\u2003\u2003Inspect Pipeline Requests: YES"},{"entry":"\u2003\u2003URI Discovery Strict Mode: NO"},{"entry":"\u2003\u2003Allow Proxy Usage: NO"},{"entry":"\u2003\u2003Disable Alerting: NO"},{"entry":"\u2003\u2003Oversize Dir Length: 500"},{"entry":"\u2003\u2003Only inspect URI: NO"},{"entry":"\u2003\u2003Ascii: YES alert: NO"},{"entry":"\u2003\u2003Double Decoding: YES alert: YES"},{"entry":"\u2003\u2003%U Encoding: YES alert: YES"},{"entry":"\u2003\u2003Bare Byte: YES alert: YES"},{"entry":"\u2003\u2003Base36: OFF"},{"entry":"\u2003\u2003UTF 8: OFF"},{"entry":"\u2003\u2003IIS Unicode: YES alert: YES"},{"entry":"\u2003\u2003Multiple Slash: YES alert: NO"},{"entry":"\u2003\u2003IIS Backslash: YES alert: NO"},{"entry":"\u2003\u2003Directory: YES alert: NO"},{"entry":"\u2003\u2003Apache WhiteSpace: YES alert: YES"},{"entry":"\u2003\u2003IIS Delimiter: YES alert: YES"},{"entry":"\u2003\u2003IIS Unicode Map: GLOBAL IIS UNICODE MAP CONFIG"},{"entry":"\u2003\u2003Non-RFC Compliant Characters: NONE"},{"entry":"\u2003rpc_decode arguments:"},{"entry":"\u2003\u2003Ports to decode RPC on: 111 32771"},{"entry":"\u20030 8080 8180"},{"entry":"\u2003\u2003alert_fragments: INACTIVE"},{"entry":"\u2003\u2003alert_large_fragments: ACTIVE"},{"entry":"\u2003\u2003alert_incomplete: ACTIVE"},{"entry":"\u2003\u2003alert_multiple_requests: ACTIVE"},{"entry":"\u2003telnet_decode arguments:"},{"entry":"\u2003\u2003Ports to decode telnet on: 21 23 25 119"},{"entry":"\u20031615 Snort rules read. . . "},{"entry":"\u20031615 Option Chains linked into 152 Chain Headers"},{"entry":"\u20030 Dynamic rules"},{"entry":"+++++++++++++++++++++++++++++++++++++++++++++++++++"},{"entry":"-----------------------[thresholding-config]----------------------------------"},{"entry":"| memory-cap : 1048576 bytes"},{"entry":"+-----------------------[thresholding-global]----------------------------------"},{"entry":"| none"},{"entry":"+-----------------------[thresholding-local]-----------------------------------"},{"entry":"| gen-id=1\u2003\u2003sig-id=2275\u2003\u2003type=Threshold tracking=dst count=5"},{"entry":"\u2003\u2003\u2003\u2002seconds=60"},{"entry":"+-----------------------[suppression]------------------------------------------"},{"entry":"-------------------------------------------------------------------------------"},{"entry":"Rule application order: ->activation->dynamic->alert->pass->log"},{"entry":"\u2003\u2003--== Initialization Complete ==--"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0133","num":"0132"},"figref":"FIG. 12"},"The invention also allows rapid traffic regeneration of the captured data and retrieval of captured data via standard file system and network device interfaces into the operating system. This flexible design allows user space applications to access captured data in native file formats and native device support formats without the need for specialized interfaces and APIs (application programming interfaces).","Data is streamed from the capture adapters into volatile (memory) slot cache buffers via direct DMA mapping of the network adapter ring buffer memory and flushed into non-volatile (disk) as the volatile cache fills and overflows. Each slot cache segment is time based and has a start time, end time, size, and chain linkage meta tag and are self annotated and self describing units of storage of network traffic. As the slot cache storage system fills with fully populated slot cache segments, older segments in a slot chain are overwritten or pushed\/pulled into long term archive storage.","The invention uses two primary disk partition types for the storage and archival of captured network traffic. These on-disk layouts facilitate rapid I\/O transactions to the non-volatile (on-disk) storage cache for writing to disk captured network traffic. There are three primary partition types embodied in the invention. Partition type 0x97, 0x98 and partition type 0x99 as are known in the art.","Partition type 0x97 partitions are used by the system to storage active data being captured from a live network medium. Partition type 0x98 partitions are long term storage used to archive captured network traffic into large on-disk library caches that can span up to 128 Tera-bytes of disk storage for each Primary capture partition. Type 0x97 partitions are described by a Disk Space Record header located on each partition.","The Disk Space Record Header describes the block size, partition table layout, and slot storage layout of a type 0x97 partition. The Disk Space Record Header uses the following on-disk structure to define the storage extents of either a type 0x97 or type 0x98 storage partition.",{"@attributes":{"id":"p-0139","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct _DISK_SPACE_RECORD"},{"entry":"{"},{"entry":"\u2003volatile unsigned long version;"},{"entry":"\u2003ULONG id_stamp;"},{"entry":"\u2003volatile unsigned long state;"},{"entry":"\u2003volatile unsigned long io_state;"},{"entry":"\u2003ULONG timestamp;"},{"entry":"\u2003ULONG date;"},{"entry":"\u2003ULONG time;"},{"entry":"\u2003ULONG disk_id;"},{"entry":"\u2003ULONG partition_id;"},{"entry":"\u2003ULONG disk_record_blocks;"},{"entry":"\u2003ULONG member_id;"},{"entry":"\u2003ULONG member_slot;"},{"entry":"\u2003ULONG member_count;"},{"entry":"\u2003ULONG members[MAX_RECORD_MEMBERS];"},{"entry":"#if ADDRESS_64"},{"entry":"\u2003long long member_cluster_map[MAX_RECORD_MEMBERS];"},{"entry":"#else"},{"entry":"\u2003ULONG member_cluster_map[MAX_RECORD_MEMBERS];"},{"entry":"#endif"},{"entry":"\u2003ULONG start_lba[MAX_RECORD_MEMBERS];"},{"entry":"\u2003ULONG sector_count[MAX_RECORD_MEMBERS];"},{"entry":"\u2003ULONG cluster_size;"},{"entry":"\u2003ULONG start_of_logical_data_area;"},{"entry":"#if ADDRESS_64"},{"entry":"\u2003long long size;\u2003\u2003\/\/ in 4K blocks"},{"entry":"\u2003long long total_clusters;"},{"entry":"#else"},{"entry":"\u2003ULONG size;\u2003\u2003\/\/ in 4K blocks"},{"entry":"\u2003ULONG total_clusters;"},{"entry":"#endif"},{"entry":"\u2003ULONG total_slot_records;"},{"entry":"\u2003ULONG start_of_slot_data;"},{"entry":"\u2003ULONG start_of_space_table;"},{"entry":"\u2003ULONG space_table_size;"},{"entry":"\u2003ULONG start_of_name_table;"},{"entry":"\u2003ULONG name_table_size;"},{"entry":"\u2003ULONG start_of_machine_table;"},{"entry":"\u2003ULONG machine_table_size;"},{"entry":"\u2003ULONG disk_space_present;"},{"entry":"#if CONFIG_CLUSTER_STRIPING"},{"entry":"#if ADDRESS_64"},{"entry":"\u2003long long striped_size;\u2003\u2003\/\/ in 4K blocks"},{"entry":"\u2003long long striped_total_clusters;"},{"entry":"#else"},{"entry":"\u2003ULONG striped_size;\u2003\u2003\/\/ in 4K blocks"},{"entry":"\u2003ULONG striped_total_clusters;"},{"entry":"#endif"},{"entry":"\u2003ULONG striped_total_slot_records;"},{"entry":"\u2003ULONG striped_space_present;"},{"entry":"\u2003ULONG striped_detected_member_count;"},{"entry":"#endif"},{"entry":"\u2003ULONG slot_size;"},{"entry":"\u2003ULONG bitmap_full;"},{"entry":"\u2003ULONG recycle_count;"},{"entry":"\u2003ULONG slot_starting_cluster[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003ULONG slot_ending_cluster[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003ULONG slot_starting_time_domain[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003ULONG slot_ending_time_domain[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003ULONG slot_chain_size[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003long long slot_element_count[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003long long slot_element_bytes[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003long long slot_slice_bytes[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003SPACE_TABLE space_entry[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003SPACE_TABLE slice_entry[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003BYTE slot_names[MAX_INTERFACE_SLOTS][IFNAMSIZ];"},{"entry":"\u2003INTERFACE_INFO interface_info[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003\/\/ in memory structures"},{"entry":"#if (!LINUX_UTIL)"},{"entry":"\u2003spinlock_t d_lock;"},{"entry":"\u2003ULONG d_flags;"},{"entry":"#endif"},{"entry":"\u2003struct _DISK_SPACE_RECORD *next;"},{"entry":"\u2003struct _DISK_SPACE_RECORD *prior;"},{"entry":"\u2003SPACE_TABLE_BUFFER *space_table_head;"},{"entry":"\u2003SPACE_TABLE_BUFFER *space_table_tail;"},{"entry":"\u2003NAME_TABLE_BUFFER *name_table_head;"},{"entry":"\u2003NAME_TABLE_BUFFER *name_table_tail;"},{"entry":"\u2003BIT_BLOCK_HEAD allocation_bitmap;"},{"entry":"\u2003BIT_BLOCK_HEAD slot_bitmap;"},{"entry":"\u2003BIT_BLOCK_HEAD chain_bitmap[MAX_INTERFACE_SLOTS];"},{"entry":"\u2003ULONG io_count;"},{"entry":"\u2003ASYNCH_IO io[MAX_BUFFER_SIZE \/ IO_BLOCK_SIZE];"},{"entry":"\u2003ULONG active_slot_records;"},{"entry":"\u2003BYTE *name_hash;"},{"entry":"\u2003ULONG name_hash_limit;"},{"entry":"\u2003volatile unsigned long signature;"},{"entry":"\u2003MACHINE_TABLE_BUFFER *machine_table_head;"},{"entry":"\u2003MACHINE_TABLE_BUFFER *machine_table_tail;"},{"entry":"\u2003ULONG buffer_count;"},{"entry":"} DISK_SPACE_RECORD;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Disk Space Records also allow chaining of Disk Space Records from multiple type 0x97 or type 0x98 partitions based upon creation and membership ID information stored in a membership cluster map, which allows the creation of a single logical view of multiple type 0x97 partitions. This allows the system to concatenate configured type 0x97 partitions into stripe sets and supports data striping across multiple devices, which increases disk channel performance dramatically.","Disk Space Records also define the internal table layouts for meta-data and chaining tables used to manage slot cache buffer chains within a virtual Disk Space Record set. Disk Space records contain table pointers that define the tables used by the DSFS file system to present slot storage as logical files and file chains of slot storage elements.","Disk Space Record based storage divides the storage partition into contiguous regions of disk sectors called slots. Slots can contain from 16 up to 2048 64K blocks of 512 byte sectors, and these storage elements are stored to disk in sequential fashion. Slots are access via a sequential location dependent numbering scheme starting at index 0 up to the number of slots that are backed up by physical storage on a particular disk device partition. Each Disk Space Record contains a space table. The space table is a linear listing of structures that is always NUMBER_OF_SLOTS*sizeof (SPACE_TABLE-ENTRY) in size. The Space table maintains size, linkage, and file attribute information for a particular slot and also stores the logical chaining and ownership of particular slots within a logical slot chain.",{"@attributes":{"id":"p-0143","num":"0142"},"figref":"FIG. 13"},"Virtual Cluster addresses are generated for stripe sets using the following algorithm:",{"@attributes":{"id":"p-0145","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"register int j = (cluster_number % disk_space_record->"]},{"entry":[{},"\u2003\u2003member_count);"]},{"entry":[{},"logical sector address = disk_space_record->start_lba[j] +"]},{"entry":[{},"\u2003\u2003\u2003((cluster_number \/ disk_space_record->member_count) *"]},{"entry":[{},"\u2003\u2003\u2003\u2009(disk_space_record->cluster_size \/ 512));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The module of a cluster number relative to the number of stripe members is performed and used as an index into a particular disk LBA offset table of partition offsets within a disk device partition table that calculates the relative LBA offset of the 64K cluster number. Cluster numbers are divided by the number of striped members to determine and physical cluster address and sector LBA offset into a particular stripe set partition.",{"@attributes":{"id":"p-0147","num":"0146"},"figref":"FIG. 14","b":"0"},{"@attributes":{"id":"p-0148","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"register ULONG spb, lba;"]},{"entry":[{},"spb = (SystemDisk[j]->DeviceBlockSize \/ SystemDisk[j]->"]},{"entry":[{},"\u2003\u2003BytesPerSector);"]},{"entry":[{},"Rounded I\/O Device Blocks = (SystemDisk[j]->"]},{"entry":[{},"\u2003\u2003PartitionTable[i].StartLBA + (spb \u2212 1)) \/ spb;"]},{"entry":[{},"SystemDisk[j]->StartOfPartition[i]= lba * spb; \/\/ adjusted LAB Start"]},{"entry":[{},"\u2003\u2003of Partition"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This optimization allows all I\/O requests to the disk layout to be coalesced into 4K page addresses in the disk I\/O layer. All read and write requests to the disk device are performed through the I\/O layers as a 4K page.  depicts the slot cache buffers stored as contiguous runs of 16-2048 sectors. The sector run size may be configured as a compile-time option. Slots are submitted for I\/O in coalesced requests that transmit a single scatter-gather list of DMA addresses and in sector order resulting in minimal head movement on the physical device and large coalesced I\/O capability.","The Disk Space Record (DSR) will occupy the first cluster of an adjusted Disk Space Record partition. The DSR records the cluster offset into the virtual Disk Space Store of the location of the Space Table, and optionally for partition type 0x98, the Name and Machine Tables as well. There is also a cluster record that indicates where the slot storage area begins on a Virtual Disk Space Store Partition.","The DSR also contains a table of slot chain head and tail pointers. This table is used to create slot chains that map to physical network adapters that are streaming data to the individual slot chains. This table supports a maximum of 32 slot chains per Disk Space Record Store. This means that a primary capture partition type 0x97 can archive up to 32 network adapter streams concurrently per active Capture Partition.","Type 0x98 Archive Storage Partitions employ a Name Table and Machine table that are used to store slots from primary capture partitions for long term storage and archive of network traffic and also record the host machine name and the naming and meta-tagging information from the primary capture partition, depicts the use of a Name Table and Machine Table in a type 0x98 partition. When slots are archived from the primary capture partition to a storage partition, the interface name and machine host name are added to the name table and the host name table on the archive storage partition. This allow multiple primary capture partitions to utilize a pool of archive storage to archive captured network traffic from specific segments into a large storage pool for archival and post capture analysis.","Archive storage can be mapped to multiple Network Capture Appliances as a common pool of slot segments. Archive storage pools can also be subdivided into storage zones with this architecture and tiered as a hierarchical cache and archive network traffic for months, or even years from target segments.","Individual Slot addresses are mapped to the Disk Space Store based upon partition size, number of slots, storage record cluster size, and reserved space based on the following algorithm:",{"@attributes":{"id":"p-0155","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"slot_cluster = (disk space record->start_of_slot_data +"]},{"entry":[{},"\u2003\u2003(slot_number * (disk_space_record->slot_size \/"]},{"entry":[{},"\u2003\u2003\u2009disk_space_record->cluster_size)));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The Start of slot data is the logical cluster address that immediately follows the last cluster of the space table for type 0x97 partitions and the last cluster of the machine table for type 0x98 partitions. Slots are read and written as a contiguous run of sectors to and from the disk storage device starting with the mapped slot cluster address derived from the slot number.","A slot defines a unit of network storage and each slot contains a slot header and a chain of 64K clusters. The on-disk structure of a slot is identical to the cache in-memory structure and both memory and the on-disk slot caches are viewed and treated by DSFS as specialized forms of LRU (last recently used) cache.","The slot header stores meta-data that describes the content and structure of a slot and its corresponding chain of 64 clusters.  depicts the slot storage element layout comprising 64K clusters. The slot header points to the buffers as a character byte stream and also maintains starting index:offset pairs into buffer indexes within a slot.  depicts the slot header and pointer system to the slot buffers containing data. Buffers in a slot are indexed zero relative to the first buffer element contained in a slot buffer segment. A slot can have from 16-2048 buffer elements. Slots also provide a block oriented method for packet traversal that allow network packets to be skipped over based on index:offset pair. This index:offset pair is handled by the file system layers as a virtual index per packet into a slot segment.","The slot buffer header points to the first index:offset and the last index:offset pair within a slot segment buffer, and also contains a bitmap of buffer indexes that are known to contain valid slot data. These indexes are used by the I\/O caching layer for reading sparse slots (slots not fully populated with network packet data) into memory efficiently.","Slot buffer sizes must match the underlying hardware in order for the algorithm to work properly. The high performance of this invention is derived from the technique described for filling of pre-load addresses into a network adapter device ring buffer. Network adapters operate by pre-loading an active ring or table on the adapter with memory addresses of buffer addresses to receive incoming network packets. Since the adapter cannot know in advance how large a received packet may be, the pre-loaded addresses must be assumed to be at least as large as the largest packet size the adapter will support. The algorithm used by DSFS always assumes at least the free space of (PACKET_SIZE+1) must be available for a pre-load buffer since buffers can exceed the maximum packet size due to VLAN (Virtual LAN) headers generated by a network router or switch.","The network adapter allocates buffers from the DSFS slot cache into the adapter based upon the next available index:offset pair. The buffers are maintained as a linear list of index addresses that are cycled through during allocation that allows all ring buffer entries to be pre-loaded from a buffer array (i.e. slot segment) in memory. The number of slot buffers must therefore be (NUMBER_OF_RING_BUFFERS*2) at a minimum in order to guarantee that as buffers elements are received and freed, the adapter will always obtain a new pre-load buffer without blocking on a slot segment that has too many buffers allocated for a given ring buffer.","Since ring buffer ring buffer pre-load\/release behavior is always sequential in a network adapter, this model works very well, and as the buffer chain wraps, the adapter ring buffer will continue to pre-load buffers as free-behind network packets are released to the operating system on receive interrupts.  depicts sequential loading of slot cache elements on an LRU basis from an e1000 Adaptor Ring Buffer. This has the affect of harnessing the DMA engine on the network adapter to move network traffic into the slot buffer segment without copying the network data.","As buffers are allocate from a slot cache element and pre-loaded into the adapter ring buffer memory, the buffer header is pinned in memory for that particular buffer, and subsequent allocation requests will skip this buffer until the pre-loaded element has been received from the adapter.","This is necessary because the size of the received buffer is unknown. It is possible to round robin allocate pre-load buffers to the maximum size (MTU\u2014maximum transmission unit) of a network packet, however, this method wastes space. In the current invention, preloads pin buffer headers until receipt so that subsequent allocation requests to the buffer will use space more efficiently.","Slot buffers are allocated in a round-robin pattern from each buffer element in a slot buffer list, as depicted in . Linkages are maintained between each element into the next buffer that are accessed by means of an index:offset pair as described. These comprise a coordinate address for a buffer location of stored data and allow the lost buffer to preload capture addresses into the ring buffers of a capture device that supports direct DMA access at very high data rates into a slot buffer element cached in memory. Reading the captured data requires that the slot be held in memory and the elements traversed via a set of linkages within each element header that point to the next index:offset address pair for a stored element or network packet.","The allocation algorithm is as follows:",{"@attributes":{"id":"p-0167","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"for (lock_count = 0, search_count = 0,"},{"entry":"\u2003\u2003curr = (slot->current_buffer % slot->d->buffer_count);;)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003buffer = (slot->buffers[slot->current_buffer % slot->d->"},{"entry":"\u2003\u2003\u2003buffer_count]);"},{"entry":"\u2003\u2003if (!buffer)"},{"entry":"\u2003\u2003{"},{"entry":"#if INTERFACE_STATISTICS"},{"entry":"\u2003\u2003\u2003ioctl_stats.i_stats[index].dropped_elements_no_buffers++;"},{"entry":"\u2003\u2003\u2003ioctl_stats.i_stats[index].dropped_elements_current++;"},{"entry":"#endif"},{"entry":"#if VERBOSE"},{"entry":"\u2003\u2003\u2003getcaptrace(0, (void *)8, \u22121, \u22121);"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003spin_unlock_irqrestore(&slot->s_lock, slot->s_flags);"},{"entry":"\u2003\u2003\u2003return (get_collision_buffer( ));"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003if (!buffer->flags)"},{"entry":"\u2003\u2003{"},{"entry":"#if DYNAMIC_MTU"},{"entry":"\u2003\u2003\u2003if ((buffer->buffer_offset + sizeof(ELEMENT_HEADER) +"},{"entry":"\u2003\u2003\u2003\u2003\u2003(ndevs[index]->mtu * 2)) < slot->buffer_size)"},{"entry":"#else"},{"entry":"\u2003\u2003\u2003if ((buffer->buffer_offset + sizeof(ELEMENT_HEADER) +"},{"entry":"\u2003\u2003\u2003\u2003\u2003slot->max_packet_size) < slot->buffer_size)"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003p = (BYTE *)&buffer->buffer[buffer->buffer_offset];"},{"entry":"\u2003\u2003\u2003\u2003element = (ELEMENT_HEADER *) p;"},{"entry":"\u2003\u2003\u2003\u2003element->id_stamp = ELEMENT_SIGNATURE;"},{"entry":"\u2003\u2003\u2003\u2003element->slot = slot;"},{"entry":"\u2003\u2003\u2003\u2003element->sequence = slot->sequence++;"},{"entry":"\u2003\u2003\u2003\u2003element->buffer = buffer;"},{"entry":"\u2003\u2003\u2003\u2003element->state = 0;"},{"entry":"\u2003\u2003\u2003\u2003element->timestamp = 0;"},{"entry":"\u2003\u2003\u2003\u2003element->date = 0;"},{"entry":"\u2003\u2003\u2003\u2003element->time = 0;"},{"entry":"\u2003\u2003\u2003\u2003element->interface = index;"},{"entry":"\u2003\u2003\u2003\u2003element->length = 0;"},{"entry":"\u2003\u2003\u2003\u2003buffer->header_offset = buffer->buffer_offset;"},{"entry":"\u2003\u2003\u2003\u2003buffer->buffer_offset += sizeof(ELEMENT_HEADER);"},{"entry":"\u2003\u2003\u2003\u2003buffer->flags = \u22121;"},{"entry":"\u2003\u2003\u2003\u2003buffer->state |= L_DIRTY;"},{"entry":"\u2003\u2003\u2003\u2003if (!slot->b->cluster_bitmap[buffer->index])"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003slot->posted_count++;"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003slot->b->cluster_bitmap[buffer->index] = 1;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003slot->state |= L_DIRTY;"},{"entry":"\u2003\u2003\u2003\u2003slot->buffers_allocated++;"},{"entry":"\u2003\u2003\u2003\u2003p = (BYTE *)&buffer->buffer[buffer->buffer_offset];"},{"entry":"\u2003\u2003\u2003\u2003last_element = (ELEMENT_HEADER *)slot->last_element;"},{"entry":"\u2003\u2003\u2003\u2003if (last_element)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003last_element->next_offset = buffer->header_offset;"},{"entry":"\u2003\u2003\u2003\u2003\u2003last_element->next_index ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(slot->current_buffer % slot->d->buffer_count);"},{"entry":"#if (!TEST_AUTO_REPAIR)"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (slot->last_buffer)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003slot->last_buffer->state |= L_DIRTY;"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003element->previous_offset = slot->b->last_element_offset;"},{"entry":"\u2003\u2003\u2003\u2003\u2003element->previous_index = slot->b->last_element_index;"},{"entry":"\u2003\u2003\u2003\u2003\u2003element->next_offset = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003element->next_index = 0xFFFFFFFF;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003slot->b->starting_index ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003(slot->current_buffer % slot->d->buffer_count);"},{"entry":"\u2003\u2003\u2003\u2003\u2003slot->b->starting_offset = buffer->header_offset;"},{"entry":"\u2003\u2003\u2003\u2003\u2003element->previous_offset = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003element->previous_index = 0xFFFFFFFF;"},{"entry":"\u2003\u2003\u2003\u2003\u2003element->next_offset = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003element->next_index = 0xFFFFFFFF;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003slot->last_buffer = buffer;"},{"entry":"\u2003\u2003\u2003\u2003slot->last_element = element;"},{"entry":"\u2003\u2003\u2003\u2003slot->b->last_element_offset = buffer->header_offset;"},{"entry":"\u2003\u2003\u2003\u2003slot->b->last_element_index = (slot->current_buffer % slot->"},{"entry":"\u2003\u2003\u2003\u2003d->buffer_count);"},{"entry":"\u2003\u2003\u2003\u2003slot->b->all_elements++;"},{"entry":"#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003getcaptrace(p, buffer, buffer->buffer_offset,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003slot->current_buffer % slot->d->buffer_count);"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003for (slot->current_buffer++,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003curr = (slot->current_buffer % slot->d->buffer_count);;)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003buffer = (slot->buffers[slot->current_buffer % slot->d->"},{"entry":"\u2003\u2003\u2003\u2003buffer_count]);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (!buffer)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003slot->full = 0xFFFFFFFF;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (!buffer->flags)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"#if DYNAMIC_MTU"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if ((buffer->buffer_offset +"},{"entry":"\u2003\u2003\u2003\u2003sizeof(ELEMENT_HEADER) +"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(ndevs[index]->mtu * 2)) < slot->buffer_size)"},{"entry":"#else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if ((buffer->buffer_offset +"},{"entry":"\u2003\u2003\u2003\u2003sizeof(ELEMENT_HEADER) +"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003slot->max_packet_size) < slot->buffer_size)"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if ((++slot->current_buffer % slot->d->buffer_count) =="},{"entry":"\u2003\u2003\u2003\u2003curr)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003slot->full = 0xFFFFFFFF;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003spin_unlock_irqrestore(&slot->s_lock, slot->s_flags);"},{"entry":"\u2003\u2003\u2003\u2003\u2003return p;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003lock_count++;"},{"entry":"\u2003\u2003\u2003if ((++slot->current_buffer % slot->d->buffer_count) == curr)"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0168","num":"0167"},"figref":"FIG. 21"},"The Disk Space Record contains a 32 entry slot chain table. The Slot chain table defines the starting and ending slot Identifiers for a chain of populated slot cache elements that reside in the non-volatile system cache (on-disk). The Slot Chain table also records the date extents for capture network packets that reside in the time domain that comprises the sum total of elapsed time between the starting and ending slot chain element.","As slots are filled, each slot records the starting and ending time for the first and last packet contained within the slot cache element. Slots internally record time at the microsecond interval as well as UTC time for each received packet, however, within the Slot Chain and Space Table, only the UTC time is exported and recorded since microsecond time measurement granularity is not required at these levels for virtual file system interaction.",{"@attributes":{"id":"p-0171","num":"0170"},"figref":"FIG. 22"},"The Slot Chain Table uses the internal layout depicted in  to record specific information about each allocated slot chain. The disk space record contains a slot chain table the records the starting and ending slot index for a slot chain of captured elements. This table also records the number of slots in a chain and the starting and ending date:time for data stored in a linked chain of slots.","The Slot Chain Table records the starting slot address for a slot chain, the ending slot address for a slot chain, the number of total slots that comprise a slot chain, and the starting and ending dates for a slot chain. The dates are stored in standard UTC time format in both the Slot Chain Table and the System Space Table.","The slot chain table is contained within these fields in the disk space record header:",{"@attributes":{"id":"p-0175","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"ULONG slot_starting_cluster[MAX_INTERFACE_SLOTS];"},{"entry":"ULONG slot_ending_cluster[MAX_INTERFACE_SLOTS];"},{"entry":"ULONG slot_starting_time_domain[MAX_INTERFACE_SLOTS];"},{"entry":"ULONG slot_ending_time_domain[MAX_INTERFACE_SLOTS];"},{"entry":"ULONG slot_chain_size[MAX_INTERFACE_SLOTS];"},{"entry":"long long slot_element_count[MAX_INTERFACE_SLOTS];"},{"entry":"long long slot_element_bytes[MAX_INTERFACE_SLOTS];"},{"entry":"long long slot_slice_bytes[MAX_INTERFACE_SLOTS];"},{"entry":"SPACE_TABLE space_entry[MAX_INTERFACE_SLOTS];"},{"entry":"SPACE_TABLE slice_entry[MAX_INTERFACE_SLOTS];"},{"entry":"BYTE slot_names[MAX_INTERFACE_SLOTS][IFNAMSIZ];"},{"entry":"INTERFACE_INFO interface_info[MAX_INTERFACE_SLOTS];"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The Space Table serves as the file allocation table for Slot Chains in the system.  depicts the Space Table layout schematically. Slot Chains are analogous to files in a traditional file system. The Space table contains a field that points to the next logical slot within a slot chain, as well as starting and ending dates in UTC time format for packets stored within a Slot Cache Element.","The space table also stores meta-data used for dynamic file reconstruction that includes the number of packets stored in a slot cache element, the number of total packet bytes in a slot cache element, file attributes, owner attributes, meta-data header size, and the size of packet sliced bytes (96 byte default).","Space Table Entries use the following internal structure:",{"@attributes":{"id":"p-0179","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _SPACE_TABLE"]},{"entry":[{},"{"]},{"entry":[{},"\u2003ULONG slot;"]},{"entry":[{},"\u2003ULONG time_domain;"]},{"entry":[{},"\u2003ULONG ending_domain;"]},{"entry":[{},"\u2003ULONG element_count;"]},{"entry":[{},"\u2003ULONG element_bytes;"]},{"entry":[{},"\u2003ULONG slice_bytes;"]},{"entry":[{},"\u2003ULONG meta_bytes;"]},{"entry":[{},"\u2003WORD interface;"]},{"entry":[{},"\u2003umode_t mode;"]},{"entry":[{},"\u2003uid_t uid;"]},{"entry":[{},"\u2003gid_t gid;"]},{"entry":[{},"\u2003long long size;"]},{"entry":[{},"} SPACE_TABLE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Space Table Linkages are created by altering the next slot field which corresponds to a slot on a Disk Space Record Store. The Space Table entries are sequentially ordered based on slot position within the store. Index 0 into the Space Table corresponds to slot 0, index 1 to slot 1, and so forth. Space Table information is mirrored in both a secondary Mirrored Space table, and also exists within the slot cache element header for a slot as well. This allows a Space Table to be rebuilt from slot storage even if both primary and secondary Space Table mirrors are lost and is provided for added fault tolerance.","The slot number address space is a 32-bit value for which a unique disk space record store is expressed as:\n\n(01)=total number of slot addresses.\n","Value 0xFFFFFFFF is reserved as an EOF (end of file) marker for the Space Table next slot entry field which allows a range of 0\u2212(0xFFFFFFFF\u22121) permissible slot addresses. Slot Chains are created and maintained as a linked list in the Space Table of slots that belong to a particular slot chain. The beginning and ending slots and their time domain and ending domain values are stored in the Slot Chain table in the DSR, and the actual linkages between slots is maintained in the space table. During Space Table traversal, when the value 0xFFFFFFFF is encountered, this signals end of chain has been reached.","The DSFS space table maintains an allocation table that employs positional chain elements in a forward linked list that describe a slot index within a DSFS file system partition. The Disk Space record stores the actual cluster based offset into a DSFS partition for meta-table and slot storage.",{"@attributes":{"id":"p-0184","num":"0183"},"figref":"FIG. 25"},"During normal operations in which a disk space record store has not been fully populated, slots are allocated based upon a bit table built during DSR mount that indicated the next free slot available on a particular DSR. As slots are allocated, and the disk space record store becomes full, it becomes necessary to recycle the oldest slot cache elements from the store. Since the time domain information for a particular slot chain is stored in the Disk Space Record header, it is a simple matter to scan the 32 entries in the table and determine the oldest slot cache element reference in a slot chain head. When the slot cache has become completely full, the oldest slot segment is pruned from the head of the target slot chain and re-allocated for storage from the volatile (in-memory) slot element cache.","The Slot Chain Heads are correspondingly updated to reflect the pruned slot and the storage is appended to the ending slot of the active slot chain that allocated the slot cache element storage.  depicts the on-disk slot cache segment chains employing a last recently uses LRU recycling method. The starting slot located in the slot chain table is pruned from the slot chain head based on the oldest starting slot in the Slot Chain Table for a given Disk Space Record of slot cache storage segments.","During initial mounting and loading of a DSFS disk space record store, the store is scanned, space tables are scanned for inconsistencies, and the chain lengths and consistencies are checked. During this scan phase, the system builds several bit tables that are used to manage allocation of slot cache element storage and chain management. These tables allow rapid searching and state determinations of allocations and chain location and are used by the DSFS virtual file system to dynamically generate file meta-data and LIBPCAP headers. These tables also enable the system to correct data inconsistencies and rapid-restart of due to incomplete shutdown.","The Space Tables are mirrored during normal operations on a particular DSR and checked during initial mounting to ensure the partition is consistent. The system also builds an allocation map based on those slots reflected to exist with valid linkages in the space table.  depicts the Allocation Bitmap and Chain Bitmap table structure. After this table is constructed, DSFS verifies all the slot chain links and compares the allocations against a chain bitmap table that is annotated as each chain element is traversed. If a chain is found to have already been entered into the bitmap table, then a circular chain has been detected and the chain is truncated to a value of 0xFFFFFFFF. Following verification of chain linkages, the system compares the allocation bitmap with the chain bitmap and frees any slots in the space table that do not have valid linkages in the chain bitmap table. This allows the system to dynamically recover from data corruption due to improper shutdown or power failures without off-line (unmounted) repair. Each Slot Chain Head maintains a bitmap of current slot allocations within it's particular chain. This table is used to validate slot membership within a chain by user space processes running about DSFS that may have stale handles or context into a chain after a recycle event.","It is possible for a user space application to hold a slot open for a particular slot chain, and for the chain to re-cycle the slot underneath the user during normal operations. The Slot Chain bitmaps allow the DSFS virtual file system to verify a slots membership in a chain before retrying the read with a known slot offset location.","The volatile (in-memory) slot element cache is designed as a memory based linked listing of slot cache elements that mirrors the slot cache element structure used on disk. The format is identical on-disk to the in-memory format that described a slot cache element. This list is maintained through three sets of linkages that are combined within the slot buffer header for a slot cache element. The structure of a slot cache element is as follows:",{"@attributes":{"id":"p-0191","num":"0190"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct _SLOT_BUFFER_HEADER"},{"entry":"{"},{"entry":"\u2003ULONG signature;"},{"entry":"\u2003ULONG asynch_io_signature;"},{"entry":"\u2003ULONG slot_instance;"},{"entry":"\u2003struct _SLOT_BUFFER_HEADER *next;"},{"entry":"\u2003struct _SLOT_BUFFER_HEADER *prior;"},{"entry":"\u2003struct _SLOT_BUFFER_HEADER *lnext;"},{"entry":"\u2003struct _SLOT_BUFFER_HEADER *lprior;"},{"entry":"\u2003struct _SLOT_BUFFER_HEADER *hashNext;"},{"entry":"\u2003struct _SLOT_BUFFER_HEADER *hashPrior;"},{"entry":"\u2003struct _SLOT_BUFFER_HEADER *list_next;"},{"entry":"\u2003struct _SLOT_BUFFER_HEADER *list_prior;"},{"entry":"\u2003volatile unsigned long state;"},{"entry":"\u2003ULONG max_packet_size;"},{"entry":"\u2003ULONG buffer_size;"},{"entry":"\u2003ULONG current_buffer;"},{"entry":"\u2003ULONG buffers_allocated;"},{"entry":"\u2003ULONG sequence;"},{"entry":"\u2003ULONG io_count;"},{"entry":"\u2003ULONG critical_section;"},{"entry":"\u2003ULONG slot_age;"},{"entry":"\u2003CAPTURE_BUFFER_HEADER *buffers[RING_SLOTS_MAX];"},{"entry":"\u2003CAPTURE_BUFFER_HEADER *slot_buffer;"},{"entry":"\u2003CAPTURE_BUFFER_HEADER *last_buffer;"},{"entry":"\u2003void *last_element;"},{"entry":"\u2003DISK_SPACE_RECORD *d;"},{"entry":"\u2003ULONG waiters;"},{"entry":"\u2003ULONG lock_count;"},{"entry":"\u2003ULONG slot_id;"},{"entry":"\u2003ULONG io_signature;"},{"entry":"\u2003ULONG (*slot_cb)(struct _SLOT_BUFFER_HEADER *);"},{"entry":"\u2003ULONG slot_cb_param;"},{"entry":"\u2003ULONG lru_recycled;"},{"entry":"\u2003ULONG last_slot_id;"},{"entry":"\u2003ULONG slot_type;"},{"entry":"\u2003ULONG posted_count;"},{"entry":"\u2003ULONG submitted_count;"},{"entry":"#if (!LINUX_UTIL)"},{"entry":"\u2003spinlock_t s_lock;"},{"entry":"\u2003ULONG s_flags;"},{"entry":"#endif"},{"entry":"\u2003ULONG last_eip;"},{"entry":"#if (!LINUX_UTIL)"},{"entry":"\u2003struct semaphore sema;"},{"entry":"\u2003struct semaphore release_sema;"},{"entry":"#endif"},{"entry":"\u2003SPACE_TABLE *space;"},{"entry":"\u2003SPACE_TABLE_BUFFER *space_buffer;"},{"entry":"\u2003SLOT_BANK_HEADER *b;"},{"entry":"\u2003ULONG full;"},{"entry":"\u2003ULONG flags;"},{"entry":"} SLOT_BUFFER_HEADER;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The slot buffer header that describes a slot cache element is a member of four distinct lists. The first list is the master allocation list. This list maintains a linkage of all slot buffer heads in the system. It is used to traverse the slot LRU listing for aging of slot requests and write I\/O submission of posted slots. The slot buffer header also can exist in a slot hash listing.  depicts the use of a slot hash table to map slot LRU buffer elements. This listing is an indexed table that utilizes an extensible hashing algorithm to keep a hash of slots currently cached in the system. This allows rapid lookup of a slot by number from the system and is the main view portal from user space into the DSFS file system. If a slot does not exist in the hash listing with a valid ID, then it is not accessible during initial open operations of a slot.","The LRU list is used by DSFS to determine which slot buffer header was touched last. More recent accesses to a slot buffer header result in the slot buffer header being moved to the top of the listing. Slot cache elements that have valid data and have been flushed to disk and have not been accessed tend to move to the bottom of this list over time. When the system needs to re-allocate a slot cache element and it's associated slot buffer header for a new slot for either a read or write request to the volatile slot LRU cache, then the caching algorithm will select the oldest slot in memory that is not locked, has not been accessed, and has been flushed to disk and return date from it. In the event of a read request from user space, it the slot is does not exist in the slot hash listing, it is added, the oldest slot buffer header is evicted from the cache, and scheduled for read I\/O in order to load the requested slot from a user space reader.",{"@attributes":{"id":"p-0194","num":"0193"},"figref":"FIG. 29"},"Network adapters that are open and capturing network packets allocate an empty slot buffer header which reference a slot cache element and its associated buffer chain from the LRU cache based on the algorithm depicted in  which shows how adaptors allocate slot LRU elements from cache. These slot buffer headers are locked and pinned in memory until the adapter releases the allocated buffers. The system keeps track of allocated slot buffer headers through an adapter slot table that records the current active slot cache element that is being accessed by a particular adapter ring buffer.","If a reader from user space accesses a slot buffer header and its associated slot cache element buffer chain during a recycle phase of a target slot, the slot LRU allows the network adapter at this layer to reallocate the same slot address in a unique slot buffer header and slot cache element. This process requires that the slot id be duplicated in the slot LRU until the last user space reference to a particular slot address is released. This even can occur if user space applications are reading data from a slot chain, and the application reaches a slot in the chain that has been recycled due to the slot store becoming completely full. In most cases, since slot chains contain the most recent data at the end of a slot chain, and the oldest data is located at the beginning of a slot chain, this is assumed to be an infrequent event.","The newly allocated slot chain element in this case becomes the primary entry in the slot hash list in the LRU, and all subsequent open requests are redirected to this entry. The previous slot LRU entry for this slot address is flagged with a \u22121 value and removed from the slot hash list that removes it from the user space portal view into the DSFS volatile slot cache. When the last reference to the previous slot buffer header is released from user space, the previous slot buffer header is evicted from the slot LRU and placed on a free list for reallocation by network adapters for writing or user space readers for slot reading by upper layer applications.  depicts the recycling of the oldest entries as they are released. When a slot cache buffer is recycled by the capture store, if any references exist from p_handle access, the previous slot buffer is pinned in the slot cache until the last p_handle releases the buffer. New request point to a newly allocated slot cache buffer with the same slot number.","A single process daemon is employed by the operating system that is signaled via a semaphore when a slot LRU slot buffer header is dirty and requires the data content to be flushed to the disk array. This daemon uses the master slot list to peruse the slot buffer header chain to update aging timestamps in the LRU slot buffer headers, and to submit writes for posted LRU elements. By default, an LRU slot buffer header can have the following states:",{"@attributes":{"id":"p-0199","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define L_AVAIL\u2003\u20030x0000001"]},{"entry":[{},"#define L_FREE\u2003\u20030x0000002"]},{"entry":[{},"#define L_DATAVALID 0x0000004"]},{"entry":[{},"#define L_DIRTY\u2003\u20030x0000008"]},{"entry":[{},"#define L_FLUSHING 0x0000010"]},{"entry":[{},"#define L_LOADING\u20030x0000020"]},{"entry":[{},"#define L_UPTODATE 0x0000040"]},{"entry":[{},"#define L_MAPPED\u20030x0000080"]},{"entry":[{},"#define L_MODIFIED\u20030x0000100"]},{"entry":[{},"#define L_POST\u2003\u20030x0000200"]},{"entry":[{},"#define L_LOCKED\u20030x0000400"]},{"entry":[{},"#define L_DROP\u2003\u20030x0000800"]},{"entry":[{},"#define L_HASHED\u20030x0001000"]},{"entry":[{},"#define L_VERIFIED 0x0002000"]},{"entry":[{},"#define L_CREATE\u20030x0004000"]},{"entry":[{},"#define L_REPAIR\u20030x0008000"]},{"entry":[{},"#define L_ADJUST\u20030x0010000"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Entries flagged as L_POST or L_REPAIR are written to non-volatile storage immediately. Entries flagged L_DIRTY are flushed at 30 second intervals to the system store. Meta-data updates to the Space Table for L_DIRTY slot buffer headers are synchronized with the flushing of a particular slot address. Slot buffer headers flagged L_LOADING are read requests utilizing asynchronous read I\/O. L_HASHED means the slot address and slot buffer header are mapped in the slot hash list and are accessible by user space applications for open, read, and close requests.",{"@attributes":{"id":"p-0201","num":"0200"},"figref":"FIG. 32"},"The directory layouts are all accessible via open( ), read( ), write( ), Iseek( ), and close( ) system calls; Slot chains are also exposed as virtual files and can also use standard system calls to read an entire slot chain of capture network traffic. LIBPCAP allows this data to be exported dynamically to a wide variety of user space applications and network forensics monitoring and troubleshooting tools.","The DSFS file system utilizes a P_HANDLE structure to create a unique view into a slot cache element or a chain of slot cache elements. The P_HANDLE structure records the network interface chain index into the Slot Chain table, and specific context referencing current slot address, slot index address, and offset within a slot chain, if a slot chain is being access and not an individual slot cache element.","The P_HANDLE structure is described as:",{"@attributes":{"id":"p-0205","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _P_HANDLE"]},{"entry":[{},"{"]},{"entry":[{},"\u2003ULONG opened;"]},{"entry":[{},"\u2003ULONG instance;"]},{"entry":[{},"\u2003ULONG interface;"]},{"entry":[{},"\u2003ULONG vinterface;"]},{"entry":[{},"\u2003struct net_device *dev;"]},{"entry":[{},"\u2003ULONG minor;"]},{"entry":[{},"\u2003ULONG slot_id;"]},{"entry":[{},"\u2003BYTE *buffer;"]},{"entry":[{},"\u2003ULONG length;"]},{"entry":[{},"\u2003ULONG flags;"]},{"entry":[{},"\u2003ULONG pindex;"]},{"entry":[{},"\u2003ULONG index;"]},{"entry":[{},"\u2003ULONG offset;"]},{"entry":[{},"\u2003ULONG slot_offset;"]},{"entry":[{},"\u2003ULONG turbo_slot;"]},{"entry":[{},"\u2003ULONG turbo_index;"]},{"entry":[{},"\u2003long long turbo_offset;"]},{"entry":[{},"\u2003SLOT_BUFFER_HEADER *slot;"]},{"entry":[{},"\u2003ULONG slot_instance;"]},{"entry":[{},"\u2003struct timeval start;"]},{"entry":[{},"\u2003struct timeval end;"]},{"entry":[{},"\u2003solera_file_node *node;"]},{"entry":[{},"\u2003ULONG slot_anchor;"]},{"entry":[{},"\u2003unsigned long long offset_anchor;"]},{"entry":[{},"\u2003ULONG pindex_anchor;"]},{"entry":[{},"\u2003ULONG anchor_date_limit;"]},{"entry":[{},"\u2003unsigned long long anchor_limit;"]},{"entry":[{},"\u2003ULONG xmit_flags;"]},{"entry":[{},"\u2003BITMAP *bitmap;"]},{"entry":[{},"\u2003ULONG bitmap_size;"]},{"entry":[{},"\u2003struct _P_HANDLE *next;"]},{"entry":[{},"\u2003struct _P_HANDLE *prior;"]},{"entry":[{},"\u2003void *d;"]},{"entry":[{},"\u2003struct timeval next_timestamp;"]},{"entry":[{},"\u2003unsigned long p_count;"]},{"entry":[{},"\u2003unsigned long p_curr;"]},{"entry":[{},"\u2003unsigned long p_mask;"]},{"entry":[{},"\u2003struct _P_HANDLE *p_active;"]},{"entry":[{},"\u2003ULONG p_active_size;"]},{"entry":[{},"\u2003ULONG p_active_offset;"]},{"entry":[{},"\u2003BYTE p_state[MAX_INTERFACE_SLOTS];"]},{"entry":[{},"\u2003struct _P_HANDLE *p_array[MAX_INTERFACE_SLOTS];"]},{"entry":[{},"\u2003long long p_offset[MAX_INTERFACE_SLOTS];"]},{"entry":[{},"} P_HANDLE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The P_HANDLE structure is also hierarchical, and allows P_HANDLE contexts to be dynamically mapped to multiple slot cache elements in parallel, that facilitates time domain based merging of captured network traffic. In the case of asymmetrically routed TX\/RX network traffic across separate network segments, or scenarios involving the use of an optical splitter, network TX\/RX traffic may potentially be stored from two separate network devices that actually represent a single stream of network traffic.","With hierarchical P_HANDLE contexts, it is possible to combine several slot chains into a single chain dynamically by selecting the oldest packet from each slot chain with a series of open p_handles, each with it's own unique view into a slot chain. This facilitates merging of captured network traffic from multiple networks. This method also allows all network traffic captured by the system to be aggregated into a single stream of packets for real time analysis of network forensics applications, such as an intrusion detection system from all network interfaces in the system.",{"@attributes":{"id":"p-0208","num":"0207"},"figref":"FIG. 33"},"Commands are embedded directly into the created file name and parsed by the DSFS virtual file system and used to allocate and map P_HANDLE contexts into specific index locations within the specified slot chains. The format of the command language is more fully defined as:",{"@attributes":{"id":"p-0210","num":"0209"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Name Format -> int0:int1:int2:int3-data:<D>-data:<D,S>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"D - Beginning or Ending Date"},{"entry":"S - Maximum Size"}]}}}}},"Where <int0> is the name or chain index number of a slot chain and <D> date is either a starting or ending date formatted in the following syntax or a date and an ending size of a merged series of slot chains. The touch command can be used to create these views into specified slot chains. To create a file with a starting and ending date range you wish to view, enter:",{"@attributes":{"id":"p-0212","num":"0211"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"touch <interface[number]:interface[number]>-"},{"entry":"\u2003\u2003MM.DD.YYYY.HH.MM.SS:d-MM.DD.YYYY.HH.MM.SS:d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":"to create a file with a starting date that is limited to a certain size, enter:"}}}},{"@attributes":{"id":"p-0213","num":"0213"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"touch <interface[number]:interface[number]>-"]},{"entry":[{},"\u2003\u2003MM.DD.YYYY.HH.MM.SS:d-<size in bytes>:s"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"An interface number can also be used as an interface name. This was supported to allow renaming of interfaces while preserving the ability to read data captured on a primary partition including, by way of example, the following data sets and their respective command line entries:","all packets captured for a time period of 1 second on Aug. 2, 2004 at 14:15:07 through Aug. 2, 2004 at 14:15:08 on eth1 and eth2\n\n","all packets captured for a time period of Aug. 2, 2004 at 14:15:07 up to the <size> of the specified data range on eth1\n\n","all packets captured for a time period of 1 second on Aug. 2, 2004 at 14:15:07 through Aug. 2, 2004 at 14:15:08 for eth1(11)\n\n","all packets captured for a time period of Aug. 2, 2004 at 14:15:07 up to the <size> of the specified data range eth1(11)\n\n","P_HANDLE context structures are also employed via user space interfaces to create virtual network adapters to user space that appear as physical adapters to user space applications as depicted in . DSFS allows p_handle contexts to be mapped to the capture slot chain for a physical network adapter, such as eth0, and allow user space applications to read from the capture store as though it were a physical network. The advantage of this approach relates to packet lossless performance. With this architecture, the I\/O subsystem in the DSFS capture system has been architected to favor network capture over user applications. Exporting virtual network interfaces allows user space intrusion detection systems to run as applications without being directly mapped to hardware devices. This also allows the user applications to process the captured network packets in the background while the network packets are streamed to the disk arrays in parallel. This provides significantly improved performance of intrusion detection applications without packet loss, since the application can simply sleep when the network load on the system becomes more active.","This also allows all known network forensic applications that use standard network and file system interfaces seamless and integrated access to captured data at real-time performance levels and additionally providing a multi-terabyte capture store that streams packets to disk in a permanent archive while at the same time supporting real-time analysis and filtering applications with no proprietary interfaces. Virtual interfaces are created using calls into the sockets layer of the underlying operating system. Calls to open s socket result in the creation of a P_HANDLE context pointer mapped into the captured slot chain for a mapped virtual device. The algorithm that maps a P_HANDLE context to an operating system socket is described as:",{"@attributes":{"id":"p-0221","num":"0225"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003int bind_event(struct socket *sock, struct net_device *dev)"},{"entry":"\u2003{"},{"entry":"\u2003\u2002struct sock *sk = sock->sk;"},{"entry":"\u2003\u2002P_HANDLE *p_handle;"},{"entry":"\u2003\u2002if (dev && ifp_state[dev->ifindex] && !sk->priv_data)"},{"entry":"\u2003\u2002{"},{"entry":"\u2003\u2003if (!verify_license(VI_ACTIVE))"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2002P_Print(\u201cSolera Networks, Inc.: license feature"},{"entry":"VIRTUAL_INTERFACE not installed\\n\u201d);"},{"entry":"\u2003\u2003\u2002return \u221210;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003p_handle = KMALLOC(sizeof(P_HANDLE), GFP_KERNEL);"},{"entry":"\u2003\u2003if (!p_handle)"},{"entry":"\u2003\u2003\u2002return 0;"},{"entry":"\u2003\u2003memset(p_handle, 0, sizeof(P_HANDLE));"},{"entry":"\u2003#if USE_LOCAL_BUFFER"},{"entry":"\u2003\u2003p_handle->buffer = KMALLOC(MAX_BUFFER_SIZE,"},{"entry":"GFP_KERNEL);"},{"entry":"\u2003\u2003if (!p_handle->buffer)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2002kfree(p_handle);"},{"entry":"\u2003\u2003\u2002return 0;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003memset(p_handle->buffer, 0, MAX_BUFFER_SIZE);"},{"entry":"\u2003\u2003p_handle->length = MAX_BUFFER_SIZE;"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003p_handle->opened = \u22121;"},{"entry":"\u2003\u2003p_handle->instance = (ULONG) sock;"},{"entry":"\u2003\u2003p_handle->vinterface = \u22121;"},{"entry":"\u2003\u2003p_handle->dev = NULL;"},{"entry":"\u2003\u2003if (dev)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2002p_handle->vinterface = dev->ifindex;"},{"entry":"\u2003\u2003\u2002p_handle->dev = dev;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003p_handle->interface = 0;"},{"entry":"\u2003\u2003p_handle->minor = 0;"},{"entry":"\u2003\u2003p_handle->slot_id = 0;"},{"entry":"\u2003\u2003p_handle->slot_anchor = \u22121;"},{"entry":"\u2003\u2003p_handle->offset_anchor = 0;"},{"entry":"\u2003\u2003p_handle->pindex_anchor = 0;"},{"entry":"\u2003\u2003p_handle->anchor_date_limit = 0;"},{"entry":"\u2003\u2003p_handle->anchor_limit = 0;"},{"entry":"\u2003\u2003p_handle->slot_instance = 0;"},{"entry":"\u2003\u2003p_handle->pindex = 0;"},{"entry":"\u2003\u2003p_handle->index = 0;"},{"entry":"\u2003\u2003p_handle->offset = 0;"},{"entry":"\u2003\u2003p_handle->slot_offset = 0;"},{"entry":"\u2003\u2003p_handle->turbo_slot = \u22121;"},{"entry":"\u2003\u2003p_handle->turbo_index = 0;"},{"entry":"\u2003\u2003p_handle->turbo_offset = 0;"},{"entry":"\u2003#if LINUX_26"},{"entry":"\u2003\u2003p_handle->start.tv_sec = CURRENT_TIME.tv_sec;"},{"entry":"\u2003#else"},{"entry":"\u2003\u2003p_handle->start.tv_sec = CURRENT_TIME;"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003p_handle->start.tv_usec = 0;"},{"entry":"\u2003\u2003p_handle->end.tv_sec = 0xFFFFFFFF;"},{"entry":"\u2003\u2003p_handle->end.tv_usec = 0xFFFFFFFF;"},{"entry":"\u2003\u2003p_handle->flags = \u22121;"},{"entry":"\u2003\u2003p_handle->next = NULL;"},{"entry":"\u2003\u2003p_handle->prior = NULL;"},{"entry":"\u2003\u2003if ((p_handle->vinterface != \u22121) &&"},{"entry":"\u2003\u2003\u2002(p_handle->vinterface < MAX_INTERFACE_SLOTS) &&"},{"entry":"\u2003\u2003\u2002(vbitmap[p_handle->vinterface]))"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2002p_handle->bitmap = vbitmap[p_handle->vinterface];"},{"entry":"\u2003\u2003\u2002p_handle->bitmap_size = sizeof(BITMAP);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003sk->priv_data = p_handle;"},{"entry":"\u2003\u2003if (dev->name && !(strncmp(dev->name, \u201cifm\u201d, 3)))"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2002register int j;"},{"entry":"\u2003\u2003\u2002for (p_handle->p_mask = p_handle->p_count = j = 0;"},{"entry":"\u2003\u2003\u2003j < MAX_INTERFACE_SLOTS; j++)"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003if (ndev_state[j])"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2002register P_HANDLE *new_p_handle;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle = KMALLOC(sizeof(P_HANDLE),"},{"entry":"GFP_KERNEL);"},{"entry":"\u2003\u2003\u2003\u2002if (!new_p_handle)"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2002memset(new_p_handle, 0, sizeof(P_HANDLE));"},{"entry":"\u2003#if USE_LOCAL_BUFFER"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->buffer ="},{"entry":"KMALLOC(MAX_BUFFER_SIZE, GFP_KERNEL);"},{"entry":"\u2003\u2003\u2003\u2002if (!new_p_handle->buffer)"},{"entry":"\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003kfree(new_p_handle);"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2002memset(new_p_handle->buffer, 0, MAX_BUFFER_SIZE);"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->length = MAX_BUFFER_SIZE;"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->opened = \u22121;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->instance = (ULONG) sock;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->vinterface = \u22121;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->dev = NULL;"},{"entry":"\u2003\u2003\u2003\u2002if (dev)"},{"entry":"\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003new_p_handle->vinterface = dev->ifindex;"},{"entry":"\u2003\u2003\u2003\u2003new_p_handle->dev = dev;"},{"entry":"\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->interface = j;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->minor = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->slot_id = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->slot_anchor = \u22121;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->offset_anchor = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->pindex_anchor = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->anchor_date_limit = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->anchor_limit = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->slot_instance = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->pindex = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->index = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->offset = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->slot_offset = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->turbo_slot = \u22121;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->turbo_index = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->turbo_offset = 0;"},{"entry":"\u2003#if LINUX_26"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->start.tv_sec = CURRENT_TIME.tv_sec;"},{"entry":"\u2003#else"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->start.tv_sec = CURRENT_TIME;"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->start.tv_usec = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->end.tv_sec = 0xFFFFFFFF;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->end.tv_usec = 0xFFFFFFFF;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->flags = \u22121;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->next = NULL;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->prior = NULL;"},{"entry":"\u2003#if ZERO_NEXT_TIMESTAMP"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->next_timestamp.tv_sec = 0;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->next_timestamp.tv_usec = 0;"},{"entry":"\u2003#else"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->next_timestamp.tv_sec = 0xFFFFFFFF;"},{"entry":"\u2003\u2003\u2003\u2002new_p_handle->next_timestamp.tv_usec = 0xFFFFFFFF;"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2002if ((p_handle->vinterface != \u22121) &&"},{"entry":"\u2003\u2003\u2003\u2003(p_handle->vinterface < MAX_INTERFACE_SLOTS)"},{"entry":"&&"},{"entry":"\u2003\u2003\u2003\u2003(vbitmap[p_handle->vinterface]))"},{"entry":"\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003new_p_handle->bitmap = vbitmap[p_handle-"},{"entry":">vinterface];"},{"entry":"\u2003\u2003\u2003\u2003new_p_handle->bitmap_size = sizeof(BITMAP);"},{"entry":"\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2002p_handle->p_array[p_handle->p_count] = new_p_handle;"},{"entry":"\u2003\u2003\u2003\u2002p_handle->p_state[p_handle->p_count] = 0;"},{"entry":"\u2003\u2003\u2003\u2002p_handle->p_count++;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002return 0;"},{"entry":"\u2003}"},{"entry":"\u2003int release_event(struct socket *sock)"},{"entry":"\u2003{"},{"entry":"\u2003\u2002struct sock *sk = sock->sk;"},{"entry":"\u2003\u2002register int j;"},{"entry":"\u2003\u2002P_HANDLE *p_handle, *m_handle;"},{"entry":"\u2003\u2002if (sk->priv_data)"},{"entry":"\u2003\u2002{"},{"entry":"\u2003\u2003p_handle = (P_HANDLE *)sk->priv_data;"},{"entry":"\u2003\u2003for (j=0; j < p_handle->p_count; j++)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2002if (p_handle->p_array[j])"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003m_handle = p_handle->p_array[j];"},{"entry":"\u2003#if USE_LOCAL_BUFFER"},{"entry":"\u2003\u2003\u2003if (m_handle->buffer)"},{"entry":"\u2003\u2003\u2003\u2002kfree(m_handle->buffer);"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003\u2003kfree(m_handle);"},{"entry":"\u2003\u2003\u2003p_handle->p_array[j] = 0;"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003#if USE_LOCAL_BUFFER"},{"entry":"\u2003\u2003if (p_handle->buffer)"},{"entry":"\u2003\u2003\u2002kfree(p_handle->buffer);"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003kfree(p_handle);"},{"entry":"\u2003\u2003sk->priv_data = NULL;"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002return 0;"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Subsequent IOCTL calls to the virtual device return the next packet in the stream. For merge slot chains, the IOCTL call returns the oldest packet for the entire array of open slot chains. This allows virtual interfaces ifm0 and ifm1 to return the entire payload of a captured system to user space applications though a virtual adapter interface. P_HANDLE contexts are unique and by default, are indexed to the current time the virtual interface is opened relative to the time domain position in a captured slot chain. This mirrors the actual behavior of a physical network adapter. It is also possible through the P_HANDLE context to request a starting point in the slot chain at a time index that is earlier or later than the current time a virtual interface was opened. This allows user space application to move backwards or forward in time on a captured slot chain and replay network traffic. Virtual interfaces can also be configured to replay data to user space applications with the exact UTC\/microsecond timings the network data was actually received from the network segments and archived.","Playback is performed in a slot receive event that is also hooked to the underlying operating system sys_recvmsg sockets call. calls to recvmsg redirect socket reads to the DSFS slot cache store and read from the mapped slot chain for a particular virtual interface adapter.","The sys_recvmsg algorithm for redirecting operating system user space requests to read a socket from a virtual interface is described as:",{"@attributes":{"id":"p-0225","num":"0229"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003int receive_event(struct socket *sock, struct msghdr *msg,"},{"entry":"\u2003\u2003\u2003\u2002int len, int flags, struct timeval *stamp)"},{"entry":"\u2003{"},{"entry":"\u2003\u2002struct net_device *dev;"},{"entry":"\u2003\u2002struct sock *sk = NULL;"},{"entry":"\u2003\u2002register P_HANDLE *p_handle = NULL;"},{"entry":"\u2003\u2002register P_HANDLE *new_p_handle = NULL;"},{"entry":"\u2003\u2002register int ifindex;"},{"entry":"\u2003\u2002if (!sock)"},{"entry":"\u2003\u2003return -EBADF;"},{"entry":"\u2003\u2002sk = sock->sk;"},{"entry":"\u2003\u2002if (!sk)"},{"entry":"\u2003\u2003return -EBADF;"},{"entry":"\u2003\u2002\/\/ not mapped to virtual interface"},{"entry":"\u2003\u2002p_handle = (P_HANDLE *)sk->priv_data;"},{"entry":"\u2003\u2002if (!p_handle)"},{"entry":"\u2003\u2003return 0;"},{"entry":"\u2003\u2002ifindex = p_handle->vinterface;"},{"entry":"\u2003\u2002if (ifindex == \u22121)"},{"entry":"\u2003\u2003return -EBADF;"},{"entry":"\u2003\u2002if ((sk->sk_family & PF_PACKET) &&"},{"entry":"\u2003\u2003(ifindex <= MAX_INTERFACE_SLOTS) && (sk->priv_data))"},{"entry":"\u2003\u2002{"},{"entry":"\u2003\u2003if (ifp_state[ifindex])"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2002register ULONG pindex, copied;"},{"entry":"\u2003\u2003\u2002ULONG length = 0;"},{"entry":"\u2003\u2003\u2002READ_ELEMENT_HEADER header;"},{"entry":"read_again:;"},{"entry":"\u2003\u2003\u2002if (ifp_merge[ifindex])"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003new_p_handle = get_merge_target(p_handle, NULL,"},{"entry":"NULL);"},{"entry":"\u2003\u2003\u2003if (!new_p_handle)"},{"entry":"\u2003\u2003\u2003\u2002return -ENOENT;"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2002else"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003new_p_handle = p_handle;"},{"entry":"\u2003\u2003\u2003p_handle->interface = get_ifp_mapping(ifindex);"},{"entry":"\u2003\u2003\u2003if (p_handle->interface < 0)"},{"entry":"\u2003\u2003\u2003\u2002return -EBADF;"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2002pindex = read_chain_packet(new_p_handle->interface, msg,"},{"entry":"len,"},{"entry":"\u2003\u2003\u2003\u2003\u2003new_p_handle, &length, stamp, &header,"},{"entry":"\u2003\u2003\u2003\u2003\u2003&new_p_handle->start, &new_p_handle-"},{"entry":">end,"},{"entry":"\u2003\u2003\u2003\u2003\u2003NULL);"},{"entry":"\u2003\u2003\u2002if (pindex == -ENOENT)"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003P_Print(\u201c-ENOENT\\n\u201d);"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003\u2003return pindex;"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2002if (pindex == 0xFFFFFFFF)"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003P_Print(\u201cpindex == 0xFFFFFFFF\\n\u201d);"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003\u2003if (flags & MSG_DONTWAIT)"},{"entry":"\u2003\u2003\u2003\u2002return -EAGAIN;"},{"entry":"\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2002goto read_again;"},{"entry":"\u2003\u2003\u2003return 0;"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2002if (!length)"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003P_Print(\u201c!length\\n\u201d);"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003\u2003if (flags & MSG_DONTWAIT)"},{"entry":"\u2003\u2003\u2003\u2002return -EAGAIN;"},{"entry":"\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2002goto read_again;"},{"entry":"\u2003\u2003\u2003return 0;"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2002copied = length;"},{"entry":"\u2003\u2003\u2003if (copied > len)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003copied = len;"},{"entry":"\u2003\u2003\u2003\u2002msg->msg_flags |= MSG_TRUNC;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003if (sock->type == SOCK_PACKET)"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2002struct sockaddr_pkt *spkt ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002(struct sockaddr_pkt *)msg->msg_name;"},{"entry":"\u2003\u2003\u2003if (spkt)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003dev = dev_get_by_index(ifindex);"},{"entry":"\u2003\u2003\u2003\u2003if (dev)"},{"entry":"\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003\u2002spkt->spkt_family = dev->type;"},{"entry":"\u2003\u2003\u2003\u2003\u2002strncpy(spkt->spkt_device, dev->name,"},{"entry":"\u2003\u2003\u2003\u2003\u2003sizeof(spkt->spkt_device));"},{"entry":"\u2003\u2003\u2003\u2003\u2002spkt->spkt_protocol = header.protocol;"},{"entry":"\u2003\u2003\u2003\u2003if solera_rx(dev, length, 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2002dev_put(dev);"},{"entry":"\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2002struct sockaddr_ll *sll ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002(struct sockaddr_ll *)msg->msg_name;"},{"entry":"\u2003\u2003\u2003if (sll)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003sll->sll_family = AF_PACKET;"},{"entry":"\u2003\u2003\u2003\u2003sll->sll_ifindex = ifindex;"},{"entry":"\u2003\u2003\u2003\u2003dev = dev_get_by_index(ifindex);"},{"entry":"\u2003\u2003\u2003\u2003if (dev)"},{"entry":"\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003\u2002sll->sll_protocol = header.protocol;"},{"entry":"\u2003\u2003\u2003\u2003sll->sll_pkttype = header.type;"},{"entry":"\u2003\u2003\u2003\u2003\u2002sll->sll_hatype = dev->type;"},{"entry":"\u2003\u2003\u2003\u2003\u2002sll->sll_halen = dev->addr_len;"},{"entry":"\u2003\u2003\u2003\u2003\u2002memcpy(sll->sll_addr, dev->dev_addr, dev-"},{"entry":">addr_len);"},{"entry":"\u2003\u2003\u2003\u2003if solera_rx(dev, length, 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2002dev_put(dev);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2002else"},{"entry":"\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003\u2002sll->sll_hatype = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2002sll->sll_halen = 0;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2002if (ifp_time_state[ifindex] &&"},{"entry":"\u2003\u2003\u2003stamp && (stamp->tv_sec || stamp->tv_usec))"},{"entry":"\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003if ((ifp_delay_table[ifindex].tv_sec) ||"},{"entry":"\u2003\u2003\u2003\u2002(ifp_delay_table[ifindex].tv_usec))"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003long long usec = 0;"},{"entry":"\u2003\u2003\u2003\u2002unsigned long sec = 0, i;"},{"entry":"\u2003\u2003\u2003\u2003long long last_usec = 0, curr_usec = 0;"},{"entry":"\u2003\u2003\u2003\u2002register ULONG usec_per_jiffies = 1000000 \/ HZ;"},{"entry":"\u2003\u2003\u2003\u2002register ULONG j_usec;"},{"entry":"\u2003\u2003\u2003\u2002i = ifindex;"},{"entry":"\u2003\u2003\u2003\u2003last_usec = (ifp_delay_table[i].tv_sec * 1000000) +"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003ifp_delay_table[i].tv_usec;"},{"entry":"\u2003\u2003\u2003\u2003curr_usec = (stamp->tv_sec * 1000000) + stamp-"},{"entry":">tv_usec;"},{"entry":"\u2003\u2003\u2003\u2002if (curr_usec > last_usec)"},{"entry":"\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003usec = curr_usec \u2212 last usec;"},{"entry":"\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003printk(\u201clast-%lld curr-%lld usec-%lld\\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002last_usec, curr_usec, usec);"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2002while (usec >= 1000000)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003usec \u2212= 1000000;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002sec++;"},{"entry":"\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003printk(\u201csec-%u usec-%lld\\n\u201d, (unsigned) sec, usec);"},{"entry":"\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003if (sec)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (pi_sleep(sec))"},{"entry":"\u2003\u2003\u2003\u2003\u2003goto end_timeout;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003if ((usec) && (usec < 1000000))"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2002j_usec = (ULONG)usec;"},{"entry":"\u2003\u2003\u2003\u2003\u2002schedule_timeout(j_usec \/ usec_per_jiffies);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003end_timeout:;"},{"entry":"\u2003\u2003\u2003ifp_delay_table[ifindex].tv_sec = stamp->tv_sec;"},{"entry":"\u2003\u2003\u2003ifp_delay_table[ifindex].tv_usec = stamp->tv_usec;"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003length = (flags & MSG_TRUNC) ? length : copied;"},{"entry":"\u2003\u2003\u2002return length;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002return 0;"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Virtual network interface mappings also employ an include\/exclude mask of port\/protocol filters that is configured via a separate IOCTL call and maps a bit table of include\/exclude ports to a particular virtual network interface.  depicts the use of a filter table to include or exclude packet data from a slot cache element. The algorithm that supports this will filter those network packets that do not match the search criteria from the sys_recvmsg socket based packet stream that is returned to user space applications. This allows virtual interfaces to be configured to return only packets that meet pre-determined port criteria, which is useful for those applications that may only need to analyze HTTP (web traffic). The actual implementation requires pre-defined bit tables to be created in user space by a system administrator, then these tables are copied into the DSFS slot cache store and associated with a particular virtual interface adapter. Packets that do not meet the filer parameters are skipped in the store and not returned to user space.","The algorithm that performs the filtering of network packets from open slot chains is more fully described as:",{"@attributes":{"id":"p-0228","num":"0232"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003int int_bitmap_match(SLOT_BUFFER_HEADER *slot,"},{"entry":"READ_ELEMENT_HEADER *element,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BITMAP *bitmap)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003register int ip_hdr_len, s, d;"},{"entry":"\u2003\u2003\u2003\u2003unsigned char *data;"},{"entry":"\u2003\u2003\u2003\u2003struct iphdr *ip;"},{"entry":"\u2003\u2003\u2003\u2003struct tcphdr *tcp;"},{"entry":"\u2003\u2003\u2003\u2003struct udphdr *udp;"},{"entry":"\u2003\u2003\u2003\u2003register int ie_ret = 1;"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003P_Print(\u201cbitmap %08X\\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(unsigned)bitmap);"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003if (!bitmap || !bitmap->ie_flag)"},{"entry":"\u2003\u2003\u2003\u2003\u2003return 1;"},{"entry":"\u2003\u2003\u2003\u2003switch (bitmap->ie_flag & IE_MASK)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003case 0: \/\/ exclude"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002P_Print(\u201cexclude set\\n\u201d);"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002ie_ret = 1;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003case 1: \/\/ include"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002P_Print(\u201cinclude set\\n\u201d);"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002ie_ret = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003default:"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002P_Print(\u201cdefault set\\n\u201d);"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002ie_ret = 1;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002break;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003data = (BYTE *)((ULONG)element +"},{"entry":"sizeof(ELEMENT_HEADER));"},{"entry":"\u2003\u2003\u2003\u2003switch (slot->b->dev_type)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\/\/ Ethernet device"},{"entry":"\u2003\u2003\u2003\u2003\u2003case 0:"},{"entry":"\u2003\u2003\u2003\u2003\u2003case ARPHRD_ETHER:"},{"entry":"\u2003\u2002\u2003\u2003\u2003case ARPHRD_LOOPBACK:"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003P_Print(\u201cETHER dev_type %X protocol-%X ie_ret %d\\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2009(unsigned)slot->b->dev_type,(unsigned)ntohs(element-"},{"entry":">protocol),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2009(int)ie_ret);"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003switch (ntohs(element->protocol))"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002case ETH_P_802_3:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002case ETH_P_802_2:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002\/\/ Ethernet II, IP"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002case ETH_P_IP:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ip = (struct iphdr *)((ULONG)data + sizeof(struct ethhdr));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ip_hdr_len = ip->ihl * 4;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003switch (ip->protocol)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002case IPPROTO_TCP:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003tcp = (struct tcphdr *)((ULONG)ip + ip_hdr_len);"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003P_Print(\u201cTCP source %d dest %d \\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002(int)ntohs(tcp->source), (int)ntohs(tcp->dest));"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (bitmap->ie_flag & SOURCE_MASK)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002s = ntohs(tcp->source);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (bitmap->bitmap[s >> 3] & (1 << (s & 7)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003P_Print(\u201chit TCP source %d dest %d ret-%d\\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002(int)ntohs(tcp->source), (int)ntohs(tcp->dest),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003((bitmap->ie_flag & IE_MASK) ? 1 : 0));"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ((bitmap->ie_flag & IE_MASK) ? 1 : 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (bitmap->ie_flag & DEST_MASK)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002d = ntohs(tcp->dest);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (bitmap->bitmap[d >> 3] & (1 << (d & 7)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003P_Print(\u201chit TCP source %d dest %d ret-%d\\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002(int)ntohs(tcp->source), (int)ntohs(tcp->dest),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003((bitmap->ie_flag & IE_MASK) ? 1 : 0));"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ((bitmap->ie_flag & IE_MASK) ? 1 : 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002case IPPROTO_UDP:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003udp = (struct udphdr *)((ULONG)ip + ip_hdr_len);"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003P_Print(\u201cUDP source %d dest %d \\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002(int)ntohs(udp->source), (int)ntohs(udp->dest));"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (bitmap->ie_flag & SOURCE_MASK)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002s = ntohs(udp->source);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (bitmap->bitmap[s >> 3] & (1 << (s & 7)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003P_Print(\u201chit UDP source %d dest %d ret-%d\\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002(int)ntohs(udp->source), (int)ntohs(udp->dest),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003((bitmap->ie_flag & IE_MASK) ? 1 : 0));"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ((bitmap->ie_flag & IE_MASK) ? 1 : 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (bitmap->ie_flag & DEST_MASK)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002d = ntohs(udp->dest);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (bitmap->bitmap[d >> 3] & (1 << (d & 7)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003P_Print(\u201chit UDP source %d dest %d ret-%d\\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002(int)ntohs(udp->source), (int)ntohs(udp->dest),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003((bitmap->ie_flag & IE_MASK) ? 1 : 0));"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ((bitmap->ie_flag & IE_MASK) ? 1 : 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002default:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Raw IP"},{"entry":"\u2003\u2003\u2003\u2003case ARPHRD_PPP:"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003P_Print(\u201cPPP dev_type %X protocol-%X ie_ret %d\\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2009(unsigned)slot->b->dev_type, (unsigned)ntohs(element-"},{"entry":">protocol),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2009(int)ie_ret);"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (ntohs(element->protocol) != ETH_P_IP)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2003ip = (struct iphdr *)data;"},{"entry":"\u2003\u2003\u2003\u2003\u2003ip_hdr_len = ip->ihl * 4;"},{"entry":"\u2003\u2003\u2003\u2003\u2003switch (ip->protocol)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002case IPPROTO_TCP:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003tcp = (struct tcphdr *)((ULONG)ip + ip_hdr_len);"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003P_Print(\u201cTCP source %d dest %d \\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002(int)ntohs(tcp->source), (int)ntohs(tcp->dest));"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (bitmap->ie_flag & SOURCE_MASK)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002s = ntohs(tcp->source);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (bitmap->bitmap[s >> 3] & (1 << (s & 7)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ((bitmap->ie_flag & IE_MASK) ? 1 : 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (bitmap->ie_flag & DEST_MASK)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002d = ntohs(tcp->dest);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (bitmap->bitmap[d >> 3] & (1 << (d & 7)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ((bitmap->ie_flag & IE_MASK) ? 1 : 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002case IPPROTO_UDP:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003udp = (struct udphdr *)((ULONG)ip + ip_hdr_len);"},{"entry":"\u2003\u2003\u2003#if VERBOSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003P_Print(\u201cUDP source %d dest %d \\n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(int)udp->source, (int)udp->dest);"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (bitmap->ie_flag & SOURCE_MASK)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002s = ntohs(udp->source);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (bitmap->bitmap[s >> 3] & (1 << (s & 7)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ((bitmap->ie_flag & IE_MASK) ? 1 : 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (bitmap->ie_flag & DEST_MASK)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002d = ntohs(udp->dest);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002if (bitmap->bitmap[d >> 3] & (1 << (d & 7)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ((bitmap->ie_flag & IE_MASK) ? 1 : 0);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002default:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003\u2002default:"},{"entry":"\u2003\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003return ie_ret;"},{"entry":"\u2003\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Virtual network interfaces can also be used to regenerate captured network traffic onto physical network segments for playback to downstream IDS appliances and network troubleshooting consoles.  depicts a Virtual Interface mapped to a specific shot chain. Virtual Network interfaces also can employ a filter bit table during regeneration to filter out network packets that do not conform with specific include\/exclude mask criteria. Virtual Network interfaces can be configured to regenerate network traffic at full physical network line rates or at the rates and UTC\/microsecond timing the network packets were captured. Time replay virtual network interfaces (ift#) are employed to replay captured traffic to downstream devices that need to receive traffic at the original capture timing. Raw Virtual Network Interfaces (ifp#) will replay captured and filtered content at the full line supported by the physical interface.","When a virtual interface encounters end of stream (0xFFFFFFFF) the call will block on an interruptible system semaphore until more packets are received at the end of the slot chain. Captured network traffic can be regenerated from multiple virtual network interfaces onto a single physical network interface, and filters may also be employed. This implementation allows infinite capture of network traffic and concurrent playback to downstream IDS appliances and support for real-time user space applications monitoring of captured network data.","Regeneration creates a unique process for each regenerated virtual network interface to physical interface session. This process reads from the virtual network device and outputs the data to the physical interface upon each return from a request to read a slot chain. A P_HANDLE context is maintained for each unique regeneration session with a unique view into the captured slot chain being read.","The regeneration process con be configured to limit data output on a physical segment in 1 mb\/s (megabit per second) increments. The current embodiment of the invention allows these increments to span 1-10000 mb\/s configurable per regeneration thread.","Regeneration steps consist of mapping a P_HANDLE context to a virtual interface adapter and reading packets from an active slot chain until the interface reaches the end of the slot chain and blocks until more packet traffic arrives. As the packets are read from the slot chain, they are formatted into system dependent transmission units (skb's on Linux) and queued for transmission on a target physical network interface.","The regeneration algorithm meters the total bytes transmitted over a target physical interface relative to the defined value for maximum bytes per second set by the user space application that initiated a regeneration process. The current embodiment of packet and protocol regeneration is instrumented as a polled method rather than event driven method.","The regeneration algorithm is more fully described as:",{"@attributes":{"id":"p-0236","num":"0240"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003int regen_data(void *arg)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003register ULONG pindex;"},{"entry":"\u2003\u2003\u2003\u2003struct sk_buff *skb;"},{"entry":"\u2003\u2003\u2003\u2003long long size;"},{"entry":"\u2003\u2003\u2003\u2003int err, skb_len, tx_queue_len;"},{"entry":"\u2003\u2003\u2003\u2003ULONG length = 0;"},{"entry":"\u2003\u2003\u2003\u2003VIRTUAL_SETUP *v = (VIRTUAL_SETUP *)arg;"},{"entry":"\u2003\u2003\u2003\u2003P_HANDLE *p_handle;"},{"entry":"\u2003\u2003\u2003\u2003register ULONG s_pindex, s_index, s_offset, s_turbo_slot,"},{"entry":"s_turbo_index;"},{"entry":"\u2003\u2003\u2003\u2003long long s_turbo_offset;"},{"entry":"\u2003\u2003\u2003\u2003struct net_device *dev;"},{"entry":"\u2003\u2003\u2003#if LINUX_26"},{"entry":"\u2003\u2003\u2003\u2003daemonize(\u201cif_regen%d\u201d, (int)v->pid);"},{"entry":"\u2003\u2003\u2003#else"},{"entry":"\u2003\u2003\u2003\u2003sprintf(current->comm, \u201cif_regen%d\u201d, (int)v->pid);"},{"entry":"\u2003\u2003\u2003\u2003daemonize( );"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003regen_active++;"},{"entry":"\u2003\u2003\u2003\u2003v->active++;"},{"entry":"\u2003\u2003\u2003\u2003dev = dev_get_by_index(v->pindex);"},{"entry":"\u2003\u2003\u2003\u2003if (!dev)"},{"entry":"\u2003\u2003\u2003\u2003\u2002return 0;"},{"entry":"\u2003\u2003\u2003\u2003tx_queue_len = dev->tx_queue_len;"},{"entry":"\u2003\u2003\u2003\u2003dev->tx_queue_len = 60000;"},{"entry":"\u2003\u2003\u2003\u2003dev_put(dev);"},{"entry":"\u2003\u2003\u2003\u2003while (v->ctl)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003retry:;"},{"entry":"\u2003\u2003\u2003\u2003\u2002if (v->interval)"},{"entry":"\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003#if LINUX_26"},{"entry":"\u2003\u2003\u2003\u2003\u2003v->currtime = CURRENT_TIME.tv_sec;"},{"entry":"\u2003\u2003\u2003#else"},{"entry":"\u2003\u2003\u2003\u2003\u2003v->currtime = CURRENT_TIME;"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (v->lasttime == v->currtime)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002if (v->totalbytes >= (v->interval * (1000000 \/ 8)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003pi_sleep(1);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003goto retry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (kill_regen)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003skb = create_xmit_packet(v->pindex, &err, &skb_len);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (!skb)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003switch (err)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003case -ENXIO:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->retry_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->interface_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto retry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003case -ENETDOWN:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->interface_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->retry_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto retry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003case -EMSGSIZE:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->size_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->retry_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto retry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003case -EINVAL:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->fault_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->retry_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto retry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003case -ENOBUFS:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->no_buffer_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->retry_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto retry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003default:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009v->fault_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009v->retry_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto retry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003read_again:;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if ((kill_regen) || (!v->ctl))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002release_skb(skb);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003p_handle = v->p_handle;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (!p_handle)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003release_skb(skb);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003s_pindex = p_handle->pindex;"},{"entry":"\u2003\u2003\u2003\u2003\u2003s_index = p_handle->index;"},{"entry":"\u2003\u2003\u2003\u2003\u2003s_offset = p_handle->offset;"},{"entry":"\u2003\u2003\u2003\u2003\u2003s_turbo_slot = p_handle->turbo_slot;"},{"entry":"\u2003\u2003\u2003\u2003\u2003s_turbo_index = p_handle->turbo_index;"},{"entry":"\u2003\u2003\u2003\u2003\u2003s_turbo_offset = p_handle->turbo_offset;"},{"entry":"\u2003\u2003\u2003\u2003\u2003pindex = regen_chain_packet(v->interface, skb, skb_len,"},{"entry":"p_handle,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&length, NULL, NULL,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&p_handle->start, &p_handle->end,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (pindex == -ENOENT)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003release_skb(skb);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (pindex == 0xFFFFFFFF)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto read_again;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003release_skb(skb);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (!length)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto read_again;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003release_skb(skb);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003size = skb->len;"},{"entry":"\u2003\u2003\u2003\u2003\u2003err = xmit_packet(skb);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (err)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003p_handle->pindex = s_pindex;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003p_handle->index = s_index;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003p_handle->offset = s_offset;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003p_handle->turbo_slot = s_turbo_slot;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003p_handle->turbo_index = s_turbo_index;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003p_handle->turbo_offset = s_turbo_offset;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003v->retry_errors++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (!pm_sleep(VIRTUAL_SLEEP))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003goto retry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003goto exit_process;"},{"entry":"\u2003\u2003\u2003\/\/ \u2003\u2003\u2003v->packets_aborted++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003v->bytes_xmit += size;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003v->packets_xmit++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (v->interval)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003#if LINUX_26"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003v->currtime = CURRENT_TIME.tv_sec;"},{"entry":"\u2003\u2003\u2003#else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003v->currtime = CURRENT_TIME;"},{"entry":"\u2003\u2003\u2003#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (v->lasttime != v->currtime)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003v->totalbytes = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003v->totalbytes += size;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003v->lasttime = v->currtime;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003exit_process:;"},{"entry":"\u2003\u2003\u2003\u2003dev = dev_get_by_index(v->pindex);"},{"entry":"\u2003\u2003\u2003\u2003if (!dev)"},{"entry":"\u2003\u2003\u2003\u2003\u2003return 0;"},{"entry":"\u2003\u2003\u2003\u2003dev->tx_queue_len = tx_queue_len;"},{"entry":"\u2003\u2003\u2003\u2003dev_put(dev);"},{"entry":"\u2003\u2003\u2003\u2003v->active\u2212\u2212;"},{"entry":"\u2003\u2003\u2003\u2003regen_active\u2212\u2212;"},{"entry":"\u2003\u2003\u2003\u2003return 0;"},{"entry":"\u2003\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"figref":"FIG. 37"},"This architecture allows days, week, months, or even years of network packet data to be archived and indexed for off line post analysis operations, auditing, and network transaction accounting purposes.","Primary Capture partitions contain a table of mapped archive partitions that may be used to allocate slot storage. As slots are allocated and pinned by adapters and subsequently filled, if a particular primary storage partition has an associated map of archive storage partitions, the primary capture partitions creates dual I\/O links into the archive storage and initiates a mirrored write of a particular slot to both the primary capture partition and the archive storage partition in tandem. Slot chains located on archive storage partitions only export two primary slot chains. The VFS dynamic presents the slots in a replica chain (chain 0) and an archive chain (1).","As slots are allocated from an Archive Storage partition, they are linked into the replica partition. Originating interface name, MAC address, and machine host name are also annotated in the additional tables present on a type 0x98 partition to identify the source name of the machine and interface information relative to a particular slot. Altering the attributes by setting an slot to read-only on an archive partition moves the slot from the replica slot chain (0) to the permanent archive slot chain (1). Slot allocation for selection of eligible targets for slot recycle on archive storage partitions is always biased to use the replica chain for slot reclamation. Slots stored on the archive slot chain (1) are only recycled if all slots in a given archive storage partition replica chain (0) have been converted to entries on the archive slot chain (1). In both cases, the oldest slots are targeted for recycle when an archive storage partition becomes fully populated. This allows forensic investigators the ability to pin specific slots of interest in an archive chain for permanent archival.",{"@attributes":{"id":"p-0240","num":"0244"},"figref":"FIG. 38"},"In the event a storage array has been taken off line temporarily, the slot bitmap table records a value of 0 for any slots that have not been mirrored due to system unavailability, and a background re-mirroring process is spawned when the off line storage becomes active and re-mirrors the slot cache elements onto the target archive storage partitions with a background process. The system can also be configured to simply drop captured slots on the primary capture partition and not attempt mirroring of slots lost during an off line storage event for a group of archive partitions.","To avoid elevator starvation cases for sector ordering during re-mirroring, slots may be re-mirrored backwards as a performance optimization starting at the bottom of a primary capture partition rather than at the beginning to prevent excessive indexing at the block I\/O layer of the operating system of coalesced read and write sector run requests.",{"@attributes":{"id":"p-0243","num":"0247"},"figref":"FIG. 39"},"Off line indexing is supported by tagging each captured packet with a globally unique identifier that allows rapid searching and retrieval on a per packet basis of capture network packets.  depicts the method for tagging captured packets. These indexes are built during capture and combine the source MAC address of the capturing network adapter, the slot address and packet index within a slot, and protocol and layer 3 address information. These indexes are exposed through the \/index subdirectory in the virtual file system per slot and are stored in 64K allocation clusters that are chained from the Slot Header located in the slot cache element.","Off line indexes allow external applications to import indexing information for captured network traffic into off line databases and allow rapid search and retrieval of captured network packets through user space P_HANDLE context pointers. The globally unique identifier is guaranteed to be unique since it incorporates the unique MAC address of the network adapter that captured the packet payload. The global packet identifier also stores Ipv4 and Ipv6 address information per packet and supports Ipv4 and Ipv6 indexing."],"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other features and advantages of the present invention will be apparent from reference to a specific embodiment of the invention as presented in the following Detailed Description taken in conjunction with the accompanying Drawings, in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 40"}]},"DETDESC":[{},{}]}
