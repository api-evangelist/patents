---
title: Migrating code from a source format to a target format
abstract: Source code is automatically migrated from a source format to a target format. In particular, the execution of the source code is dynamically analyzed for incompatibilities using runtime information. Solutions for the incompatibilities are additionally determined. Based on the identified incompatibilities and solutions, the source code is converted from the source format to the target format.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09052966&OS=09052966&RS=09052966
owner: GOOGLE INC.
number: 09052966
owner_city: Mountain View
owner_country: US
publication_date: 20111202
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of Disclosure","This invention relates generally to computer programming, and particularly to migrating source code from one format to another.","2. Description of the Related Art","In computer programming, the migration of source code from one format to another is a common occurrence. For example, a given programming language may be updated from an initial version to a later version. The later version may include different operations, object data types, etc. As a result, to make source code written in the initial version compatible with the later version, modification of the source code may be required.","One technique for migrating source code involves using static analysis i.e., migrating the source code without executing the code. While such a technique normally is able to handle syntactic differences (i.e., differences in code formatting), it is not able to effectively handle semantic differences (i.e., differences in code behavior). More specifically, because information critical to code behavior (e.g., object data type information) is frequently not determined until source code execution or runtime, the technique is often unable to properly migrate code. As a result, code migrated using the technique must often be manually corrected, which can cause the code migration process to be tedious and time consuming for developers.","The above and other issues are addressed by a method, a non-transitory computer-readable storage medium, and a system for migrating source code.","Embodiments of the method include executing source code in an environment compatible with a source format. During execution of the source code, an analysis is performed on runtime information associated with the execution of the source code in the environment compatible with the source format. Responsive to the analyzed runtime information, an incompatibility in the source code with respect to a target format is identified. A solution is then determined for the incompatibility by performing a lookup in a data structure containing one or more solutions. The solution enables the source code to be made compatible with the target format. The source code is thereafter converted from the source format to the target format based at least in part on the solution.","Embodiments of the computer-readable storage medium store computer-executable instructions for performing the steps described above. Embodiments of the system further include a processor for executing the computer-executable instructions.","The features and advantages described in this disclosure and in the following detailed description are not all-inclusive, and particularly, many additional features and advantages will be apparent to one of ordinary skill in the relevant art in view of the drawings, specification, and claims hereof. Moreover, it should be noted that the language used in the specification has been principally selected for readability and instructional purposes, and may not have been selected to delineate or circumscribe the inventive subject matter, resort to the claims being necessary to determine such inventive subject matter.","The Figures (FIGS.) and the following description describe certain embodiments by way of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein. Reference will now be made in detail to several embodiments, examples of which are illustrated in the accompanying figures. It is noted that wherever practicable similar or like reference numbers may be used in the figures and may indicate similar or like functionality.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","100","100","105","120","130","105","120","105","120"]},"The network  enables communications between the development client  and the development server . In one embodiment, the network  uses standard communications technologies and\/or protocols. Thus, the network  can include links using technologies such as Ethernet, 802.11, worldwide interoperability for microwave access (WiMAX), 3G, digital subscriber line (DSL), asynchronous transfer mode (ATM), InfiniBand, PCI Express Advanced Switching, etc. Similarly, the networking protocols used on the network  can include multiprotocol label switching (MPLS), the transmission control protocol\/Internet protocol (TCP\/IP), the User Datagram Protocol (UDP), the hypertext transport protocol (HTTP), the simple mail transfer protocol (SMTP), the file transfer protocol (FTP), etc. The data exchanged over the network  can be represented using technologies and\/or formats including the hypertext markup language (HTML), the extensible markup language (XML), etc. In addition, all or some of links can be encrypted using conventional encryption technologies such as secure sockets layer (SSL), transport layer security (TLS), virtual private networks (VPNs), Internet Protocol security (IPsec), etc. In another embodiment, the entities can use custom and\/or dedicated data communications technologies instead of, or in addition to, the ones described above. Depending upon the embodiment, the network  can also include links to other networks such as the Internet.","The development server  stores source code to be migrated from a source format to a target format. In one embodiment, the development server  includes a code repository  that stores data such as source code, compiled code, software libraries, and\/or the like. The development server  communicates with the development client  by exchanging data via the network . In particular, the development server  can receive requests, via the network , from the development client  to retrieve data from the code repository . For example, the development client  can request an item of source code be retrieved from the code repository . As used herein, an item of source code can be the source code comprising a data file or a number of data files, a subset of the source code comprising a data file or a number of data files, etc. The development server  can additionally receive data, via the network , from the development client  and store the data in the code repository . For example, the development server  can receive an item of source code generated by the development client  and store the source code in the code repository .","The development client  is an electronic device used by a developer to migrate source code from a source format to a target format. In one embodiment, the development client  is a conventional computer system executing, for example, a MICROSOFT WINDOWS compatible operating system (OS), APPLE OS X, UNIX, and\/or a LINUX distribution. The development client  can be any type of computer system, such as a laptop, desktop, workstation, or server. The development client  can also be another device having computer functionality, such as a personal digital assistant (PDA), mobile telephone, tablet device, etc.","As shown, the development client  includes a migration module  and a local store . The local store  generally stores data used by the migration module . For example, the data stored on local store  can include an item of source code received by the development client  from the development server . The local store  can additionally store source code and\/or other data generated by the migration module . For example, the local store  can store a migration data file . The migration data file  can include information usable for migrating source code. In one embodiment, the migration data file  can include a table of entries or records. Each entry can include an identified incompatibility for an item of source code, the location of where the incompatibility occurs in the item of source code, and a corresponding solution to the incompatibility. For example, an entry in the migration data file  can include a line of incompatible code, a specific line number in the source code where the incompatible code is located, and a corresponding line of compatible code (i.e., a solution).","The migration module  migrates an item of source code from the source format to the target format. A format can include or be a programming language, a version of a programming language, an application programming interface (API), a version of an API, etc. For example, the migration module  can migrate an item of source code compatible with version 2.0 of the PYTHON programming language into an item of source code compatible with version 3.0 of the same language.","In one aspect, the migration module  performs a dynamic analysis of an execution of the source code item in an environment compatible with the source format. As part of this execution, the migration module  uses information that would not otherwise be available during a static analysis of the code in order to identify portions of the code in the source format that are incompatible with the target format. Based on this analysis, the migration module  converts the item of source code to the target format. As a result, the migration module  can more accurately migrate source code from the source format to the target format than would be possible using only a static analysis of the code.","For example, assume that a developer has developed an item of source code in version 2.0 of the PYTHON programming language. Illustratively, the item of source code can be as follows:\n\n","In this sample item of source code, line 1 defines a function foo that accepts an argument \u201cd\u201d. Assume that the argument \u201cd\u201d is intended to be an object having a dictionary data type. It should be appreciated, however, that because the PYTHON programming language is dynamic, the data type for \u201cd\u201d is not resolved until runtime. Line 2 includes code for selecting the items of the argument \u201cd\u201d (via the d.items( ) call). Such a selection, when performed on a dictionary object, results in the creation of a list object. Line 2 additionally includes code for slicing the list object (via the slicing shorthand [1:]). Line 2 further includes code for returning the resulting sliced list object (via the return call).","Assume, at a later time, that the developer wishes to migrate the sample source code from version 2.0 to version 3.0 of the PYTHON programming language. Under version 3.0 of the language, selecting the items of a dictionary object no longer returns an object that supports slicing. More specifically, selecting the items of the argument \u201cd\u201d using the d.items( ) call no longer results in an object of a list data type. As such, performing the slice function in the sample code above would cause an error.","In migrating the sample source code to version 3.0 of the PYTHON programming language, a static analysis of the source code would be unable to identify and correct the issue highlighted above. In particular, because the dictionary data type of the argument \u201cd\u201d is not resolved until runtime, the static analysis technique would not have the information necessary to determine that the source code performs a slicing operation on an unsupported data type. As such, the source code would not be modified to accordingly address the issue. In contrast, the development client , through first executing and analyzing an item of source code, enables the item of source code to be properly migrated, as will be described in greater detail below.","In one embodiment, the environment  is not a networked environment. More specifically, the environment  may not include the development server  and\/or the network . In such an embodiment, the development client  may locally migrate source code from a source format to a target format without interacting with a development server. For example, an item of source code can be retrieved locally from the local store  by the development client  and migrated to a target format. The migrated source code can thereafter be stored locally on the local store .",{"@attributes":{"id":"p-0029","num":"0030"},"figref":"FIG. 2","b":["200","105","120","202","204","204","206","208","210","212","214","216","218","212","204","220","222","206","202","204"]},"The storage device  is a non-transitory computer-readable storage medium, such as a hard drive, compact disk read-only memory (CD-ROM), DVD, or a solid-state memory device. The memory  holds instructions and data used by the processor . The pointing device  may be a mouse, track ball, or other type of pointing device, and is used in combination with the keyboard  to input data into the computer system . The graphics adapter  displays images and other information on the display . The network adapter  couples the computer system  to the network .","As is known in the art, a computer  can have different and\/or other components than those shown in . In addition, the computer  can lack certain illustrated components. In one embodiment, a computer  acting as the development server  is formed of multiple blade computers and lacks a keyboard , pointing device , graphics adapter , and\/or display . Moreover, the storage device  can be local and\/or remote from the computer  (such as embodied within a storage area network (SAN)).","As is known in the art, the computer  is adapted to execute computer program modules for providing functionality described herein. As used herein, the term \u201cmodule\u201d refers to computer program logic utilized to provide the specified functionality. Thus, a module can be implemented in hardware, firmware, and\/or software. In one embodiment, program modules are stored on the storage device , loaded into the memory , and executed by the processor .","Embodiments of the entities described herein can include other and\/or different modules than the ones described here. In addition, the functionality attributed to the modules can be performed by other or different modules in other embodiments. Moreover, this description occasionally omits the term \u201cmodule\u201d for purposes of clarity and convenience.",{"@attributes":{"id":"p-0034","num":"0035"},"figref":"FIG. 3","b":["110","110"]},"The migration module  includes modules for performing various functions. These modules include a compatibility rules module , an analysis module , a conversion module , and a verification module . The modules , , , and  include functionality corresponding to the functionality invoked on the development client  when migrating code, such as the sample source code described above.","At the highest level, the compatibility rules module  stores rules usable for migrating source code from a source format to a target format. In one embodiment, the compatibility rules module  may support the migration of source code from a variety of different source formats to a variety of different target formats. For example, the compatibility rules module  can include rules that enable an item of source code to be converted from PYTHON version 2.0 to PYTHON version 3.0, from PHYTHON version 3.0 to PYTHON version 2.0, from PHP to PYTHON version 3.0, etc.","The rules stored in the compatibility rules module  can be created in any suitable manner. In one embodiment, the rules are created by encoding expert knowledge supplied by a human user. The expert knowledge can be supplied by the human user via an input device (e.g., a keyboard and\/or mouse) attached to the development client . The expert knowledge can alternatively be supplied by the human user at a computing device different from the development client . After creating the rules through encoding the expert knowledge, the other computing device can send the rules to the development client  via the network .","In one embodiment, the compatibility rules module  includes rules usable for identifying incompatibilities (e.g., semantic incompatibilities) in an item of source code, where the item of source code is to be migrated from a source format to a target format. For instance, the compatibility rules module  can include a table of rules specifying the objects, functions, methods, operations, and\/or the like that are incompatible between two different formats. For example, the compatibility rules module  can include a rule indicating that under PYTHON version 3.0, a slicing operation cannot be performed on the result of an item selection of a dictionary object (i.e., the d.items( ) call in the sample code above).","The compatibility rules module  additionally includes data usable for determining a solution to an identified incompatibility. For instance, the data can include information regarding the manner in which an incompatible usage of a data object can be converted into a compatible usage. Illustratively, the compatibility rules module  can include information indicating how an object can be converted, under version 3.0 of the PYTHON programming language, to support a slicing operation.","The analysis module  analyzes the execution of an item of source code to dynamically identify incompatibilities and corresponding solutions. In one aspect, the identified incompatibilities may be incompatibilities relating to the semantics or syntax of the source code with respect to the target format. In one embodiment, the analysis module  executes an item of source code in an environment compatible with the source format. For example, an item of source code may be written in version 2.0 of the PYTHON programming language. As a result, the analysis module  executes the item of source code in an environment compatible with version 2.0 of the language. In one embodiment, the analysis module  may include an interpreter that executes the source code in the environment compatible with the source format.","Execution of the source code can be facilitated by applying one or more unit tests to individual units of the source code. As used herein, a unit of source code can refer to a testable part of the source code. For example, a unit may be an individual function, procedure, or interface of the source code. During each unit test, various inputs designed to ensure that the source code executes correctly for an environment compatible with the source format under a variety of different conditions can be provided. For instance, a unit test can make a number of calls to functions within the source code and pass a variety of different arguments to the functions. The unit test can additionally verify that any returned results are correct. For example, referring to the sample code above, a unit test may call the function foo and pass a dictionary object as the argument \u201cd\u201d. The unit test may further verify that a list object is returned by the foo function. In practice, unit tests are often created during the initial development of an item of source code. As such, many source code items already have associated unit tests. These same unit tests can be reused by the analysis module  to aid in the migration of the source code items.","In one embodiment, the source code may not include a semantic or syntactic incompatibility with respect to the source format. More specifically, the source code may be written such that the code's structure and behavior is compatible with the source format. As a result, when tested using unit tests in an environment for the source format, an incompatibility with respect to the source format is not identified. In such an embodiment, the source code may be executed successfully. It should be appreciated, however, that the source code may still include logic errors or other similar bugs unrelated to the semantics or syntax of the code.","In one embodiment, while a unit test is being performed, the analysis module  analyzes runtime information associated with the execution of the item of source code. Responsive to the analyzed runtime information, the analysis module  identifies incompatibilities in the source code with respect to a target format. More specifically, the analysis module  can include instrumentation usable to monitor the behavior of the source code during a unit test. As the source code is executed during a unit test, the analysis module  uses the instrumentation to track runtime information for the source code, such as object data types, variable values, runtime metadata, etc. The analysis module  additionally uses the instrumentation to monitor for certain types of code behavior. For instance, the analysis module  can use the instrumentation to identify when an object is returned and\/or a function, method, or operation is called. Each time the analysis module  identifies such code behavior, the module  performs a check to determine whether the behavior is compatible with the target format. In particular, the analysis module  can reference the rules provided by the compatibility rules module  and the tracked runtime information to determine the compatibility of the behavior with the target format. For example, a line in an item of source code may include a function that is called on a particular object. While the line is being executed, the analysis module  performs a check and identifies the data type of the object. The analysis module  can then reference the rules provided by the compatibility rules module  to determine whether the function called on the object is valid for the identified data type for the target format.","In the embodiment, the identification of incompatibilities in the source code with respect to the target format is performed concurrently with the identification of incompatibilities for the source code in the source format. In one embodiment, an incompatibility for the target format may be determined to exist if, for a given statement of code, an incompatibility (e.g., a semantic incompatibility) is identified for the target format, but not for the source format.","In one embodiment, the analysis module , responsive to identification of an incompatibility for the target format, references the data included in the compatibility rules module  to determine a corresponding solution. In one embodiment, the analysis module  can perform a lookup in a data structure (e.g., a table, etc.) of the compatibility rules module  for the corresponding solution. The solution can enable the item of source code to be made compatible with the target format. The solution can be an exact solution for the incompatibility (e.g., a specific line or lines of converted code) or a general solution (e.g., a general instruction indicating how to correct the incompatibility).","The analysis module  further records any identified incompatibility, the location of the incompatibility, and the determined solution for the incompatibility to the migration data file . Following execution of the source code, the analysis module  stores the migration data file  in the local store  and\/or sends the file to the development server  for storage in the code repository . The migration data file  can be later accessed by the conversion module .","As an example, the analysis module  can perform unit testing on the sample source code described above using PYTHON version 2.0. As the sample source code is being executed, the analysis module  performs checks for incompatibilities based on the rules provided by the compatibility rules module . The rules can be those specific to migrating code from PYTHON version 2.0 to PYTHON version 3.0. At line 2 of the sample source code, the analysis module  determines that \u201cd\u201d is a dictionary object. Based on this determination, the analysis module  determines that the d.items( ) call in the code results in a non-list object under version 3.0 of the PYTHON programming language while the slicing function (i.e., [1:]) called on the non-list object in fact requires a list object. Upon making such a determination, the analysis module  records the incompatibility to a table in the migration data file . The analysis module  additionally determines and records a solution to the incompatibility in the migration data file . The resulting table entry can appear as the following:",{"@attributes":{"id":"p-0048","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Location","Incompatibility","Solution"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Line 2","d. items ( ) [1:]","list (d. items ( ) ) [1:]"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The conversion module  converts an item of source code from a source format to a target format based at least in part on the solution determined by the analysis module . More specifically, the conversion module  converts the item of source code using the migration data file  generated by the analysis module . The migration data file  can be retrieved from the local store  and\/or the development server . In one aspect, the conversion module  performs, for each line in the item of source code, a lookup in the migration data file  for one or more entries that reference the line. For each located entry, the conversion module  identifies the incompatibility indicated by the entry and its corresponding solution. For example, upon reaching line 2 of the sample source code described above, the conversion module  performs a lookup in the migration data file  and locates an entry identifying that the d.items( ) [1:] call of line 2 is not compatible with version 3.0 of the PYTHON programming language. As a result, the conversion module  identifies the solution for the incompatibility and modifies the source code accordingly. In particular, the conversion module  replaces d.items( ) [1:] in the code with list (d.items( )) [1:]. In doing so, the object resulting from the d.items( ) call is converted to a list object, which enables the object to be sliced.","In one implementation, the migration data file  includes the exact solution for an incompatibility. As such, the conversion module  replaces incompatible code with the compatible code embodying the solution. In another implementation, the migration data file  includes a general solution. The general solution can indicate the manner in which the conversion module  can convert incompatible code to compatible code embodying the solution. For example, the migration data file  may include a solution indicating that the object resulting from a d.items( ) call must be converted to a list. Based on such an indication, the conversion module  determines the specific code needed to convert the object to have a list data type.","In one embodiment, the conversion module  can identify and resolve certain incompatibilities without referencing the migration data file . In particular, the conversion module  can include rules for identifying and resolving those incompatibilities that may be identified statically. For instance, the conversion module  can resolve incompatibilities relating to code structure. As an example, the conversion module  may convert the syntax of an item of source code to PYTHON version 3.0 without referencing the migration data file .","In one aspect, the conversion module  can record errors encountered during the conversion. For example, a solution for an incompatibility might not be included in the migration data file . As a result, the conversion module  may be unable to properly convert the incompatibility to code compatible with the target format. Responsive to such a situation, the conversion module  can record the error. In one embodiment, the recorded error can indicate the specific conversion problem, and optionally, the line where the problem occurred. In one aspect, recorded errors can be stored in the local store  and\/or sent to the development server  for storage in the code repository .","After performing the conversion process, the conversion module  outputs a migrated item of source code. In one aspect, the migrated item of source code can be stored in the local store  and\/or sent to the development server  for storage in the code repository . The migrated item of source code can be later accessed by the verification module . In one embodiment, the errors encountered during the conversion can be reported to the user in a listing of errors following the conversion process. In other embodiments, the errors encountered during the conversion can be reported following verification, as will be described below.","In one embodiment, the verification module  verifies a migrated item of source code. In particular, the verification module  can execute the migrated item of source code in an environment compatible with the target format. For example, an item of source code may have been migrated to version 3.0 of the PYTHON programming language. As such, the verification module  executes the migrated item of source code in an environment compatible with version 3.0 of the PYTHON programming language. In one embodiment, the verification module  may include an interpreter that executes the source code in the environment compatible with the target format. The migrated source code can be retrieved from the local store  and\/or the development server . In one aspect, the verification module  performs unit testing on the migrated item of source code. The unit tests can enable the verification module  to determine that the migrated code performs the correct behaviors (e.g., returns the correct values, performs the correct operations, etc.). In one embodiment, the verification module  generates and presents a report to a user that provides information regarding the migration. For example, the report can indicate the modifications made to the item of source code during the migration process. In one embodiment, he report additionally includes a listing of the errors recorded during the conversion process. The errors included in the list can be retrieved from the local store  and\/or the development server .",{"@attributes":{"id":"p-0055","num":"0056"},"figref":["FIG. 4","FIG. 4"],"b":["110","110","405","110","410","110","110","415","110","420","117"]},{"@attributes":{"id":"p-0056","num":"0057"},"figref":["FIG. 5","FIG. 5"],"b":["110","110","505","117","110","117","110","117","110","510","110","515","110","110","520","110","105","110","525","110","110","530","105"]},"The above description is included to illustrate the operation of certain embodiments and is not meant to limit the scope of the invention. The scope of the invention is to be limited only by the following claims. From the above discussion, many variations will be apparent to one skilled in the relevant art that would yet be encompassed by the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
