---
title: System and method for message handling using message interceptors
abstract: A system including an interception service that serves as a discovery mechanism and framework for carriers to connect to processors. The system allows for message handling using message interceptors, comprising one or more message carriers for receiving and handling messages; one or more message processors for processing messages; and an interception service that registers interception points in the message carriers for allowing message processors to access the message.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07606855&OS=07606855&RS=07606855
owner: Bea Systems, Inc.
number: 07606855
owner_city: Redwood Shores
owner_country: US
publication_date: 20050520
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","COPYRIGHT NOTICE","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority from provisional application entitled SYSTEM AND METHOD FOR MESSAGING HANDLING USING MESSAGE INTERCEPTORS, Application No. 60\/573,208, filed May 21, 2004, by Shean Chang, and incorporated herein by reference.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The invention is related generally to application servers and messaging systems, and specifically to a system and method for message handling using message interceptors.","In an application server environment, a message broker is a configurable intermediary that can process messages and make high-level decisions about how they should be handled. Message brokers support routing, filtering, transforming, duplicating and various other simple operations on messages. Message brokers are connected to normal processing paths by either being the explicit destination for a message or by intercepting messages intended for some other destination.","What is desirable is a means for taking responsibility off of the carriers and processors. One approach is to put a message broker interception code into the proper processing paths. However, a better approach would be to separate the notion of interception from the description of processing. The only existing standard that is similar to this is JAX-RPC handler chains. However, while JAX-RPC handler chains describe the processing of messages, they do not offer a flexible means of registering message carriers with message processors.","In accordance with an embodiment of the invention, an interception service serves as a discovery mechanism and framework for carriers to connect to processors. If desired, a separate feature can be built that implements handler chains on top of the interception service as a type of processor.","Interception is the insertion of processing code in the normal flow of control of a program. This inserted code is given the power to supersede the standard processing or to complement it. As described herein an interception service for message handling elements of the WebLogic Server (WLS) is described. Other types of application server may use and benefit from the feature. There are four goals driving this design: loose coupling, extensibility, dynamic manageability and minimality of performance impact.","In accordance with an embodiment, the system includes the Message Interception Service (interception service) as well as the framework that it provides to those who are making messages available to be intercepted (these are termed Message Carriers or, for convenience, carriers) and those who are processing these messages (termed Message Processors or, simply, processors).","The central premise guiding the feature is taking responsibility off of the carriers and processors. With that in mind, the guiding principles in defining the interception service are as follows: loose coupling between processors and carriers, extensibility to support new carriers or processors over time, manageability to support monitoring and configuration without special code in either and minimal performance impact, so that the carriers can continue to function without fear that enabling interception will cripple their performance.","The following is a brief definition of terms used throughout this document:","Carrier\u2014Software that has messages to be intercepted.","Interception Point\u2014The abstract notion of a place in the code where a carrier makes messages available to be intercepted.","Processor\u2014Software that processes intercepted messages.","Interception Service\u2014An administered service that associates processors with interception point.","Message broker\u2014An intermediary that gives administrative control to message routing and transformation.","JAX-RPC Handler\u2014A java interface. (javax.xml.rpc.handler.Handler) that describes message processing functions for SOAP","JAX-RPC Handler Chain\u2014Handlers are run in an ordered list, described by javax.xml.rpc.handler.HandlerChain.","Interception Service","The interception service is an administrable table of associations between interception points and processors. It is also a table of processor information. As such, the interception service provides a framework for the behavior of carriers and processors with respect to interception.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 1","FIG. 1"],"b":["100","108","110","112","114","116","118","106","104","104","120","124"]},"Interception Service Configurator","The interception service is designed to be administered through static method calls which add, remove and modify associations and processor information. While these calls can and should be made by various elements of the system, a part of the system is dedicated to storing interception service configuration information termed the Interception Service Configurator (ISC). The configuration information can be passed through dynamic deployment of modules. This specification will not discuss the use of modules at the present time; instead, the focus will be on what runtime and configuration information will be available.","Interception Service Functional Description","The interception service allows processors and interception points to be named and the administrator to choose which to connect to which.","In accordance with an embodiment there are seven operations provided by the interception service: Interception Point Description, Interception Point Registration, Processor Type Registration, Processor Registration, Interception Point\/Processor Association, Run-Time Control and Interception.","There is one interception service on each server (for example Weblogic Server). It is assumed, however, that all interception service instances across the cluster will be configured uniformly.","Interception Point Description","Each interception point type may have a different naming scheme. Through the registerInterceptionPointNameDescription method, the carrier informs the interception service about the naming scheme of the interception points that it will register. The description includes information for each part of the name: a name, a validation function and the number of acceptable values for the name (if the name can only take on a limited number of values, this is useful information to the interception service).","Alternatively, all names, independent of interception point type, may simply be a triple: interception point type, location and name.","Interception Point Registration","When the carrier reaches a point in its execution where it is aware of an impending interception point, it registers the existence of that interception point with the interception service via the registerInterceptionPoint call that it provides. It is returned a handle through which it calls the interception service which in turn calls the processor and with which it can unregister.","Processor Type Registration","When a processor framework, like the message broker, boots, it registers its processor type with the interception service through the registerProcessorType call. It also specifies a factory with which processor instances can be created by the interception service.","Processor Registration","When configuration information is available about processors (for example, when the ISC boots), the interception service is called to add to the list of configured processors through the addProcessor method. The interception service in turn invokes the particular processor type's processor factory in order to get a processor for runtime use. If the particular processor type is not yet registered, this act will be deferred until registration. However, a handle is returned to the caller in either case.","Run-Time Control","The basis of the interception service is a table of associations between names of interception points and names of processors. The interception service provides calls such as addAssociation, through which an association can be added to the table; removeAssociation, through which an association can be removed from the table; and getAssociationHandle and getAssociationHandles through which an individual association can be found or the complete set of associations can be enumerated.","Interception","When a carrier reaches an interception point, its job is to call the interception service to reach any processors that may be associated with this particular interception point.","In the non-optimized view of this, it creates an object that implements the MessageContext interface (from the JAX-RPC standard\u2014javax.xml.rpc.handler.MessageContext) and calls a process method of the handle that the interception service provided during registration. This will invoke the corresponding process method of the associated processor, if one exists.","This can be optimized somewhat by querying the interception service before creating the MessageContext to see if there is an association configured for this interception point. This would save the possibly superfluous creation of the MessageContext.","Configuration","The interception service is configured as a set of interception point\/processor associations. The table of associations can be searched and modified from outside the interception service. Further, it is possible to enable and disable individual associations dynamically. Lastly, any modifications to this table should be transparent to the carriers and processors (excepting that processors may request to be informed of changes to its associations, see \u201cProcessor Awareness\u201d).","Processor Registration","The interception service supports a registration mechanism for processors. Each registration must use a unique name. A handle is returned with which the processor can determine the interception points with which it is associated. A processor may deregister using the handle as well.","Processor Shutdown","When a processor misbehaves (e.g. throws a runtime exception), the interception service will forcibly shutdown the offending processor. The processor will be informed of this event through the invocation of its on Shutdown method. It is assumed that the processor will inform the administrative software of this occurrence and that it will respond accordingly. It may choose to simply reenable the processor by removing and adding it.","The interception service makes it possible for external modules to see whether an association has a processor that is in the shutdown state (i.e. has been shutdown but has not been reenabled).","Processor Awareness","The processor may specify a method to be invoked to be notified about changes to the state of its associations. There are two events currently which are considered to be state changes: when the number of associated interception points goes from nonzero to zero and when the number of associated interception points goes from zero to nonzero. This is useful since processors may free or allocate resources when these events occur.","Interception Point Naming Scheme","An interception point must follow the naming scheme that is described by its interception point type. The interception service verifies that this is so and, otherwise, throws an exception.","Multiple Interception Point Registration","It is expected that a carrier will register with the same interception point name multiple times. Each registration may or may not return the same handle.","Single Association for Interception Point","A particular interception point name may only occur once in the table of associations of the interception service. An attempt to add an association with the same interception point name as an existing association will throw an exception.","Processor Uniqueness","Each processor must register with a unique name. An attempt to register a processor with the same name as a processor which has already registered will cause an exception.","Processor Necessity","Interception point processing is deemed as necessary for the proper functioning of the carrier. If there is an association configured for an interception point, yet no corresponding processor has registered (or the processor has unregistered or been shutdown), an InterceptionServiceException is thrown to the carrier when it attempts to invoke its associated processor. In other words, a carrier cannot function without its associated processor.","Thread Resource Conservation","The Interception Service needs certain guarantees from the processor for proper behavior. It needs to know that processor shutdown notification and processor state change notification calls will return promptly. The Interception Service provides similar guarantees to its callers. All administrative calls may be assumed to be of short duration. This includes adding and removing association, registering and unregistering interception points and registering and unregistering processors.","Superseding Message Flow in the Processor","The interception framework gives the processor the ability to say to the carrier that it has processed the message and that the carrier should not continue its processing. This is communicated via the return code of the process method. The interception service is not really involved in this; it is merely specified here that the carrier should interpret the return code as described.","Disallowing Superseding in the Processor","When it reaches an interception point, the carrier may be at a point in its processing where it cannot allow the destination of its message to be superseded. A call, process only, is provided by the interception service and by the processor, which only gives the processor the ability to read and write the message, but does not give the processor the opportunity to tell the carrier whether or not to allow the message to continue along its current path.","A flawed configuration may cause a processor whose only function is to make such decisions to be called in this way. It is assumed that the processor will throw an exception which will cause the interception service to shut down the processor as described above.","Processor Exceptions","The interception framework defines exceptions of two types: one that indicates a problem that is not related to the particular message being processed and one that indicates a problem that is related to the message. Further, the exception may indicate whether the problem is perceived to be of short or long duration.","Interception Point Statistics","The interception service must gather statistics for each association that is configured. It should keep track of the number of times the processor is invoked as well as the number of times that the processor supersedes the original destination of the message.","Due to the nature of interception, the statistics may indicate something slightly different than expected. For a JMS example, if a transaction is rolled back, then a consumer side processor may see the same message twice and the statistics will reflect that occurrence. Therefore, the number of messages intercepted may be different than the number of messages received by JMS, as reported by JMS.","Logging","The interception service will provide logging that will note each time a processor registers, as well as each time an association is added or removed.","Java Programming Interfaces","The Java interfaces are provided here for reference.",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class InterceptionException extends Exception {"},{"entry":"\u2003\u2003public InterceptionException(String reason) {"},{"entry":"\u2003\u2003\u2003\u2003super(reason);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public InterceptionException(String reason, Throwable cause) {"},{"entry":"\u2003\u2003\u2003\u2003super(reason, cause);"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":"public class InterceptionServiceException extends Exception {"},{"entry":"\u2003public InterceptionServiceException(String reason) {"},{"entry":"\u2003\u2003\u2003super(reason);"},{"entry":"\u2003}"},{"entry":"\u2003public InterceptionServiceException(String reason, Throwable cause)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003super(reason, cause);"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"public class MessageContextException extends Exception {"},{"entry":"\u2003public MessageContextException(String reason) {"},{"entry":"\u2003\u2003super(reason);"},{"entry":"\u2003}"},{"entry":"\u2003public MessageContextException(String reason, Throwable cause) {"},{"entry":"\u2003\u2003super(reason, cause);"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"public interface AssociationHandle {"},{"entry":"\u2003\u2003AssociationInfo getAssociationInfo( ) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003void activate( ) throws InterceptionServiceException;"},{"entry":"\u2003\u2003void deactivate( ) throws InterceptionServiceException;"},{"entry":"}"},{"entry":"public interface AssociationInfo {"},{"entry":"\u2003\u2003String getInterceptionPointType( ) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003String[ ] getInterceptionPointName( ) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003String getProcessorType( ) throws InterceptionServiceException;"},{"entry":"\u2003\u2003String getProcessorName( ) throws InterceptionServiceException;"},{"entry":"\u2003\u2003boolean hasProcessor( ) throws InterceptionServiceException;"},{"entry":"\u2003\u2003boolean isActivated( ) throws InterceptionServiceException;"},{"entry":"\u2003\u2003boolean isProcessorShutdown( ) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003long getTotalMessagesCount( ) throws InterceptionServiceException;"},{"entry":"\u2003\u2003long getContinueMessagesCount( ) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003long getInProgressMessagesCount( ) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003long getProcessorRegistrationTime( ) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"}"},{"entry":"public interface AssociationListener {"},{"entry":"\u2003\u2003void onAddAssociation("},{"entry":"\u2003\u2003\u2003String interceptionPointType,"},{"entry":"\u2003\u2003\u2003String[ ] interceptionPointName,"},{"entry":"\u2003\u2003\u2003String processorType,"},{"entry":"\u2003\u2003\u2003String processorName,"},{"entry":"\u2003\u2003\u2003boolean activated,"},{"entry":"\u2003\u2003\u2003int depth"},{"entry":"\u2003\u2003);"},{"entry":"\u2003\u2003void onRemoveAssociation("},{"entry":"\u2003\u2003\u2003String interceptionPointType,"},{"entry":"\u2003\u2003\u2003String[ ] interceptionPointName,"},{"entry":"\u2003\u2003\u2003String processorType,"},{"entry":"\u2003\u2003\u2003String processorName"},{"entry":"\u2003\u2003);"},{"entry":"public interface CarrierCallBack {"},{"entry":"\u2003void onCallBack("},{"entry":"\u2003\u2003boolean continueOn"},{"entry":"\u2003);"},{"entry":"\u2003void onException("},{"entry":"\u2003\u2003InterceptionProcessorException exception"},{"entry":"\u2003);"},{"entry":"}"},{"entry":"public interface InterceptionCallBack {"},{"entry":"\u2003void onCallBack("},{"entry":"\u2003\u2003boolean continueOn"},{"entry":"\u2003);"},{"entry":"\u2003void onException("},{"entry":"\u2003\u2003InterceptionProcessorException exception"},{"entry":"\u2003);"},{"entry":"}"},{"entry":"public interface InterceptionPointHandle {"},{"entry":"\u2003\u2003String getType( );"},{"entry":"\u2003\u2003String[ ] getName( );"},{"entry":"\u2003\u2003AssociationInfo getAssociationInfo( );"},{"entry":"\u2003\u2003boolean hasAssociation( ) throws InterceptionServiceException;"},{"entry":"\u2003\u2003void processOnly(MessageContext messageContext)"},{"entry":"\u2003\u2003\u2003throws InterceptionException, MessageContextException,"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003boolean process(MessageContext messageContext)"},{"entry":"\u2003\u2003\u2003throws InterceptionException, MessageContextException,"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003void processAsync("},{"entry":"\u2003\u2003\u2003MessageContext messageContext,"},{"entry":"\u2003\u2003\u2003CarrierCallBack callBack"},{"entry":"\u2003\u2003) throws InterceptionException, MessageContextException,"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003void processOnlyAsync("},{"entry":"\u2003\u2003\u2003MessageContext messageContext,"},{"entry":"\u2003\u2003\u2003CarrierCallBack callBack"},{"entry":"\u2003\u2003) throws InterceptionException, MessageContextException,"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"}"},{"entry":"public interface InterceptionPointNameDescriptionListener {"},{"entry":"\u2003\u2003void onRegister( );"},{"entry":"\u2003\u2003String getType( );"},{"entry":"}"},{"entry":"public abstract class InterceptionPointNameDescriptor {"},{"entry":"\u2003\u2003public static String DEFAULT_PREFIX_NAME ="},{"entry":"\u2003\u2003\u201cNAME_SEGMENT\u201d;"},{"entry":"\u2003\u2003public static int UNRESTRICTED_VALUE ="},{"entry":"\u2003\u2003Integer.MAX_VALUE;"},{"entry":"\u2003\u2003public static String getDefaultPrefixName( ) {return"},{"entry":"\u2003DEFAULT_PREFIX_NAME;}"},{"entry":"\u2003\u2003public abstract String getTitle( );"},{"entry":"\u2003\u2003public abstract int getTotalNumberOfUniqueValue( );"},{"entry":"\u2003\u2003public abstract boolean isValid(String value);"},{"entry":"}"},{"entry":"public interface InterceptionService {"},{"entry":"\u2003\u2003AssociationHandle addAssociation("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String interceptionPointType,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String[ ] interceptionPointName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String processorType,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String processorName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003boolean activated"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003) throws InterceptionServiceException;"},{"entry":"\u2003\u2003AssociationHandle addAssociation("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String interceptionPointType,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String[ ] interceptionPointName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String processorType,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String processorName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003boolean activated,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003int depth"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003) throws InterceptionServiceException;"},{"entry":"\u2003\u2003void removeAssociation("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003AssociationHandle associationHandle) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003void registerInterceptionPointNameDescription("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String interceptionPointType,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003InterceptionPointNameDescriptor[ ] descriptor,"},{"entry":"\u2003\u2003\u2003\u2003\u2003AssociationListener listener"},{"entry":"\u2003\u2003\u2003\u2003\u2003) throws InterceptionServiceException;"},{"entry":"\u2003\u2003void registerInterceptionPointNameDescriptionListener("},{"entry":"\u2003\u2003\u2003InterceptionPointNameDescriptionListener listener"},{"entry":"\u2003\u2003)throws InterceptionServiceException;"},{"entry":"\u2003\u2003InterceptionPointNameDescriptor[ ]"},{"entry":"\u2003getInterceptionPointNameDescription(String interceptionPointType);"},{"entry":"\u2003\u2003InterceptionPointHandle registerInterceptionPoint(String"},{"entry":"\u2003interceptionPointType, String[ ] interceptionPointName);"},{"entry":"\u2003\u2003void unRegisterInterceptionPoint(InterceptionPointHandle handle)"},{"entry":"throws InterceptionServiceException;"},{"entry":"\u2003\u2003void registerProcessorType(String name, Object factory) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003ProcessorHandle addProcessor(String type, String name, String"},{"entry":"\u2003metaData) throws InterceptionServiceException;"},{"entry":"\u2003\u2003void removeProcessor(ProcessorHandle handle) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003void removeProcessor(String type, String name) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003\u2003Iterator getAssociationHandles( );"},{"entry":"\u2003\u2003AssociationHandle getAssociationHandle(String type, String[ ]"},{"entry":"\u2003name) throws InterceptionServiceException;"},{"entry":"\u2003\u2003Iterator getProcessorHandles( );"},{"entry":"\u2003\u2003\u2003ProcessorHandle getProcessorHandle(String type, String name)"},{"entry":"throws InterceptionServiceException;"},{"entry":"}"},{"entry":"public interface Processor {"},{"entry":"\u2003\u2003String getType( );"},{"entry":"\u2003\u2003String getName( );"},{"entry":"\u2003\u2003boolean process(MessageContext mc, AssociationInfo associate)"},{"entry":"\u2003throws InterceptionException, MessageContextException;"},{"entry":"\u2003\u2003void processOnly(MessageContext mc, AssociationInfo associate)"},{"entry":"\u2003\u2003\u2003throws InterceptionException, MessageContextException;"},{"entry":"\u2003\u2003void processAsync(MessageContext mc, AssociationInfo associate,"},{"entry":"\u2003InterceptionCallBack callBack)"},{"entry":"\u2003\u2003\u2003throws InterceptionException, MessageContextException;"},{"entry":"\u2003\u2003void processOnlyAsync(MessageContext mc, AssociationInfo"},{"entry":"\u2003associate, InterceptionCallBack callBack)"},{"entry":"\u2003\u2003\u2003throws InterceptionException, MessageContextException;"},{"entry":"\u2003\u2003void onShutdown( );"},{"entry":"\u2003\u2003void associationStateChange(boolean active);"},{"entry":"}"},{"entry":"public interface ProcessorFactory {"},{"entry":"\u2003\u2002Processor create(String name, String metadata) throws"},{"entry":"\u2003InterceptionServiceException;"},{"entry":"\u2003}"},{"entry":"\u2003public interface ProcessorHandle {"},{"entry":"\u2003\u2003AssociationInfo[ ] getAssociationInfos( );"},{"entry":"\u2003\u2003String getType( );"},{"entry":"\u2003\u2003String getName( );"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"While MBeans which correspond to the management interfaces of the interception service are mostly straightforward, there is one type of MBean which requires more explanation. As described above, the interception service allows different interception point types to have different naming schemes. Therefore, there needs to be a different MBean for associations with each of the different interception point types. The following section discuss the carriers' (for example JMS and Web Services) relationships to the interception service.","Sample Chronology","The following example illustrates an initialization and running of the interception service in which there is just one carrier, JMS, and all processors are part of the message broker. Further, this example assumes that all processors and associations are configured through the ISC.","After boot, the message broker comes up first. It merely calls a hard-coded line which tells the interception service its name (\u201cmessage broker\u201d) and its processor factory.","Next, the ISC reads its Mbeans. In this example, these MBeans identify one processor and one association. The processor is of type \u201cmessage broker\u201d, with name \u201cRoute Through Chicago Office\u201d and has the associated configuration information that the message broker needs. The interception service configurator calls the interception service to describe this processor. The interception service in turn calls the processor's factory to create a processor. Next, the ISC adds its one configured association to the interception service. Let us assume that this association is the following pair\u2014the (multipart) name of the interception point is \u201cS1\u201d, \u201cQ1\u201d, \u201cIncoming\u201d and the name of the processor is \u201cRoute Through Chicago Office\u201d.","Next, JMS starts. It calls the interception service to describe its naming scheme. Its naming scheme is that it has a server name (which can take on any value), a destination name (which can take on any value) and a location (which can be either \u201cincoming\u201d or \u201coutgoing\u201d). That is it for now.","Next, let us assume that a JMS producer starts, JMS registers an interception point with the name \u201cS2\u201d, \u201cQ2\u201d, \u201cincoming\u201d. Let us assume that a consumer comes up next and JMS registers the name \u201cS1\u201d, \u201cQ1\u201d, \u201coutgoing\u201d. The reader will notice that neither of these interception points actually has a processor associated with it. So, when JMS receives a message from the previously mentioned producer, it asks the interception service if there are any processors associated with this particular point. Since there is no processor associated with this name, JMS simply continues its processing.","Finally, another producer starts which has the interception point named \u201cS1\u201d, \u201cQ1\u201d, \u201cincoming\u201d. When a message is received by the JMS server through this producer, the interception service will now have an associated processor. So, the JMS code creates a MessageContext and calls the interception service to process the message. The interception service, in turn, calls the processor to process it\u2014unless it has unregistered in that millisecond in which case it will just return true. The processor may return true or false; if it returns false, this indicates that JMS should not continue along its course (true indicates that JMS should continue).","Association Run-time Data","In accordance with an embodiment it must be possible to fetch the following run-time information:","1. Total count of messages which have reached the associated interception point","2. Total count of messages which the processor has allowed to continue along its path (the number which have been superseded can be derived, of course)","3. Total messages which are in the process of being handled by the processors","4. The time that the currently associated processor registered","5. Whether the association deactivated (Or shutdown, perhaps due to program failure).","Association Control","In accordance with an embodiment, it must be possible to activate and deactivate an association. As described above, an inactive association is functionally equivalent (with respect to interception) to there being no association configured.","Processor Metadata","In accordance with an embodiment, the interception service configuration can configure processors with metadata.","Java Programming Interfaces",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public interface InterceptionProcessorMBean extends DeploymentMBean"},{"entry":"{"},{"entry":"\u2003void setName(String name)"},{"entry":"\u2003\u2003throws InvalidAttributeValueException;"},{"entry":"\u2003String getName( );"},{"entry":"\u2003void setType(String type)"},{"entry":"\u2003\u2003throws InvalidAttributeValueException;"},{"entry":"\u2003String getType( );"},{"entry":"\u2003void setMetaData(String metadata);"},{"entry":"\u2003String getMetaData( );"},{"entry":"}"},{"entry":"public interface AssociationRuntimeMBean extends RuntimeMBean {"},{"entry":"\u2003long getTotalMessagesCount( );"},{"entry":"\u2003long getContinueMessagesCount( );"},{"entry":"\u2003long getInProgressMessagesCount( );"},{"entry":"\u2003long getProcessorRegistrationTime( );"},{"entry":"\u2003boolean hasProcessor( );"},{"entry":"\u2003void activate( );"},{"entry":"\u2003void deActivate( );"},{"entry":"\u2003boolean isActivated( );"},{"entry":"\u2003boolean isProcessorShutdown( );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art.","In some embodiments, the present invention includes a computer program product which is a storage medium (media) having instructions stored thereon\/in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and\/or data.","The foregoing description of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"}},"DETDESC":[{},{}]}
