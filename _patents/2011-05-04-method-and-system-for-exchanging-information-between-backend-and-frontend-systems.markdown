---
title: Method and system for exchanging information between back-end and front-end systems
abstract: A system for exchanging information content between a back-end system within a restricted access environment and an end-user includes a front-end system and a manager node outside of the restricted environment, and an access node within the restricted environment. The front-end system executes a mini-application to output query data. The manager node receives the query data and applies business logic and connection parameters to generate a request for the information content in a first format. The manager node communicates the request to the access node in the first format. The access node converts the request to a second format particular to the back-end system, and conveys the request to the back-end system. Responses containing the information content are received at the access node from the back-end system. The access node converts the responses to the first format and sends information content contained in the responses to the front-end system via the manager node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09229998&OS=09229998&RS=09229998
owner: AppsFreedom, Inc.
number: 09229998
owner_city: Chandler
owner_country: US
publication_date: 20110504
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED INVENTIONS","TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","FIG. ","FIG. ","FIG. ","FIG. ","FIG. ","FIG. ","FIG. ","FIG. ","FIG.  ","FIGS. A-B","FIG. ","FIG. "],"p":["The present invention claims priority under 35 U.S.C. \u00a7119(e) to: \u201cSystem and Method for Managing Micro Applications,\u201d U.S. Provisional Patent Application Ser. No. 61\/334,235, filed 13 May 2010, which is incorporated by reference herein.","The present invention relates to the field of enterprise systems and, more particularly, to a method and system for exchanging information between end-users and back-end enterprise systems.","An enterprise system refers to the network of computers, interconnection equipment, and software components used within a business or organization to support the execution of business processes, information flows, reporting, data analysis, and so forth within and between organizations. A set of packaged application-software for an enterprise system can include, for example, enterprise resource planning (ERP), customer relationship management (CRM), supply chain management (SCM), strategic enterprise management (SEM), manufacturing integration and intelligence (MII), master data management (MDM), product lifecycle management (PLM), and so forth.","An enterprise system can additionally include all the data for manufacturing, supply chain management, financials, projects, human resources, etc., maintained in a common database. Through the common database, different business units can store and retrieve information. An enterprise system can be advantageous for a number of reasons, including standardization, lower maintenance, providing a common interface for accessing data, greater and more efficient reporting capabilities, sales and marketing purposes, and so forth.","Enterprise systems are typically back-end systems that support a company's back office. The \u201cback office\u201d is generally considered to be the technology, services, and human resources required to manage a company itself. Such back-end systems are typically contained within restricted access environments that require appropriate authentication and verification before a user can access such systems.","Unfortunately, access to enterprise systems can be complex and limited to certain users in an organization. For example, the use of an enterprise software system often requires a direct connection to the system. As such, use of these enterprise systems is typically limited to users with access to a desktop or a mobile workstation with disparate authorization and verification protocols. Furthermore, user interfaces (i.e., programs and hardware that control a display for the user and that allow the user to interact with the devices to these enterprise systems) can be difficult to implement and greatly varied among the various devices.","Increasingly, users of enterprise systems wish to perform business processes from remote locations and using a variety of devices. These business processes can include, for example, order fulfillment and billing, workflow approval, proof of delivery, order capture, human capital management, customer sales and satisfaction, and even inventory and warehouse management. Typically, an organization stores business processes of an enterprise system on a number of different computing systems, which may be deployed on disparate platforms and disparate physical locations. Further, these computing systems may use different protocols, data structures, and databases, each system customized to cater to a specific business process within the organization.","The devices from which users may wish to perform business processes can include a myriad of mobile devices, operating systems, wired and wireless processor platforms using web browsers, and so forth. Furthermore, these devices call for various user interfaces, i.e., programs and hardware that control a display for the user and that allow the user to interact with the devices. Exemplary mobile devices include, for example, personal digital assistants (PDAs), tablet PCs, smart phones, and the like.","Embodiments of the invention entail methodology and a system for facilitating the exchange of information content between a back-end system contained in a restricted access environment and a front-end system. More particularly, embodiments of the invention facilitate the transfer of business data quickly and easily between multiple source enterprise applications of the back-end systems and various front-end systems.","Throughout this discussion, items are assigned three- or four-digit reference numbers whose first digit or first two digits reflects the Figure in which the item first appears. That is, items first appearing in  are assigned reference numbers between  and , items first appearing in  are assigned reference numbers between  and , etc. Once assigned, a given reference number is used in all Figures in which that item appears.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["100","102","104","106","108"]},"System  is implemented in network  for facilitating the exchange of information content  between back-end systems  and front-end systems , where each back-end system  is contained within a restricted access environment , and front-end systems  are located remotely outside of restricted access environment. Moreover, the exchange of information content  is effectively accomplished in minimal traversals over network  and enables real-time access to back-end systems .","In some embodiments, each back-end system  may be any computing device or devices implementing an enterprise system used within a business or organization to support the execution of business processes. For example, an organization may use several types of enterprise applications that make up its back-end system . These enterprise applications could include enterprise resource planning (ERP), supply chain management (SCM), customer relationship management (CRM), human resources (HR), and so forth. These enterprise applications may be supplied by a variety of vendors such as SAP, ORACLE, IBM, and so forth.","Network  includes a plurality of back-end systems  for illustrative purposes. One or more of these multiple back-end systems  in one or more locations may be utilized by a single organization to implement their enterprise system. In addition, or alternatively, distinct back-end systems  may be utilized by distinct organizations to implement their individual enterprise systems.","The term \u201crestricted access environment\u201d pertains to that portion of an organization's computing systems and processes that is blocked from unauthorized access while permitting authorized communication. This restricted access may be achieved through the implementation of a firewall  designed to prevent an unauthorized user from accessing the back-end system.","Front-end systems  encompass any of a variety of computing devices. For example, front-end systems  may be any variety of desktop computers executing web browsers, cellular phones, personal digital assistants (PDA), tablet PCs, smartphones, notebook computers, and so forth. Front-end systems  are used by end-users  to access back-end systems  from remote locations at any time convenient to end-users .","Network  includes a plurality of front-end systems  for illustrative purposes. One or more of these multiple front-end systems  may be utilized by a single end-user . In addition, distinct front-end systems  may be utilized by different end-users  to access their particular back-end systems .","In an exemplary scenario, end-user  may use one front-end system  such as a desktop computer , when he or she is located in an office. Alternatively, end-user  may use a different front-end system , such as a smartphone , when he or she is located outside of the office. A bubble  encircling desktop computer  and smartphone  indicates that these front-end systems  are associated with end-user , at least temporarily, for the purpose of accessing particular back-end systems .","In general, system  within network  includes at least one front-end system  directly accessible by end-user  and executing one or more mini-applications , a manager node  in communication with front-end system , and at least one access node  within each restricted access environment  in selective communication with each of manager node  and at least one back-end system . Front-end system , manager node , and access node  within system  may be periodically interconnected via a plurality of wired and\/or wireless links .","Each of front-end systems  may run one or more mini-applications  to achieve the functionality of accessing particular back-end systems . Mini-applications  are light-weight applications (e.g., widgets, gadgets, etc.) that occupy a comparatively small amount of display space and system memory, do not include unused features, perform a specific and somewhat limited function, and execute quickly and efficiently. Mini-applications  provide secure access to back-end systems  via simple interfaces. In various embodiments, mini-applications  may be built and deployed on various platforms and operating systems. For example, some mini-applications  may be Google gadgets running under the Google Desktop framework, the Google Sites framework, the Google Documents framework, and\/or the Google Maps framework. Other mini-applications  may be iPhone gadgets, Android gadgets, BlackBerry gadgets, and so forth.","Mini-applications  running under the Google Desktop framework may provide desktop alerts for business events at desktop computer . These desktop alerts can be information content  in the form of notifications of business events as non-intrusive pop-ups from back-end systems . Mini-applications  running under the Google Sites framework may provide visibility as well as small user interface displays for business interactions with back-end systems . Mini-applications  running under the Google Documents framework may provide a spreadsheet, Word-editor, or Powerpoint interface to back-end systems . Mini-applications  that are iPhone gadgets can provide access to business data contained in back-end systems  via the iPhone. Similarly, mini-applications  that are Android gadgets can provide access to business data contained in back-end systems  via Google phones, and mini-applications  that are BlackBerry gadgets can provide access to business data contained in back-end systems  via the Blackberry. In addition, mini-applications  may be built on various other platforms (e.g., social media platforms, Internet TV gadgets, and for forth) implemented in front-end systems .","Manager node  may be a multi-tenant cloud application that manages all communications between mini-applications executing on front-end system  and back-end systems  via access nodes . Cloud computing is Internet-based computing, whereby shared resources, software, and information are provided to computers and other devices on demand. A multi-tenant cloud application is an application that runs on a web server and can be used by multiple customers. However, each customer can customize the application to its user's purposes. Customizing an application includes adding new data fields, new data entities, new business logic, application flows, batch data manipulations, application screens and so forth, without the need to deploy a new application. Manager node  provides integration, security, usage, and data services between mini-applications  executing on front-end systems  and access nodes  within restricted access environments , as will be discussed in greater detail in connection with .","Access nodes  are applications that reside within a customer environment, i.e., behind associated firewalls  within restricted access environments , and are responsible for communications between manager node  and back-end systems . In the illustrated embodiment, each back-end system  within a restricted access environment  is associated with a single instance of an access node . It should be understood, however, that in alternative embodiments, a restricted access environment  may contain multiple back-end systems  and\/or multiple access nodes  also contained within the same restricted access environment . Access nodes  will be discussed in greater detail in connection with .","Information content  may be notification from back-end system  of any conceivable event. In some embodiments, information content  may be a business event, process, or workflow. Information content  could be receipt of an order, shipment of an order, notification indicating that end-user  must approve a document such as an invoice, notification that a machine or plant has gone down, notifications of delays in shipment, notifications indicating whether a supplier will be able to meet his or her promised deliveries, and so forth. Although some examples of information content  are listed, it should be understood that information content  may be any information pertinent to the enterprise system of a particular organization.","As will be discussed in detail below, information content  is communicated between front-end systems  (executing mini-applications ) and manager node  in a first standardized format. Likewise, information content  is communicated between manager node  and access node  in the first standardized format. However, information content  is communicated between access node  and back-end system  in a second format. This, second format is an application programming interface (API) that is application-specific to back-end system  with which access node  is associated. The API generally includes a set of functions, procedures, methods, classes, or protocols that an operating system, library, or service provides to support requests made by computer programs. Thus, access node  receives information content  from manager node  in the first format, converts it to application-specific API's for back-end system  in order to retrieve source content from back-end system . Access node  subsequently converts the source content received from back-end system  to the first format and sends it to front-end system  via manager node .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2","b":["108","100","106","108"]},"Front-end system  includes a processor  on which methods according to the invention can be practiced. Processor  is in communication with an input device , an output device , and a memory system  for storing one or more mini-applications  and for storing display logic . These elements are interconnected by a bus structure .","Input device  can encompass user controls, such as a keyboard, touchscreen, keypad, mouse, pointing device, audio device (e.g., a microphone), and\/or any other device providing input to processor . Output device  can encompass a display , a printer, an audio device (e.g., a speaker), and\/or other devices providing output from processor . Input and output devices  and  can also include network connections, modems, or other devices, exemplified by an antenna , used for communications with other computer systems or devices, such as manager node  via network .","Memory system  may be a magnetic disk, compact disk, or any other volatile or non-volatile mass storage system readable by processor . Memory system  may also include cooperating or interconnected computer readable media, which exist exclusively on front-end system  or are distributed among multiple interconnected computer systems (not shown) that may be local or remote.","Mini-applications  are stored in memory system  for instructing processor  to query back-end system  about particular events and\/or to disposition particular events. Front-end system  may run multiple mini-applications  stored in memory system  according to the preferences or business requirements of end-user . Each mini-application  is associated with one or more back-end systems , and only those mini-applications  in which end-user  has an interest need be executed. Front-end system  is not limited to only running mini-applications . In addition, front-end system  will typically be running multiple applications concurrently.","For clarity of description, mini-applications  stored in memory system  include a query mini-application  and a disposition mini-application . In an example, end-user  may wish to be kept informed of certain business events, and subsequently respond to, or disposition, those business events. In an embodiment, query mini-application  may periodically execute in order to send query data  to back-end system . Alternatively, execution of query mini-application  may be initiated by end-user  via input device . In response, information content  may be received at front-end system  for presentation as a notification , for example, a pop-up message, on display . Disposition mini-application  may subsequently execute in order to allow end-user to disposition the event indicated by notification .","In an exemplary scenario, when end-user  is an employee of a company, he or she may wish to be informed of particular business events. For example, a manager may wish to receive notice of open purchase orders. Accordingly, query mini-application  may periodically execute in order to access purchase order information from a particular one of back-end systems . This purchase order information may then be provided from back-end system  as notification  of particular open purchase orders. End-user  may subsequently initiate execution of disposition mini-application  in order to disposition the purchase orders, for example, send an approval or disapproval indication of a particular purchase order to back-end system  in order to update particular information content  at back-end system .","Only one simplified example is mentioned above for brevity. However, it should be understood that a multitude of mini-applications  can be provided that enable end-user  to query back-end systems , to update information content  at back-end systems , to monitor the status of information content  at back-end system , and so forth in accordance with particular enterprise systems of a particular organization or business. Moreover, in alternative embodiments, one of mini-applications  may include the appropriate command structure to both query back-end system  and disposition, i.e., update, information content  at back-end system .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":["124","102","124","100","104","108","106","124","124","122","106","106","126"]},"Various functions of manager node  may be provided by a third party cloud provider. These various functions may include administrative console; customer onboarding (i.e., acquiring and keeping customers); development framework\/tools\/API; workflow and usage monitoring; subscription management, bundling, pricing, & reports; user authentication and internationalization; trial-ware management and release management; multi-tenancy, database flexibility, and database isolation; and so forth. These various functions are not described in detail herein for brevity.","The inventive core of manager node  is a manager engine . Manager engine  acts as the central execution engine between front-end systems  executing mini-applications  and access nodes . In an embodiment, manager engine  includes an integration engine , a rules engine , and an access node connector . The term \u201cengine\u201d used herein refers to some combination of hardware and\/or software that performs a very specific and repetitive function. The term \u201cconnector\u201d used herein does not necessarily refer to a physical device that connects manager node  with an external entity. Rather, the term \u201cconnector\u201d refers to some combination of hardware and\/or software that enables communication between manager node  and appropriate access nodes .","Integration engine  is responsible for handling all external communications with respect to mini-applications  executing on front-end systems , and for handling various validations before passing any external communications further on for processing. For example, front-end system  may send query data  in a first standardized format (discussed below) as a secure web-service for receipt at integration engine  of manager node . Integration engine  could then validate and verify end-user  sending query data  and forward query data  to rules engine , again in the first standardized format.","Rules engine  is responsible for applying rules to query data  incoming from front-end system , manipulating query data  appropriately, and forwarding query data  in the first standardized format to access node connector . Rules engine  includes a rules configuration module , a command formulation module , and a response formulation module . The term \u201cmodule\u201d used herein refers to a program unit that is discrete and identifiable with respect to compiling, combining with other modules, and loading.","Rules configuration module  accepts query data  from integration engine  in the first standardized format and appends query data  with business logic  that is appropriate for both mini-application  sending query data  and to the appropriate back-end systems . In other words, business logic  specifies the type of information content  to be sent to front-end system . Rules configuration module  forwards query data  appended with business logic  in the first standardized format to command formulation module .","Command formulation module  accepts query data  appended with business logic  from rules configuration module  and applies the technical rules and logic that is appropriate for both mini-application  sending query data  and to the appropriate back-end systems . For example, command formulation module  may apply connection parameters , such as a network address, to query data  that identify a particular one of access nodes  to be queried. Thus, command formulation module  completes the generation of a request  in the first standardized format (discussed below) with respect to query and data selection. Command formulation module  subsequently forwards request  to access node connector .","Access node connector  takes request  in the first standardized format from command formulation module  and securely communicates request  to one of access nodes  identified by connection parameters  in request . Some functions that may be performed by access node connector  include locating the appropriate access node  for an associated back-end system , encrypting and securing request  for transmission, and communicating request  to the appropriate access node .","In addition, access node connector  is enabled to receive a response  from access node  in the first standardized format. In general, response  represents the particular information content  (e.g., business events) requested from one or more back-end systems  during the execution of one of mini-applications , such as query mini-application . Upon receipt of response , access node connector  forwards response  to response formulation module .","Response formulation module  processes response  from back-end system  by applying appropriate business rules. Some of the typical functions of response formulation module  include, for example, filtering response  coming from access node connector  to obtain information content  requested upon execution of one of mini-applications , such as query mini-application .","In an embodiment, one of mini-applications  may output query data  that calls for accessing two or more back-end systems  in order to formulate information content . In such an instance, response formulation module  may temporarily store a subset of the requested information content  while access node connector  is processing other routines in order to receive responses  from other back-end systems. Response formulation module  may then receive these additional responses , filter them to obtain additional subsets of information content , and eventually compile the subsets of information into a single packet of information content .","This information content  is forwarded from response formulation module  to integration engine  where it is sent to the particular one of front-end systems  executing one of mini-applications . In some instances, display logic  may additionally be communicated with information content  so that notification  of information content  can be appropriately displayed on the receiving front-end system .","Manager node  may additionally include a data logger module and\/or an error handler module The data logger module may log all application messages and store milestone data from manager engine  with an appropriate audit trail. The error handler module handles error resolutions.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 4","b":["126","102","126","100","106","124","126","318","124","320","124","126","112","126","400","402","404"]},"Integration engine  is responsible for handling external communications with manager node . Request  is received at integration engine  from manager node  in the first standardized format. Request  includes business logic , is desirably comprehensive, and contains all the information for processing, as well as any data. Integration engine  validates and verifies request  and sends it to rules engine .","Rules engine  is responsible for applying rules to the incoming request , manipulating request , and sending request  to query engine . Rules engine  includes a command formulation module  and a response formulation module .","In general, command formulation module  of rules engine  receives request  and separates it into smaller steps, or discrete operations, for execution in accordance with a source application executing on a particular one of back-end systems . Command formulation module  passes these smaller steps or operations separated from request  to query engine  along with system parameters for the associated back-end system .","Query engine  is responsible for taking the smaller steps, pieces, or operations separated from request  in the first standardized format and executing the Application Programming Interface (API) in particular source back-end systems . Query engine  has factories , or factory objects, for each source application, i.e., back-end system , supported. The term \u201cfactory\u201d refers to an object, in object-oriented computer programming, for creating other objects. In this instance, each \u201cfactory\u201d processes request  received in the first standardized format to create API objects specific to a source application of a particular back-end system . Thus, at each of factories , request  (i.e., the smaller steps, pieces, or operations of request ) in the first standardized format is converted into a second format, the second format being API objects specific to a source application of a particular back-end system .","In an embodiment, factories  may include, but are not limited to, one or more of an SAP business application programming interface (BAPI) factory , an SAP business function enabler (BFE) factory , a Web Services factory , Oracle factory , and so forth. Factories  generally provide for the conversion of request  from the first standardized format to a particular format suitable to particular source back-end systems . In an example, back-end systems  in the form of an SAP back-end system , an Oracle back-end system , and intranet web services back-end system  are illustrated.","SAP is a software company which specializes in the development of business enterprise software. SAP back-end system  includes source applications referred to herein as back-end applications . By way of example, back-end applications  include an enterprise resource planning (ERP) application , a customer relationship management (CRM) application , and a supply chain management (SCM) application . Ellipses indicate that SAP back-end system  may include additional back-end applications  not illustrated for brevity. Each of ERP application , CRM application , and SCM application  may communicate using a remote function call (RFC) interface and\/or a business application programming interface (BAPI). The RFC interface and the BAPI interface are illustrated herein as a single RFC\/BAPI interface . Each of ERP application , CRM application , and SCM application  may additionally communicate using a web services (W\/S) interface  and\/or a business function enabler (BFE) interface .","A remote function call is the standard SAP interface for communication between an SAP client, e.g., end-user , and an SAP server, e.g., SAP back-end system  over transmission control protocol\/internet protocol (TCP\/IP) or common programming interface for communications (CPI-C) connections. A BAPI is a remote-enabled function module provided by SAP and used to achieve business related functionalities. BAPIs enable access to SAP functions across formal, stable and dialog-free interfaces. These interfaces can be used by external applications developed by customers and complementary software partners as well as by other SAP applications. BAPIs are defined as application programming interface (API) methods of SAP Business Object Types. These object types are used within the Business Framework to enable object-based communication between components.","SAP BAPI factory  calls SAP Remote Function modules from request  that was received from rules engine  in the first standardized format. In particular, SAP BAPI factory  converts request  from the first standardized format into a second format, namely an SAP language format, and conveys request  in the SAP language to a particular SAP RFC\/BAPI interface  for any of, for example, ERP application , CRM application , SCM applications . SAP BAPI factory  subsequently receives response  in the SAP language format, extracts the data in response , formulates response  back into the first standardized format, and sends it to response formulation module  of rules engine .","The SAP business function enabler interface  is a module that resides within SAP and communicates with access node  on one side and executes SAP function modules on the other side. A large number of SAP function modules and data within various SAP applications are not exposed outside of restricted access environment  for external program calls from end-user . Indeed, roughly only forty percent of the data within SAP applications may be exposed via RFC\/BAPI interface  and W\/S interface . The remaining sixty percent of the data within SAP applications is non-remote enabled data. In other words, an user can only access this information from within the restricted access environment  via BFE interface . Business function enabler interface  enables a standardized way of exposing any data within an SAP application.","Accordingly, SAP BFE factory  converts request  from the first standardized format into a second format, namely an SAP specific query in SAP's proprietary protocol and format. SAP BFE factory  subsequently conveys request  in SAP's proprietary format to a particular SAP BFE interface . SAP BFE factory  subsequently receives response  in the SAP proprietary format, extracts the data in response , formulates response  back into the first standardized format, and sends it to response formulation module  of rules engine .","Web services factory  converts request  from the first standardized format to call web services and extract data from intranet web services back-end system  or any of SAP web services interfaces . Web services factory  subsequently formulates response  back into the first standardized format and sends response  back to response formulation module  of rules engine . Oracle factory  receives request  in the first standardized format from rules engine  and converts request  into Oracle specific queries in order to extract data from Oracle back-end system . Oracle factory  subsequently receives response , formulates it back into the first standardized format and sends response  back to response formulation module  of rules engine .","Response formulation module  of rules engine  is used to process response  from query engine  back to manager node . Some typical functions of response formulation module  include, for example, filtering response  coming from query engine  and holding information content  contained in response  while query engine  may be processing other routines. The information content contained in multiple responses may eventually be compiled to form a single response  that is communicated in a single traversal via link  to manager node .",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 5","b":["102","100"]},"In an exemplary scenario, front-end system  executes one of its mini-applications , and in this case, query mini-application . Execution of query mini-application  may occur through input by end-user  or mini-application  may be configured to automatically execute at periodic intervals. Query mini-application  formulates query data  in a standardized format and subsequently outputs query data  to manager node  in a first transmission event via links . For illustrative purposes, the standardized format for communications is represented by a rightward leaning parallelogram .","Query data  in standardized format  is received at integration engine  of manager node . Integration engine  validates query data  and forwards query data  to rules configuration module (RCM)  of rules engine . Rules configuration module  applies business logic  to query data  and forwards query data  with business logic  to command formulation module (CFM)  in standardized format .","Command formulation module  receives query data  with the applied business logic  and applies connection parameters  in order to generate request  for information content  in standardized format . In alternative embodiments, command formulation module  may initially break query data  with the applied business logic  into smaller subsets in the instance that information content  is to be obtained from more than one back-end system . Once query data  is subdivided, connection parameters  are applied to the subdivided query data  in order to generate multiple requests . In either instance, after request  is generated in standardized format , command formulation module  sends request  to access node connector  in a second transmission event via links .","Access node connector  receives request , identifies one of access nodes  and securely sends request  to integration engine  of access node  in standardized format . Integration engine  receives request  in standardized format , processes request , and forwards request  to command formulation module  of access node .","Command formulation module  breaks request  into smaller request queries, referred to herein as discrete operations , in accordance with an API to be used to access back-end applications  (e.g., ERP application , CRM application , SCM application , etc.) within back-end system . Command formulation module  calls query engine  with a single operation  in standardized format .","Query engine  receives the single operation  and converts operation  from standardized format  to a different format particular to the access interface (e.g., RFC\/BAPI interface , W\/S interface , BFE interface , etc.) being used at back-end system . This application programming interface (API) format is represented by a leftward leaning parallelogram . Query engine  subsequently conveys operation  in API format  to back-end system , and more particularly, to the one of back-end applications  to which operation  is directed.","Query engine  receives a discrete response  from back-end system  in API format  and sends response  to command formulation module . Command formulation module  controls further calls to query engine  in accordance with the multiple discrete operations . Response  may be stored at response formulation module  until all calls of operations  are made to back-end system , and all responses  are received.","Once all calls are made, response formulation module  processes, compiles, or otherwise manipulates the multiple responses  to preferably form a single communication packet containing response  in standardized format . Response  is then sent to integration engine . Integration engine  securely sends response  to access node connector  of manager node  in a third transmission event via links .","Response  formed at response formulation module  is preferably a \u201clean\u201d message containing the requested information content . The term \u201clean\u201d used here refers to a message that is compact, small in size, and contains only the necessary information so that response  can be quickly and efficiently sent via link  from access node  to manager node  in a single communication traversal.","When access node connector  receives response , it sends response  in standardized format  to command formulation module . Command formulation module  controls further calls to other access nodes  and back-end systems  as needed. One or more responses  in standardized format  are stored in response formulation module  of manager node  until all requests  in standardized format  are completed.","When all requests  are completed, response formulation module  processes, compiles, or otherwise manipulates the multiple responses  to preferably form a single communication packet containing information content  in standardized format . Information content  is then sent to integration engine . Integration engine  securely sends information content  from manager node  to front-end system  in a fourth transmission event via links .","At front-end system , information content  may be presented on display  as notification . Advantageously, notification  may be displayed in a format that is optimized for the particular front-end system  on which it is displayed.","Thus, the configuration of elements in system  provides for the secure, efficient, and timely delivery of information content  from back-end system  to front-end system . Preferably communication via network  is accomplished in minimal traversals over links .",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 6","FIGS. 8 and 9"],"b":["600","602","318","320","108","124","126","602","500","102","802"]},"There are a multitude of user interfaces across the multitude of front-end systems  used in businesses today, including desktop clients, Web-services, smartphones, etc. User interfaces include hardware (physical) and software (logical) components. User interfaces allow users to input in order to manipulate a system and allow the system to indicate the effects of the users' manipulation. Business users, i.e., end-users , may use many of these types of user interfaces and front-end systems  in his or her average work day, from accessing back-end systems  via desktop-client or via web-browsers or even accessing business emails via mobile phones. In addition, an organization may use many types of back-end applications , such as enterprise resource planning application , customer relationship management application , supply chain management , human resources applications, and the like provided by various vendors. In addition, there are a variety of Software-as-a-Source (SaaS) vendors that provide cloud applications. One problem is how to readily enable communication between the multitude of front-end systems  that implement a variety of user interfaces with various back-end systems  in a manner that is scalable simple, and readily understood.","Each of XML-based and JSON-based formats  and  solves this problem for mini-applications  where a small amount of business data needs to be transferred very quickly and easily between multiple back-end applications  at back-end systems  and various front-end systems . Each of XML-based and JSON-based formats  and  is a novel query language that enables any of a multitude of front-end systems  outside of restricted access environments  to communicate with any of a multitude of back-end systems  located within restricted access environments . In addition, each of XML-based and JSON-based formats  and  is built for simplicity so that an individual can readily write a query to extract information content  from any back-end system  without needing to know the proprietary language of various enterprise back-end applications  (e.g., SAP applications, Oracle applications, IBM applications, and so forth) or the intricate details of back-end systems .","Each of XML-based and JSON-based formats  and  provides a normalized and common format between various back-end systems  and front-end systems  in desktop computers, browsers, and mobile devices. Additionally, each of XML-based and JSON-based formats  and  enables communication using minimal characters in order to keep transmission messages small in size. This feature is particularly useful in mobile phone communications where successful communication depends on the quality of signals.","Each of XML-based and JSON-based formats  and  is \u201cself-contained\u201d in terms of 1) retaining business knowledge to not only extract the correct data from various back-end systems  but apply business logic  and simple mathematical rules, 2) containing the technical knowledge to know where to send requests  and using which connection parameters , 3) encompassing technical and business knowledge in one place so that other systems understand XML-based and\/or JSON-based formats  and\/or , and 4) encompassing responses from various back-end systems  into a common and compact format for various user interfaces across various front-end systems  in order to understand and display the notifications.","XML-based format  combines the features of extensible markup language (XML) with structured query language (SQL). As is well known, XML is a set of rules for encoding documents in machine-readable form. XML emphasizes simplicity, generality, and usability over the Internet. SQL on the other hand is an industry-standard language for creating, updating, and querying relational database management systems.","A conventional XML-based language format is typically used for long-distance or Internet communications. It is also typically used for transmitting data with medium to large record sets. However, a conventional XML-based language format cannot extract business data from an enterprise system, e.g., back-end system , let alone a disparate set of enterprise systems with different formats and syntax. In contrast, a conventional SQL-based language format is useful for system interactions around business data. That is, it is typically used for business data extractions and\/or updates into business systems and\/or databases. However, a conventional SQL-based language format is not built for long distance communication, especially across the Internet and across disparate enterprise systems. In particular, it lacks the ability to handle communication data and protocols required for data communications over the Internet.","XML-based format  allows long-distance data communication across the Internet between disparate systems. In addition, XML-based format  allows business communication for data extractions and data updates to and from disparate enterprise systems.","As illustrated in chart , the general structure of XML-based format  roughly follows an XML standard. For example, elements within XML-based format  are written with a start tag and an end tag, with the content in between. Typically tags are composed of the name of the element surrounded by angle brackets, e.g., \u201c<AQL>\u201d. In addition, all tags should have a beginning tag with parentheses \u201c< >\u201d and end with an ending tag with a forward slash within parentheses \u201c<\/>,\u201d e.g. \u201c<\/AQL>.\u201d The term \u201cAQL\u201d refers to API (application programming interface) Query Language. \u201cAQL\u201d is the generalized nomenclature used herein for XML-based format  and JSON-based format  for querying back-end applications . AQL is desirably a reserved word that is not used elsewhere.","<AQL>message<\/AQL> defines the message structure of XML-based format , the contents of which will be generated by input from one of mini-applications  as well as from manager node .","A URL tag , <URL>connectionparameters<\/URL>, provides connection parameters  for one of back-end systems , such as SAP, Oracle, Infor, and also includes web services and cloud applications, databases, and so forth. \u201c<URL>\u201d signifies the start of the value and \u201c<\/URL>\u201d signifies the end of the value. Desirably, \u201cURL\u201d is a reserve word that should not be used elsewhere. The various tags, format and permissible values for connection parameters include, for example:","Protocol:\/\/hostname:port\/contextname?parametername=parametervalue","where:","\u201c:\/\/\u201d \u201c?\u201d and \u201c=\u201d are syntax elements in the communication parameters","\u201cProtocol\u201d refers to the various permissible values for protocol. These permissible values include 1) http: to connect to application using the HTTP protocol; 2) https: to connect to applications using HTTPS (Secure) protocol; 3) SAP: to connect to SAP applications using SAP's Proprietary interfaces; 4) ORA: to connect to Oracle Applications using Oracle's proprietary interfaces; 5) JDE: to connect to JDE (JK Edwards) applications using JDE's proprietary interfaces; 6) I2: to connect to I2 (i2 Technologies) applications using I2's proprietary interfaces; 7) MSFT: to connect to MicroSoft applications using MicroSoft's .Net and other proprietary interfaces; 8) NetERP: to connect to NetSuite ERP using its interface methodologies; 9) SFCOM: to connect to SalesForce.com applications; and 10) MSSQL: to connect to MicroSoft SQL Databases. It should be understood that this list of permissible protocol values can be expanded as required.","\u201chostname\u201d refers to the hostname of one of back-end systems  to be connected. This is typically a www address and is to be used for http protocols, HTTPS protocols, web-services, and so forth.","\u201cport\u201d refers to the port number of the host to be connected. This is typically used in HTTP, HTTPS or web services.","\u201ccontextname\u201d refers to the home-page or link that may be executed after connecting to back-end system .","\u201cparametername\u201d is the name of the parameter to be passed on to the system. These could be authentication parameters or business application parameters.","\u201cparametervalue\u201d is the value to be passed for the parameter name. These could be either authentication values or business application values for parameters.","Examples of connection parameters  are:",{"@attributes":{"id":"p-0109","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"http:\/\/www.hostname.com:50000\/contextName?UserId=user1&Pass"},{"entry":"\u2003\u2003word=passvalue&Customer=10023"},{"entry":"SAP:\/\/?RFCDestination=SEALERP&userid=user1&password=passvalue"},{"entry":"\u2003\u2003&Customer=10023"},{"entry":"SAP:\/\/sealerp.sealconsult.com?SYSNO=00&SYSID=ERP&Userid=use"},{"entry":"\u2003\u2003r1&Password=Passvalue"},{"entry":"MSSQL:\/\/?JNDI=JNDIname&userId=user1&password=passvalue"},{"entry":"ORA:\/\/AppServername?userid=user1&Password=passvalue"},{"entry":"JDE:\/\/Appservername?uesrid=user1&Password=passvalue"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A QUERY tag , <QUERY>businesslogic<\/QUERY> substantially encompasses business logic  to extract information content  from source applications of back-end systems , and to apply filters and business rules to it. Query tag  contains all details about input fields, output fields and all the business logic  to be applied. Business logic  is defined using statements, functions, operators and clauses of XML-based format . The details of business logic  will be discussed in connection with .","A ROWS tag , <ROWS>response<\/ROWS> is used to capture responses  from a source application at one of back-end systems , apply business rules, and\/or forward response  to front-end systems . <ROW> <\/ROW> denotes the row of the output from an application at one of back-end systems . <Fieldname>Fieldvalue<\/Fieldname> denotes the fieldname and value coming from the source application at one of back-end systems .","Different parts of request  in XML-based format  may be generated by different elements within system , including mini-applications , manager node , and\/or access node . A complete request  in XML-based format  is not generated nor used by only one element or component of system . Rather, the complete request  is generated by multiple elements of system .",{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 7","b":["700","314","320","602","700","314","606","314","702","704","706","708","602"]},"Statements  are used to specify operations, API for a particular back-end application , input & output fields, data manipulation, and so forth. Statements  of XML-based format  include a SELECT statement, a FROM statement, a WHERE statement, an OPERATION statement, a GROUPBY statement, an ORDERBY statement, a LIMIT statement, a UNION statement, and a CONDITION statement.","The SELECT statement  is used to select information content  from a particular back-end application  within back-end system . Output fields  would be listed under the SELECT statement . This SELECT statement  is generated by mini-application  when the query data  is created. Output fields  could be generic fieldnames and need not be specific fieldnames for one of back-end applications  of back-end system . For example, a fieldname could be named \u201cCustomer_No\u201d in an Application-A, and named \u201cAccount\u201d in an Application-B, but the mini-application  could use a generic field-name called \u201cCustomer\u201d. Manager node  converts generic fieldnames to back-end system  specific fieldnames while applying business logic . Output fields are separated by a delimiter, such as a comma, for example, \u201cSELECT customer, contact, phone.\u201d","The FROM statement  is used to specify the API of the source enterprise application at a back-end system . FROM statement  is generated by manager node  and is appended to query data  received from front-end system  executing mini-application , for example, \u201cFROM BAPI_FIND_CUSTOMER_ADDRESS.\u201d","The WHERE statement  specifies the conditions  for data selection. In an embodiment, mini-application  executing at front-end system  would capture input fields from end-user  and generate WHERE statement . The input fields could be generic fieldnames and need not be specific fieldnames for one of back-end applications  of back-end system . For example, a fieldname could be named \u201cID\u201d in application-A, and could be named \u201cIdentifier\u201d in Application B, but the mini-application  could use a generic field-name called \u201cId\u201d. Manager node  converts generic fieldnames to back-end system  specific fieldnames while applying business logic , for example, WHERE Id=101.","The OPERATION statement  is used to specify the execution operation on back-end application . Operation statement  desirably takes precedence over SELECT statement  when it is executed. In one embodiment, the permissible and valid values for OPERATION statement are \u201cSELECT,\u201d \u201cINSERT,\u201d \u201cUPDATE,\u201d and \u201cDELETE.\u201d SELECT specifies that a SELECT operation is to be executed to extract data. \u201cINSERT\u201d specifies that an INSERT operation is to be executed to insert a new record into back-end application . UPDATE specifies that an UPDATE operation is to be executed at back-end application . DELETE specifies that a DELETE operation is to be executed at back-end application .","These OPERATIONS are executed in conjunction with the SELECT Statement  above. As an example, end-user  may want to approve a Purchase-Requisition that in turn creates a Purchase-Order in the back-end application . The end result for end-user  would be to see a Purchase-Order number as a confirmation of Purchase-Requisition Approval. In this case, two operations can be executed in back-end application . The first operation is to create a Purchase-Order and the second operation is to extract the purchase order created and display it at display  as a confirmation. In this case, the system would execute the OPERATION \u201cINSERT\u201d first to create a purchase order and execute the \u201cSELECT\u201d statement to extract the purchase order as a confirmation for the user, for example, OPERATION INSERT.","The GROUPBY statement  groups the output by the fieldname and sums up the result by the same fieldname, for example, GROUPBY customer.","The ORDERBY statement  is used to sort the output result by the fieldname. The sorting could be done ascending or descending. Ascending is given by \u201cASC\u201d and descending is done by \u201cDESC,\u201d for example, ORDERBY Customer ASC|DESC.","The LIMIT statement  is used to limit the number of records in the output. Information content  eventually goes to front-end system  executing mini-application , and mini-applications  typically cannot handle large amounts of data. Accordingly, the LIMIT statement  is used to limit the number of records, for example LIMIT .","The UNION statement  is used to join\/combine output results from two disjoint SELECT statements, for example, UNION SELECT fieldname FROM API_name Where Fieldname=Fieldvalue.","The CONDITION statement  is used to specify clauses . These clauses  can be used with other statements , for example, CONDITION IF fieldname>fieldvalue THEN SELECT . . . FROM . . . ELSE SELECT . . . FROM . . . .","The EXCEPTIONS statement  is used to specify the error handling logic during the generation or execution process.","Functions  are specific operations applied to data after extraction from back-end systems . Functions are typically used within clauses. Some of functions  included in XML-based format  are a SUM function, a SUBTRACT function, a COUNT function, an AVERAGE function, a MAX function, and a MIN function.","The SUM function  returns a sum of the values included. The syntax is SELECT SUM{{output_field}, {output_field}}. The SUBTRACT function  subtracts one value from another value. The syntax would be SELECT SUBTRACT {{output_field}, {output_field}}. The COUNT function  counts and returns the number of rows from the resultset. The syntax would be SELECT COUNT{output_field}. The AVERAGE function  gives an average of the resultset. The syntax would be SELECT AVERAGE{output_field}. The MAX function  returns the maximum value of the resultset. The syntax would be SELECT MAX{output_field}. The MIN function  returns the minimum value of the resultset. The syntax would be SELECT MIN{output_field}.","Clauses  are used to apply conditions and loops. Clauses  are either conditional statements or repeating statements that can be applied to statements. Clauses  include IF-THEN-ELSE, CASE-WHEN-THEN-ELSE, LOOP-UNTIL, WHILE-LOOP-END, and FOR-LOOP-END.","The IF-THEN-ELSE clause  checks a Boolean value or expression and if true, executes the statements in the THEN clause. If the condition is false, the statements in the THEN clause are skipped and statements after the ELSE clause is executed. The expression that is checked must return a true or false. It can be a simple Boolean variable or a compound expression joined with AND\/OR clauses.","The CASE-WHEN-THEN-ELSE clause  is an extension of IF-THEN-ELSE clause  where multiple and complex conditions may have to be checked. It prevents the repetition of IF-THEN-ELSE clauses  for complex and repetitive conditions.","The LOOP-UNTIL clause  tests a condition at the end of a loop. In other words, it executes the statements at least once before testing the condition and then will keep executing the loop until the condition is satisfied.","In the WHILE-LOOP-END clause , the WHILE portion tests a condition at the start of the loop, and it executes the code after the LOOP portion if the condition is true. If the condition is false, the execution never happens.","In the FOR-LOOP-END clause , the FOR portion executes the statements after LOOP for the times mentioned in the FOR portion of the clause. It automatically increments a counter and executes the number of times mentioned in the FOR portion.","Operators  are used to apply mathematical operators and are typically used within statements  or clauses  to link two fields. Operators include AND operator, OR operator, BETWEEN operator, IN operator, \u201c=\u201d equal-to operator, \u201c>\u201d greater-than operator, \u201c<\u201d less-than operator, \u201c< >\u201d not-equal-to operator.","The AND operator  means both of the conditions are satisfied, for example {Condition-} and {Condition-}. The OR operator  means either one of the conditions is satisfied, for example, {Condition-} or {Condition-}. The BETWEEN operator  means the selection is of a field-value between two given values, for example, {Column_name} BETWEEN {Value-, Value-). The IN operator  means the selection is for values given after the IN operator , for example, {Column_name} IN {Value-, Value-). The \u201c=\u201d operator , the \u201c>\u201d operator , the \u201c<\u201d operator , and the \u201c< >\u201d operator  are self-explanatory.","Statements  can be used independently or in relation\/conjunction with other statements . Statements  can also be interrelated and depend on one another to build business logic . In contrast, functions  are always applied to a specific dataset and are not interrelated. Clauses  are typically used to apply repeating or conditional logic. Operators  are used with clauses  or functions  to link them. Desirably, statements , functions , clauses , and operators  used in QUERY tag  are reserve words.",{"@attributes":{"id":"p-0137","num":"0136"},"figref":"FIG. 8","b":["800","802","318","320","108","124","126","602","802","602","802"]},"JSON-based format  is built on two structures. These two structures include a collection of name\/value pairs and an ordered list of values. The collection of name\/value pairs is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array in various languages. The ordered list of values is realized as an array, vector, list, or sequence in various languages.","Like XML-based format , JSON-based format  includes a URL tag  that provides connection parameters  for one of back-end systems  and a QUERY tag  that substantially encompasses business logic  to extract information content  from source applications of back-end systems , and to apply filters and business rules to it. JSON-based format  additionally includes a RESPONSE tag  that is used to capture responses  from back-end application  at one of back-end systems , apply business rules, and\/or forward response  to front-end systems .",{"@attributes":{"id":"p-0140","num":"0139"},"figref":"FIG. 9","b":["900","314","320","802","900","314","806","602","314","902","904","906","908","802","902","904","906","908","602"]},{"@attributes":{"id":"p-0141","num":"0140"},"figref":["FIGS. 10A and 10B","FIGS. 10A and 10B"],"b":["1000","102","1000","102","108","124","126"]},"Information exchange process  commences with a task . At task , mini-application  is executed at front-end system . Mini-application  initiates generation of request  by outputting query data  from front-end system  over link  to manager node . For illustrative purposes, query data  is in XML-based format  and includes output field(s)  and condition(s) .","A task  is performed in connection with task . At task , manager node  receives query data .","Next, manager node  validates query data  at a query task . Validation may entail verifying a user identifier  and other identification markers associated with query data . When manager node  determines at query task  that query data  and\/or user identifier  are invalid process control proceeds to a task . At task , an error handling routine may be initiated to record the invalidated query data . Following task , information exchange process  exits.","However, when manager node  validates query data  and user identifier  at query task , process control proceeds to a task . At task , manager node  generates one or more requests  in XML-based format  and applies business logic  and connection parameters , as previously discussed.","Information exchange process  continues with a task . At task , manager node  identifies the appropriate access node or nodes  to which the one or more requests  are to be communicated using connection parameters  applied to each request .","Following task , a task  is performed. At task , manager node  communicates the one or more requests  to the appropriate access nodes  in accordance with connection parameters .","In response to task , a task  is performed. At task , access node  receives request  in XML-based format . Task  and subsequent related tasks will discuss operations at a single access node  and a single back-end system  for simplicity of illustration. It should be understood, however, that manager node  may have communicated multiple requests  to disparate access nodes , all of which are to be processed in order to obtain the requested information content .","Following task , process  continues with a task . At task , access node  converts request  into an API format specific to one of back-end applications  to be accessed. Conversion may entail separating request  into multiple discrete operations , in accordance with an API to be used to access one of back-end applications .","In response to task , a task  is performed. At task , access node  conveys a next discrete operation  to back-end system . Of course, during a first iteration of task , the \u201cnext\u201d discrete operation  will be a first operation . Operation  is conveyed to back-end system  as a query in a format, or language, specific to back-end application  to be accessed.","Process  continues with a task . At task , access node  obtains a next discrete response  in response to operation . Again, during a first iteration of task , the \u201cnext\u201d discrete response  will be a first response .","Next, at a task , access node  at least temporarily stores response .","Information exchange process  continues with a query task . At query task , access node  determines whether there is another discrete operation  to be executed. When a determination is made that there is another discrete operation , program control loops back to task  to convey the next discrete operation  to back-end system and obtain the next discrete response . However, at query task , when all calls have been made to back-end system  and there are no further operations , information exchange process  proceeds to a task . Note that process  continues on FIB B with task .","At task , access node  forms response  containing information content  from the multiple discrete responses . Forming response  entails converting the information contained in responses  to XML-based format .","Next, at a task , access node  transfers response  to manager node  in XML-based format .","Process  continues with a task . At task , manager node  receives \u201cnext\u201d response  in XML-based format . It should be recalled that manager node  may have generated more than one request  at task  in order to obtain the desired information content . Thus, manager node  may be awaiting more than one response  from more than one access node . Accordingly, during a first iteration of task , the \u201cnext\u201d response  will be a first response .","Upon receipt of response  at task , a task  is performed. At task , manager node  at least temporarily retains response .","Next at a query task , manager node  determines whether another response  is to be received. Again, manager node  may have generated and communicated more than one request  to access nodes . When receipt of another response  is expected, program control loops back to task  to receive and process another response . However, when no further responses  are expected at query task , process  continues with a task .","At task , manager node  filters, combines, or otherwise processes responses  to obtain information content .","Next at a task , manager node  transfers information content  in XML-based format  to mini-application  executing on front-end system .","Information exchange process  continues with a task . At task , through the execution of mini-application  and implementation of display logic , front-end system  converts information content  to notification . Of course, notification  can be any display format, such as full screen display, pop-up message, or visual notification, that is considered optimal for the particular front-end system  on which it will be displayed.","Next, at a task , information content , for example, an event occurring at back-end system , is provided to end-user  on display  as notification  of the particular event.","Process  continues with a query task . At query task , a determination is made at front-end system  by end-user  as to whether the end-user  is to disposition, i.e., make some decision, about the event. When end-user  need not make some decision about the event, information exchange process  ends for that particular instance of information exchange. Such a situation can arise, when end-user  need only be kept informed of certain events taking place within back-end applications  of back-end system , but need not take action regarding those events.","However, when end-user  is to make some decision about the event, process  continues with a task . At task , end-user  dispositions the event. In an embodiment, execution of disposition mini-application  may be initiated by end-user  or by query mini-application  to enable the transfer of disposition data back to a particular back-end application  within one of back-end systems . That is, XML-based and JSON-based formats  and , respectively, readily accommodate the input of disposition data back to back-end application  in order to update information content  stored in back-end system . Following task , process  ends for that particular instance of information exchange.",{"@attributes":{"id":"p-0165","num":"0164"},"figref":"FIG. 11","b":["1100","102","1100","1050","1000","114","425"]},"Event disposition process  begins with a task . At task , one of mini-applications  (e.g., disposition mini-application ) receives a disposition response (DR)  from end-user . In an example, end-user may approve or disapprove a particular purchase order. Although, it should be understood that disposition response  could be any decision required for any possible event envisioned.","Next at a task , disposition response  is sent from front-end system  to manager node  in a standardized format , e.g., XML-based format  or JSON-based format .","Following task , manager node  receives disposition response , processes disposition response  to generate a disposition request  with applied business logic (BL)  and connection parameters (CP) .","Next, at a task , manager node  identifies the appropriate access node  from the applied connection parameters  and communicates disposition request  containing disposition response  to the identified access node  in standardized format .","Event disposition process  continues with a task . At task , access node  receives disposition request  in standardized format . Access node filters, converts, or otherwise processes disposition request  to a different format, e.g., an API that is specific to back-end application  within back-end system  with which access node  is associated.","A task  is performed in connection with task . At task , access node  conveys disposition response  to back-end application  in the form and format suitable for the particular back-end application . Thus, disposition response  can be used at back-end application  to update information content  associated with back-end application . Following task , event disposition process ends for that particular instance of updating information content.","Although not expressly shown, a response  from access node  to front-end system  via manager node  may optionally be sent in order to inform end-user  of the update to information content .",{"@attributes":{"id":"p-0173","num":"0172"},"figref":"FIG. 12","b":["1200","102","1200"]},"Purchase order review process  begins with a task . At task , query data  is initiated for current purchase orders in XML-based format . Statements , in XML-based format , to be used include \u201cSELECT\u201d and \u201cWHERE.\u201d Query data  may be output by front-end system  to manager node  through execution of one of mini-applications . Alternatively, manager node  may include some form of a mini-application  that periodically provides query data .","Next, at a task , manager node  applies business logic  and connection parameters  to query data  in order to generate request . Statements, in XML-based format , to be used include <URL>Connection parameters<\/URL>, FROM statement , LIMIT statement , GROUPBY statement , and ORDERBY statement .","Following generation of request  at task , a task  is performed. At task , manager node  communicates request  to access node  in XML-based format .","At a task  performed in response to task , access node  executes request  and extracts response  from back-end system in a particular API format .","Next at a task , access node  converts the extracted response  to XML-based format .","Process  continues with a task . At task , access node  transfers response  in XML-based format  to manager node . Statements, in XML-based format , to be used include <ROWS>PURCHASE ORDER(S)<\/ROWS>.","Next, a task  is performed. At task , manager node filters response  to obtain information content , namely, PURCHASE ORDER(S).","In response to task , a task  is performed. At task , manager node  transfers information content , namely PURCHASE ORDER(S) to front-end system .","Following task , a task  is performed at front-end system . At task , notification  of PURCHASE ORDER(S) is displayed on display . Following task , process  ends for this particular instance of information exchange.","In summary, the present invention teaches of methodology and a system for facilitating the exchange of information content between a back-end system contained in a restricted access environment and a front-end system outside of the restricted access environment. Embodiments of the invention facilitate the transfer of business data quickly and easily between multiple source enterprise applications of the back-end systems and various front-end systems. Embodiments include mini-applications that execute on any of a variety of front-end systems, a manager node that provides integration, security, usage, and data services between the mini-applications and back-end applications operating on back-end systems via access nodes. The access nodes reside within the restricted access environment and are responsible for communicating with source systems, e.g. the back-end applications operating on the back-end systems. In addition, the access nodes enable access to any business functionality within SAP enterprise systems via the SAP business function enabler. A standardized format, also called an API query language herein, provides a business language for any front-end system, and eliminates the need to store any business data outside the back-end systems. Furthermore, the API query language is \u201clean\u201d for communications between the front-end systems, manager node, and access node, and enables the receipt of business data in minimal communication traversals. In addition, embodiments of the invention enable continual access to, and ability to update information content at, business applications, thereby improving business productivity.","Although the preferred embodiments of the invention have been illustrated and described in detail, it will be readily apparent to those skilled in the art that various modifications may be made therein without departing from the spirit of the invention or from the scope of the appended claims. For example, the process steps discussed herein can take on great number of variations and can be performed in a differing order then that presented."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A more complete understanding of the present invention may be derived by referring to the detailed description and claims when considered in connection with the Figures, wherein like reference numbers refer to similar items throughout the Figures, and:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 8","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIGS. 10A and 10B","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 11","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 12","FIG. 1"]}]},"DETDESC":[{},{}]}
