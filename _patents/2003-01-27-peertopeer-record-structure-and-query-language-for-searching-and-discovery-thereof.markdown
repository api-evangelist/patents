---
title: Peer-to-peer record structure and query language for searching and discovery thereof
abstract: A simple record query language (SRQL) is a generic record meta-data query solution that can natively describe the information contained in a record and search each against it to find records whose meta-data matches a particular set of criteria. SRQL includes both a record data structure that includes searchable SRQL attributes that describe the record, and queries that are able to search the attributes. The attributes are an XML node that exists in the record header itself. There are two types of queries, to wit local to find records in the local data store, and distributed to find records that may be stored in a neighbor's data store. As such, SRQL finds particular applicability to peer-to-peer networks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07139760&OS=07139760&RS=07139760
owner: Microsoft Corporation
number: 07139760
owner_city: Redmond
owner_country: US
publication_date: 20030127
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["Ser. No. 09\/942,164, entitled Peer-To-Peer Name Resolution Protocol (PNRP) And Multilevel Cache For Use Therewith, filed on Aug. 29, 2001; Ser. No. 10\/122,863, entitled Multi-Level Cache Architecture and Cache Management Method for Peer-To-Peer Name Resolution Protocol, filed Apr. 15, 2002; Ser. No. 09\/955,923, entitled Peer-To-Peer Group Management and Method For Maintaining Peer-To-Peer Graphs, filed on Sep. 19, 2001; Ser. No. 09\/956,260, entitled Peer-To-Peer Name Resolution Protocol (PNRP) Security Infrastructure And Method, filed on Sep. 19, 2001; Ser. No. 09\/955,924, entitled Peer-To-Peer Name Resolution Protocol (PNRP) Group Security Infrastructure and Method, filed on Sep. 19, 2001; Ser. No. 10\/309,865, entitled Peer-To-Peer Graphing Interfaces and Methods, filed on Dec. 4, 2002; Ser. No. 10\/309,864, entitled Peer-To-Peer Identity Management Interfaces And Methods, filed on Dec. 4, 2002; Ser. No. 10\/351,905, entitled Peer-To-Peer Grouping Interfaces and Methods, filed January 27, 2003.","The present invention relates generally to peer-to-peer network records and the discovery thereof, and more particularly to peer-to-peer record structures and application programming interfaces that provide local and distributed peer-to-peer record searching and discovery in a peer-to-peer network.","Various communication technologies on the Internet allow users with common interest to collaborate, share files and other data records, chat with one another, multi-cast audio and video for presentations and group meetings, and engage in multi-player gaming. Currently, however, most communication and record sharing on the Internet takes place in a server centric environment whereby all communication flows to or through large central servers to which individuals may connect to join and participate in such communication.","With the reemergence of peer-to-peer technology, the current server centric model of Internet communication and record sharing is quickly being replaced. Indeed, peer-to-peer technologies enable users to contact one another and share records in a serverless environment, free from the constraints of server based Internet communication. In a peer-to-peer based system, a user's anonymity and privacy may be maintained since communication occurs directly between peers within the network.","Peer-to-peer communication, and in fact all types of communication, depends on the possibility of establishing valid connections between selected entities or nodes. These entities or nodes may be peers (e.g., users or machines) or groups formed within a peer-to-peer network. The connections between the nodes form the peer-to-peer graph that enables communication and information to be passed to and between the nodes. The nodes typically have assigned a stable name. Each peer is found within the peer-to-peer cloud by resolving this name to a current address when a connection is needed.","Because peer-to-peer networks are formed as a graph of distributed users or peers, it is necessary that communication be passed from one peer to another before all peers within a network may become cognizant of the shared information. In a typical peer-to-peer infrastructure nodes in a graph share such data via structured packets called records. Records can contain any kind of data imaginable from chat messages to pointers to files. However, while some information is shared between peers as a matter of course, a vast majority of information available from the peers is not shared until and unless a peer requests that information. Such a request is embodied in a search query for the record from a neighbor peer.","However, in order for a search to converge to the desired information, the query must somehow adequately identify the desired record stored in the neighbor peers data store. Unfortunately, a record in its base form inherently does not provide any mechanism by which to mark up and describe through meta-data the contents of the record to allow an intelligent query to locate it. Further, because peer-to-peer infrastructures are distributed systems, there is an ever present need to manage the amount of data and meta-data replicated amongst nodes in a graph. Replicating large amounts of meta-data to each node is not an option in today's bandwidth constrained networking infrastructure. Thus the size of the meta-data describing the record's contents needs to be appropriate. Further, there is currently no standard way of describing the contents of a record. As such, the success of any record search query for a particular record or type of record is not well defined. Similarly, if the search is successful, the number of records found that are returned often swamps or overwhelms the actual record content sought.","There exists, therefore, a need in the art for a peer record structure and method for describing the record content and a simple record query language that may be used to construct queries for specific records and record types.","The inventive concepts disclosed in this application involve a new and improved peer-to-peer record data structure and simple record query search language (SRQL) that enables simple yet power searching for specified records. More particularly, the present invention presents a generic record meta-data solution that can describe the information contained in a record. This meta-data can then be queried against to find records whose meta-data matches a particular set of criteria.","In one embodiment of the present invention, the data structure of the peer-to-peer records includes an SRQL attributes data XML node that exists in the record header itself. This XML provides the developer a place to provide an attribute name, type, and value. A record can have 0\u2013N attribute elements inside of a given attributes complex type. In one embodiment of the invention, there are three basic attribute types: string, int, and date where date follows the guidelines set by the W3C. However, in other embodiments of the invention, all existing and not yet existing types could be specified in a type field. Preferably, the record data structure of a record including the SRQL attributes of the present invention includes the record header field, the SRQL attributes field, and the record data itself.","In addition to the data structure of the peer records, the present invention provides the actual query able to search SRQL attributes. A SRQL query is able to function in multiple manners. The first manner is a strict matching query that allows an application to search based on one particular SRQL attribute. The second manner in which an SRQL query can function is by grouping together clauses via logic operators (ex. AND and OR). This enables developers to create complex and powerful queries in an easy and intuitive manner. Though only two simple logic functions are given in the example above, the preferred embodiment of the invention covers any logic operation in existence today or in the future. In addition to logic operator support, SRQL allows for different comparison mechanisms, such as equal, not equal, less or equal, greater or equal, greater, less, etc. SRQL also allows for the use of wildcards for non-exclusive searching. This means that a query could be made to find all records of a certain type. The SRQL is protocol independent and could be used in other protocols or products.","In one embodiment of the present invention, application programming interfaces (APIs) are provided that provide all of the support necessary for applications to both local and distributed searches of the group database for the queried records. The local searching API preferably resides at the same layer as other record management APIs, and provides the methods to retrieve individual records, iterate over all records or a certain type, etc., as well as actually querying the database. If the record sought does not exist in the local database, the search query is distributed to a neighbor via the graphing APIs. The neighbor then uses the query to perform a local search for the record on its local database. If the record is found, the neighbor sends a search results record back to the requesting peer. The requesting peer may then select which records from the results it would like to download to its local database from the neighbors who have the sought after records.","While the invention will be described in connection with certain preferred embodiments, there is no intent to limit it to those embodiments. On the contrary, the intent is to cover all alternatives, modifications and equivalents as included within the spirit and scope of the invention as defined by the appended claims.","Turning to the drawings, wherein like reference numerals refer to like elements, the invention is illustrated as being implemented in a suitable computing environment. Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed by a personal computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Associate (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during startup, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers hereto illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through a output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network member, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computer, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.","As introduced above, the success of a peer-to-peer (P2P) protocol depends on the protocol's ability to establish valid connections between selected entities and to find and share information and records within the peer-to-peer cloud. Likewise, the formation of groups in such a P2P network relies on this ability. Because a particular user may connect to the network in various ways at various locations having different addresses, a preferred approach is to assign a unique identity to the user or the group, and then resolve that identity to a particular address or addresses through the protocol. Such a peer-to-peer name resolution protocol (PNRP) to which the simple record query language (SRQL) and method of the instant invention finds particular applicability, although by which the present invention is not limited, is described in co-pending application Ser. No. 09\/942,164, entitled Peer-To-Peer Name Resolution Protocol (PNRP) And Multilevel Cache For Use Therewith, filed on Aug. 29, 2001, in co-pending application Ser. No. 10\/122,863, entitled Multi-Level Cache Architecture and Cache Management Method for Peer-To-Peer Name Resolution Protocol, filed Apr. 15, 2002, and in co-pending application Ser. No. 09\/955,923, entitled Peer-To-Peer Group Management and Method For Maintaining Peer-To-Peer Graphs, filed on Sep. 19, 2001, the teachings and disclosure of which are hereby incorporated in their entireties by reference thereto.","However, one skilled in the art will recognize from the following teachings that the SRQL and methods of the present invention are not limited to the particular peer-to-peer protocol of these co-pending applications, but may be applied to other resolution and grouping protocols with equal force. Likewise, co-pending application Ser. No. 09\/956,260, entitled Peer-To-Peer Name Resolution Protocol (PNRP) Security Infrastructure And Method, filed on Sep. 19, 2001 describes an underlying security infrastructure that ensures that the identities of the various entities within the network are valid, without unnecessary burdening the network with excess traffic. In the P2P grouping environment, co-pending application Ser. No. 09\/955,924, entitled Peer-To-Peer Name Resolution Protocol (PNRP) Group Security Infrastructure and Method, filed on Sep. 19, 2001, describes the underlying security infrastructure used for such groups. The teachings and disclosure of these applications are also incorporated in their entireties by reference thereto. However, while the SRQL and methods of the present invention find particular applicability to and interaction with such PNRP, one skilled in the art will recognize that the present invention is not limited thereby, but has applicability to any P2P system or protocol that desires to provide a generic record meta-data structure and query system to find peer records.","As discussed in the above-incorporated co-pending application describing the PNRP, and to provide some useful background, establishing peering relations between individual peers is an expensive process in existing peer-to-peer networks. In the PNRP, however, each member accumulates a routing table that contains a list of references to other members in the network. For each member entry, address information, which may include a member identification, address, the key of the member, and the distance between the key of this member and the key of the local member are obtained. Each time the local member learns about a remote member, it checks whether the member is already known, and if not whether to enter an entry in the routing table.","To find a particular record in PNRP that is not resident in that member's local data store, it sends a record query to a member in its local cache. When that member receives a query for a record that it does not have, that member searches for the entry or record in its routing table whose key best matches the target. The query is then forwarded directly to the member that advertised the entry or record. If there is no adequate entry or record in its data store, the request is sent back to the member from whom the request was received; this member will try another neighbor in its own routing table. The request is successful if it reaches a member that has an entry or record whose key matches the target. It is unsuccessful if the target is not reached in the maximum number of steps, or if the member from whom the request was received tries all possible neighbors and receives a negative response. In the case of successful requests, the response is relayed by all intermediate hops. It carries the address of the member that held the target key, and this entry can be inserted in the routing tables of the intermediate members. Unfortunately, while PNRP and other peer-to-peer protocols define how queries are routed between the members of the peer cloud, it provides no adequate mechanism to actually search the data store for a particular record.","However, actually being able to find resources in a group is essential to the peer-to-peer user experience. In a peer-to-peer infrastructure such as that discussed above and in the co-pending applications, nodes in a graph share data via structured packets called records. Records can contain any kind of data imaginable from chat messages to pointers to files. The manner in which the data is distributed is key in determining the method of search. If each node has a copy of all the data, then the search can be conducted locally. If the data is distributed, a distributed search needs to be issued. Unfortunately, a record in its base form inherently does not provide a mechanism by which to mark up and describe through metadata the contents of the record. Recognizing this, the system and methods of the present invention provide a generic record meta-data solution that can describe the information contained in a record. In addition, the meta-data can be queried against to find records whose meta-data matches a particular set of criteria. This record meta-data\/query solution is the Simple Record Query Language (SRQL) of the present invention. This SRQL provides an asynchronous keyword\/attribute search for both local and distributed record searching. To reduce the network and peer resources utilized in one embodiment, the results of the search will be records corresponding to the data, not the data itself.","There are two key requirements that must be observed in a peer-to-peer network. The first is data size. Because, a peer-to-peer infrastructure is a distributed system, there is an ever present need to manage the amount of data and meta-data replicated amongst nodes in a graph. Replicating large amounts of meta-data to each node is not an option in today's bandwidth constrained networking infrastructure. Thus the size of the meta-data describing the record's contents needs to be appropriate. The second requirement is industry alignment. That is, the meta-data needs to be described via a common mechanism that allows developers to use pre-existing tools in order to utilize the meta-data associated with a record. After careful consideration, it was decided that the basis of the query language would be XML. However, this presents a problem as all other XML query mechanisms are relatively cumbersome and not able to satisfy the size requirement placed on the infrastructure.","Essentially, there are two main aspects of the Simple Record Query Language (SRQL) of the present invention resulting from these considerations. The first is the attributes data XML node  that exists in the record header  of the record  itself to describe the record data . This XML provides the developer a place to provide an attribute name, type, and value. As an example of attributes that may be included and on which the SRQL queries can be run, the record ID (unique identifier of the record), the record type (the UUID value of the record type), the creator (who published the record), the modified time (the last time of modification to the record), and the last modifier ID (the last person to modify the record) are searchable. An example of such a data island is as follows:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<attributes>"},{"entry":"\u2003<attribute name=\u201cFileName\u201d type=\u201cstring\u201d>skipicture.jpg<\/attribute>"},{"entry":"<attributes>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the above example, the developer has specified the following: name as \u201cFileName\u201d the type which is \u201cstring\u201d, and the actual value which exists between the beginning and end attribute tag, which is \u201cskipicture.jpg\u201d.","A record can have 0\u2013N<attribute>elements inside of a given <attributes>complex type. In one embodiment of the invention, there are three basic attribute types: string, int, and date, where date follows the guidelines set by the W3C. However, in one embodiment of the invention, all types could be specified in the \u201ctype\u201d field. The following schema represents an exemplary implementation of this aspect of SRQL:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d encoding=\u201cutf-8\u201d ?>"]},{"entry":[{},"<xs:schema xmlns:xs=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\u201d>"]},{"entry":[{},"\u2003<xs:element name=\u201cattributes\u201d>"]},{"entry":[{},"<xs:complexType>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<xs:sequence>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<xs:element name=\u201cattribute\u201d type=\u201cattribute\u201d"]},{"entry":[{},"minOccurs=\u201c0\u201d maxOccurs=\u201cunbounded\u201d \/>"]},{"entry":[{},"\u2003<\/xs:sequence>"]},{"entry":[{},"\u2003<\/xs:complexType>"]},{"entry":[{},"\u2003<\/xs:element>"]},{"entry":[{},"\u2003<xs:complexType name=\u201cattribute\u201d>"]},{"entry":[{},"<xs:simpleContent>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<xs:extension"]},{"entry":[{},"base=\u201cxs:string\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<xs:attribute name=\u201cname\u201d type=\u201cxs:string\u201d \/>"]},{"entry":[{},"<xs:attribute name=\u201ctype\u201d type=\u201cxs:string\u201d \/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/xs:extension>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/xs:simpleContent>"]},{"entry":[{},"\u2003<\/xs:complexType>"]},{"entry":[{},"\u2003\u2003<\/xs:schema>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"To utilize the SRQL attributes, the SRQL of the present invention allows peers to construct queries that are able to search the attributes and find the desired records. A SRQL query is able to function in multiple manners. The first manner is a strict matching query that allows an application to search based on one particular SRQL attribute. Given the following SRQL attributes:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<attributes>"]},{"entry":[{},"\u2003<attrib attribName=\u201cFileName\u201d type=\u201cstring\u201d>ski.jpg<\/attrib>"]},{"entry":[{},"\u2003<attrib attribName=\u201cFileSize\u201d type=\u201cint\u201d>123456<\/attrib>"]},{"entry":[{},"<attributes>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following SRQL query is constructed to match the file name:",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<peersearch>"},{"entry":"\u2003<clause attribName=\u201cFileName\u201d type=\u201cstring\u201d compare=\u201cequal\u201d>ski."},{"entry":"\u2003jpg<\/clause>"},{"entry":"<\/peersearch>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"This particular SRQL query would look for an attribute name=FileName, whose type=string, where FileName=skipicture.jpg.","The second manner in which an SRQL query can function is by grouping together clauses via logic operators (ex. \u201cAND\u201d and \u201cOR\u201d). This enables developers to create complex and powerful queries in an easy and intuitive manner. An example given the attributes above is as follows to match the first part of the file name and a minimum file size:",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/peersearch>"},{"entry":"\u2003<and>"},{"entry":"\u2003\u2003<clause attribName=\u201cFileName\u201d type=\u201cstring\u201d compare=\u201cequal\u201d>"},{"entry":"\u2003\u2003ski*<\/clause>"},{"entry":"\u2003\u2003<clause attribName=\u201cFileSize\u201d type=\u201cint\u201d compare=\u201cgreaterthan\u201d>"},{"entry":"\u2003\u200310000<\/clause>"},{"entry":"\u2003<and>"},{"entry":"<\/peersearch>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The above clause would search for records that contain meta-data that matches FileName=\u201cskipicture.jpg\u201d and whose FileSize is greater than 10000.","Though the embodiment of SRQL discussed above only provides two simple logic functions, one skilled in art will recognize that an embodiment of the invention includes any logic operation. In addition to logic operator support, SRQL allows for different comparison mechanisms, e.g. equal, not equal, less or equal, greater or equal, greater, less, etc. Further, SRQL also allows for the use of wildcards. This means that a query could be made to find all records of a certain type. For example:",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<peersearch>"]},{"entry":[{},"\u2003<clause attrib=\u201cFileName\u201d type=\u201cstring\u201d compare=\u201cequal\u201d>*."]},{"entry":[{},"\u2003jpg<\/clause>"]},{"entry":[{},"<peersearch>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The above query would search for all records that had a .jpg ending to value specified by the FileName attribute. Both the \u2018?\u2019 and the \u2018*\u201d characters are implemented in one embodiment, and other embodiments of the invention provide support for other such wildcards.","An exemplary schema for one embodiment of th SRQL query is as follows:",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d encoding=\u201cutf-8\u201d ?>"]},{"entry":[{},"<xs:schema xmlns:xs=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\u201d>"]},{"entry":[{},"\u2003<xs:complexType name=\u201cclause\u201d>"]},{"entry":[{},"<xs:simpleContent>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<xs:extension base=\u201cxs:string\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<xs:attribute name=\u201cattrib\u201d type=\u201cxs:string\u201d \/>"]},{"entry":[{},"<xs:attribute name=\u201ctype\u201d type=\u201cxs:string\u201d"]},{"entry":[{},"default=\u201cstring\u201d \/>"]},{"entry":[{},"\u2003<xs:attribute name=\u201ccompare\u201d type=\u201cxs:string\u201d"]},{"entry":[{},"default=\u201cequal\u201d \/>"]},{"entry":[{},"\u2003<\/xs:extension>"]},{"entry":[{},"\u2003<\/xs:simpleContent>"]},{"entry":[{},"\u2003<\/xs:complexType>"]},{"entry":[{},"\u2003<xs:complexType name=\u201cand\u201d>"]},{"entry":[{},"<xs:sequence>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<xs:element name=\u201cclause\u201d type=\u201cclause\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"maxOccurs=\u201cunbounded\u201d minOccurs=\u201c0\u201d \/>"]},{"entry":[{},"\u2003<xs:element name=\u201cor\u201d type=\u201cor\u201d maxOccurs=\u201cunbounded\u201d"]},{"entry":[{},"minOccurs=\u201c0\u201d \/>"]},{"entry":[{},"\u2003<xs:element name=\u201cand\u201d type=\u201cor\u201d maxOccurs=\u201cunbounded\u201d"]},{"entry":[{},"minOccurs=\u201c0\u201d \/>"]},{"entry":[{},"\u2003<\/xs:sequence>"]},{"entry":[{},"\u2003<\/xs:complexType>"]},{"entry":[{},"\u2003<xs:complexType name=\u201cor\u201d>"]},{"entry":[{},"<xs:sequence>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<xs:element name=\u201cclause\u201d type=\u201cclause\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"maxOccurs=\u201cunbounded\u201d minOccurs=\u201c0\u201d \/>"]},{"entry":[{},"\u2003<xs:element name=\u201cand\u201d type=\u201cand\u201d maxOccurs=\u201cunbounded\u201d"]},{"entry":[{},"minOccurs=\u201c0\u201d \/>"]},{"entry":[{},"\u2003<xs:element name=\u201cor\u201d type=\u201cand\u201d maxOccurs=\u201cunbounded\u201d"]},{"entry":[{},"minOccurs=\u201c0\u201d \/>"]},{"entry":[{},"\u2003<\/xs:sequence>"]},{"entry":[{},"\u2003<\/xs:complexType>"]},{"entry":[{},"\u2003<xs:element name=\u201cpeersearch\u201d>"]},{"entry":[{},"<xs:complexType>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<xs:choice>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<xs:element name=\u201cclause\u201d type=\u201cclause\u201d\/>"]},{"entry":[{},"<xs:element name=\u201cand\u201d type=\u201cand\u201d\/>"]},{"entry":[{},"<xs:element name=\u201cor\u201d type=\u201cor\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/xs:choice>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/xs:complexType>"]},{"entry":[{},"\u2003<\/xs:element>"]},{"entry":[{},"<\/xs:schema>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"It is instructional to note that the SRQL language is comprised of both parts: Attributes and Queries. It is also important to note that the SRQL is protocol independent and could be used in other protocols or products.","Having now described the particulars of the SRQL of the present invention, both the attributes and the queries, the following discussion will focus on a peer-to-peer environment to which the SRQL of the present invention finds particular applicability. As illustrated in , the peer networking architecture  of the present invention provides a modular search architecture that allows for two distinct search engines to exist and operate within a group context. The engines are local  and distributed search engines . A local engine  is one that searches only the machine it is on, while a distributed search engine  is one that sends a search request to neighbor peers in the group. Both of these search engines are callable by an application  via one search application programming interface (API) .","In this  the search API  is the module that calls the correct engine based on the parameters of the search query. The group database search engine  is the module that searches the group database for the various types of records . The group database includes all information that was flooded in the group context. A search that is conducted using this module  returns all information that has been flooded to the group. The data provider engine  allows applications to register to accept search queries. They can then return the appropriate information to the requesting application. This is because some applications may not choose to publish data into the group database. They may choose to continue to keep data within their own database. In such situations, the applications know the best way to analyze the queries made. The distribution engine  determines how non-local search requests are replicated across the group. Since some distribution engines may wish to affect the shape and connectivity of the nodes in the group specified by the grouping and graphing APIs , only one distribution engine can be specified for a group.","A description of one embodiment of peer graphing interfaces is contained in co-pending application Ser. No. 10\/309,865, entitled Peer-To-Peer Graphing Interfaces and Methods, filed on Dec. 4, 2002, the teaching and disclosure of which are hereby incorporated in their entireties by reference thereto. A typical infrastructure also includes identity interfaces. A description of one embodiment of these identity management interfaces is contained in co-pending application Ser. No. 10\/309,864, entitled Peer-To-Peer Identity Management Interfaces And Methods, filed on Dec. 4, 2002, the teachings and disclosure of which are hereby incorporated in their entireties by reference thereto. Finally, a set of grouping interfaces are also provided to allow proper participation in P2P groups. A description of one embodiment of such grouping interfaces is contained in co-pending application Ser. No. 10\/351,905, entitled Peer-To-Peer Grouping Interfaces and Methods, filed on even date herewith, the teachings and disclosure of which are hereby incorporated in their entireties by reference thereto.","The main addition to the current APIs (and the focus of this document) is the addition of an actual \u201cSearch\u201d API. This \u201csearch\u201d API will be specified below. The actual implementation of it will live in the same layer as the rest of the record management APIs. The parameters of the peer graph search API include a handle to the graph associated with the query, an XML string representing the search criteria, and a handle to a newly allocated record enumerator used to iterate over each of the records returned from the search. The peer group get next item API discussed in the grouping API co-pending application discussed above should be used to retrieve the actual records returned. The peer graph search API returns an indication of success or failure. The failure indications include an indication that the handle to the graph is invalid, that the search string is NULL or the handle to the record enumerator is NULL, or the XML string is invalid.","As indicated above, the search API accepts a string as a parameter. The string is a XML document following a format specified herein. If the user is trying to query against a attribute of type \u2018string,\u2019 wildcard matches are allowed. Since SQL uses different wildcards than users are used to, a mapping is provided when SQL is used.",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"szValue characters","meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"*","wildcard, matches 0\u2013n characters"]},{"entry":[{},"\\*","matches exactly 1 asterisk"]},{"entry":[{},"?","Wildcard, matches any 1 char."]},{"entry":[{},"\\?","Matches exactly 1 question mark"]},{"entry":[{},"\\\\","matches exactly 1 backslash"]},{"entry":[{},"\\n","matches exactly backslash"]},{"entry":[{},{},"followed by the character n,"]},{"entry":[{},{},"where n is any character except*"]},{"entry":[{},{},"or \\."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Internally, all text queries preferably use the LIKE operator of SQL Lite, with the escape character set to backlash as follows:\n\nselect id from attributes where value LIKE \u2018% ski trip %\u2019 ESCAPE\\\n","Note that SQL uses % for its wildcard character, and that _(underscore) is used to mean \u2018any 1 character\u2019. Full mapping from szValue to actual SQL query is:",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"szValue characters","SQL characters"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"*","%"]},{"entry":[{},"\\*","*"]},{"entry":[{},"?",{"sub":"\u2014 "}]},{"entry":[{},"\\?","?"]},{"entry":[{},"\\\\","\\\\"]},{"entry":[{},"\\n","\\\\n"]},{"entry":[{},"%","\\%"]},{"entry":[{},{"sub":"\u2014"},"\\"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A query will be built and ran against the Attributes table on the associated database connection. The actual query will use a join, similar to this example:",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT DISTINCT t1.recordid"]},{"entry":[{},"FROM attribs t1"]},{"entry":[{},"JOIN attribs t2 ON t1.recordid = t2.recordid"]},{"entry":[{},"JOIN attribs t3 ON t1.recordid = t3.recordid"]},{"entry":[{},"WHERE"]},{"entry":[{},"\u2003t1.Attribute = \u2018Name\u2019 AND t1.StringValue = \u2018Scott\u2019 AND"]},{"entry":[{},"\u2003t2.Attribute = \u2018Age\u2019 AND t2.IntValue < 30 AND"]},{"entry":[{},"\u2003t3.Attribute = \u2018Birthday\u2019 AND t3.DateValue = \u20184\/4\/1972\u2019;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In an alternate embodiment, all values are stored in 1 column, which is converted when doing the query. However, having multiple columns is preferred because convert is an expensive operation (best performed once, at insert time), better performance may be realized with indexed columns, and there is no significant increase in database size for the additional columns in a sparse table.","Given the hGraph, internally a connection to the database will be obtained, and the actual query will be executed using roughly the same mechanism as the PeerGraphEnumRecords API discussed in the above co-pending application. HPEERENUM returned should be handed off to PeerGraphGetNextItem to retrieve the actual records associated with the query, and PeerGraphEndEnumeration should be used to free any resources.","With this discussion, everything necessary to enable distributed searching has already been specified. The main APIs that enable this are the get neighbor list, send to neighbor, and the record notification API's discussed in the above co-pending applications.  illustrates the process that takes place to search a remote machine in accordance with one embodiment of the present invention. First , the search API  calls into the graphing layer  to retrieve the list of neighbors. With this list, the searching layer  could choose to send a search request to one neighbor or many, depending on its needs. The searching API  would use the SendToNeighbor API  to send a record to one (or more) of its neighbors. It is up to the search API  to define a user-defined record type appropriate for a search request.","The underlying socket layer would actually send  the search request record to the specified neighbor. In the neighbor machine, the receipt of the search record will fire a \u201cnew record\u201d event . It is up to the searching layer  to register to be notified of incoming search request records. When the search request is received, it will be propagated to the search API . At this point the searching layer would do whatever searching was appropriate, including possibly calling back into the record management layer to call the search API.","For each matching record found based on the search criteria, the searching layer would call SendToNeighbor  to send a \u201csearch result\u201d record back to the caller. It is up to the searching layer to define the new user defined record type. At this point, the searching layer may also decide to propagate the search request to its neighbors in the same fashion as in step . The underlying socket layer would send  the actual search result record back to the caller. In the caller, a \u201cnew record\u201d event will fire . The searching layer must have previously registered for the new record event when the type is \u201csearch result\u201d. When this event is fired, the searching layer will now have a search hit to use. One event will be fired for each search hit.","The foregoing description of various embodiments of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise embodiments disclosed. Numerous modifications or variations are possible in light of the above teachings. The embodiments discussed were chosen and described to provide the best illustration of the principles of the invention and its practical application to thereby enable one of ordinary skill in the art to utilize the invention in various embodiments and with various modifications as are suited to the particular use comtemplated. All such modifications and variations are within the scope of the invention as determined by the appended claims when interpreted in accordance with the breadth to which they are fairly, legally, and equitably entitled."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings incorporated in and forming a part of the specification illustrate several aspects of the present invention, and together with the description serve to explain the principles of the invention. In the drawings:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
