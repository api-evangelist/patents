---
title: Method and system for the garbage collection of shared data
abstract: A method of garbage collection of shared data in a system heap within a data processing system, the method comprising the steps of: (a) determining if the contents of the system heap has reached a predetermined threshold, the system heap storing shared objects which are shared amongst a plurality of processes running in a data processing system; (b) in a table identifying each of the plurality of processes with a status field, setting the status field of a process which has carried out determining step (a) to a mark initiator value; (c) triggering remaining processes to mark all objects in the system heap that each process is currently using; (d) determining that each of the remaining processes has completed the marking, at step (c); (e) releasing any unmarked objects in the system heap to an object pool.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06996590&OS=06996590&RS=06996590
owner: International Business Machines Corporation
number: 06996590
owner_city: Armonk
owner_country: US
publication_date: 20021220
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates to the field of data processing systems and in particular to the garbage collection of shared data.","People today use the World Wide Web for a variety of different and diverse tasks for example locating information, ordering and buying goods on-line and managing their finances. Users expect that these applications will operate regardless of what type of computer platform is used. It would be inconvenient and cumbersome if a different application had to be launched for each type of computer platform. This would be an inconvenience not only for the users of the launched application but the application developers as well.","Java technology, which is a trademark of Sun Microsystems, Inc, provides a solution to this problem by allowing the creation of computer platform independent programs. The Java technology consists of an object orientated programming language and a platform on which to run the Java applications. Java is both a compiled and an interpreted language. The source code that has been written by the application developer is compiled into an intermediate form called a Java bytecode, which is a platform independent language and sent over the network to a client machine where the java bytecodes are interpreted by the Java platform and the Java interpreter parses and runs each Java bytecode instruction on the computer.","Java's objected orientated programming language is based on using objects and classes and this paragraph will introduce the reader to a few basic concepts. Just like real world objects, software objects consist of a state and a behavior. A software object maintains its state in one or more variables and a variable is an item of data named by an identifier. A software object implements its behavior with methods and a method is a function associated with an object. Just like any other objected orientated programming language objects communicate with each other by passing messages. Further object orientated concepts are well known in the art and will not be described here further.","The Java platform consists of the Application Programming Interface (API), which is a large collection of ready-made software components, which provide a variety of capabilities, and the Java Virtual Machine (JVM) which will be explained in the paragraph below. Together the JVM and the API sit on top of the hardware based computer platform and provide a layer of abstraction between the Java program and the underlying hardware.","The JVM is made up of software, which can run a Java program on a specific computer platform of a client machine. Before a Java program can be run on a JVM, the Java program must first be translated into a format that the JVM recognizes, which is called a Java class file format. The Java class file format contains all the information needed by a Java runtime system to define a single Java class.","The JVM running on a particular computer can be divided into four basic parts: the registers, the stack, the garbage-collected heap, and the method area.","Like most other object-orientated applications, a Java application typically allocates new objects to a region of the system memory within a data processing system commonly referred to as the \u2018heap\u2019 and each JVM has its own heap. Java does not have a \u2018free\u2019 or \u2018delete\u2019 method, which allows a Java application to free objects that are no longer required by the system. Instead when a Java application executes on a particular computer platform the Java application relies on a garbage collection process which is the responsibility of the JVM, to reclaim space within the heap that is no longer utilized by previously allocated objects.","When the client computer invokes a method on a remote object, a message is sent to the server process that hosts the remote object. The message must specify which particular object is to have its method invoked. For example the object to which the message is addressed (yourCar) and the name of the method to perform (changeGears) and any parameters needed by the method (higherGear).","A remote object reference is an identifier for a remote object that is valid throughout the computer system. An object is determined as being live whilst there is an object reference pointer to it somewhere in the active state of the JVM and therefore the object is able to be located. When an object ceases to be referenced from the active state within the JVM it can be classified as garbage. The memory space occupied by the object can then be reclaimed for reuse and garbage collected. Garbage collection is usually triggered whenever the Java application attempts to create a new object, and it is determined that there is insufficient free space available within the heap to satisfy an object allocation.","Garbage collection is usually performed in a synchronous manner. Generally, the synchronous garbage collection begins its operation by temporarily stopping all Java applications within the JVM. The synchronous garbage collection then traverses a Java stack and the heap in order to search for all the active objects and their children. These active objects and their children are then marked accordingly. Afterwards the heap is searched again for a second time to reclaim any space previously utilized by the unmarked objects. Finally the Java applications are restarted again. This type of garbage collection is typically called \u2018stop the world\u2019 as all applications are stopped whilst garbage collection is performed and restarted when the garbage collection process has finished.","When multiple JVM's are running on the same computer, there arises a need to minimize the footprint of each JVM, such that memory resources are utilized to their full advantage and therefore it is important to share as much data as possible with other individually running JVM's on the same computer. Typically the data to be shared between the multiple JVM's could be any read only data for example all Java classes together with their bytecode and equivalent Just-In-Time (JIT) code, or the data structures representing methods and classes. A Just-In-Time code generator generates JIT code, which is a technique for speeding up the execution of interpreted programs such as Java. JIT code is created before a method is run for the first time. The Java interpreter converts the Java byte code for the method into native machine code, which, the computer can then execute directly rather than via a Java interpreter.","Generally the shared data that is used by multiple JVM's on the same computer is not stored in the heap of any one JVM, but instead it is stored in a shared area called the system heap. Often the system heap is not garbage collected as multiple JVM's running on the same computer could each have a reference or many references to a shared object or any other shared data in the system heap. This leads to an environment, in which it is difficult to determine which objects are live within the system and which are eligible for garbage collection as there currently is no means in which to co-ordinate the actions of multiple JVM's running on the same computer, to determine whether an object can be garbage collected to free the resources that the object utilized.","The problem has been described only in the context of Java, but the same problem arises in other programming environments where there is a need for the automatic reclamation of heap-allocated storage after its last use by a program and further when there arises a need for automatic dynamic memory management. An example of other programming environments are, but not limited to C, C++, Smalltalk, Eiffel, Dylan, Modula-3 and Oberon.","In accordance with the present invention there is now provided a method of garbage collection of shared data in a system heap within a data processing system, the method comprising the steps of: (a) determining if the contents of the system heap has reached a predetermined threshold, the system heap storing shared objects which are shared amongst a plurality of processes running in a data processing system; (b) in a table identifying each of the plurality of processes with a status field, setting the status field of a process which has carried out determining step (a) to a mark initiator value; (c) triggering remaining processes to mark all objects in the system heap that each process is currently using; (d) determining that each of the remaining processes has completed the marking, at step (c); (e) releasing any unmarked objects in the system heap to an object pool.","The method provides an advantage in that the actions of the plurality of JVM's running on the same data processing system can be co-coordinated and once the objects are marked it is apparent which objects are suitable for garbage collection. The method provides a further advantage such that all the processes running on the same data processing system are not required to stop working whilst garbage collection is being carried out.","Viewed from another aspect the present invention provides a system for carrying out the method described above.","Further the invention provides a computer program product, for instructing a data processing system to carry out the method described above.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},"Referring to , a Java runtime environment is shown and follows the well-known architecture as specified in the JVM specification from Sun Microsystems. A Java application can create new objects and arrays, which the JVM 125 stores in a block of memory called the heap . A system heap  stores the shared data that the individually running JVM's share in a data processing system.","The execution engine  carries out the instructions contained in the byte code of a Java method. The dynamic class loader  loads the classes that a Java program requires in order to run. The loading of the classes involves obtaining in bytes the Java class file that defines a class. This can be achieved by reading a file from a disk or over a network . Java uses exception threads  to signal that there is an error within the program. Each method defines an exception handler table that lists which exceptions the method catches.","Classes can contain native method  declarations. The body of the method is not provided as Java bytecode in a class file, but instead is written using another programming language and compiled into machine code stored in a separate Dynamic Link Library (DLL) which is an executable program module that performs a particular function, or a shared library. Runtime systems include code to dynamically load and execute the code in native methods using calls made to the operating system  that use DLL's in Microsoft Windows, which is a trademark of Microsoft Corp, or shared libraries in UNIX. Once a native method  has been linked into the runtime system by the native method linker , the execution engine  traps calls to the native method  and routes these to the underlying native code. The dynamic class loader  loads, links and initializes classes. The first time a class is referenced, its class file is located; the bytes in the class file are loaded into memory and the class in further linked into the runtime system at initialization.","The JVM 125 includes an instruction that allocates memory on the heap  for a new object but includes no instruction for freeing the memory. The JVM 125 is responsible for deciding when to free memory occupied by objects that are no longer referenced by the running application. Usually, a JVM 125 uses a garbage collector thread to manage the heap . Or the JVM can use a thread provided by the Java application to carry out the garbage collection. This provides an advantage of allowing the Java application to initiate its own garbage collection process without having to stop all other JVM'S.","While only one JVM is shown in , it is commonly the case that a plurality of such JVM's are running on the same machine as explained above. A description will now be given of preferred embodiments of the present invention, which enables the garbage collection of the system heap in this plural JVM environment.","To enable the garbage collection of the shared data in the system heap used by multiple JVM's, an object in the system heap must be identified as either an object, which is alive within the system, or as an object that can be removed from the system heap, thereby releasing memory used by the object To achieve this an object in the system heap is marked by a bit, such that each object can be identified as \u2018reachable\u2019 and the objects within the system heap that are not marked by a bit and thus not identified as \u2018reachable\u2019 can be classified as appropriate for garbage collection. The marking of an object can be carried out in a number of ways. A separate shared area can be utilized to hold all of the mark bits; a bit would cover a predefined amount of the shared heap, which typically is 8 bytes. A bit corresponding to the start address of each shared object would be set to indicate a mark. A bit within the object itself could also be allocated and set when the object is marked. To trigger the process of garbage collection of the shared data in the system heap, the system heap is monitored to determine whether its contents has reached a predetermined threshold (that is the system heap is filled with data to a certain threshold level, for example 80% full) and needs to be garbage collected. At least one of the running JVM's has the capability of detecting whether the system heap has reached a predetermined threshold. Once such detection is made, one of the JVM's (e.g., the one that performed the detection) elects itself the role of mark initiator (MI) and begins the process of monitoring all the JVM's access to the system heap, running on the data processing system.","Referring to and , a shared table is defined for keeping track of all the running JVM's; each of the running JVM's can either be classed as an initiator process or a worker process, which is accessing the system heap. The initiator process is the mark initiator as described above. The worker processes are the remaining running JVM's. The shared table contains a process ID  and a status field  of each initiator or worker JVM. A JVM can have a status of running (R) , mark initiator (MI)  or mark complete (MC) . As each JVM is working through the process of marking any shared objects, its status will be updated in the shared table. Only one JVM can update its status in the shared table at any given time and by using a global lock one JVM can deny concurrent access to all other JVM's. A status of running (R)  signifies to the initiator JVM that the worker JVM is carrying out its normal duties. The status of mark initiator  is the status that the initiator JVM takes upon itself when the initiator JVM begins the task of triggering the other worker JVM's to start marking their objects. At JVM initialization time the process ID's of all running JVM's are added to the shared table.","In the process ID   has a status of mark initiator. The mark initiator will monitor the shared table until all running JVM's have a status of mark complete (MC)  in the shared table and the mark initiator JVM is then able to locate all unmarked objects in the system heap. The mark initiator , will update the status fields of all other worker JVM's to a status of mark requested (MR) in the shared table , from their previous status of running (R) ,  and  to indicate to the worker JVM's that they should traverse their own heap and the system heap locating references to shared objects.","Referring to , once all worker JVM's have completed the task of marking all shared objects, each JVM 260, 270, 280 and 290 will sequentially take control of the global lock and update their status in the shared table to mark complete , ,  and .","Referring to , at step , the initiator JVM takes control of the global lock. At step , the initiator JVM clears all references to the shared mark bits in the marked objects of the previous garbage collection cycle and at step , sets its own status value to mark initiator in the status field  of the shared table and sets all other status values for each worker JVM to mark requested at step , and releases the global lock at step . At step , the initiator JVM traverses its own heap and the system heap to locate shared objects and marks the shared objects accordingly. At step , the mark initiator JVM waits for all other worker JVM's to update their status to mark complete in the shared table.","Referring to  at step , each of the worker JVM's periodically polls its own status value in the shared table to detect if the status value has been updated to mark requested; the most appropriate and advantageous time to do this would be during garbage collection. If mark requested, is not detected control flows to step , where the worker JVM carries on with its normal operations. When a worker JVM detects that its status field has a value of mark requested, control flows to step , where the worker JVM traverses its own heap and the system heap looking for references to shared objects and when a shared object has been located the JVM sets the appropriate mark bits in the located shared objects. The worker JVM can either mark the bit by taking control of the global lock at step , or could perform an atomic update and therefore does not require a lock.","Once the worker JVM has completed the task of marking a shared object, the worker JVM takes control of the global lock at step , and updates its own status in the shared table to mark complete at step . Each worker JVM notifies the mark initiator at step , that it has completed marking all objects and then releases the global lock at step . Each worker JVM will notify the mark initiator in turn, as the mark initiator cannot release the unmarked objects back to an object pool until all the status values of all other worker JVM's have been updated to mark complete , ,  and .","Turning back to , as part of step , the mark initiator periodically polls the status field values in the shared table. When all worker JVM's have reached the status of mark complete, the mark initiator completes the garbage collection task by releasing any unmarked objects at step  back to the object pool. Finally, at step , the mark initiator JVM takes the global lock, resets all JVM status values including its own to running and continues its normal duties at step .","If any JVM creates an object in the system heap while its status is mark requested or mark completed it must ensure that the object is not garbage collected. This can be achieved by marking or by allocating the object from a new object pool, which is not to be garbage collected in this cycle. This approach is preferable, as system performance is preserved.","If a JVM terminates due to system failure or the JVM terminates normally, its associated process ID and status is removed from the shared table. It is equally possible for a new JVM to start up before all JVM's have reached the status of mark complete in the shared table. If this situation should arise, the JVM enters its process ID and status into the shared table by taking control of the global lock as part of step  in . The worker JVM polls the shared table to see if mark initiator  has been updated in the shared table. the answer is positive the JVM updates its status to mark complete , otherwise the status is running . This method of garbage collection allows the system heap to be garbage collected without having to stop all processes."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A preferred embodiment of the invention will now be described in detail by way of example only with reference to the following drawings:",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 2","i":["a ","b "],"b":"2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
