---
title: Timeout request scheduling using grouping and nonsynchronized processing to enhance performance
abstract: An invention is disclosed for a computer software timeout algorithm that reduces the amount of list manipulation needed to satisfy system or network requirements for scheduling and cancelling timeout requests to determine whether the expiration time has been reached for execution of an input/output (I/O) request, thereby requiring action to cancel the I/O operation if it has not yet been completed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07707464&OS=07707464&RS=07707464
owner: International Business Machines Corporation
number: 07707464
owner_city: Armonk
owner_country: US
publication_date: 20090114
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is a continuation of and claims priority to and claims the benefit of U.S. patent application Ser. No. 11\/465,797 titled \u201cTIMEOUT REQUEST SCHEDULING USING GROUPING AND NONSYNCHRONIZED PROCESSING TO ENHANCE PERFORMANCE,\u201d which was filed in the U.S. Patent and Trademark Office on Aug. 18, 2006, and which is incorporated herein by reference in its entirety.","This invention relates to use of \u201cevent completion\u201d style input\/output (I\/O) models in computer system or network applications, and specifically to a computer software timeout algorithm that reduces the amount of list manipulation needed to satisfy system or network requirements for scheduling and cancelling timeout requests.","Input\/Output (\u201cI\/O\u201d) operations encompass all types of actions and communications between a computer and its users and\/or its processing, storage or peripheral devices, as well as with other system computers (via a network such as a local area network (\u201cLAN\u201d) or a wide area network (\u201cWAN\u201d) or the Internet using a communications protocol such as Transmission Control Protocol over Internet Protocol (TCP\/IP)) or the outside world; including \u201cread\u201d operations (where information is extracted from a stored location in a system or network device) as well as \u201cwrite\u201d operations (where information is stored in a system or network location) and \u201ctransfer\u201d operations (where information is transmitted from one system or network location or device to another). I\/O \u201cevent completion\u201d models are based upon use of application programming interfaces (APIs) that allow a software application to communicate with a computer or network operating system for the purpose of requesting performance of a particular I\/O operation. When such I\/O operations take place over a computer system or network, I\/O \u201cread\u201d and\/or \u201cwrite\u201d (or other) requests are made by a \u201cuser code\u201d (or \u201cthread\u201d) of the requesting application in order to send (or retrieve) data or instructions for the purpose of transmitting them from one system or network location or device to another.","System or network communication software often needs to provide \u201ctimeout\u201d functionality for the reading and writing of data or instructions (and other I\/O operations) in order to allow the next I\/O request to be processed in the event that some system event or problem prevents processing of the current request. For example, a \u201cread\u201d I\/O request will expire (or \u201ctimeout\u201d) within a certain period of time (often seconds) if the read operation has not been completed by that time after a \u201cread\u201d API has been called by the \u201cuser code\u201d to execute that request. Most of the time such an I\/O request will be completed within the required \u201ctimeout\u201d period, and the \u201ctimeout\u201d will not be signaled to the calling code for execution. However, problems can occur if the system or network is not optimized for performance in a way that prevents system processing resources from being unnecessarily used to schedule and cancel possible timeout actions. For example, if 10,000 \u201cread\u201d requests are initiated during a 5 second time interval and each of them has a timeout that is scheduled to occur within 60 to 120 seconds after initiation of the request, and each read is subsequently executed within 30 seconds after its initiation, then the system resources that were used to schedule (and subsequently cancel) those \u201ctimeout requests\u201d were wasted by being occupied with those requests instead of contributing to system processing activity (or \u201cthrough-put\u201d).","Most system or network \u201ctimeout\u201d algorithms involve keeping track of when outstanding I\/O requests will \u201ctimeout\u201d through use of a list that is periodically checked (for example once per second) to determine whether the timeout (expiration) time has been reached for a given request, and if so a \u201ctimeout action\u201d is taken to cancel the associated I\/O operation. The list is then accessed to remove a \u201ctimeout entry\u201d when its I\/O operation has been timely completed so that it will not be errantly triggered. However, the processing of such \u201ctimeout lists\u201d causes a significant degradation in system performance, since the list must be ordered according to the point in time when an entry will timeout due to expiration of its I\/O request, requiring the list to be searched for the proper location to insert a new entry (as well as for removal of an entry when it is no longer needed due to timely execution of the request). Such a list must also be periodically processed to find any \u201cactive\u201d entry requiring a \u201ctimeout action\u201d to be taken due to expiration of its I\/O operation without completion. Software synchronization logic is required to coordinate the timing of most of these types of \u201clist manipulation actions\u201d with a further resulting degradation in system processing performance.","An invention is disclosed for a computer software \u201ctimeout algorithm\u201d program that reduces the amount of \u201ctimeout list\u201d manipulation needed to satisfy system or network requirements for scheduling and cancelling \u201ctimeout requests\u201d to determine whether the \u201ctimeout period\u201d (or expiration time) has been reached for execution of an input\/output (I\/O) request, thereby requiring a \u201ctimeout action\u201d to cancel the I\/O operation if it has not yet been completed.","Specifically, the \u201ctimeout algorithm\u201d is comprised of software components programmed to execute at least the following functions:\n\n","It is therefore an object of the present invention to overcome the disadvantages of the prior art by providing improved use of event completion style input\/output (I\/O) models in computer system or network applications, through disclosure of a computer software timeout algorithm program that reduces the amount of timeout list manipulation needed to satisfy system or network requirements for scheduling and cancelling timeout requests to determine whether the timeout period (or expiration time) has been reached for execution of an input\/output (I\/O) request, thereby requiring a timeout action to cancel the I\/O operation if it has not yet been completed.","It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to execute a timeout action that is adjusted to take place at the nearest time interval after the exact time when it should occur for each I\/O operation to be executed by the system or network, in order to allow individual timeout request entries to be chronologically grouped into a subset (or \u201ctimeout bucket\u201d) of all entries having the same adjusted timeout time, so as to allow processing of the timeout list to be accomplished through use of the buckets instead of individual entries by comparison of the system time to the timeout time for each bucket, such that if the timeout time has been passed then a timeout action is initiated for an entry if it has not already been cancelled due to timely completion of its associated I\/O request.","It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to process individual timeout entries each having a data field (or \u201ctimeout status flag\u201d) that can be set to schedule (and subsequently reset to cancel) a pending timeout action, in order to eliminate the need for removal of an entry from a timeout list after its associated I\/O request has been timely executed.","It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to process an individual timeout entry that is initially stored in an unordered list (or \u201cqueue\u201d) before being placed into a timeout bucket to be processed by the timeout algorithm, wherein the queue is used by the algorithm code segment which processes the information contained in a timeout list and is programmed to enable a timeout request in the queue to be cancelled and discarded without action before being placed into a timeout bucket.","It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to inactivate the algorithm for a period of time to allow data processing to be accomplished instead of timeout processing.","It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to examine each timeout bucket periodically to determine whether all of its individual timeout entries have been cancelled.","The subject matter which is regarded as the invention is particularly pointed out and distinctly claimed in the concluding portion of the specification. The invention, however, together with further objects and advantages thereof, may best be understood by reference to the following description taken in conjunction with the accompanying drawings.","As illustrated in , input\/output (I\/O) \u201cevent completion\u201d models are based upon use of application programming interfaces (APIs) that allow a software application to communicate with a computer operating system for the purpose of requesting performance of a particular I\/O operation . When such I\/O operations take place over a computer system or network, I\/O \u201cread\u201d or \u201cwrite\u201d (or other) requests are made by a \u201cuser code\u201d segment (or \u201cthread\u201d) of the requesting application  sending such a request to an \u201cevent completion code\u201d module  for the purpose of transmitting data or instructions from one system or network location or device to another. The event completion code then responds by providing notification of completion  to the user code after the I\/O request has been successfully processed.","This invention discloses a computer software \u201ctimeout algorithm\u201d program  that reduces the amount of \u201ctimeout list\u201d  manipulation (and therefore processing resources) needed to satisfy computer system  or network requirements for scheduling and cancelling \u201ctimeout requests\u201d  to determine whether the \u201ctimeout\u201d (or expiration) time has been reached for execution of an input\/output (I\/O) request , thereby requiring a \u201ctimeout action\u201d  to cancel the I\/O operation if it has not yet been completed. As illustrated in , the timeout algorithm program is preferably comprised of software components executed by a processor  from a memory  consisting of many TimeOutRequest objects  along with many UserThreads  and a TimeOutThread  all programmed using conventional techniques to execute at least the functions described herein.","A UserThread  is programmed to be executed by the processor  to accomplish the following processing functions: (i) a TimeOutRequest object  is created when a \u201ctimeout entry\u201d  is originated upon initiation of an I\/O request  (event ) and then placed into an \u201cunordered queue\u201d  event  with its \u201ctimeout status flag\u201d  set to ACTIVE for a pending I\/O request; (ii) a TimeOutRequest object is then invalidated by resetting its timeout status flag to CANCELLED when a timeout entry is no longer needed because its associated I\/O request has been timely completed or if its timeout period has expired and a timeout action has been invoked.","A TimeOutRequest object  consists of definition of at least the following data fields for each individual timeout entry : (i) a timeout time  for which the timeout action will be invoked to cancel the read\/write (or other) I\/O operation  if it has not been completed by then (which can be the same length or duration for multiple timeout entries); (ii) identifying a \u201ctimeout action callback routine\u201d should execution of a timeout action  (event ) be required for that entry; and (iii) setting a timeout status flag  as ACTIVE for an individual timeout request  if its associated I\/O request  has not yet been executed and its timeout time  has not yet been reached, or CANCELLED if a timeout request is no longer valid due to timely completion of its I\/O request or expiration of its timeout period and the subsequent invocation of a timeout action.","A TimeOutThread  processes the \u201ctimeout buckets\u201d  and timeout lists  (including the unordered queue ) and is programmed to be executed by the processor  to accomplish the following processing functions, in order to eliminate the need for these data structures to be protected by \u201csynchronization logic\u201d since they will be accessed by only this thread: (i) an individual TimeOutRequest object  is removed from the unordered queue and it is ignored if this timeout request  has already been cancelled, and this processing step is then revisited for the next TimeOutRequest object in the queue; otherwise (ii) the point in time is calculated when that request should signal a timeout action  by adding the unelapsed portion of the timeout period  for that request to the initiation time of its associated I\/O request  (which can be the current chronological time) and then adjusting the timeout action to take place at the nearest time interval or increment after that time (such as by \u201crounding up\u201d to the nearest second or multiple of 1024).","The list of timeout buckets  is then searched for one that has the same adjusted timeout time  as the timeout request  under examination from the unordered queue , and if one is found then the request is inserted into that bucket from the unordered queue (event ); otherwise, a new bucket is created with this new timeout time and the timeout request is assigned to that bucket (which can hold either a fixed or varying number of entries). The list of timeout buckets is ordered from \u201clowest\u201d (soonest upcoming) timeout time to \u201chighest\u201d (most distant future) timeout time, so that a new bucket is inserted at that point in the list after a bucket that has a lower (and before a bucket that has a higher) timeout time than its own, so that each bucket represents the correct point in time for occurrence of the timeout with respect to each timeout request in that bucket. This processing step is then revisited for the next TimeOutRequest object  in the queue, and if there are no more timeout requests stored in the queue then the next processing step is executed.","The current chronological clock  time is determined by the processor  from the computer system  and each timeout bucket  is periodically retrieved for examination (event ) according to its order from \u201clowest\u201d timeout time to \u201chighest\u201d timeout time. The system chronological time is then compared to the timeout time  for the next bucket. If the timeout time has been passed then each timeout entry in the bucket is examined, and the TimeOutThread  triggers the timeout callback routine to initiate a timeout action  (event ) for the entry if it has not already been cancelled due to timely completion of its associated I\/O request . (It should be noted that the timeout callback routine must in some instances be synchronized with the timeout status flag  to ensure that the I\/O operation is not being completed at essentially the same time when the \u201ctimeout\u201d is detected.) The timeout bucket  is then discarded after examining each of its timeout entries in this manner. Once a bucket is encountered for which the timeout time has not been reached, then no more buckets are examined through that cycle because each subsequent bucket will also have a timeout time that has not been reached. Therefore the next processing step will be executed. The \u201cpruning\u201d processing step is then executed after the last timeout bucket is examined using this step.","A \u201cdead bucket pruning time interval\u201d is defined to determine how often each\u2014timeout bucket list  should be examined to decide if a bucket can be discarded. If this time interval has been triggered then each bucket is examined to determine whether all of its timeout entries  have been invalidated. If at least one timeout entry is still ACTIVE then the next bucket is examined, since all entries have not yet \u201ctimed out\u201d for that bucket (meaning that it cannot yet be discarded). If all entries in a timeout bucket have already been invalidated, then its entries are discarded and the bucket is eliminated. The timeout algorithm 1 is inactivated for a certain period of time (i.e., \u201csleeps for a lazy interval\u201d) to allow data processing to be accomplished instead of timeout processing. The timeout algorithm is then repeated in its entirety after expiration of this \u201clazy sleep interval\u201d time period.","While certain preferred features of the invention have been shown by way of illustration, many modifications and changes can be made that fall within the true spirit of the invention as embodied in the following claims, which are to be interpreted as broadly as the law permits to cover the full scope of the invention, including all equivalents thereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DETAILED DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0020"},"figref":"FIG. 2"}]},"DETDESC":[{},{}]}
