---
title: Realtime kernel
abstract: A realtime kernel supports realtime communications between communicants operating on respective network nodes. The realtime kernel handles the complex tasks of connecting to communicants, virtual areas, and other network resources, switching those connections in response to user inputs, and mixing realtime data streams. The realtime kernel enables developers to focus on developing high-level communications functionality instead of low-level plumbing code. The realtime kernel imposes relatively low computational resource requirements so that realtime communications performance can be achieved using a wide range of computing devices and network connections that currently are available.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09055131&OS=09055131&RS=09055131
owner: Social Communications Company
number: 09055131
owner_city: Eugene
owner_country: US
publication_date: 20131003
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","I. DEFINITION OF TERMS","II. INTRODUCTION","III. OVERVIEW","IV. SYSTEM ARCHITECTURE","V. EXEMPLARY REALTIME KERNEL EMBODIMENT","VI. SODA DEFINITIONS","VII. CONCLUSION"],"p":["This application is a divisional application of prior U.S. patent application Ser. No. 12\/630,973, filed Dec. 4, 2009, which claims the benefit of U.S. Provisional Application No. 61\/120,372, filed Dec. 5, 2008, the entirety of which is incorporated herein by reference.","This application also relates to the following patent applications, the entirety of each of which is incorporated herein by reference:","U.S. patent application Ser. No. 12\/418,243, filed Apr. 3, 2009;","U.S. patent application Ser. No. 11\/923,629, filed Oct. 24, 2007; and","U.S. patent application Ser. No. 11\/923,634, filed Oct. 24, 2007.","Interest in avatar-based virtual reality communications systems has grown with the increased availability of computing systems that have high-processing-power and high-bandwidth network connections. A primary goal of such a virtual reality system is to create a virtual space in which users can interact and communicate using realtime data streams, such as audio, video and text chat streams. The virtual space typically is defined by a computer graphics specification that describes the visual geometry of the space, the colors and textures that are mapped onto the visual geometry, the collision properties that control how users maneuver within the space, and auditory properties, such as, reverberation and sound absorption properties, of the space.","In a typical virtual reality system, the users communicate with each other from respective computers through an interface that is a source, a sink, or both a source and a sink of one or more of the realtime data streams that are supported by the system. A virtual reality software application running on each of the user's computers configures its own audio and graphic rendering based on position information describing the positions of avatars in the virtual space. The position information typically is received either directly from the other users' computers or indirectly from a central presence server. By default, the virtual reality software application typically connects each source represented in the virtual space to every sink represented in the virtual space, subject to conditions specified in global switching rules, local user preferences, and the properties of objects within the virtual space. These conditions typically are specified in terms of relative distances between objects. For example, some virtual reality software applications are configured so that realtime data stream connections are not established if the separation distance between avatars exceeds a maximum threshold distance.","A successful virtual reality communications system typically should have relatively low computational resource requirements so that realtime communications performance can be achieved using currently available computing devices and network bandwidth constraints. In addition, such a system typically should be implemented in a way that encourages area designers to develop virtual areas that increase the adoption of the system by users.","In one aspect, the invention features a method in accordance with which one or more stream handling instructions are received at a local network node from a remote network node. The one or more stream handling instructions include a specification of a stream handler for processing at least one realtime data stream. At the local network node, a stream handler is created in accordance with the specification. A resultant data stream is produced at the local network node. In this process, a realtime data stream is processed through the created stream handler.","In another aspect, the invention features a method in accordance with which a specification of a realtime stream handler is parsed from one or more stream handling instructions. In this process, an input source identifier, an output sink identifier, and a respective identifier of each of one or more data processing objects are parsed from the one or more stream handing instructions. Realtime stream handling objects corresponding to respective ones of the identifiers are instantiated. A directed graph that includes ones of the instantiated realtime stream handling objects are created in accordance with the specification. A realtime data stream is received from an input source corresponding to the input source identifier. A resultant data stream is produced at an output sink corresponding to the output sink identifier. In this process, the realtime data stream is processed through the directed graph.","In another aspect, the invention features a method in accordance with which at least one realtime data stream connection is established between a local network node and at least one remote network node. At the local network node, at least one realtime data stream that is sourced by the remote network node is processed. In this process, the at least one realtime data stream is processed through one or more realtime data processing operations to produce a resultant data stream. The processing is monitored. In response to a determination based on the monitoring that the processing deviates from a performance target, the processing is modified in accordance with a realtime performance targeting routine.","In another aspect, the invention features a method in accordance with which, on a local network node, a first session is established with a remote network node on a transport stream in accordance with a connectionless transport protocol. On behalf of one or more software entities on the local network node, one or more channels over which data is transmitted between the local network node and the remote network node in the first session automatically are opened. In the first session, a table is maintained. The table identifies open ones of the channels and associates respective attribute values with the identified channels. In response to a determination that the first session has failed, a second session with the remote network node is automatically attempted to be established on a second transport stream in accordance with the connectionless transport protocol. In response to successful establishment of the second session, each of the channels identified in the table automatically is opened.","In another aspect, the invention features a method in accordance with which a list of kernel components that include one or more kernel service components is parsed. All the kernel components in the parsed list that are missing from a local repository are determined. Each of the kernel components determined to be missing is retrieved. Kernel services are instantiated from ones of the kernel service kernel components. The instantiated kernel services are executed to communicate with one or more remote network nodes in a communication environment defined with respect to a virtual area.","In another aspect, the invention features a method that is performed on a local network node. In accordance with this method the local network node is configured to support realtime communications with at least one remote network node in a context defined by a virtual area. The configuration process includes: returning a list comprising identifiers of all plugins associated with the specified API in a plugin database in response to a call to enumerate all plugins that support a specified application programming interface (API); delivering a list comprising identifiers of all variants of the given API that are supported by the identified plugin in response to a call to enumerate variants of a given API supported by an identified one of the plugins; and loading the identified plugin and providing a pointer to an instance of the identified variant in response to a call to instantiate an identified one of the variants of an identified API supported by an identified one of the plugins. At least one realtime data stream connection is established between the configured local network node and the at least one remote network node.","The invention also features apparatus operable to implement the inventive methods described above and computer-readable media storing computer-readable instructions causing a computer to implement the inventive methods described above.","Other features and advantages of the invention will become apparent from the following description, including the drawings and the claims.","In the following description, like reference numbers are used to identify like elements. Furthermore, the drawings are intended to illustrate major features of exemplary embodiments in a diagrammatic manner. The drawings are not intended to depict every feature of actual embodiments nor relative dimensions of the depicted elements, and are not drawn to scale.","A \u201ccomputer\u201d is any machine, device, or apparatus that processes data according to computer-readable instructions that are stored on a computer-readable medium either temporarily or permanently.","A \u201ccomputer operating system\u201d is a software component of a computer that manages and coordinates the performance of tasks and the sharing, of software and hardware resources. A \u201ckernel\u201d is a collection of software components that can be invoked by software applications to provide specific functions for accessing computer resources (e.g., CPU, memory, network links, and peripheral resources). A \u201csoftware application\u201d (also referred to as software, an application, computer software, a computer application, a program, and a computer program) is a set of instructions that a computer can interpret and execute to perform one or more tasks.","An \u201capplication programming interface\u201d for API) is a set of declarations of the functions (or procedures) that an operating system, library, or service provides to support requests made by a software application. An API specifies an interface and the behavior of the identifiers specified in that interface. An implementation of an API refers to the software application code that provides the functionality described by the API. A \u201ccomputer data file\u201d is a bock of information that durably stores data for use by a software application.","A \u201cservice\u201d is a process that performs a task on its own initiative (independently of other processes).","A \u201cmanager\u201d is a gateway for a service to perform tasks. A manager does not perform a task on its own initiative.","A \u201cdatabase\u201d is an organized collection of records that are presented in a standardized format that can be searched by computers. A database may be stored on a single computer-readable data storage medium on a single computer or it may be distributed across multiple computer-readable data storage media on one or more computers.","A \u201cdata sink\u201d (referred to herein simply as a \u201csink\u201d) is any of a device, part of a device (e.g., a computer), or software that receives data.","A \u201cdata source\u201d (referred to herein simply as a \u201csource\u201d) is any of a device, part of a device (e.g., a computer), or software that originates data.","A \u201cnetwork node\u201d (also referred to simply as a \u201cnode\u201d) is a junction or connection point in a communications network. Exemplary network nodes include, but not limited to, a terminal, a computer, and a network switch. A \u201cserver network node\u201d is a host computer on a network that responds to requests for information or service. A \u201cclient network node\u201d is a computer on a network that requests information or service from a server. A \u201cnetwork connection\u201d is a link between two communicating network nodes. The term \u201clocal network node\u201d refers to a network node that currently is the primary subject of discussion. The term \u201cremote network node\u201d refers to a network node that is connected to a local network node by a network communications link.","\u201cPresence\u201d refers to the ability and willingness of a networked entity (e.g., a communicant, service, or device) to communicate, where such willingness affects the ability to detect and obtain information about the state of the entity on a network and the ability to connect to the entity.","A \u201crealtime data stream\u201d is data that is structured and processed in a continuous flow and is designed to be received with no delay or only imperceptible delay. Realtime data streams include digital representations of voice, video, user movements, facial expressions and other physical phenomena as well as data within the computing environment that may benefit from rapid transmission, rapid execution, or both rapid transmission and rapid execution, including for example, avatar movement instructions, text chat, realtime data feeds (e.g., sensor data, machine control instructions, transaction streams and stock quote information feeds), and file transfers.","A \u201cstream mix\u201d is a combination of two or more realtime data streams of the same or semantically consistent type (e.g., audio, video, chat, and motion data). For example, a set of voice streams might be mixed into a single voice stream or a voice stream might be mixed into the audio portion of a video stream.","A \u201cswitching rule\u201d is an instruction that specifies a connection or disconnection of one or more realtime data sources and one or more realtime data inks subject to one or more conditions precedent.","A \u201cvirtual area\u201d (also referred to as an \u201carea\u201d or a \u201cplace\u201d) is a representation of a computer-managed space or scene. Virtual areas typically are one-dimensional, two-dimensional, or three-dimensional representations; although in some embodiments a virtual area may correspond to a single point. Oftentimes, a virtual area is designed to simulate a physical, real-world space. For example, using a traditional computer monitor, a virtual area may be visualized as a two-dimensional graphic of a three-dimensional computer-generated space. However, virtual areas do not require an associated visualization to implement switching rules. A virtual area typically refers to an instance of a virtual area schema, where the schema defines the structure and contents of a virtual area in terms of variables and the instance defines the structure and contents of a virtual area in terms of values that have been resolved from a particular context.","A \u201cvirtual area application\u201d (also referred to as a \u201cvirtual area specification\u201d) is a description of a virtual area that is used in creating a virtual area communication environment. The virtual area application typically includes definitions of geometry, physics, and realtime switching rules that are associated with one or more zones of the virtual area.","A \u201cvirtual communication environment\u201d is a representation of a computer-managed space that includes at least one virtual area and supports realtime communications between communicants.","A \u201czone\u201d is a region of a virtual area that is associated with at least one switching rule or governance rule. A switching rule controls switching (e.g., routing, connecting, and disconnecting) realtime data streams between network nodes communicating in the context of a virtual area. A governance rule controls a communicant's access to a resource (e.g., an area, a region of an area, or the contents of that area or region), the scope of that access, and follow-on consequences of that access (e.g., a requirement that audit records relating to that access must be recorded).","A \u201cposition\u201d in a virtual area refers to a location of a point or an area or a volume in the virtual area. A point typically is represented by a single set of one-dimensional, two-dimensional, or three-dimensional coordinates (e.g., x, y, z) that define a spot in the virtual area. An area typically is represented by the three-dimensional coordinates of three or more coplanar vertices that define a boundary of a closed two-dimensional shape in the virtual area. A volume typically is represented by the three-dimensional coordinates of four or more non-coplanar vertices that define a closed boundary of a three-dimensional shape in the virtual area.","In the context of a virtual area, an \u201cobject\u201d is any type of discrete element in a virtual area that may be usefully treated separately from the geometry of the virtual area. Exemplary objects include doors, portals, windows, view screens, and speakerphone. An object typically has attributes or properties that are separate and distinct from the attributes and properties of the virtual area. An \u201cavatar\u201d is an object that represents a communicant in a virtual area.","A \u201ccommunicant\u201d is a person who communicates or otherwise interacts with other persons over a network connection, where the communication or interaction may or may not occur in the context of a virtual area. A \u201cuser\u201d is a communicant who is operating a particular network node that defines a particular perspective for descriptive purposes.","An \u201carea server\u201d is a network node that includes an area network infrastructure service, which administers a virtual area that hosts a virtual area application by managing sessions of client nodes associated with objects in the virtual area.","As used herein, the term \u201cincludes\u201d means includes but not limited to, and the term \u201cincluding\u201d means including but not limited to.","The embodiments that are described herein provide a realtime kernel that supports realtime communications between communicants operating on respective network nodes. The realtime kernel handles the complex tasks of connecting to communicants, virtual areas, and other network resources, switching those connections in response to user inputs, and mixing realtime data streams. The realtime kernel enables developers to focus on developing high-level communications functionality instead of low-level plumbing code. The realtime kernel imposes relatively low computational resource requirements so that realtime communications performance can be achieved using a wide range of computing devices and network connections that currently are available.","In some embodiments, the realtime kernel supports remote configuration and execution of audio and graphic rendering engines, as well as switching of realtime data streams in response to instructions (also referred to as definitions) that are received from a remotely hosted virtual area application. In this way, the realtime kernel enables virtual area designers to maintain control over the presentation of immersive virtual communication environments on remote client network nodes, thereby encouraging the development of a wide variety of different types of virtual areas and increasing the number of users who will want to adopt the communications system.","In some embodiments, the realtime kernel monitors the processing of a realtime data stream and adapts the processing based on deviations of the processing from a performance target. In this way, the realtime kernel increases the likelihood that realtime performance can be achieved regardless of the computing environment in which the realtime data stream processing is being performed.","In some embodiments, the realtime kernel implements a stream transport protocol that is efficient in connection and disconnection, as well as in transport. In some of these embodiments, the stream transport protocol provides a connection-oriented, encrypted connection over a connectionless transport protocol (e.g., UDP). The realtime kernel additionally provides between a client application and the transport layer a reconnection mechanism that automatically attempts to reestablish failed connections without intervention by the client application, thereby adding reliability on top of an inherently unreliable communication protocol.","In some embodiments, the realtime kernel has a plugin architecture that allows the functionalities of kernel components to be provided by one or more plugins that can be loaded dynamically on client network nodes. In this way, kernel components can be independently developed and remotely managed and updated. The plugin architecture additionally allows the installation footprint of the realtime kernel to be reduced substantially, thereby allowing the kernel to be installed on a wide range of client devices including those with significant computing and memory resource constraints.","A. Introduction",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 1","b":["10","12","14","16","18","12","20","22","24","14","12","16","26","28","12","14","28","28","30","26","28","30"]},"In the process of creating the shared virtual area communication environment, the area service  remotely configures the realtime kernels in the first and second client network nodes ,  in accordance with the remote virtual area application  subject to a set of constraints  on the virtual area application . The constraints  typically include controls on access to the virtual area. The access controls typically are based on one or more of capabilities (where access is granted to communicants or client nodes having proper capabilities or permissions) and an access control list (where access is granted to communicants or client nodes having identities that are on the list). In some embodiments, the constraints  are administered by a security network infrastructure service (described below). Client software applications operating on the first and second client network nodes ,  allow communicants to access the shared virtual area communication environment by presenting respective views of the virtual area in accordance with data received from the area service  via the realtime kernel  and by providing an interface for receiving commands from the communicants. The communicants typically are represented in the virtual area by respective avatars, which move about the virtual area in response to commands that are input by the communicants at their respective network nodes. Each communicant's view of the virtual area typically is presented from the perspective of the communicant's avatar, which increases the level of immersion that is experienced by the communicant. Each communicant typically is able to view any part of the virtual area around his or her avatar. The realtime kernels operating on the first and second client network nodes ,  establish realtime data stream connections with other network nodes sharing the virtual area communication environment based at least in part on the positions of the communicants' avatars in the virtual area.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["20","20","26","34","20","28","36","32","26","20","20","26","38","20","24","26","40"]},"In some embodiments, the process of configuring the I\/O hardware  involves dynamically configuring at least one of the stream handlers  in accordance with the instructions that are received from the remote network node  and the position data. For example, the virtual area application  may specify one or more audio effects that should be applied to audio streams that are associated with the objects currently in the virtual area, in which case the area service  sends to the realtime kernels executing on the first and second client network nodes ,  instructions that configure their respective audio stream handlers to implement the specified effects in accordance with the positions of the respective objects in the virtual area.","The realtime kernel  processes realtime data streams that are associated with the communicant objects through each of the configured stream handlers  to produce a respective output . Depending on its content, the output  may be stored on a computer-readable medium or converted into a human-perceptible output by the I\/O hardware operating on the first and second network nodes , . For example, audio output signals are converted into audible sounds by audio hardware (e.g., a sound card and speakers) and graphic output signals are converted into visible images by graphic hardware (e.g., a video card and a display). In some embodiments, the output  that is produced by at least one of the stream handlers  is processed by one or more downstream software components that in turn produce an output that either may be stored on a computer-readable medium or converted into a human-perceptible output.","B. An Exemplary Operating Environment","The realtime kernel  operates in the context of the virtual area communication environment , which includes the network  and a network infrastructure service environment that includes a number of network infrastructure services including the area service . The realtime kernel  and the network infrastructure service environment constitute a platform for creating virtual area communication environments for communicants.","1. Network Environment","The network  may include any of a local area network (LAN), a metropolitan area network (MAN), and a wide area network (WAN) (e.g., the internet). The network  typically includes a number of different computing platforms and transport facilities that support the transmission of a wide variety of different media types (e.g., text, voice, audio, and video) between network nodes.","The realtime kernel  typically operates on a network node that includes software and hardware resources which\u2014together with administrative policies, user preferences (including preferences regarding the exportation of the user's presence and the connection of the user to areas and connection targets), and other settings\u2014define a local configuration that influences the administration of realtime connections with other network nodes. The network connections between network nodes may be arranged in a variety of different stream handling topologies, including a peer-to-peer architecture, a server-mediated architecture, and hybrid architectures that combine aspects of peer-to-peer and server-mediated architectures.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 3A","b":["42","10","12","14","16","18","12","16","28","16","16","12","14","16","12","14","16","16","28","30","12","14","16","12","14"]},{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 3B","FIG. 3A"],"b":["44","10","12","16","46","46","16","46","12","16","12","16","46","12","16"]},"2. Network Infrastructure Services","One or more network infrastructure services typically cooperate with the realtime kernel  in the process of establishing and administering the network connections with other network nodes. The network infrastructure services may run on a single network node or may be distributed across multiple network nodes. The network infrastructure services typically run on one or more dedicated network nodes (e.g., a server computer or a network device that performs edge services, such as routing and switching). In some embodiments, however, one or more of the network infrastructure services run on at least one of the communicants' network nodes. Among the network infrastructure services that are included in the exemplary embodiment of the virtual area communication environment  are an account service, a security service, the area service , a rendezvous service, and an interaction service.","The account service manages communicant accounts in the network infrastructure service environment. The account service also manages the creation and issuance of authentication tokens that can be used by client network nodes to authenticate themselves to any of the network infrastructure services.","The security service controls communicants access to the assets and other resources of the virtual area communication environment . The access control method implemented by the security service typically is based on one or more of capabilities (where access is granted to entities having proper capabilities or permissions) and an access control list (where access is granted to entities having identities that are on the list). After a particular communicant has been granted access to a resource, that communicant typically uses the functionality provided by the other network infrastructure services to interact in the virtual area communication environment .","The area service  administers a virtual area. In this process, the area service  manages connections that are associated with the virtual area subject to the capabilities of the requesting entities, maintains global state information for the virtual area, and serves as a data server for the client network nodes participating in a shared communication session in a context defined by the virtual area. The global state information includes a list of all the objects that are in the virtual area and their respective locations in the virtual area. The area service  sends instructions that configure the client network nodes. The area service  also registers and transmits initialization information to other client network nodes that request to join the communication session. In this process, the area service  transmits to each joining client network node a list of components (e.g., plugins) that are needed to render the virtual area  on the client network node in accordance with the virtual area application . The area service  also ensures that the client network nodes can synchronize to a global state if a communications fault occurs.","The rendezvous service manages the collection, storage, and distribution of presence information and provides mechanisms for network nodes to communicate with one another (e.g., by managing the distribution of connection handles) subject to the capabilities of the requesting entities. The rendezvous service typically stores the presence information in a presence database.","The interaction service maintains an interaction database that records interactions between communicants and supports queries on the interaction database subject to the capabilities of the requesting entities. For every interaction between communicants, one or more services in the virtual area communication environment  (e.g., the area service ) transmit interaction data to the interaction service. In response, the interaction service generates one or more respective interaction records in the relationship database. Each interaction record describes the context of an interaction. For example, in some embodiments, an interaction record contains an identifier for each of the communicants, an identifier for the place of interaction (e.g., a virtual area instance), a description of the hierarchy of the interaction place (e.g., a description of how the interaction room relates to a larger area), start and end times of the interaction, and a list of all files and other streams shared during the interaction. Thus, for each realtime interaction, the interaction service tracks when it occurred, where it occurred, and what happens during the interaction in terms of communicants involved (e.g., entering and exiting), objects that are activated\/deactivated, and the files that were shared.","The interaction service is able to present the results of queries on the interaction database records in a sorted order (e.g., most frequent or most recent) based on place. The query results can be used to drive a frequency sort of contacts whom a communicant has met in which virtual areas, as well as sorts of who the communicant has met with regardless of virtual area and sorts of the virtual areas the communicant frequents most often. The query results also may be used by application developers as part of a heuristic system that automates certain tasks based on relationships. An example of a heuristic of this type is a heuristic that permits communicants who have visited a particular virtual area more than five times to enter without knocking by default, or a heuristic that allows communicants who were present in an area at a particular time to modify and delete files created by another communicant who was present in the same area at the same time. Queries on the interaction database can be combined with other searches. For example, queries on the interaction database may be combined with queries on contact history data generated for interactions with contacts using a communication system (e.g., Skype, Facebook, and Flickr) that is outside the domain of the network infrastructure service environment.","3. Virtual Areas","The realtime kernel  administers the realtime connections with network nodes in a communication context that is defined by an instance of a virtual area. The virtual area instance may correspond to an abstract (non-geometric) virtual space that is defined with respect to abstract coordinates. Alternatively, the virtual area instance may correspond to a visual virtual space that is defined with respect to one-, two- or three-dimensional geometric coordinates that are associated with a particular visualization. Abstract virtual areas may or may not be associated with respective visualizations, whereas visual virtual areas are associated with respective visualizations.","As explained above, communicants typically are represented by respective avatars in a virtual area that has an associated visualization. The avatars move about the virtual area in response to input commands that are input by the communicants at their respective network nodes. The communicant's view of a virtual area instance that has an associated visualization typically is presented from the perspective of the communicant's avatar, and each communicant typically is able to view any part of the visual virtual area around his or her avatar, increasing the level of immersion that is experienced by the communicant.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 4","b":["48","48","50","52","554","56","58","60","50","62","62","64","62","66","66","68","70","72","66"]},"As explained in detail below, the virtual area  includes zones , , , ,  that are associated with respective rules that govern the switching of realtime data streams between the network nodes that are represented by the avatars - in the virtual area . (During a typical communication session, the dashed lines demarcating the zones - in  are not visible to the communicants although there may be visual cues associated with such zone boundaries.) The switching rules dictate how local connection processes executing on each of the network nodes establishes communications with the other network nodes based on the locations of the communicants' avatars - in the zones - of the virtual area .","A virtual area is defined by a specification that includes a description of geometric elements of the virtual area and one or more rules, including switching rules and governance rules. The switching rules govern realtime stream connections between the network nodes. The governance rules control a communicant's access to resources, such as the virtual area itself, regions with the virtual area, and objects within the virtual area. In some embodiments, the geometric elements of the virtual area are described in accordance with the COLLADA\u2014Digital Asset Schema Release 1.4.1 April 2006 specification (available from http:\/\/www.khronos.org\/collada\/), and the switching rules are described using an extensible markup language (XML) text format (referred to herein as a virtual space description format (VSDL)) in accordance with the COLLADA Streams Reference specification described in U.S. application Ser. Nos. 11\/923,629 and 11\/923,634.","The geometric elements of the virtual area typically include physical geometry and collision geometry of the virtual area. The physical geometry describes the shape of the virtual area. The physical geometry typically is formed from surfaces of triangles, quadrilaterals, or polygons. Colors and textures are mapped onto the physical geometry to create a more realistic appearance for the virtual area. Lighting effects may be provided, for example, by painting lights onto the visual geometry and modifying the texture, color, or intensity near the lights. The collision geometry describes invisible surfaces that determine the ways in which objects can move in the virtual area. The collision geometry may coincide with the visual geometry, correspond to a simpler approximation of the visual geometry, or relate to application-specific requirements of a virtual area designer.","The switching rules typically include a description of conditions for connecting sources and sinks of realtime data streams in terms of positions in the virtual area. Each rule typically includes attributes that define the realtime data stream type to which the rule applies and the location or locations in the virtual area where the rule applies. In some embodiments, each of the rules optionally may include one or more attributes that specify a required role of the source, a required role of the sink, a priority level of the stream, and a requested stream handling topology. In some embodiments, if there are no explicit switching rules defined for a particular part of the virtual area, one or more implicit or default switching rules may apply to that part of the virtual area. One exemplary default switching rule is a rule that connects every source to every compatible sink within an area, subject to policy rules. Policy rules may apply globally to all connections between the area clients or only to respective connections with individual area clients. An example of a policy rule is a proximity policy rule that only allows connections of sources with compatible sinks that are associated with respective objects that are within a prescribed distance (or radius) of each other in the virtual area.","In some embodiments, governance rules are associated with a virtual area to control who has access to the virtual area who has access to its contents, what is the scope of that access to the contents of the virtual area (e.g., what can a user do with the contents), and what are the follow-on consequences of accessing those contents (e.g., record keeping, such as audit logs, and payment requirements). In some embodiments, an entire virtual area or a zone of the virtual area is associated with a \u201cgovernance mesh.\u201d In some embodiments, a governance mesh is implemented in a way that is analogous to the implementation of the zone mesh described in U.S. application Ser. Nos. 11\/923,629 and 11\/923,634. A governance mesh enables a software application developer to associate governance rules with a virtual area or a zone of a virtual area. This avoids the need for the creation of individual permissions for every file in a virtual area and avoids the need to deal with the complexity that potentially could arise when there is a need to treat the same document differently depending on the context.","In some embodiments, a virtual area is associated with a governance mesh that associates one or more zones of the virtual area with a digital rights management (DRM) function. The DRM function controls access to one or more of the virtual area or one or more zones within the virtual area or objects within the virtual area. The DRM function is triggered every time a communicant crosses a governance mesh boundary within the virtual area. The DRM function determines whether the triggering action is permitted and, if so, what is the scope of the permitted action, whether payment is needed, and whether audit records need to be generated. In an exemplary implementation of a virtual area, the associated governance mesh is configured such that if a communicant is able to enter the virtual area he or she is able to perform actions on all the documents that are associated with the virtual area, including manipulating the documents, viewing the documents, downloading the documents, deleting the documents, modifying the documents and re-uploading the documents. In this way, the virtual area can become a repository for information that was shared and discussed in the context defined by the virtual area.","Additional details regarding the specification of a virtual area are described in U.S. Application Nos. 61\/042,714 (which was filed on Apr. 4, 2008), Ser. No. 11\/923,629 (which was filed on Oct. 24, 2007), and Ser. No. 11\/923,634 (which was filed on Oct. 24, 2007).","4. Other Platform Components","The realtime kernel  is designed to work as a component of a local network node as part of a client software package that additionally includes:\n\n","a. Heads-Up Display (HUD)","The Heads-up Display (HUD) is an application interface to the realtime kernel , which operates on each client network node. The HUD is a small, lightweight interface that a user can keep up and running all the time on his or her desktop. It is the user's interface for launching virtual area applications, providing him or her with immediate access to realtime contacts and realtime collaborative places (or areas). A virtual area is integrated with the user's desktop through the HUD and the realtime kernel  such that the user can drag and drop files into the virtual area communications environment, use files stored in association with the virtual area using the native client software applications independently of the virtual area communications environment while still present in a virtual area, and more generally treat presence and position within a virtual area as an aspect of their operating environment analogous to other operating system functions rather than just one of several applications.",{"@attributes":{"id":"p-0116","num":"0119"},"figref":"FIGS. 5A and 5B","b":["84","84","84"],"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["Small, lightweight application that is intended to be running all the time on the user's desktop; and","Provides the user with an easy interface to see and interact with contacts as well as the virtual areas where interactions occur."]}}}},"In this embodiment, the HUD  is implemented by a substantially transparent (semi-translucent) user interface overlay that provides a persistent interface and access to controls. In the embodiment shown in , the HUD  is transparent except for a limited set of one or more of the following semi-translucent elements of the interface:\n\n","The communicant is able to work in a normal desktop computing environment while the realtime kernel  and the HUD  are running and ready to initiate realtime communications sessions. For example, the communicant may work with other applications, such as Microsoft\u00ae Excel\u00ae, to create a document that can later be shared in a realtime communications session. The virtual area  is integrated with the communicants desktop such that the communicant can drag and drop files into the virtual area, use files stored in association with the virtual area using native client software applications independently of the virtual area communications environment while still present in a virtual area, and more generally treat presence and position within a virtual area as an aspect of the operating environment analogous to other operating system functions rather than one of several applications.","While the communicant interacts in the virtual area , the HUD  provides the communicant with independent control over his or her desired visualization. For example, a communicant may display a minimized view of the virtual area (minimized to the lower right-hand corner of the desktop) and participate in an audio conversation with another communicant in the virtual area while working in different application such as Microsoft\u00ae Excel\u00ae. A communicant then can change his or her visualization schema and enter into a more immersive three-dimensional rendering of the virtual area . This is accomplished by changing the setting of the progressive immersion slider  in the HUD  from \u201cDesktop\u201d to \u201c3D\u201d. Once in the 3D visualization mode, the communicant's desktop displays a 3D rendition of the virtual are  (as shown in ). The communicants (represented by sprites , ,  in the Desktop mode) now take the form of three-dimensional avatars , , , as shown in .","Any data that is associated with the virtual area  can be displayed on view screens , , . A view screen is a generic data rendering component that can be used to render any arbitrary data. Examples of the types of data that can be rendered on a view screen include:\n\n","As shown in , the HUD  is designed to serve as a true interface that displays information and provides access to controls with only minimal obscuration of the underlying parts of the graphical user interface  being presented on the communicant's display monitor. The HUD  efficiently shows:\n\n","The HUD  shows an ordered set of place tiles , , . Clicking on one of the place tiles brings the user to the virtual area represented by the selected place tile. For people, we have a basic metaphor of Go (to the communicant's area) and Get (bring them to the user's area). This is refined in the HUD  by allowing communicants to queue requests to go or get, as well as communicate with people via text or voice without \u201cmoving.\u201d The HUD  notifies the communicant when each communication request is received from another communicant. The communicant can accept the request, ignore it, or add it to a communications queue. In this way, communicants can respond to non-priority communications at a later time. For example, a communicant can queue communications received during a time when the communicant is busy (e.g., engaged in a current communications session) and, after the communicant is free, the communicant can respond to communication requests in the communications queue.","As described above, the interaction network infrastructure service maintains an interaction database that records who the communicant meets with and where. The interaction service responds to queries on the relationship database with query results that may be presented in a sorted order (e.g., most frequent or most recent) based on place. In this way, the relationship database information can be used to drive a frequency sort of who the communicant met in which areas, as well as sorts of who the communicant has met with regardless of area, and sorts of the areas the communicant has frequented most often. This data is used in the HUD . This data also may be used by virtual area application developers as part of a heuristic system (e.g. a rule that permits people who have visited a particular virtual area more than five times to enter without knocking by default, or people who were present in a virtual area at a particular time to modify and delete files created by another communicant there at the same time).","In , the HUD  presents a series of place tiles , ,  that represent respective virtual areas. Each of the virtual areas is tied to queries on the relationship database. With respect to each virtual area, the rendezvous service does a query on the relationship database for all of the contacts the user has met with in that virtual area. The rendezvous service typically presents the identified contacts in a list that is sorted either by frequency or by recentness of interaction (e.g., the contact with whom the communicant interacted with last). In other embodiments, the contacts may be sorted in some other application-dependent way.","Queries on the relationship database can be combined with other searches. For example, queries on the relationship database may be combined with queries on contact history data generated for interactions with contacts using another communication system (e.g., Skype, Facebook, and Flickr). In one example, the Skype virtual area  may be associated with a query on a communicants relationship data associated with the Skype virtual area  and the communicant's Skype history data to produce a sorted list of realtime contacts of the user that are associated with the Skype virtual area .",{"@attributes":{"id":"p-0126","num":"0143"},"figref":"FIG. 5C","b":["84","108","112","114","84","86","86","116","108","110"]},"Should any communicant exit a virtual area or enter a virtual area, the presence indicators (i.e., the sprites shown by circles, which typically are associated with names or other identifiers) in that virtual area will automatically be updated in realtime. This feature demonstrates the ability of a virtual area designer to put application-specific realtime data into a place tile. The place tile may appear either associated with a communicant, or with the communicant's places. For example, a game developer may export a map of where a communicant is in their game environment such that other people connected to that communicant through the relationship database receive a realtime feed of that communicant's current activities. These people can use this virtual area tile to navigate to that communicant, communicate with him or her, or contact him or her (e.g., send an invitation to enter a virtual area). The HUD  manages this interface to contacts and virtual areas for many different virtual areas simultaneously.","The realtime data used in the HUD virtual area tiles , , ,  is provided by an interface that is managed by the area service hosting the relevant area via the realtime kernel . Each area service may provide a different respective HUD virtual area tile data feed to communicants based on the communicants' permissions to view the hosted virtual area. For example, if a communicant enters a virtual area that the communicant does not have permission to view, the HUD virtual area tile may show limited or no detailed information. In addition, the HUD virtual area tile data feed that is provided by the hosting area service may be customized by the virtual area provider operating that area service to present an application-specific view of the virtual area to subscribing HUDs.","b. Local Human Interface Device (HID) and Audio Playback Devices","The local HID devices enable a communicant to input commands and other signals into the client network node while participating in a virtual area communications session. Exemplary HID devices include a computer keyboard, a computer mouse, a touch screen display, and a microphone.","The audio playback devices enable a communicant to playback audio signals received during a virtual area communications session. Exemplary audio playback devices include audio processing hardware (e.g., a sound card) for manipulating (e.g., mixing and applying special effects) audio signals, and speakers for outputting sounds.","c. So3D Graphical Display, Avatar, and Physics Engine","The So3D engine is a three-dimensional visualization engine that controls the presentation of a respective view of a virtual area and objects in the virtual area on a display monitor. The So3D engine typically interfaces with a graphical user interface driver and the HID devices to present the views of the virtual area and to allow the communicant to control the operation of the HUD application.","The So3D engine typically receives graphics rendering instructions from the area service  via the realtime kernel . In some embodiments, the So3D engine also reads a communicant avatar database that contains images needed for rendering the communicant's avatar in the virtual area. Based on this information, the So3D engine generates a visual representation (i.e., an image) of the virtual area and the objects in the virtual area from the point of view (position and orientation) of the communicant's avatar in the virtual area. The visual representation typically is passes to the graphics rendering components of the operating system, which drive the graphics rendering hardware to render the visual representation of the virtual area on the client network node.","The communicant can control the presented view of the virtual area by transmitting commands from a HID device (e.g., a computer mouse) to the realtime kernel , which transmits view control commands to the So3D engine. The So3D engine updates the view of the virtual area in accordance with the view control commands. The So3D engine also updates the graphic representation of the virtual area on the display monitor in accordance with updated object position information that is received from the area service  via the realtime kernel .","d. System Database and Storage Facility","The system database and storage facility stores various kinds of information that is used by the platform. Exemplary information that typically is stored by the storage facility includes the presence database, the interaction database, an avatar database, a real user id (RUID) database, an art cache database, and a virtual area specification database. This information may be stored on a single network node or it may be distributed across multiple network nodes.","C. Exemplary Communication Session","Referring back to , during a communication session, each of the client network nodes generates a respective set of realtime data streams (e.g., motion data streams, audio data streams, chat data streams, file transfer data streams, and video data streams). For example, each communicant manipulates one or more input devices (e.g., the computer mouse  and the keyboard ) that generate motion data streams, which control the movement of his or her avatar in the virtual area . In addition, the communicant's voice and other sounds that are generated locally in the vicinity of the computer system  are captured by the microphone . The microphone  generates audio signals that are converted into realtime audio streams. Respective copies of the audio streams are transmitted to the other network nodes that are represented by avatars in the virtual area . The sounds that are generated locally at these other network nodes are converted into realtime audio signals and transmitted to the computer system . The realtime kernel  converts the audio streams that are generated by the other network nodes into audio signals that are rendered by the speakers , . The motion data streams and audio streams may be transmitted from each of the communicant nodes to the other client network nodes either directly or indirectly. In some stream handling topologies, each of the client network nodes receives copies of the realtime data streams that are transmitted by the other client network nodes. In other stream handling topologies, one or more of the client network nodes receives one or more stream mixes that are derived from realtime data streams that are sourced (or originated) from other ones of the network nodes.","In some embodiments, the area service  maintains global state information that includes a current specification of the virtual area, a current register of the objects that are in the virtual area, and a list of any stream mixes that currently are being generated by the network node that is hosting the area service . The objects register typically includes for each object in the virtual area a respective object identifier (e.g., a label that uniquely identifies the object), a connection handle (e.g., a URI, such as an IP address) that enables a network connection to be established with a network node that is associated with the object, and interface data that identifies the realtime data sources and sinks that are associated with the object (e.g., the sources and sinks of the network node that is associated with the object). The objects register also typically includes for each object one or more optional role identifiers, which may be assigned explicitly to the objects by either the communicants or the area service , or may be inferred from other attributes of the objects. In some embodiments, the objects register also includes the current position of each of the objects in the virtual area as determined by the area service  from an analysis of the realtime motion data streams received from the network nodes associated with objects in the virtual area. In this regard, the area service  receives realtime motion data streams from the network nodes associated with objects in the virtual area, tracks the communicants' avatars and other objects that enter, leave, and move around in the virtual area based on the motion data. The area service  updates the objects register in accordance with the current locations of the tracked objects.","In the process of administering realtime data stream connections with other network nodes, the area service  maintains for each of the client network nodes a set of configuration data, including interface data, a zone list, and the positions of the objects that currently are in the virtual area. The interface data includes for each object associated with each of the client network nodes a respective list of all the sources and sinks of realtime data stream types that are associated with the object. The zone list is a register of all the zones in the virtual area that currently are occupied by the avatar associated with the corresponding client network node. When a communicant first enters a virtual area, the area service  typically initializes the current object positions database with position initialization information. Thereafter, the area service  updates the current object positions database with the current positions of the objects in the virtual area as determined from an analysis of the realtime motion data streams received from the other client network nodes sharing the virtual area.",{"@attributes":{"id":"p-0142","num":"0159"},"figref":["FIG. 6","FIG. 6"],"b":["26","26","180","26","26","26"]},"The area service  determines a set of target realtime data stream types that are defined for the zones in the occupied zones list (, block ). The area service  then determines a set of required realtime data stream data from the set of target realtime data stream types, the positions of the objects in the virtual area instance, and the switching rules defined in the virtual area specification (, block ).","In some exemplary embodiments, after the area service  has determined the set of realtime data stream data that enables the user to participate in a collaborative communication session with other network nodes in the shared virtual area instance (, block ), the area service  determines the realtime data stream connections that will result in the delivery of the required data stream data to the computer system .","In some of these embodiments, the area service  determines a realtime data stream handling topology that delivers the set of realtime data streams to the computer system  based at least in part on bandwidth capabilities of the computer system . In this process, the area service  determines a respective form in which to receive each of the realtime data streams from an unmixed realtime data stream and a stream mix derived from a combination of realtime data streams. The area service  also determines a network route over which each of the realtime streams is received from a direct peer-to-peer network route and a network route mediated by one or more of the other network nodes. After the stream handling topology has been determined, the area service  sends instructions to the realtime kernel operating on the computer system . The instructions specify the required realtime data stream connections between the computer system  and other ones of the network nodes in accordance with the determined stream handling topology.",{"@attributes":{"id":"p-0146","num":"0163"},"figref":"FIG. 7","b":["20","120"]},"In accordance with this method, the realtime kernel  determines if the computer system  has sufficient bandwidth to receive the set of required realtime data stream data  directly from the other network nodes (, block ). In this process, the other network nodes transmit link requests to the computer system . The link requests indicate the respective bandwidth requirements for transmitting the respective sets of realtime data streams needed by the computer system . The realtime kernel  compares the overall bandwidth that is needed to establish the required direct connections with the download bandwidth that is available currently to the computer system .","If the available bandwidth is at least equal to the overall required bandwidth, the realtime kernel  establishes direct connections with the other network nodes that provide the required realtime data stream data (, block ). In this process, the realtime kernel  creates sockets (e.g., TCP sockets or specialized realtime sockets optimized for performance) between the computer system  and one or more of the other network nodes. The realtime kernel  processes the realtime data streams, including encrypting them, recording them, and delivering the processed data streams to downstream software components as needed for rendering into the user interface and transmission over the network .","If the available bandwidth is less than the required bandwidth (, block ), the realtime kernel  checks the stream mix list to determine if a stream mix that provides the required realtime data stream data currently is being generated by the area service  (, block ). If the needed stream mix is available, the realtime kernel  establishes with the area service  a connection over which a copy of the needed realtime data stream mix is transmitted from the area server  to the computer system  (, block ). If the needed stream mix is not available, the realtime kernel  sends a stream mix request to the area service  (, block ). If possible, the area service  generates the needed stream mix in response to the stream mix request.","A. Introduction","A communicant typically connects to the network  from a client network node, which typically is implemented by a general-purpose computer system or a dedicated communications computer system (or \u201cconsole\u201d, such as a network-enabled video game console). The network node executes communications processes that establish realtime data stream connections with other network nodes and typically executes visualization rendering processes that present a view of each virtual area entered by the communicant.",{"@attributes":{"id":"p-0152","num":"0169"},"figref":"FIG. 8","b":["120","120","122","124","126","122","120","122","124","120","126","120","128","126"]},"A communicant may interact (e.g., input commands or data) with the computer system  using one or more input devices  (e.g. one or more keyboards, computer mice, microphones, cameras, joysticks, physical motion sensors such Wii input devices, and touch pads). Information may be presented through a graphical user interface (GUI) that is presented to the communicant on a display monitor , which is controlled by a display controller . The computer system  also may include other input\/output hardware  (e.g., peripheral output devices, such as speakers and a printer). The computer system  connects to other network nodes , , and  through a network adapter  (also referred to as a \u201cnetwork interface card\u201d or NIC).","A number of program modules may be stored in the system memory , including an operating system (OS)  (e.g., the Windows XP\u00ae operating system available from Microsoft Corporation of Redmond, Wash. U.S.A.), the realtime kernel , drivers  (e.g., a GUI driver), network protocols , a local software application  (e.g., the HUD ), and data (e.g., input data, output data, program data, a registry , and the configuration settings ).","B. Operating System","The operating system  hosts software applications by providing the base operating system services for creating a run-time execution environment on the computer system . Among the exemplary types of services that typically are provided by the operating system are resource management, file management, security, authentication, verification, notification, and user interfaces (e.g., windowing, menus, dialogs, etc.).","The services relating to the management of the resources (e.g., memory, processors, and I\/O devices) of the computer system  typically are implemented by an operating system kernel. File management may be implemented by the operating system kernel or it may be implemented by a separate file system manager (e.g., the installable file system, which is provided in some Microsoft\u00ae Windows\u00ae operating systems). In the process of opening a file (e.g., a computer data file or a software application file), the file system manager typically calls an appropriate file system driver that looks up the disk storage location of the file in a database (e.g., a file allocation table, such as FAT, FAT98, VFAT, MET, and CDFS) that maps out the storages locations of the file on the disk. Other operating system functions, such as security, authentication, verification, notification, and user interfaces, may be provided by one or more other components of the operating system (e.g., the executive services layer in some Microsoft\u00ae Windows\u00ae operating systems).","Among the exemplary types of services that typically are provided by the operating system kernel are process management, memory management, device management, and system call handling. Process management includes running applications and providing an application programming interface (API) to hardware components of the computer system. In the process of running a software application, the operating system kernel typically sets up an address space in memory for the software application, loads a file that contains the software application code into the address space, and executes the loaded software application code. Memory management involves managing software application accesses to the system memory . Device management involves providing access to hardware devices through device drivers. System call handling involves providing an API that exposes the operating system kernel services to user mode software applications. By invoking the API (e.g., through inter-process communication mechanisms and system calls), a software application can request a service from the operating system kernel, pass parameters, and receive results that are generated by the service in response to the request.","The operating system  typically stores hardware and software configuration information, user preferences, and setup information in the registry . For example, the registry  typically contains the following information: parameter values that are needed to boot and configure the system; system-wide software settings that control the operation of the operating system ; a security database; and per-user profile settings. In some embodiments, the connection rules  are stored in the registry  instead of a separate database.","C. Network Protocols","The network protocols  control or enable the connection, communication, and transfer of data between the computer system  and other network nodes. Exemplary types of network protocols include the Transmission Control Protocol\/Internet Protocol (TCP\/IP), the User Datagram Protocol\/Internet. Protocol (UDP\/IP), the realtime Transport Protocol (RTP), and the Session Initiation Protocol (SIP).","The TCP\/IP includes a TCP portion and an IP portion. The TCP portion of the protocol provides the transport function by breaking a message into smaller packets, reassembling the packets at the other end of the communication network, and re-sending any packets that get lost along the way. The IP portion of the protocol provides the routing function by assigning to the data packets addresses for the destination network and the target node at the destination network. Each data packet that is communicated using TCP\/IP includes a header portion that contains the TCP and IP information. The IP provides no guarantee of packet delivery to the upper layers of the communications stack. The TCP, on the other hand, provides a connection-oriented, end-to-end transport service with guaranteed, in-sequence packet delivery. In this way, the TCP protocol provides a reliable, transport layer connection.","The UDP is a message-oriented transport layer protocol that provides an interface between the application layer and the internet layer. UDP does not guarantee message delivery to the application layer. UDP is a connectionless protocol in that there is no effort made to setup a dedicated end-to-end connection. A UDP sender retains no state information about UDP messages after they are sent. Communication is based on transmission of messages in one direction from source to destination without checking the state of the receiver.","The RTP defines a standardized packet format for delivering audio and video over network connections. A variety of network protocols may be used in transmitting and receiving RTP data between network nodes, including peer-to-peer networking frameworks, a centralized server using TCP sockets alone or in combination with UDP, and multicast protocols.","The SIP provides means for users to locate one another, establish communicative sessions, and terminate active sessions. With a SIP transaction, session negotiations processes are handled in accordance with a Session Description Protocol (SDP).","D. Device Drivers","The device drivers  typically are implemented by software applications that enable other software applications (e.g., user-mode software applications and the operating system) to interact with hardware devices that are connected to the computer system . A device driver typically provides an API for functions that can be invoked by calls made by software processes in order to translate commands and data that are transferred between the software processes and the hardware device.","E. Realtime Kernel","1. Introduction","The realtime kernel  includes services that control the processing and switching of realtime data streams between the computer system  and other network nodes sharing a virtual area communication environment, as well as the presenting of a respective view of a virtual area and objects in the virtual area on the display monitor . In these processes, the realtime kernel interfaces with the operating system functions that communicate with the drivers  to translate commands and data to and from the hardware components of the computer system  in order to exchange realtime data streams with other network nodes and to present an immersive virtual area communication experience to the communicant.","Implementations of the realtime kernel  include one or more discrete modules or libraries (e.g., dynamic linked libraries) that are not limited to any particular hardware, firmware, or software configuration. In general, these modules may be implemented in any computing or data processing environment, including in digital electronic circuitry (e.g., an application-specific integrated circuit, such as a digital signal processor (DSP)) or in computer hardware, firmware, device driver, or software. In some embodiments, the functionalities of the modules are combined into a single data processing component. In some embodiments, the respective functionalities of each of one or more of the modules are performed by a respective set of multiple data processing components. In some implementations, process instructions (e.g., computer-readable code, such as computer software) for implementing the methods that are executed by the embodiments of the realtime kernel , as well as the data they generate, are stored in one or more computer-readable media. Storage devices suitable for tangibly embodying these instructions and data include all forms of non-volatile computer-readable memory, including, for example, semiconductor memory devices, such as EPROM, EEPROM, and flash memory devices, magnetic disks such as internal hard disks and removable hard disks, magneto-optical disks, DVD-ROM\/RAM, and CD-ROM\/RAM.","2. Exemplary Realtime Kernel Functionality","The realtime kernel  cooperates with one or more of the network infrastructure services in establishing and administering the network connections between the computer system  and the other network nodes sharing a virtual area communication environment. Among the exemplary functionalities that are involved in the process of establishing and administering network connections are session administration, remote-controlled stream handling, and realtime task scheduling.","e. Session Administration",{"@attributes":{"id":"p-0175","num":"0192"},"figref":"FIG. 9","b":"20"},"In accordance with the method of , the realtime kernel  determines a designation of a virtual area (, block ). In some embodiments, this functionality of the realtime kernel  is invoked by issuing a realtime kernel API call that includes a virtual area designation to a realtime kernel service. The realtime kernel API call may be made by any of a software application, an operating system service.","The realtime kernel  establishes a session with a network infrastructure service that hosts the designated virtual area (, block ). In this process, the realtime kernel  establishes a session with the area service . The realtime kernel  then transmits to the area service  a request to connect to the designated virtual area. The area service  determines an instance of the virtual area that is designated in the request received from the realtime kernel . After determining the instance of the virtual area instance, the area service  determines if the user's capabilities satisfy the capability requirements associated with the virtual area instance. If the user's capabilities meet the capability requirements, the area service  transmits a message indicating the availability of state data that describes a current state of the virtual area instance (e.g., a list of the objects currently in the virtual area instance, along with the names of communicants associated with those objects).","The realtime kernel  subscribes to state data describing the current state of the virtual area instance (, block ). In response to the subscription request, the area service  publishes the state data to a channel on the link between the realtime kernel  and the area service .","In some embodiments, So3D engine of the realtime kernel  invokes a user interface service of the operating system  to render a human-perceptible view of the state data. For example, the So3D engine may invoke the interface service to render a representation of each of the communicants associated with objects currently in the area on the display . In some embodiments, the communicants may be represented by an icon, thumbnail image, or other graphic that optionally is labeled with the communicant's name. In some embodiments, the state data is presented in a graphical interface of a software application that triggered the invocation of the realtime kernel . In some embodiments, the state data is presented in an embodiment of the heads-up display (HUD) interface  (see ).","After a connection has been established with a virtual area instance, the software application that triggered the invocation of the realtime kernel  can give the user an option to request entry into the virtual area instance or can automatically request entry into the virtual area instance on behalf of the user.",{"@attributes":{"id":"p-0181","num":"0198"},"figref":"FIG. 10","b":"20"},"In accordance with the method of , the realtime kernel  declares an intention to enter the virtual area to the network infrastructure service hosting the virtual area (, block ). In this process, the realtime kernel  sends a message containing the declaration to the area service . The message may be sent on a channel of an existing link with the area service  or over a new link that is established with the area service  by the realtime kernel . In response, the area service  determines if the users capabilities satisfy the capability requirements that are associated with the virtual area instance. If the users capabilities meet the capability requirements, the area service  returns configuration data to the realtime kernel . The configuration data typically includes a definition of the virtual area instance, a register of the objects currently in the virtual area instance, and a set of realtime data stream sources and sinks that are associated with objects in the virtual area in accordance with the specification of the virtual area instance.","The realtime kernel  initiates transfer of at least one realtime data stream over at least one network connection with at least one realtime data stream source respectively associated with at least one object in the virtual area (, block ). In this process, the realtime kernel  ascertains one or more network nodes that are associated with the instance of the virtual area based on the configuration data that was received from the area service . The realtime kernel  then initiates transfer of at least one realtime data stream over at least one network connection with at least one of the ascertained network nodes. The connections between the realtime kernel  and the other network nodes may be peer-to-peer connections or server-mediated connections. With respect to a peer-to-peer connection, the connection target network node and the realtime kernel  typically authenticate one another, and then establish a link over which to transmit the at least one realtime data stream either to or from the connection target. Links typically are one-way and requested by the transmitter and accepted or rejected by the receiver.","In the illustrated embodiment, the realtime kernel  processes the initiated realtime data streams in accordance with at least one stream handling definition in the specification of the virtual area instance (, block ). In this process, the realtime kernel  assembles a set of stream processing objects into a directed graph in accordance with the stream processing configuration that is defined in the virtual area specification.","f. Remote-Controlled Stream Handling",{"@attributes":{"id":"p-0186","num":"0203"},"figref":"FIG. 11","b":["20","26"]},"In accordance with the method of  the realtime kernel  receives one or more stream handling instructions from the area service  operating on a remote network node, where the stream handling instructions include a specification of a stream handler for processing at least one realtime data stream (, block ). The realtime kernel  creates a stream handler in accordance with the stream handler specification (, block ). The stream handler typically includes a mixing function that is specified in the one or more stream handling instructions. The mixing function is used to mix the realtime data stream with at least one other realtime data stream to produce a mixed realtime data stream. The realtime kernel  produces a resultant data stream in a process that includes processing a realtime data stream through the created stream handler (, block ). In some embodiments, this process involves determining configuration parameter values from realtime state information that is specified in the one or more stream handling instructions, and dynamically configuring the stream handler with the configuration parameter values.",{"@attributes":{"id":"p-0188","num":"0205"},"figref":"FIG. 12","b":["206","208","20","210","26","208","20","208","206","208","212","206","208","206","214","216","218","206","220","206","220","222","216","218","224","222"]},"g. Realtime Task Scheduling",{"@attributes":{"id":"p-0190","num":"0207"},"figref":"FIG. 13","b":["20","20"]},"In accordance with the method of , the realtime kernel  establishes at least one realtime data stream connection with at least one remote network node (, block ).","The realtime kernel  processes at least one realtime data stream that is sourced by the remote network node (, block ). In this process, the realtime kernel  processes the at least one realtime data stream through one or more realtime data processing operations to produce a resultant data stream.","The realtime kernel  monitors the processing of the at least one realtime data stream (, block ). In some embodiments, the realtime kernel  monitors one or more of the following parameters: the rate at which the resultant data stream is produced; utilization of at least one processor of the local network node; and bandwidth utilization by at least one networking resource of the local network node. In some embodiments, the realtime data stream is packetized into frames and the realtime kernel  monitors the processing of each of each of the frames during each of successive fixed length intervals that are set in accordance with a local clock, which typically is synchronized with a remote master clock service. Based on the monitoring, the realtime kernel  determines whether or not the processing of the realtime data stream deviates from a performance target. In some embodiments, the performance target includes a time-based threshold on the production of the resultant data stream. For example, in some embodiments, the performance target is a predicate (i.e., condition) on the rate at which frames of the resultant data stream are produced. Exemplary performance targets of this type include a target threshold and a target range.","In response to a determination that the processing of the at least one realtime data stream varies from a performance target, the realtime kernel  modifies the processing in accordance with a realtime performance targeting routine (, block ).",{"@attributes":{"id":"p-0195","num":"0212"},"figref":["FIG. 14","FIG. 14","FIG. 14","FIG. 14","FIG. 14","FIG. 14","FIG. 14"],"b":["20","238","20","240","20","20","242","20","244","20","246","242","20"]},"If the processing of the at least one realtime data stream satisfies the performance target (, block ) and the computational load has been reduced to a lower level by any of the methods described above (, block ), the realtime kernel  increases the computational load from the lower level (, block ). The realtime kernel  typically increases the computational resource load by reversing one or more of the operations that were used to reduce the computational resource load in block  in accordance with a heuristic. If the processing of the at least one realtime data stream satisfies the performance target (, block ) and the computational load has not been reduced to a lower level by any of the methods described above (, block ), the realtime kernel  maintains the current processing of the realtime data stream.","In some embodiments, the realtime kernel  instantiates processing objects that perform respective ones of the data processing operations on the at least one realtime data stream. The realtime kernel  builds a directed graph from ones of the instantiated processing objects and processes the at least one realtime data stream through the directed graph. Depending on the realtime performance targeting routine, the realtime kernel  may modify the processing of the realtime data stream by pruning one or more of the instantiated processing objects from the directed graph. In some embodiments, the processing objects are assigned respective priority values, and the realtime kernel  prunes processing objects by removing ones of the instantiated processing objects from the directed graph based on the assigned priority values. For example, in some of these embodiments, the pruning includes removing from the directed graph ones of the instantiated processing objects having assigned respective priority values that fail to satisfy a priority threshold.","In some embodiments, the realtime kernel  builds from ones of the instantiated processing objects a second directed graph that is used to process a second realtime data stream that is sourced by one of the local network node and the at least one remote network node. In some of these embodiments, the first and second directed graphs are assigned respective priority values, and the realtime kernel modifies the processing of the first and second realtime data streams by preferentially modifying one of the first and second directed graphs based on the assigned priority values. For example, the realtime kernel may tear down the one of the first and second directed graphs that is assigned a lowest priority value.","In some embodiments, the realtime kernel  processes a second realtime data stream through the directed graph, where the second realtime data stream is sourced by one of the local network node and the at least one remote network node. In some of these embodiments, the first and second realtime data streams are assigned respective priority values, and the realtime kernel  preferentially modifies the processing of one of the first and second realtime data streams based on the assigned priority values.","In some embodiments, the realtime kernel  establishes respective realtime data stream connections between the local network node and multiple remote network nodes. The realtime kernel  processes through the directed graph realtime data streams that are sourced by respective ones of the remote network nodes. In some of these embodiments, the realtime data streams are assigned respective priority values, and the realtime kernel  preferentially modifies the processing of one or more of the realtime data streams based on the assigned priority values. The directed graph typically includes multiple directed chains of respective ones of the instantiated processing objects. The realtime kernel  typically processes a respective one of the realtime data streams through each of the directed chains. In some of these embodiments, the realtime kernel  iteratively modifies the processing of the realtime data streams until the processing is within the specified performance target. During each of the iterations, the modifying typically includes performing one or more of (i) removing one or more of the chains from the directed graph and (ii) pruning one or more of the instantiated processing objects from the directed graph.","A. Introduction",{"@attributes":{"id":"p-0202","num":"0219"},"figref":"FIG. 15","b":["260","20","260","26","260","268","260","260","26","26","260","26","26","260"]},"The realtime kernel  includes a set of managers and services. Among the realtime kernel managers are a connection and service mix manager , an area\/zone manager , and a plugin manager . Among the realtime kernel services are a STRAW service , a SODA handler service , a media service , an audio stream service , a So3D interface service , an asset cache service , one or more social processors , a recording, playback, and transport bus service , a realtime scheduler service , a time service , a SIP service , a local HID\/RDS driver handler service , and interface services for local audio devices including local audio playback , a local speaker , a local microphone , and Skype\u00ae audio. In one exemplary embodiment, the realtime kernel  is implemented by the following runtime package components:",{"@attributes":{"id":"p-0204","num":"0221"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"LIBRARIES:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Library Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["SORK.DLL","Realtime scheduler 278"]},{"entry":["Compress.DLL","Compression engine"]},{"entry":["Media.DLL","Media Service 271 for streaming audio transport"]},{"entry":["SODA.DLL","SODA channel service 270 for streaming SODA"]},{"entry":[{},"definition transport"]},{"entry":["GIPS.DLL","GIPS voice components"]},{"entry":["OpenAL.DLL","Open Audio Library for sound card support"]},{"entry":["AudioSvc.DLL","Audio stream service 272"]},{"entry":["TransBus.DLL","Media transport bus including Audio stream service"]},{"entry":[{},"272"]},{"entry":["OpenAL.DLL","Sound card"]},{"entry":["STRAW.DLL","STRAW Service 268 (packet transport engine)"]},{"entry":["CSMMgr.DLL","Connection and Server Mix Manager 262"]},{"entry":["AreaZone.DLL","Area\/Zone Manager 264"]},{"entry":["ArtCache.DLL","Asset Cache service providing SODA interface to art"]},{"entry":[{},"in local db"]},{"entry":["So3D.DLL","SODA interface to the 3D rendering engine"]},{"entry":["TimeSID.DLL","Network time standard interface"]},{"entry":["PlugInMgr.DLL","Plugin manager"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"OTHER PLUGINS:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Encryption algorithm"]},{"entry":[{},"Compression algorithm"]},{"entry":[{},"Authentication algorithm"]},{"entry":[{},"Credential"]},{"entry":[{},"Audio Mix"]},{"entry":[{},"Audio Source"]},{"entry":[{},"Audio Codec"]},{"entry":[{},"Audio Calculation"]},{"entry":[{},"Graphical effect"]},{"entry":[{},"Physics extension"]},{"entry":[{},"Script extension"]},{"entry":[{},"Input device hosting"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"B. Realtime Kernel Design","As shown in , the realtime kernel  is designed as a collection of services, plugins and a realtime scheduler, which constitute a platform for rendering virtual area communication environments in accordance with instructions received from the area service . Services work together to implement the platform, operating at different levels\u2014from network features through audio and graphics rendering configuration. Plugins are of various classes, each adhering to a Plugin Management API, each with its own class API. The realtime scheduler  ensures that audio and graphic rendering occur at an even frame rate. The platform is configured in accordance with an instance of a virtual area by area service  through SODA definition records transmitted over a STRAW UDP socket (see section VI, which contains SODA definitions for an exemplary set of SODA records.). The STRAW service  de-multiplexes SODA record streams using a publish\/subscribe model. SODA records are transmitted only when a subscriber exists on the other end of a STRAW socket. Received SODA records are delivered to one or more subscribers on arrival. Services support local APIs for use by the So3D graphics engine and the HUD .","The following sub-sections describe the installation, design, and operation of embodiments of the realtime kernel  and its components.","1. Installation","a. Overview","In some embodiments, the virtual area based rendering platform is downloaded as a software package over the internet as an installation package. It is delivered by HTTP download from a download server. On client network nodes operating a Microsoft\u00ae Windows\u00ae operating system, the platform software package is a .msi package. The initial installation is a single package that is amended on the download server as updates become available. When a new client network node performs a current installation, no other updates are needed until such time as subsequent updates are created.","The realtime kernel  makes use of plugins to customize applications. Necessary plugins are included in the installation package. From time to time components may be updated independently (e.g., realtime kernel services may be point-released and plugins may be added). In this case a separate Windows\u00ae .msi installation package may be created for the point release and registered with an update server. The installed platform software will be informed of the update and will offer the communicant the option of upgrading. Some communicants may delay upgrading until more than one update is available. When the communicant finally agrees to upgrade, all available updates will be loaded and applied sequentially.","Multiple versions of a plugin may be present on a client network node at the same time. This is because the client network node typically negotiates features, and chooses the plugin that suits the API and version requirements. Each plugin advertises its API and variants. The plugins will have different file names to avoid name collision in the file system. Two plugins with the same API and different variants are different implementations, and the choice is made by the service requesting the plugin (perhaps by negotiation with a server for instance). When a plugin is loaded with the same API and variant as an existing plugin, this is a bug-fix. The new plugin replaces the old one. Services are always replaced by an upgrade. There are never two services with the same API. The Windows\u00ae installation uses a manifest and bundled Windows\u00ae dependent DLLs, to guarantee a functioning product regardless of the update state of the Windows\u00ae environment. The Windows\u00ae side-by-side feature is used to avoid conflicting with other product installation requirements.","b. Update Server","The update server contains installation packages for each supported host operating environment, and upgrade packages for each previous supported installation package.","The client network node and the update server communicate over a reliable STRAW channel. The update server publishes available upgrade definitions for each supported host operating environment. The virtual area based rendering platform software that is installed on the client network node subsequently may subscribe to an upgrade. The update server begins sending the desired software piecemeal.","In some embodiments, a client version and upgrade tool is installed on each client network node to allow the user to see the current client software version, list available upgrades and start and monitor the upgrade process. The client network node will keep a table of the GUIDs of the upgrade packages that have been applied. It will present this list to the update server, and in return get a list of pending upgrades by GUID, in order of application. They will have attached description, size and date attribute.","An upgrade is marked \u201capplied\u201d only when the download completes, and the automatic install reports success. The automatic install process includes stopping any running SORK services so the DLLs can be overwritten. Downloading an upgrade is done through a sequence of SODA records, so the process can be interrupted and resumed without repeating any data transfer. The records include the upgrade GUID and an offset.","Since there is no requirement for rolling back or uninstalling, there is no need for any Microsoft\u00ae Windows\u00ae \u201cside-by-side\u201d library manifests. Any required libraries can be loaded as part of the upgrade.","The upgrade tool will make a registry entry or keep a file, containing the GUIDs of applied upgrades as well as the GUID of any current loading upgrade, its offset and a reference to the file on disk containing the data \u201cso far\u201d. Upgrade packages are deleted once applied. If it is desirable to cache an upgrade package for multiple client network nodes, then point them each at the same client proxy which will do the caching.","c. Update Local Database","The client network node stores the virtual area based rendering platform services and plugins in an asset directory in local file system. The services and plugins are self-describing, through APIs and attached resources. No further information is kept on the client network node software state. When a client network node reinstalls the virtual area based rendering platform software, perhaps after an OS upgrade, existing plugins typically are revalidated. The fresh installation includes all basic services and plugins, but there may be present on the machine optional or application-specific plugins, which typically are deleted or re-validated. In some embodiments, the binary content of valid plugins is hashed and one-way encrypted and the resulting value is stored as an attached resource that is used to check whether or not the plugins are authentic. To validate a suspected plugin, the current plugin content is rehashed and encrypted, and the resulting value is compared with the existing resource. If the content does not match the resource, then the plugin is invalid.","d. Client Authentication","Network authentication typically is made once each time the realtime kernel  is launched. In some embodiments, an account server running the account network infrastructure service is used to authenticate the communicant and establish a real user identifier (RUID) for the communicant. The account server creates a token (subsequently included as part of the RUID) and gives it to the client network node to authenticate itself to other servers. In this process, the client network node is securely issued a credential at installation time. The credential typically is a CA-defined certificate that is signed by a certificate authority. The certificate contains a private and public key. The virtual area based rendering platform installation package creates a new credential containing just the public key. The private key is stored securely on the client network node. The virtual area based rendering platform installation package creates a signature using the private key to encrypt a digest of a communicant-supplied password, and transmits the signature securely to the account server. The account server recovers the digest and stores it as the client identifying secret.","When establishing connections, the realtime kernel  shares the credential with the account server. The account server responds with its credential (e.g., a server-side certificate). The client network node and the account server validate the credentials using a registration authority. Once verified, the server-side credential is valid for any server anywhere.","In some embodiments, the account server also provides a random 128-bit challenge phrase to the client network node. The client network node hashes the challenge phrase with a cryptographic digest of the communicant-provided password and returns this as a response. The account server also hashes the challenge phrase with the previously-obtained digest for that communicant and verifies that the response from the client network node matches. The network connection is now authenticated and the communicant is identified as the owner of the private key.","In some embodiments, the account server assigns to the communicant a random Client ID with attached signatures. The signature is a 128-bit hash of the Client ID encrypted using the account server private key. The signature can only be created by the account server. Anyone receiving the token can validate the communicant by decrypting the digest using the public key published by the account server and comparing it with the Client ID.","e. Account Server Authentication",{"@attributes":{"id":"p-0228","num":"0245"},"figref":["FIG. 16","FIG. 16","FIG. 16","FIG. 16"],"b":["296","294","296","298","300","294","296","296","294","302","296","294","304"]},"2. Initialization Sequence",{"@attributes":{"id":"p-0230","num":"0247"},"figref":["FIG. 17","FIG. 17","FIG. 17","FIG. 17","FIG. 17","FIG. 17"],"b":["260","320","322","324","326","328","84"]},"In some embodiments, the following services of the realtime kernel  are loaded at boot time as Windows\u00ae service DLLs:\n\n","In these embodiments, services are loaded by name, not by GUID. Only one copy of each service is present on a client network node at one time. After loading, the SODA channel service , the media service , the audio stream service , the area\/zone manager, and the realtime scheduler service wait idle. The connection and server mix manager leaves audio un-configured and waits for a definition of a connection to an area server. The default plugins are registered by GUID as API class objects. They are loaded when referenced by GUID in a definition. The HUD  contacts the account server, authenticates and identifies the communicant. The HUD  creates a stream to the rendezvous network infrastructure service and the interaction network infrastructure service and populates its most recently used (MRU) friends and area lists and its frequency friends and area lists. The asset cache service  typically contacts the art database server and begins to cache digital resources according to a heuristic and update its GUID map.","3. Sessions","The realtime kernel  manages sessions between the client network node and other network nodes. During a session, data is shared between a server and the client network node as SODA definition records over STRAW sockets. Data is shared in a publish\/subscribe model. The realtime kernel  subscribes only to the data the client network node needs. To subscribe, the realtime kernel  creates a STRAW channel to the desired server. A STRAW channel is negotiated by well-known GUID for a particular virtual area. In some embodiments, STRAW sockets are connected using an address that is provided through a configured DNS.","The area service will send publish messages indicating the data streams that are available to the communicant, tagging each with a GUID handle. The realtime kernel  then sends subscribe messages for the desired data streams. Any changes to area service data for the subscribed channels are sent as SODA definition records to all client network nodes that have subscribed to those channels.","There are two primary types of sessions: (a) a HUD session, which involves displaying current relationship and presence information in the HUD ; and (b) an area session, which involves either lurking or entering a virtual area instance.","a. HUD Session","In a HUD session, the HUD  contacts the account server, the RUID server, and the rendezvous server, and through STRAW channels subscribes to the communicant's own account and relationship information. The HUD  then subscribes to presence information for closely-related contacts and virtual areas. At this point the HUD  can display dynamic presence information for closely-related contacts.","b. Area Session","In an area session, the HUD  subscribes to information about related virtual areas. In some embodiments, a directory server is consulted to determine the current area server hosting a virtual area specified by the HUD. A STRAW stream is created to the current area server.","The HUD subscribes to the presence data that is associated with the virtual area and updates its 2D head-up display with the names of the other communicants currently participating in the virtual area. At this point the communicant is \u201clurking\u201d in the virtual area. The presence of a communicant can be displayed in a pop-up list, and an icon is displayed in the HUD area representation (e.g., in the Office place tile shown in ).","If the communicant directs the HUD  to enter a virtual area, then the realtime kernel informs the rendezvous service of the communicant's request to enter the virtual area. Other communicants that are subscribed to the presence information that is associated with the virtual area are informed of the new communicant that has entered the virtual area.","The realtime kernel  directs the So3D engine to launch an interactive environment. The So3D engine subscribes to the area server environment data (e.g., rendering and motion data). The area server begins to stream the requested area server environment data to the realtime kernel . The realtime kernel passes the requested data to the So3D engine, which renders the data according to the current visualization mode (e.g., 2D overhead view, low-resolution view, or fully immersive 3D view).","The area server defines raw microphone audio media streams between the client network nodes that are associated with objects in the virtual area. The area server also creates definitions of audio mix elements according to audio handling instructions (e.g., spatial effects definitions and zone definitions) in the virtual area specification. The connection and server mix manager  listens for audio definitions, which include GUID handles for each P2P audio stream, and creates media streams for each definition. Each of the media streams is registered with the local transport bus  and appropriate audio mixing components are created by the audio stream service . The area\/zone manager  also subscribes to SODA definitions for audio and for avatar motion and orientation data. The area\/zone manager  controls gain\/mute of each audio stream as the communicant's avatar navigates the virtual area.","In some embodiments, the area\/zone manager  additionally subscribes to relationship data, which the area\/zone manager  uses to control avatar orientation\/movement\/pose within the virtual area via social processors  (see ). In this process, the area\/zone manager  sets parameter values of the social processors  based on the positions of the avatars in the virtual area and the relationship data. In this way, relationships can be indicated by changing the positions and orientations of an avatar's head when a communicant speaks (e.g., turning the avatar to face another avatar as it enters a zone of the virtual area, or orienting the avatar for optimal viewing of a view screen when a media zone of the virtual area is entered). In some embodiments, the social processors  are defined by third party developers and delivered to the client network nodes via plugins. Each social processor  is a set of instructions that are executed automatically when a specific event occurs (e.g., automatic motion triggered by proximity to other avatars, or position in an area, or both). A social processor  can be any arbitrary programmatic routine that controls the motion of avatars or objects in a virtual area. For example, in some embodiments, if an avatar approaches a view screen, one type of the social processor automatically snaps the avatar to a grid that is defined in the virtual area specification and centers the avatar in front of the view screen so that the user can easily see the contents of the view screen. In this way, the need for complex manipulation of movement of the avatar is eliminated. Another type of social processor  automatically pivots and turns an avatar to acknowledge the presence of another user. For example, an embodiment of this type of social processor is configured to automatically re-orient avatars in a virtual area from facing each other to respective orientations in which the avatars are facing a new communicant's avatar in response to the entry of the new communicant into the virtual area. In this case, the communicants that are associated with the avatars originally in the virtual area do not have to manipulate their avatars manually; instead, the social processor automatically rotates their heads to acknowledge the presence of the new communicant.","4. Managing Sessions",{"@attributes":{"id":"p-0247","num":"0274"},"figref":"FIG. 18","b":"268"},"In accordance with the method of , on a local network node, the STRAW service  establishes a first session with a remote network node on a transport stream in accordance with a connectionless transport protocol (e.g., UDP) (, block ). The STRAW service  creates a definition of the session, where the definition includes an internet protocol (IP) address, a port address, and a globally unique identifier of a transport protocol. The STRAW service  sends the definition to the remote network node. The STRAW service  determines a first station definition that is assigned to the remote network node and stores the first station definition in the table as an attribute of each of the open channels. In this process, the STRAW service  parses a station definition record that is received from the remote network node. The station definition record includes a set of fields, where each of the fields is defined by a respective field type and an associated field value, and each of the field types is identified by a respective globally unique identifier (GUID).","On behalf of one or more software entities on the local network node, the STRAW service  automatically opens one or more channels over which data is transmitted between the local network node and the remote network node in the first session (, block ). In this process, the STRAW service  sends to the remote network node records defining the local publish channels and a record of each of the local subscribe channels having an identifier that matches an identifier of one of the remote publish channels.","In the first session, the STRAW service  maintains a table that identifies open ones of the channels and associates respective attribute values with the identified channels (, block ). The STRAW service  records attributes of local publish channels available from the local network node, local subscribe channels requested by the one or more software entities, remote publish channels available from the remote network node, and remote subscribe channels requested by the remote network node. In this process, the STRAW service  maintains for each of the local publish channels a record that includes an identifier of one of the software entities indicating a capacity to publish data on the local publish channel, an identifier of a remote network node subscribing to the local publish channel, and an identifier of the local publish channel. The STRAW service  maintains for each of the local subscribe channels a record that includes an identifier of one of the software entities subscribing to the local subscribe channel, an identifier of a remote network node indicating a capacity to publish data on the local subscribe channel, an identifier of the local subscribe channel, and one or more network transport parameters associated with the local subscribe channel. The STRAW service  maintains for each of the remote publish channels a record that includes an identifier of a remote network node indicating a capacity to publish data on the remote publish channel, and an identifier of the remote publish channel.","The STRAW service  transmits data between the local network node and the remote network node on the one or more open channels in the session. In some embodiments, the data is transmitted in the form of records each of which includes a set of fields. Each of the fields of a record is defined by a respective field type and an associated field value, and each of the field types is identified by a respective GUID. Some of the records are media records that contain media data, which includes packets of renderable data. Other records are configuration records that contain configuration data, which includes definitions of configuration settings. The media records and the configuration records typically are encapsulated in transport records over the transport stream. The media records typically are compressed using a first data compression service and the configuration records typically are compressed using a second data compression service. On transmission, the STRAW service  associates the transport records with identifiers of respective ones of the channels on which they are transmitted, encrypts the transport records, and sequences the encrypted transport records. On reception, the STRAW service  decrypts the transport records and dispatches the media records and the configuration records contained in the decrypted transport records to subscribing ones of the software entities.","In response to a determination that the first session has failed, the STRAW service  automatically attempts to establish a second session with the remote network node on a second transport stream in accordance with the connectionless transport protocol (, block ). In some embodiments, the STRAW service  determines that the first session has failed in response to a determination that the current station definition assigned to the remote network node is different from the first station definition that was assigned to the remote network node when the first session was established.","In response to successful establishment of the second session, the STRAW service  automatically opens each of the channels identified in the table (, block ).","5. Processing Data Streams","The realtime kernel  supports remote configuration of stream handlers for processing data streams that are received by a client network node from other network nodes. In response to instructions that are received from the area service , various services and other components of the realtime kernel  cooperatively construct and configure directed graphs of processing elements into stream handlers that are used to process data streams. The area service instructions configure the stream handlers in accordance with a virtual area application being hosted by a virtual area that is managed by the area service .",{"@attributes":{"id":"p-0256","num":"0283"},"figref":"FIG. 19","b":["260","26"]},"In accordance with the method of , the realtime kernel  parses a specification of a realtime stream handler from one or more stream handling instructions (, block ). In this process, the STRAW service  receives SODA definitions for configuring a stream handler from the area service . The STRAW service  dispatches the SODA definitions to the connection and server mix manager  and the area\/zone manager . The connection and server mix manager  parses an input source identifier, an output sink identifier, and a respective identifier of each of one or more data processing objects from the one or more stream handing instructions.","The connection and server mix manager  instantiates realtime stream handling objects corresponding to respective ones of the identifiers (, block ). The connection and server mix manager  registers the instantiated objects with the transport bus .","The transport bus  creates a directed graph that includes ones of the instantiated realtime stream handling objects in accordance with the specification (, block ). The area\/zone manager  passes audio calculation SODA definitions to specified audio calculation objects in the directed graph.","The STRAW service  receives a realtime data stream from an input source corresponding to the input source identifier (, block ). The STRAW service  passes the realtime data stream to the media service , which processes the stream and passes it to the transport bus . The transport bus  executes the processing graph elements of the stream handler in sequence to perform the specified processing of the realtime data stream.","The stream handler produces a resultant data stream at an output sink corresponding to the output sink identifier (, block ). The resultant data stream then is passed to rendering components of the client network node.","6. Services and Other Components of the Realtime Kernel","The components of the realtime kernel  include services, plugins, and libraries.","a. Compressor library",{"@attributes":{"id":"p-0265","num":"0292"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"APIs:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Compressor::Ctor( )"]},{"entry":[{},"Compressor::KeyFrame(preload)"]},{"entry":[{},"Compressor::Compress(data, size, target)"]},{"entry":[{},"Compressor::Decompress(data, size, target)"]},{"entry":[{},"Compressor::Dtor( )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Services:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Compressor"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Client of:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PlugInMgr"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The compressor library implements an optional compression layer for transport data. It is not intended to compress protocol headers or link negotiation exchanges.","The compressor library is used by the SODA channel service  and by the media service . When encryption is configured, these services ,  create two compressor instances and pipe channel data through. One compressor instance is used for transmit and the other compressor instance is used for receive.","The compressor library uses a compression\/decompression plugin that is configured by variant. It is up to the service to negotiate the compression variant, and provide it to compressor.","b. Audio Stream Service",{"@attributes":{"id":"p-0270","num":"0297"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"APIs:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AudioService::Ctor(TransBus &)"]},{"entry":[{},"AudioService::Mix(guidId, api, variant, owner,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"AudioComponent*source1, AudioComponent*source2,"},{"entry":"AudioComponent*&)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"AudioService::Effect(guidId, api, variant, owner, AudioComponent*,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"AudioComponent*&)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AudioService::Source(guidId, api, device, AudioComponent*&)"]},{"entry":[{},"AudioService::Calculation(guidScript, AudioComponent*, GUID"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"RUIDSource, GUID RUIDSink, param1, param2)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"AudioService::Dtor( )"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Services:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"AudioService"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Client of:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TransBus.DLL"]},{"entry":[{},"PlugInMgr.DLL"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In some embodiments, the audio stream service  is a Windows\u00ae service DLL.","The audio stream service  manages audio stream mixing. It defines APIs for creating and configuring audio processing graph elements (also referred to as AudioComponent objects), which are manipulated by the area\/zone manager . The audio stream service  is a client of the transport bus . All audio processing graph elements are registered with the transport bus .","Audio processing graph elements are created through the plugin manager  (PlugInMgr) via the following API calls:",{"@attributes":{"id":"p-0274","num":"0301"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"PlugInMgr::APIEnumerate(guiPluginApi)"]},{"entry":[{},{},"PlugInMgr::VariantEnumerate(guidIdentifer, "]},{"entry":[{},{},"guidPluginApi)"]},{"entry":[{},{},"PlugInMgr::CreateInstance(guidIdentifier, "]},{"entry":[{},{},"guidPluginApi, guidVariant)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The plugin APIs used for audio processing graph elements are:\n\n","c. STRAW Service",{"@attributes":{"id":"p-0277","num":"0312"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Services:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STRAW.DLL"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Client of:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Compress.DLL"]},{"entry":[{},"PlugInMgr"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"(i) Overview","In some embodiments, the STRAW service  is a Windows\u00ae service DLL.","The STRAW service  implements a STRAW transport protocol that enables connection-oriented, encrypted secure socket connections between network nodes over a connectionless transport protocol (e.g., UDP). The STRAW transport protocol uses fixed-length globally unique identifiers (GUIDs) to identify all records and all field types in the records. For example, in some embodiments, a network node (or station) is defined by an IP_Address and a Port. In these embodiments, a STRAW station identification record defines a particular network node with the following set of GUIDs: {GUID1, GUID2, GUID3, GUID4, GUID5, GUID6}, where\n\n","Referring to , the STRAW service  manages a session  on a transport stream . In some embodiments, a stream in the context of a STRAW session is defined by a pair of {IP, port} addresses and a transport GUID. A session consists of zero or more logical channels, where a channel is a sequence of records appropriate for a particular kernel manager (e.g., the So3D graphics engine , the connection and server mix manager , and the area\/zone manager ). More than one kernel manager can receive records from the same stream, differentiated by channel.","The STRAW service  manages two kinds of channels: media channels that contain streaming data (e.g., audio); and SODA channels that contain SODA records of definitions (or instructions). STRAW records encapsulate SODA records and media records over a stream, STRAW records are encrypted, sequenced, and include a message integrity field. The sequence is independent of the record source or purpose\u2014it is a link-level feature used to detect out-of-order or missing records.","STRAW records are identified by channel. GUIDs are used as channel identifiers. SODA and media records may be compressed at the channel level, as a stream irrespective of STRAW record encapsulation. Each SODA record contains one or more SODA definitions . Examples of SODA definitions include processing graph elements (e.g., AudioMix and AudioEffect), 3D rendering assets (e.g., texture and mesh), and RDS (e.g., avatar motion checkpoints). Each media record contains one media packet . Examples of media packets include audio codec and text.","Applications publish channels on a session using a well-known GUID Kernel managers subscribe to channels. The publish\/subscribe model is connectionless. A kernel manager that subscribes to a channel registers to receive notification of channel state changes and channel records as they arrive.","(ii) Stream Vs. Session Vs. Channel Vs. Record","In the context of STRAW sessions, a stream is a bi-directional UDP socket between two network nodes defined by two IP address\/port pairs, and a transport GUID. A stream supports sessions of channels. A session is a logical node-to-node connection. Sessions transport channels for the two nodes. Sessions may pass through one or more proxy stations and are transported over streams that may contain multiple sessions.","A channel is a logical construct that transfers SODA or media records between two network nodes in a session. A channel can be reliable or unreliable, compressed or non-compressed. The content of a channel is identified by a content CUD. Channel records are transported in a sequence of STRAW records sharing the same header CHANNEL_CLIENT ID and with sequential packet numbers and a MAC field. The MAC calculation depends upon the packet sequence on the given channel in one direction only. All records transmitted on a single channel share a single set of configuration parameters (e.g., {Client, reliable, compressed}). Records on a single channel are compressed as a serial stream. Only reliable channels normally can be compressed. In some embodiments unreliable channels can be compressed with a compression process in which compression restarts on each key frame. In the case of a lost packet on an unreliable channel, records on that channel are discarded until a key frame is reached (because they cannot be decompressed out of order).","Compression uses Compress.lib. To improve compression a channel definition can include preload data, which is run through the compressor but not transmitted. The purpose is to prime the compression state tables with common phrases. The compression state table is reset and rebuilt each time a key frame is received.",{"@attributes":{"id":"p-0289","num":"0330"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Encrypt STRAW Records individually"]},{"entry":[{},{},"\u2003\u2003STRAW Record"]},{"entry":[{},{},"\u2003\u2003MAC: long"]},{"entry":[{},{},"\u2003\u2003CHANNEL_CLIENT:GUID"]},{"entry":[{},{},"\u2003\u2003PACKET #:short"]},{"entry":[{},{},"\u2003\u2003KEYFRAME: bit"]},{"entry":[{},{},"\u2003Compress Records by Channel"]},{"entry":[{},{},"\u2003\u2003\u2003SODA Record"]},{"entry":[{},{},"\u2003\u2003\u2003. . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"(iii) SODA Records","SODA records are nested structures with an initial GUID ID and one or more SODA definitions. A SODA definition has a definition type, a definition length and one or more fields. The definition type is a well-known GUID (e.g., guidAsset). The length indicates total size of fields. Fields are a combination of type-specific fixed fields and nested SODA definitions. That is,",{"@attributes":{"id":"p-0292","num":"0333"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SODA Record:"]},{"entry":[{},"\u2003\u2003\u2003guid ID"]},{"entry":[{},"\u2003\u2003\u2003SODA definition"]},{"entry":[{},"\u2003\u2003\u2003. . ."]},{"entry":[{},"SODA Definition:"]},{"entry":[{},"\u2003\u2003\u2003Guid DefinitionType"]},{"entry":[{},"\u2003\u2003\u2003long length;"]},{"entry":[{},"\u2003\u2003\u2003[Field] - depend upon definitionType"]},{"entry":[{},"Field:"]},{"entry":[{},"\u2003\u2003\u2003Fixed field"]},{"entry":[{},"Or\u2003\u2003SODA Definition"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0293","num":"0334"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SODA Record"]},{"entry":[{},"GUID: YYYY"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SODA Operation: length 318"]},{"entry":[{},"OPERATION: ART_ASSET"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ATTRIBUTES: length 24"]},{"entry":[{},"CLASS, TEXTURE"]},{"entry":[{},"COLLADA_NAME, Tex7"]},{"entry":[{},"COLLADA_ID, 449"]},{"entry":[{},"DATA: length 256"]},{"entry":[{},"00 02 2B 6C 00 01 ..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"SODA records are encapsulated within a STRAW record:",{"@attributes":{"id":"p-0295","num":"0336"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"STRAW Record"]},{"entry":[{},"MAC: long"]},{"entry":[{},"CHANNEL_CLIENT:GUID"]},{"entry":[{},"PACKET #:short"]},{"entry":[{},"KEYFRAME: bit"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SODA Record"]},{"entry":[{},"..."]},{"entry":[{},"SODA Record"]},{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"(iv) Channel Reliability and Link-Level Protocol","STRAW records are numbered and contain a channel ID. After receiving a packet and after a short time delay the transport sends an ACK record containing the number of the next expected packet for each channel so that the sender can confirm transmitted records were received and can release local resources. There is no reliability feature for this ACK beyond periodic transmission. This scheme uses the minimum network resources for reliability, assuming that almost all records are successfully received.","A MAC field is calculated for each STRAW record transmitted. It is checked on receive.","For Reliable Channels:","If records in a channel are received out-of-order, a NACK is transmitted for the missing record. A MAC failure also results in a NACK being transmitted for the expected record. Up to four NACKs for a single record are permitted, and then the transport queues a failure message to any subscribing kernel managers and erases the channel definition.","For Unreliable Channels:","If records in a channel are received out-of-order, the missed packet number is signaled to any managers subscribed to the channel and no NACK is sent. A MAC failure is also indicated as a missed packet to any kernel managers subscribed to the channel and no NACK is sent. There is no threshold for missed packets, and the channel is never closed by the transport.","There is no need to \u201cclose\u201d a channel. If all kernel managers unsubscribe, then data transmission over the channel stops. Since a channel is a logical entity, no operating system resources are used.","(v) Publish\/Subscribe","The STRAW service  maintains a list of local publish and subscribe entries. Each entry contains\n\n","The list is initialized with\n\n","The STRAW service  also maintains a table of all arrived publish definitions, for use in case a late subscribe is registered in the local list.\n\n","When the STRAW service  receives a session definition for a desired connection to another station, the STRAW service  establishes the stream, sends the session definition, and then sends all of the local table publish entries in a SODA record on the session channel. When a publish definition arrives at a STRAW service , the STRAW service  enters that definition into the publish definition table and then sends a subscribe definition on the session channel for each subscribe entry in the local list that had a matching Channel ID in the publish record. When a subscribe definition arrives, the STRAW service  begins sending definition updates (piped from the publishing Applications) on the given channel as STRAW records containing the SODA record for that definition. The records may be sent on more than one channel.","When a kernel manager desires to participate in a channel with a server, the kernel manager defines a subscribe request, whether or not any STRAW Streams exist to any servers. If a virtual area application publishes later (i.e., after stream is established) then the change in the local table triggers re-sending of the publish entries in the table, which automatically triggers any latent subscribe on the other end of the link. If a kernel manager subscribes later and there is an entry in the publish table, then the STRAW service  sends the subscribe request automatically. This process ensures that channel data is sent over a link only if it is desired by the receiver.","(vi) Channel Record Dispatching","STRAW records are decrypted as they arrive. If valid, their embedded records are uncompressed and then dispatched to all subscribing kernel managers. The list of local subscribe entries is examined, and all entries matching the Channel ID (in the subscribe transport info) receive a copy of the record on their message queue.","The subscribing kernel manager is responsible for freeing messages as they are processed. The bulk data portion of a message is not copied, but points to the original network buffer containing the STRAW Record. Each kernel manager frees messages such that when they are all freed the network buffer can be recycled.","(vii) Establishing a STRAW Stream","The client network node connects sessions over streams with servers and peer network nodes. In this process, each party authenticates itself to the other.","STRAW streams are authentic and secure. This means that:\n\n","Part of a session definition is a list of stream transport plugin GUIDs. If the client network node responding to the definition supports at least one of the GUIDs, it loads the plugin and uses it to establish the session. The server creating the definition may examine the support list of each client network node involved and decide which transport plugin GUID to include in the definition.","Part of a session definition is a list of stream encryption plugin GUIDs. If the client network node responding to the definition supports at least one of the GUIDs, it loads the plugin and uses it to encrypt the Session. The server creating the definition may examine the support list of each client network node involved and decide which stream encryption pluginGUID to include in the definition.","(viii) Server Stream","In some embodiments, a stream from a client network node  to a server  is established using an address that is obtained from a server, such as a directory server, a map server, or an area server. Exemplary purposes of the stream include obtaining presence information, rendering a public space using rendering definitions from a map server, and rendering a virtual area using rendering definitions from an area server.",{"@attributes":{"id":"p-0320","num":"0372"},"figref":["FIG. 21","FIG. 21","FIG. 21","FIG. 21","FIG. 21"],"b":["344","346","344","346","348","346","350","344","352","346","344","346","354"]},"(ix) Client Stream","Referring to , each session is identified by a new GUID that is generated by the issuing server. Network nodes involved in the stream are informed of the session definition, and each network node communicates with the other using a hash of the session GUID and Client ID as the stream encryption key. In the exemplary embodiment shown in , an area server  defines a session between two client network nodes , . Each of the client network nodes ,  is authenticated to the area server, and uses an encrypted channel to communicate definitions (including session definitions). There is no need for the client network nodes ,  to share any further authentication information with each other. Each of the client network nodes ,  is identified by the server  with a respective GUID. Each session definition identifies both client network nodes ,  by their GUIDs. The client network nodes ,  can use this information to decide which channels to publish on the session.","If the stream or session fails for one of the client network nodes , , that client network node informs the area server  of the failure using a SessionFailure SODA definition. Reasons for failure include, for example, no compatible transport, no available channel, and reliable channel failure. In some embodiments, the area server  responds to the SessionFailure SODA definition by attempting to re-route the stream (e.g., by reflecting an audio stream through a proxy or server).","In some embodiments, the client network nodes ,  communicate P2P in accordance with the Simple Traversal of UDP through Network Address Translators (NATs) (abbreviated STUN) network protocol. In these embodiments, the clients ,  operate through respective NATs. A server (e.g., the area server ) acts as a STUN server, which listens at two IP addresses in the network on the public side of the NATs and reports the mapped IP addresses and ports on the outside of the NATs. From this information, the client network nodes ,  are able to discover the presence and specific type of NAT, and obtain the mapped (external) IP address (NAT address) and port number that the NAT has allocated for the clients' UDP connections to remote hosts. The client network nodes ,  then use the external IP addresses to communicate with one another P2P in accordance with the UDP protocol. Additional details regarding the STUN protocol can be obtained from Jonathan Rosenberg at al., \u201cSTUN\u2014Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs),\u201d Internet proposed standard RFC 3489 (March 2003).","(x) Keep-Alive","In some embodiments, once a stream is established, the transport on the client network node issues periodic idle StreamKeepAlive definitions. The partner network node returns a StreamKeepAlive definition with the timeout set to whatever it estimates is the maximum interval it can tolerate. The purpose of this message is to keep any NAT firewall pinhole active. The partner network node records the desired timeout and lengthens the interval each time. If the next message comes from a different IP and port, then the NAT timed out and a new pinhole was created by the keepalive. The interval should then be shortened.","If either the client network node or the partner network node notices a StreamKeepAlive is missing either because the idle timer expired and no message was received, or no answer was received to a keepalive message, then it issues an immediate StreamKeepAlive with a very small timeout. This is to distinguish between a dropped station and a dropped UDP packet. Several retries can be attempted. If no answer is received after the retries then a local Stream Failure event is generated with the failed Session ID(s), and the stream definition is deleted.","In some embodiments, the STRAW service  responds to a broken link by automatically reestablishing the link and re-linking all subscriptions and data flows based on the local publish and subscribe table entries without application (or client) intervention.","f. Media Channel Service",{"@attributes":{"id":"p-0330","num":"0382"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"APIs:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"MediaChannel::Ctor(STRAW&, AudioSource&, IDChannel,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IDCodec, TransportParams)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MediaChannel::Send( )"]},{"entry":[{},"MediaChannel::Receive(data&)"]},{"entry":[{},"MediaChannel::Dtor( )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Services:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Media.DLL\u2003streaming audio channel"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Client of:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Compress.lib compression"]},{"entry":[{},"PlugInMgr"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In some embodiments, the media channel service  is a Windows\u00ae service DLL.","The media channel service  is used to robustly communicate P2P audio and text chat. The media channel service  will compress the stream if configured to do so. The compressor library accomplishes compression as requested. The media channel service uses an audio codec plugin configured by variant. The variant GUID is taken from the stream definition.","g. SODA Channel Service",{"@attributes":{"id":"p-0334","num":"0386"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"APIs:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SODAChannel::Ctor(STRAW&, IDChannel, TransportParams)"]},{"entry":[{},"SODAChannel::Send(SODA&)"]},{"entry":[{},"SODAChannel::Receive(SODA&)"]},{"entry":[{},"SODAChannel::Dtor( )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Services:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SODA.DLL\u2003SODA channel"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Client of:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Compress.lib compression"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In some embodiments, the SODA channel service  is a Windows\u00ae service DLL.","The SODA channel service  is used to robustly communicate SODA definitions. The SODA channel service  will compress the stream if configured to do so. The compressor library accomplishes compression as requested. This is the place where data structures are converted to network byte order. In some embodiments, little-endian (Intel) network byte order is used.","h. Connection and Server Mix Manager",{"@attributes":{"id":"p-0338","num":"0390"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SODA definitions:"]},{"entry":[{},"AudioStream"]},{"entry":[{},"AudioCalculation"]},{"entry":[{},"AudioEffect"]},{"entry":[{},"AudioMix"]},{"entry":[{},"AudioDevice"]},{"entry":[{},"AudioParameter"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AreaSession"]},{"entry":[{},"CommunicantState"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Services:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CSMMgr.DLL"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Client of:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"STRAW.DLL get instructions from AS, create new"]},{"entry":[{},"connections to clients"]},{"entry":[{},"Media.DLL"]},{"entry":[{},"SODA.DLL"]},{"entry":[{},"TransBus.DLL\u2003audio stream connections"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In some embodiments, the connection and server mix manager  is a Windows\u00ae service DLL.","In some embodiments, the connection and server mix manager  exports a procedural API available for the local conference scheduling tool to initiate a session with an area server. This API is the initial entry point for creating a session. The connection and server mix manager  publishes an active session definition. The area server receives the session definition on a SODA channel.","The connection and server mix manager  also constructs audio graphs from audio graph processing elements. The audio graph processing elements are configured by the area service , either directly through SODA records or indirectly through VSDL scripts. In any case SODA definitions are the result. In some embodiments, the connection and server mix manager  processes the following SODA definitions sent by area service :\n\n","These SODA definitions are described in the following paragraphs.","AudioDevice is a definition of a local audio device to be registered with the audio transport bus (which is a component of the transport bus ) as an AudioSource. The well-known ID of a standard local audio source (microphone, headset) or a registered local audio recording (file, streaming CD audio) is provided, along with an instance ID (which headset if more than one is available). The device is given a new ID for use on the audio transport bus. The connection and server mix manager  creates an instance of the appropriate variant of the AudioDevice plug-in using the well-known audio source ID, and hands it off to the audio transport bus.","AudioStream is a definition of an incoming audio stream to be registered with the audio transport bus as an AudioSource. An incoming audio stream is defined by the Channel ID it is transported over. For purposes of dynamic mixing (done by the area\/zone manager ) it is necessary to associate a stream with an Avatar ID. The device uses the Channel ID as its audio transport bus ID. The connection and server mix manager  creates an instance of the appropriate variant of the AudioStream plug-in based on the Channel Type ID, and hands it off to the audio transport bus.","AudioMix is a definition of a combination AudioSource and AudioSink plug-in. The definition fully specifies the plug-in API ID, variant ID, one or two Audio Transport Bus source IDs, and an associated Avatar ID (for the area\/zone manager ). The connection and server mix manager  creates the indicated variant of the AudioMix plug-in based on the IDs provided, and hands it off to the Audio Transport Bus.","AudioEffect is a definition of a combination AudioSource and AudioSink plug-in. The definition fully specifies the plug-in API ID, variant ID, one audio transport bus Source IDs, and an associated Avatar ID (for the area\/zone manager ). The connection and server mix manager  creates the indicated variant of the AudioEffect plug-in based on the IDs provided, and hands it off to the audio transport bus.","AudioCalculation is a definition of an AudioCalculation plug-in. The definition fully specifies the plug-in API ID, variant ID, associated audio transport bus AudioSource object ID, the component's own audio transport bus ID, and two situation-specific parameters. The AudioCalculation objects are not processing audio data directly in audio chains. Instead the AudioCalculation objects calculate settings for other audio graph components based on a \u201cdomain object model\u201d, external information such as manual settings (mute, volume control in the HUD), avatar position and motion, reverb spaces and Windows\u00ae settings (speaker selection in the Control Panel for instance). AudioCalculation objects are executed on a different rendering timer event\u2014much less often than normal audio rendering. This is because the data they use as inputs to calculations change slowly. The connection and server mix manager  creates the indicated variant of the AudioCalculation plug-in based on the Ds provided, and hands it off to the audio transport bus.","AudioRecord is a definition of an AudioSink plug-in. The definition links a point in the audio graph with a storage component. At rendering time, an AudioRecord component doesn't trigger rendering itself. But if rendering is triggered by another AudioSink component, then the rendered audio data is provided to the AudioRecord object for transfer to the indicated storage component. The connection and server mix manager  creates the AudioSink plug-in and hands it off to the audio transport bus.","AudioPlayback is a definition of an AudioSource plug-in. The definition links a point in the audio graph with a storage component. If an audio chain references this component, then at frame-preparation time one time-slice worth of audio data is fetched from the storage component and provided as output of this component. The connection and server mix manager  creates the AudioSource plug-in and hands it off to the audio transport bus.","The connection and server mix manager  configures the transport bus  and the audio stream service  according to definitions received from the area server. Each definition results in the creation of an audio processing graph element, which is an audio stream plugin, an audio calculation plugin, or an audio source plugin. The local audio devices (e.g., microphone, speaker(s), and Skype audio) can be configured according to settings chosen through a HID configuration tool. The HID configuration tool allows the user to choose keyboard and mouse options for navigating the 3D collaborative space. For example, shortcut keys may be defined, and mouse gestures bound to avatar behaviors. In some embodiments, the audio output selection follows the Windows\u00ae Control Panel \u201cSounds and Audio Device\u201d settings for Audio and Voice. This ensures that the same audio settings are used for virtual area communications as are used for ordinary VOIP conversations.","In the event of an area server session transport failure, the connection and server mix manager  attempts recovery. It tears down the session and re-launches it on a different area server. In the event of a media stream failure, the connection and server mix manager  attempts recovery. In this process, the connection and server mix manager  tries to reconnect to the client network node. If the reconnection attempt fails, the connection and server mix manager  defines the communicant state as inaudible to the area server.","i. Area\/Zone Manager",{"@attributes":{"id":"p-0353","num":"0412"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SODA definitions:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PhysicsCheckpoint"]},{"entry":[{},"AudioCalculation"]},{"entry":[{},"Zone"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Services:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"AreaZone.DLL"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Client of:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"STRAW.DLL"]},{"entry":[{},"OpenAL.DLL"]},{"entry":[{},"GIPS.DLL"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In some embodiments, the area\/zone manager  is a Windows\u00ae service DLL.","The area\/zone manager  adjusts the audio stream service  mix parameters according to zone definitions and avatar position definitions. The area service  publishes to the area\/zone manager  SODA definitions that relate each avatar to the audio processing graph element that responds to that avatar's motion. The avatar position data is used to mix the audio streams from each of the client network nodes participating in a virtual area in a way that allows each communicant to hear the other communicants at the right audio location with the right volume according to local zone definitions. The parameter values that are applied to the audio processing graph elements typically depend upon a calculation that includes relative position, orientation of communicants, zone definitions, audio properties of the virtual area, and manual settings (e.g., mute, volume) that are configured by the communicant.","In some embodiments, the area\/zone manager  processes the following SODA definitions, which pertain to gross features of the simulated audio space in which the current audio graph is rendering.\n\n","These SODA definitions are described in the following paragraphs.","AudioReverb is a definition of a reverb space which is a \u201chollow space\u201d that results in a certain reverb or echo effect. The definition identifies a simple geometry with a location. This definition is provided in a domain object model (DOM) to all AudioCalculation objects when they are invoked.","AudioAperture is a definition of a connection between two reverb spaces. It identifies two reverb spaces by ID, and specifies an audio connection between them. The connection is a circle at a certain location and orientation. This definition is provided in a domain object model (DOM) to all AudioCalculation objects when they are invoked.","AudioObstruction is a definition of a physical barrier to sound propagation. It is modeled as a sphere at a location. This definition is provided in a domain object model (DOM) to all AudioCalculation objects when they are invoked.","The SODA definitions described above are inputs for AudioCalculation objects, which are scriptable calculation plugins that take the following parameters as an argument:\n\n","Initial Audio Calculation plugins include:\n\n","Some calculations are appropriate for individual audio sources; some for whole-room final mix. The virtual area application can introduce new plugins at will by referring to them in audio definitions. The area\/zone manager  will subscribe to plugins that it doesn't have, and receive their definition from the area server.",{"@attributes":{"id":"p-0364","num":"0438"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Calculation Plugin","Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Manual Mute","This simply returns 0.0 or 1.0 depending upon the"]},{"entry":[{},"mute setting for that source (Avatar)."]},{"entry":["Manual Volume","Returns between 0.0 and 1.0 depending upon the"]},{"entry":[{},"volume setting for that source (Avatar)."]},{"entry":["Location","Takes a mono signal, and returns 5.1. Gains are"]},{"entry":[{},"calculated from the relative angle of the source from"]},{"entry":[{},"the sink, including the sink orientation. This may"]},{"entry":[{},"even include ear separation?"]},{"entry":["Doppler","Shifts frequency depending upon relative velocity of"]},{"entry":[{},"source vs. sink."]},{"entry":["Orientation","Attenuates source depending upon source orientation"]},{"entry":[{},"e.g. facing toward or away."]},{"entry":["Zone","Sets Zone Mute for a sound source (1.0 if in same"]},{"entry":[{},"Zone else 0.0). Perhaps it could have a graduated"]},{"entry":[{},"setting for elegant zone boundary fade-out."]},{"entry":["Room","Applies room audio characteristics to a source"]},{"entry":[{},"relative to a sink including reverb zones, apertures"]},{"entry":[{},"and obstructions. Functions on 5.1 signal, produces"]},{"entry":[{},"multi-variant setting for a Reverb widget"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0365","num":"0439"},"figref":"FIG. 23","b":"380"},"The arrows , , , ,  represent AudioSources, which are all dry mono audio sources. Avatars 1, 2 and 3 are network streams from remote client network nodes. Whisper is an optional local audio feed from a designated source. Everything to the left of the audio Panners is mono with a series of effects added. These effects include adjusting volume according to Zone and speaker Orientation and applying a Doppler shift to account for relative velocity of speaker and listener. The audio Panners position each adjusted mono signal in the three hundred sixty degree audio space of the currently occupied zone of a virtual area. The Location of the speaker relative to the listener is used. Everything to the right of an audio Panner is 5.1 audio. The Room audio processing graph element calculates the effect of the room acoustics on the audio signal. It takes into account position of speaker and listener, room characteristics, and obstructions. The Final Mix audio processing graph element adds all of the processed audio signals together to produce a resultant stream that is piped to the designated audio output device (i.e., SPKR, which represents the local speaker(s) in the illustrated example).","Some audio processing graph elements (inserts) have fixed parameters and, therefore, are not associated with any runtime calculation plugin scripts. These elements include echo and noise cancellation, automatic gain control (AGC), silence detection, fixed-source Panner, and Final Mix.","j. Asset Cache Service",{"@attributes":{"id":"p-0369","num":"0443"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SODA definitions"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"See Art resource API document"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Services:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ArtCache.DLL"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Client of:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"File system or cfb"]},{"entry":[{},"So3D"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In some embodiments, the asset cache service  is a Windows\u00ae service DLL.","Assets are recorded in a local database or table service indexed by GUID. The asset data is kept in an amorphous storage pool. The ID on a particular asset never changes, thereby avoiding any cache consistency issues. Assets are cached by SODA record. This means that large assets may be stored in many pieces, since SODA records are limited in size to the UDP MTU (around 1000 bytes). The asset cache must index records by GUID and the data offset, which is a field in the SODA record.","(i) Asset Index","Assets are represented in a class table, and an optional attribute table.","The asset class table maps the asset GUID to a class GUID and a data store reference.",{"@attributes":{"id":"p-0375","num":"0449"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Asset ID","Asset Class","Data store"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["guidSurface","guidClassTexture","<image1>"]},{"entry":["guidConfTableSurface","guidClassTexture","<image2>"]},{"entry":["guidSococoConfTableSurface","guidClassTexture","<image3>"]},{"entry":["guidDogShowMesh","guidClassMesh","<image4>"]},{"entry":["guidNameSococoConfName","guidClassText","\u201cConference\u201d"]},{"entry":["guidAuthorDVW","guidClassText","\u201cDavid Van Wie\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"(ii) Data Store","The asset storage interface of the virtual area based rendering platform allows heaping data, storing a separate index transactionally, and scavenging unused asset storage for reuse. A combination of a database and file will serve for asset storage. The database contains two tables: a storage allocation table, and a GUID\/offset index. The file is created with a fixed size according to the cache size configured. Assets are stored in the file using a heap-bucket algorithm.","The asset cache data store will be indexed by GUID and offset. The heap is partitioned into buckets by data size, in powers of two. The smallest bucket is 32 bytes; the largest is 2 kilobytes, which makes a total of 7 buckets. Each bucket is budgeted the same amount of storage, which means there are half as many items in each successive bucket. Each bucket is a heap table large enough to hash enough items to fulfill the storage budget, which makes the chance of hash collision reasonably small.","(iii) SODA Asset Definition Records","Assets are encapsulated in SODA records for transmission. The definition includes the asset GUID, its content (unstructured data) and it's offset if it is larger than one record, and a table of attributes. A SODA record encapsulating an asset never contains any reference to the storage system.",{"@attributes":{"id":"p-0381","num":"0455"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Asset: length 1400"]},{"entry":[{},"ID: guidSococoConfTableSurface"]},{"entry":[{},"TOTAL_SIZE: 4096"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ATTRIBUTES"]},{"entry":[{},"CLASS, TEXTURE"]},{"entry":[{},"APPLICATION, guidAppSococoConf"]},{"entry":[{},"AUTHOR, guidAuthorDVW"]},{"entry":[{},"NAME, guidNameSococoConfName"]},{"entry":[{},"COLLADA_NAME, Tex7"]},{"entry":[{},"COLLADA_ID, 449"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0382","num":"0456"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"OFFSET: 0"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DATA"]},{"entry":[{},"00 02 2B 6C 00 01 ..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"A query for an asset is a definition",{"@attributes":{"id":"p-0384","num":"0458"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Asset query: length 60"]},{"entry":[{},"ID"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Array: length 28 ( 1 entry )"]},{"entry":[{},"Offset: 0"]},{"entry":[{},"Length: 10000"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"An asset is forgotten using a definition",{"@attributes":{"id":"p-0386","num":"0460"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Asset dereference: length 36"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Array: length 20 ( 1 entry )"]},{"entry":[{},"ID"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"(iv) Attribute Hierarchy","Assets have attributes, the most important of which are Type and Default. Type specifies the purpose of the asset. Default specifies a base asset that can be used in place of the given asset. An exemplary attribute hierarchy is shown in the following table:",{"@attributes":{"id":"p-0389","num":"0463"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","Type","Default","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Blank","Texture","NULL","<image5>"]},{"entry":[{},"WoodGrain7","Texture","Blank","<image6>"]},{"entry":[{},"TableTop1","Texture","WoodGrain7","<image7>"]},{"entry":[{},"ConfTableWood","Texture","TableTop1","<image8>"]},{"entry":[{},"SococoTable","Texture","ConfTableWood","<image9>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The Artbase will have a huge hierarchical tree of assets based on default assets, all finally based on a small number of fundamental assets. These fundamental assets are installed as part of the client software package. This feature is intended to allow designing a level with specific art assets called out, and to allow rendering it before all of the art assets are actually designed. Also it may be desirable to start rendering a virtual area before all of the art assets are loaded.","Optional attributes include Default. Author, Application and Collada ID which is a reference to the Collada source from which the asset is derived. Browsing tools running on an author station will index assets by any and all Attributes.","k. Audio Transport Bus","The audio transport bus is a component of the transport bus  that handles audio streams. In some embodiments, the audio transport bus is implemented by a library that manages an audio graph as a collection of component objects. All of the audio graph objects are registered with the audio transport bus by a unique ID. The audio transport bus is responsible for managing the audio graph objects when rendering audio. The audio transport bus traces the audio graph components by ID. In this process, the audio transport bus invokes each audio graph component in turn, providing the audio data from the input component named by ID.","The audio transport bus buffers one time-interval of each audio stream available on the client network node. The audio transport bus feeds these streams to zero or more subscribers as configured by the audio stream service . Streaming data uses a pull model, where the final output stage calls preceding stages for data as needed. Each stage calls the one before until the original audio stream source is reached. If the source needs to control rate (flow control) it typically does its own buffering and has its own particular signaling scheme. For instance a local file source can double-buffer and read ahead one time-interval while processing the preceding one. A network file source can signal flow rates and buffer limits over the network to the server. A local microphone source, on the other hand, has no ability to control flow rate at all.","The audio transport bus operates in two phases: upon a rendering timer event, it provides existing rendered data to AudioSink components; the audio transport bus then traverses the audio graph, causing the next time-slice worth of audio data to be rendered and buffered. This technique gives the audio graph a good chance of providing continuous playback, even in the presence of variable-latency audio source data.","In some embodiments, the audio transport bus measures the rendering latency of each audio graph component, and aggregates each rendering chain latency by adding up all dependent (source) audio component latencies. The audio transport bus collects and registers the rendering latency statistics. Based on these statistics, the realtime scheduler  determines when and how the audio graph should be modified in order to achieve an audio graph processing target. In some embodiments, the realtime scheduler  executes one or more of the methods described above in connection with  in the process of determining when and how the audio graph should be modified in order to achieve an audio graph processing target.","Another function of the audio transport bus is to invoke AudioCalculation objects periodically. The AudioCalculation objects are used to change settings of associated ones of the audio graph processing elements. The period of AudioCalculation execution typically is much longer (less often) than the audio graph rendering period.","The audio transport bus typically has the ability to record streams and replay recorded streams. The raw audio streams typically are recorded so that during playback the mix can be re-rendered according to the viewer's point of view. Some embodiments include a hub that receives all of the raw audio streams. In these embodiments, the hub typically handles the recording of sessions. When it is not desirable to re-render a session, the audio transport bus typically only records audio streams at the client network node.","The AudioSource object is the base for all audio sources. This object delivers data when polled, and defines its desired latency and channels (e.g., mono, stereo, 5.1). Derived objects include Microphone, MediaStream, Clip, WaveFile, DirectX audio, and the output side of the Mix plugins.","The AudioSink object is the base object for audio output devices. This object requests data from an AudioSource when polled. Derived objects include Speaker, MediaStream and the input side of the Mix plugins.","(i) Audio Plugin API","In some embodiments, the audio plugins incorporate VST audio effect C++ objects that are available from Steinberg Media Technologies GmbH. In particular, the audio plugins incorporate VST objects wrapped as plugins. A shim library is provided for wrapping a VST object as an audio plugin. This wrapper supplies the audio plugin API. The API of the VST objects will be used as the audio plugin class-specific API. This API includes:\n\n","In these embodiments, a VST plugin is wrapped as an AudioSource and AudioSink. For instance, the AudioSource::Frame(data&, size) call will be implemented as a call to the preceding AudioSource::Frame(data&, size&), followed by setupProcessing(process) and process(data&). The Configuration(latency, channelLayout&) call is implemented in terms of getLatencySamples( ) and getBusArrangements(output, i, channelLayout&) for each supported channel. The existence of a wrapper means that VST source code is required to shim an existing VST plugin into the audio bus.","(ii) OpenAL","Most audio processing graph mixing and effect elements are executed using the OpenAL cross-platform audio API available from www.openal.org. The OpenAL library is capable of calculating all parameters listed above in the area\/zone manager section using the best features of the available soundcard to implement the features. In particular, OpenAL Sources, Listeners, and program Buffers are created for each operation in the audio graph from mute through final mix. Before each update, the buffer parameters are modified according to the calculation plugins.","In some embodiments the GIPS componentized audio library available from Global IP Solutions, Inc. is used for implementing stream-processing components (inserts). The GIPS audio library directly supports the following audio plugins: Codecs, Error Concealment, Jitter control, Echo and Noise cancellation, AGC, and Silence detection.",{"@attributes":{"id":"p-0407","num":"0489"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Interfaces:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TransBus::Ctor(bufferHint)"]},{"entry":[{},"TransBus::Register(AudioSource&, AudioSink&, GUID)"]},{"entry":[{},"TransBus::Reference(GUID, AudioSource&)"]},{"entry":[{},"TransBus::Link(GUID, indexSrc, GUID, indexSink)"]},{"entry":[{},"TransBus::Record(GUID)"]},{"entry":[{},"TransBus::Playback(stream, GUID)"]},{"entry":[{},"TransBus::EnumerateRecordings( )"]},{"entry":[{},"TransBus::EnumeratePlayback( )"]},{"entry":[{},"TransBus::QueryLink(GUID, indexSrc)"]},{"entry":[{},"TransBus::Dtor( )"]},{"entry":[{},"AudioSource::Ctor( )"]},{"entry":[{},"AudioSource::Frame(data&, size)"]},{"entry":[{},"AudioSource::Configuration(latency&, channelLayout&)"]},{"entry":[{},"AudioSource::Configure(parameter, value)"]},{"entry":[{},"AudioSource::Dtor( )"]},{"entry":[{},"AudioSink::Ctor( )"]},{"entry":[{},"AudioSink::Link(AudioSource &)"]},{"entry":[{},"AudioSink::Frame( )"]},{"entry":[{},"AudioComponent::Ctor(guidId, latency&, channelLayout&)"]},{"entry":[{},"AudioComponent::Frame(data&, size)"]},{"entry":[{},"AudioComponent::Link(AudioSource &)"]},{"entry":[{},"AudioComponent::Dtor( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0408","num":"0490"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Plugins:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AUDVol.DLL","Volume control"]},{"entry":[{},"AUDMix.DLL","Aggregate streams"]},{"entry":[{},"AUDMute.DLL","Mute"]},{"entry":[{},"AUDPan.DLL","Panner"]},{"entry":[{},"AUDFreq.DLL","Frequency shifter"]},{"entry":[{},"AUDJitr.DLL","Jitter reducer"]},{"entry":[{},"AUDRevrb.DLL","Reverb"]},{"entry":[{},"AUDLPF.DLL","Low-pass filter"]},{"entry":[{},"AUDHPF.DLL","High-pass filter"]},{"entry":[{},"AUDError.DLL","Error concealment (lost media packet)"]},{"entry":[{},"AUDIPCM.DLL","iPCM-wb codec"]},{"entry":[{},"AUDILBC.DLL","iLBC codec"]},{"entry":[{},"AUDEcho.DLL","Echo cancellation"]},{"entry":[{},"AUDNoise.DLL","Noise cancellation"]},{"entry":[{},"AUDSilnc.DLL","Silence detection"]},{"entry":[{},"AUDAGC.DLL","Automatic Gain Control"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"I. Local Stream Sources","Local Stream sources are the microphone, local sound sources such as recorded way files and music, and sound art resources. A Windows\u00ae operating system API is used to attach each of these sources and present them to the audio transport bus for distribution. Each source is \u201cwrapped\u201d as an AudioSource derived class. Source object wrappers are created when a definition is received (see the AudioDevice SODA definition in section VI). DirectSound APIs are used on Windows\u00ae based computing systems for microphone, clip, Skype, and CD sound. RTP streaming is simply an AudioSource wrapper around the Real-Time Protocol (RTP) service, which is used to deliver streaming data (e.g., audio) over a UDP socket. Streaming audio over the internet supports web-based download-and-play and also Microsoft Media Server streams.",{"@attributes":{"id":"p-0411","num":"0493"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Plugins:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AUDMic.DLL","Microphone"]},{"entry":[{},"AUDClip.DLL","Audio clip file"]},{"entry":[{},"AUDRtp.DLL","Streaming audio over network"]},{"entry":[{},"AUDSkype.DLL","Skype session live capture"]},{"entry":[{},"AUDCD.DLL","Local music playback"]},{"entry":[{},"AUDWeb.DLL","Web service audio"]},{"entry":[{},"AUDComft.DLL","Comfort noise generator"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In some embodiments, the realtime kernel  supports sourcing and mixing of sessions of virtual area based communications with non-virtual area based communications (e.g., Skype and VOIP audio). In these embodiments, the realtime kernel intercepts non-virtual area based communications and presents them as local audio sources. The non-virtual area based communication session is initiated by one of the communicants on a client network node that is responsible for sharing the non-virtual area based communication session raw audio with other client network nodes. The hosting client network node also mixes audio associated with a virtual area communication environment for the communicant who is communicating via the non-virtual area based communication application.",{"@attributes":{"id":"p-0413","num":"0495"},"figref":["FIG. 24","FIG. 24","FIG. 24"],"b":["389","260","391","391","393"],"ul":{"@attributes":{"id":"ul0035","list-style":"none"},"li":{"@attributes":{"id":"ul0035-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":["Stream Handler : composed of the following audio graph processing elements:\n        \n        ","C: Audio Capture by a virtual area based communication application","P: Audio Playback by a virtual area based communication application","C: Audio Capture by the alternate audio application of System 1","P: Audio Playback by the alternate audio application of System 2","V Mic: virtual microphone associated with System 2 alternate audio","V Spkr: virtual speaker(s) associated with System 2 alternate audio"]}}}},"In operation of the computer system , the I\/O Multiplexer\/Demultiplexer sends the audio signals 1 and 2 received from Systems 1 and 2 to both System 3 and System 4. The I\/O Multiplexer\/Demultiplexer also sends the audio signals 3 and 4 received from Systems 3 and 4 to the P Route component of the stream handler . The P Route component sends the audio signals 1, 3, and 4 to the playback component of System 2 and passes the audio signals 3 and 4 to the P mix component of System 2. The P Mix component of the stream handler  mixes the audio signals 2, 3, 4 and passes the mixed signal to the integration component of System 2. The integration component  passes the mixed signal to the audio capture component of an alternative communications application (e.g., Skype) that is running on System 2 and that corresponds to the communications application  (e.g., Skype) that is used by System 1. The alternative audio capture system (C) passes the captured mixed signal 2+3+4 to the playback component of the alternative communications application  running on System 1.","In some embodiments of the communication infrastructure , P Mix subscribes to I\/O Multiplexer\/Demultiplexer directly so that the system is more symmetric. In these embodiments, P Route becomes P Mix 1, and receives 3, 4 from I\/O and 1 from C Split 1. Since these are sent as independent channels, the output of C Split 1 could be sent directly to the Playback Component, but that isn't quite as flexible (since P Mix could perform an actual mix instead of a pass through of independent channels, see 3 below). In this case. P Mix becomes P Mix 2 and receives 3, 4 from I\/O and 2 from C Split 2 The output of this mixer is a true mix, since the Alternate Audio System is a single channel communication system (even if the channel is stereo, we there is no multi-track mixer at the other end to combine signals from multiple sources).",{"@attributes":{"id":"p-0416","num":"0510"},"figref":"FIG. 24"},"In , any time two streams are delimited with a comma (meaning that it is a multichannel route), the system could also be sending mixed streams to conserve internal communication resources (e.g., out of the I\/O Multiplexer\/Demultiplexer). The stream to be mixed is indicated with plus signs (i.e. the virtualized microphone signal sent by the integration component  to the alternate capture component C).","m. Realtime Scheduler",{"@attributes":{"id":"p-0419","num":"0513"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Services:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SORK.DLL"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Client of:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TimeSID.DLL"]},{"entry":[{},"TransBus.DLL"]},{"entry":[{},"So3D"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In some embodiments, the realtime scheduler service  is a Windows\u00ae service DLL.","In some embodiments, rendering of audio and the 3D scene is done on a frame-by-frame basis. Initially, the streams are started, then after a delay the realtime scheduler service  begins processing the first frame. The delay is calibrated by the combined desired latency of each audio and video processing chain. The realtime scheduler service  initiates consumption of the previously prepared frame and then processes the next frame, on a time Tick that has a period of 50 milliseconds.","The final rendering objects in each chain are registered with the realtime scheduler service . The objects are derived from a SoFrameRenderer class, which has a method\n\n","A Windows\u00ae operating system has no \u201chard scheduling\u201d ability. In some embodiments, the realtime scheduler service  is configured to call one or more SoFrameRenderer classes, which include audio processors, graphical processors, physical modeling and scripts. The SoFrameRenderer classes enable the realtime scheduler service  to readjust frame processing in response to a determination that the client network node cannot keep up with the target processing level. In some embodiments, the realtime scheduler  implements one or more of the methods described above in connection with . In some of these embodiments, the realtime scheduler service  measures the rendering time for all frames, and make statistics available through a SODA interface. If the statistics fall out of range (e.g., it takes too long to prepare a frame) then a log event is generated. A heuristic will be triggered, to try to \u201ccatch up\u201d, perhaps by skipping a frame, dropping out-of-range rendering chains (which typically are out-of-range due to a hardware or network error), or by dropping lower-priority rendering chain(s). For the purpose of implementing priority-based scheduling, the SoFrameRenderer class defines the method:\n\n","In some embodiments, the realtime scheduler service  additionally is able to drop stages within a chain. For this purpose, the realtime scheduler service  is able to call the method:\n\n","The realtime scheduler service  also is responsible for managing the interface to a SIS time service (a network resource), so as to synchronize the client network node clock with the clocks of the other client network nodes in the network. In some embodiments the time services are implemented by plugins, as described below.","7. Failure Recovery","The realtime kernel  makes a best-effort attempt to continue operating in the presence of network and server failures. In this process, the realtime kernel  implements a two-tier failure recovery algorithm. First the SODA channel service  and the Media service  independently attempt to reestablish connections upon failure. The media recovery will allow a conference to continue in the presence of individual audio channel failure, or to recover in the case of NAT timeout. Second, if the SODA channel service  and the media service  fail to reestablish connections, they will signal failure to their clients. In some embodiments, the actions of multiple communicants simultaneously attempting recovery are coordinated by registering the client node sessions with an area vault server that can synchronize the recovery attempts.","In some embodiments, the area\/zone manager  also attempts a recovery in the event of a server failure. The area\/zone manager  fields the stream failure and then tears down the session and re-launched it on a different area server.","8. Plugins","In some embodiments, the realtime kernel  has a componentized, open, and platform-independent architecture that allows developers to independently and develop and remotely add and update components of the realtime kernel .","a. Plugin Design","Plugins are platform-specific binary images that are downloaded from a plugin server. On Windows\u00ae based computer systems, plugins are implemented as DLLs (e.g., .NET or COM style plugins). Plugins differ from normal dynamic linked libraries, however, by the way in which they are loaded. In particular, during loading there is no need to link to the plugin library; nor is there any need for any compilation of software code. Instead, the plugin manager  simply loads the plugins that are contained in the plugin directory. In this way, plugins can be added or removed from a client network node without any further configuration of the station (e.g. registry entries), simply by downloading or deleting the executable. The plugins connect to each plugin host in a well defined way.","As shown in , an active instance of a plugin  is derived from a respective plugin variant class , which in turn is derived from a respective plugin base class . In some embodiments, a plugin instance  is instantiated by creating a base plugin object and casting the base plugin object to an identified variant through inheritance. Each base class  and variant class  signifies that it provides a service by declaring that it implements an interface.",{"@attributes":{"id":"p-0434","num":"0532"},"figref":"FIG. 26","b":["398","400","402","404","406","408","398","400"]},"Plugins are identified by GUID as well as human-readable name. A single plugin can have multiple APIs supported as well as multiple variants on the same API. In some embodiments, a plugin API is a C language data structure containing function pointers to the plugin functions implementing the services defined by the interface.","The following table shows an example of a fictitious Physics plugin that is identified as guidPhysicsSet1.",{"@attributes":{"id":"p-0437","num":"0535"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Internal",{},{},{}]},{"entry":["File Name","Name","Identifier","API","Variant"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Physics.DLL","Frictionless","guidPhysicsSet1","guidJoint","guidJointBall"]},{"entry":[{},"physics set"]},{"entry":[{},"1.0"]},{"entry":["Physics.DLL","Frictionless","guidPhysicsSet1","guidJoint","guidJointHinge"]},{"entry":[{},"physics set"]},{"entry":[{},"1.0"]},{"entry":["Physics.DLL","Frictionless","guidPhysicsSet1","guidJoint","guidJointSlider"]},{"entry":[{},"physics set"]},{"entry":[{},"1.0"]},{"entry":["Physics.DLL","Frictionless","guidPhysicsSet1","guidJoint","guidJointSpring"]},{"entry":[{},"physics set"]},{"entry":[{},"1.0"]},{"entry":["Physics.DLL","Frictionless","guidPhysicsSet1","guidCollision","guidCollisionOctTree"]},{"entry":[{},"physics set"]},{"entry":[{},"1.0"]},{"entry":["Physics.DLL","Frictionless","guidPhysicsSet1","guidCollision","guidCollisionDynamic"]},{"entry":[{},"physics set"]},{"entry":[{},"1.0"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["266","270"]},{"@attributes":{"id":"p-0438","num":"0536"},"figref":"FIG. 27","b":["410","410","412","414","416","418","420","410","414","420","410"]},"Each plugin executable supports a core Plugin API that allows the plugin manager  to manage the plugin. The core Plugin API makes the plugin executables self-describing. In particular, each plugin exports a function that can be called by the plugin manager  to allow the plugin to register itself. In some embodiments, each plugin executable exports the following core Plugin API:",{"@attributes":{"id":"p-0440","num":"0538"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PlugIn:GUID( )","returns GUID of this"]},{"entry":[{},"plugin"]},{"entry":["PlugIn:NameGet( )","get human-readable name"]},{"entry":[{},"of API"]},{"entry":["PlugIn:APIEnumerate( )","returns GUIDs of"]},{"entry":[{},"supported APIs"]},{"entry":["PlugIn:VariantEnumerate(guidPluginApi)","return GUIDs of"]},{"entry":[{},"supported Variants for"]},{"entry":[{},"given API"]},{"entry":["PlugIn:DependencyEnumerate(guidPluginApi)","return GUIDs of plugins"]},{"entry":[{},"API depends upon"]},{"entry":["PlugIn:Create (guidPluginApi, guidVariant,","return PlugInVariant"]},{"entry":["PlugInVariant&*)","instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(i) Plugin Variant","An active instance of a plugin variant is derived from the class PlugInVariant. They are always created using a PlugIn object. All useful plugins extend this class to include API-specific methods. The only common methods are generic configuration methods.",{"@attributes":{"id":"p-0443","num":"0541"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PlugInVariant:Configure( )","launch dialog"]},{"entry":[{},"PlugInVariant:ConfigurationSet(parameters)","set configuration"]},{"entry":[{},{},"parameters"]},{"entry":[{},"PlugInVariant:ConfigurationGet(parameters&)","get configuration"]},{"entry":[{},{},"parameters"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"(ii) Plugin Manager",{"@attributes":{"id":"p-0445","num":"0543"},"figref":"FIG. 28","b":["266","422","424","426","428","266","424","422","426","428","428","262","264","428"]},{"@attributes":{"id":"p-0446","num":"0544"},"figref":"FIG. 29","b":"266"},"In accordance with the method of , the plugin manager  discovers the plugins that are available on the client network node (, block ). In some embodiments, all plugins are stored in a shared plugin directory that is created in the file system of the client network node. In these embodiments, the plugin manager  discovers the available plugins by checking the shared plugin directory. In other embodiments, the plugin manager  may be configured to check other file locations for available plugins.","The plugin manager  queries the discovered plugins for all APIs that they support (, block ). In this process, the plugin manager  makes calls to the core API in order to enumerate the parameter values associated with the available plugins. For example, the plugin manager  queries the plugins with core API calls that return the GUIDs of the plugins, the GUIDs of supported APIs, and the GUIDs of supported variants for given API.","Based on the results of the querying, the plugin manager  stores associations between the plugins and the APIs that they respectively support in the plugin database  (, block ). In this process, the plugin manager  classifies all of the plugins in the directory  by the APIs that that support. The plugin manger  automatically enters the plugins into the plugin database  under all supported APIs. In this way, the plugin database  allows plugins with the same API to be queried for a variant. In addition, plugins in the plugin database  can be enumerated by API and variant and instances created when referenced by a virtual area application.  shows an exemplary embodiment of a plugin database .","The Plugin Manager exports the following API:",{"@attributes":{"id":"p-0451","num":"0549"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PlugInMgr:PlugInEnumerate(guidPluginApi)","get list of available"]},{"entry":[{},"plugins by name,"]},{"entry":[{},"identifier"]},{"entry":["PlugInMgr:VariantEnumerate(guidIdentifier,","get list of variants"]},{"entry":"guidPluginApi)"},{"entry":["PlugInMgr:DependencyEnumerate(guidIdentifier,","return GUIDs of"]},{"entry":["guidPluginApi)","plugins this plugin"]},{"entry":[{},"depends upon"]},{"entry":["PlugInMgr:CreateInstance(guidIdentifier,","load plugin and get"]},{"entry":["guidPluginApi, guidVariant, PlugIn&*)","PlugIn instance"]},{"entry":["PlugInMgr:EntryPointEnumerate(guidPlugin)","get list of available"]},{"entry":[{},"entry points"]},{"entry":["PlugInMgr:EntryPointGet(guidPlugin, EntryPoint)","get entry point"]},{"entry":["PlugInMgr:Configure(guidPlugin)","display configuration"]},{"entry":[{},"dialog modally"]},{"entry":["PlugInMgr:ConfigurationSet(guidPlugin)","set SODA record of"]},{"entry":[{},"plugin configuration"]},{"entry":["PlugInMgr:ConfigurationGet(guidPlugin)","get SODA record of"]},{"entry":[{},"plugin configuration"]},{"entry":["PlugInMgr:NameGet(guidPlugin)","get human-readable"]},{"entry":[{},"name"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0452","num":"0550"},"figref":["FIG. 31","FIG. 31","FIG. 31","FIG. 31","FIG. 31","FIG. 31","FIG. 31"],"b":["266","428","440","266","442","444","266","446","448","266","450"]},"(iii) Plugin Server","Plugins are present on a server in appropriate downloadable form for each supported platform. Servers always support a minimum set of encryption, compression and authentication plugins, so client network nodes always succeed when attempting a server connection.","When first registered on a server by a third party developer, the plugin is examined by an automated tool to ensure it conforms to the API specification, and is checked for unacceptable client station API references. For instance, no dynamic binding is allowed to any native interfaces not already in the Plugin environment. Then the plugin is scanned for viruses. All images on the server are then virus-safe.","Plugins are access-controlled by authenticating users. In this way a user who has paid for access can use the plugin from any location. In some embodiments, user is authenticated for plugin download via an electronic commerce engine.","b. Classes of Plugin","All plugins conform to the plugin API. Some plugins are specific to certain tools (e.g., OpenGL) and have their own standard. Each class of plugin has APIs that are class-specific. In some embodiments, plugins depend upon a native application runtime for all client station access. In each component where plugins are used, protocols allow negotiation of the feature using a GUID namespace. For example, in some instances, when connecting a network stream the offering client network node offers its encryption plugin GUID list in order of preference and the receiving network node chooses among those offered and responds with a choice or a refusal.","In some exemplary embodiments, the following classes of plugins are defined and used by developers to develop plugins for use in creating virtual area communicant environments.\n\n","Encryption Algorithm","Encryption is a stream transport feature, and is negotiated at stream creation time. The session definition will include the encryption Variant ID. Exemplary encryption variants include AES and RC4 block encryption.","Compression Algorithm","Compression is an optional Channel content feature. Channels choose compression when the transport negotiates a channel definition. The subscribing station offers available compression options, and the publishing station indicates its selection when the publication is offered. Audio codecs may choose to skip compression, since their content is already compressed. An exemplary audio compression plugin variant implements the ITU-T V.44 compression process with a channel-specific priming stream.","Authentication Algorithm","Network infrastructure servers require certain authentication protocols in order to connect. Third party servers may have specific authentication requirements. Authentication protocols may be amended from time to time. In addition to the core Plugin API, an authentication plugin has APIs for executing authentication protocols and gaining access to local credentials. Exemplary authentication plugin variants include plugin variants that support SSL type of authentication for an initial server and that support subsequent server login using a signed ID as a token.","Credential","Credentials may be created and must be encapsulated in a plugin for storage and use by the authentication algorithm. Exemplary credentials are certificates containing public keys.","Graphical Effect","OpenGL and Collada support scriptable shaders, samplers, profiles and annotations. Some embodiments support Collada cg_surface_type and glsl_surface_type which are shaders, and gl_samplerX and cg_samplerX which are samplers.","Physics Extension","In some embodiments, the Open Dynamics Engine (ODE) is amended to included specific hooks into the dynamic behavior loop. Virtual area applications typically specify physics by applying physical properties to entities in the scene graph. Physics extension plugins have an API for querying associated property GUID(s) that are processed by that plugin. In this way, the physics plugins are only invoked for pertinent objects and virtual areas. Some embodiments support Collada rigid_constraint which is a joint in a model, and OpenGL collision detection which is a global motion algorithm for avatars and artifacts.","Script Extension","Script extension plugins have an additional API to allow wrapping a scripting runtime (e.g., Java and JavaScript) and to provide to it the native application runtime. Scripts are defined through a SODA record that includes the GUID of the script extension plugin.","Input Device Hosting","Input device plugins generate SODA records for standard input events (e.g., events generated by computer keyboard, computer mouse, Xbox\u00ae controller, and Wii\u00ae controller) that are processed by application logic.","Audio Mix, Audio Source, and Audio Insert","Audio processing is desirable at the origin (e.g., microphone) and effects and mixing at the destination (e.g., speaker). Audio plugins typically are not able to change audio network routing, because that affects other user's experience. Audio plugins on the Windows\u00ae platform are DLLs that conform to the Audio Plugin API. They are registered with the realtime kernel  and are available for reference by SODA. Virtual area developers may request audio plugins as part of a virtual area application (e.g., using extended Collada fields or VSDL semantics).","Avatar scripts can request audio plugins as well.","Mix variants include echo, echo cancellation, reverb and compose.","Source variants include microphone, clip, media. Skype and streaming file.","Insert variants include panner, volume, iLBC, RCU, iPCM-wb, equalizer, LPF, HPF, AGC, Noise Cancellation, Error Concealment, Jitter Control, mute, delay, silence detection, comfort noise.","Stream Transport","STRAW uses a stream transport plugin to host sessions on a network. A Stream transports packets and provides reliability, authentication and encryption.","Time Service","The realtime scheduler  is interested in synchronizing time between client network nodes. For this purpose each client network node will synchronize with an internet time standard, such as SIS, NTP (Network Time Protocol), or ITS (Internet Time Service).","c. Plugin Class APIs","All Plugin class objects are based on PlugInVariant.","Encryption Algorithm","This plugin is based on PlugInVariant. It performs a block encryption algorithm including keying. This plugin is stateless except for the key i.e. each encryption is independent of any other.\n\n","Compression Algorithm","This plugin is based on PlugInVariant. It performs one or more lossless compression\/decompression algorithms. It compresses is a continuous stream, and may keep an internal state table. The algorithm is restarted on each KeyFrame, which may include processing a \u201cpriming\u201d block which is not emitted but contributes to the compression state.\n\n","Authentication Algorithm","This plugin is based on PlugInVariant. It accesses local credentials, and implements a client authentication state machine of one or more states. The authentication state machine does NOT control the communication link to the authentication server. It only processes messages and produces subsequent messages.\n\n","Credential\n\n","Graphical Effects\u2014Shader","This plugin is based on PlugInVariant. It affects 3D rendering.","The Shader API supports shaders (scripted procedural surface generators).\n\n","Graphical Effects\u2014Sampler","The Sampler API is based on PlugInVariant. It supports mapping texture to surfaces,\n\n","Physics Extension\u2014Joint","This plugin is based on PlugInVariant. It extends the dynamics of motion.","The Joint API supports joint constraints and dynamics for avatar and artifact subassemblies.\n\n","Physics Extension\u2014Collision","The Collision API is based on PlugInVariant. It supports rapidly calculating collision detection. In some embodiments, a collision plugin variant may implement the quad-tree class dxSpace algorithm in the Open Dynamics Engine (ODE).\n\n","Script Extension","This plugin is based on PlugInVariant. It supports execution of code supplied by the virtual area application. This code is in binary form and labeled by the language and the API the particular code definition supports. The plugin varies by language. It loads a particular code definition and calls it, supplying a native application runtime object appropriate for the API.\n\n","Input Device Hosting","This plugin is based on PlugInVariant. It supports user event capture (other than audio). This includes everything from a mouse to a video camera with facial recognition. The plugin generates user events to the queue.\n\n","Audio Mix","This plugin is based on Audio Component. It combines two audio streams.\n\n","Audio Source","This plugin is based on AudioComponent. It provides pollable audio stream.\n\n","Audio Insert","This plugin is based on AudioComponent. It translates an audio stream. It may compress, decompress or simply modify the stream.\n\n","Audio Send","This plugin is based on AudioComponent. It divides an audio stream into two equal streams (copies the stream). Any AudioSource can be routed to any other audio element.","AudioSend::Ctor(AudioSource&)\n\n","Stream Transport","This plugin is based on PlugInVariant. An exemplary stream transport plugin variant supports an IP UDP transport with configurable authentication and encryption.\n\n","Time Service","This plugin is based on PlugInVariant. It synchronizes a client network node time with an Internet standard.\n\n",{"@attributes":{"id":"p-0522","num":"0702"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Session",{}]},{"entry":[{},"IDStation1","GUID"]},{"entry":[{},"IDStation2","GUID"]},{"entry":[{},"IDSession","GUID"]},{"entry":[{},"SessionFailure"]},{"entry":[{},"IDSession","GUID"]},{"entry":[{},"Reason","long"]},{"entry":[{},"Parameter","long"]},{"entry":[{},"Station"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"STRAW_Address","IP, Port"]},{"entry":[{},"STRAW_Transport","[GUID]"]},{"entry":[{},"Publish"]},{"entry":[{},"IDClient","GUID"]},{"entry":[{},"IDServer","GUID"]},{"entry":[{},"IDChannel","GUID"]},{"entry":[{},"IDCompression","[GUID]"]},{"entry":[{},"Subscribe"]},{"entry":[{},"IDClient","GUID"]},{"entry":[{},"IDServer","GUID"]},{"entry":[{},"IDChannel","GUID"]},{"entry":[{},"IDChannelIndex","GUID"]},{"entry":[{},"Reliable","bit"]},{"entry":[{},"Compressed","bit"]},{"entry":[{},"KeyFrameUser","bit"]},{"entry":[{},"IDCompression","GUID"]},{"entry":[{},"Preload","text"]},{"entry":[{},"StreamKeepAlive"]},{"entry":[{},"IDSession","GUID"]},{"entry":[{},"Timeout","long"]},{"entry":[{},"StreamFailure"]},{"entry":[{},"IDSession","GUID"]},{"entry":[{},"ChannelFailure"]},{"entry":[{},"IDChannelIndex","GUID"]},{"entry":[{},"CommunicantState"]},{"entry":[{},"IDSelf","GUID"]},{"entry":[{},"IDCommunicant","GUID"]},{"entry":[{},"State","short"]},{"entry":[{},"HID"]},{"entry":[{},"IDDeviceClass","GUID"]},{"entry":[{},"IDDevice","GUID"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"AudioParmeter"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"IDParameter","GUID"]},{"entry":[{},"Value","short"]},{"entry":[{},"AudioDevice"]},{"entry":[{},"IDDeviceClass","GUID"]},{"entry":[{},"IDDevice","GUID"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"AreaSession"]},{"entry":[{},"IDArea","GUID"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"PhysicsCheckpoint"]},{"entry":[{},"Location","doubleX3"]},{"entry":[{},"Velocity","doubleX3"]},{"entry":[{},"Acceleration","doubleX3"]},{"entry":[{},"Orientation","doubleX3"]},{"entry":[{},"Center Of Gravity","doubleX4"]},{"entry":[{},"Inertia Tensor","doubleX3"]},{"entry":[{},"Mass","double"]},{"entry":[{},"Zone"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"Shape","Mesh"]},{"entry":[{},"Origin","doubleX3"]},{"entry":[{},"Avatar","[GUID]"]},{"entry":[{},"AudioAperture"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"Radius","double"]},{"entry":[{},"Origin","doubleX3"]},{"entry":[{},"Orientation","doubleX3"]},{"entry":[{},"AudioObstruction"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"Radius","double"]},{"entry":[{},"Origin","doubleX3"]},{"entry":[{},"AudioReverb"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"Shape","Mesh"]},{"entry":[{},"Origin","doubleX3"]},{"entry":[{},"AudioMix"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"Type","GUID"]},{"entry":[{},"Variant","GUID"]},{"entry":[{},"Avatar","GUID"]},{"entry":[{},"Source1","GUID"]},{"entry":[{},"Source2","GUID"]},{"entry":[{},"AudioEffect"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"Type","GUID"]},{"entry":[{},"Variant","GUID"]},{"entry":[{},"Avatar","GUID"]},{"entry":[{},"Source1","GUID"]},{"entry":[{},"AudioStream"]},{"entry":[{},"IDAudio","GUID"]},{"entry":[{},"Avatar","GUID"]},{"entry":[{},"AudioCalculation"]},{"entry":[{},"IDSource","GUID"]},{"entry":[{},"IDSink","GUID"]},{"entry":[{},"IDComponent","GUID"]},{"entry":[{},"IDOperation","GUID"]},{"entry":[{},"Param1","long"]},{"entry":[{},"Param2","long"]},{"entry":[{},"PlugIn"]},{"entry":[{},"Type","GUID"]},{"entry":[{},"Name","Text"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"API Supported","[GUID]"]},{"entry":[{},"UpgradeDependencyList"]},{"entry":[{},"Base Installation","GUID"]},{"entry":[{},"Description","Text"]},{"entry":[{},"Upgrade ID","[GUID]"]},{"entry":[{},"Upgrade"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"Offset","long"]},{"entry":[{},"Data","[ ]"]},{"entry":[{},"AudioRecord"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"IDAudio","GUID"]},{"entry":[{},"IDStore","GUID"]},{"entry":[{},"AudioPlayback"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"IDAudio","GUID"]},{"entry":[{},"IDStore","GUID"]},{"entry":[{},"NetworkDNS"]},{"entry":[{},"Address","String"]},{"entry":[{},"NetworkProxy"]},{"entry":[{},"Address","String"]},{"entry":[{},"DebugInfo"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"Statistic","GUID"]},{"entry":[{},"Reset","Boolean"]},{"entry":[{},"DebugTrap"]},{"entry":[{},"ID","GUID"]},{"entry":[{},"Trap","GUID"]},{"entry":[{},"Rearm","Boolean"]},{"entry":[{},"HID"]},{"entry":[{},"IDKvm","GUID"]},{"entry":[{},"HID","event"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The embodiments that are described herein provide a realtime kernel that supports the realtime communications between communicants operating on respective network nodes. The realtime kernel handles the complex tasks of connecting to communicants, virtual areas, and other network resources, switching those connections in response to user inputs, and mixing realtime data streams. The realtime kernel enables developers to focus on developing high-level communications functionality instead of low-level plumbing code. The realtime kernel imposes relatively low computational resource requirements so that realtime communications performance can be achieved using a wide range of currently available computing devices and network connections.","Other embodiments are within the scope of the claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":"16"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 5B","FIG. 5A"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 5C","FIG. 5A"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 10","FIG. 8"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 11","FIG. 8"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 13","FIG. 8"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 14","FIG. 8"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 15","FIG. 8"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 17","FIG. 8"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 18","FIG. 8"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 19","FIG. 8"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 20","FIG. 8"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 21","b":["344","346"]},"Referring to , each session is identified by a new GUID conjured up by the issuing server, client stream [0260]",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 29","FIG. 28"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 31","FIG. 28"]}]},"DETDESC":[{},{}]}
