---
title: Processor configured to allocate resources using an entitlement vector
abstract: An embodiment or embodiments of an information handling apparatus are adapted to facilitate resource allocation using an entitlement vector comprising multiple fields that are respectively directed to multiple different resources or capabilities. In illustrative embodiments, an information handling apparatus can comprise an entitlement vector configured with a plurality of bit fields at least partly corresponding to a plurality of resources and operable to specify the resources used by at least one object of a plurality of a plurality of objects. The information handling apparatus can further comprise logic operable to allocate the resources to the at least one object based on entitlement as specified by the entitlement vector.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09098608&OS=09098608&RS=09098608
owner: Elwha LLC
number: 09098608
owner_city: Bellevue
owner_country: US
publication_date: 20111028
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application is related to and claims the benefit of the earliest available effective filing date(s) from the following listed application(s) (the \u201cRelated Applications\u201d) (e.g., claims earliest available priority dates for other than provisional patent applications or claims benefits under 35 USC \u00a7119(e) for provisional patent applications, for any and all parent, grandparent, great-grandparent, etc. applications of the Related Application(s)).","For purposes of the United States Patent and Trademark Office (USPTO) extra-statutory requirements (described more fully below), the present application is:\n\n","The United States Patent and Trademark Office (USPTO) has published a notice to the effect that the USPTO's computer programs require that patent applicants reference both a serial number and indicate whether an application is a continuation or continuation in part. Stephen G. Kunin, Benefit of Prior-Filed Application, USPTO Electronic Official Gazette, Mar. 18, 2003. The present applicant entity has provided a specific reference to the application(s) from which priority is being claimed as recited by statute. Applicant entity understands that the statute is unambiguous in its specific reference language and does not require either a serial number or any characterization such as \u201ccontinuation\u201d or \u201ccontinuation-in-part.\u201d Notwithstanding the foregoing, applicant entity understands that the USPTO's computer programs have certain data entry requirements, and hence applicant entity is designating the present application as a continuation in part of its parent applications, but expressly points out that such designations are not to be construed in any way as any type of commentary and\/or admission as to whether or not the present application contains any new matter in addition to the matter of its parent application(s).","All subject matter of the Related Applications and of any and all parent, grandparent, great-grandparent, etc. applications of the Related Applications is incorporated herein by reference to the extent such subject matter is not inconsistent herewith.","Resource allocation in data processing and computing is used for applications to run on a system. A program initiated by a user generates a process. A computer allocates resources for the process to be run. Typical resources include access to a section of computer memory, data in a device interface buffer, one or more files, a suitable amount of processing power, and the like.","A computer with only a single processor can only perform one process at a time, regardless of the number of programs loaded by a user or initiated on start-up. Single-processor computers emulate the running of multiple programs concurrently because the processor multitasks, rapidly alternating between programs in very small time slices. Time allocation is automatic, however higher or lower priority may be given to certain processes with high priority programs typically allocated either more or larger slices of processor execution time.","On multi-processor computers, different processes can be allocated to different processors so that the computer can truly multitask.","An embodiment or embodiments of an information handling apparatus are adapted to facilitate resource allocation using an entitlement vector comprising multiple fields that are respectively directed to multiple different resources or capabilities. In illustrative embodiments, an information handling apparatus can comprise an entitlement vector configured with a plurality of bit fields at least partly corresponding to a plurality of resources and operable to specify the resources used by at least one object of a plurality of a plurality of objects. The information handling apparatus can further comprise logic operable to allocate the resources to the at least one object based on entitlement as specified by the entitlement vector.","In various embodiments, computer systems and associated methods can be configured to include one or more of several improvements that facilitate resource handling.","Various aspects of resource allocation include hardware threading, computational limits, pooled resources, entitlements, and others. Resource allocation can be handled via various architectural aspects of a system including microarchitecture, instruction set architecture (ISA), operating system, and library calls. Software can associate capabilities with particular library functions or software objects. This software can be in the form of compiler, operating system, or others. The operating system can, for example, create a profile for any process running floating point operations and give that entitlement. Resources allocated include processors, central processing units (CPUs), graphics hardware, network controllers, memory, memory management, other hardware, and the like. Resources further include power, cycles, and the like.","Entitlements can be used to allocate resources. Entitlements can be defined as user-specified rights wherein a process is entitled to a predetermined percentage of power or of time. A scheduler or chooser can monitor entitlement values and schedule the next highest priority process. A particular scheme can allocate modulo by bit to avoid starving a process with lower entitlement. In some conditions, the level of entitlement can be overridden or adjusted. Entitlement can be set according to a predetermined algorithm which defines a \u201cfair share\u201d for the processes, for example round-robin, history-based, randomized, and the like, which are efficient since a large history need not be accumulated. Thus, an efficient and inexpensive hardware implementation is possible.","A metric can be specified which enables modification of a goal. A selected level of entitlement to resource consumption can be assigned to each process. One example scheme can be a short, low complexity method which is implemented while storing a limited operation history. For example, when running low on battery charge, a sequence 1-2-3-4-4-3-2-1 can be used to determine whether any of the processes is a resource glutton and can rank the processes on order of gluttony. The most gluttonous can be assigned the lowest priority. Another option can rank processes according to gluttony in combination with another factor of goodness (niceness). Processes can be ranked for the next cycle with the most gluttonous given last priority or can be ranked according to gluttony and one other nice system criterion. Monitoring and\/or control can be performed highly efficiently if hardware, although either monitoring can be performed either in hardware or software in various embodiments. Power management units in CPUs can be used for monitoring, for example to monitor for increases or decreases in voltage or frequency, and for thread execution selection.","Capabilities can be used to perform monitoring and allocation of resources. For example, granting the capability to run video processing software can be combined with simultaneous granting of power capability.","Power is typically global to a process or to an individual CPU. Use of capabilities enables more refined control of power, for example power can be made specific to an object or library routine. With power global to a process, the process will continue to run in absence of a fault, a page fault, a disk access, or the like, and will run until blocked by the operating system scheduler, allowing high power consumption. Use of capabilities enables power to be controlled on a per-hardware thread granularity. Use of capabilities further enables power to be controlled specific to a per-hardware thread granularity for throttling power.","Processors can use instruction prefetch to improve execution speed by reducing wait states. The processor prefetches an instruction by request from main memory before the instruction is needed and, when retrieved from memory, placing the prefetched instruction in a cache. When needed, the instruction is quickly accessed from the cache. Prefetch can be used in combination with a branch prediction algorithm which anticipates results of execution to fetch predicted instructions in advance. Prefetches conventionally operate independently. In some embodiments, a processor disclosed herein can prefetch according to holistic monitoring of operating conditions such as voltage, frequency, and the like to more accurately determine or predict which instructions to prefetch.","The cache can be reconfigured dynamically, for example beginning with a single large, slow cache which can be divided into a relatively small subcache and a larger subcache to enable faster operation. In embodiments disclosed herein, operating characteristics can be monitored to generate information for dynamic reconfiguring of the cache. As a result of the monitored operating conditions, the cache can be selectively configured for slower or faster speed, larger and smaller cache subregions. In some conditions, part of the cache can be temporarily disabled, for example to save power. Monitoring of operating conditions can enable a suitable balance of considerations to determine whether part of the cache is to be disabled, for example determining whether the power saved in disabling part of the cache is appropriate in light of the power lost with a greater cache miss rate.","Disclosed system and method embodiments can use operating condition monitoring and holistic control at the level of calling an object. In an object-level paradigm, various objects or values (such as numbers, symbols, strings, and the like) can be combined to form other objects or values until the final result objects or values are obtained. New values can be formed from existing values by the application of various value-to-value functions, such as addition, concatenation, matrix inversion, and the like. Various objects have different impacts on system operations.","An example of an object which, when called, can have large consumption of power or other resources is video encoding which is a brute force, unintelligent algorithm which runs much more efficiently on dedicated hardware than a general CPU, and has real-time constraints. Video conferencing has similar real-time constraints.","Another object example is video games which perform many different tasks concurrently including processing geometry and processing video simultaneously, possibly processing speech for Skype communications, voice compression, input\/output, and the like. Video games thus typically involve concurrent operation of multiple objects such as the game processing tasks and interface (Application Programming Interface, API) that perform different actions separately. The multiple objects are commonly run as separate threads, unless prohibitive due to the large amount of overhead in running threads that are not essential. Separate threads simplify programming.","In some configurations, applications, and conditions, multiple threads can be run wherein the threads need not be run in the same context.","Hyperthreading is a particular implementation of hardware threading. Software threading is a slightly different implementation of threading wherein the threads are often, but not always, related. In some implementations, a processor can include a GOAL register that can be used to set performance characteristics for particular threads. For example, if different routines (Skype, physics) are run in different threads, selected operating characteristics for the threads can be loaded into the GOAL register to give the threads separate issues. Allocating priority to the different threads can be difficult. In an illustrative system, priority to the threads can be allocated using a NICE utility which specifies acceptable performance for a particular operation and allows reduced priority in appropriate conditions for tasks that can be assigned lower priority with little or no consequence.","In an example implementation, priorities, particular types of priorities, and entitlements can be associated with particular library routines to facilitate management of relatively heuristic phenomena. A library can be constituted wherein entitlements are assigned to individual library routines. The library includes information for adjusting the priority of threads. In some configurations or applications, the library can support hint vectors, such as branch prediction hints to specify whether static prediction should be taken or not taken. In some embodiments, the library can be configured to support NICE-type handling of a hint vector.","A process scheduler can be constituted to support prioritized entitlements and resource allocations upon calling selected libraries. A typical embodiment includes such support in software, although hardware support can also be implemented. For example, a network library can include library routines adapted for heavy network usage so that resources giving access to the network are more important processes to schedule. More entitlements are allocated to network-related resources. Libraries can also be configured to handle secondary priorities that change dynamically. For example, a sound card can have a greater power priority and have a pattern of operation wherein a process uses a network card and possibly other subsystems in combination with the sound card. Thus, the network card and other subsystems can also be allocated a higher priority. Similarly, for a process which performs less modeling and number computation in lieu of higher input\/output operations and sending of information, a higher level of priority can be allocated to input\/output resources.","Entitlements can be used to specify operations of a library. For example, a library with entitlement to run a predetermined number of floating point operations per second can, in response to a condition of executing instructions with few or no floating point computations, use the condition as a hint to power down floating point hardware, thus saving power. Thus, if computations include fixed point operations but no floating point operations, an a priori indicator can be generated designating that the floating point hardware is not needed in the near future and can be powered down. A process can call a library and, if known that a resource is not needed, the resource can be temporarily halted, thereby changing the entitlement level of that process with respect to the resource (for example a floating point unit) to a very low point.","In the illustrative example, the entitlement level of the process with respect to the floating point unit can be changed to very low because the resource is not needed for a foreseeable duration. The process thus indicates to other processes a willingness to relinquish access to the source, for example a willingness to be \u201cnice\u201d about allowing others to use the resource, so that access is deferred in favor of any other process that uses the resource, or the resource is shut down if not currently needed by another process.","Rather than have hardware determine demand for a resource after instructions have been executed, the illustrative system and method can use a call to a library or the result of making a call to the library as an indicator of entitlement niceness. This entitlement can be enforced in the manner of capabilities, for example by requesting access to a memory region, a request which may be denied. The library can give information regarding entitlement, thus giving a priori knowledge.","Resource allocation can also be managed using hints. An illustrative instruction that uses a hint is a hint that not much floating point computation is to be performed, a hint indicative of power demand. For example, hints to maintain power at a low level or to maintain power at a high level. An exception can create problems when using hints, since a hint is not unwound in the event of an exception. For example, for a hint to maintain high power, an exception which changes the condition but does not reset the hint allows hardware to remain in a high power mode, potentially forever. Examples of problems with hint processing in conditions of context switching include problems with unlocking memory locations.","In contrast to entitlements, capabilities enable mechanisms to unwind.","Entitlement Vector.","An entitlement vector may comprise multiple fields that are respectively directed to multiple different resources or capabilities. General examples may include, for example, floating point, power, arithmetic logic unit (ALU), graphics triangle computations, translation lookaside buffers (TLBs), virtual memory usage, and the like. The entitlement vector can thus be used, for example, to power down the TLB as no longer relevant to operation, or to enable usage of a wide range of virtual memory. Software can determine values for each of these fields, for example after monitoring, or the fields can be preconfigured. To maintain in hardware, an entitlement vector may be a suitable size, such as 256 bits. Values can be Boolean. Otherwise, values can be a number from a numerical range to indicate how much from a percentage or relative sense of a given resource is being requested. For example, a big number may be placed in an ALU field if significant usage of the ALU is expected.","Libraries or other objects (and associated threads) can request entitlements. Objects use resources to execute. For example, a networking library has greater usage of a network resource than other libraries or objects. Particular entitlements may be assigned to individual library routines using an entitlement vector, which can indicate expected capabilities to which an object may be entitled. Entitlements may be assigned via the entitlement vector. An entitlement vector may be used when selecting a thread for execution in a multi-threading environment in terms of aspects such as priority.","In some embodiments, an entitlement vector can be used as a hint for an object. Software or a manual determination can ascertain and\/or specify what resources\/capabilities are to be used by an object, such as a library. Code may be included, for example at the beginning of a library, to request particular resources in the form of an entitlement vector. The request may be a request for preferential scheduling, especially with regard to resources. Such code may be a hint, a data structure, a set of one or more bits, or the like in the library.","In some embodiments and\/or applications an entitlement vector can be operable as a repercussion of a calling library. An entitlement vector can serve as a request for resources. The request may be realized as a call to a system call, such as a request to the operating system to allocate additional resources. A hint instruction can be provided to hardware, for example for hardware to use in scheduling. When a library call is made, an entitlement vector may be returned. An entitlement vector can be returned directly or by reference to an address\/register location. Otherwise, an entitlement vector may be installed, for example in association with a register, as a result or side effect of making the library call.","An entitlement vector can be configured to handle field of scale. Human perception is limited. For data representing phenomena that are to be perceived by humans, the data size may be limited so that precision beyond what is human-perceptible may be omitted to conserve resources. Accordingly, a requested data resource can be scaled down or set to a maximum size. For example, finger prints do not require greater than 2 MB, and eyes can discern only \u201cx\u201d amount of resolution. Scale may also be applied to other parameters having a relevant precision that is constrained by the physical world. Thus, a field of the entitlement vector can specify scale. Examples of scale can be human scale, width of the accumulator, or any suitable scale. For example, for a finger print, a suitable scale can be no more than 2 MB.","The entitlement vector field can have a suitable predetermined data path width. Communication and computational data path widths may be large to accommodate data-intensive activities. A data path width entitlement vector field may request a reduction to or only a portion of a maximum available data path width. For example, perhaps only 128 bits of 1024 bits are needed. The other bits of the non-used data path width may be shared with another process or shut down to conserve energy. For example, a portion of a power-hungry super accumulator may be powered down in response to a data path width indication in a field of an entitlement vector. Thus, a field of the entitlement vector can be data path width, a similar concept to scale. A large instruction size, for example 1024 bits, wastes power, but typically only a portion of the bits are used at one time so that a desired subset of the bits can be activated, changing the data path width. The scale concept leads to the concept of a selected partial data path width. The data path width is part of the entitlement. For example, of 1024 bits logic can compute the number of bits actually needed and allocate that predetermined subset of bits, such as 128 bits. The data path field thus can be used to lower the data path width used of the available entitlement vector width, for example activating a super-accumulator data path width.","An entitlement vector can also be used to supply information for scheduling. Individual instruction pointers or threads can be associated with an entitlement vector. For example, four instruction pointers (IPs) can be associated respectively with four entitlement vectors. Logic for a thread chooser can schedule a next thread for execution based at least partly on an entitlement vector. Hence, an entitlement vector may affect priority of scheduling. For example, a glutton with low priority may be moved toward the back of a queue. A miserly resource user with a high priority, on the other hand, can be moved toward the front of the queue.","The entitlement vector can enable usage of selected scheduling functions. Different functions can be used to schedule threads with regard to entitlement vectors. Generally, a function (i) can be based at least partly on: a weight, an entitlement vector, and a usage level. A function can be, but is not necessarily, linear. For example, a sum of a product of a weight times an entitlement vector may be compared to a usage vector when considering priority for scheduling threads.","An entitlement vector and usage vector can be mutually associated. An entitlement vector for an object can be set by software. A usage vector may be determined by hardware by monitoring resource usage during execution. An entitlement vector and a usage vector can be combined into an uber-priority vector that can be used when scheduling threads.","In an example software embodiment, software can monitor the system over history, or can be preprogrammed, and fills in some sets in entitlement vector fields. Software can determine values for the fields and fill in the bits of data, possibly associated as a lookup table, an associated hash table, an extra field to call for a library, and the like. For a library call, an entitlement vector EV is returned. The entitlement vector can be received from various sources, for example from external to calling software. For example, the entitlement vector EV may be installed into hardware as a side effect of the library call.","A factor in determining whether the entitlement vector is handled in software or hardware is the size of the vector.","In an example hardware implementation, a suitable entitlement vector size is 256 bits, although any suitable size is possible. For example, a vector of 64K bits is generally considered too large for hardware implementation.","In some embodiments, an entitlement vector can be associated with each library. The entitlement vector can be used, for example, to eliminate floating point if desired, reduce the number of floating point operations if such operations are rarely used, reduce the scale as appropriate when full accumulator width is unnecessary, increase support for the ALU.","The entitlement vector can be implemented as a call with a memory address made in association with a call to a library which, for example, can return a pointer or address location to the entitlement vector.","Another field of the entitlement vector can be a chooser\/thread selector. The entitlement vector can be used by the chooser\/scheduler, which includes logic that performs operations based on a single entitlement vector or possibly relative entitlement vectors. Each Instruction Pointer (IP) or thread can have an associated entitlement vector. For example instruction pointers, for IP1, IP2, IP3, IP4, then four entitlement vectors can be allocated. Chooser\/scheduler logic considers the entitlement vector when scheduling the next thread for computation. The logic informs the chooser\/scheduler about how to make the selection. The logic can perform selected functions to make the choice and for scheduling, for example by elevating or decreasing priority of a thread.","An example function using an entitlement vector (EV) can compute the sum of weight times EVcompared to the usage vector of Thread, a simple target function for evaluating when to schedule threads from the highest priority to the lowest priority. Thus, for a thread with high priority and large requirement for resources, the thread can be elevated in the scheduling list and resources are likely to be allocated. In contrast, a thread that is a glutton for resources and has low priority is likely to be deferred by the scheduler, moving back or to the end of the list of scheduled threads. A high priority thread that consumes only limited resources is likely to be moved up in the schedule list, possibly to the front of the list.","In some embodiments, the entitlement vector supplied by a HINT instruction can be modified by a capability process. Illustratively, the entitlement vector can set entitlement to use X resources which can be limited by the operating system for example by reduced weighting or setting of maximum allowed resources. The entitlement vector can also be limited according to usage, wherein a thread using an inordinately large amount of resources can be limited when the high usage is detected or predicted.","The entitlement vector function F(w, EV, v) of weight (w), entitlement vector (EV), and resource volume (v) can be either linear or non-linear.","The entitlement vector enables association of scheduling with functions. The entitlement vector further enables association of priority with functions.","One of the challenges in allocating resources is the potential for highly unpredictable changes in resource demand. For example, minor changes in workload can result in substantial variation in performance. Another challenge is unpredictable behavior in response to context switches from one process to another. One technique for dealing with these challenges is making a library call as a technique for determining whether a context switch occurred or, if not expecting to make a library call, perform an action that randomizes priority. If degradation results from making the library call, then performance can be monitored to determine whether performance is reduced. If so, priority of the threads can be randomized. Example techniques for randomization can include a Boltzmann search, simulated annealing, hop-around, other lateral computing techniques, and the like. A Boltzmann search can be performed by a Boltzmann machine, a stochastic recurrent neural network that is capable of learning internal representations and solving combinatoric problems. Simulated annealing is a computer technique used for answering difficult and complex problems based on simulation of how pure crystals form from a heated gaseous state. Instead of minimizing the energy of a block of metal or maximizing strength, the program can minimize or maximize an objective relevant to the problem at hand, specifically randomization to attain stable performance. In a hop-around technique, priority or other parameters can be bounced around to determine a local maximum but not global optimum. Search optimizations can be used to determine whether truly at a maximum value. The new results can be compared with an old optimum.","In some embodiments, a supervisor circuit, for example for thermal and\/or overvoltage protection, can modify the entitlement vector.","Entitlement Vector for Power Control Monitoring.","The entitlement vector, for example in combination with a usage vector, can be used for monitoring power control. In various embodiments, power control monitoring can be performed remotely or locally, possibly by the operating system.","In an example embodiment, a user can supply an entitlement vector using instructions, for example by specification of the beginning and end of a function. The entitlement vector can be used in association with a performance monitoring unit which monitors and determines other entitlement vectors. In various embodiments, the entitlement vectors can be maintained separately or combined into a single effective entitlement vector.","Context Switches.","Context switches can be defined as switches from one process to another. In contrast, a thread can typically be considered limited to a single context. Standard threads and mock threads share resources including context and can have multiple processes, multiple threads within the same privilege level technically. However, a threading library and threading operating system can be created wherein threads are not limited to the same context. Threads can comprise simply a stack and an instruction pointer, and can run in the same address space, for example threads can run as different users in the same address space. In a case of multiple users accessing the same database, if the database is a shared-memory database, software or an interpreter can be responsible for ensuring that unauthorized user(s) cannot access certain data. In the case of users assigned different privilege levels or different threads in the same virtual memory address space assigned different privilege levels, different registers are assigned to particular users and\/or threads, and thus switches between users and\/or threads are context switches.","Privileges can be associated with a page, a page table, an actual physical memory address, a virtual memory address, and the like.","Combining Capabilities and Entitlement.","In some embodiments, the capabilities vector and the entitlement vector can be merged. In some aspects of operation, entitlement can be considered to be a capability. With entitlements specified, the associated performance capabilities and management of associated capabilities prevents unauthorized access to data and\/or resources, and prevents system takeover, unless specifically allowed or enabled by a system call, improving security and enabling denial of service to attacks.","Merged capabilities and entitlement can be used to prevent microarchitectural denial of service. Denial of service is typically considered to arise from a hacker on a network blocking access by using up all or a substantial part of network bandwidth. For example, when operating on a virtual machine in a cloud computing platform (such as Amazon Elastic Compute Cloud (EC2)) a job can be run that thrashes the cache, resulting in an architectural denial of service in response. Preventative remedies can include checking for performance counters and preventing such unauthorized accesses. Microarchitectural remedies can also be used such as implementing microarchitectural covert channels in which, for various types of code, secret keys running on the same virtual machine can be detected. Similarly, microarchitectural covert channels can be used to monitor timing of code to detect intrusion and to detect whether a bit is set in a particular bit position which may indicate intrusion. Microarchitectural techniques can thus include timing channels and covert channels for use whenever a shared resource is to be modulated. Covert channels can be applied, for example, in modulating a disk arm, detecting seeks on a file system.","In various embodiments, operations implementing and using the entitlement vector can be executed by software in a processor, by microcode, in logic, in hardware, or the like.","Hardware Threading.","Several aspects of hardware threading are currently implemented in processors such as CPUs. Simultaneous threading (SMT), hyperthreading, or simultaneous hyperthreading relate to hardware execution of two or four threads selected for running at any time, managed according to many fine-grained scheduling decisions. In a cycle, two threads are selected at instruction fetch, typically at the front of the pipeline and hardware determines which of the two thread's instructions to fetch. An instruction for each of the threads pass to an out-of-order machine within which the instructions are running concurrently. For example, an arithmetic logic unit (ALU) instruction from thread 1 and a memory instruction from thread 2 can run simultaneously.","Another type of hardware threading is interleaved multithreading (IMT) which removes all data dependency stalls from the execution pipeline. One thread is relatively independent from other threads so the probability of one instruction in one pipeline stage needing an output from an older instruction in the pipeline is low. IMT is conceptually similar to pre-emptive multi-tasking used in operating systems.","In contrast to CPU multithreading which handle relatively few threads (typically two or four threads), graphics processing units (GPUs) are stream processors for computer graphics hardware and manage hundreds or thousands of threads, thus using much more sophisticated scheduling. When blocking occurs, for example on a cache miss such as from a memory reference, a very large number of threads are blocked. Threads are chosen for execution on massively parallel thread arrays. In a typical arrangement, a processor has approximately 64,000 threads of which only about a thousand execute at one time. Underlying operations during execution include scheduling, addressing cache misses, and the like. Rather than scheduling from a memory pool, GPUs schedule instructions for execution from a very large pool of threads, waiting for memory to become available to run the next thread.","A CPU can be configured for a CPU thread hierarchy which includes a currently running list and a pool of non-running threads enabled to receive information pertinent to computational limits from devices or components such as special-purpose hardware.","Computational Limits","A limit on computation can be imposed according to setting of priority level which is, in turn, based on available resources. One example resource that can be monitored to set limits on computation is the battery. Limits on computation can be imposed based on battery consumption, battery life remaining. Computational limits can be addressed via a framework of setting capabilities, for example specifying a capability to execute on selected processing resources. In an example implementation, the capability can be set up in metadata.","Addressing computational limits can be fairly complex, involving not only information from monitored resources but also user input. For example, a determination by hardware of low battery level and associated limited battery life can be overridden by a user who may request a software application to run in anticipation of being able to soon recharge the battery at a line power source.","Performance Capabilities","A performance capabilities framework can be defined to address handling of a pool of available resources. A thread pool pattern can be configured wherein a number of threads are created to perform a number of tasks which are typically organized in a queue. Usually, the number of tasks is greater than the number of threads. A thread upon completing an associated task will request the next task from the queue until all tasks have completed. The thread can then terminate or become inactive until new tasks are available. The number of threads can be tuned to improve performance, and can be dynamically updated based on the number of waiting tasks. Increasing the size of the thread pool can result in higher resource usage.","A hardware scheduler can respond to any countable or measurable operating condition or parameter, for example electrons, constraints, frequency, cycles, power, voltage, and the like, to control the thread pool and pool of resources. Two highly useful conditions or parameters for monitoring are power and cycles, which are the basis for other measurable phenomena. Monitoring of operating conditions can be performed in hardware or via software call.","Furthermore, software can associate capabilities with particular objects such as libraries.","In an example embodiment, a software model can be configured to use and enforce performance capabilities. In a relatively simple operation, if power is too low, then the software can limit the maximum number of threads or other capabilities. For example, in a cell processor case the number of threads can be limited to less than 1000. Fundamentally, software can disable functionality if sufficient power is unavailable for scheduled operations.","In another example, a sensor or sensors can detect whether battery bias voltage level is recovering too slowly or, similarly, a thermistor can indicate a battery is too hot which may indicate operating at too aggressive a level. A bit or bits can be set indicating the recovery time is too long. The set bit(s) can be used to throttle the maximum thread hopping rate in the case of a CPU with two threads. The bits disallow a thread hop and set an allowable rate of thread hopping; or perhaps allow thread hopping which creates slowing but saves power.","An example of performance capability monitoring and management can be implemented in a CPU with four process threads each having instruction pointers. One of the four threads is selected to execute for next instruction cycle. Various types of information can be monitored to determine which thread to select including recent demand for power, memory, CPU cycles, and the like. For example, a process can be a resource glutton and allocated fewer resources to enable other processes priority. Information is available relating to recent performance, requested performance, and acceptable performance (niceness).","Another option is to use a \u201cNICE\u201d instruction which can be used to adjust the priority level of predetermined instructions, enabling the instructions to be run in the background at a convenient time. For example, if a processor or battery is running too hot, the NICE instruction can reduce the urgency of executing code. In a particular example implementation, the NICE instruction can change a multiplier and step of a decay algorithm.","High and low capabilities can be specified. For example, a particular software routine can sometimes, although rarely, use floating point operations so the capability for such routines can be set low. Operations performed by software can include monitoring, configuring parameters, and the like.","A predictive hint can also be used to allocate resources. For example, a software routine can use a hint a prediction of a significant amount of floating point usage. A HINT instruction can be included in the routine. In another version, at the beginning of a library function, code can be inserted to enable predictive preferential scheduling. The HINT instruction can be part of the library, for example at the beginning, or associated with the library. Code can be inserted in the library, such as at the beginning of a library function requesting particular resources, for example for preferential scheduling. In one example form, a call to a system call can request the operating system to allocate more resources. In another example form, a hint instruction can be sent to hardware to implement the hint and the hardware responds by using the hint in hardware scheduling, such as push, pop, pull, stack, or the like. The hint instruction typically has no direct effect on program execution. The program will run correctly except for changes in performance and battery life.","Predictive hints can also be implemented other than with a hint instruction. Rather than an instruction, the hint may be part of the data structure. For example, X number of bits can relate to expected capabilities to which a process can be entitled such as a vector or a structure. Software can determine information for a performance descriptor, then fills in the data so that metadata of a descriptor determines importance of the performance descriptor.","Accordingly, predictive hints can be implemented in hardware, software, the instruction set architecture, or a combination of configurations. Hardware is typically more constrained than a software implementation. A software library enables the hint to be passed in a linked list of hash trees for passage into hardware, for example as a 128-bit or 256-bit register. Such an implementation can be implemented in an application programming interface (API) but sufficiently simple to be part of hardware. Thus, the API can be designed, then simplified sufficiently to put into hardware.","Capabilities can be used to implement security. Typically, a system has only a few predetermined capabilities. However, a system can be configured in which every memory addressing register is assigned a capability. If the register specifies a capability to access the associated memory location, the location can be accessed. Otherwise, access is prohibited, for example producing a fault or incrementing counter or accumulator which can be noted in an intrusion vector. For any aspect related to security, if a test is failed, the counter is incremented and placed in the intrusion vector.","An instruction can be specified in an instruction set which sets a capability. In various embodiments, the instruction can be implemented in software, hardware, the operating system, or the like. The instruction can operate in association with a capabilities vector. In some embodiments, the instruction can also or otherwise operate in association with a hint vector.","The capabilities vector can be associated with a pointer, an address, and an object. A highly basic capability is a lower bound and an upper bound. Other more complex capabilities can be implemented. In various implementations, the capabilities vector and the entitlement vector can be separate, or can be combined. Merging the capabilities vector and the entitlement vector enables software structuring.","The capabilities vector can be used to enable fine-grained permission. Fine-grained permission facilitates operations of multiple users or entities in a shared memory data base, enabling the multiple users to access storage such as disk and to perform system calls, but limit access to data only to the user who owns the data or is authorized to access the data. Another benefit of fine-grained permissions is an ability to facilitate and improve security while multiplexing software threads onto hardware threads. In an example configuration, 64000 software threads are multiplexed onto only four hardware threads. Only a small portion of the software threads are running at one time with the remaining software threads idle. The software threads alternately run on the hardware threads, then go back to idle to allow other software threads to run.","A classic security hole in a database management is the inability to limit access to data for the different software threads multiplexed onto the hardware threads. A database typically does not allocate a hardware thread to a user. In typical database operation, a request is received and placed on a software thread so that users are multiplexed onto the software threads, an action giving very little protection. Better protection is attained by allocating each user to a separate process, a technique that is prohibitively expensive because the threads are expensive. Multiplexing the users onto software threads leaves a security hole because access to a particular user's data allowed while running the user's software thread on a hardware thread is not removed when the user's software thread is swapped out from the hardware thread. The access permission remains so access remains enabled. The depicted system solves the security hole by using capabilities.","In a non-capabilities system, any of the software threads can access the entire database at any time, including any data that has been placed in shared memory (unless a call out is made through the operating system to enable any of the threads to create I\/O, a prohibitively expensive operation). Simple databases only have one peer thread so all threads can access any data. Many typical databases have 64 threads that can access any data in shared memory but only four threads that can access I\/O. These systems sometimes have different privilege levels (for example, Intel's rings 0, 1, 2, 3) so specify compatibility. Most code runs in ring 3 and the kernel in ring 0. Rings 1 and 2 are generally not used although several databases have features that can run in ring 1 and ring 2 but are rare and used primarily for benchmarks (a benchmark hack).","In an example implementation that uses capabilities, generally a processor has 16 or 32 registers, some of which are addressing registers. A capability can be loaded to enable access to selected threads. A capability can be loaded to access a particular thread (owned by another user) into hardware thread 0, enabling running as that user. This is one type of context switch\u2014to change the software thread that is executing on hardware thread 0. The capability registers can then be changed, a minor context switch and a change in privilege level. The action does not invalidating translation lookaside buffer (TLBs), but rather moves the permissions out of the TLB. The access control model is also changed. Capabilities can be used in this manner to change operations, guaranteeing only access to data and\/or resources for which access is allowed by a permission-granting entity. Capabilities can guarantee a transitive exposure of only the data and\/or resources of another user according to granted authorization. The technique is deterministic so that, by inspection, which accesses are possible is known.","Translation Lookaside Buffer TLB.","A translation lookaside buffer (TLB) is a processor cache which can be used by memory management hardware to improve virtual address translation speed. Processors use a TLB to map virtual and physical address spaces. TLB are used widely in hardware which uses virtual memory.","The TLB can be implemented as content-addressable memory (CAM), using a CAM search key which is the virtual address to produce a search result which is a physical address. If the TLB holds the requested address\u2014called a TLB hit, the CAM search quickly yields a match and the retrieved physical address can be used to access memory. If the TLB does not hold the requested address\u2014a TLB miss, the translation proceeds by looking up the page table in a process called a page walk. The page walk is computationally expensive process, involving reading contents of multiple memory locations and using the contents to compute the physical address. After the page walk determines the physical address, the virtual address to physical address mapping is entered into the TLB.","A stream monitoring instruction can improve efficiency and performance of the TLB by supporting a software predictor. The instruction can be used to monitor misaligned or split access. A memory access is aligned when the data item accessed is n-bytes long and the data item address is n-byte aligned. Otherwise, the memory access is misaligned. Monitoring for misaligned access can be performed by hardware, resulting in a trap, or somewhat less efficiently by software. In practice, monitoring for misaligned access has a high false positive rate, for example approaching 90%. A predictor can be configured, for example by microarchitecture adjustment, to indicate whether the misaligned access hits are accurate.","A processor can be configured to change voltage, frequency, and\/or power based on the number of cache misses. For example, logic can detect an abundance of cache misses or other performance problems, the voltage can be varied such as increased to cure the problem. The logic can dynamically adjust operating parameters according to the amount of traffic. Frequency and voltage can be adjusted, for example whenever a change in frequency occurs, the voltage can be modified accordingly.","Logic in a memory interface can detect when memory is full to some threshold level, for example 70%. If memory is full to the threshold level and a high level of access is occurring, memory speed can decrease. In response, the frequency and voltage of operation can be dynamically increased to maintain a desired memory speed.","In various embodiments, logic for performing dynamic adjustment can be positioned in memory, in a logic interface, in a processor. A hardware configuration can optimize by active adjustment, redirection, or possibly a combination of adjustment and redirection. For example, a computation-intensive process with many instructions to be executed rapidly can be addressed by running the processor at a higher rate by increasing operating frequency and voltage, and\/or some of the burden can be shifted to components other than the processor to maintain processor execution at a lower frequency.","Infrastructure.","An infrastructure configured to support multiple processors in a system can have a shared memory and message passing between threads, processes, processors, and the like. Operating systems (OS) can include various mechanisms to enable message passing, for example pipelines, daemons that use sockets, loopback, and the like. Any suitable number of processors can be supported in the system, from relatively small systems with few processors to large scale systems with hundreds of thousands or millions of processors. In a typical large scale system, the multitudes of processors communicate via fat trees which support the large amount of bandwidth demanded by the large scale system. The amount of bandwidth in different positions in the tree is variable, depending on traffic. In various other configurations, the many processors can communicate via meshes or buses, via Gigabit Ethernet, via CDMA-CE (Code Division Multiple Access-series CE), and the like. In large interconnects, the number of processors determines what functionality is attainable. For example, for more than about 1000 processors, memory can no longer be shared. At around 100 processors, memory space can be shared but cache-coherence is typically not possible and memory is thus non-cache-coherent shared memory. Cache-coherence is generally considered to cause problems for more than about sixteen processors so that fewer processors at a first level can have cache-coherent shared memory.","For a supercomputer or other system with the large number of processors, for example more than about 1000, for which memory is non-shared, Message Passing Interface (MPI) can be used for communication. MPI uses multiple threads but does not use shared memory. The MPI multiple threads are all part of local shared memory, but no global shared memory exists. The amount of local shared memory is limited, resulting in a communications bottleneck. Supercomputer memories use Message Passing Interface (MPI) which, to a first order, includes a limited number of instructions such as send some location, buffer, end buffer, and receive some entity, buffer, end buffer, and the like. MPI is an application programming interface (API) and is thus a library call. The received entity can be, for example, a channel connecting the sender and the receiver, although channels are rarely used in MPI since channels do not scale beyond about a thousand processors. Accordingly, MPI can use commands with masks which identify which processors are to receive a message. A difficulty with MPI is that different code must be written, and a different core engine and interface, for small-scale and large-scale parallelism. Thus, send-and-receive communication such as is used by MPI is suitable if memory is shared.","What is desired is a technique for expanding send-and-receive communication more broadly. In accordance with system and method embodiments, a communications application programming interface (API) can be created that enables communication between different types of threads and hides that the threads are sharing memory. The communications API can enhance functionality of a Transmission Control Protocol (TCP) socket. The TCP socket, also termed an Internet socket for network socket, is an endpoint of a bidirectional inter-process communication flow across and Internet Protocol (IP)-based computer network such as the Internet. In some embodiments, the communications API can also incorporate functionality of MPI into that of a TCP socket. In a distributed system, a processor can communicate with a Network Interface Controller (NIC) and a send instruction puts data on a queue to send to the NIC and pass through the routing network to a specified destination. The communications API can perform communications via TCP-IP, in some configurations optimizing aspects of TCP-IP such as by ordering packets, and also via other protocols. The communications API can include send-and-receive functionality, and include one or more channels, which is operable with TCP-IP. Some of the channels can be shared memory in the form of a buffer with a counter. Some channels can connect to the NIC, some channels to TCP-IP, and some channels can have other functionality. In some embodiments, the communications API can support different types of channels. One example of a channel type is simply registers. Another type of channel can run two hardware threads with a pipeline coupled between the two threads.","The communications API can be adapted to handle the possibility of overflow. For example, for a channel implemented as shared registers, filling the registers to capacity can cause overflow to memory, which can call a trap or exception.","Another technique for expanding send-and-receive communication more broadly can comprise creating a message passing infrastructure in hardware. Speed is one advantage of forming the message passing infrastructure in hardware. For example in the case of a system call, conventionally a slow operation, hardware can be configured to support a send instruction operable to check a bit in a channel selected for the send operation to determine whether the channel is available and, if not, performing a system call by faulting to the system call. Thus, the hardware can be configured to pass execution through the operating system in response to desired conditions.","In an example embodiment, the message passing infrastructure hardware can be configured to avoid passing execution through the operating system, for example to avoid the context switch inherent with going to the operating system. In another example embodiment, the hardware can be configured to include a message passing paradigm and one core can be run in ring 0 to enable access to operating system calls. The operating system is not a separate process but rather a library call in a library. Another option is to allocate a hardware thread to the operating system.","The operating system performs a ring 0 call via a system call which, in terms of hardware implementation, can be a function call to change a bit, granting permission to change the bit, and identification of the stack from which the OS is operating. In one example implementation, the user can explicitly control the stack, for example by placing the operating system stack in a different register. In another implementation, a system call can change the instruction pointer and the stack.","The message passing infrastructure hardware implementation can, for example, include support for send and receive calls. The hardware implementation can enable faster operating speed. For particular special cases, hardware send and receive calls can be faster than a shared library call. Send and receive are global messages, supporting point-to-point communication in two-party messaging. In some embodiments, the hardware implementation can support put and get APIs to enable sending a message to a designated address asynchronously or synchronously, as selected. The designated address is in a global address space partition, not local load-store. The put and get APIs can handle access to shared physical memory by sending a request to the master or server for the designated memory location. The memory is hashed across all the global memory space. In the illustrative implementation, get and put can be system calls rather than instructions, thus facilitating global access. Because the get and put system calls are relatively resource-expensive, efficiency can be attained by communicating blocks of data, for example 64K, at one time rather than for individual bytes.","For a cache-coherent shared memory that is accessed using the put and get system calls, different schemes can be used depending on what entities are communicating. For entities which share memory, the get and put calls simply access the shared memory. For entities separated by substantial physical or network distances, the get and put calls, if unable to fulfill the call by shared memory access, by running through the same router or similar local actions can send the calls to the network interface to relay remotely, for example across the world. For shared memory, whether cache-coherent or cache-noncoherent, the put and get, and send and receive operations are relatively simple since all entities can access the same memory. More complexity arises when memory is not shared. In various embodiments, when memory is not shared different schemes can be used such as copy-on-write (copying the shared memory), creating in remote memory the shared memory that shares the same capability, an implicit in the put and get, or other options.","The message passing infrastructure thus can include hardware support for the various put and get, send and receive, or the like system calls or instructions. The message passing infrastructure can be configured to enable two threads to be forked and used with the put and get calls to enable optimum speed performance. The send and receive, and put and get instructions, as described, consume two hardware threads or might consume two passive threads.","In some embodiments, the put-get and send-receive can be combined with access bits which designate memory to which the sender is allowed access. Passing along the access bits can enable a reduction in overhead while enabling protection across processes. The overhead of switching or sending a message drops significantly because the receiver already knows the memory to which the sender has access.","An entitlement vector can be used to simultaneously manage and activate entitlement of objects and processes to various resources independently from one another. The entitlement vector can be specific to particular objects, processes, libraries, and the like and can specify entitlement, activation levels, power levels, application timers, and other aspects of operation. The entitlement vectors operate on a resource pool and enable detection and resolution of conflicts when physical resources are insufficient to address all resource requests. Accordingly, the entitlement vectors can be used to allocate resources to a selected priority and schedule later usage of resources to deferred objects and processes. Referring to , B, C, D, and E, four schematic block diagrams and a data structure diagram respectively show embodiments of an information handling apparatus  adapted to facilitate resource allocation using an entitlement vector  comprising multiple fields that are respectively directed to multiple different resources  or capabilities . In an illustrative embodiments, an information handling apparatus  can comprise an entitlement vector  configured with a plurality of bit fields  at least partly corresponding to a plurality of resources . The bit fields  are operable to specify the resources  used by at least one object  of a plurality of a plurality of objects . The information handling apparatus  can further comprise logic  operable to allocate the resources  to the at least one object  based on entitlement  as specified by the entitlement vector .","In some implementations, entitlement  can be set according to a predetermined algorithm which defines a \u201cfair share\u201d for the processes, for example round-robin, history-based, randomized, and the like, which are efficient since a large history need not be accumulated. Thus, an efficient and inexpensive hardware implementation is possible. A particular scheme can allocate modulo by bit to avoid starving a process with lower entitlement .","In various embodiments of the information handling apparatus , the entitlement vector  can comprise a plurality of bit fields  respectively directed to a plurality of different resources  and capabilities , for example as shown in . The entitlement vector  can be operable to specify the resources  and capabilities  used by the at least one object .","Resource allocation can be handled via various architectural aspects of a system including microarchitecture, instruction set architecture (ISA), operating system, and library calls. Software can associate capabilities with particular library functions or software objects. This software can be in the form of compiler, operating system, or others. The operating system can, for example, create a profile for any process running floating point operations and give that entitlement. Resources allocated include processors, central processing units (CPUs), graphics hardware, network controllers, memory, memory management, other hardware, and the like. Resources further include power, cycles, and the like. Thus, in various embodiments of the information handling apparatus , the plurality of resources  can comprise physical\/logical resources  and operational resources .","The physical\/logical resources  of a particular information handling apparatus  can be one or more of physical and\/or logical instances of processors , central processing units (CPUs) , graphics hardware , network controllers , memory , memory management , hardware , microarchitecture , sound cards , video cards , network interfaces , instruction set architecture (ISA) , library calls , library functions , software objects , compilers , operating systems , and the like.","Resources can be allocated in response to any countable or measurable operating condition or parameter, for example electrons, constraints, frequency, cycles, power, voltage, and the like, to control the thread pool and pool of resources. Two highly useful conditions or parameters for monitoring are power and cycles, which are the basis for other measurable phenomena. Monitoring of operating conditions can be performed in hardware or via software call. Thus, in various embodiments and\/or applications of the information handling apparatus , the operational resources  can be one or more entities or phenomena including, for example, power , voltage , current , electrons , frequency , execution cycles , battery consumption , battery life , constraints , temperature , and measurable phenomena , and the like.","Power is typically global to a process or to an individual CPU. Use of capabilities enables more refined control of power, for example power can be made specific to an object or library routine. With power global to a process, the process will continue to run in absence of a fault, a page fault, a disk access, or the like, and will run until blocked by the operating system scheduler, allowing high power consumption. Use of capabilities enables power to be controlled on a per-hardware thread granularity. Use of capabilities further enables power to be controlled specific to a per-hardware thread granularity for throttling power. Accordingly, the information handling apparatus  can be constituted wherein the entitlement vector  is operable to ascertain and specify resources  and capabilities  used by the at least one object .","In various embodiments, the information handling apparatus  can be configured such that the logic  operable to allocate the resources  to the at least one object  is operable to ascertain resources  and\/or capabilities  used by an object  of the plurality of objects  and further operable to set the entitlement vector  according to the ascertained resources  and\/or capabilities .","Communication and computational data path widths can be selected of a suitable size to accommodate data-intensive activities. A data path width entitlement vector field may request a reduction to a maximum available data path width, or selected to use only a portion of a maximum available data path width. For example, perhaps only 128 bits of 1024 bits are used. The other bits of the non-used data path width may be shared with another process or shut down to conserve energy. For example, a portion of a power-hungry super accumulator may be powered down in response to a data path width indication in a field of an entitlement vector . Thus, the information handling apparatus  can be configured wherein the bit fields  of the entitlement vector  can include a data path width bit field DPW operable to request allocation of only a portion of a maximum data path width.","For example, for a total width of 1024 bits, a particular application or operation can be found to function suitably with only 128 bits. Thus, resource conservation is possible by operating upon only a predetermined subset of the bits, reducing the data path width from the total available width, for example as shown with respect to Object 3 in . Hence, in various embodiments and\/or applications of the information handling apparatus , the bit fields  of the entitlement vector  can comprise a data path width bit field DPW operable to request allocation of only a portion of a maximum data path width wherein a plurality of processes  share the entitlement vector .","The concept of operation of data path width in an illustrative entitlement vector  can have to some similarities to that of scale. For example, an instruction that is 1024 bits may be so large that power is wasted. Thus, in conditions such that an identification can be made that only a portion of the bits are required for a particular operation or circumstances, a selected subset of the bits can be activated. When only a portion of the bits are activated, the result of operations does not change, and resources such as power are conserved. Thus a scaling concept can have similarities to the concept of selected partial data path width. The data path width can thus be part of the entitlement. Thus, embodiments of the information handling apparatus  can be configured wherein the bit fields  of the entitlement vector  comprise a data path width bit field DPW operable to request allocation of only a portion of a maximum data path width wherein a portion of the entitlement vector  is deactivated to conserve energy.","Libraries or other objects (and associated threads) can request entitlements. Objects use resources to execute. For example, a networking library has greater usage of a network resource than other libraries or objects. Particular entitlements may be assigned to individual library routines using an entitlement vector, which can indicate expected capabilities to which an object may be entitled. Entitlements may be assigned via the entitlement vector. An entitlement vector may be used when selecting a thread for execution in a multi-threading environment in terms of aspects such as priority. Accordingly, embodiments and\/or applications of the information handling apparatus , for example as shown in , can further comprise monitoring logic  operable to monitor resource usage  and associate a library call  as at least a portion of the bit fields  based on the monitoring.","The entitlement vector  can track and\/or control usage of any suitable resources  and capabilities . General examples can include usage of power, arithmetic logic unit (ALU), virtual memory, translation lookaside buffer (TLB), graphics triangle computations, floating point, and the like. Software and\/or hardware may determine values for each of these fields, for example after monitoring, or the values can be preconfigured. Accordingly, some embodiments of the information handling apparatus  can further comprise monitoring logic  which is operable to monitor resource usage  and determine values for the bit fields  based on the monitoring.","Human perception is limited. For data representing phenomena that are to be perceived by humans, the data size can be limited so that precision beyond what is human-perceptible may be omitted, enabling resource conservation. Accordingly, a requested data resource can be scaled down or a maximum size set. For example, finger prints do not require greater than 2 MB, and human vision can discern only \u201cx\u201d amount of resolution. Scale may also be applied to other parameters having a relevant precision that is constrained by the physical world. Thus some embodiments of the information handling apparatus  can comprise monitoring logic  that is operable to monitor resource usage , scale data according to human-perceptible precision, and set values for the bit fields  based on the monitoring and scaling.","As shown with respect to Object 2 of , the bit fields  can include a scale bit field S, adding the feature or capability of scaling data. Examples of scale can include human scale, width of accumulator, measurement-precision scale, perceivable scale, and the like. For commonly-stored data such as biometric or finger print scale, more than 2 MB is virtually never needed. Therefore, in various embodiments and\/or applications of the information handling apparatus  can comprise monitoring logic  operable to monitor resource usage , scale data according to physical precision, and set values for the bit fields  based on the monitoring and scaling.","Similarly, in some embodiments of the information handling apparatus , the bit fields  of the entitlement vector  can comprise a scale bit field S operable to specify a scale of at least one of the bit fields .","The multiple fields of the entitlement vector  can be set as determined by monitoring of resource usage . Logic in software and\/or hardware can track system operations over history or, in some embodiments, can be preprogrammed, and fill in some sets in the fields accordingly. The resource usage  can be analyzed to select appropriate values for the fields. Consequently, the information handling apparatus  can be configured which further comprises monitoring logic  operable to monitor resource usage , determine values for selected ones of the bit fields  based on the monitoring, and set the selected ones of the bit fields .","In various embodiments, applications, and\/or conditions, the monitoring logic  can determine appropriate values for the monitored phenomenon and set a field of the entitlement vector  in an appropriate form. Suitable forms can include a bit of data, several bits of a size appropriate for information of usage. In some applications, the bit field can be associated as a lookup table, an associated hash table, or an extra field in which a library can be called. The bit field size and format can be determined based on considerations of implementation, for example whether the logic is configured in hardware or software. Accordingly, some embodiments of the information handling apparatus  can further comprise monitoring logic  operable to monitor resource usage , and determine a value of a single bit  of the bit fields  based on the monitoring, as shown for Object 1 of .","Similarly, various embodiments of the information handling apparatus  can comprise monitoring logic  operable to monitor resource usage  and associate a lookup table  as at least a portion of the bit fields  based on the monitoring, as depicted for Object 3 of .","Also, some embodiments and\/or applications of the information handling apparatus  can further comprise monitoring logic  operable to monitor resource usage  and associate a hash table  as at least a portion of the bit fields  based on the monitoring, as depicted for Object N of .","An entitlement vector  that is suitable for storage in hardware  is configured in a suitable size, for example 256 bits in some systems and architectures, although any suitable size can be implemented. Very large width entitlement vectors, for example 64K bits, can be too unwieldy for hardware implementation. In various embodiments, values can be Boolean, a number from a numerical range to indicate how much from a percentage or relative sense of a given resource is being requested, and others. For example, a large number can be placed in an ALU field if significant usage of the ALU is expected. Accordingly, in various embodiments of the information handling apparatus , the bit fields can include data types such as integer, floating point, Boolean, characters, strings, numerical values, numerical values indicative of relative resource allocation, complex numbers, tables, library calls, and any other suitable form.","In some applications, when a library call  is made, entitlement vector  is returned. Hence, various embodiments and\/or applications of the information handling apparatus  can further comprise monitoring logic  operable to monitor resource usage  and determine values for the bit fields  based on the monitoring, wherein a library call  returns the entitlement vector .","The entitlement vector  can be supplied from various sources, either internal or external to the information handling apparatus . For example, the entitlement vector  can be installed into hardware  as side effect of library call . Thus, some embodiments of the information handling apparatus  can further comprise monitoring logic  which is operable to monitor resource usage , determine values for the bit fields  based on the monitoring, and install the entitlement vector  into hardware  as a side effect of a library call .","In some embodiments and\/or applications, the information handling apparatus  can be configured to further comprise a library  wherein the entitlement vector  specifies and\/or allocates resources  and\/or capabilities  used by at least one object  in the library .","The information handling apparatus  can be configured to support prioritized entitlements and resource allocations upon calling selected libraries. A typical embodiment includes such support in software, although hardware support can also be implemented. For example, a network library can include library routines adapted for heavy network usage so that resources giving access to the network are more important processes to schedule. More entitlements are allocated to network-related resources. Libraries can also be configured to handle secondary priorities that change dynamically. For example, a sound card can have a greater power priority and have a pattern of operation wherein a process uses a network card and possibly other subsystems in combination with the sound card. Thus, the network card and other subsystems can also be allocated a higher priority. Similarly, for a process which performs less modeling and number computation in lieu of higher input\/output operations and sending of information, a higher level of priority can be allocated to input\/output resources.","A library is a collection of resources used to develop software, including pre-written code and subroutines, classes, values, or type specifications. Libraries contain code and data to enable services to independent programs, encouraging code sharing, modification, and distribution. Executables can be both standalone programs and libraries, although many libraries are not executable. Executables and libraries make references known as links to each other through the process known as linking, for example by using a linker.","Referring to , a scheduler or chooser can monitor entitlement values and schedule the next highest priority process. A particular scheme can allocate modulo by bit to avoid starving a process with lower entitlement. In some conditions, the level of entitlement can be overridden or adjusted. Entitlement can be set according to a predetermined algorithm which defines a \u201cfair share\u201d for the processes, for example round-robin, history-based, randomized, and the like, which are efficient since a large history need not be accumulated. Thus, an efficient and inexpensive hardware implementation is possible.","A field of the entitlement vector can be a chooser\/thread selector. The entitlement vector can be used by the chooser\/scheduler, which includes logic that performs operations based on a single entitlement vector or possibly relative entitlement vectors. Each Instruction Pointer (IP) or thread can have an associated entitlement vector. For example instruction pointers, for IP1, IP2, IP3, IP4, then four entitlement vectors can be allocated. Chooser\/scheduler logic considers the entitlement vector when scheduling the next thread for computation. The logic informs the chooser\/scheduler about how to make the selection. The logic can perform selected functions to make the choice and for scheduling, for example by elevating or decreasing priority of a thread.","Accordingly, in some embodiments the information handling apparatus  can further comprise a scheduler  operable to schedule a process of a plurality of processes  based on at least one entitlement vector  of a plurality of entitlement vectors .","The scheduler  can operate as a chooser or thread selector. The entitlement vector  can be used by a chooser which has logic that performs operations based on relative entitlement vectors , or even a single entitlement vector .","In a particular implementation, individual instruction pointers or threads can have an associated entitlement vector . For example, in a particular embodiment, each instruction pointer can be allocated a respective entitlement vector  so that instruction pointers IP1, IP2, IP3, and IP4 would use four entitlement vectors .","The scheduler  can include or operate in combination with logic that considers the entitlement vector  when scheduling the next thread for computation. The logic informs the chooser about how to select threads. For example, the entitlement vector  can be used during choosing by elevating or reducing priority of a particular thread. In a particular illustrative simple operation, logic can compute the sum of weight times the entitlement vector EV; which can be compared to a usage vector of Thread. The evaluation enables scheduling of highest or lowest priority for threads. A thread that is high priority and has a large resource usage is likely to be scheduled. However, a thread with low priority and very large resource usage is likely to be deferred for execution. A thread with high priority and only little resource usage is likely to be moved toward the front of an execution queue. The entitlement vector  can thus be used to avoid threads which are gluttons for resources. The evaluation need not be linear and can use a nonlinear evaluation function (F(w, EV, v)). The entitlement vector  thus enables association of scheduling with resource usage and dynamic functions and operation.","Accordingly, in various embodiments, the information handling apparatus  can further comprise a scheduler  operable to schedule a process  of a plurality of processes  based on the entitlement vector  wherein the entitlement vector  specifies that the process  of the plurality of processes  is entitled to a predetermined percentage of operational resources .","Logic, such as in hardware or software, or a manual determination, can ascertain and\/or specify what resources\/capabilities are to be used by an object. In various embodiments, the entitlement vector  can be dynamically determined and modified. Referring to , some embodiments of the information handling apparatus  can further comprise resource allocation logic  operable to dynamically modify the entitlement vector  according to usage of resources  by the at least one object  of a plurality of a plurality of objects .","A performance capabilities framework can be defined to address handling of a pool of available resources. A thread pool pattern can be configured wherein a number of threads are created to perform a number of tasks which are typically organized in a queue. Usually, the number of tasks is greater than the number of threads. A thread upon completing an associated task will request the next task from the queue until all tasks have completed. The thread can then terminate or become inactive until new tasks are available. The number of threads can be tuned to improve performance, and can be dynamically updated based on the number of waiting tasks. Increasing the size of the thread pool can result in higher resource usage.","A limit on computation can be imposed according to setting of priority level which is, in turn, based on available resources. One example resource that can be monitored to set limits on computation is the battery. Limits on computation can be imposed based on battery consumption, battery life remaining. Computational limits can be addressed via a framework of setting capabilities, for example specifying a capability to execute on selected processing resources. In an example implementation, the capability can be set up in metadata.","A sensor or sensors can detect whether battery bias voltage level is recovering too slowly or, similarly, a thermistor can indicate a battery is too hot which may indicate operating at too aggressive a level. A bit or bits can be set indicating the recovery time is too long. The set bit(s) can be used to throttle the maximum thread hopping rate in the case of a CPU with two threads. The bits disallow a thread hop and set an allowable rate of thread hopping; or perhaps allow thread hopping which creates slowing but saves power.","The entitlement vector can be used to enable dynamic runtime updating of an entitlement vector. The entitlement vector can be used to track resource usage by an object or process. Through updating of the entitlement vector and application of the entitlement vector to instruction execution, dynamic updates are applied to instructions. In some embodiments and in some conditions, for example defining an initial state, the entitlement vector can be initially set, for example as supplied by a user or set to a default condition. Similarly, the entitlement vector can be set by specification of the beginning and the end of the function, for example to determine the final condition. The entitlement vector can also be dynamically derived or monitored through performance monitoring, such as monitoring of resource usage and determining the entitlement vector used by active objects and functions, and dynamic control of other entitlement vectors that may not be directed related to the active objects and functions. Accordingly, referring to , B, and C, two schematic block diagrams and a data structure diagram respectively illustrate an embodiment or embodiments of an information handling apparatus  that enables dynamic modification of the entitlement vectors . Accordingly, in an illustrative embodiment, an information handling apparatus  can comprise an entitlement vector  configured with a plurality of bit fields  at least partly corresponding to a plurality of resources . The entitlement vector  can be operable to specify the resources  used by at least one object  of a plurality of a plurality of objects . The information handling apparatus  can further comprise monitoring logic  operable to monitor resource usage  and determine values for the bit fields  based on the monitoring.","The entitlement vector  can also be modified by a capability process. For example, a user or various operations of the information handling apparatus  can allocate usage of resources  in a predetermined manner but operating systems  can limit the allocation, or can weigh the allocation and set resources  to an allowed maximum. Hence, the information handling apparatus  can be configured such that the entitlement vector  comprises a plurality of bit fields  respectively directed to a plurality of different resources  and capabilities . The entitlement vector  can be operable to specify the resources  and capabilities  used by the at least one object .","The entitlement vector  can be configured to conserve resources by recognizing limits to human perception of particular phenomena. Thus, the information handling apparatus  can be constituted such that the monitoring logic  is operable to monitor resource usage , scale data according to human-perceptible precision, and set values for the bit fields  based on the monitoring and scaling.","Similarly, the entitlement vector  can consider physical constraints to information and thus conserve resources. Accordingly, the information handling apparatus  can be formed such that the monitoring logic  is operable to monitor resource usage , scale data according to physical precision, and set values for the bit fields  based on the monitoring and scaling.","Logic can monitor a system over history and fill in various bit fields  of the entitlement vector  by analyzing resource usage  and determining suitable values for the bit fields , for example as a bit of data, associated as a lookup table, associated as a hash table, an extra field which can be used to call for a library, or other suitable techniques. Hence, the information handling apparatus  can be configured wherein the monitoring logic  is operable to monitor resource usage , determine values for selected ones of the bit fields  based on the monitoring, and set the selected ones of the bit fields . For example, as shown for Objects 3 and 4 in , the bit fields  of the entitlement vector  can comprise a data path width bit field DPW operable to request allocation of only a portion of a maximum data path width wherein a plurality of processes  share the entitlement vector .","As shown with respect to Object 2 of , the bit fields  can include a scale bit field S, adding the feature or capability of scaling data. For example, the scale bit field S can be asserted to indicate entitlement of an object to floating point hardware, while a deasserted bit indicates that floating point is not used and power to hardware can be denied.","For some resources , under certain conditions, and for particular phenomena, a single bit is suitable for setting entitlement, for example to specify that entitlement is enabled or disabled. Thus, the information handling apparatus  can be configured wherein the monitoring logic  is operable to monitor resource usage  and determine a value of a single bit  of the bit fields  based on the monitoring.","Additional complexity is enabled by using a field in the form of a table. Consequently, the information handling apparatus  can be formed such that the monitoring logic  is operable to monitor resource usage  and associate a lookup table  as at least a portion of the bit fields  based on the monitoring.","In some embodiments and\/or applications, a hash table can be used to allocate entitlement. For example, the hash table can indicate a level of entitlement per memory block. The hash enables reduction of bits in the table such as by using memory at the hash of an address to compress the address. Accordingly, the information handling apparatus  can be formed wherein the monitoring logic  is operable to monitor resource usage  and associate a hash table  as at least a portion of the bit fields  based on the monitoring.","Libraries can also be configured to handle secondary priorities that change dynamically. For example, a sound card can have a greater power priority and have a pattern of operation wherein a process uses a network card and possibly other subsystems in combination with the sound card. Thus, the network card and other subsystems can also be allocated a higher priority. Similarly, for a process which performs less modeling and number computation in lieu of higher input\/output operations and sending of information, a higher level of priority can be allocated to input\/output resources. Accordingly, as depicted in , an embodiment of the information handling apparatus  can further comprise monitoring logic  operable to monitor resource usage  and associate a library call  of a library  as at least a portion of the bit fields  based on the monitoring.","In some embodiments and\/or conditions, the entitlement vector  can be received via a library call . The library call  is useful, for example, to address a context switch. If some context switches occurs or is likely to occur, that often can lead to strange behavior, the library call  can be used to determine the context switch. The library call  can also be used to randomize priority. If degradation results from making the library call , then if performance starts to decrease, then priority can be temporarily randomized, such as via a Boltzman search, simulated annealing, or hop around. Randomization thus allows determination of a local maximum performance. Thus, an embodiment of the information handling apparatus  can be configured wherein the monitoring logic  is operable to monitor resource usage  and determine values for the bit fields  based on the monitoring. A library call  can return the entitlement vector .","Similarly, the information handling apparatus  can be formed such that the monitoring logic  is operable to monitor resource usage , determine values for the bit fields  based on the monitoring, and installs the entitlement vector  into hardware  as a side effect of a library call .","In various embodiments of the information handling apparatus , the plurality of resources  can comprise physical\/logical resources  and operational resources . The physical\/logical resources  of a particular information handling apparatus  can be one or more of physical and\/or logical instances of processors , central processing units (CPUs) , graphics hardware , network controllers , memory , memory management , hardware , microarchitecture , sound cards , video cards , network interfaces , instruction set architecture (ISA) , library calls , library functions , software objects , compilers , operating systems , and the like. In various embodiments and\/or applications of the information handling apparatus , the operational resources  can be one or more entities or phenomena including, for example, power , voltage , current , electrons , frequency , execution cycles , battery consumption , battery life , constraints , temperature , and measurable phenomena , and the like.","The entitlement vectors enable data and resource parallelism of multiple objects and processes simultaneously accessing a plurality of resources of various types, wherein operations can be performed on different data. Referring to , schematic flow diagrams depict an embodiment or embodiments of a method operable in an information handling apparatus adapted to facilitate resource allocation using an entitlement vector comprising multiple fields that are respectively directed to multiple different resources. Referring to , a method  for handling information can comprise providing  an entitlement vector configured with a plurality of bit fields at least partly corresponding to a plurality of resources, and specifying  the resources used by at least one object of a plurality of a plurality of objects. The method  can further comprise allocating  the resources to the at least one object based on entitlement as specified by the entitlement vector.","In various embodiments, the resources can comprise physical\/logical resources and operational resources. The physical\/logical resources can comprise at least one of a group consisting of physical and\/or logical instances of processors, central processing units (CPUs), graphics hardware, network controllers, memory, memory management, hardware, microarchitecture, sound cards, video cards, network interfaces, instruction set architecture (ISA), library calls, library functions, software objects, compilers, and operating systems. The operational resources can comprise at least one of power, voltage, current, electrons, frequency, execution cycles, battery consumption, battery life, constraints, temperature, and measurable phenomena.","Referring to , a method  for handling information can further comprise providing  the entitlement vector comprising a plurality of bit fields respectively directed to a plurality of different resources and capabilities. The method  can further comprise specifying  the resources and capabilities used by the at least one object.","In various embodiments and\/or applications, as illustrated in , a method  for handling information can further comprise monitoring  resource usage, and determining  values for the bit fields based on the monitoring.","As shown in , a method  for handling information can further comprise monitoring  resource usage, and scaling  data according to human-perceptible precision. The method  can further comprise setting  values for the bit fields based on the monitoring and scaling.","In other embodiments and\/or applications, as depicted in , a method  for handling information can further comprise monitoring  resource usage, scaling  data according to physical precision, and setting  values for the bit fields based on the monitoring and scaling.","Similarly, illustrated in , a method  for handling information can further comprise monitoring  resource usage, and determining  values for selected ones of the bit fields based on the monitoring. The method  can further comprise setting  the selected ones of the bit fields.","Furthermore, referring to , a method  for handling information can further comprise monitoring  resource usage, and determining  a value of a single bit of the bit fields based on the monitoring.","In additional embodiments, as shown in , method  for handling information can further comprise monitoring  resource usage, and associating  a lookup table as at least a portion of the bit fields based on the monitoring.","Referring to , a method  for handling information can further comprise monitoring  resource usage, and associating  a hash table as at least a portion of the bit fields based on the monitoring.","In various embodiments and\/or applications, as illustrated in , a method  for handling information can further comprise monitoring  resource usage, and associating  a library call as at least a portion of the bit fields based on the monitoring.","Various methods can deploy a logic to perform different aspects of operation. For example, as shown in , a method  for handling information can further comprise monitoring  resource usage, determining  values for the bit fields based on the monitoring, and returning  the entitlement vector using a library call.","In other embodiments and\/or applications, as depicted in , a method  for handling information can further comprise monitoring  resource usage, and determining  values for the bit fields based on the monitoring. The method  can further comprise installing  the entitlement vector into hardware as a side effect of a library call.","Similarly, illustrated in , a method  for handling information can further comprise selecting  the bit fields from data types of a group consisting of integer, floating point, Boolean, characters, strings, numerical values, numerical values indicative of relative resource allocation, complex numbers, tables, and library calls.","Furthermore, referring to , a method  for handling information can further comprise specifying  a data path width bit field in the bit fields of the entitlement vector, and requesting  allocation of only a portion of a maximum data path width using the data path width bit field.","In additional embodiments, as shown in , method  for handling information can further comprise specifying  a data path width bit field in the bit fields of the entitlement vector, and requesting  allocation of only a portion of a maximum data path width wherein a plurality of processes share the entitlement vector using the data path width bit field.","Referring to , a method  for handling information can further comprise specifying  a data path width bit field in the bit fields of the entitlement vector, and requesting  allocation of only a portion of a maximum data path width wherein a portion of the entitlement vector is deactivated to conserve energy using the data path width bit field.","In various embodiments and\/or applications, as illustrated in , a method  for handling information can further comprise specifying  a scale bit field in the bit fields of the entitlement vector, and specifying  a scale of at least one of the bit fields using the scale bit field.","As shown in , a method  for handling information can further comprise providing  a library, and specifying and\/or allocating  resources and\/or capabilities used by at least one object in the library using the entitlement vector.","In other embodiments and\/or applications, as depicted in , a method  for handling information can further comprise scheduling  a process of a plurality of processes based on at least one entitlement vector of a plurality of entitlement vectors.","Similarly, illustrated in , a method  for handling information can further comprise scheduling  a process of a plurality of processes based on the entitlement vector, and specifying  that the process of the plurality of processes is entitled to a predetermined percentage of operational resources using the entitlement vector.","Furthermore, referring to , a method  for handling information can further comprise ascertaining and specifying  resources and capabilities used by the at least one object using the entitlement vector.","In additional embodiments, as shown in , method  for handling information can further comprise ascertaining  resources and\/or capabilities used by an object of the plurality of objects. The method  can further comprise setting  the entitlement vector according to the ascertained resources and\/or capabilities.","Referring to , a method  for handling information can further comprise dynamically modifying  the entitlement vector according to usage of resources by the at least one object of a plurality of a plurality of objects.","Referring to , schematic flow diagrams depict an embodiment or embodiments of a method operable in an information handling apparatus that enables dynamic modification of bit fields in entitlement vectors for allocating resources. Accordingly, in an illustrative embodiment, referring to , a method  for handling information can comprise providing  an entitlement vector configured with a plurality of bit fields at least partly corresponding to a plurality of resources, and specifying  the resources used by at least one object of a plurality of a plurality of objects. The method  can further comprise monitoring  resource usage, and determining  values for the bit fields based on the monitoring.","In various embodiments, the resources can comprise physical\/logical resources and operational resources. The physical\/logical resources can comprise at least one of a group consisting of physical and\/or logical instances of processors, central processing units (CPUs), graphics hardware, network controllers, memory, memory management, hardware, microarchitecture, sound cards, video cards, network interfaces, instruction set architecture (ISA), library calls, library functions, software objects, compilers, and operating systems. The operational resources can comprise at least one of power, voltage, current, electrons, frequency, execution cycles, battery consumption, battery life, constraints, temperature, and measurable phenomena.","Referring to , a method  for handling information can further comprise providing  the entitlement vector comprising a plurality of bit fields respectively directed to a plurality of different resources and capabilities, and specifying  the resources and capabilities used by the at least one object.","Several methods can scale values in the bit fields of the entitlement vector to the range of human perception. For example, as shown in , a method  for handling information can further comprise monitoring  resource usage, scaling  data according to human-perceptible precision, and setting  values for the bit fields based on the monitoring and scaling.","Some methods can scale values in the bit fields of the entitlement vector to the range of actual physical phenomena. For example, as shown in , a method  for handling information can further comprise monitoring  resource usage, scaling  data according to physical precision, and setting  values for the bit fields based on the monitoring and scaling.","In additional embodiments, as shown in , method  for handling information can further comprise monitoring  resource usage, and determining  values for selected ones of the bit fields based on the monitoring. The method  can further comprise setting  the selected ones of the bit fields.","In further embodiments, depicted in , a method  for handling information can further comprise monitoring  resource usage, and determining  a value of a single bit of the bit fields based on the monitoring.","Referring to , a method  for handling information can further comprise monitoring  resource usage, and associating  a lookup table as at least a portion of the bit fields based on the monitoring.","In various embodiments and\/or applications, as illustrated in , a method  for handling information can further comprise monitoring  resource usage, and associating  a hash table as at least a portion of the bit fields based on the monitoring.","Several methods can use a library and library calls to allocate resources using the bit fields of the entitlement vector. For example, as shown in , a method  for handling information can further comprise monitoring  resource usage, and associating  a library call as at least a portion of the bit fields based on the monitoring.","Similarly, as shown in , a method  for handling information can further comprise monitoring  resource usage, and determining  values for the bit fields based on the monitoring. The entitlement vector can be returned  using a library call.","Likewise, as shown in , a method  for handling information can further comprise monitoring  resource usage, and determining  values for the bit fields based on the monitoring. The entitlement vector can be installed  into hardware as a side effect of a library call.","Referring to , an embodiment comprises a computer program product . The computer program product includes a computer-readable storage medium  bearing program instructions. The program instructions are operable to perform a process in a computing device. The computer program product can be constituted as any combination of one or more computer usable or computer readable medium(s), for example but not limited to, communication, electronic, semiconductor, magnetic, optical, electromagnetic, infrared, in the form of propagation medium, system, apparatus, device, or the like. Specific examples of the computer-readable medium may include, are not limited to, a wired connection, a wireless connection, Internet or an intranet transmission media, an optical fiber, a magnetic storage device, a portable diskette, a hard disk, a portable compact disc read-only memory (CDROM), an optical storage device, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM), Flash memory, or the like. Similarly, the computer-usable or computer-readable medium can be a visual display such as paper, poster, screen view, that can be visually or electronically captured such as by optical scanning of a medium, then compiled, interpreted, or otherwise processed.","The program instructions can comprise program instructions  operable to program instructions operable to provide an entitlement vector configured with a plurality of bit fields at least partly corresponding to a plurality of resources, and program instructions  operable to specify the resources used by at least one object of a plurality of a plurality of objects. The program instructions can further comprise program instructions  operable to allocate the resources to the at least one object based on entitlement as specified by the entitlement vector.","In some embodiments, the computer program product can further comprise program instructions  operable to provide the entitlement vector comprising a plurality of bit fields respectively directed to a plurality of different resources and capabilities. The program instructions can further comprise program instructions  operable to specify the resources and capabilities used by the at least one object.","In further embodiments and\/or applications, the computer program product can further comprise program instructions  operable to monitor resource usage, and program instructions  operable to determine values for the bit fields based on the monitoring.","Referring to , a schematic block diagram illustrates an embodiment of an information handling apparatus  which is adapted to facilitate resource allocation using an entitlement vector comprising multiple fields that are respectively directed to multiple different resources or capabilities. The illustrative information handling apparatus  can comprise means  for providing an entitlement vector  configured with a plurality of bit fields  at least partly corresponding to a plurality of resources , and means  for specifying the resources  used by at least one object  of a plurality of a plurality of objects . The information handling apparatus  can further comprise means  for allocating the resources  to the at least one object  based on entitlement as specified by the entitlement vector .","In various embodiments, the information handling apparatus  can further comprise means  for providing the entitlement vector  comprising a plurality of bit fields  respectively directed to a plurality of different resources and capabilities , and means  for specifying the resources  and capabilities  used by the at least one object .","In further embodiments and\/or applications, the information handling apparatus  can further comprise means  for monitoring resource usage , and means  for determining values for the bit fields  based on the monitoring.","Terms \u201csubstantially\u201d, \u201cessentially\u201d, or \u201capproximately\u201d, that may be used herein, relate to an industry-accepted variability to the corresponding term. Such an industry-accepted variability ranges from less than one percent to twenty percent and corresponds to, but is not limited to, materials, shapes, sizes, functionality, values, process variations, and the like. The term \u201ccoupled\u201d, as may be used herein, includes direct coupling and indirect coupling via another component or element where, for indirect coupling, the intervening component or element does not modify the operation. Inferred coupling, for example where one element is coupled to another element by inference, includes direct and indirect coupling between two elements in the same manner as \u201ccoupled\u201d.","The illustrative pictorial diagrams depict structures and process actions in a manufacturing process. Although the particular examples illustrate specific structures and process acts, many alternative implementations are possible and commonly made by simple design choice. Manufacturing actions may be executed in different order from the specific description herein, based on considerations of function, purpose, conformance to standard, legacy structure, and the like.","While the present disclosure describes various embodiments, these embodiments are to be understood as illustrative and do not limit the claim scope. Many variations, modifications, additions and improvements of the described embodiments are possible. For example, those having ordinary skill in the art will readily implement the steps necessary to provide the structures and methods disclosed herein, and will understand that the process parameters, materials, shapes, and dimensions are given by way of example only. The parameters, materials, and dimensions can be varied to achieve the desired structure as well as modifications, which are within the scope of the claims. Variations and modifications of the embodiments disclosed herein may also be made while remaining within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the invention relating to both structure and method of operation may best be understood by referring to the following description and accompanying drawings:",{"@attributes":{"id":"p-0011","num":"0022"},"figref":["FIGS. 1A","FIG. 1E"],"b":["1","1","1"]},{"@attributes":{"id":"p-0012","num":"0023"},"figref":"FIGS. 2A","b":["2","2"]},{"@attributes":{"id":"p-0013","num":"0024"},"figref":"FIGS. 3A through 3W"},{"@attributes":{"id":"p-0014","num":"0025"},"figref":"FIGS. 4A through 4K"},{"@attributes":{"id":"p-0015","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0027"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
