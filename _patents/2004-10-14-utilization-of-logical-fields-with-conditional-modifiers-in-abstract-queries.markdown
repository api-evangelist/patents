---
title: Utilization of logical fields with conditional modifiers in abstract queries
abstract: Methods, systems, and articles of manufacture for enhancing abstract queries by utilizing conditional modifiers with logical fields are provided. Conditional modifiers allow for the referencing of multiple physical fields via a single logical field. Further, conditional modifiers facilitate the ability to specify, on an instance by instance basis, which physical field or combination of physical fields a particular logical field should reference.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08090739&OS=08090739&RS=08090739
owner: International Business Machines Corporation
number: 08090739
owner_city: Armonk
owner_country: US
publication_date: 20041014
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","An Exemplary System","An Exemplary Graphical User Interface"],"p":["The present application is related to commonly owned, co-pending U.S. patent application Ser. No. 10\/083,075, filed Feb. 26, 2002, entitled \u201cApplication Portability And Extensibility Through Database Schema And Query Abstraction\u201d, which is incorporated herein by reference.","1. Field of the Invention","The present invention generally relates to data processing and more particularly to utilizing logical fields with conditional modifiers in abstract queries.","2. Description of the Related Art","Databases are computerized information storage and retrieval systems. A relational database management system is a computer database management system (DBMS) that uses relational techniques for storing and retrieving data. The most prevalent type of database is the relational database, a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways. A distributed database is one that can be dispersed or replicated among different points in a network. An object-oriented programming database is one that is congruent with the data defined in object classes and subclasses.","Regardless of the particular architecture, in a DBMS, a requesting entity (e.g., an application or the operating system) demands access to a specified database by issuing a database access request. Such requests may include, for instance, simple catalog lookup requests or transactions and combinations of transactions that operate to read, change and add specified records in the database. These requests are made using high-level query languages such as the Structured Query Language (SQL) and application programming interfaces (API's) such as Java\u00ae Database Connectivity (JDBC). The term \u201cquery\u201d denominates a set of commands for retrieving data from a stored database. Queries take the form of a command language, such as SQL, that lets programmers and programs select, insert, update, find out the location of data, and so forth.","Unfortunately, generating queries using SQL may require a detailed understanding of the possibly complex physical layout of the underlying database and interpretation of cryptic field names. For some applications, to facilitate the query building process, an abstraction model may be utilized that, in effect, hides some of the complexities of the underlying database physical layout from users. The abstraction model may include logical fields with recognizable names that map to corresponding physical fields of the underlying database. \u201cAbstract\u201d queries may be generated containing conditions based on the logical fields. Upon issuance, the logical fields of an abstract query may be mapped to corresponding physical fields to create a physical or \u201cconcrete\u201d query. For some applications, abstract queries may be saved, allowing subsequent users to reuse the saved abstract queries without having to generate their own. The concepts of data abstraction and abstract queries are described in detail in the commonly owned, co-pending application Ser. No. 10\/083,075, entitled \u201cImproved Application Portability And Extensibility Through Database Schema And Query Abstraction,\u201d filed Feb. 26, 2002, herein incorporated by reference in its entirety.","Abstract queries often contain a conditional element (e.g., a WHERE clause in a corresponding SQL statement) in which a logical field is used within an expression with a comparison operator. As described in the related application Ser. No. 10\/083,075, logical fields are typically mapped to a particular physical field in a physical database. For instance, if the physical database was implemented as a relational database, a particular logical field would be mapped to a particular column within a relational table.","While abstraction makes working with the data easy and efficient, in certain instances, there remains a need to make logical fields flexible so that they can refer to more than one field in a physical database. For example, suppose that in an environment supporting a medical testing application, a logical field named WEIGHT is mapped to a column named \u201cweight\u201d in a relational table named demographic. Consider that the weight column contains patients' most recently measured weight. Accordingly, in abstract queries where a patient's current weight is required, the WEIGHT logical field can be utilized. For example, in order to determine the names of all patients who currently weigh more than 220 pounds, the following abstract query may be submitted: Return NAME where WEIGHT>220.","Further, suppose that patients' weights measured in previous years (i.e., historical weight) is also available in the database. However, the historical data is not available in the demographic table, but rather in a separate table called weight_history. A logical field called HISTORICAL_WEIGHT is mapped to the weight column of weight_history table. Therefore, the names of all patients who have weighed more than 220 in the past can be found via the following query: Return NAME where HISTORICAL_WEIGHT>220.","In terms of the above example queries, if the user wanted to consolidate the two sets of query results pertaining to current patient weight data and historical patient weight data, they would have to run two separate queries (as shown above) and then merge the query results.","Further, it should be recognized that the WEIGHT and the WEIGHT_HISTORY logical fields represent different perspectives of the same data. For example, the WEIGHT logical field represents current data regarding patients' weights, and the WEIGHT_HISTORY logical field represents historical data. In many cases, it would be beneficial to provide users the ability to gain access to multiple physical fields via a single logical field. For instance, in the above example, it would be beneficial to provide users access to both the current data and the historical data via a single logical field, such as the WEIGHT logical field. Unfortunately, the infrastructure facilitating existing data abstraction models may not be flexible enough to allow for the referencing of multiple physical data sources as described above. Therefore, what is needed is a data abstraction solution that allows for the referencing of multiple physical fields via a single logical field. A further need is to provide users the ability to specify, on an instance by instance basis, which physical field or combination of physical fields a particular logical field should reference.","The present invention is generally directed to methods, systems and articles of manufacture for utilizing conditional modifiers with abstract queries.","One embodiment of the present invention provides a data processing system for retrieving data. The data processing system generally includes an abstract model comprising a plurality of definitions of logical fields, each definition comprising a logical field name and a mapping referencing physical data, wherein at least one logical field comprises at least a first mapping referencing data in a first physical data structure, a second mapping referencing data in a second physical data structure, and a first conditional modifier allowing the logical field to be selectably mapped to the first physical data structure using the first mapping or the second physical data structure using the second mapping, depending on the presence of the first conditional modifier in an abstract query containing the at least one logical field. The data processing system also includes a query processor configured to convert one or more abstract queries containing logical fields configured with conditional modifiers into one or more executable queries of a given query language by referencing the abstract model.","The present invention is generally directed to methods, systems and articles of manufacture for enhancing abstract queries by utilizing conditional modifiers with logical fields.","Further, in the following, reference is made to embodiments of the invention. The invention is not, however, limited to specific described embodiments. Instead, any combination of the following features and elements, whether related to different embodiments or not, is contemplated to implement and practice the invention. Furthermore, in various embodiments the invention provides numerous advantages over the prior art. Although embodiments of the invention may achieve advantages over other possible solutions or over the prior art, whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus, the following aspects, features, embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in the claims. Similarly, reference to \u201cthe invention\u201d shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims, except where explicitly recited in a specific claim.","As used herein, the term user may generally apply to any entity utilizing the data processing system described herein, such as a person (e.g., an individual) interacting with an application program or an application program itself, for example, performing automated tasks. While the following description may often refer to a graphical user interface (GUI) intended to present information to and receive information from a person, it should be understood that in many cases, the same functionality may be provided through a non-graphical user interface, such as a command line and, further, similar information may be exchanged with a non-person user via a programming interface.","As used herein, the term database generally refers to a collection of data arranged for ease and speed of search and retrieval. While the following description focuses on transaction statements (such as queries) for relational databases, those skilled in the art will recognize the methods described herein may be used with any type of database including an object-relational database and an XML-based database.","In one embodiment of a data abstraction model, users may compose an abstract query using a set of logical fields defined by a data abstraction layer. The data abstraction layer, along with an abstract query interface, provide users with an abstract view of the data available to query (e.g., search, select, and modify). The data itself is stored in a set of underlying physical databases using a concrete physical representation (e.g., a relational database). The physical representation may include a single computer system, or may comprise many such systems accessible over computer networks. The data abstraction layer provides a logical view of one or more such underlying data repositories that is independent of the particular manner of data representation. Where multiple data sources are provided, each logical field may be is configured to include a location specification identifying the location of the data to be accessed. A runtime component is configured to resolve an abstract query into a form that can be issued against the underlying physical data repositories.","One embodiment of the invention is implemented as a program product for use with a computer system such as, for example, the computer system  shown in  and described below. The program product defines functions of the embodiments (including the methods) described herein and can be contained on a variety of signal-bearing media. Illustrative signal-bearing media include, without limitation, (i) information permanently stored on non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive); (ii) alterable information stored on writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive); or (iii) information conveyed across communications media, (e.g., a computer or telephone network) including wireless communications. The latter embodiment specifically includes information downloaded from the internet and other networks. Such signal-bearing media, when carrying computer-readable instructions that perform methods of the present invention, represent embodiments of the present invention.","In general, the routines executed to implement the embodiments of the invention, may be part of an operating system or a specific application, component, program, module, object, or sequence of instructions. The software of the present invention typically is comprised of a plurality of instructions capable of being performed using a computer system. Also, programs typically also include variables and data structures that reside in memory or on storage devices as part of their operation. In addition, various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. Those skilled in the art will recognize, however, that any particular nomenclature that follows is used merely for convenience, and thus does not limit the invention for use solely in any specific application identified or implied by such nomenclature. Furthermore, the functionality of programs described here in uses discrete modules or components interacting with one another. Those skilled in the art will recognize that different embodiments may combine or merge the components and modules described herein in many different ways.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1","b":["100","100","105","120","111","110","111","214","214","214","214"],"sub":["1","2","3"]},"The system  may include a data abstraction model (DAM)  that, in effect, shields a user from the details of the particular physical representation of the database . The DAM , also referred to as a data repository abstraction (DRA) in related applications, may define a set of logical fields that map to underlying physical fields of the underlying database . Users may be able to create abstract queries based on the logical fields, via the query building interface . Upon issuance of abstract queries, a query execution component  may convert an abstract query into a physical or \u201cconcrete\u201d query suitable for issuance against the database  by mapping logical fields of the abstract query to physical fields of the particular physical representation , based on the field definitions in the DAM .","Additionally, embodiments of the present invention allow for a particular logical field  to be mapped to two or more physical fields residing in multiple physical data structures. Within abstract queries , logical fields  are often used within the conditional portion of the abstract query statement. According to embodiments of the present invention, logical fields are configured to be used with conditional modifiers . Logical fields  configured with conditional modifiers  are capable of referencing data in more than one physical data structure. As will be described in greater detail later, when these fields are used in the conditional portion of abstract queries , a conditional modifier can be utilized to allow the user to specify which particular physical data structure the logical field should reference for a particular implementation of an abstract query .","There may be instances, however, where an alternative physical data structure may not be available for the logical field  to reference based on the conditional modifier . In these instances, it may be necessary to define a change enabler  that may be implemented as a program module that creates the alternative physical data structure (e.g. a table) and populates the new structure with data as specified by the user.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2","b":["150","208","208","208","131","130","208","210","210","210","210","210","210","212","214","212","212","212","212","130","214","214","214","156","214","214","214"],"sub":["1-5 ","1","2","3","4","5 ","1","2","3","4","5 ","1","2 ","N ","1 ","2","N "]},"Any number of access methods are contemplated depending upon the number of different types of logical fields to be supported. In one embodiment, access methods for simple fields, filtered fields and composed fields, and logical fields with conditional modifiers are provided. Logical fields configured to work with conditional modifiers are capable of representing data in more than one physical data structure. When these logical fields are used in the conditional portion of abstract queries, a conditional modifier can be specified to allow the user to specify which particular physical data structure the logical field should reference for that particular query. Logical fields with conditional modifiers are described in greater detail below.","Referring back to , the field specifications , and exemplify simple field access methods , , and , respectively. Simple fields are mapped directly to a particular entity in the underlying physical data representation (e.g., a field mapped to a given database table and column). By way of illustration, the simple field access method shown in  maps the logical field name (\u201cFirstName\u201d) to a column named \u201cf_name\u201d in a table named \u201ccontact\u201d. The field specification exemplifies a filtered field access method . Filtered fields identify an associated physical entity and provide rules used to define a particular subset of items within the physical data representation. An example is provided in  in which the filtered field access method maps the logical field name (\u201cAnytownLastName\u201d) to a physical entity in a column named \u201cI_name\u201d in a table named \u201ccontact\u201d and defines a filter for individuals in the city of Anytown. Another example of a filtered field is a New York ZIP code field that maps to the physical representation of ZIP codes and restricts the data only to those ZIP codes defined for the state of New York. The field specification exemplifies a composed field access method . Composed access methods compute a logical field from one or more physical fields using an expression supplied as part of the access method definition. In this way, information which does not exist in the underlying data representation may be computed. In the example illustrated in  the composed field access method maps the logical field name \u201cAgeInDecades\u201d to \u201cAgeInYears\/10\u201d. Another example is a sales tax field that is composed by multiplying a sales price field by a sales tax rate.","By way of example, the field specifications  of the component of the data abstraction model  shown in  are representative of logical fields mapped to data represented in the relational data representation . However, other instances of the data abstraction model  map logical fields to other physical data representations, such as XML. An illustrative abstract query corresponding to the abstract query  containing logical fields  with conditional modifiers  illustrated in  is shown in Table I below. Again, in this example, the data abstraction model  is defined using XML.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"QUERY EXAMPLE"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"001\u2003\u2003<?xml version=\u201c1.0\u201d?>"},{"entry":"002\u2003\u2003<!--Query string representation: (FirstName = \u201cMary\u201d AND"},{"entry":"003\u2003\u2003LastName = \u201cMcGoon\u201d) OR State = \u201cNC\u201d-->"},{"entry":"004\u2003\u2003<QueryAbstraction>"},{"entry":"005\u2003\u2003\u2003<Selection>"},{"entry":"006\u2003\u2003\u2003\u2003<Condition internalID=\u201c4\u201d>"},{"entry":"007\u2003\u2003\u2003\u2003\u2003<Condition field=\u201cFirstName\u201d operator=\u201cEQ\u201d value="},{"entry":"008\u2003\u2003\u201cMary\u201d internalID=\u201c1\u201d\/>"},{"entry":"009\u2003\u2003\u2003\u2003\u2003<Condition field=\u201cLastName\u201d operator=\u201cEQ\u201d value="},{"entry":"\u2003\u2002\u2003\u2003\u2003\u2003\u2003\u201cMcGoon\u201d"},{"entry":"010\u2003\u2003\u2003\u2003\u2003\u2003<Conditional modifier=\u201cwas\u201d>"},{"entry":"011\u2003\u2003internalID=\u201c3\u201d relOperator=\u201cAND\u201d><\/Condition>"},{"entry":"012\u2003\u2003\u2003\u2003<\/Condition>"},{"entry":"013\u2003\u2003\u2003\u2003<Condition field=\u201cState\u201d operator=\u201cEQ\u201d value=\u201cNC\u201d"},{"entry":"014\u2003\u2003internalID=\u201c2\u201d relOperator=\u201cOR\u201d><\/Condition>"},{"entry":"015\u2003\u2003\u2003<\/Selection>"},{"entry":"016\u2003\u2003\u2003<Results>"},{"entry":"017\u2003\u2003\u2003\u2003\u2003<Field name=\u201cFirstName\u201d\/>"},{"entry":"018\u2003\u2003\u2003\u2003\u2003<Field name=\u201cLastName\u201d\/>"},{"entry":"019\u2003\u2003\u2003\u2003\u2003<Field name=\u201cStreet\u201d\/>"},{"entry":"020\u2003\u2003\u2003<\/Results>"},{"entry":"021\u2003\u2003<\/QueryAbstraction>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["005","015","016","020"]},"An illustrative instance of a component of the data abstraction model  (defined using XML) corresponding to the abstract query in Table I is shown in Table II below. For this example, the data abstraction model is defined using XML.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DATA REPOSITORY ABSTRACTION EXAMPLE"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"001\u2003\u2003<?xml version=\u201c1.0\u201d?>"},{"entry":"002\u2003\u2003<DataRepository>"},{"entry":"003\u2003\u2003\u2003<Category name=\u201cDemographic\u201d>"},{"entry":"004\u2003\u2003\u2003\u2003<Field queryable=\u201cYes\u201d name=\u201cFirstName\u201d displayable=\u201cYes\u201d>"},{"entry":"005\u2003\u2003\u2003\u2003\u2003\u2003<AccessMethod>"},{"entry":"006\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Simple columnName=\u201cf_name\u201d tableName=\u201ccontact\u201d><\/Simple>"},{"entry":"007\u2003\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"},{"entry":"008\u2003\u2003\u2003\u2003\u2003\u2003<Type baseType=\u201cchar\u201d><\/Type>"},{"entry":"009\u2003\u2003\u2003\u2003<\/Field>"},{"entry":"010\u2003\u2003\u2003\u2003<Field queryable=\u201cYes\u201d name=\u201cLastName\u201d displayable=\u201cYes\u201d>"},{"entry":"011\u2003\u2003\u2003\u2003\u2003\u2003<AccessMethod>"},{"entry":"012\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Simple columnName=\u201cI_name\u201d tableName=\u201ccontact\u201d><\/Simple>"},{"entry":"013\u2003\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"},{"entry":"014\u2003\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"},{"entry":"015\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Conditional_modifier_based columnName= \u201cI_name\u201d"},{"entry":"016\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003tablename=\u201cprevious_contact\u201d><\/Conditional_modifier_based>"},{"entry":"017\u2003\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"},{"entry":"018\u2003\u2003\u2003\u2003\u2003\u2003<Type baseType=\u201cchar\u201d><\/Type>"},{"entry":"019\u2003\u2003\u2003\u2003<\/Field>"},{"entry":"020\u2003\u2003\u2003\u2003<Field queryable=\u201cYes\u201d name=\u201cState\u201d displayable=\u201cYes\u201d>"},{"entry":"021\u2003\u2003\u2003\u2003\u2003\u2003<AccessMethod>"},{"entry":"022\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Simple columnName=\u201cstate\u201d tableName=\u201ccontact\u201d><\/Simple>"},{"entry":"023\u2003\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"},{"entry":"024\u2003\u2003\u2003\u2003\u2003\u2003<Type baseType=\u201cchar\u201d><\/Type>"},{"entry":"025\u2003\u2003\u2003\u2003<\/Field>"},{"entry":"026\u2003\u2003\u2003\u2003<Field queryable=\u201cYes\u201d name=\u201cWeight\u201d>"},{"entry":"027\u2003\u2003\u2003\u2003\u2003\u2003<AccessMethod>"},{"entry":"028\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Simple attrName=\u201cweight\u201d entityName=\u201cdemographic\u201d>"},{"entry":"029\u2003\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"},{"entry":"030\u2003\u2003\u2003\u2003\u2003\u2003<Type baseType=\u201cInt\u201d \/>"},{"entry":"031\u2003\u2003\u2003\u2003<\/Field>"},{"entry":"032\u2003\u2003\u2003\u2003<Field name=\u201cWeight History\u201d>"},{"entry":"033\u2003\u2003\u2003\u2003\u2003\u2003<AccessMethod>"},{"entry":"034\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Simple attrName=\u201chistorical_weight\u201d entityName"},{"entry":"035\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003=\u201cweight_history\u201d>"},{"entry":"036\u2003\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"},{"entry":"037\u2003\u2003\u2003\u2003\u2003\u2003<Type baseType=\u201cInt\u201d \/>"},{"entry":"038\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/Field>"},{"entry":"039\u2003\u2003\u2003<\/Category>"},{"entry":"040\u2003\u2003\u2003<Relations>"},{"entry":"041\u2003\u2003\u2003\u2003\u2003\u2003<Link id=\u201cAnyName\u201d source=\u201cDEMOGRAPHIC\u201d"},{"entry":"042\u2003\u2003\u2003\u2003\u2003\u2003\u2003target=\u201cWEIGHT_HISTORY\u201d type=\u201cLEFT\u201d >"},{"entry":"043\u2003\u2003\u2003\u2003\u2003\u2003\u2003<LinkPoint source=\u201cPID\u201d target=\u201cPID\u201d \/>"},{"entry":"044\u2003\u2003\u2003\u2003\u2003\u2003<\/Link>"},{"entry":"045\u2003\u2003\u2003<\/Relations>"},{"entry":"046\u2003\u2003<\/DataRepository>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3","FIG. 1"],"b":["300","160","300","300","302","160","130","304","160","306","160","306","308","310","312"]},"At step , the query execution component  uses the field name from a selection criterion of the abstract query to look up the definition of the field in the data abstraction model . As noted above, the field definition includes a definition of the access method used to access the physical data associated with the field. The query execution component  then builds (step ) a concrete query contribution for the logical field and conditional modifiers being processed. As defined herein, a concrete query contribution is a portion of a concrete query that is used to perform data selection based on the current logical field. A concrete query is a query represented in languages like SQL and XML Query and is consistent with the data of a given physical data repository (e.g., a relational database or XML repository). Accordingly, the concrete query is used to locate and retrieve data from a physical data repository, represented by the database  shown in . The concrete query contribution generated for the current field is then added to a concrete query statement. The method  then returns to step  to begin processing for the next field of the abstract query. Accordingly, the process entered at step  is iterated for each data selection field in the abstract query, thereby contributing additional content to the eventual query to be performed.","After building the data selection portion of the concrete query, query execution component  identifies the information to be returned as a result of query execution. As described above, in one embodiment, the abstract query defines a list of logical fields that are to be returned as a result of query execution, referred to herein as a result specification. A result specification in the abstract query may consist of a field name and sort criteria. Accordingly, the method  enters a loop at step  (defined by steps , ,  and ) to add result field definitions to the concrete query being generated. At step , the query execution component  looks up a result field name (from the result specification of the abstract query) in the data abstraction model  and then retrieves a result field definition from the data abstraction model  to identify the physical location of data to be returned for the current logical result field. The query execution component  then builds (as step ) a concrete query contribution (of the concrete query that identifies physical location of data to be returned) for the logical result field. At step , concrete query contribution is then added to the concrete query Statement.","One embodiment of a method  for building a concrete query contribution for a logical field according to steps  and  is described with reference to . At step , the method  queries whether the access method associated with the current logical field is a simple access method. If so, the concrete query contribution is built (step ) based on physical data location information (step ). Processing then continues according to method  described above. Otherwise, processing continues to step  to query whether the access method associated with the current logical field is a filtered access method. If so, the concrete query contribution is built (step ) based on physical data location information for some physical data entity. At step , the concrete query contribution is extended with additional logic (filter selection) used to subset data associated with the physical data entity. Processing then continues according to method  described above.","If the access method is not a filtered access method, processing proceeds from step  to step  where the method  queries whether the access method is a composed access method. If the access method is a composed access method, the physical data location for each sub-field reference in the composed field expression is located and retrieved at step . At step , the physical field location information of the composed field expression is substituted for the logical field references of the composed field expression, whereby the concrete query contribution is generated. Processing then continues according to method  described above.","If the access method is not a composed access method, at step  it is determined if the access method is a conditional modifier based access method. If it is, at step  the conditional modifier based access method is processed according to operations  illustrated in . However, if the access method is not a conditional modifier based access method, processing proceeds from step  to step . Step  is representative of any other access method types contemplated as embodiments of the present invention. Those skilled in the art will recognize that embodiments are contemplated in which less then all the available access methods are implemented. For example, in a particular embodiment only simple access methods are used. In another embodiment, only simple access methods and filtered access methods are used.","As shown in , processing related to the conditional modifier based access method begins at step  with the parsing of an abstract query  in order to identify logical fields  with conditional modifiers  in the conditional portion of the abstract query . At step , information, such as field mappings, associated with the identified logical fields with conditional modifiers (from step ) is retrieved from the DAM . Next, at step , an appropriate physical query is generated based on mappings associated with the identified logical fields  and conditional modifiers .",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 6","b":["600","601","131","132","132"]},"At step , a loop of operations - is entered. These operations are directed to defining conditional modifiers for the present logical field defined in step . Once definition of the conditional modifiers is complete, the present logical field is ready to be used with conditional modifiers within the conditional portion of abstract queries. As will be described in more detail later, the use of conditional modifiers allows for logical fields to reference data in multiple physical data structures.","At step , logic related to the conditional modifier is specified in abstract form. Specifically, the logic specified for the conditional modifier supports the query execution component  in providing an appropriate translation of an abstract query which contains a logical field with the conditional modifier, so that a functionally correct physical query is generated. Logic related to conditional modifiers is described in more detail with reference to .","As described above, a conditional modifier  allows for a logical field  to be mapped to multiple columns from one or more tables. There may be instances, however, where an alternative column may not be available for the logical field to point to. In these instances, it may be necessary to define a change enabler  to create the column within a table and then to populate the table with appropriate data. For example, in an implementation utilizing relational databases, the change enabler  may be implemented as a program module. In some embodiments the program may contain code that includes data definition language that, when executed, creates a database table with the appropriate columns. The program may also include instructions to create a database trigger that can execute data manipulation language commands to populate records in the new table. Change enablers  are described in more detail with reference to .","At step , it is determined if a change enabler  is needed. If a change enabler  is necessary, at step  a change enabler  is defined and configured per the requirements of the user. Configuration of change enablers  and the functionality provided by change enablers is described with more detail with reference to .","As mentioned earlier, it is possible for logical fields  to be configured with multiple conditional modifiers . At step , it is determined if additional conditional modifiers  are to be configured for the current logical field . If additional conditional modifiers  are desired, processing returns to step  in order to define the next conditional modifier .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 7","b":["700","700","701","704","701","702","703","704","700"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 8","b":["800","801","802","803","800","703","700","800","800"]},"Those skilled in the art will recognize that the demographic table  and the weight_history table  can be \u201cjoined\u201d in a query based on the PID column that appears in each of the tables. Some exemplary abstract queries and their corresponding physical queries which reference the demographic table  and weight_history table are provided below.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"BASIC QUERY EXAMPLE"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Abstract Query:"]},{"entry":[{},"001\u2003\u2003\u2002Return ID and NAME where WEIGHT > 220"]},{"entry":[{},"Corresponding Physical Query:"]},{"entry":[{},"002\u2003\u2003select distinct PID, NAME"]},{"entry":[{},"003\u2003\u2003\u2003\u2003from DEMOGRAPHIC"]},{"entry":[{},"004\u2003\u2003\u2002where WEIGHT > 220;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table I, shown above, contains a standard abstract query (line ) with a logical field included in the conditional portion of the query. The purpose of this query is to retrieve the identification numbers and names of all patients who weigh greater than 220 pounds. In this example, the conditional portion of the query is \u201cwhere WEIGHT>220\u201d, and the logical field in the conditional is WEIGHT. The WEIGHT logical field is mapped to the weight column  of the demographic table . As described herein, this mapping of the WEIGHT logical field will be referred to as the standard mapping. The abstract query shown in line  is submitted to the query execution component  for translation into a physical or executable query that can be submitted to the RDBMS . Lines - in Table A list a physical query represented in SQL that corresponds to the abstract query in line .","The query of Table A provides the user with a list of patients based on their current weight being greater than 220 pounds. Suppose the user wanted a list ID's and names of patients who have weighed over 220 pounds at some point in the past. According to embodiments of the present invention, the abstract query presented in line  of Table B below can be used to provide the desired results.",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE B"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"QUERY EXAMPLE WITH \u201cWAS\u201d CONDITIONAL MODIFIER"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Abstract Query:"]},{"entry":[{},"001\u2003\u2003\u2002Return ID and NAME where WEIGHT was > 220"]},{"entry":[{},"Corresponding Physical Query:"]},{"entry":[{},"002\u2003\u2003select distinct TI.PID, T1.NAME"]},{"entry":[{},"003\u2003\u2003\u2003from DEMOGRAPHIC T1, WEIGHT_HISTORY T2"]},{"entry":[{},"004\u2003\u2003\u2002where T2.WEIGHT > 220"]},{"entry":[{},"005\u2003\u2003\u2003\u2003and T1.PID = T2.PID;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"It can be seen that the abstract query of Table B is very similar to the abstract query of Table A, with the only difference being the inclusion of the \u201cwas\u201d conditional modifier after the WEIGHT logical field in the conditional portion of the query. As stated above, the standard mapping of the WEIGHT logical field specifies that it is mapped to the weight column  of the demographic table . However, according to embodiments of the present invention, another mapping can be created for the WEIGHT logical field. The WEIGHT logical field can also be mapped to the historical_weight column  of the weight_history table . When the WEIGHT field is used together with the \u201cwas\u201d conditional modifier in the conditional portion of an abstract query, the new mapping to the WEIGHT column in the weight_history table  will be used rather than the standard mapping to the weight column  in the demographic table .","Lines - of Table B list the physical query that corresponds to the abstract query in line  of Table B. It can be seen that the historical_weight column  in the weight_history table , rather than the weight column  in the demographic table  is used in the WHERE clause, which corresponds to the conditional portion of the abstract query. It can also be seen that the corresponding physical query joins the demographic table  and the wieight_history table  in order to provide data pertaining to all the fields in the desired results.","Suppose the user required a list of ID's and names of patients who have weighed over 220 pounds within the past two years. The abstract query presented in line  of Table C below provides the desired results by utilizing yet another conditional modifier according to embodiments of the current invention.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE C"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"QUERY EXAMPLE WITH \u201cWAS X IN THE PAST Y YEARS\u201d"},{"entry":"CONDITIONAL MODIFIER"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Abstract Query:"]},{"entry":[{},"001\u2003\u2003Return ID and NAME where WEIGHT was > 220"]},{"entry":[{},"002\u2003\u2003in the past 2 years"]},{"entry":[{},"Corresponding Physical Query:"]},{"entry":[{},"003\u2003\u2003select distinct TI.PID, T1.NAME"]},{"entry":[{},"004\u2003\u2003\u2003from DEMOGRAPHIC T1, WEIGHT_HISTORY T2"]},{"entry":[{},"005\u2003\u2003\u2002where T2.WEIGHT > 220"]},{"entry":[{},"006\u2003\u2003\u2003\u2003and T1.PID = T2.PID"]},{"entry":[{},"007\u2003\u2003\u2003\u2003and (current timestamp \u2212 T2.DATE) < 2 years;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Specifically, the \u201cwas X in the past Y years\u201d conditional modifier is utilized in Table C, wherein during implementation at runtime, X is replaced with a comparison operator combined with a value (e.g., \u201c>220\u201d) and Y is replaced with a numerical value (e.g., \u201c2\u201d) associated with the number of years.","It should be understood that in addition to simply defining which physical field is to be referenced by a particular logical field, a mapping may also include additional logic directed to further processing results. For instance, the \u201cwas X in the past Y years\u201d specifies that the WEIGHT logical field reference the historical_weight column  in the weight_history table ; however the \u201cwas\u201d conditional modifier also contains supplementary logic that specifies that the results be filtered to only include historical data from the past two years. Lines - of Table III presents a physical query that corresponds to the abstract query which includes the \u201cwas X in the past Y years\u201d. Due to the similarities between the \u201cwas\u201d conditional modifier and the \u201cwas X in the past Y years\u201d conditional modifier, it can be seen that lines - are identical to the physical query presented in Table B above. The physical query of Table C, however, also includes line  which specifies that the result set include only records from the past two years.","Embodiments of the present invention also provide support for conditional modifiers that allow for concurrently utilizing multiple mappings for a particular logical field. For instance, suppose the user wanted to retrieve records pertaining patients who currently weigh greater than 220 pounds, or have at some point in the past weighed more than 220 pounds. In other words, the results may contain both current and historical records. In this case, the standard mapping of the WEIGHT logical field combined with the mapping of WEIGHT associated with the \u201cwas\u201d conditional modifier (described above with reference to Table B) would provide the desired results. Line  of Table D below contains an abstract query containing the WEIGHT field and the \u201chas been\u201d conditional modifier. The \u201chas been\u201d conditional modifier provides the combined functionality of the standard mapping and the mapping associated with the \u201cwas\u201d conditional modifier.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE D"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"QUERY EXAMPLE WITH \u201cHAS BEEN\u201d CONDITIONAL MODIFIER"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Abstract Query:"]},{"entry":[{},"001\u2003\u2003Return ID and NAME where WEIGHT has been > 220"]},{"entry":[{},"Corresponding Physical Query:"]},{"entry":[{},"002\u2003\u2003select distinct TI.PID, T1.NAME"]},{"entry":[{},"003\u2003\u2003\u2003from DEMOGRAPHIC T1, WEIGHT_HISTORY T2"]},{"entry":[{},"004\u2003\u2003\u2002where (T2.WEIGHT > 220 or T1.WEIGHT > 220)"]},{"entry":[{},"005\u2003\u2003\u2003\u2003and T1.PID = T2.PID"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Lines - in Table D (shown above) contain a physical query which corresponds to the abstract query of line  containing the \u201chas been\u201d conditional modifier. Again, it can be seen that the physical query is very similar to the physical query based on the \u201cwas\u201d conditional modifier (Table B). However, it can be seen in the conditional portion of the physical query (line ) in Table D that both the weight column  of the demographic table  and the historical_weight column  of the weight_history table  are referenced.","Embodiments of the present invention can also accommodate conditional modifiers that utilize mappings that are based on calls to stored procedures. For instance, suppose using a conditional modifier called \u201ctrend\u201d with the WEIGHT logical field results in the calling of a stored procedure that determines the annual percentage increase (or decrease) of a patient's weight. The exemplary abstract query listed in line  of Table E (shown below) is configured to return the ID and name of patients whose weight has increased by three percent on an annual basis.",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE E"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"QUERY EXAMPLE WITH STORED PROCEDURE BASED"},{"entry":"CONDITIONAL MODIFIER"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Abstract Query:"]},{"entry":[{},"001\u2003\u2003Return ID and NAME where FITNESS TREND = \u201cFAIR\u201d"]},{"entry":[{},"Corresponding Physical Query:"]},{"entry":[{},"002\u2003\u2003select distinct PID, NAME"]},{"entry":[{},"003\u2003\u2003\u2003from DEMOGRAPHIC"]},{"entry":[{},"004\u2003\u2003\u2002where WEIGHT trend > 3%"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"While the exemplary stored procedure presented in Table E is simple, those skilled in the art will understand that more complex stored procedures or program modules can be accommodated by embodiments of the present invention.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIGS. 9-13","FIG. 9"],"b":["703","700","901"]},"A drop down box  is provided to allow users to select the available physical data structures that can be referenced by the logical field. In one embodiment the physical database layer comprises a relational database. Accordingly, the physical data structures available for choosing via the drop down box  are the available relational database tables.","Based on the table selected via drop down box , a list of columns within the selected table is provided via drop down box . In this case, the user has selected the weight column  from the demographic table . Further, check boxes  are provided to allow users to specify if conditional modifiers are to be configured for this logical field. If the \u201cYES\u201d checkbox  is selected, and the continue button  is pushed, the user is presented with a GUI screen illustrated in .",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 10","b":["1001","1002"]},"Configuring conditional modifiers for logical fields involves specifying logic that allows for the proper translation of the abstract query in which they are utilized. A free-form text box  is provided to allow users to input the logic related to the conditional modifier.",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE F"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"EXEMPLARY LOGIC FOR A CONDITIONAL MODIFIER"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Conditional Modifier logic:"]},{"entry":[{},"001\u2003\u2003Replace data:\\\\Demographic\\Weight"]},{"entry":[{},"002\u2003\u2003\u2003\u2003With data:\\\\Demographic\\Weight History"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The syntax shown in free-form text box  is listed in Table F above. Lines  and  specify that rather than referring to the weight column  in the demographic table , when used with the \u201cwas\u201d conditional modifier, the WEIGHT logical field should be mapped to the historical_weight column  of the weight_history table . In one embodiment, the logic needed to implement this type of replacement is found in the definition of the data abstraction model as seen in lines - of Table II above.","Referring back to , two check boxes  are provided to allow the user to specify whether a change enabler is required for the current logical field. If the \u201cYes\u201d check box  is selected, a change enabler definition screen (illustrated in ) is provided. Change enablers are described in detail with reference to  below. However, once satisfied with the conditional modifier definition in , the continue button  can be selected to proceed with other related processing. If the user desires to leave the current screen without saving any changes, the cancel button  can be selected.","The examples described herein demonstrate that use of conditional modifiers supports the functionality of a particular logical field to be mapped to multiple physical data structures. It should be understood that embodiments of the present invention also facilitate the creation of physical data structures to support new mappings. For instance, consider the example abstract query listed in Table B with reference to the \u201cwas\u201d conditional modifier. As described above, the inclusion of the \u201cwas\u201d conditional modifier in the conditional portion of the abstract query specifies that the WEIGHT logical field should refer to data in the historical_weight column  in the weight_history table , rather than the weight column  in the demographic table . Suppose, however, that the weight_history table  did not yet exist. Embodiments of the current invention support the creation and population of such a table via a change enabler . For instance, in an implementation utilizing relational databases, the change enabler  facilitates the creation of a relational table within a database, and the creation of records containing data within the relational table.","A database trigger may be set up to detect changes to records within the demographic table. Upon detecting a change to a particular record, the trigger may be configured to capture the data values from the demographic table and populate the weight_history table. For instance, consider the data from the demographic table  and the weight_history table . Each time a patient's weight is updated in the demographic table, a database trigger could create a new record in the weight_history table  and populate the PID column , historical_weight column  and historical_date column  with the patient's identification number, existing value for weight and date, respectively, which is extracted from the demographic table.","Referring now to , which is an exemplary GUI screen utilized for defining a change enabler for a particular logical field. A drop down box  allows the user to select the logical field for which a change enabler is being defined. A label (not editable)  that lists the physical data structure being referenced by the logical field based on the standard mapping is provided for reference.","A drop-down box  is provided to allow the user to select the type of change enabler to be implemented. In relational database environments, for example, the types of change enablers may include database triggers, stored procedures or a variety of other program modules configured to facilitate mappings in accordance to conditional modifiers defined for logical fields.","A free-form text box  is also provided to allow the user to input instructions related to the configuration and functionality provided by the change enabler. Specifically, the instructions may be provided in syntax that is translatable by the DAM  and may be directed to creating, configuring or managing the change enabler . Once satisfied with the change enabler configuration, the continue button  can be selected to proceed with processing. If the user desires to leave the current screen without saving any changes, the cancel button  can be selected.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIGS. 12 and 13","FIG. 12"],"b":["1201","150"]},"As the abstract query is being entered in box , it is parsed and analyzed by referencing the DAM . In some cases, users may have previous knowledge of conditional modifiers that are available for a particular field and may enter the conditional modifiers as they are crafting the query. In other cases, users may not be aware of all available conditional modifiers for a given logical field. In these cases, users may be provided with a drop down box  containing a list of available conditional modifiers that can be included in the conditional portion of the abstract query. In other words, the system alerts users that certain conditional modifiers (associated with a logical field in the conditional) are available for use with the current query. The user is allowed to pick one of the available conditional modifiers to be included in the abstract query. In other embodiments, users may be alerted regarding available logical modifiers for a particular logical field via other graphical means, such as highlighting the logical field within box  or displaying the logical field as a link that, when selected, presents a separate window that allows the selection of an available conditional modifier.","It should be noted that \u201cavailable\u201d conditional modifiers are those that have been configured for the particular logical field. Once the user selects the desired available conditional modifier, the continue button  can be selected to continue processing and present the GUI screen illustrated in .","Next, the updated version of the abstract query , including the user selected conditional modifier (i.e., HAS BEEN), is presented to the user in a confirmation screen as illustrated in . If the user is satisfied with the query, the submit button  can be selected to submit the abstract query for translation into a physical query. The physical query, in turn, is then submitted to a database management system for processing.","Many of the example queries described above present fields and records from two tables within a single database. However, those skilled in the art will recognize the methods described herein may be used with transactions affecting records from multiple tables which may be located in various databases in a distributed database environment.","While the conditions in the exemplary abstract queries above contain only one logical field, it should be understood that embodiments of the current invention can contain several logical fields in the conditional portion of the abstract query. Further, while the examples above are based on logical fields configured with conditional modifiers directed to referencing historical data, those skilled in the art will recognize that there are a variety of uses for conditional modifiers. In short, conditional modifiers can be implemented to facilitate the use of multiple mappings for any logical field.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the present invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention are attained and can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to the embodiments thereof which are illustrated in the appended drawings.","It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 9-10"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 12-13"}]},"DETDESC":[{},{}]}
